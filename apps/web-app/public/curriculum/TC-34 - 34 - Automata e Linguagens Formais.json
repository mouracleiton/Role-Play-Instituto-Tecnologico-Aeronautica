{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T22:36:12.265Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - TC-34",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 372
    },
    "areas": [
      {
        "id": "10",
        "name": "Ciência da Computação",
        "description": "Área dedicada aos fundamentos teóricos da computação, incluindo autômatos, linguagens formais e teoria da complexidade.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Automata e Linguagens Formais",
            "description": "Autômatos finitos e expressões regulares. Propriedades dos conjuntos regulares. Linguagens e gramáticas. Linguagens livres de contexto, sensíveis ao contexto e tipo-0. Fundamentos de análise sintática (parsing). Autômato de pilha. Máquinas de Turing: seus modelos restritos e tese de Church. Indecidabilidade e problemas intratáveis. A classe de problemas NP. Bibliografia: HOPCROFT, J. E.; ULLMAN, J. D. Introduction to automata theory, languages, and computation. New York: Addison-Wesley, 1979. SUDKAMP, T. Languages and machines: an introduction to the theory of computer science. 2. ed. Reading, MA: Addison-Wesley, 1997. SIPSER, M. Introduction to the theory of computation. 2. ed. Boston: Thomson Course Technology, 2006.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Expressões Regulares e Conjuntos Regulares",
                "description": "Estudo de expressões regulares e propriedades dos conjuntos regulares, incluindo autômatos finitos.",
                "totalSkills": 42,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Definição de Expressões Regulares",
                    "description": "Definição formal, operações básicas (união, concatenação, estrela de Kleene) e exemplos de expressões regulares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Definição Formal de Expressões Regulares",
                        "description": "Apresenta a definição recursiva formal de expressões regulares sobre um alfabeto Σ, incluindo os casos base (∅, ε e símbolos do alfabeto) e as regras de construção.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Identificar os casos base de expressões regulares",
                            "description": "Reconhecer e listar os elementos básicos de uma expressão regular: o conjunto vazio ∅, a cadeia vazia ε e cada símbolo individual do alfabeto Σ, explicando seu significado como linguagens singleton ou vazia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de casos base em expressões regulares",
                                  "subSteps": [
                                    "Revise a definição formal de expressões regulares como a menor classe fechada sob união, concatenação e estrela de Kleene.",
                                    "Identifique que os casos base são os elementos fundamentais que geram todas as expressões regulares.",
                                    "Liste os três casos base principais: conjunto vazio ∅, cadeia vazia ε e símbolos individuais de Σ.",
                                    "Explique por que esses são 'base': eles não dependem de operações e definem linguagens atômicas.",
                                    "Crie um diagrama simples mostrando a hierarquia: bases → operações."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando os casos base e seus papéis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Teoria da Computação (cap. Expressões Regulares), papel e caneta para diagrama.",
                                  "tips": "Use analogia com números primos: bases são 'primos' das expressões regulares.",
                                  "learningObjective": "Entender o papel fundacional dos casos base na definição recursiva de expressões regulares.",
                                  "commonMistakes": "Confundir casos base com operações; lembrar que bases são puramente primitivas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o conjunto vazio ∅ como caso base",
                                  "subSteps": [
                                    "Defina ∅ como a expressão regular que gera a linguagem vazia L(∅) = {} (nenhuma string).",
                                    "Compare com linguagens não-vazias para destacar a diferença.",
                                    "Escreva exemplos: ∅ não aceita ε ou qualquer string de Σ*.",
                                    "Discuta uso em construções: ∅ ∪ r = r, mas ∅* = {ε}.",
                                    "Pratique convertendo ∅ para autômato: estado inicial sem transições finais."
                                  ],
                                  "verification": "Construa um exemplo onde ∅ é usado em uma expressão maior e prove que não adiciona strings.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto para escrever expressões, calculadora de linguagens regulares online.",
                                  "tips": "Pense em ∅ como 'nada': útil para exclusões lógicas.",
                                  "learningObjective": "Reconhecer ∅ como gerador da linguagem vazia e suas propriedades algébricas.",
                                  "commonMistakes": "Confundir ∅ com ε; ∅ é vazio, ε contém a string vazia."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a cadeia vazia ε como caso base",
                                  "subSteps": [
                                    "Defina ε como a expressão que gera L(ε) = {ε}, a linguagem singleton com a string vazia.",
                                    "Diferencie de ∅: ε aceita apenas a string de comprimento zero.",
                                    "Exemplos: ε* = {ε}, ε ∪ a = {ε, a} para a em Σ.",
                                    "Construa autômato para ε: estado inicial = final com loop ε.",
                                    "Pratique em expressões: rε = r (concatenação neutra)."
                                  ],
                                  "verification": "Liste 3 propriedades algébricas de ε e demonstre com exemplos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Ferramenta de desenho de autômatos (ex: JFLAP), notas de aula.",
                                  "tips": "Visualize ε como 'string invisível' de zero caracteres.",
                                  "learningObjective": "Identificar ε como singleton {ε} e seu papel como identidade na concatenação.",
                                  "commonMistakes": "Achar que ε gera todas as strings vazias múltiplas; é apenas uma."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar símbolos individuais do alfabeto Σ",
                                  "subSteps": [
                                    "Defina cada a ∈ Σ como expressão base gerando L(a) = {a}, singleton com string de um símbolo.",
                                    "Para Σ = {0,1}, liste: '0' gera {'0'}, '1' gera {'1'}.",
                                    "Discuta generalidade: qualquer símbolo único é base.",
                                    "Exemplos compostos: ab gera {ab}, mas a e b são bases.",
                                    "Converta para NFA: transição única de inicial para final via a."
                                  ],
                                  "verification": "Dado Σ = {a,b,c}, escreva as 3 expressões base e suas linguagens.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Alfabeto exemplo escrito, simulador NFA online.",
                                  "tips": "Lembre: símbolos são 'blocos de construção' atômicos de strings.",
                                  "learningObjective": "Reconhecer símbolos de Σ como singletons e base para concatenações.",
                                  "commonMistakes": "Confundir com variáveis; símbolos são literais fixos de Σ."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e explicar linguagens dos casos base",
                                  "subSteps": [
                                    "Resuma: ∅ → {}, ε → {ε}, a → {a} para cada a ∈ Σ.",
                                    "Crie tabela comparativa: linguagem, tamanho, exemplos de strings.",
                                    "Discuta recursão: bases + ops → todas regex.",
                                    "Pratique identificação: em r = ∅ ∪ ε ∪ a ∪ ..., marque bases.",
                                    "Avalie: explique como bases definem linguagens regulares mínimas."
                                  ],
                                  "verification": "Crie um quiz auto-aplicado com 5 perguntas sobre identificação de bases.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha para tabela, flashcards de conceitos.",
                                  "tips": "Use mnemônico: 'Zero (∅), Empty-string (ε), Singles (Σ)'.",
                                  "learningObjective": "Listar e explicar todos os casos base como linguagens singleton ou vazia.",
                                  "commonMistakes": "Esquecer que Σ inclui todos os símbolos, não apenas exemplos."
                                }
                              ],
                              "practicalExample": "Dada a regex r = ∅ ∪ ε ∪ a ∪ (b ∪ c)*, identifique os casos base: ∅ (vazia), ε (singleton ε), a (singleton 'a'). Explique: L(r) inclui {}, {ε}, {'a'} mais strings de b e c; prove listando strings geradas manualmente.",
                              "finalVerifications": [
                                "Liste corretamente os 3 tipos de casos base com suas linguagens exatas.",
                                "Diferencie ∅ de ε com contraexemplos de strings aceitas/rejeitadas.",
                                "Para Σ={0,1}, escreva todas as bases e prove L('0') = {'0'}.",
                                "Construa NFA para cada base e verifique aceitação.",
                                "Explique recursão: como bases + união/concat/* geram regex complexas.",
                                "Identifique bases em uma regex dada sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: 100% correto para ∅, ε, Σ.",
                                "Diferenciação clara: sem confusão entre vazia e singleton.",
                                "Exemplos concretos: pelo menos 2 por base com linguagens.",
                                "Uso de formalismo: notação L(r) usada consistentemente.",
                                "Compreensão recursiva: explica como bases se expandem.",
                                "Aplicação prática: identifica bases em regex real corretamente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (linguagens como subconjuntos de Σ*).",
                                "Lógica: Elementos primitivos semelhantes a átomos em lógica proposicional.",
                                "Programação: Regex em Python (re.compile('')) para testar ε.",
                                "Linguística: Símbolos como fonemas básicos em gramáticas formais."
                              ],
                              "realWorldApplication": "Em validação de formulários web, use ∅ para campos obrigatórios vazios inválidos, ε para strings vazias permitidas, e símbolos de Σ para checar caracteres específicos como e-mails (@ como base em Σ)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Compreender a definição recursiva",
                            "description": "Explicar a estrutura recursiva da definição formal, onde uma expressão regular R é construída aplicando operações sobre expressões regulares menores, garantindo que toda expressão válida siga as regras indutivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os casos base da definição recursiva",
                                  "subSteps": [
                                    "Ler a definição formal de expressões regulares, focando nos casos base.",
                                    "Listar os três casos base: o conjunto vazio ∅, a expressão vazia ε e os símbolos individuais do alfabeto Σ.",
                                    "Explicar o significado de cada caso base: ∅ gera o conjunto vazio, ε gera {λ} e símbolos geram singletons.",
                                    "Desenhar um diagrama simples mostrando esses casos como folhas da recursão.",
                                    "Praticar identificando casos base em exemplos simples como 'a' ou 'ε'."
                                  ],
                                  "verification": "Capacidade de listar e explicar corretamente os três casos base sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Definição formal impressa ou digital",
                                    "Papel e caneta para diagramas",
                                    "Exemplos de expressões básicas"
                                  ],
                                  "tips": "Lembre-se: casos base são os 'átomos' que não dependem de outras expressões.",
                                  "learningObjective": "Reconhecer e descrever os elementos fundamentais que iniciam a construção recursiva.",
                                  "commonMistakes": [
                                    "Confundir ε com ∅",
                                    "Esquecer símbolos do alfabeto como base"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender as regras de indução (operações recursivas)",
                                  "subSteps": [
                                    "Estudar as três regras indutivas: união (R1 ∪ R2), concatenação (R1 · R2) e estrela de Kleene (R* ) onde R1 e R2 são expressões regulares menores.",
                                    "Explicar como cada operação constrói uma nova expressão a partir de expressões válidas existentes.",
                                    "Escrever formalmente: se R1 e R2 são regulares, então R1 ∪ R2, R1 · R2 e R1* também são.",
                                    "Criar uma tabela comparando as operações com exemplos numéricos simples.",
                                    "Discutir a ordem de aplicação das operações na construção."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito como uma operação indutiva expande uma expressão base.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha com regras indutivas",
                                    "Exemplos de operações",
                                    "Calculadora simbólica opcional"
                                  ],
                                  "tips": "Pense nas regras como 'blocos de construção' que empilham recursivamente.",
                                  "learningObjective": "Dominar as operações que permitem a construção hierárquica de expressões complexas.",
                                  "commonMistakes": [
                                    "Ignorar parênteses na precedência",
                                    "Achar que operações criam linguagens irregulares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a estrutura recursiva de uma expressão",
                                  "subSteps": [
                                    "Escolher uma expressão simples como (a ∪ b)* e decompor recursivamente.",
                                    "Identificar o caso base mais interno e subir camada por camada.",
                                    "Mapear a árvore de recursão: raiz é *, filhos são (a ∪ b), netos a e b.",
                                    "Rastrear como a linguagem é gerada em cada nível.",
                                    "Repetir com uma expressão mais complexa como (a · (b ∪ ε))*."
                                  ],
                                  "verification": "Desenhar corretamente a árvore recursiva de uma expressão dada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para árvores de análise",
                                    "Exemplos de expressões progressivas",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": "Comece do centro e expanda para fora, como desmontar uma cebola.",
                                  "learningObjective": "Aplicar a definição recursiva para desconstruir expressões em componentes menores.",
                                  "commonMistakes": [
                                    "Parar na superfície sem ir aos bases",
                                    "Confundir união com concatenação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar expressões regulares pela definição recursiva",
                                  "subSteps": [
                                    "Pegar uma expressão duvidosa como a ∪ (b* · c) e verificar passo a passo.",
                                    "Confirmar que cada subexpressão segue as regras indutivas até os bases.",
                                    "Identificar expressões inválidas, como 'ab*' sem parênteses necessários.",
                                    "Praticar com 3-5 expressões variadas, justificando validade ou invalidez.",
                                    "Documentar o raciocínio em um relatório curto."
                                  ],
                                  "verification": "Validar corretamente 4 de 5 expressões testadas com justificativa recursiva.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de expressões para validação",
                                    "Folha de respostas",
                                    "Referência da definição formal"
                                  ],
                                  "tips": "Se não chega aos casos base, é inválida!",
                                  "learningObjective": "Usar a recursão para julgar a correção formal de expressões regulares.",
                                  "commonMistakes": [
                                    "Aceitar sintaxe informal sem recursão estrita",
                                    "Esquecer precedência de operadores"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a expressão (a ∪ b)*. Desconstrução: 1. 'a' e 'b' são bases (símbolos). 2. 'a ∪ b' é união de bases. 3. '(a ∪ b)*' é estrela de Kleene de uma regular. Assim, válida e gera todas strings de a's e b's.",
                              "finalVerifications": [
                                "Explicar os casos base sem hesitação.",
                                "Descrever as três regras indutivas com exemplos.",
                                "Desenhar árvore recursiva de uma expressão complexa.",
                                "Validar ou invalidar expressões com justificativa.",
                                "Diferenciar definição recursiva de sintaxe informal.",
                                "Reconhecer padrões recursivos em expressões reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de bases e operações (80% corretas).",
                                "Profundidade da análise recursiva (árvores completas).",
                                "Capacidade de justificar validações formalmente.",
                                "Clareza na explicação oral ou escrita.",
                                "Criatividade em exemplos práticos.",
                                "Ausência de confusões comuns como precedência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da Indução Matemática.",
                                "Programação: Funções Recursivas e Árvores de Parsing.",
                                "Lógica: Definições Indutivas em Teoria dos Conjuntos.",
                                "Linguística: Gramáticas Gerativas Recursivas."
                              ],
                              "realWorldApplication": "Em compiladores (parsers regex como em grep ou JavaScript), validação de padrões em editores de texto e análise de logs em sistemas de segurança cibernética, garantindo que padrões sejam formalmente corretos antes da compilação para autômatos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Validar uma expressão regular",
                            "description": "Analisar uma dada string e determinar se ela é uma expressão regular válida de acordo com a definição formal, identificando violações nas regras de recursão ou casos base.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal de Expressões Regulares",
                                  "subSteps": [
                                    "Estude os casos base: ∅ (conjunto vazio), ε (string vazia) e a (qualquer símbolo único do alfabeto).",
                                    "Memorize as regras recursivas: (R1 + R2), (R1 · R2) e (R1*) onde R1 e R2 são expressões regulares válidas.",
                                    "Note que parênteses são obrigatórios para todas as operações e que operadores precedem ou seguem subexpressões adequadamente.",
                                    "Liste 3 exemplos válidos de casos base e 2 de construções recursivas simples.",
                                    "Identifique símbolos proibidos ou mal posicionados, como operadores soltos."
                                  ],
                                  "verification": "Escreva um resumo da definição com exemplos corretos e explique uma regra recursiva em suas próprias palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha com definição formal de expressões regulares",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use indução para pensar: valide o menor primeiro, depois construa para cima.",
                                  "learningObjective": "Dominar os elementos exatos que definem uma expressão regular válida.",
                                  "commonMistakes": [
                                    "Assumir sintaxe de regex prática (ex: sem parênteses obrigatórios)",
                                    "Confundir · com concatenação implícita sem parens",
                                    "Ignorar que ∅ e ε são casos base explícitos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Tokenizar a String de Entrada",
                                  "subSteps": [
                                    "Remova espaços em branco se houver e identifique todos os tokens: símbolos (a,b,...), ∅, ε, (, ), +, ·, *.",
                                    "Quebre a string em uma lista sequencial de tokens, tratando parênteses como delimitadores.",
                                    "Conte o número de parênteses de abertura e fechamento para um cheque inicial de balanceamento.",
                                    "Marque posições de operadores (+, ·, *) e verifique se estão sempre entre parênteses.",
                                    "Crie uma representação em árvore preliminar ou lista anotada dos tokens."
                                  ],
                                  "verification": "Produza uma lista de tokens numerados e confirme que nenhum token inválido existe (ex: caractere desconhecido).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "String de exemplo escrita",
                                    "Editor de texto ou papel quadriculado"
                                  ],
                                  "tips": "Trate a string como uma sequência linear primeiro; visualize com setas entre tokens.",
                                  "learningObjective": "Decompor a entrada em unidades atômicas para análise estrutural.",
                                  "commonMistakes": [
                                    "Ignorar escapes ou símbolos compostos",
                                    "Contar parênteses incorretamente em strings aninhadas",
                                    "Permitir operadores adjacentes sem subexpressões"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Balanceamento e Estrutura de Parênteses",
                                  "subSteps": [
                                    "Use uma pilha para checar balanceamento: empilhe '(' e desempilhe em ')'; falha se pilha vazia ou sobra.",
                                    "Identifique subexpressões entre cada par de parênteses correspondentes.",
                                    "Confirme que cada operador (+, ·, *) está imediatamente precedido por '(' e seguido por subexpressões válidas.",
                                    "Rejeite se houver parênteses vazios ou operadores no nível raiz sem envoltório.",
                                    "Anote profundidade máxima de aninhamento para guiar recursão."
                                  ],
                                  "verification": "Desenhe a árvore de parênteses e confirme que todos pares matcham perfeitamente sem sobras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para pilha simulada",
                                    "Ferramenta online de balanceamento de parênteses (opcional)"
                                  ],
                                  "tips": "Simule com dedo na tela: aponte para cada '(' e encontre o matching ')' caminhando.",
                                  "learningObjective": "Garantir integridade estrutural antes da validação semântica.",
                                  "commonMistakes": [
                                    "Balancear incorretamente em aninhamentos cruzados",
                                    "Permitir (R1 + sem R2)",
                                    "Confundir * como unário sem parens em volta de subexpr"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Recursivamente e Identificar Violações",
                                  "subSteps": [
                                    "Para cada subexpressão entre parênteses, aplique recursivamente: cheque se é caso base ou segue exatamente uma regra recursiva.",
                                    "Para + ou ·, confirme exatamente duas subexpressões válidas recursivamente.",
                                    "Para *, confirme exatamente uma subexpressão válida dentro.",
                                    "No nível raiz, rejeite se não for uma única expressão envolta ou caso base simples.",
                                    "Registre violações específicas: ex. 'Operador + sem segunda subexpr' ou 'Símbolo inválido em posição X'."
                                  ],
                                  "verification": "Classifique a string como válida/inválida e liste todas as violações encontradas com referências a posições.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Árvore de tokens do step 2",
                                    "Checklist de regras recursivas"
                                  ],
                                  "tips": "Comece das folhas (profundidade máxima) e suba; use indução bottom-up.",
                                  "learningObjective": "Aplicar definição por recursão para confirmação completa.",
                                  "commonMistakes": [
                                    "Aplicar recursão infinita ou pular subexpr inválidas",
                                    "Aceitar concatenação implícita",
                                    "Confundir ordem de operadores"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise a string '(a + (b · ε))*': Tokenize para ['(', 'a', '+', '(', 'b', '·', 'ε', ')', ')', '*']. Verifique balanceamento (ok), valide recursivamente: inner (b · ε) ok (casos base com ·), outer (a + isso) ok, então * ok. Válida. Contraexemplo inválido: 'a + b' (sem parens: rejeitar por operador solto).",
                              "finalVerifications": [
                                "Todos os parênteses estão perfeitamente balanceados sem sobras ou faltas.",
                                "Cada operador tem o número exato de subexpressões requeridas (2 para +, ·; 1 para *).",
                                "Todas as folhas são casos base válidos (∅, ε ou símbolo).",
                                "Nenhum token inválido ou mal posicionado existe.",
                                "A estrutura inteira parseia como uma única expressão raiz válida.",
                                "Violação específica é identificada e localizada para inválidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de casos base (100% correto).",
                                "Correção no balanceamento e contagem de parênteses.",
                                "Aplicação fiel das regras recursivas sem exceções inventadas.",
                                "Relato claro de violações com evidências posicionais.",
                                "Eficiência no processo (sem passos redundantes).",
                                "Capacidade de lidar com aninhamentos profundos (até 3 níveis)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Reconhecimento de linguagens regulares via gramáticas.",
                                "Compiladores: Fase de parsing e análise sintática.",
                                "Lógica Matemática: Provas por indução estrutural.",
                                "Programação: Implementação de parsers recursivos em linguagens como Python.",
                                "Autômatos: Construção de AFNs a partir de regex válidas."
                              ],
                              "realWorldApplication": "Desenvolver validadores de sintaxe em editores de código (ex: VS Code extensions para regex), ferramentas de linting em compiladores, ou processadores de padrões em buscas como grep/regex engines, garantindo que padrões inseridos sejam sintaticamente corretos antes da compilação para NFA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Operações Básicas em Expressões Regulares",
                        "description": "Descreve as três operações fundamentais: união (R|S), concatenação (RS) e estrela de Kleene (R*), incluindo sua semântica como linguagens e notação.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Aplicar a operação de união",
                            "description": "Construir a expressão regular para a união de duas linguagens regulares representadas por R e S, entendendo que L(R|S) = L(R) ∪ L(S), e fornecer exemplos como (a|b) para cadeias com 'a' ou 'b'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de união de linguagens regulares",
                                  "subSteps": [
                                    "Defina linguagem regular como o conjunto de cadeias aceitas por uma ER.",
                                    "Explique que a união L(R) ∪ L(S) é o conjunto de todas as cadeias em L(R) ou L(S).",
                                    "Identifique que a ER R|S representa essa união: L(R|S) = L(R) ∪ L(S).",
                                    "Diferencie união de outras operações como concatenação (RS)."
                                  ],
                                  "verification": "Escreva uma definição clara da união e dê um exemplo verbal como 'cadeias com a ou b'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas de aula sobre expressões regulares"
                                  ],
                                  "tips": "Pense na união como um 'OU lógico' entre as linguagens.",
                                  "learningObjective": "Entender conceitualmente que a união combina duas linguagens sem sobreposição obrigatória.",
                                  "commonMistakes": "Confundir união com interseção (que não é básica em ERs) ou concatenação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a sintaxe da operação de união (|)",
                                  "subSteps": [
                                    "Memorize o símbolo | como operador de união/alternativa.",
                                    "Aprenda precedência: use parênteses para agrupar, ex: (a|b)c.",
                                    "Estude exemplos simples: a|b aceita 'a' ou 'b'.",
                                    "Pratique escrita manual de 3 expressões básicas com |.",
                                    "Identifique quando usar parênteses para evitar ambiguidades."
                                  ],
                                  "verification": "Escreva corretamente 3 ERs simples usando | sem erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Ferramenta online como regex101.com"
                                  ],
                                  "tips": "Sempre teste precedência: | tem menor precedência que concatenação.",
                                  "learningObjective": "Dominar a sintaxe exata do operador | e seu uso com parênteses.",
                                  "commonMistakes": "Esquecer parênteses em expressões complexas, levando a interpretações erradas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir expressões regulares para união de linguagens",
                                  "subSteps": [
                                    "Dado R = a* e S = b, construa R|S = (a*|b).",
                                    "Para linguagens mais complexas, como R = ab e S = cd, crie (ab|cd).",
                                    "Combine com outros operadores: (a|b)* para zero ou mais de a ou b.",
                                    "Crie uma ER para aceitar 'gato' ou 'cachorro': (gato|cachorro).",
                                    "Generalize: identifique R e S no problema e aplique |."
                                  ],
                                  "verification": "Construa e anote 4 ERs corretas para uniões dadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "regex101.com ou similar",
                                    "Papel para rascunhos"
                                  ],
                                  "tips": "Comece identificando as linguagens individuais antes de unir.",
                                  "learningObjective": "Aplicar a operação de união para construir ERs acionáveis.",
                                  "commonMistakes": "Não usar parênteses ao unir subexpressões complexas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar expressões de união",
                                  "subSteps": [
                                    "Use uma ferramenta online para testar cadeias contra a ER.",
                                    "Verifique aceitação: teste cadeias de L(R), L(S) e fora da união.",
                                    "Analise falhas: ajuste parênteses ou sintaxe se necessário.",
                                    "Compare L(R|S) com união manual de exemplos de L(R) e L(S).",
                                    "Documente 2 testes bem-sucedidos e 1 erro corrigido."
                                  ],
                                  "verification": "Execute testes em ferramenta e confirme matches corretos para 5 cadeias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "regex101.com (modo ER)",
                                    "Lista de cadeias de teste"
                                  ],
                                  "tips": "Teste bordas: ε (vazio), cadeias longas e inválidas.",
                                  "learningObjective": "Validar ERs de união empiricamente para garantir correção.",
                                  "commonMistakes": "Ignorar escape de caracteres especiais como | em contextos literais."
                                }
                              ],
                              "practicalExample": "Construa a ER para aceitar senhas que começam com 'abc' ou 'xyz': (^abc|xyz). Teste com 'abc123' (aceita), 'xyz456' (aceita), 'def789' (rejeita).",
                              "finalVerifications": [
                                "Explicar verbalmente L(R|S) = L(R) ∪ L(S) com exemplo.",
                                "Construir ER correta para união de duas linguagens dadas.",
                                "Identificar e corrigir erro em ER com | mal agrupado.",
                                "Testar ER em ferramenta e listar 3 matches/3 non-matches.",
                                "Diferenciar união de concatenação em 2 exemplos."
                              ],
                              "assessmentCriteria": [
                                "Correção conceitual da união (100% precisão na definição).",
                                "Sintaxe impecável nas ERs construídas (uso correto de | e parênteses).",
                                "Profundidade nos testes (cobertura de casos positivos/negativos).",
                                "Criatividade em exemplos práticos e generalizações.",
                                "Clareza na documentação de passos e verificações.",
                                "Tempo de execução dentro dos estimados com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Conjuntos: União de conjuntos A ∪ B.",
                                "Lógica Proposicional: Operador OU (disjunção).",
                                "Programação: Operadores lógicos || em if/condicionais.",
                                "Matemática Discreta: Operações em linguagens formais."
                              ],
                              "realWorldApplication": "Em desenvolvimento web para validação de formulários (ex: campo que aceita CPF ou CNPJ via (cpf_pattern|cnpj_pattern)); busca avançada em editores como VS Code ou grep com | para padrões alternativos; análise de logs em DevOps para filtrar erros de tipo A ou B."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Aplicar a operação de concatenação",
                            "description": "Formar a expressão regular RS, onde L(RS) = {xy | x ∈ L(R), y ∈ L(S)}, ilustrando com exemplos como ab para cadeias 'a' seguidas de 'b'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal da concatenação",
                                  "subSteps": [
                                    "Leia a definição: L(RS) = {xy | x ∈ L(R), y ∈ L(S)}",
                                    "Identifique que concatenação forma sequências obrigatórias de símbolos de R seguidos de S",
                                    "Compare com outras operações como união e estrelamento",
                                    "Anote exemplos iniciais como R = a, S = b → ab",
                                    "Explique em suas palavras o que significa 'linguagem gerada'"
                                  ],
                                  "verification": "Escreva a definição e um exemplo simples corretamente",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre expressões regulares",
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Papel e caneta"
                                  ],
                                  "tips": [
                                    "Visualize como 'colar' uma string após outra",
                                    "Use diagramas de transição para automata equivalentes"
                                  ],
                                  "learningObjective": "Dominar a definição formal e intuitiva da concatenação em linguagens regulares",
                                  "commonMistakes": [
                                    "Confundir com união (que permite escolha)",
                                    "Ignorar que x e y podem ser vazios apenas se suportado por R/S"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer e gerar exemplos simples de concatenação",
                                  "subSteps": [
                                    "Escolha expressões básicas: R = a*, S = b",
                                    "Gere L(RS): todas cadeias terminando em b após a's",
                                    "Liste 5 cadeias em L(RS): εb, ab, aab, etc.",
                                    "Desenhe o autômato equivalente para RS",
                                    "Teste com cadeias inválidas para confirmar"
                                  ],
                                  "verification": "Liste corretamente pelo menos 5 cadeias válidas e 2 inválidas",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online de regex tester (regex101.com)",
                                    "Simulador de autômatos (JFLAP)",
                                    "Folha de exercícios"
                                  ],
                                  "tips": [
                                    "Comece com expressões vazias ou unitárias para simplicidade",
                                    "Conte os símbolos em cada cadeia gerada"
                                  ],
                                  "learningObjective": "Aplicar concatenação em expressões simples e listar linguagens resultantes",
                                  "commonMistakes": [
                                    "Incluir cadeias com b antes de a",
                                    "Esquecer cadeias vazias se permitidas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir expressões concatenadas complexas",
                                  "subSteps": [
                                    "Combine múltiplas: (a|b)* . c . (d|e)",
                                    "Escreva a regex resultante: (a|b)*c(d|e)",
                                    "Gere exemplos concretos: ac d, bc e, aaac d",
                                    "Construa o autômato concatenado passo a passo",
                                    "Valide com strings de teste"
                                  ],
                                  "verification": "Construa uma regex concatenada e valide 3 strings",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto com regex support (VS Code)",
                                    "Papel para diagramas de NFA",
                                    "Exemplos de aula"
                                  ],
                                  "tips": [
                                    "Priorize parênteses para clareza",
                                    "Pense em NFA: estados finais de R vão para início de S"
                                  ],
                                  "learningObjective": "Criar expressões regulares compostas por concatenação",
                                  "commonMistakes": [
                                    "Omitir parênteses em subexpressões",
                                    "Confundir ordem de concatenação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e testar concatenações em contextos práticos",
                                  "subSteps": [
                                    "Crie um exercício: dada R e S, encontre L(RS)",
                                    "Use ferramenta para matchar strings contra RS",
                                    "Compare L(RS) com L(R) + L(S) ou L(R|S)",
                                    "Analise propriedades: RS é regular se R e S forem",
                                    "Documente um caso de erro comum e correção"
                                  ],
                                  "verification": "Teste bem-sucedido de uma regex concatenada em 5 strings",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Regex101 ou RegexBuddy",
                                    "Lista de strings de teste",
                                    "Documentação de regex engines"
                                  ],
                                  "tips": [
                                    "Sempre teste bordas: vazia, mínima, longa",
                                    "Use flags como /g para múltiplos matches"
                                  ],
                                  "learningObjective": "Validar e depurar expressões regulares com concatenação",
                                  "commonMistakes": [
                                    "Não testar strings vazias",
                                    "Ignorar diferenças entre engines de regex"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada R = a (L(R) = {'a'}) e S = b* (L(S) = {ε, b, bb, ...}), então RS = a b* gera cadeias como 'a', 'ab', 'abb', representando 'a' seguida de zero ou mais 'b's, útil para padrões como identificadores iniciando com 'a'.",
                              "finalVerifications": [
                                "Defina corretamente L(RS) com notação formal",
                                "Gere pelo menos 5 cadeias válidas para um RS dado",
                                "Construa o autômato NFA para uma concatenação simples",
                                "Diferencie concatenação de união e estrelamento com exemplos",
                                "Valide uma regex concatenada em ferramenta online",
                                "Explique por que RS preserva regularidade"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% correto)",
                                "Diversidade e correção dos exemplos gerados",
                                "Clareza na construção de regex compostas",
                                "Profundidade na verificação e testes",
                                "Identificação correta de erros comuns",
                                "Conexão com autômatos ou linguagens"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Similar ao produto cartesiano de conjuntos",
                                "Programação: Concatenação de strings em linguagens como Python (str1 + str2)",
                                "Linguística: Composição sequencial de morfemas em palavras",
                                "Engenharia de Software: Padrões em parsing de logs ou validação de inputs"
                              ],
                              "realWorldApplication": "Em ferramentas como grep ou editores de texto (VS Code, Notepad++), concatenação permite matching sequencial, ex: validar emails com '[a-z]+@[a-z]+\\.[a-z]+' onde partes são concatenadas para usuário@domínio.extensão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Aplicar a estrela de Kleene",
                            "description": "Construir R* como zero ou mais concatenações de cadeias de L(R), com L(R*) = {w | w = w1...wk, k≥0, cada wi ∈ L(R)}, exemplificando com a* para zero ou mais 'a's.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Básico da Estrela de Kleene",
                                  "subSteps": [
                                    "Revise a definição de uma expressão regular R e sua linguagem L(R).",
                                    "Explique que a estrela de Kleene (R*) representa zero ou mais repetições de strings em L(R).",
                                    "Identifique que ε (string vazia) sempre pertence a L(R*).",
                                    "Diferencie de outros operadores como + (uma ou mais).",
                                    "Discuta concatenação: w = w1 w2 ... wk onde cada wi ∈ L(R)."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e inclua ε como exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre expressões regulares",
                                    "Quadro branco ou papel"
                                  ],
                                  "tips": "Use diagramas para visualizar repetições infinitas.",
                                  "learningObjective": "Compreender intuitivamente o que R* representa.",
                                  "commonMistakes": [
                                    "Confundir R* com R+ (excluir ε)",
                                    "Pensar que R* requer pelo menos uma ocorrência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente L(R*)",
                                  "subSteps": [
                                    "Escreva a definição formal: L(R*) = {w | w = w1...wk, k ≥ 0, cada wi ∈ L(R)}.",
                                    "Prove que ε ∈ L(R*) (caso k=0).",
                                    "Mostre que L(R) ⊆ L(R*) (caso k=1).",
                                    "Demonstre fechamento sob concatenação: se u,v ∈ L(R*), então uv ∈ L(R*).",
                                    "Verifique inductivamente para k ≥ 2."
                                  ],
                                  "verification": "Construa uma prova curta por indução para um R simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de teoria da computação (cap. expressões regulares)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use indução em k: base (k=0,1), passo (assuma para k, prove k+1).",
                                  "learningObjective": "Dominar a definição matemática precisa de R*.",
                                  "commonMistakes": [
                                    "Esquecer o caso k=0 (ε)",
                                    "Confundir com união em vez de concatenação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Exemplos Simples",
                                  "subSteps": [
                                    "Exemplo 1: R = 'a', construa L(a*) = {ε, a, aa, aaa, ...}.",
                                    "Exemplo 2: R = 'ab', liste strings em L((ab)*): ε, ab, abab, etc.",
                                    "Gere 5 strings aleatórias e classifique se pertencem a L(R*).",
                                    "Desenhe um AFD/NFA para R* usando construção padrão.",
                                    "Teste strings inválidas para confirmar exclusão."
                                  ],
                                  "verification": "Liste 10 strings corretas/incorretas e justifique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online como JFLAP para NFA",
                                    "Papel para listar strings"
                                  ],
                                  "tips": "Comece com alfabeto unitário para simplicidade.",
                                  "learningObjective": "Aplicar a definição em exemplos concretos.",
                                  "commonMistakes": [
                                    "Incluir strings com ordem errada",
                                    "Gerar loops infinitos sem cutoff"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Expressões Complexas e Verificar",
                                  "subSteps": [
                                    "Combine com outros operadores: ex. (a|b)* para qualquer string de a's e b's.",
                                    "Construa R* para R = (0|1) e verifique binários.",
                                    "Converta R* para NFA: adicione loop de volta ao estado inicial.",
                                    "Teste com strings reais: valide se \"aaa\" ∈ a*.",
                                    "Resolva exercício: prove L((a*)*) = L(a*)."
                                  ],
                                  "verification": "Crie um NFA para um R* dado e simule 3 strings.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Simulador de autômatos (JFLAP ou regex101)",
                                    "Exercícios de livro"
                                  ],
                                  "tips": "Visualize NFAs para entender loops.",
                                  "learningObjective": "Integrar estrela de Kleene em expressões regulares completas.",
                                  "commonMistakes": [
                                    "Erro na construção de NFA (esquecer ε-transições)",
                                    "Confundir * com quantificadores em regex modernas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para R = 'a', L(a*) inclui ε (vazia), 'a', 'aa', 'aaa'. Use para validar senhas com zero ou mais vogais 'a' em um padrão regex como ^[^a]*a*$ em Python: import re; re.match('^a*$', 'aaa') retorna match.",
                              "finalVerifications": [
                                "Defina corretamente L(R*) incluindo ε e concatenações.",
                                "Gere exemplos válidos e inválidos para a*.",
                                "Construa NFA equivalente para R*.",
                                "Prove L(R) ⊆ L(R*) e fechamento sob concatenação.",
                                "Aplique em regex complexa como (ab)*.",
                                "Diferencie R* de R+ e R?."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% dos elementos).",
                                "Corretude de exemplos (sem strings inválidas incluídas).",
                                "Qualidade da prova por indução.",
                                "Construção correta de NFA para R*.",
                                "Criatividade em aplicações reais.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (união, concatenação, fechamento).",
                                "Lógica: Indução matemática para provas.",
                                "Programação: Regex em linguagens como Python/Java.",
                                "Linguística: Modelagem de padrões linguísticos.",
                                "Engenharia de Software: Validação de inputs."
                              ],
                              "realWorldApplication": "Em programação, a* em regex valida campos com zero ou mais 'a'; em busca de texto (grep), padrões como [0-9]* encontra números opcionais; em compiladores, tokenização de repetições variáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.4",
                            "name": "Combinar operações básicas",
                            "description": "Usar união, concatenação e estrela de Kleene em conjunto para formar expressões mais complexas, como (a|b)* para todas as cadeias sobre {a,b}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar operações básicas e precedência",
                                  "subSteps": [
                                    "Liste as operações básicas: união (a|b), concatenação (ab), estrela de Kleene (a*)",
                                    "Estude a precedência: * > concatenação > união, use parênteses para agrupar",
                                    "Pratique escrevendo expressões simples com uma operação cada",
                                    "Identifique ambiguidades em expressões sem parênteses, como a|b*",
                                    "Construa árvore de parsing para a|b*c"
                                  ],
                                  "verification": "Escreva 5 expressões simples corretas com precedência explícita usando parênteses",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de precedência de expressões regulares (impressa ou online)"
                                  ],
                                  "tips": "Sempre use parênteses extras para evitar confusão na precedência",
                                  "learningObjective": "Compreender como as operações básicas interagem via precedência e agrupamento",
                                  "commonMistakes": [
                                    "Ignorar precedência, confundindo a|b* com (a|b)*",
                                    "Esquecer parênteses em uniões complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Combinar união e concatenação",
                                  "subSteps": [
                                    "Comece com união simples: (a|b)",
                                    "Adicione concatenação: (a|b)c ou a(b|c)",
                                    "Crie expressões para linguagens finitas: ab|cd",
                                    "Teste gerando strings aceitas: para (a|b)c, liste 'ac', 'bc'",
                                    "Construa expressão para {ab, cd, ef}"
                                  ],
                                  "verification": "Gere pelo menos 3 strings para cada uma de 3 expressões combinadas e confirme validade",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto simples",
                                    "Ferramenta online de teste de regex (ex: regex101.com)"
                                  ],
                                  "tips": "Pense em termos de 'escolha ou sequência' para guiar combinações",
                                  "learningObjective": "Formar expressões regulares usando união e concatenação para linguagens finitas",
                                  "commonMistakes": [
                                    "Concatenar incorretamente sem parênteses: ab|c vira a(b|c)",
                                    "Gerar strings inválidas por falta de teste"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar estrela de Kleene em combinações",
                                  "subSteps": [
                                    "Aplique * a expressões simples: (a|b)*",
                                    "Combine com concatenação: (a|b)*c",
                                    "Crie para linguagens infinitas: a*(b|a*)*",
                                    "Expanda o exemplo dado: explique por que (a|b)* gera todas as cadeias sobre {a,b}",
                                    "Teste com strings longas: verifique se aceita 'abab', rejeita strings vazias se necessário"
                                  ],
                                  "verification": "Construa e teste (a|b)* gerando 5 strings variadas e confirmando aceitação",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de regex tester",
                                    "Lista de strings de teste pré-definidas"
                                  ],
                                  "tips": "Lembre-se que * inclui a string vazia; use ε ou ajuste se necessário",
                                  "learningObjective": "Integrar Kleene star para gerar linguagens regulares infinitas complexas",
                                  "commonMistakes": [
                                    "Aplicar * sem parênteses: a|b* aceita 'aa' incorretamente",
                                    "Confundir com repetição finita"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e validar expressões complexas",
                                  "subSteps": [
                                    "Defina uma linguagem alvo, ex: todas as cadeias terminando em 'ab' sobre {a,b}",
                                    "Construa passo a passo: (a|b)*(ab)",
                                    "Compare com alternativas e otimize",
                                    "Valide contra 10 strings: 5 aceitas, 5 rejeitadas",
                                    "Documente o raciocínio de construção"
                                  ],
                                  "verification": "Crie uma expressão complexa para uma linguagem dada e valide com testes exaustivos",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel para rascunhos",
                                    "Simulador de autômatos ou regex101.com"
                                  ],
                                  "tips": "Decompose linguagens grandes em blocos menores antes de combinar",
                                  "learningObjective": "Sintetizar operações para expressar linguagens regulares arbitrárias",
                                  "commonMistakes": [
                                    "Expressões ambíguas que aceitam extras",
                                    "Falta de testes com strings rejeitadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa (a|b)* para gerar todas as cadeias finitas sobre alfabeto {a,b}, incluindo ε, a, b, aa, ab, ba, bb, etc. Teste em regex101.com com strings como 'abab' (aceita) e 'c' (rejeitada).",
                              "finalVerifications": [
                                "Gere corretamente strings de uma expressão combinada como (a|b)*a",
                                "Identifique e corrija erros de precedência em expressões dadas",
                                "Construa expressão para linguagem simples como 'todas as cadeias com pelo menos duas 'a's'",
                                "Valide expressão rejeitando strings inválidas",
                                "Explique verbalmente o passo a passo de uma construção complexa",
                                "Compare duas expressões equivalentes usando operações básicas"
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de precedência e parênteses (90% correto)",
                                "Capacidade de gerar strings válidas/inválidas para expressões (100% acerto em 10 testes)",
                                "Criatividade na decomposição de linguagens em operações básicas",
                                "Documentação clara do raciocínio em construções",
                                "Tempo de construção de expressão complexa < 10 min",
                                "Ausência de erros comuns como precedência errada"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (união, produto cartesiano análogo a concatenação)",
                                "Lógica: Expressões booleanas e disjunções",
                                "Programação: Uso de regex em Python/JavaScript para padrões de texto",
                                "Linguística: Modelagem de padrões linguísticos formais"
                              ],
                              "realWorldApplication": "Desenvolver padrões de validação em formulários web (ex: regex para emails ou senhas), busca avançada em editores de texto como VS Code, filtros de log em sistemas de monitoramento, ou parsers em compiladores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Exemplos de Expressões Regulares",
                        "description": "Fornece exemplos concretos de expressões regulares e suas linguagens correspondentes, relacionando com conjuntos regulares simples e complexos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Interpretar linguagens de expressões simples",
                            "description": "Dado uma expressão como (a|b)a, descrever a linguagem gerada, listando exemplos de cadeias como 'aa' e 'ba', e explicando por que 'a' não pertence.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar componentes básicos de expressões regulares",
                                  "subSteps": [
                                    "Identifique símbolos básicos: letras como 'a' e 'b' representam si mesmos.",
                                    "Entenda a união '|': (a|b) significa 'a' ou 'b'.",
                                    "Aprenda concatenação: colocados lado a lado, como XY, significa X seguido de Y.",
                                    "Estude parênteses: agrupam subexpressões para definir ordem.",
                                    "Revise o ε (vazio) e o conjunto vazio, mas foque em expressões simples sem eles."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o significado de (a|b) e 'a' isolada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Tabela de sintaxe de expressões regulares (impressa ou digital)"
                                  ],
                                  "tips": "Desenhe árvores de análise para visualizar a estrutura.",
                                  "learningObjective": "Compreender os operadores fundamentais de expressões regulares simples.",
                                  "commonMistakes": "Confundir união '|' com ou lógico em cadeias longas; ignorar parênteses."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decompor a estrutura da expressão (a|b)a",
                                  "subSteps": [
                                    "Divida em partes: subexpressão interna (a|b), seguida de concatenação com 'a'.",
                                    "Expanda (a|b): gera 'a' ou 'b'.",
                                    "Aplique concatenação: cada resultado de (a|b) seguido por 'a'.",
                                    "Anote a árvore de derivação: raiz é concatenação, esquerda (a|b), direita 'a'.",
                                    "Confirme precedência: parênteses garantem (a|b) primeiro."
                                  ],
                                  "verification": "Desenhe e rotule a árvore de parsing da expressão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Exemplos de expressões similares"
                                  ],
                                  "tips": "Use setas para mostrar derivações: (a|b) → a ou b, então +a.",
                                  "learningObjective": "Analisar hierarquicamente a estrutura de uma expressão regular.",
                                  "commonMistakes": "Interpretar como a|(ba) sem parênteses; esquecer concatenação obrigatória."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar strings na linguagem e descrevê-la",
                                  "subSteps": [
                                    "Liste derivações: de (a|b)a → 'aa' (a+a), 'ba' (b+a).",
                                    "Gere mais exemplos: confirme apenas strings de comprimento 2 terminando em 'a'.",
                                    "Descreva formalmente: { w | w = xa onde x ∈ {a,b} e |w|=2 }.",
                                    "Teste variações: adicione mais letras se aplicável, mas foque na dada.",
                                    "Escreva a linguagem em notação de conjunto: L = {aa, ba}."
                                  ],
                                  "verification": "Liste pelo menos 3 strings na linguagem e prove que derivam da expressão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de possíveis strings curtas (aa, ab, ba, bb, a, etc.)"
                                  ],
                                  "tips": "Comece com strings mínimas e expanda sistematicamente.",
                                  "learningObjective": "Derivar exemplos concretos da linguagem gerada pela expressão.",
                                  "commonMistakes": "Incluir strings como 'a' (falta o prefixo); gerar infinitas sem limite."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar strings fora da linguagem e justificar",
                                  "subSteps": [
                                    "Teste 'a': deriva de 'a', mas expressão requer dois símbolos; falta prefixo.",
                                    "Teste 'ab': termina em 'b', não 'a'; concatenação exige final 'a'.",
                                    "Teste 'aaa': comprimento 3, expressão gera só 2 símbolos.",
                                    "Explique rejeições: trace back à estrutura (deve ser exatamente (a ou b) + a).",
                                    "Liste 3-5 contra-exemplos com razões."
                                  ],
                                  "verification": "Para 3 strings dadas (ex: 'a', 'ab', 'aaa'), explique por que não pertencem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de testes: string | aceita? | razão"
                                  ],
                                  "tips": "Use prova por contradição: assuma pertence e encontre mismatch.",
                                  "learningObjective": "Distinguir membros e não-membros da linguagem com justificativa.",
                                  "commonMistakes": "Aceitar 'a' como subcaso; confundir com linguagens mais complexas."
                                }
                              ],
                              "practicalExample": "Para a expressão (a|b)a: Linguagem = {aa, ba}. Exemplos: 'aa' (a seguido de a), 'ba' (b seguido de a). 'a' não pertence porque falta o primeiro símbolo (deve ter dois caracteres).",
                              "finalVerifications": [
                                "Descreva corretamente a linguagem como todas as strings de dois caracteres terminando em 'a' com primeiro em {a,b}.",
                                "Liste pelo menos dois exemplos positivos ('aa', 'ba') com derivações.",
                                "Explique três contra-exemplos ('a', 'ab', 'bb') com razões estruturais.",
                                "Desenhe a árvore de parsing sem erros.",
                                "Converta para notação de conjunto: L((a|b)a) = {aa, ba}.",
                                "Compare com expressão similar, como a(a|b)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição: 100% dos operadores corretos.",
                                "Exemplos gerados: pelo menos 2 positivos e 3 negativos com provas.",
                                "Descrição formal: linguagem descrita sem ambiguidades.",
                                "Justificativas: lógicas e ligadas à sintaxe.",
                                "Clareza na comunicação: explicações concisas e diagramas legíveis.",
                                "Completude: cobre estrutura, exemplos e exclusões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conjuntos e união, similar a teoria de conjuntos.",
                                "Lógica: Provas por casos, como em lógica proposicional.",
                                "Linguística: Análise sintática de frases simples.",
                                "Programação: Padrões regex em Python/Java para validação."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, interpretar regex simples para validar formatos como emails (ex: [a-z]@dominio.com) ou padrões de senhas, garantindo que inputs sigam regras exatas em formulários web."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Construir expressões para linguagens dadas",
                            "description": "Para uma linguagem descrita verbalmente, como 'todas as cadeias com número par de a's sobre {a,b}', criar uma expressão regular equivalente, como (b*(aa)*b*|(aa)*)*.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a descrição da linguagem",
                                  "subSteps": [
                                    "Leia cuidadosamente a descrição verbal da linguagem, identificando o alfabeto (ex: {a,b}).",
                                    "Identifique as restrições principais, como 'número par de a's'.",
                                    "Reescreva a descrição em termos formais, como 'L = { w ∈ {a,b}* | número de a's em w é par }'.",
                                    "Liste exemplos de strings na linguagem e strings fora dela.",
                                    "Anote propriedades chave, como paridade ou ordem."
                                  ],
                                  "verification": "Confirme que você tem uma lista de 3 exemplos positivos e 3 negativos anotados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto; descrição da linguagem.",
                                  "tips": "Use tabelas para organizar exemplos aceitos vs rejeitados.",
                                  "learningObjective": "Compreender e formalizar a linguagem descrita verbalmente.",
                                  "commonMistakes": "Ignorar o alfabeto ou confundir 'par' com 'ímpar'; não listar contraexemplos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decompor a linguagem em componentes primitivos",
                                  "subSteps": [
                                    "Identifique padrões básicos: ε (vazia), a, b, ou sequências simples.",
                                    "Divida restrições em sublinguagens, ex: strings com 0 a's (b*), 2 a's (b* a b* a b*), etc.",
                                    "Use união para combinar casos: par = 0 ou 2 ou 4... a's.",
                                    "Considere concatenação e estrela (Kleene) para repetições.",
                                    "Desenhe um diagrama informal de como os componentes se conectam."
                                  ],
                                  "verification": "Crie sub-expressões para cada componente e teste manualmente com exemplos simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto; exemplos da linguagem; tabela de operações regex (união |, concatenação, *).",
                                  "tips": "Comece com casos base (0 a's) e construa iterativamente.",
                                  "learningObjective": "Quebrar linguagens complexas em expressões regulares primitivas.",
                                  "commonMistakes": "Esquecer de cobrir todos os casos (ex: só pares ímpares); não usar * para repetição."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a expressão regular completa",
                                  "subSteps": [
                                    "Combine sub-expressões usando união: ex: b* | (b* a b* a b*) | ... mas otimize com *.",
                                    "Para paridade de a's: use (b | a a)* para alternar pares.",
                                    "Aplique estrela para repetição ilimitada: ((b*(a a)*b*)*).",
                                    "Simplifique usando propriedades regex (associatividade, idempotência).",
                                    "Escreva a expressão final e anote sua estrutura."
                                  ],
                                  "verification": "A expressão gerada aceita todos os exemplos positivos e rejeita negativos manualmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta online de teste regex (ex: regex101.com); exemplos anotados.",
                                  "tips": "Priorize padrões como (X* (Y X*)*) para contagens pares.",
                                  "learningObjective": "Sintetizar expressões regulares usando operações básicas.",
                                  "commonMistakes": "Parênteses incorretos levando a precedência errada; regex infinita ou vazia."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar a expressão",
                                  "subSteps": [
                                    "Teste com ferramenta regex contra 10+ strings (positivas e negativas).",
                                    "Verifique minimalidade: remova redundâncias desnecessárias.",
                                    "Compare com AFD equivalente se possível (converta mentalmente).",
                                    "Documente por que a regex é correta (prova por indução informal).",
                                    "Ajuste se falhar em algum teste."
                                  ],
                                  "verification": "100% de acerto em conjunto de testes diversificado (curtas, longas, extremas).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Regex tester online; gerador de strings aleatórias.",
                                  "tips": "Inclua edge cases: ε, só a's, só b's, alternando.",
                                  "learningObjective": "Garantir correção e eficiência da expressão regular.",
                                  "commonMistakes": "Não testar strings longas; assumir correção sem validação."
                                }
                              ],
                              "practicalExample": "Para L = {todas as cadeias com número par de a's sobre {a,b}}, construa (b*(aa)*)*. Teste: 'abab' (2 a's, par, aceito); 'aba' (2a's? aba tem 2a1b, aceito? wait: aa tem 2, mas ajuste para (b|aa)* que gera bb, aa, baba, etc., mas correto é (b*(aa)*)* cobre bbb (0a), aabb (2a), etc.",
                              "finalVerifications": [
                                "A expressão aceita todas as strings com par de a's e rejeita ímpares.",
                                "Funciona para strings vazia (0 a's, par).",
                                "Testada com pelo menos 10 exemplos variados.",
                                "Minimal e sem redundâncias óbvias.",
                                "Prova informal de correção via casos base e indução.",
                                "Compatível com alfabeto dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Regex gera exatamente a linguagem descrita (90%+ testes passem).",
                                "Estrutura: Uso correto de |, concatenação e * sem erros sintáticos.",
                                "Eficiência: Expressão concisa, sem loops desnecessários.",
                                "Documentação: Explicação clara de cada parte da regex.",
                                "Criatividade: Abordagem inovadora para linguagens complexas.",
                                "Validação: Evidência de testes com contraexemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e indução matemática para provas.",
                                "Lógica: Equivalência entre regex, AFDs e gramáticas regulares.",
                                "Programação: Aplicação em validação de inputs (Python re module).",
                                "Linguística: Padrões em linguagem natural e parsing."
                              ],
                              "realWorldApplication": "Desenvolvimento de validadores de formulários web (ex: senhas com par de caracteres especiais), processamento de logs para padrões de erro pares, filtros de texto em buscas (ex: GitHub code search), compiladores para análise léxica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Verificar pertencimento de cadeias",
                            "description": "Dada uma expressão regular e uma cadeia específica, determinar se a cadeia pertence à linguagem, derivando passo a passo usando as operações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da expressão regular e da cadeia",
                                  "subSteps": [
                                    "Leia e parseie a expressão regular, identificando parênteses, operadores (∪ para união, · para concatenação, * para estrela de Kleene) e símbolos básicos (ε ou alfabeto Σ).",
                                    "Construa uma árvore sintática simples da regex, anotando nós como raiz, filhos para uniões/concatenações.",
                                    "Analise a cadeia de entrada: liste seus símbolos sequencialmente e note seu comprimento.",
                                    "Defina o alfabeto Σ da regex e confirme se todos os símbolos da cadeia pertencem a Σ.",
                                    "Prepare uma tabela ou diagrama para registrar derivações."
                                  ],
                                  "verification": "Árvore sintática desenhada corretamente e cadeia analisada sem erros de símbolos.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de regras de derivação (ε ∈ L(ε), a ∈ L(a), etc.)"
                                  ],
                                  "tips": "Comece pela regex mais interna (remova parênteses gradualmente); use cores para diferenciar operadores.",
                                  "learningObjective": "Identificar e representar hierarquicamente a estrutura de uma expressão regular.",
                                  "commonMistakes": [
                                    "Ignorar precedência de operadores (estrela > concat > união)",
                                    "Confundir símbolos da cadeia com operadores da regex"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar regras básicas e de concatenação",
                                  "subSteps": [
                                    "Para sub-expressões básicas: verifique se cadeia vazia pertence a ε, ou se primeiro símbolo da cadeia é o símbolo literal (ex: 'a' ∈ L(a)).",
                                    "Para concatenação r1 · r2: assuma derivação para prefixo em L(r1), reste em L(r2); divida a cadeia em prefixo e sufixo exatos.",
                                    "Registre derivações parciais: escreva 'cadeia = derivada de r1 + derivada de r2'.",
                                    "Teste todas as divisões possíveis para concatenação (i de 0 a |cadeia|).",
                                    "Marque derivações bem-sucedidas com ✓ e falhas com ✗."
                                  ],
                                  "verification": "Todas derivações básicas e concatenações documentadas com divisões corretas e sem ambiguidades.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Árvore sintática do step 1",
                                    "Lista da cadeia com índices de divisão"
                                  ],
                                  "tips": "Use indução no comprimento da cadeia para concatenações; priorize divisões onde |prefixo| = altura de r1.",
                                  "learningObjective": "Dominar derivações indutivas para expressões básicas e concatenações.",
                                  "commonMistakes": [
                                    "Não considerar cadeia vazia para concatenações vazias",
                                    "Divisões incorretas que sobrepõem prefixo/sufixo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar regras de união e estrela de Kleene",
                                  "subSteps": [
                                    "Para união r1 ∪ r2: teste se cadeia inteira deriva de r1 OU r2; registre pelo menos uma derivação válida.",
                                    "Para estrela r*: encontre decomposição cadeia = w1 w2 ... wk onde cada wi ∈ L(r), ou ε; use iterações até consumir toda cadeia.",
                                    "Combine recursivamente com sub-árvore: propague ✓ da esquerda/direita para nó pai.",
                                    "Verifique exaustivamente loops na estrela (máx. |cadeia|+1 iterações para evitar infinito).",
                                    "Atualize tabela global de derivações até a raiz."
                                  ],
                                  "verification": "Nó raiz marcado como ✓ com pelo menos uma derivação completa da cadeia inteira.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Tabela de derivações parciais",
                                    "Regras de indução impressas"
                                  ],
                                  "tips": "Para estrela, liste posições consumidas após cada iteração; pare se posição > |cadeia|.",
                                  "learningObjective": "Executar derivações para operadores complexos, garantindo cobertura exaustiva.",
                                  "commonMistakes": [
                                    "Loop infinito na estrela sem limite",
                                    "Esquecer que união requer apenas UMA ramificação válida"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e validar a derivação completa",
                                  "subSteps": [
                                    "Traceie da raiz à folha: confirme que toda cadeia foi consumida sem resíduos.",
                                    "Escreva a prova formal: 's ∈ L(r) por regra X aplicada a sub-derivações Y e Z'.",
                                    "Teste com variação: altere um símbolo da cadeia e reexecute para ver falha.",
                                    "Compare com ferramenta externa (ex: regex tester) se disponível.",
                                    "Resuma em uma sentença: 'Pertence/Não pertence porque...'"
                                  ],
                                  "verification": "Prova escrita completa e teste de contra-exemplo falha corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Derivações completas",
                                    "Ferramenta online de regex opcional"
                                  ],
                                  "tips": "Sempre inclua contra-exemplo para reforçar entendimento.",
                                  "learningObjective": "Sintetizar derivação em prova rigorosa e validar robustez.",
                                  "commonMistakes": [
                                    "Aceitar derivações parciais como completas",
                                    "Não consumir toda a cadeia"
                                  ]
                                }
                              ],
                              "practicalExample": "Regex: (a ∪ b)* a\nCadeia: 'aba'\nDerivação: 'aba' = 'ab' (de (a∪b)*) · 'a' (de a)\n'ab' = 'a' (de a∪b) · 'b' (de a∪b) no primeiro ciclo da estrela; ✓ pertence.",
                              "finalVerifications": [
                                "Pode reconstruir a árvore sintática da regex sem erros?",
                                "Lista todas as regras de derivação usadas corretamente?",
                                "Identifica pelo menos uma derivação válida para cadeia que pertence?",
                                "Explica por que uma cadeia similar não pertence?",
                                "Traceia consumo completo da cadeia?",
                                "Aplica limites para evitar loops infinitos na estrela?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na árvore sintática e parsing (20%)",
                                "Correção das derivações indutivas (40%)",
                                "Cobertura exaustiva de uniões/estrelas (20%)",
                                "Clareza na documentação e prova final (10%)",
                                "Tratamento de casos negativos/contras (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por indução estrutural",
                                "Programação: Implementação de motores regex (Python re module)",
                                "Lógica: Verificação de teoremas em linguagens formais",
                                "Engenharia de Software: Validação de parsers e compiladores"
                              ],
                              "realWorldApplication": "Verificação de padrões em validação de formulários (ex: email com regex), busca em motores de texto (Google), análise de logs de segurança cibernética para detectar padrões maliciosos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Conjuntos Regulares",
                    "description": "Definição de linguagens regulares e sua relação com expressões regulares, incluindo exemplos clássicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Definição de Linguagens Regulares",
                        "description": "Conceito fundamental que define linguagens regulares como conjuntos de strings reconhecidos por autômatos finitos determinísticos (AFD) ou não-determinísticos (AFND), ou gerados por expressões regulares.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Definir formalmente uma linguagem regular",
                            "description": "Explicar a definição formal de uma linguagem regular como o conjunto de strings aceitas por um autômato finito, incluindo notação L(M) para a linguagem aceita por uma máquina M.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal de um autômato finito determinístico (DFA)",
                                  "subSteps": [
                                    "Estude os componentes de um DFA: conjunto finito de estados Q, alfabeto Σ, função de transição δ: Q × Σ → Q, estado inicial q0 ∈ Q, conjunto de estados finais F ⊆ Q.",
                                    "Desenhe um diagrama simples de um DFA que aceita strings com número par de 'a's sobre alfabeto {a,b}.",
                                    "Escreva a tupla formal (Q, Σ, δ, q0, F) para o seu DFA.",
                                    "Explique verbalmente cada componente para um colega ou em voz alta.",
                                    "Compare DFA com NFA para destacar diferenças na definição."
                                  ],
                                  "verification": "Você consegue listar e descrever corretamente os 5 componentes de um DFA sem consultar notas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 1)",
                                    "Ferramenta online como JFLAP para simular DFAs",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com exemplos visuais; diagramas ajudam a fixar a estrutura.",
                                  "learningObjective": "Compreender os elementos constitutivos de um autômato finito como base para linguagens regulares.",
                                  "commonMistakes": [
                                    "Confundir função de transição com aceitação",
                                    "Esquecer que F é subconjunto de Q",
                                    "Ignorar o alfabeto Σ na tupla"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a notação L(M) para a linguagem aceita por uma máquina M",
                                  "subSteps": [
                                    "Defina L(M) como o conjunto de todas as strings w ∈ Σ* tais que M aceita w, ou seja, δ̂(q0, w) ∈ F.",
                                    "Estude a definição de computação passo a passo: configuração inicial (q0, w), transição para (q1, w1), até estado final.",
                                    "Calcule L(M) para um DFA simples que aceita strings terminando em '1' sobre {0,1}.",
                                    "Escreva formalmente: L(M) = {w ∈ {0,1}* | δ̂(q0, w) ∈ F}.",
                                    "Pratique com 2 exemplos adicionais, variando o DFA."
                                  ],
                                  "verification": "Você pode computar δ̂(q0, w) para uma string w dada e determinar se w ∈ L(M).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre teoria da computação",
                                    "Simulador online de autômatos (ex: automataTutor)",
                                    "Exemplos de DFAs impressos"
                                  ],
                                  "tips": "Use setas para rastrear transições em papel durante computações.",
                                  "learningObjective": "Dominar a notação L(M) e o processo de aceitação de strings.",
                                  "commonMistakes": [
                                    "Confundir L(M) com o autômato M em si",
                                    "Erros no cálculo de δ̂ (função estendida)",
                                    "Incluir strings não no Σ*"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a definição de uma linguagem regular",
                                  "subSteps": [
                                    "Enuncie: Uma linguagem L ⊆ Σ* é regular se existe um DFA M tal que L = L(M).",
                                    "Estenda para NFAs: L também regular se L = L(M) para algum NFA M.",
                                    "Escreva a definição completa usando notação matemática: L é regular ⇔ ∃ M DFA/NFA, L(M) = L.",
                                    "Prove com um exemplo: Mostre que {strings com 'ab' como subpalavra} é regular construindo M.",
                                    "Discuta equivalência: Todo NFA tem DFA equivalente, preservando L(M)."
                                  ],
                                  "verification": "Escreva a definição formal de linguagem regular em um papel e compare com a referência.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigo da Wikipedia sobre Linguagens Regulares (seção formal)",
                                    "Livro de Hopcroft/Ullman (Capítulo 3)",
                                    "Editor de texto para fórmulas LaTeX"
                                  ],
                                  "tips": "Use símbolos matemáticos corretos: ⊆, ∃, = para precisão.",
                                  "learningObjective": "Articular a definição formal ligando autômatos a linguagens.",
                                  "commonMistakes": [
                                    "Definir só via expressões regulares, ignorando autômatos",
                                    "Confundir regular com recursivamente enumerável",
                                    "Omitir Σ* no contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar a definição com exemplos complexos",
                                  "subSteps": [
                                    "Construa um DFA para L = {w ∈ {a,b}* | w tem comprimento par} e defina L(M).",
                                    "Converta para NFA e confirme L(M) igual.",
                                    "Discuta por que linguagens como {a^n b^n} não são regulares ( teaser para bombeamento).",
                                    "Escreva 3 definições formais de linguagens regulares variadas.",
                                    "Teste: Dado M, descreva L(M) informal e formalmente."
                                  ],
                                  "verification": "Crie uma definição correta para uma nova linguagem regular sem erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "JFLAP ou Draw.io para diagramas",
                                    "Lista de exercícios de linguagens regulares",
                                    "Gravador de voz para autoexplicação"
                                  ],
                                  "tips": "Sempre valide com strings de teste: aceitas e rejeitadas.",
                                  "learningObjective": "Aplicar a definição em contextos variados para internalizar o conceito.",
                                  "commonMistakes": [
                                    "Construir autômatos incorretos que não capturam L",
                                    "Ignorar strings vazias ε",
                                    "Confundir aceitação com reconhecimento"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o DFA M = ({q0,q1}, {0,1}, δ, q0, {q1}) onde δ(q0,0)=q0, δ(q0,1)=q1, δ(q1,0)=q1, δ(q1,1)=q0. Defina formalmente L(M) = {w ∈ {0,1}* | w tem número par de 1's}, pois δ̂(q0, w) = q1 iff par de 1's.",
                              "finalVerifications": [
                                "Pode enunciar a definição de linguagem regular usando L(M)?",
                                "Consegue listar componentes de DFA e ligá-los a L(M)?",
                                "Calcula corretamente aceitação de strings em L(M)?",
                                "Distingue linguagens regulares de não-regulares basicamente?",
                                "Escreve notação matemática precisa sem erros?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal (uso correto de L(M), Σ*, δ̂)",
                                "Compreensão conceitual (liga autômato à linguagem aceita)",
                                "Capacidade de exemplificar com DFAs/NFAs corretos",
                                "Identificação de erros comuns em definições",
                                "Clareza na explicação verbal/escrita",
                                "Aplicação a exemplos não triviais"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (L ⊆ Σ*) e Funções (δ)",
                                "Linguística: Análise de padrões em sequências simbólicas",
                                "Engenharia de Software: Bases para parsing em compiladores",
                                "Lógica: Autômatos como modelos computacionais finitos"
                              ],
                              "realWorldApplication": "Em compiladores (ex: regex em editores de texto como VS Code ou grep no Linux), validação de padrões em protocolos de rede (IPs válidos), e análise de DNA para sequências repetitivas em bioinformática."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Reconhecer linguagens finitas como regulares",
                            "description": "Identificar que todo conjunto finito de strings é regular e fornecer um autômato finito ou expressão regular equivalente para exemplos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de linguagens finitas",
                                  "subSteps": [
                                    "Defina uma linguagem finita como um conjunto com um número finito de strings sobre um alfabeto dado.",
                                    "Liste exemplos de linguagens finitas, como {'a', 'bb', 'ccc'} sobre Σ = {a,b,c}.",
                                    "Diferencie linguagens finitas de infinitas, como a* (infinitas).",
                                    "Explique por que linguagens finitas não requerem loops em autômatos.",
                                    "Crie um conjunto finito simples com 3-5 strings e descreva seu alfabeto."
                                  ],
                                  "verification": "Escreva uma definição precisa e forneça 2 exemplos corretos de linguagens finitas vs. infinitas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de teoria da computação (cap. linguagens formais)"
                                  ],
                                  "tips": "Use diagramas de conjuntos para visualizar o tamanho finito.",
                                  "learningObjective": "Identificar e definir corretamente linguagens finitas.",
                                  "commonMistakes": [
                                    "Confundir com linguagens vazias ou singleton.",
                                    "Ignorar o alfabeto subjacente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender por que toda linguagem finita é regular",
                                  "subSteps": [
                                    "Lembre que linguagens regulares são geradas por expressões regulares ou aceitas por autômatos finitos.",
                                    "Argumente que para um conjunto finito F = {w1, w2, ..., wn}, uma ER é a união: ER(w1) ∪ ER(w2) ∪ ... ∪ ER(wn), onde ER(wi) é a concatenação de símbolos de wi.",
                                    "Discuta que autômatos finitos para finitas não precisam de loops; basta um caminho linear por string.",
                                    "Prove informalmente para um exemplo pequeno: F = {'ab'} → ER = a·b.",
                                    "Generalize para qualquer finito: número de estados ≤ soma dos comprimentos +1."
                                  ],
                                  "verification": "Forneça um argumento lógico curto provando que qualquer finito é regular.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou editor de texto",
                                    "Notas de aula sobre regularidade"
                                  ],
                                  "tips": "Pense em 'árvore de decisão' sem ramificações infinitas.",
                                  "learningObjective": "Explicar o teorema fundamental de que finitas ⊆ regulares.",
                                  "commonMistakes": [
                                    "Achar que precisa de laços.",
                                    "Esquecer união na ER."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir expressões regulares para conjuntos finitos",
                                  "subSteps": [
                                    "Escolha um exemplo finito: L = {'cat', 'dog', 'rat'} sobre Σ = {a,c,d,g,o,r,t}.",
                                    "Construa ER para cada string: 'cat' → c·a·t; 'dog' → d·o·g; 'rat' → r·a·t.",
                                    "Una-as: (c·a·t) ∪ (d·o·g) ∪ (r·a·t).",
                                    "Teste a ER gerando apenas strings em L.",
                                    "Simplifique se possível e valide com ferramenta online de regex."
                                  ],
                                  "verification": "Escreva ER correta para um conjunto finito dado e gere todas as strings dela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de regex (regex101.com)",
                                    "Papel para rascunhos"
                                  ],
                                  "tips": "Trate cada string como uma ER literal concatenada.",
                                  "learningObjective": "Gerar ERs equivalentes a conjuntos finitos.",
                                  "commonMistakes": [
                                    "Usar * ou + desnecessariamente.",
                                    "Erros de parênteses na união."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir autômatos finitos para linguagens finitas",
                                  "subSteps": [
                                    "Para L = {'cat', 'dog'}, crie AFD com estados em cadeia para cada caminho.",
                                    "Defina estados: q0 →c q1 →a q2 →t qf (para 'cat'); ramifique de q0 para 'dog'.",
                                    "Garanta estado final único ou múltiplos convergindo.",
                                    "Desenhe o diagrama e simule aceitando/rejeitando strings.",
                                    "Converta ER do step 3 em AFD usando Thompson ou similar, simplificando."
                                  ],
                                  "verification": "Desenhe AFD que aceita exatamente o conjunto finito e teste 3 strings.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (draw.io ou papel)",
                                    "Simulador de AFD online"
                                  ],
                                  "tips": "Use 'estados sink' para rejeição após desvio.",
                                  "learningObjective": "Projetar AFDs para linguagens finitas sem loops.",
                                  "commonMistakes": [
                                    "Adicionar loops acidentais.",
                                    "Estados insuficientes para ramificações."
                                  ]
                                }
                              ],
                              "practicalExample": "Dado L = {'00', '01', '10'} sobre Σ={0,1}, construa ER: (0·0) ∪ (0·1) ∪ (1·0) e AFD com 4 estados: q0 ramifica para caminhos exatos terminando em qf.",
                              "finalVerifications": [
                                "Explica corretamente por que finitas são regulares.",
                                "Constrói ER válida para qualquer finito dado.",
                                "Desenha AFD que aceita só o finito especificado.",
                                "Testa ER/AFD com strings dentro/fora de L.",
                                "Identifica quando um conjunto é finito vs. infinito."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de ER (sem gerar extras).",
                                "Corretude do AFD (aceita só L, rejeita resto).",
                                "Explicação clara do teorema finito-regular.",
                                "Eficiência: ER/AFD minimais.",
                                "Testes abrangentes (positivos/negativos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e união finita.",
                                "Lógica: Provas por construção e indução finita.",
                                "Programação: Regex em Python/Java para padrões finitos.",
                                "Linguística: Análise de padrões finitos em morfologia."
                              ],
                              "realWorldApplication": "Em editores de código (VS Code), use regex finitas para substituir padrões exatos como nomes de variáveis específicas em um arquivo pequeno, ou em validação de formatos fixos como códigos postais curtos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Diferenciar linguagens regulares infinitas",
                            "description": "Explicar como linguagens regulares podem ser infinitas, usando o princípio da casa dos pombos para provar que autômatos finitos capturam padrões repetitivos limitados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Linguagens Regulares e Autômatos Finitos",
                                  "subSteps": [
                                    "Defina formalmente uma linguagem regular como o conjunto de strings aceitas por um autômato finito determinístico (AFD) ou não-determinístico (AFND).",
                                    "Descreva a estrutura de um AFD: estados finitos Q, alfabeto Σ, função de transição δ, estado inicial q0, estados finais F.",
                                    "Construa um exemplo simples de AFD para a linguagem {a^n | n ≥ 0}, destacando o número finito de estados.",
                                    "Explique como expressões regulares equivalem a linguagens regulares via teoremas de Kleene.",
                                    "Discuta por que o número finito de estados limita os padrões, mas permite repetições via loops."
                                  ],
                                  "verification": "Construa e desenhe um AFD para uma linguagem regular simples e liste suas componentes formais corretamente.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Papel e lápis ou software JFLAP",
                                    "Livro de Teoria da Computação (ex: Sipser)"
                                  ],
                                  "tips": "Use diagramas visuais para representar transições; comece com linguagens finitas para contrastar depois.",
                                  "learningObjective": "Compreender os fundamentos que permitem linguagens regulares serem infinitas apesar de estados finitos.",
                                  "commonMistakes": "Confundir AFD com AFND ou esquecer que linguagens vazias ou finitas também são regulares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Linguagens Infinitas e o Princípio da Casa dos Pombos",
                                  "subSteps": [
                                    "Defina uma linguagem infinita como um conjunto com infinitas strings distintas.",
                                    "Explique o Princípio da Casa dos Pombos: se n+1 pombos em n casas, pelo menos uma casa tem 2 pombos.",
                                    "Aplique intuitivamente: em um AFD com |Q| estados, considere |Q|+1 strings prefixadas curtas; pelo menos duas alcançam o mesmo estado.",
                                    "Descreva como isso implica um ciclo (loop) na execução, permitindo gerar infinitas strings via bombeamento.",
                                    "Diferencie de linguagens finitas: sem loops acessíveis de estados iniciais a finais."
                                  ],
                                  "verification": "Enuncie o Princípio da Casa dos Pombos corretamente e dê um exemplo numérico simples (ex: 3 pombos, 2 casas).",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Folha de anotações",
                                    "Vídeo tutorial sobre Pigeonhole Principle (Khan Academy)"
                                  ],
                                  "tips": "Visualize 'pombos' como configurações de execução e 'casas' como estados.",
                                  "learningObjective": "Dominar o princípio matemático chave para provar infinitude em autômatos finitos.",
                                  "commonMistakes": "Aplicar o princípio incorretamente, ignorando que loops devem ser acessíveis e gerar strings distintas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Princípio para Provar Infinitude de Linguagens Regulares",
                                  "subSteps": [
                                    "Escolha uma linguagem regular infinita, como L = (a|b)*, e construa seu AFD mínimo.",
                                    "Gere |Q|+1 strings curtas (ex: ε, a, b, aa, ab) e trace suas execuções no AFD.",
                                    "Identifique dois prefixos que levam ao mesmo estado via pigeonhole, destacando o ciclo.",
                                    "Bombeie o ciclo para gerar infinitas strings distintas na linguagem.",
                                    "Formalize a prova: se L regular e infinita, existe loop em todo AFD equivalente."
                                  ],
                                  "verification": "Trace execuções em um AFD exemplo e demonstre um ciclo explícito com bombeamento.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Software JFLAP ou Draw.io para diagramas",
                                    "Exemplos de linguagens regulares infinitas"
                                  ],
                                  "tips": "Comece com alfabeto unitário para simplificar; verifique se strings bombeadas permanecem na linguagem.",
                                  "learningObjective": "Aplicar o pigeonhole para provar rigorosamente que uma linguagem regular específica é infinita.",
                                  "commonMistakes": "Escolher strings que não geram strings distintas ou ignorar estados inalcançáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Linguagens Regulares Infinitas de Finitas e Não-Regulares",
                                  "subSteps": [
                                    "Compare com linguagens finitas regulares (ex: {a, aa, aaa}): sem loops necessários.",
                                    "Use o teorema: L regular infinita iff seu AFD mínimo tem um ciclo acessível.",
                                    "Dê contraexemplo: {a^n b^n | n ≥ 0} é infinita mas não regular (pumping lemma).",
                                    "Pratique identificando infinitude em expressões regulares como (ab)* vs. abc.",
                                    "Resuma critérios: infinitude requer repetição ilimitada via loops finitos."
                                  ],
                                  "verification": "Classifique 3 linguagens como infinita/finita regular/não-regular com justificativa usando pigeonhole.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Lista de exercícios de linguagens formais",
                                    "Simulador online de autômatos"
                                  ],
                                  "tips": "Teste sempre com pumping: se puder gerar infinitas via loop, é infinita regular.",
                                  "learningObjective": "Diferenciar precisamente linguagens regulares infinitas usando provas formais.",
                                  "commonMistakes": "Confundir infinitude com não-regularidade ou assumir todo loop torna infinita."
                                }
                              ],
                              "practicalExample": "Para a linguagem regular L = {a^n | n ≥ 0} sobre Σ={a}, construa AFD com estados q0 (inicial/final) e q1, transição δ(q0,a)=q1, δ(q1,a)=q1. Considere 3 strings: ε (q0), a (q1), aa (q1). Pigeonhole: 'a' e 'aa' em q1 → ciclo em q1. Bombeie: a^k para k≥1 gera infinitas strings.",
                              "finalVerifications": [
                                "Explica corretamente como loops em AFDs permitem infinitude.",
                                "Aplica pigeonhole para provar infinitude em um exemplo dado.",
                                "Diferencia linguagens regulares infinitas de finitas.",
                                "Identifica erros comuns em provas de infinitude.",
                                "Constrói AFD simples e traça execuções com pigeonhole.",
                                "Responde perguntas sobre bombeamento de ciclos."
                              ],
                              "assessmentCriteria": [
                                "Correção formal na aplicação do Princípio da Casa dos Pombos (30%)",
                                "Clareza na construção e análise de AFDs (25%)",
                                "Precisão na diferenciação de linguagens infinitas vs finitas (20%)",
                                "Uso de exemplos concretos e bombeamento (15%)",
                                "Identificação de erros comuns e tips práticos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e Princípio da Casa dos Pombos em provas de existência.",
                                "Lógica: Estruturas formais e indução em linguagens.",
                                "Programação: Regex em linguagens como Python para padrões infinitos (ex: r'a*').",
                                "Filosofia da Computação: Limites da finitude em modelos computacionais."
                              ],
                              "realWorldApplication": "Em compiladores e validadores, regex como ^[a-zA-Z0-9+]*$ capturam domínios infinitos possíveis; entender infinitude garante eficiência em autômatos finitos para parsing de logs ou validação de senhas com padrões repetitivos ilimitados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Relação com Expressões Regulares",
                        "description": "Estabelecimento da equivalência entre linguagens regulares e expressões regulares, baseado no Teorema de Kleene.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Enunciar o Teorema de Kleene",
                            "description": "Descrever o teorema que afirma que uma linguagem é regular se e somente se existe uma expressão regular que a gera, incluindo as direções da equivalência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de Linguagens Regulares e Expressões Regulares",
                                  "subSteps": [
                                    "Defina linguagem regular como o conjunto de strings aceitas por um autômato finito não-determinístico (AFND).",
                                    "Explique expressões regulares como construções usando ε, símbolos do alfabeto, união, concatenação e estrela de Kleene.",
                                    "Compare as duas noções, destacando que ambas modelam padrões simples e finitos.",
                                    "Liste exemplos básicos: linguagem {ε}, a*, (a|b)*.",
                                    "Anote as semelhanças em poder expressivo."
                                  ],
                                  "verification": "Escreva definições precisas em um papel e compare com fontes confiáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser ou similar), notas de aula, whiteboard.",
                                  "tips": "Use diagramas para visualizar AFNDs correspondentes a ERs simples.",
                                  "learningObjective": "Compreender os conceitos base para contextualizar o teorema.",
                                  "commonMistakes": "Confundir AFND com AFD; esquecer que ERs definem linguagens regulares via interpretação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a Direção 'Expressão Regular Implica Linguagem Regular'",
                                  "subSteps": [
                                    "Construa um AFND a partir de uma ER usando regras de Thompson.",
                                    "Aplique as regras: para ε (estado inicial-final), símbolo (duas transições), união (novo inicial com ε para inicios), concatenação (ε de final1 para inicial2), estrela (loops com ε).",
                                    "Simule a construção para ER simples como (a|b)*.",
                                    "Prove informalmente que o AFND aceita exatamente a linguagem da ER.",
                                    "Verifique com traços de execução."
                                  ],
                                  "verification": "Construa AFND para duas ERs diferentes e teste com strings de exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel para desenhar autômatos, simulador online de AFND (ex: JFLAP).",
                                  "tips": "Desenhe sub-autômatos modulares para evitar confusão em ERs complexas.",
                                  "learningObjective": "Dominar a construção que prova uma direção da equivalência.",
                                  "commonMistakes": "Esquecer transições ε na estrela de Kleene; não tratar o caso vazio corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar a Direção 'Linguagem Regular Implica Existência de Expressão Regular'",
                                  "subSteps": [
                                    "Comece com AFD e converta para AFND se necessário.",
                                    "Use eliminação de estados inalcançáveis e não-finais.",
                                    "Aplique indução no número de estados: base (1 estado), passo (particionar transições).",
                                    "Construa ER via equações de estado (método de Arden).",
                                    "Exemplo: para AFD de strings terminando em 'ab', derive ER (a|b)*ab(a|b)*."
                                  ],
                                  "verification": "Derive ER de um AFD simples com 3 estados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "JFLAP ou papel para equações, exemplos resolvidos de livros.",
                                  "tips": "Resolva equações sistematicamente, substituindo da esquerda para direita.",
                                  "learningObjective": "Entender o algoritmo que extrai ER de autômatos.",
                                  "commonMistakes": "Ignorar estados mortos; erros em resolução de equações não-regulares."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enunciar e Combinar Ambas as Direções no Teorema Completo",
                                  "subSteps": [
                                    "Escreva: 'Uma linguagem L é regular se e somente se existe uma expressão regular R tal que L = L(R)'.",
                                    "Justifique '=>': construção de AFND de ER, que define linguagem regular.",
                                    "Justifique '<=': extração de ER de AFND/AFD equivalente.",
                                    "Discuta unicidade (não única ER, mas existência).",
                                    "Memorize e recite em voz alta três vezes."
                                  ],
                                  "verification": "Escreva o teorema completo e suas justificativas sem consultar notas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Flashcards para memorização, gravador de voz.",
                                  "tips": "Use mnemônicos: 'Kleene liga ER e Regulares bidirecionalmente'.",
                                  "learningObjective": "Enunciar precisamente o teorema com ambas direções.",
                                  "commonMistakes": "Omitir 'se e somente se'; confundir com teoremas de bombeamento."
                                }
                              ],
                              "practicalExample": "Considere a linguagem de strings sobre {a,b} com pelo menos um 'a'. ER: (a|b)* a (a|b)*. Construa AFND via Thompson (prova =>). Para um AFD com estados rastreando 'visto a?', extraia a mesma ER (prova <=).",
                              "finalVerifications": [
                                "Enuncie o teorema verbatim sem hesitação.",
                                "Explique cada direção com um esboço de prova.",
                                "Forneça um exemplo bidirecional correto.",
                                "Distinga de linguagens não-regulares (ex: {a^n b^n}).",
                                "Responda a perguntas sobre implicações (ex: todo AFND tem ER?).",
                                "Construa AFND e ER para uma linguagem dada."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado: inclui 'se e somente se' e definições claras.",
                                "Compreensão das provas: descreve construções corretas.",
                                "Exemplos relevantes: usa linguagens simples e verifica equivalência.",
                                "Ausência de confusões: diferencia de outros teoremas (Pitágoras, bombeamento).",
                                "Fluência: enuncia em menos de 30 segundos com confiança.",
                                "Aplicação: relaciona a regex em programação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e indução em provas.",
                                "Lógica: Equivalências e implicações bidirecionais.",
                                "Programação: Regex em linguagens como Python/Java para padrões reais.",
                                "Linguística: Modelagem de padrões linguísticos finitos."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, o teorema justifica o uso de expressões regulares (regex) em editores de texto, validadores de formulários (ex: emails) e parsers de logs, pois qualquer padrão regular pode ser implementado eficientemente via ERs compiladas em autômatos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Converter AFD para expressão regular",
                            "description": "Aplicar o método de eliminação de estados ou equações de Arden para transformar um autômato finito determinístico em uma expressão regular equivalente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e diagramar o Autômato Finito Determinístico (AFD)",
                                  "subSteps": [
                                    "Identifique os estados, estado inicial, estados finais e todas as transições do AFD dado.",
                                    "Remova estados inacessíveis a partir do estado inicial usando um algoritmo de busca em grafos (BFS ou DFS).",
                                    "Remova estados sem transições de saída ou que não levam a estados finais.",
                                    "Renomeie os estados para q0 (inicial), q1, ..., qn (finais) e desenhe o diagrama do grafo.",
                                    "Verifique se o AFD está na forma padrão: único estado inicial, sem transições vazias."
                                  ],
                                  "verification": "Confirme que o diagrama tem apenas estados acessíveis e relevantes, e que simula corretamente strings de exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta como JFLAP ou draw.io",
                                    "Descrição do AFD"
                                  ],
                                  "tips": "Sempre teste com strings aceitas e rejeitadas para validar a preparação.",
                                  "learningObjective": "Compreender a estrutura do AFD e limpá-lo para simplificar a conversão.",
                                  "commonMistakes": [
                                    "Ignorar estados inacessíveis",
                                    "Esquecer de renomear estados",
                                    "Manter transições vazias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o método de eliminação de estados",
                                  "subSteps": [
                                    "Escolha um estado não-inicial e não-final para eliminar (priorize folhas ou ordem reversa topológica).",
                                    "Para cada par de estados p e r com transições p --R--> q --S--> r, adicione p --R S* S'--> r, onde S* é o loop em q e S' a transição de saída.",
                                    "Atualize todas as transições afetadas e remova o estado q e suas transições originais.",
                                    "Repita o processo para todos os estados intermediários até restarem apenas o inicial e o(s) final(is).",
                                    "Se múltiplos finais, adicione um super-final com ε, mas como é AFD, ajuste para regex direta."
                                  ],
                                  "verification": "Simule uma string no AFD original e na versão parcial após cada eliminação para garantir equivalência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama do Step 1",
                                    "Folha de cálculo para regex parciais",
                                    "Calculadora simbólica opcional"
                                  ],
                                  "tips": "Use parênteses para agrupar regex compostas e anote cada eliminação separadamente.",
                                  "learningObjective": "Dominar a construção de expressões regulares via substituição de caminhos em grafos.",
                                  "commonMistakes": [
                                    "Esquecer loops em q (deve ser (loop)*)",
                                    "Não multiplicar regex corretamente",
                                    "Eliminar estado inicial ou final"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simplificar a expressão regular resultante",
                                  "subSteps": [
                                    "Aplique regras de simplificação: (a|b)*a = a(a|b)*, elimine ε*, concatene identidades.",
                                    "Use equações de Arden se necessário para resolver loops: X = A X + B → X = A* B.",
                                    "Remova redundâncias como ++ ou | com vazio.",
                                    "Teste a regex simplificada com um simulador de regex.",
                                    "Compare o comprimento e legibilidade antes/depois."
                                  ],
                                  "verification": "A regex simplificada gera o mesmo conjunto de strings que o AFD original em testes unitários.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Regex da Step 2",
                                    "Ferramentas online como regex101.com",
                                    "Tabela de regras de simplificação"
                                  ],
                                  "tips": "Escreva a regex em notação infixa com parênteses explícitos para evitar ambiguidades.",
                                  "learningObjective": "Aprender a otimizar expressões regulares para eficiência e clareza.",
                                  "commonMistakes": [
                                    "Aplicar Arden incorretamente em loops não-direitos",
                                    "Ignorar precedência de operadores",
                                    "Não testar com contraexemplos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar equivalência e documentar o processo",
                                  "subSteps": [
                                    "Construa o AFE (Autômato Finito não-determinístico) da regex usando Thompson ou Glushkov.",
                                    "Minimize o AFE e compare com o AFD original.",
                                    "Teste com 5-10 strings: aceitas, rejeitadas, fronteira.",
                                    "Documente cada passo com diagramas e regex intermediárias.",
                                    "Opcionalmente, implemente em código Python para validação automática."
                                  ],
                                  "verification": "Todas as strings de teste comportam-se igual no AFD e na regex.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador JFLAP ou Automata Tutor",
                                    "Código Python com re module",
                                    "Strings de teste"
                                  ],
                                  "tips": "Use Myhill-Nerode para prova formal se avançado, mas testes empíricos bastam.",
                                  "learningObjective": "Garantir correção da conversão através de validação múltipla.",
                                  "commonMistakes": [
                                    "Poucos testes de strings",
                                    "Confundir aceitação com prefixos",
                                    "Não considerar linguagem infinita"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o AFD M = (Q={q0,q1,q2}, Σ={a,b}, δ, q0, F={q2}) onde: δ(q0,a)=q0, δ(q0,b)=q1, δ(q1,a)=q2, δ(q1,b)=q1, δ(q2,a)=q2, δ(q2,b)=q2. Este aceita strings terminando em 'ba' após qualquer prefixo. Eliminando q1: regex de q0 a q2 via q1 é b (a|b)* a; com loops, resulta em (a|b)* b (a|b)* a (a|b)*, simplificando para (a|b)* b a (a|b)*.",
                              "finalVerifications": [
                                "A regex aceita exatamente as mesmas strings curtas e longas que o AFD.",
                                "Diagrama final tem apenas transições iniciais-finais corretas.",
                                "Simplificação não altera o poder expressivo (sem vazios ou universos).",
                                "Testes com minimização mostram estados equivalentes.",
                                "Documentação inclui regex intermediárias sem erros aritméticos.",
                                "Alternativa via Arden: resolver R0 = a R0 + b R1, R1 = (a|b) R1 + a R2, etc., leva à mesma regex."
                              ],
                              "assessmentCriteria": [
                                "Precisão na eliminação: todas as substituições de regex corretas (80%).",
                                "Qualidade da simplificação: regex legível e mínima (15%).",
                                "Validação robusta: pelo menos 8 testes passando (5%).",
                                "Documentação completa com subpassos e diagramas.",
                                "Tratamento de casos edge como AFDs com 1 ou 2 estados.",
                                "Uso correto de operadores * , | , concatenação."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: eliminação de vértices e caminhos etiquetados.",
                                "Álgebra: resolução de sistemas de equações (Arden como fixpoint).",
                                "Lógica e Prova: indução em comprimento de strings para equivalência.",
                                "Programação: implementação de regex em linguagens como Python (re module).",
                                "Compiladores: construção de NFA para scanners léxicos."
                              ],
                              "realWorldApplication": "Conversão de AFDs em regex é usada em compiladores para gerar padrões de tokens em analisadores léxicos (ex: flex), validadores de formulários web (email patterns), motores de busca (grep, regex em editores como VS Code), e processamento de logs para detecção de padrões em segurança cibernética."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Converter expressão regular para AFND",
                            "description": "Construir um autômato finito não-determinístico a partir de uma expressão regular usando composição recursiva (união, concatenação, estrela de Kleene).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar e decompor a expressão regular",
                                  "subSteps": [
                                    "Identifique os operadores principais: união (|), concatenação (implicita ou .), estrela de Kleene (*).",
                                    "Quebre a regex em sub-expressões atômicas (literais como 'a', ε ou ∅).",
                                    "Desenhe uma árvore de parsing da regex para visualizar a estrutura recursiva.",
                                    "Anote os parênteses para priorizar sub-expressões compostas.",
                                    "Defina estados iniciais e finais para cada sub-expressão."
                                  ],
                                  "verification": "Verifique se a árvore de parsing cobre toda a regex sem ambiguidades e lista todas as sub-expressões.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta de diagramação como Draw.io ou Graphviz"
                                  ],
                                  "tips": "Sempre priorize parênteses e precedência: * > concatenação > união.",
                                  "learningObjective": "Compreender a estrutura hierárquica da regex para aplicação recursiva.",
                                  "commonMistakes": [
                                    "Ignorar precedência de operadores",
                                    "Não quebrar corretamente em sub-expressões",
                                    "Confundir literais com operadores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir AFND para sub-expressões básicas",
                                  "subSteps": [
                                    "Para literais (ex: 'a'): Crie estado inicial i → estado final f com transição 'a'.",
                                    "Para ε (vazio): Estado inicial i com ε-transição para final f.",
                                    "Para ∅ (vazio): Nenhum estado ou estado sem transição para final.",
                                    "Para cada sub-expressão atômica, desenhe o diagrama com estados numerados.",
                                    "Garanta que cada AFND básico tenha um estado inicial e um ou mais finais."
                                  ],
                                  "verification": "Teste se o AFND básico aceita apenas a string correspondente à sub-expressão.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Marcadores coloridos para estados e transições"
                                  ],
                                  "tips": "Use círculos duplos para estados finais e seta dupla para inicial.",
                                  "learningObjective": "Dominar a representação básica de símbolos em AFND.",
                                  "commonMistakes": [
                                    "Esquecer de marcar estado inicial/final",
                                    "Adicionar transições desnecessárias",
                                    "Confundir ε com transição vazia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar concatenação recursivamente",
                                  "subSteps": [
                                    "Para A · B: Conecte todos os estados finais de A com ε-transições aos estados iniciais de B.",
                                    "Crie novo estado inicial como o de A e novos finais como os de B.",
                                    "Atualize numeração de estados para evitar conflitos.",
                                    "Desenhe as novas ε-transições claramente.",
                                    "Verifique conectividade: de inicial A até finais B."
                                  ],
                                  "verification": "Simule a concatenação com strings de A seguidas de B; deve aceitar apenas sequências válidas.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Software de autômatos como JFLAP",
                                    "Papel para rascunhos"
                                  ],
                                  "tips": "Mantenha ε-transições curtas e labeladas para clareza.",
                                  "learningObjective": "Implementar composição sequencial preservando a linguagem.",
                                  "commonMistakes": [
                                    "Não adicionar ε para todos os finais/iniciais",
                                    "Alterar estados originais",
                                    "Perder não-determinismo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar união recursivamente",
                                  "subSteps": [
                                    "Para A | B: Crie novo estado inicial i* com ε-transições para iniciais de A e B.",
                                    "Conecte todos os finais de A e B com ε-transições a novo estado final f*.",
                                    "Atualize estados e desenhe o diagrama composto.",
                                    "Garanta que não haja caminhos cruzados indesejados.",
                                    "Teste com strings de A ou B separadamente."
                                  ],
                                  "verification": "O AFND aceita strings de A ou B, mas rejeita outras.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "JFLAP ou similar para simulação",
                                    "Lápis para correções"
                                  ],
                                  "tips": "Use cores diferentes para sub-AFNDs para rastrear origens.",
                                  "learningObjective": "Construir ramificações não-determinísticas para disjunção.",
                                  "commonMistakes": [
                                    "Esquecer ε do novo inicial para ambos",
                                    "Não unificar finais",
                                    "Criar loops acidentais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar estrela de Kleene recursivamente",
                                  "subSteps": [
                                    "Para A*: Crie novo inicial i* com ε para inicial de A e direto para final f*.",
                                    "Conecte todos os finais de A com ε para inicial de A (loop) e para f*.",
                                    "Adicione ε de i* direto para f* (caso vazio).",
                                    "Atualize diagrama e numere estados.",
                                    "Verifique aceitação de zero ou mais repetições de A."
                                  ],
                                  "verification": "Simule ε (aceita), A, AA, etc., e rejeite inválidos.",
                                  "estimatedTime": "30-35 minutos",
                                  "materials": [
                                    "Ferramenta de simulação de autômatos",
                                    "Papel grande para diagrama final"
                                  ],
                                  "tips": "Desenhe o loop de volta claramente com seta curva.",
                                  "learningObjective": "Implementar repetição zero ou mais com não-determinismo.",
                                  "commonMistakes": [
                                    "Esquecer ε para zero ocorrências",
                                    "Não conectar loop de volta",
                                    "Perder estado final único"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a regex (a|b)*a: 1. Decompor: ((a|b)*) · a. 2. Básicos: 'a' (i1-a>f1), 'b' (i2-b>f2). 3. União: i3-ε>i1, i3-ε>i2, f1-ε>f3, f2-ε>f3. 4. Estrela: i4-ε>i3, i4-ε>f4, f3-ε>i3, f3-ε>f4. 5. Concat: f4-ε>i5 ('a'), f5 como final. Resultado aceita strings terminando em 'a' com qualquer prefixo de a/b.",
                              "finalVerifications": [
                                "O AFND possui exatamente um estado inicial e pelo menos um final.",
                                "Todas as transições correspondem à estrutura da regex original.",
                                "Simulação aceita todas as strings da linguagem regex e rejeita inválidas.",
                                "Não há estados desconectados ou transições órfãs.",
                                "O número de estados é mínimo possível pela construção (Thompson).",
                                "ε-transições estão corretamente posicionadas para composição."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição recursiva da regex (100% cobertura).",
                                "Correta implementação de ε-transições para cada operador.",
                                "Diagrama legível com numeração sequencial e labels claros.",
                                "Validação via simulação de pelo menos 3 strings (aceitar/rejeitar).",
                                "Ausência de erros comuns como loops infinitos ou caminhos errados.",
                                "Eficiência na numeração e minimização de estados redundantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e indução recursiva.",
                                "Programação: Regex em linguagens como Python (re module) e compiladores (lexers).",
                                "Lógica e IA: Modelagem de estados em máquinas de busca e reconhecimento de padrões.",
                                "Engenharia de Software: Análise léxica em parsers.",
                                "Linguística Computacional: Processamento de linguagem natural."
                              ],
                              "realWorldApplication": "Essa conversão é a base do algoritmo de Thompson em compiladores (ex: flex, regex engines no JavaScript/Python), usada em editores de texto (VS Code search), validadores de formulários web, scanners de antivírus para padrões maliciosos e sistemas de busca como Google para matching de queries complexas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Exemplos Clássicos de Conjuntos Regulares",
                        "description": "Ilustração prática com exemplos comuns de linguagens regulares e contraexemplos não-regulares para reforçar o entendimento.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Construir exemplo de strings com paridade",
                            "description": "Criar expressão regular e autômato para a linguagem de todas as strings sobre {a,b} com número par de 'a's.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir formalmente a linguagem e identificar propriedades chave",
                                  "subSteps": [
                                    "Escreva a definição formal da linguagem L = { w ∈ {a,b}* | número de 'a's em w é par }.",
                                    "Liste exemplos de strings em L (ex: ε, b, abab, aabb) e fora de L (ex: a, aaab).",
                                    "Identifique que a paridade requer rastreamento de estado par/ímpar de 'a's.",
                                    "Desenhe um diagrama conceitual de dois estados: Even (par) e Odd (ímpar).",
                                    "Anote transições iniciais: estado inicial Even (paridade 0)."
                                  ],
                                  "verification": "Confirme que a definição cobre todos os casos e exemplos são corretos (pelo menos 5 em L e 5 fora).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou editor de texto como Notion/Draw.io",
                                  "tips": "Comece com strings vazia (ε tem 0 a's, par) para ancorar o raciocínio.",
                                  "learningObjective": "Compreender a linguagem e necessidade de memória finita para paridade.",
                                  "commonMistakes": "Confundir paridade de 'a's com comprimento total ou ignorar strings só com b's."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Autômato Finito Determinístico (DFA)",
                                  "subSteps": [
                                    "Defina estados: q0 (Even, inicial e aceitador), q1 (Odd).",
                                    "Adicione transições: de q0 com 'a' → q1; com 'b' → q0. De q1 com 'a' → q0; com 'b' → q1.",
                                    "Desenhe o diagrama do DFA com setas etiquetadas.",
                                    "Marque estado inicial (q0) e estados finais (q0).",
                                    "Teste manualmente com 3 strings: 'abab' (aceitar), 'a' (rejeitar), 'bb' (aceitar)."
                                  ],
                                  "verification": "Simule o DFA em strings de teste; deve aceitar exatamente L.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de desenho como Draw.io ou JFLAP",
                                  "tips": "Use círculos duplos para estados finais e seta de entrada para inicial.",
                                  "learningObjective": "Projetar DFA que rastreia paridade via estados mínimos.",
                                  "commonMistakes": "Esquecer transições para 'b' ou inverter setas de 'a' (paridade flipa só em 'a')."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Expressão Regular (ER) do DFA",
                                  "subSteps": [
                                    "Aplique o algoritmo de conversão DFA para ER: elimine estados não-iniciais/finais se houver (aqui mínimos).",
                                    "Use método de equações de estado: R0 = B0 + A0 R0 + A1 R1; R1 = A0 R1 + A1 R0 (onde A0='b', A1='a').",
                                    "Resolva: R0 = (b + a a)* (simplificando para todas strings com par 'a's).",
                                    "ER final: (b* (a b* a b*)*)* ou equivalente (b + a(b + a)*a)*.",
                                    "Simplifique e valide gerando strings da ER."
                                  ],
                                  "verification": "Gere 5 strings da ER e confirme que DFA as aceita.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel para equações ou software como Regex101 para teste",
                                  "tips": "Lembre que ER para par 'a's é (b|ab*a)*, mas construa sistematicamente.",
                                  "learningObjective": "Converter DFA em ER preservando a linguagem.",
                                  "commonMistakes": "Gerar ER para todas strings ou ímpar 'a's; não simplificar corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e testar a correção",
                                  "subSteps": [
                                    "Teste DFA e ER com 10 strings variadas (curtas/longas, borda como ε).",
                                    "Prove minimalidade: dois estados são mínimos por Myhill-Nerode (distinguíveis por 'a').",
                                    "Implemente DFA em pseudocódigo ou ferramenta online.",
                                    "Compare saída de ER vs DFA em simulador.",
                                    "Documente discrepâncias e corrija."
                                  ],
                                  "verification": "100% acerto em testes; prova de minimalidade esboçada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "JFLAP ou online DFA simulator (ex: cyberzhg.github.io)",
                                  "tips": "Use strings como a^n b^m para testar flip de paridade.",
                                  "learningObjective": "Validar formalmente DFA/ER contra L.",
                                  "commonMistakes": "Ignorar strings vazia ou só b's; não testar casos de borda."
                                }
                              ],
                              "practicalExample": "Para L = strings com par de 'a's: DFA com q0(Even)--a-->q1(Odd)--a-->q0; ambos --b-->self. ER: (b*(a b* a b*)*)*. Teste: 'aabb' (2a's, par): aceito.",
                              "finalVerifications": [
                                "DFA aceita ε, bb, abab (par) e rejeita a, aaab (ímpar).",
                                "ER gera apenas strings com par de 'a's.",
                                "Número de estados é mínimo (2).",
                                "Todas transições definidas (total).",
                                "Pseudocódigo simula corretamente 10+ testes.",
                                "Prova por indução: paridade preservada."
                              ],
                              "assessmentCriteria": [
                                "DFA correto com transições precisas para 'a'/'b'.",
                                "ER equivalente gera L exatamente.",
                                "Testes cobrem casos positivos/negativos/borda.",
                                "Explicação clara de estados e minimalidade.",
                                "Sem erros em simulações manuais.",
                                "Documentação inclui diagramas legíveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (DFA como grafo dirigido).",
                                "Programação: Regex em Python/Java para validação de inputs.",
                                "Lógica: Estados como variáveis booleanas (par/ímpar).",
                                "Física: Modelos de parity checks em circuitos digitais."
                              ],
                              "realWorldApplication": "Validação de checksums pares em protocolos de rede (ex: paridade em bits de erro); padrões regex em editores de código para matching de estruturas balanceadas como chaves/parênteses."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Identificar linguagens não-regulares",
                            "description": "Usar o lema da bombeamento para provar que {a^n b^n | n ≥ 0} não é regular, contrastando com exemplos regulares semelhantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Lema da Bombeamento para Linguagens Regulares",
                                  "subSteps": [
                                    "Revise a definição formal de linguagem regular via autômatos finitos ou expressões regulares.",
                                    "Enuncie o Lema da Bombeamento: Para toda linguagem regular L, existe p tal que para todo w em L com |w| >= p, w = xyz onde |xy| <= p, |y| >= 1 e xy^i z em L para todo i >= 0.",
                                    "Explique cada componente: p (constante de bombeamento), x, y (parte bombeável), z.",
                                    "Discuta o propósito: provar não-regularidade por contradição.",
                                    "Estude exemplos introdutórios de aplicação em linguagens simples."
                                  ],
                                  "verification": "Escreva o enunciado completo do lema e explique cada condição em suas próprias palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Caderno e caneta",
                                    "Acesso a notas de aula sobre autômatos"
                                  ],
                                  "tips": "Memorize a condição |xy| <= p para restringir y ao início da string.",
                                  "learningObjective": "Dominar o enunciado preciso e as condições do Lema da Bombeamento.",
                                  "commonMistakes": "Confundir com o lema para linguagens livres de contexto; ignorar |y| >= 1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Linguagem e Assumir sua Regularidade",
                                  "subSteps": [
                                    "Defina formalmente L = {a^n b^n | n ≥ 0}.",
                                    "Assuma por contradição que L é regular.",
                                    "Pelo lema, existe constante p de bombeamento.",
                                    "Escolha uma string w em L com |w| >= p, especificamente w = a^p b^p.",
                                    "Justifique por que essa w é adequada: representa o 'pior caso' balanceado."
                                  ],
                                  "verification": "Escreva a definição de L, a assunção e a escolha de w com justificativa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Caderno",
                                    "Ferramenta de desenho para diagramas (opcional)"
                                  ],
                                  "tips": "Sempre escolha w que explore a estrutura 'não-local' da linguagem, como igualdade de contagens.",
                                  "learningObjective": "Preparar a base para a prova por contradição usando uma string representativa.",
                                  "commonMistakes": "Escolher w muito curta (|w| < p) ou não balanceada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decompor a String e Analisar Posições Possíveis de y",
                                  "subSteps": [
                                    "Decomponha w = a^p b^p = xyz, respeitando |xy| <= p e |y| >= 1.",
                                    "Analise casos: y inteiramente em a's (caso principal), ou y cruza a-b (impossível por |xy|<=p).",
                                    "Considere y = a^k com 1 <= k <= p.",
                                    "Verifique que x = a^{p-k}, z = a^{k} b^p? Não: z = b^p.",
                                    "Liste todas posições viáveis de y."
                                  ],
                                  "verification": "Desenhe a decomposição w = xyz para p=3, listando casos possíveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado para strings",
                                    "Marcadores coloridos"
                                  ],
                                  "tips": "Use cores para x (azul), y (vermelho), z (verde) para visualizar.",
                                  "learningObjective": "Identificar decomposições válidas e restringir casos.",
                                  "commonMistakes": "Permitir y cruzar a transição a para b, violando |xy| <= p."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Contradição pelo Bombeamento e Contrastar com Regulares",
                                  "subSteps": [
                                    "Bombeie com i=2: xy^2 z = x y y z = a^{p+k} b^p, onde k = |y| >=1.",
                                    "Mostre que xy^2 z não está em L: mais a's que b's.",
                                    "Verifique para i=0: xz = a^{p-k} b^p, mais b's que a's se k>=1.",
                                    "Conclua que L não é regular.",
                                    "Contrastar: L_reg = a* b* é regular (AFD simples); (ab)* também."
                                  ],
                                  "verification": "Escreva as strings bombeadas e prove que saem de L.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno",
                                    "Exemplos de AFD para contrastes"
                                  ],
                                  "tips": "Teste bombeamentos para i=0 e i=2 para reforçar contradição.",
                                  "learningObjective": "Completar a prova e diferenciar de linguagens regulares semelhantes.",
                                  "commonMistakes": "Esquecer de cobrir todos os i ou assumir y em b's."
                                }
                              ],
                              "practicalExample": "Para p=3, w=aaa bbb = xyz. Suponha y=aa (segundos a's), então xy^2 z = a (aa)(aa) bbb = aaaaa bbb, que tem 5 a's e 3 b's, não em L. Similar para outros y.",
                              "finalVerifications": [
                                "Enuncie corretamente o Lema da Bombeamento.",
                                "Escolha w = a^p b^p e justifique.",
                                "Analise decomposições possíveis de xyz.",
                                "Mostre contradição para i=2 e i=0.",
                                "Dê exemplo regular contrastante como a* b*.",
                                "Explique por que o contraste importa."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado do lema (todas condições corretas).",
                                "Escolha adequada de w e decomposição xyz válida.",
                                "Demonstração clara de strings bombeadas fora de L.",
                                "Uso correto de prova por contradição.",
                                "Contraste lógico com linguagens regulares semelhantes.",
                                "Ausência de erros lógicos ou aritméticos em contagens."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por contradição e indução finita.",
                                "Lógica: Estruturas formais e negação de propriedades.",
                                "Programação: Limites de expressões regulares (regex) vs. parsers.",
                                "Filosofia da Ciência: Método hipotético-dedutivo em teoremas."
                              ],
                              "realWorldApplication": "Em compiladores e analisadores léxicos, entender que regex (regulares) falham em linguagens como {a^n b^n} (usadas em sintaxe balanceada), exigindo parsers descendente/pushdown para código fonte real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Analisar propriedades básicas",
                            "description": "Demonstrar fechamento de linguagens regulares sob união, concatenação, estrela e complemento, com exemplos concretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de linguagens regulares e operações básicas",
                                  "subSteps": [
                                    "Defina linguagem regular como aquela reconhecida por um autômato finito determinístico (DFA) ou expressa por uma expressão regular.",
                                    "Liste as operações: união (L1 ∪ L2), concatenação (L1 ⋅ L2), estrela de Kleene (L*), e complemento (Σ* - L).",
                                    "Forneça exemplos simples: L1 = {a, aa}, L2 = {b} sobre alfabeto {a,b}.",
                                    "Construa DFAs para L1 e L2 usando ferramentas como JFLAP.",
                                    "Verifique se as linguagens são regulares convertendo expressões regulares para DFAs."
                                  ],
                                  "verification": "Construa DFAs corretos para L1 e L2 e simule strings de teste como 'a' ∈ L1 e 'b' ∈ L2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, software JFLAP ou draw.io, livro de Teoria da Computação (Sipser ou similar)",
                                  "tips": "Comece com alfababeto pequeno (Σ = {a,b}) para simplificar diagramas de DFA.",
                                  "learningObjective": "Compreender as bases conceituais de linguagens regulares e operações para preparar demonstrações de fechamento.",
                                  "commonMistakes": "Confundir linguagens regulares com context-free; assumir que toda linguagem sobre alfabeto finito é regular."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar fechamento sob união e concatenação",
                                  "subSteps": [
                                    "Para união: Construa um DFA para L1 ∪ L2 adicionando estados iniciais e transições ε-equivalentes.",
                                    "Para concatenação: Crie DFA para L1 ⋅ L2 conectando estados finais de L1 aos iniciais de L2, marcando novos finais.",
                                    "Use exemplo: L1 = a* (DFA com loop em 'a'), L2 = b+ (DFA com loop em 'b').",
                                    "Construa L1 ∪ L2 = a* + b+ e L1 ⋅ L2 = a* b+.",
                                    "Teste com strings: 'aaa' ∈ L1 ∪ L2, 'aabbb' ∈ L1 ⋅ L2."
                                  ],
                                  "verification": "Simule DFAs construídos em strings específicas e confirme aceitação/rejeição correta.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "JFLAP ou Graphviz para diagramas, exemplos impressos de DFAs",
                                  "tips": "Use estados 'dead' para rejeição explícita em construções de produto.",
                                  "learningObjective": "Construir DFAs que provem fechamento sob união e concatenação usando construção de produto.",
                                  "commonMistakes": "Esquecer de tornar estados finais não-aceitantes em concatenação; erros em transições de estados iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar fechamento sob estrela de Kleene",
                                  "subSteps": [
                                    "Construa DFA para L* adicionando novo estado inicial/final com loops via L e ε-transições simuladas.",
                                    "Exemplo: L = {ab}, então L* aceita ε, ab, abab, etc.",
                                    "Crie DFA: novo inicial q0 com transição para si (ε) e para DFA de L; finais conectados de volta.",
                                    "Minimize o DFA usando algoritmo de Hopcroft se necessário.",
                                    "Teste: 'abab' deve ser aceito, 'aba' rejeitado."
                                  ],
                                  "verification": "Verifique se DFA aceita todas as concatenações finitas de strings em L e a string vazia.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta de minimização de DFA online, exemplos de expressões regulares",
                                  "tips": "Lembre-se que L* sempre inclui a string vazia, mesmo se L não.",
                                  "learningObjective": "Dominar a construção de DFA para estrela de Kleene, provando regularidade.",
                                  "commonMistakes": "Omitir loop para string vazia; criar loops infinitos incorretos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar fechamento sob complemento e sintetizar com exemplos concretos",
                                  "subSteps": [
                                    "Construa DFA para complemento de L invertendo estados finais/não-finais no DFA de L.",
                                    "Exemplo: L = a* b (strings terminando em b após a's), complemento inclui strings com b antes de a ou terminando em a.",
                                    "Combine todas operações: Comece com L1, L2 regulares, aplique operações e verifique DFAs.",
                                    "Forneça prova não-construtiva via expressões regulares se aplicável.",
                                    "Documente exemplos em tabela: Operação | Exemplo | DFA construído."
                                  ],
                                  "verification": "Confirme que DFA do complemento rejeita exatamente as strings aceitas pelo original.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Tabela de exemplos em Excel ou papel, simulador de autômatos",
                                  "tips": "Sempre minimize DFAs para clareza visual.",
                                  "learningObjective": "Provar fechamento sob complemento e integrar todas propriedades com exemplos.",
                                  "commonMistakes": "Inverter incorretamente estados em complemento; esquecer alfabeto completo Σ*."
                                }
                              ],
                              "practicalExample": "Dado L1 = {w ∈ {a,b}* | w tem número par de a's} (regex: (b* (aa b*)*)*) e L2 = b* a b* (strings com exatamente um 'a'). Construa DFA para L1 ∪ L2 (pares de a's ou exatamente um a), L1 ⋅ L2, L1*, e complemento de L1. Simule 'aabb a b' em L1 ⋅ L2.",
                              "finalVerifications": [
                                "DFAs para todas operações aceitam/rejeitam strings de teste corretamente.",
                                "Construções usam apenas estados finitos e transições totais.",
                                "Exemplos incluem string vazia onde aplicável.",
                                "Tabela resume operações com regex equivalentes.",
                                "Minimização confirma ausência de estados redundantes.",
                                "Provas verbais explicam por que cada construção preserva regularidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas construções de DFA (sem erros de transição).",
                                "Uso correto de exemplos concretos com simulações.",
                                "Explicação clara de cada propriedade de fechamento.",
                                "Criatividade nos exemplos (além de triviais).",
                                "Documentação completa com diagramas legíveis.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos (união, complemento) e indução para estrela.",
                                "Lógica: Equivalência entre autômatos e expressões regulares (teorema de Kleene).",
                                "Programação: Aplicação em regex de linguagens como Python (re module).",
                                "Engenharia de Software: Validação de padrões em compiladores."
                              ],
                              "realWorldApplication": "Essas propriedades são fundamentais para processadores de texto em editores (VS Code regex search), validadores de formulários web (padrões de email/senhas), e analisadores léxicos em compiladores, garantindo eficiência em reconhecimento de padrões finitos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Propriedades dos Conjuntos Regulares",
                    "description": "Propriedades de fechamento sob união, concatenação, complemento e estrela de Kleene, e teoremas pumping.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Propriedades de Fechamento dos Conjuntos Regulares",
                        "description": "Estudo das propriedades que garantem que os conjuntos regulares permanecem regulares sob operações específicas como união, concatenação, complemento e estrela de Kleene, utilizando autômatos finitos determinísticos (AFDs) ou não-determinísticos (AFNs).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Provar fechamento sob união",
                            "description": "Construir um AFN que reconhece a união de dois conjuntos regulares dados por AFDs ou AFNs, demonstrando a construção de estados e transições para simular a escolha entre as linguagens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar os Autômatos Finito Não-Determinísticos (AFNs) Originais",
                                  "subSteps": [
                                    "Desenhe ou liste os estados, alfabeto, transições, estado inicial e estados finais do primeiro AFN (M1) que reconhece a linguagem L1.",
                                    "Repita o processo para o segundo AFN (M2) que reconhece L2, garantindo que todos os componentes sejam claramente identificados.",
                                    "Verifique se ambos os AFNs são válidos, testando com pelo menos uma string aceita e uma rejeitada para cada um.",
                                    "Anote o alfabeto compartilhado Σ entre M1 e M2.",
                                    "Identifique potenciais sobreposições ou diferenças nos estados para evitar confusões na construção."
                                  ],
                                  "verification": "Confirme que diagramas ou tabelas de transição para M1 e M2 estão completos e corretos, com testes manuais de aceitação/rejeição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, software de desenho de autômatos (ex: JFLAP), exemplos de linguagens regulares simples.",
                                  "tips": "Use cores diferentes para M1 e M2 nos diagramas para facilitar a distinção visual.",
                                  "learningObjective": "Compreender a estrutura interna dos AFNs dados para preparar a construção da união.",
                                  "commonMistakes": "Confundir estados iniciais ou finais entre M1 e M2; ignorar ε-transições existentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Estado Inicial Ramificado com Transições ε",
                                  "subSteps": [
                                    "Crie um novo estado inicial q0 para o AFN de união M.",
                                    "Adicione transições ε de q0 para o estado inicial de M1 e para o estado inicial de M2.",
                                    "Copie todos os estados, transições e ε-transições de M1 e M2 para M, renomeando se necessário para evitar conflitos (ex: prefixo M1_ e M2_).",
                                    "Mantenha o alfabeto Σ o mesmo.",
                                    "Desenhe o diagrama parcial mostrando apenas q0 e as ramificações ε."
                                  ],
                                  "verification": "Simule uma transição ε de q0: deve haver caminhos para ambos os iniciais originais sem consumir símbolos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "JFLAP ou papel para diagramas, tabelas de estados.",
                                  "tips": "Teste imediatamente adicionando uma transição ε e verificando não-determinismo.",
                                  "learningObjective": "Implementar o mecanismo de escolha não-determinística para simular a união.",
                                  "commonMistakes": "Esquecer de copiar todas as transições de M1/M2; criar loops acidentais em q0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Estados Finais e Completar o AFN",
                                  "subSteps": [
                                    "Declare como estados finais de M todos os estados finais de M1 e M2.",
                                    "Verifique que não há estados finais adicionais ou removidos.",
                                    "Complete a tabela de transições de M, incluindo todas as cópias de M1 e M2.",
                                    "Adicione transições de 'armadilha' para estados não especificados, se necessário, para completude.",
                                    "Desenhe o diagrama completo do AFN M."
                                  ],
                                  "verification": "Confirme que estados finais são exatamente a união dos finais originais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "JFLAP para simulação, papel para rascunhos.",
                                  "tips": "Use JFLAP para validar o autômato gerado automaticamente.",
                                  "learningObjective": "Garantir que M aceite strings que terminem em estados finais de M1 ou M2.",
                                  "commonMistakes": "Marcar q0 como final; esquecer estados finais de um dos AFNs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Correção Formal da Construção",
                                  "subSteps": [
                                    "Prove que L(M) ⊇ L1 ∪ L2: mostre que qualquer string em L1 ou L2 é aceita por M via caminhos ε.",
                                    "Prove que L(M) ⊆ L1 ∪ L2: argumente que aceitação só ocorre se seguir caminho completo em M1 ou M2.",
                                    "Teste com strings específicas: uma de L1 apenas, uma de L2 apenas, uma em ambos, e uma fora de ambos.",
                                    "Discuta generalização para AFDs convertendo primeiro para AFN.",
                                    "Escreva uma prova formal curta usando indução ou definição de aceitação."
                                  ],
                                  "verification": "A prova cobre inclusão mútua e testes empíricos passam em JFLAP.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "JFLAP para testes, editor de texto para prova.",
                                  "tips": "Use notação formal: δ̂(q0, w) contém estado final de M1 ou M2 para w em L1 ∪ L2.",
                                  "learningObjective": "Demonstrar matematicamente que a construção preserva a união das linguagens.",
                                  "commonMistakes": "Ignorar ε-fechos na prova; falhar em provar ⊆ direção."
                                }
                              ],
                              "practicalExample": "Dado M1 reconhecendo {a, bb} (estados q0 ->a-> q1 final; q0 ->b-> q2 ->b-> q3 final) e M2 reconhecendo {aaa} (p0 ->a-> p1 ->a-> p2 ->a-> p3 final). Construa M com q0 ε-> q0 e ε-> p0; finais q1,q3,p3. Teste: 'a' aceito via M1; 'aaa' via M2; 'ab' rejeitado.",
                              "finalVerifications": [
                                "O AFN M aceita todas as strings de L1 e L2 via simulação em JFLAP.",
                                "Não há aceitação de strings fora de L1 ∪ L2.",
                                "Diagrama mostra ramificação ε clara do novo inicial.",
                                "Prova formal confirma L(M) = L1 ∪ L2.",
                                "Estados finais são exatamente os originais de M1 e M2.",
                                "Transições são copiadas integralmente sem alterações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção do novo estado inicial e ε-transições (obrigatório).",
                                "Correção dos estados finais como união dos originais.",
                                "Validade da prova formal bidirecional.",
                                "Testes empíricos com pelo menos 4 strings variadas.",
                                "Clareza nos diagramas e tabelas de transição.",
                                "Generalização mencionada para AFDs."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Conjuntos: união como operação fundamental.",
                                "Lógica e Provas: indução e inclusão mútua.",
                                "Programação: implementação de NFA em Python para simulação de regex.",
                                "Matemática Discreta: autômatos como modelos computacionais."
                              ],
                              "realWorldApplication": "Em compiladores e editores de texto (ex: grep, regex em VS Code), união de padrões regulares permite matching flexível de múltiplos formatos de dados, como validar emails OU telefones em formulários web."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Provar fechamento sob concatenação",
                            "description": "Construir um AFN para a concatenação de dois conjuntos regulares, adicionando transições ε para conectar o estado final de um autômato ao inicial do outro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar os AFNs originais para L1 e L2",
                                  "subSteps": [
                                    "Desenhe o diagrama do AFN M1 que reconhece o conjunto regular L1, identificando claramente o estado inicial q0_1 e os estados finais F1.",
                                    "Desenhe o diagrama do AFN M2 que reconhece o conjunto regular L2, identificando o estado inicial q0_2 e os estados finais F2.",
                                    "Liste os alfabetos Σ1 e Σ2 de cada autômato e verifique se Σ = Σ1 ∪ Σ2.",
                                    "Anote todas as transições ε existentes em M1 e M2 para preservá-las.",
                                    "Confirme que ambos os AFNs aceitam corretamente exemplos de strings em L1 e L2."
                                  ],
                                  "verification": "Diagramas completos com rótulos corretos para estados iniciais/finais e transições; simulação bem-sucedida de pelo menos uma string por linguagem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de desenho (ex: Draw.io)",
                                    "Exemplos de AFNs para L1 e L2"
                                  ],
                                  "tips": "Use cores diferentes para M1 (azul) e M2 (verde) para facilitar a visualização da união.",
                                  "learningObjective": "Identificar e documentar precisamente os componentes estruturais de AFNs dados.",
                                  "commonMistakes": [
                                    "Confundir estados iniciais com finais",
                                    "Ignorar transições ε pré-existentes",
                                    "Assumir determinismo sem verificar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a estrutura base do AFN concatenado Mc",
                                  "subSteps": [
                                    "Crie a união dos estados: Qc = Q1 ∪ Q2, garantindo que os estados sejam renomeados se houver conflitos (ex: q1_i e q2_j).",
                                    "Defina o alfabeto Σc = Σ1 ∪ Σ2.",
                                    "Copie todas as transições δ1 de M1 e δ2 de M2 para δc, preservando ε-transições.",
                                    "Estabeleça o estado inicial de Mc como o estado inicial de M1 (q0_c = q0_1).",
                                    "Marque temporariamente os estados finais de Mc como os de M2 (Fc = F2)."
                                  ],
                                  "verification": "Diagrama unificado com todos os estados, transições copiadas corretamente e sem conflitos de nomes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama dos AFNs originais",
                                    "Software de desenho de autômatos"
                                  ],
                                  "tips": "Renomeie estados de M2 com prefixo '2_' para evitar sobreposições.",
                                  "learningObjective": "Construir a base não-determinística para composição de autômatos via união.",
                                  "commonMistakes": [
                                    "Perder transições durante a cópia",
                                    "Alterar acidentalmente estados iniciais/finais",
                                    "Ignorar renomeação de estados duplicados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar transições ε para conectar M1 e M2",
                                  "subSteps": [
                                    "Para cada estado final f em F1 de M1, adicione uma transição ε de f para o estado inicial q0_2 de M2.",
                                    "Atualize a função de transição δc para incluir essas novas ε-transições: δc(f, ε) inclui q0_2.",
                                    "Verifique que não há loops indesejados ou caminhos que ignorem a concatenação.",
                                    "Simule manualmente uma string w1 ∈ L1 seguida de w2 ∈ L2 para testar o caminho via ε.",
                                    "Ajuste o diagrama para destacar as novas transições ε em negrito ou cor vermelha."
                                  ],
                                  "verification": "Novas ε-transições adicionadas corretamente; simulação de concatenação w1w2 aceita por Mc.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama base de Mc",
                                    "Exemplos de strings w1 e w2"
                                  ],
                                  "tips": "Adicione ε-transições apenas de finais de M1 para inicial de M2, nunca no sentido inverso.",
                                  "learningObjective": "Implementar a conexão não-determinística essencial para fechamento sob concatenação.",
                                  "commonMistakes": [
                                    "Adicionar ε de M2 para M1",
                                    "Esquecer múltiplos estados finais em F1",
                                    "Criar ciclos via ε que aceitem strings inválidas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar a corretude do AFN Mc para L1 ⋅ L2",
                                  "subSteps": [
                                    "Prove que se w ∈ L(Mc), então w = w1 w2 com w1 ∈ L1 e w2 ∈ L2 (usando ε para transição).",
                                    "Prove o inverso: se w = w1 w2 com w1 ∈ L1 e w2 ∈ L2, então w ∈ L(Mc) (caminho via ε).",
                                    "Teste com strings que não estão em L1⋅L2 (ex: só w2 ou só w1) para confirmar rejeição.",
                                    "Formalize Mc = (Qc, Σc, δc, q0_1, F2) e verifique definição de AFN.",
                                    "Documente a prova em parágrafos curtos ou tabela de inclusão/mutualidade."
                                  ],
                                  "verification": "Prova escrita completa com ambos os sentidos; testes de aceitação/rejeição corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama final de Mc",
                                    "Strings de teste positivas e negativas"
                                  ],
                                  "tips": "Use indução sobre o comprimento da string para a prova formal.",
                                  "learningObjective": "Demonstrar matematicamente que Mc reconhece exatamente L1 ⋅ L2.",
                                  "commonMistakes": [
                                    "Provar apenas um sentido da equivalência",
                                    "Ignorar casos vazios (ε em L1 ou L2)",
                                    "Confundir aceitação com rejeição em testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere L1 = {a, aa}* (AFN M1 com loop em 'a' até final) e L2 = b (AFN M2 simples: inicial --b--> final). Construa Mc adicionando ε do final de M1 para inicial de M2. Mc aceita strings como εb, ab, aab, mas rejeita ba ou só a.",
                              "finalVerifications": [
                                "Conseguiu desenhar Mc corretamente sem erros de conexão.",
                                "Simulou com sucesso 3 strings em L1⋅L2 e 2 fora dela.",
                                "Escreveu prova bidirecional de L(Mc) = L1⋅L2.",
                                "Identificou e evitou erros comuns como ε reversas.",
                                "Explicou verbalmente o papel das ε-transições.",
                                "Aplicou o método a um exemplo próprio simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de estados e transições (30%)",
                                "Correção das ε-transições adicionadas (25%)",
                                "Completude e lógica da prova de corretude (25%)",
                                "Qualidade dos testes e simulações (10%)",
                                "Clareza dos diagramas e documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Demonstração por indução estrutural em linguagens formais.",
                                "Programação: Implementação de concatenação em engines de regex (ex: Python re module).",
                                "Lógica: Composição de relações binárias via produto cartesiano.",
                                "Engenharia de Software: Modelagem de fluxos sequenciais em autômatos de parsing."
                              ],
                              "realWorldApplication": "Em compiladores e analisadores léxicos (lexers), a concatenação de padrões regulares modela tokens sequenciais, como identificador seguido de operador em linguagens de programação, permitindo reconhecimento eficiente de código fonte."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Provar fechamento sob estrela de Kleene",
                            "description": "Construir um AFN para a estrela de Kleene de um conjunto regular, incorporando loops com transições ε para repetir zero ou mais vezes a linguagem original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de Conjuntos Regulares e Estrela de Kleene",
                                  "subSteps": [
                                    "Defina um conjunto regular como linguagem aceita por um AFN (Autômato Finito Não-determinístico).",
                                    "Explique a operação de estrela de Kleene L* como a união de L⁰ (ε), L¹, L², ..., incluindo repetições zero ou mais vezes.",
                                    "Identifique os componentes de um AFN: estados Q, alfabeto Σ, função de transição δ, estado inicial q₀, estados finais F.",
                                    "Discuta por que provar fechamento significa construir um AFN para L* dado um AFN para L.",
                                    "Desenhe um exemplo simples de AFN para um L básico, como L = {a}."
                                  ],
                                  "verification": "Liste corretamente os componentes do AFN e defina L* com ε incluído; desenhe um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Referência de livro de Teoria da Computação (ex: Sipser)"
                                  ],
                                  "tips": "Sempre inclua o caso vazio (ε) na estrela de Kleene para evitar omissões.",
                                  "learningObjective": "Compreender os pré-requisitos teóricos para a construção da prova.",
                                  "commonMistakes": [
                                    "Confundir AFD com AFN",
                                    "Esquecer que L* inclui a linguagem vazia",
                                    "Ignorar transições ε"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o AFN para L* a Partir do AFN de L",
                                  "subSteps": [
                                    "Crie um novo estado inicial e final i, que será tanto inicial quanto final.",
                                    "Adicione uma transição ε de i para o estado inicial q₀ do AFN original M de L.",
                                    "Para cada estado final f em F de M, adicione uma transição ε de f de volta para q₀.",
                                    "Mantenha todas as transições originais de M inalteradas.",
                                    "Descreva formalmente o novo autômato M*: Q' = Q ∪ {i}, δ' incluindo as novas ε-transições."
                                  ],
                                  "verification": "Desenhe o diagrama do novo AFN M* e liste todos os estados, transições e funções δ'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online (ex: draw.io)",
                                    "Papel para esboços"
                                  ],
                                  "tips": "Use setas curvas para loops ε de volta a q₀ para visualizar repetições.",
                                  "learningObjective": "Dominar a construção explícita do AFN para a estrela de Kleene.",
                                  "commonMistakes": [
                                    "Não tornar i um estado final",
                                    "Adicionar ε de i para estados errados",
                                    "Duplicar estados desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que M* Aceita Exatamente L*",
                                  "subSteps": [
                                    "Mostre que ε é aceito: caminho ε de i para i.",
                                    "Prove aceitação de w em L^n (n≥1) por indução: base n=1 via i-ε→q₀ ... →f-ε→q₀ ... n vezes de volta a i.",
                                    "Mostre que qualquer string aceita por M* está em L* (concatenação de palavras de L).",
                                    "Argumente que M* não aceita strings fora de L* (sem caminhos inválidos devido às ε-transições controladas).",
                                    "Verifique que M* é um AFN válido (finito, transições bem-definidas)."
                                  ],
                                  "verification": "Escreva uma prova por casos ou indução mostrando aceitação bidirecional (L* ⊆ L(M*) e L(M*) ⊆ L*).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel para prova escrita",
                                    "Exemplos de indução de livros-texto"
                                  ],
                                  "tips": "Use indução em n para repetições; desenhe caminhos para casos pequenos.",
                                  "learningObjective": "Capacitar a prova formal de correção da construção.",
                                  "commonMistakes": [
                                    "Falhar na indução para n≥2",
                                    "Ignorar concatenações vazias",
                                    "Confundir aceitação com geração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar a Prova com Exemplos",
                                  "subSteps": [
                                    "Aplique a construção a um exemplo concreto e teste strings em L*.",
                                    "Identifique potenciais ambiguidades no AFN e resolva com não-determinismo.",
                                    "Compare com propriedades conhecidas: L* é regular se L é.",
                                    "Discuta conversão opcional para AFD via powerset, mas enfatize que AFN basta.",
                                    "Resuma a prova em uma estrutura formal: construção + lembrete + teorema."
                                  ],
                                  "verification": "Teste o AFN construído com 3 strings: ε, uma de L, uma de L²; confirme aceitação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de AFN online (ex: JFLAP)",
                                    "Exemplo impresso de AFN"
                                  ],
                                  "tips": "Teste sempre com ε primeiro para validar o loop zero.",
                                  "learningObjective": "Consolidar a prova através de validação prática e exemplos.",
                                  "commonMistakes": [
                                    "Não testar ε",
                                    "Erros em concatenações múltiplas",
                                    "Assumir determinismo desnecessário"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado L = {ab} com AFN: q0 -a→ q1 -b→ q2 (final). Para L*: novo i (inicial/final) -ε→ q0; q2 -ε→ q0. Aceita ε (i), 'ab' (i-ε-q0-a-q1-b-q2-ε-q0 mas para uma vez até i via final), 'abab' (duas loops).",
                              "finalVerifications": [
                                "Construa corretamente o AFN M* para um L dado.",
                                "Prove aceitação de ε e de palavras em L^n por n≥1.",
                                "Identifique e corrija erros comuns na construção de ε-loops.",
                                "Explique por que a construção preserva regularidade.",
                                "Teste o AFN com strings específicas de L* e não-L*.",
                                "Escreva a prova formal em menos de 1 página."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção do AFN (todos componentes corretos: 30%)",
                                "Completude da prova de correção (incluindo ε e indução: 40%)",
                                "Clareza de diagramas e explicações (20%)",
                                "Tratamento de casos edge e erros comuns (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Regex em linguagens como Python (re module usa AFN internamente)",
                                "Matemática: Indução em teoria dos conjuntos e álgebra",
                                "Lógica: Provas formais semelhantes a tautologias em lógica proposicional",
                                "Engenharia de Software: Parsing e matching de padrões em compiladores"
                              ],
                              "realWorldApplication": "Essa propriedade fundamenta expressões regulares em editores de texto, validadores de formulários web e analisadores léxicos de compiladores, permitindo matching eficiente de padrões repetitivos como emails ou códigos postais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.4",
                            "name": "Provar fechamento sob complemento",
                            "description": "Demonstrar que o complemento de um conjunto regular é regular, utilizando a complementação de AFDs trocando estados de aceitação e convertendo AFNs para AFDs quando necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de AFD, Linguagem Regular e Complemento",
                                  "subSteps": [
                                    "Defina formalmente um AFD (Autômato Finito Determinístico) com quintupla (Q, Σ, δ, q0, F).",
                                    "Explique o que é uma linguagem regular: aceita por um AFD ou AFN.",
                                    "Defina o complemento de uma linguagem L sobre Σ* como Σ* - L.",
                                    "Discuta por que o complemento deve ser testado para aceitação por autômato finito.",
                                    "Liste propriedades conhecidas de AFDs: determinísticos, totais (transição para todo símbolo)."
                                  ],
                                  "verification": "Escreva as definições em um papel e confirme que o complemento de uma linguagem aceita por AFD é candidata a ser regular.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta; software JFLAP ou similar para visualização.",
                                  "tips": "Use diagramas para visualizar AFDs desde o início para fixar conceitos.",
                                  "learningObjective": "Compreender as bases teóricas necessárias para a prova de fechamento.",
                                  "commonMistakes": "Confundir AFN com AFD; esquecer que AFDs são totais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Autômato Complementar para um AFD",
                                  "subSteps": [
                                    "Dado um AFD M = (Q, Σ, δ, q0, F) aceitando L, crie M' = (Q, Σ, δ, q0, Q - F).",
                                    "Verifique que δ é a mesma função de transição.",
                                    "Prove que M' aceita exatamente o complemento: se w em L, rejeitado por M'; se w não em L, aceito por M'.",
                                    "Confirme que M' é um AFD válido (mesma estrutura).",
                                    "Teste com uma string de exemplo: trace o caminho em M e M'."
                                  ],
                                  "verification": "Construa M' para um AFD simples e teste 3 strings (uma aceita por M, uma rejeitada, uma vazia).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "JFLAP ou papel para desenhar autômatos; exemplos de AFDs impressos.",
                                  "tips": "Sempre trace strings passo a passo para validar.",
                                  "learningObjective": "Dominar a construção direta do complemento em AFDs.",
                                  "commonMistakes": "Esquecer de tornar a transição total ou inverter incorretamente os estados F."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender a Prova para AFNs via Conversão para AFD",
                                  "subSteps": [
                                    "Lembre que toda AFN tem equivalente AFD via construção de subconjuntos (potência do conjunto de estados).",
                                    "Dado AFN N aceitando L, construa AFD M equivalente.",
                                    "Aplique a complementação em M para obter M' aceitando complemento de L.",
                                    "Argumente que como M é AFD, M' é AFD, logo complemento é regular.",
                                    "Discuta eficiência: exponencial no pior caso, mas teoricamente finita."
                                  ],
                                  "verification": "Converta um AFN simples (com ε-transições) para AFD e aplique complementação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabela de subconjuntos para powerset; JFLAP para automação.",
                                  "tips": "Comece com AFN sem ε para simplificar; use powerset construction sistematicamente.",
                                  "learningObjective": "Integrar conversão AFN-AFD à prova de fechamento.",
                                  "commonMistakes": "Ignorar estados inacessíveis na powerset; confundir aceitação em AFN."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a Prova Completa e Verificar Propriedades",
                                  "subSteps": [
                                    "Escreva a prova formal: 'Se L regular, existe AFD M para L; M' é AFD para complemento(L)'.",
                                    "Para AFN: 'Construa AFD equivalente, depois complemento'.",
                                    "Verifique fechamento: operações preservam finitude de estados.",
                                    "Discuta implicações: união, concatenação, etc., seguem similarmente.",
                                    "Teste contra-contraprova: tente encontrar linguagem regular cujo complemento não seja."
                                  ],
                                  "verification": "Escreva a prova em parágrafos numerados e valide com professor ou peer.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto para prova; exemplos de linguagens regulares.",
                                  "tips": "Use teorema de Kleene para ligar a expressões regulares implicitamente.",
                                  "learningObjective": "Sintetizar a prova completa de fechamento sob complemento.",
                                  "commonMistakes": "Afirmar sem prova a equivalência AFN-AFD; pular verificação de determinismo."
                                }
                              ],
                              "practicalExample": "Considere L = {w em {0,1}* | w termina com 1}, AFD M com estados q0 (inicial/nãoF), q1 (F). Complemento: termina com 0. M': troque F para q0. Converta AFN equivalente (com não-determinismo em q0 para 0/1 -> q1/ε) via powerset para AFD, então complemente.",
                              "finalVerifications": [
                                "Consegui construir M' corretamente para um AFD dado.",
                                "Converti um AFN para AFD sem erros na powerset.",
                                "Testei strings aceitas/rejeitadas em M e M'.",
                                "Escrevi prova formal sem lacunas lógicas.",
                                "Verifiquei que M' aceita exatamente o complemento.",
                                "Discuti limitações computacionais (exponencialidade)."
                              ],
                              "assessmentCriteria": [
                                "Correção da construção de M': estados F invertidos corretamente.",
                                "Validade da conversão AFN-AFD: todos estados powerset gerados.",
                                "Rigor lógico da prova: indução ou construção explícita.",
                                "Testes com exemplos: pelo menos 3 strings validadas.",
                                "Clareza na explicação: diagramas e traces incluídos.",
                                "Compreensão de implicações: ligação com outras propriedades de fechamento."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: dualidade aceita/rejeita similar a negação proposicional.",
                                "Teoria da Computação: base para pumping lemma e não-regulares.",
                                "Programação: regex em linguagens como Python (re.compile) usam AFNs compilados.",
                                "Algoritmos: pattern matching em editores de texto."
                              ],
                              "realWorldApplication": "Em compiladores e analisadores léxicos (lexers), verificar se padrões regex cobrem todos inputs (complemento vazio); validação de protocolos de rede onde erros são complementos de tráfego válido; ferramentas de segurança para detectar padrões não-autorizados em logs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Teorema do Pumping para Linguagens Regulares",
                        "description": "Teorema que estabelece uma condição necessária para linguagens regulares, permitindo provar que certas linguagens não são regulares ao mostrar que não satisfazem a propriedade de 'pumping'.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Enunciar e provar o Teorema do Pumping",
                            "description": "Formalizar o teorema: para qualquer linguagem regular L, existe p tal que toda palavra w em L com |w| >= p pode ser dividida em xyz com |xy| <= p, |y| > 0 e xy^i z em L para todo i >= 0; provar usando a existência de AFD com número finito de estados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Autômatos Finitos Determinísticos (AFDs) e Linguagens Regulares",
                                  "subSteps": [
                                    "Defina o que é uma linguagem regular e sua equivalência com AFDs.",
                                    "Explique o conceito de número finito de estados em um AFD mínimo.",
                                    "Descreva o processo de aceitação de uma palavra por um AFD.",
                                    "Discuta o princípio do pombo (pigeonhole principle) aplicado a estados.",
                                    "Revise exemplos simples de linguagens regulares e seus AFDs."
                                  ],
                                  "verification": "Construa um AFD simples para uma linguagem regular dada e identifique o número de estados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 1)",
                                    "Notas de aula sobre AFDs",
                                    "Simulador de autômatos online como JFLAP"
                                  ],
                                  "tips": "Desenhe o AFD em papel para visualizar estados e transições claramente.",
                                  "learningObjective": "Compreender a estrutura finita dos AFDs como base para a prova do teorema.",
                                  "commonMistakes": [
                                    "Confundir AFD com AFN",
                                    "Ignorar estados inalcançáveis ou não mínimos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar Formalmente o Teorema do Pumping para Linguagens Regulares",
                                  "subSteps": [
                                    "Estabeleça as condições: Para L regular, existe p tal que para toda w ∈ L com |w| ≥ p, w = xyz onde |xy| ≤ p, |y| > 0.",
                                    "Especifique a propriedade de pumping: xy^i z ∈ L para todo i ≥ 0.",
                                    "Diferencie do teorema para linguagens livres de contexto.",
                                    "Escreva o teorema em notação matemática precisa.",
                                    "Memorize e recite o enunciado de cor."
                                  ],
                                  "verification": "Escreva o teorema completo em um papel sem consultar materiais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Referência formal do teorema (Sipser, p. 70)"
                                  ],
                                  "tips": "Use símbolos LaTeX ou notação clara para evitar ambiguidades em comprimentos.",
                                  "learningObjective": "Dominar o enunciado exato para evitar erros na prova.",
                                  "commonMistakes": [
                                    "Esquecer |xy| ≤ p",
                                    "Permitir |y| = 0",
                                    "Confundir com versão para CFLs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Prova do Teorema Usando o Princípio do Pombo",
                                  "subSteps": [
                                    "Dado L regular, construa um AFD M com q estados; defina p = q.",
                                    "Para w ∈ L, |w| ≥ p, considere o caminho de computação δ(q0, w).",
                                    "Pelo princípio do pombo, nos primeiros p+1 prefixos, dois prefixos x1 e x2 levam ao mesmo estado r, com |x1| ≤ p.",
                                    "Defina y = x2 - x1 (loop), x = x1, z = resto de w.",
                                    "Prove que xy^i z é aceito para i ≥ 0 bombeando o loop."
                                  ],
                                  "verification": "Escreva a prova completa passo a passo e verifique cada inferência lógica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "JFLAP para simular caminhos",
                                    "Sipser Capítulo 1.4"
                                  ],
                                  "tips": "Desenhe o grafo do AFD e marque os prefixos com pigeonhole.",
                                  "learningObjective": "Executar a prova formal usando finitude de estados.",
                                  "commonMistakes": [
                                    "Definir p incorretamente",
                                    "Não garantir |xy| ≤ p",
                                    "Erros em indução para i>1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a Prova e Aplicar a Exemplos Simples",
                                  "subSteps": [
                                    "Teste a prova em uma linguagem regular como L = (ab)*.",
                                    "Encontre p, divida uma w longa em xyz e verifique pumping.",
                                    "Analise o que acontece se L não for regular (contraste com {a^n b^n}).",
                                    "Discuta generalizações e limitações do teorema.",
                                    "Resuma a prova em suas próprias palavras."
                                  ],
                                  "verification": "Aplique o teorema a duas linguagens regulares diferentes com sucesso.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplos de linguagens regulares",
                                    "Ferramenta de regex online"
                                  ],
                                  "tips": "Escolha palavras w longas para forçar pigeonhole.",
                                  "learningObjective": "Consolidar a compreensão através de aplicação prática.",
                                  "commonMistakes": [
                                    "Escolher linguagens não-regulares para teste",
                                    "Não verificar i=0 e i=2"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere L = (a|b)*a, uma linguagem regular (palavras terminando em a). AFD tem 2 estados. p=2. Tome w = 'baaa' (|w|=4≥2). Prefixos: ε→q0, b→q1, ba→q0, baa→q1, baaa→q0 (aceito). Prefixos 1-3: b, ba, baa levam q1,q0,q1 → y='aa' (de ba a baa, mesmo q1), x='b', z='a'. xy^i z = b (aa)^i a ∈ L para todo i.",
                              "finalVerifications": [
                                "Enuncie o teorema sem erros.",
                                "Explique o papel do número de estados na escolha de p.",
                                "Aplique pigeonhole a um exemplo específico.",
                                "Prove que xy^0 z = xz ∈ L.",
                                "Identifique por que o teorema falha para não-regulares.",
                                "Resuma a prova em 5 frases."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado formal (100% correto).",
                                "Lógica impecável na aplicação de pigeonhole.",
                                "Correta identificação de x, y, z satisfazendo condições.",
                                "Verificação completa para múltiplos i.",
                                "Uso apropriado de notação matemática.",
                                "Explicação clara de cada passo da prova.",
                                "Aplicação correta a exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Princípio do pombo e indução.",
                                "Lógica: Estruturas formais e provas por contradição.",
                                "Programação: Regex em linguagens como Python (re module).",
                                "Compiladores: Análise léxica e autômatos.",
                                "Algoritmos: Análise de complexidade em autômatos."
                              ],
                              "realWorldApplication": "No desenvolvimento de compiladores e analisadores léxicos (ex: flex/yacc), o teorema garante que padrões regex (regulares) podem ser processados eficientemente sem 'explosão' em palavras longas, permitindo validação de tokens em código-fonte, protocolos de rede e expressões de busca em motores de busca."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Aplicar o teorema para provar não-regularidade",
                            "description": "Usar o teorema do pumping para demonstrar que linguagens como {a^n b^n | n >= 0} não são regulares, escolhendo palavras adequadas e mostrando contradição nas condições de pumping.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar e enunciar precisamente o Teorema do Pumping",
                                  "subSteps": [
                                    "Leia a declaração formal do teorema do pumping para linguagens regulares.",
                                    "Identifique os componentes chave: comprimento de bombeamento p, divisão w = xyz com |xy| ≤ p, |y| ≥ 1, e xy^i z ∈ L para todo i ≥ 0.",
                                    "Escreva o teorema em suas próprias palavras para internalizar.",
                                    "Verifique se entende que é uma propriedade de 'não-regularidade por contradição'.",
                                    "Compare com exemplos simples para fixar."
                                  ],
                                  "verification": "Escreva o teorema corretamente sem consultar materiais e identifique todos os componentes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Livro de Teoria da Computação ou notas de aula sobre linguagens formais",
                                  "tips": "Enfatize as condições |xy| ≤ p e |y| ≥ 1, pois são cruciais para restrições na posição de y.",
                                  "learningObjective": "Compreender a declaração exata do teorema do pumping e suas implicações para prova por contradição.",
                                  "commonMistakes": "Confundir com o lemma de Ogden ou esquecer que é para i ≥ 0, incluindo i=0 e i=2."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher o comprimento de bombeamento p e uma palavra w adequada",
                                  "subSteps": [
                                    "Assuma que L é regular, logo existe p dado pelo lemma.",
                                    "Escolha w ∈ L com |w| ≥ p, preferencialmente simples como w = a^p b^p para L = {a^n b^n | n ≥ 0}.",
                                    "Justifique por que essa w é boa: balanceada e longa o suficiente.",
                                    "Calcule |w| = 2p ≥ p.",
                                    "Anote p como variável para generalidade."
                                  ],
                                  "verification": "Confirme que w ∈ L e |w| ≥ p, e explique por que é representativa da estrutura de L.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto para anotar w",
                                  "tips": "Sempre escolha w que capture a 'essência não-regular' de L, como dependência de contagem igual.",
                                  "learningObjective": "Selecionar uma palavra w que force uma contradição ao revelar dependências não-capturáveis por autômatos finitos.",
                                  "commonMistakes": "Escolher w muito curta (|w| < p) ou não em L, como a^{p-1} b^p."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Assumir a decomposição xyz válida pelo lemma",
                                  "subSteps": [
                                    "Pelo lemma, w = xyz com |xy| ≤ p, |y| ≥ 1.",
                                    "Note que, como w = a^p b^p, os primeiros p símbolos são a's, então x e y consistem apenas em a's.",
                                    "Denote |x| = i, |y| = j ≥ 1, com i + j ≤ p.",
                                    "Escreva w = x y z = a^i a^j a^{p - i - j} b^p.",
                                    "Verifique que z começa com o resto dos a's e todos os b's."
                                  ],
                                  "verification": "Desenhe a decomposição e confirme que satisfaz |xy| ≤ p e |y| ≥ 1, com y apenas em a's.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para diagramar w = xyz",
                                  "tips": "Visualize w como uma string longa de a's seguida de b's; y não pode alcançar os b's devido a |xy| ≤ p.",
                                  "learningObjective": "Aplicar as restrições do lemma para delimitar possíveis posições de y.",
                                  "commonMistakes": "Ignorar |xy| ≤ p e permitir y nos b's ou cruzando a^{p} b^{p}."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Bombear a palavra (i=0 e i=2) e verificar não-membresia em L",
                                  "subSteps": [
                                    "Para i=2: xy^2 z = a^i (a^j)^2 a^{p-i-j} b^p = a^{p + j} b^p, onde número de a's > b's.",
                                    "Confirme que a^{p+j} b^p ∉ L pois p+j > p.",
                                    "Para i=0: x z = a^i a^{p-i-j} b^p = a^{p - j} b^p, onde a's < b's pois j ≥ 1.",
                                    "Confirme que a^{p-j} b^p ∉ L pois p-j < p.",
                                    "Ambos xy^i z ∉ L, violando o lemma."
                                  ],
                                  "verification": "Calcule explicitamente xy^0 z e xy^2 z e prove que não estão em L.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou editor para manipular expoentes",
                                  "tips": "Use i=0 para remover y e i=2 para duplicar; isso cobre os casos críticos.",
                                  "learningObjective": "Demonstrar que o bombeamento distorce o equilíbrio de a's e b's, saindo de L.",
                                  "commonMistakes": "Esquecer que |y| ≥ 1 garante mudança no comprimento, ou calcular errado os expoentes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir a contradição e afirmar não-regularidade",
                                  "subSteps": [
                                    "Resuma: assumimos regular → existe p → w → xyz → mas xy^i z ∉ L para i=0,2 → contradição.",
                                    "Afirme: logo L não é regular.",
                                    "Discuta generalidade: funciona para qualquer decomposição possível.",
                                    "Compare com prova para outras linguagens como {a^n b^n c^n}.",
                                    "Reflita sobre limitações do lemma (não prova regularidade)."
                                  ],
                                  "verification": "Escreva a conclusão formal e verifique ausência de falhas lógicas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Resumo em papel",
                                  "tips": "A contradição é por absurdo: hipótese leva a falso, logo hipótese falsa.",
                                  "learningObjective": "Finalizar a prova por contradição e reconhecer o poder do lemma.",
                                  "commonMistakes": "Não cobrir todos os i ou falhar em generalizar para qualquer xyz válida."
                                }
                              ],
                              "practicalExample": "Para L = {a^n b^n | n ≥ 0}, assuma regular com p=3. Escolha w = aaabbb (|w|=6≥3). Por |xy|≤3, y em a's. Bombeie: i=2 adiciona a's → aaaabbb ∉ L; i=0 remove a's → abbb ∉ L. Contradição!",
                              "finalVerifications": [
                                "Pode enunciar o teorema do pumping sem erros?",
                                "Escolheu w correta com |w| ≥ p e w ∈ L?",
                                "Demonstrou que todos xy^i z ∉ L para i=0 e i=2?",
                                "Identificou corretamente que y está apenas nos a's devido a |xy| ≤ p?",
                                "Concluiu logicamente a não-regularidade por contradição?",
                                "Explicou por que a prova funciona para qualquer decomposição?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na declaração do teorema (todos componentes corretos).",
                                "Escolha adequada de w que captura dependência não-regular.",
                                "Análise exaustiva das condições de decomposição (|xy|≤p, |y|≥1).",
                                "Cálculos corretos de bombeamento mostrando ∉ L.",
                                "Lógica de contradição clara e sem falhas.",
                                "Clareza na escrita e diagramas de xyz."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio do pombo (pigeonhole) subjacente ao lemma.",
                                "Lógica: Provas por contradição e absurdum.",
                                "Programação: Limitações de expressões regulares em parsers (ex: grep vs. balanced parentheses).",
                                "Filosofia da Computação: Hierarquia de Chomsky e complexidade.",
                                "Engenharia de Software: Análise de complexidade em verificadores de linguagens."
                              ],
                              "realWorldApplication": "Em compiladores e analisadores léxicos, prova que certas estruturas (como parênteses balanceados ou {ww | w ∈ {a,b}*}) exigem parsers não-regulares (pushdown automata), guiando escolhas de ferramentas como ANTLR ou regex engines limitadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Autômatos Finitos Determinísticos (AFD)",
                    "description": "Estrutura formal, transição, aceitação de linguagens e construção a partir de expressões regulares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Estrutura Formal do Autômato Finito Determinístico (AFD)",
                        "description": "Definição formal de um AFD como um quintupla (Q, Σ, δ, q0, F), onde Q é o conjunto finito de estados, Σ é o alfabeto, δ é a função de transição, q0 é o estado inicial e F é o conjunto de estados de aceitação.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Identificar os componentes de um AFD",
                            "description": "Dado um AFD descrito em texto ou diagrama, listar e explicar cada componente da quintupla formal (Q, Σ, δ, q0, F), identificando exemplos concretos para cada um.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Formal da Quintupla de um AFD",
                                  "subSteps": [
                                    "Ler e memorizar a definição: Um AFD é uma quintupla A = (Q, Σ, δ, q0, F)",
                                    "Explicar verbalmente o significado de cada componente: Q (conjunto finito de estados), Σ (alfabeto), δ (função de transição), q0 (estado inicial), F (conjunto de estados finais)",
                                    "Escrever a quintupla em um papel e rotular cada parte",
                                    "Comparar com exemplos simples de diagramas de AFD",
                                    "Listar as propriedades de cada componente (ex: Q é finito, δ é total)"
                                  ],
                                  "verification": "Escrever corretamente a quintupla e definir cada componente em uma frase curta para cada um",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de exemplo de AFD impresso ou digital"
                                  ],
                                  "tips": "Use mnemônicos como 'Estados, Símbolos, Transições, Inicial, Finais' para lembrar a ordem",
                                  "learningObjective": "Dominar a estrutura formal da quintupla e suas notações padrão",
                                  "commonMistakes": [
                                    "Confundir a ordem dos componentes",
                                    "Achar que Σ inclui o estado vazio",
                                    "Esquecer que Q deve ser finito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os Estados (Q), Estado Inicial (q0) e Estados Finais (F)",
                                  "subSteps": [
                                    "No diagrama ou texto, localizar círculos ou labels como 'q0', 'q1' para Q",
                                    "Marcar o estado com seta de entrada ou '* ' como q0",
                                    "Identificar estados duplamente circulados ou marcados como F",
                                    "Listar Q = {q0, q1, ...}, especificar q0 e F ⊆ Q",
                                    "Verificar se todos os estados listados aparecem nas transições"
                                  ],
                                  "verification": "Extrair e listar Q, q0 e F de um diagrama dado, justificando cada escolha",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de AFD exemplo",
                                    "Marcadores coloridos"
                                  ],
                                  "tips": "Use cores diferentes: azul para Q, verde para q0, vermelho para F",
                                  "learningObjective": "Reconhecer visual e textualmente os componentes de estados em representações de AFD",
                                  "commonMistakes": [
                                    "Incluir estados não alcançáveis em Q",
                                    "Confundir estados finais com iniciais",
                                    "Listar estados duplicados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar o Alfabeto (Σ) e a Função de Transição (δ)",
                                  "subSteps": [
                                    "Listar todos os símbolos nas arestas de transições para formar Σ",
                                    "Para δ, anotar cada transição como δ(q, a) = p para cada q em Q e a em Σ",
                                    "Verificar se δ é total: para todo q e a, existe exatamente uma transição",
                                    "Representar δ em tabela ou lista de pares (q, a) -> p",
                                    "Explicar como δ define o comportamento do autômato"
                                  ],
                                  "verification": "Construir a tabela de transição δ completa e listar Σ corretamente de um AFD dado",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela em branco para δ",
                                    "Exemplo textual de AFD"
                                  ],
                                  "tips": "Comece pelas transições saindo de q0 para garantir completude",
                                  "learningObjective": "Mapear com precisão o alfabeto e todas as transições dinâmicas do AFD",
                                  "commonMistakes": [
                                    "Omitir símbolos de Σ",
                                    "Deixar transições indefinidas",
                                    "Confundir δ com estados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Explicar Todos os Componentes com um Exemplo Completo",
                                  "subSteps": [
                                    "Montar a quintupla completa: (Q, Σ, δ, q0, F) usando dados extraídos",
                                    "Explicar como cada componente interage (ex: δ usa Q e Σ para mover de q0 a F)",
                                    "Simular uma string curta no AFD, traçando o caminho",
                                    "Identificar erros potenciais na extração e corrigi-los",
                                    "Escrever um parágrafo resumindo os componentes com exemplos concretos"
                                  ],
                                  "verification": "Apresentar a quintupla extraída, simular uma aceitação/rejeição e explicar cada parte",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de AFD complexo",
                                    "Simulador online de AFD (opcional)"
                                  ],
                                  "tips": "Simule pelo menos duas strings: uma aceita e uma rejeitada",
                                  "learningObjective": "Sintetizar todos os componentes em uma análise coesa e explicativa",
                                  "commonMistakes": [
                                    "Inconsistências entre δ e Q/Σ",
                                    "Explicações vagas sem exemplos",
                                    "Ignorar estados inacessíveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o AFD para strings binárias terminando em '0': Q = {q0, q1}, Σ = {0,1}, q0 = q0 (inicial), F = {q1}, δ: δ(q0,0)=q1, δ(q0,1)=q0, δ(q1,0)=q1, δ(q1,1)=q0. Identifique: Q pelos nós, Σ pelas labels, etc. Simule '10': q0 -1-> q0 -0-> q1 (aceito).",
                              "finalVerifications": [
                                "Lista corretamente os 5 componentes da quintupla sem omissões",
                                "Explica cada componente com um exemplo concreto do AFD dado",
                                "Constrói tabela de δ completa e verifica totalidade",
                                "Simula corretamente o processamento de uma string de entrada",
                                "Identifica inconsistências como transições faltantes",
                                "Distingue claramente representações diagramáticas e textuais"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de Q, Σ, δ, q0, F (100% correto)",
                                "Explicações claras e concisas para cada componente (mínimo 1 frase por)",
                                "Completude da função δ (todas as combinações q,a cobertas)",
                                "Uso correto de exemplos concretos e simulações",
                                "Ausência de erros comuns como confusão de estados ou símbolos indefinidos",
                                "Capacidade de integrar componentes em análise coesa"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conjuntos finitos (Q, Σ, F) e funções totais (δ)",
                                "Programação: Estados como variáveis em máquinas de estado finitas (ex: switch-case)",
                                "Lógica: Transições como regras if-then em raciocínio dedutivo",
                                "Engenharia de Software: Validação de inputs em compiladores e parsers"
                              ],
                              "realWorldApplication": "Em compiladores (lexers analisam tokens), validadores de protocolos de rede (ex: HTTP states), autocompletar em editores de texto e sistemas de controle embarcado (ex: máquinas vending detectando moedas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Representar um AFD em notação formal",
                            "description": "Converter uma descrição informal ou diagrama de um AFD em sua representação matemática precisa como quintupla, especificando δ como uma tabela ou função total.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a descrição ou diagrama para identificar componentes básicos",
                                  "subSteps": [
                                    "Leia atentamente a descrição informal ou examine o diagrama do AFD.",
                                    "Identifique todos os estados (círculos ou labels como q0, q1, etc.).",
                                    "Determine o alfabeto Σ (símbolos de entrada nas setas).",
                                    "Marque o estado inicial (geralmente com seta de entrada ou seta dupla).",
                                    "Identifique os estados finais (círculos duplos ou marcados com F)."
                                  ],
                                  "verification": "Crie uma lista anotada com Q preliminar, Σ, q0 e F extraídos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Descrição ou diagrama do AFD",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": [
                                    "Use cores para diferenciar estados iniciais e finais.",
                                    "Conte o número de estados para evitar omissões."
                                  ],
                                  "learningObjective": "Extrair precisamente os elementos constitutivos de uma representação informal de AFD.",
                                  "commonMistakes": [
                                    "Confundir estados transitórios com finais.",
                                    "Ignorar símbolos implícitos no alfabeto."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir formalmente os conjuntos Q, Σ, q0 e F",
                                  "subSteps": [
                                    "Liste Q como conjunto finito de estados identificados (ex: Q = {q0, q1, q2}).",
                                    "Defina Σ como o conjunto de todos os símbolos de transição (ex: Σ = {0, 1}).",
                                    "Especifique q0 como o estado inicial único.",
                                    "Defina F ⊆ Q como os estados finais.",
                                    "Verifique se Q é finito e não vazio, e Σ é finito e não vazio."
                                  ],
                                  "verification": "Escreva as definições em notação de conjunto e confirme com a descrição original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista do Step 1",
                                    "Folha de rascunho para conjuntos"
                                  ],
                                  "tips": [
                                    "Use chaves {} para notação de conjuntos.",
                                    "Garanta que q0 ∈ Q e F ⊆ Q."
                                  ],
                                  "learningObjective": "Formalizar os componentes estáticos da quintupla do AFD usando teoria dos conjuntos.",
                                  "commonMistakes": [
                                    "Incluir estados não alcançáveis em Q.",
                                    "Esquecer símbolos no Σ."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a função de transição δ como tabela ou função total",
                                  "subSteps": [
                                    "Crie uma tabela com linhas para cada estado em Q e colunas para cada símbolo em Σ.",
                                    "Preencha cada célula com o estado de destino para δ(q, a).",
                                    "Garanta que δ seja total: toda entrada Q × Σ tenha um único estado de saída.",
                                    "Se diagrama incompleto, infira transições para 'armadilha' ou estado sink.",
                                    "Converta a tabela em notação funcional se preferido (ex: δ(q0, 0) = q1)."
                                  ],
                                  "verification": "Verifique se a tabela tem |Q| linhas e |Σ| colunas, todas preenchidas sem ambiguidades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em Excel ou papel quadriculado",
                                    "Descrição/diagrama original"
                                  ],
                                  "tips": [
                                    "Comece pelas transições explícitas.",
                                    "Adicione estado sink para totalidade se necessário."
                                  ],
                                  "learningObjective": "Representar δ de forma precisa e total, garantindo determinismo.",
                                  "commonMistakes": [
                                    "Deixar células vazias (não total).",
                                    "Transições não determinísticas (múltiplos destinos)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a quintupla completa e validar a representação",
                                  "subSteps": [
                                    "Escreva a quintupla: (Q, Σ, δ, q0, F).",
                                    "Inclua a definição explícita de δ (tabela ou função).",
                                    "Simule 2-3 strings curtas para verificar se o AFD aceita/rejeita corretamente.",
                                    "Confirme propriedades: δ: Q × Σ → Q, determinístico e total.",
                                    "Compare com a descrição original para fidelidade."
                                  ],
                                  "verification": "A quintupla reproduz exatamente o comportamento do diagrama/descrição.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Elementos dos steps anteriores",
                                    "Simulador de AFD online opcional"
                                  ],
                                  "tips": [
                                    "Teste strings aceitas e rejeitadas.",
                                    "Leia em voz alta a quintupla para checar."
                                  ],
                                  "learningObjective": "Sintetizar todos os componentes em uma representação matemática precisa e verificável.",
                                  "commonMistakes": [
                                    "Ordem errada da quintupla.",
                                    "δ não total ou inconsistente com diagrama."
                                  ]
                                }
                              ],
                              "practicalExample": "Descrição: AFD sobre Σ={0,1} que aceita strings terminando em '01'. Diagrama: q0 --0--> q0, q0 --1--> q1, q1 --0--> q2, q1 --1--> q1, q2 sink para 0/1. Quintupla: Q={q0,q1,q2}, Σ={0,1}, δ(q0,0)=q0, δ(q0,1)=q1, δ(q1,0)=q2, δ(q1,1)=q1, δ(q2,0)=q2, δ(q2,1)=q2, q0, F={q2}. Tabela: | 0 | 1 |\nq0| q0| q1|\nq1| q2| q1|\nq2| q2| q2|.",
                              "finalVerifications": [
                                "Quintupla possui exatamente 5 elementos: (Q, Σ, δ, q0, F)?",
                                "δ é total (definida para todo par estado-símbolo)?",
                                "Transições reproduzem fielmente o diagrama/descrição?",
                                "Simulação de string aceita termina em F?",
                                "Simulação de string rejeitada não termina em F?",
                                "Notação usa conjuntos corretos e função precisa?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de Q, Σ, q0 e F (20%)",
                                "Construção correta e total de δ (30%)",
                                "Formato matemático rigoroso da quintupla (20%)",
                                "Verificação por simulação de traços (20%)",
                                "Ausência de erros comuns como não-determinismo (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções totais",
                                "Lógica: Máquinas de estados finitos como circuitos lógicos",
                                "Programação: Implementação de FSM em código (switch cases)",
                                "Engenharia de Software: Modelagem de parsers e validadores"
                              ],
                              "realWorldApplication": "Usado em compiladores para análise léxica (ex: tokenização de código), validação de protocolos de rede (ex: checksums em pacotes), interfaces de usuário (ex: validação de formulários regex-like) e sistemas embarcados para controle de estados finitos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Construir diagramas de transição para AFDs simples",
                            "description": "Desenhar o grafo de estados de um AFD dado sua definição formal, garantindo que todas as transições sejam representadas com rótulos do alfabeto e que o determinismo seja mantido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Definição Formal do AFD",
                                  "subSteps": [
                                    "Identifique o conjunto de estados Q.",
                                    "Liste o alfabeto Σ.",
                                    "Anote a função de transição δ para cada par (estado, símbolo).",
                                    "Marque o estado inicial q0 e os estados finais F."
                                  ],
                                  "verification": "Criar uma tabela ou lista com todos os componentes extraídos corretamente da definição formal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Definição formal do AFD fornecida"
                                  ],
                                  "tips": "Use cores diferentes para estados iniciais e finais durante a anotação.",
                                  "learningObjective": "Compreender e extrair precisamente os cinco componentes da tupla formal de um AFD.",
                                  "commonMistakes": [
                                    "Confundir estados finais com o inicial",
                                    "Omitir transições para alguns símbolos do alfabeto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar os Estados e Elementos Básicos",
                                  "subSteps": [
                                    "Desenhe círculos para cada estado em Q, posicionando q0 à esquerda.",
                                    "Rotule cada círculo com o nome do estado.",
                                    "Marque o estado inicial com uma seta de entrada sem origem.",
                                    "Preencha ou circule os estados em F para destacá-los."
                                  ],
                                  "verification": "Verificar se todos os estados estão representados, com marcações corretas para inicial e finais.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha"
                                  ],
                                  "tips": "Posicione estados próximos para evitar cruzamentos desnecessários de setas.",
                                  "learningObjective": "Representar visualmente a estrutura de estados de um AFD de forma clara e padronizada.",
                                  "commonMistakes": [
                                    "Esquecer de marcar o estado inicial",
                                    "Usar rótulos incorretos nos estados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar Transições com Rótulos",
                                  "subSteps": [
                                    "Para cada estado q em Q e símbolo a em Σ, desenhe uma seta de q para δ(q,a) rotulada com 'a'.",
                                    "Agrupe transições idênticas com setas múltiplas rotuladas (ex: 0,1).",
                                    "Garanta que não haja ambiguidades nos rótulos.",
                                    "Verifique se todas as transições da função δ foram incluídas."
                                  ],
                                  "verification": "Contar o número de transições desenhadas e comparar com o tamanho de Q x Σ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Régua para setas retas",
                                    "Marcadores coloridos para símbolos diferentes"
                                  ],
                                  "tips": "Desenhe setas curvas se necessário para clareza, evitando sobreposições.",
                                  "learningObjective": "Mapear corretamente a função de transição δ no diagrama gráfico.",
                                  "commonMistakes": [
                                    "Duplicar transições para o mesmo (q,a)",
                                    "Omitir transições para símbolos específicos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Determinismo e Completude",
                                  "subSteps": [
                                    "Confirme que para cada (q,a) há exatamente uma transição saindo de q rotulada a.",
                                    "Verifique se o grafo é completo (transições para todo Σ de todo estado).",
                                    "Teste o diagrama com uma string curta do alfabeto para simular execução.",
                                    "Ajuste qualquer erro encontrado."
                                  ],
                                  "verification": "Simular a aceitação/rejeição de 2-3 strings curtas usando o diagrama.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos de strings de teste"
                                  ],
                                  "tips": "Use uma tabela de transição ao lado do diagrama para dupla verificação.",
                                  "learningObjective": "Garantir que o diagrama reflita fielmente as propriedades determinísticas de um AFD.",
                                  "commonMistakes": [
                                    "Permitir transições não-determinísticas",
                                    "Ignorar transições para sink states"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado o AFD M = (Q={q0,q1,q2}, Σ={0,1}, δ onde δ(q0,0)=q0, δ(q0,1)=q1, δ(q1,0)=q2, δ(q1,1)=q1, δ(q2,0)=q2, δ(q2,1)=q2, q0, F={q0}): Desenhe o diagrama com q0 inicial, loop em q0 para 0, transição para q1 em 1, loop em q1 para 1, para q2 em 0, e sink em q2. O diagrama deve ter setas rotuladas corretamente sem ambiguidades.",
                              "finalVerifications": [
                                "Todos os estados de Q estão presentes e rotulados.",
                                "Estado inicial marcado com seta de entrada e estados finais destacados.",
                                "Exatamente |Q| x |Σ| transições únicas representadas.",
                                "Nenhuma transição ambígua ou não-determinística.",
                                "Diagrama é legível, sem cruzamentos confusos.",
                                "Simulação com strings de teste confirma comportamento do AFD."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação de δ (100% das transições corretas).",
                                "Clareza visual e legibilidade do diagrama (rótulos visíveis, setas nítidas).",
                                "Manutenção do determinismo (uma transição por (q,a)).",
                                "Completude (todas combinações cobertas).",
                                "Correta identificação de q0 e F.",
                                "Ausência de erros lógicos detectados em simulações."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Representação de autômatos como grafos direcionados rotulados.",
                                "Matemática Discreta: Funções de transição como relações binárias.",
                                "Lógica Digital: Máquinas de estados finitos em circuitos sequenciais.",
                                "Programação: Implementação de FSMs em código para parsers simples."
                              ],
                              "realWorldApplication": "Em compiladores, diagramas de AFDs são usados em analisadores léxicos (lexers) para reconhecer padrões regulares em código-fonte, como identificadores ou números, otimizando o processamento de linguagens de programação."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Função de Transição e Processamento de Cadeias",
                        "description": "Operação da função de transição δ: Q × Σ → Q aplicada sequencialmente a uma cadeia de entrada w ∈ Σ*, computando o estado final a partir do inicial.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Calcular a sequência de estados para uma cadeia",
                            "description": "Dado um AFD e uma cadeia w, aplicar δ estendida passo a passo para determinar a sequência de estados visitados e o estado final, ilustrando com exemplos numéricos ou simbólicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e representar os componentes do AFD e da cadeia",
                                  "subSteps": [
                                    "Liste os estados Q, o alfabeto Σ, o estado inicial q₀ e os estados finais F.",
                                    "Escreva a função de transição δ em forma tabular ou diagrama.",
                                    "Anote a cadeia w = a₁a₂...aₙ, verificando que cada aᵢ ∈ Σ.",
                                    "Confirme que o AFD está completo (transições definidas para todos pares estado-símbolo).",
                                    "Desenhe o diagrama de estados se não fornecido."
                                  ],
                                  "verification": "Componentes do AFD e w listados corretamente em uma tabela ou diagrama anotado.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de desenho como Draw.io",
                                    "Definição formal do AFD"
                                  ],
                                  "tips": [
                                    "Use uma tabela δ(q, a) para clareza em AFDs grandes.",
                                    "Numere os símbolos de w para rastreamento fácil."
                                  ],
                                  "learningObjective": "Representar precisamente o AFD e a entrada para processamento.",
                                  "commonMistakes": [
                                    "Omitir transições indefinidas.",
                                    "Confundir q₀ com estados finais.",
                                    "Incluir símbolos fora de Σ em w."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a sequência no estado inicial e processar o primeiro símbolo",
                                  "subSteps": [
                                    "Defina o estado atual q_current = q₀.",
                                    "Inicie a sequência de estados: seq = [q₀].",
                                    "Se w é vazia, seq = [q₀] e pare.",
                                    "Caso contrário, aplique q_next = δ(q_current, a₁), adicione q_next a seq.",
                                    "Atualize q_current = q_next."
                                  ],
                                  "verification": "Sequência inicia com [q₀, δ(q₀, a₁)] e transição anotada.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de transição δ",
                                    "Cadeia w anotada"
                                  ],
                                  "tips": [
                                    "Anote cada aplicação de δ com setas: q₀ --a₁--> q_next.",
                                    "Verifique δ duas vezes para precisão."
                                  ],
                                  "learningObjective": "Aplicar corretamente a transição inicial da δ estendida.",
                                  "commonMistakes": [
                                    "Pular o estado inicial na sequência.",
                                    "Usar δ errada para o primeiro símbolo.",
                                    "Tratar w vazia incorretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar os símbolos restantes iterativamente",
                                  "subSteps": [
                                    "Para cada símbolo aᵢ (i=2 a n): q_next = δ(q_current, aᵢ).",
                                    "Adicione q_next à sequência seq.",
                                    "Atualize q_current = q_next.",
                                    "Registre cada transição: q_current --aᵢ--> q_next.",
                                    "Continue até processar todos os símbolos de w."
                                  ],
                                  "verification": "Sequência completa seq = [q₀, q₁, ..., qₙ] com todas transições documentadas.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Sequência parcial",
                                    "Tabela δ atualizada com marcações"
                                  ],
                                  "tips": [
                                    "Processe um símbolo por vez, verbalizando a transição.",
                                    "Use cores diferentes para estados visitados."
                                  ],
                                  "learningObjective": "Executar iterações da δ estendida sem erros acumulativos.",
                                  "commonMistakes": [
                                    "Perder um símbolo no meio de w.",
                                    "Reutilizar estado anterior incorretamente.",
                                    "Confundir ordem dos símbolos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar a sequência, estado final e verificar aceitação",
                                  "subSteps": [
                                    "Identifique o estado final q_final = último da seq.",
                                    "Verifique se q_final ∈ F para aceitação.",
                                    "Escreva a sequência completa: q₀ ⊢ a₁ q₁ ⊢ a₂ ... ⊢ aₙ q_final.",
                                    "Confirme que seq tem n+1 estados para |w|=n.",
                                    "Teste com variação simples de w para validação."
                                  ],
                                  "verification": "Sequência anotada com estado final e decisão de aceitação/rejeição correta.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Sequência completa",
                                    "Lista de estados F"
                                  ],
                                  "tips": [
                                    "A notação ⊢ facilita a leitura da computação.",
                                    "Sempre conte os estados para matching com |w|+1."
                                  ],
                                  "learningObjective": "Concluir o processamento e avaliar corretamente o resultado.",
                                  "commonMistakes": [
                                    "Esquecer de incluir q₀ na contagem.",
                                    "Errar aceitação checando estado errado.",
                                    "Não registrar a sequência simbólica."
                                  ]
                                }
                              ],
                              "practicalExample": "AFD para strings binárias com par de 1's: Q={q0(par),q1(ímpar)}, Σ={0,1}, q0 inicial, F={q0}, δ(q0,0)=q0, δ(q0,1)=q1, δ(q1,0)=q1, δ(q1,1)=q0. Para w=1011: seq = q0 ⊢1 q1 ⊢0 q1 ⊢1 q0 ⊢1 q1. q_final=q1 ∉ F (rejeita, 3 1's ímpares).",
                              "finalVerifications": [
                                "Calcula sequência correta para AFD simples com |w|≤5.",
                                "Aplica δ estendida sem erros em exemplos variados.",
                                "Identifica estado final e aceitação precisamente.",
                                "Documenta todas transições com notação padrão.",
                                "Valida com w vazia e w unitária.",
                                "Explica verbalmente o rastreamento de estados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de δ (100% transições corretas).",
                                "Completude da sequência (n+1 estados listados).",
                                "Correta identificação de q_final e aceitação.",
                                "Clareza na documentação (diagramas/tabelas legíveis).",
                                "Tratamento de casos edge (w vazia, transições múltiplas).",
                                "Eficiência no processamento iterativo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Grafos dirigidos e caminhos em autômatos como funções parciais.",
                                "Programação: Implementação de Finite State Machines em loops while.",
                                "Lógica: Estados como variáveis booleanas rastreando paridade.",
                                "Engenharia de Software: Análise léxica em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores para tokenizar código-fonte (ex: identificar identificadores), validadores de protocolos de rede (ex: checar formato de pacotes HTTP), ou controle de jogos (ex: rastrear fases de um menu FSM)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Verificar o determinismo da função de transição",
                            "description": "Analisar uma função de transição para confirmar que para todo estado q ∈ Q e símbolo a ∈ Σ existe exatamente um δ(q, a), diferenciando de autômatos não-determinísticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição de Função de Transição Determinística",
                                  "subSteps": [
                                    "Revise a definição formal de um AFD: (Q, Σ, δ, q0, F), onde δ: Q × Σ → Q é uma função total e única.",
                                    "Compare com NFA, onde δ: Q × (Σ ∪ {ε}) → 2^Q pode mapear para múltiplos estados ou nenhum.",
                                    "Identifique que determinismo requer exatamente um estado de destino para cada (q, a).",
                                    "Anote exemplos de violações: ausência de transição ou múltiplas transições para o mesmo (q, a).",
                                    "Explique em suas palavras a diferença entre δ determinística e não-determinística."
                                  ],
                                  "verification": "Escreva a definição de δ determinística e dê um exemplo de violação; confira com uma referência confiável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro ou notas sobre Autômatos Finitos",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use tabelas para visualizar diferenças entre AFD e AFND.",
                                  "learningObjective": "Entender conceitualmente o que torna uma função de transição determinística.",
                                  "commonMistakes": [
                                    "Confundir determinismo com completude (transições para todos os símbolos)",
                                    "Ignorar transições ε, que invalidam determinismo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os Conjuntos Q e Σ no Autômato Dado",
                                  "subSteps": [
                                    "Liste todos os estados Q do diagrama ou descrição do autômato.",
                                    "Liste todos os símbolos do alfabeto Σ.",
                                    "Confirme que não há símbolos ε ou outros não listados em Σ.",
                                    "Crie uma matriz vazia com linhas para Q e colunas para Σ para representar a tabela de transição.",
                                    "Marque quaisquer estados ou símbolos ausentes ou ambíguos."
                                  ],
                                  "verification": "A matriz tem |Q| linhas e |Σ| colunas, todas identificadas corretamente sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama ou tabela do autômato",
                                    "Planilha ou papel quadriculado"
                                  ],
                                  "tips": "Nomeie estados e símbolos explicitamente para evitar confusões.",
                                  "learningObjective": "Extrair com precisão os componentes necessários para análise.",
                                  "commonMistakes": [
                                    "Omitir estados inalcançáveis",
                                    "Incluir ε como símbolo em Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher e Analisar a Tabela de Transição",
                                  "subSteps": [
                                    "Para cada célula (q, a) na tabela, preencha δ(q, a) baseado no diagrama ou descrição.",
                                    "Verifique se cada célula tem exatamente uma entrada única (um estado).",
                                    "Marque células vazias (transição ausente) ou com múltiplas setas (não-determinismo).",
                                    "Conte o número total de pares (q, a): deve ser |Q| × |Σ|, todos definidos unicamente.",
                                    "Registre quaisquer anomalias encontradas."
                                  ],
                                  "verification": "Tabela completa sem células vazias ou múltiplas entradas; compare com diagrama original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de transição em construção",
                                    "Diagrama do autômato ampliado"
                                  ],
                                  "tips": "Use cores: verde para único, vermelho para problemas.",
                                  "learningObjective": "Construir e inspecionar a representação tabular da função δ.",
                                  "commonMistakes": [
                                    "Interpretar setas sobrepostas como única transição",
                                    "Ignorar transições para o mesmo estado em loops"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a Verificação e Documentar o Resultado",
                                  "subSteps": [
                                    "Conte as violações: zero violações = determinístico.",
                                    "Se não determinístico, liste pares (q, a) problemáticos e sugira correções (ex: adicionar transição ou converter para NFA).",
                                    "Diferencie explicitamente de AFND.",
                                    "Teste com uma cadeia curta para validar comportamento.",
                                    "Escreva um relatório resumido: 'É determinístico? Por quê?'"
                                  ],
                                  "verification": "Relatório claro afirma determinismo ou lista violações específicas com evidências.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela preenchida",
                                    "Exemplo de cadeia de teste"
                                  ],
                                  "tips": "Sempre teste com todas as combinações, mesmo triviais.",
                                  "learningObjective": "Emitir uma conclusão precisa e fundamentada sobre o determinismo.",
                                  "commonMistakes": [
                                    "Declarar determinístico apesar de transições ausentes",
                                    "Confundir completude com determinismo"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o autômato com Q = {q0, q1}, Σ = {0,1}, δ(q0,0)=q0, δ(q0,1)=q1, δ(q1,0)=q1, δ(q1,1)=q1. Tabela: todas células únicas → determinístico. Agora, altere para δ(q0,1)={q1,q2} (múltiplo) → não-determinístico.",
                              "finalVerifications": [
                                "Definir corretamente δ determinística como função total única.",
                                "Construir tabela de transição sem erros para um AFD dado.",
                                "Identificar violações específicas em um exemplo não-determinístico.",
                                "Diferenciar AFD de AFND com exemplos.",
                                "Verificar determinismo em uma cadeia de entrada curta.",
                                "Explicar implicações de não-determinismo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de Q e Σ (100% corretos).",
                                "Tabela de transição completa e sem ambiguidades.",
                                "Detecção correta de todas as violações (zero falsos positivos/negativos).",
                                "Relatório claro com justificativa lógica.",
                                "Uso correto de terminologia formal.",
                                "Diferenciação explícita de AFND."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria das Funções Totais e Injetoras.",
                                "Lógica: Verificação de unicidade em tabelas de verdade.",
                                "Programação: Switch statements determinísticos em parsers.",
                                "Teoria dos Grafos: Arestas únicas em rótulos de vértices.",
                                "Engenharia de Software: Validação de especificações formais."
                              ],
                              "realWorldApplication": "Em compiladores (lexers determinísticos para análise rápida de código), validadores de protocolos de rede (transições únicas por byte), e autômatos em jogos/IA para estados previsíveis sem ambiguidades."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Simular a execução de um AFD em uma entrada longa",
                            "description": "Processar cadeias longas ou com repetições em um AFD, otimizando o rastreamento de estados e identificando padrões de ciclos em loops de estados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o AFD e analisar a entrada longa",
                                  "subSteps": [
                                    "Desenhe ou liste o diagrama do AFD, incluindo todos os estados, transições, estado inicial (q0) e estados aceitadores.",
                                    "Crie uma tabela de transições δ(q, σ) para todos os estados e símbolos do alfabeto.",
                                    "Examine a entrada longa, identificando padrões repetitivos, como sequências que se repetem (ex: 'ab' 50 vezes).",
                                    "Marque posições iniciais e potenciais pontos de ciclo na string.",
                                    "Escolha uma ferramenta de simulação (papel/caneta ou software como JFLAP)."
                                  ],
                                  "verification": "Confirme que a tabela de transições está completa e sem erros consultando a definição formal do AFD; teste com uma substring curta.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software JFLAP ou similar",
                                    "Definição formal do AFD"
                                  ],
                                  "tips": "Use cores diferentes para estados aceitadores e não-aceitadores para visualização rápida.",
                                  "learningObjective": "Entender a estrutura formal do AFD e preparar dados para simulação eficiente em entradas longas.",
                                  "commonMistakes": [
                                    "Omitir transições para algum símbolo",
                                    "Confundir estado inicial com aceitador",
                                    "Ignorar padrões repetitivos na entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar simulação e processar prefixo da entrada",
                                  "subSteps": [
                                    "Inicie no estado q0 com posição 0 na string.",
                                    "Para cada símbolo inicial (primeiros 5-10), aplique δ(estado_atual, símbolo) e avance a posição.",
                                    "Registre o estado após cada transição em uma tabela de rastreamento (posição | símbolo | estado novo).",
                                    "Identifique se um estado se repete cedo, indicando possível ciclo.",
                                    "Pausar após prefixo para validar manualmente."
                                  ],
                                  "verification": "Simule uma substring curta (ex: primeiros 5 símbolos) e confirme se chega ao estado correto comparando com execução manual.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Tabela de rastreamento em papel ou planilha",
                                    "String de entrada impressa"
                                  ],
                                  "tips": "Mantenha uma 'trilha' visual conectando estados para entradas longas, usando setas curtas.",
                                  "learningObjective": "Dominar o rastreamento sequencial de estados para entender o fluxo básico de processamento.",
                                  "commonMistakes": [
                                    "Não atualizar a posição corretamente após transição",
                                    "Ler símbolo errado da string",
                                    "Pular transições indefinidas (deve rejeitar)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar ciclos e otimizar simulação para repetições",
                                  "subSteps": [
                                    "Analise a trilha de estados para loops: identifique quando um estado q_i é revisitado após uma substring repetida.",
                                    "Calcule o comprimento do ciclo (distância entre visitas ao mesmo estado) e o efeito no estado (aceita ou não).",
                                    "Para repetições n vezes, multiplique: novo_estado = aplicar ciclo (n % período) vezes se houver subciclos.",
                                    "Salte a simulação: anote 'aplicou ciclo k vezes, estado permanece q_j'.",
                                    "Valide com uma repetição pequena antes de escalar."
                                  ],
                                  "verification": "Teste detecção de ciclo em uma substring com 2 repetições; confirme estado final manualmente.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Gráfico de estados com marcações de ciclo",
                                    "Calculadora para módulo em repetições longas"
                                  ],
                                  "tips": "Registre pares (posição, estado) para detectar ciclos rapidamente; use notação 'q_i ->[repetição]^n -> q_i'.",
                                  "learningObjective": "Aprender a otimizar simulações em entradas longas identificando e explorando ciclos de estados.",
                                  "commonMistakes": [
                                    "Confundir ciclo com caminho linear",
                                    "Erro no cálculo de múltiplos de ciclo (use mod)",
                                    "Ignorar que ciclo pode levar a rejeição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar simulação e verificar aceitação",
                                  "subSteps": [
                                    "Aplique otimizações até o final da string, registrando estado final.",
                                    "Confirme se estado final é aceitador e se todas transições foram cobertas.",
                                    "Compare com simulação completa se possível (ou amostragem).",
                                    "Documente tempo economizado pela otimização vs. simulação ingênua.",
                                    "Resuma padrões observados (ex: 'loop par mantém aceitação')."
                                  ],
                                  "verification": "Estado final correto e aceitação/rejeição matches com definição do AFD.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Tabela final de rastreamento",
                                    "Diagrama anotado"
                                  ],
                                  "tips": "Sempre termine no último símbolo; estados finais só contam após processar toda a entrada.",
                                  "learningObjective": "Concluir simulações otimizadas com precisão, determinando corretamente a aceitação de linguagens regulares.",
                                  "commonMistakes": [
                                    "Verificar aceitação antes do fim da string",
                                    "Esquecer sufixo após otimização",
                                    "Não validar otimizações com casos pequenos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o AFD que aceita strings binárias {0,1}* com número par de '1's (estados q0 par, q1 ímpar; transições alternam). Simule na entrada longa '10' repetida 50 vezes ('101010...10', 100 símbolos). Detecte ciclo: '10' alterna q0->q1->q0, ciclo de 2 símbolos volta a q0 (par). Após 50 reps, estado final q0 (aceita).",
                              "finalVerifications": [
                                "Corretamente identifica o estado final após otimização.",
                                "Detecta e aplica pelo menos um ciclo corretamente em repetições.",
                                "Rastreamento completo sem erros em transições para prefixo e sufixo.",
                                "Determina aceitação/rejeição com justificativa baseada em estados.",
                                "Documenta economia de tempo (ex: simulação ingênua 100 passos vs. 4 com ciclo).",
                                "Valida com substring curta idêntica ao padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão no rastreamento de estados (100% correto).",
                                "Eficiência na detecção e uso de ciclos (reduz passos >50%).",
                                "Documentação clara de tabela de transições e trilha.",
                                "Correta identificação de padrões repetitivos na entrada.",
                                "Explicação verbal da otimização sem hesitação.",
                                "Tratamento correto de entradas sem ciclos ou indefinidas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos (estados como vértices, transições como arestas; detecção de ciclos).",
                                "Programação: Implementação de FSM em código (loops while com switch para estados).",
                                "Lógica: Raciocínio dedutivo em sequências finitas e modularidade.",
                                "Engenharia de Software: Otimização de algoritmos para parsing eficiente."
                              ],
                              "realWorldApplication": "Em compiladores, simuladores de AFD otimizados processam tokens longos em analisadores léxicos (ex: regex em editores como VS Code); validação de protocolos de rede detectando padrões repetidos em pacotes longos sem simulação completa."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Aceitação de Linguagens Regulares e Construção a partir de Expressões Regulares",
                        "description": "Um AFD aceita uma linguagem regular L( A ) = {w | δ̂(q0, w) ∈ F}, e teorema de Kleene permite construir AFD equivalente a uma expressão regular via AFN e determinização.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Determinar se uma cadeia é aceita por um AFD",
                            "description": "Dado um AFD e uma cadeia w, computar δ̂(q0, w) e verificar se pertence a F, aplicando o critério formal de aceitação e testando múltiplas entradas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes do AFD e da cadeia de entrada",
                                  "subSteps": [
                                    "Examinar o conjunto de estados Q, alfabeto Σ, função de transição δ, estado inicial q0 e estados finais F.",
                                    "Representar o AFD graficamente ou em tabela para visualização clara.",
                                    "Analisar a cadeia w, identificando cada símbolo sequencialmente.",
                                    "Verificar se todos os símbolos de w pertencem a Σ.",
                                    "Anotar q0 como estado atual inicial."
                                  ],
                                  "verification": "Lista completa de Q, Σ, δ, q0, F e w anotada corretamente, sem erros tipográficos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama do AFD",
                                    "Papel e caneta ou software de desenho de grafos como Graphviz"
                                  ],
                                  "tips": "Desenhe o AFD como um grafo para facilitar a visualização das transições.",
                                  "learningObjective": "Compreender e extrair precisamente os elementos formais de um AFD e uma cadeia.",
                                  "commonMistakes": [
                                    "Confundir estados finais com iniciais",
                                    "Ignorar símbolos fora do alfabeto",
                                    "Erros na notação da função δ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular a transição passo a passo para cada símbolo da cadeia",
                                  "subSteps": [
                                    "Iniciar no estado q0.",
                                    "Para cada símbolo wi em w (da esquerda para a direita), aplicar δ(estado_atual, wi) para obter novo_estado.",
                                    "Registrar o estado após cada transição em uma tabela: posição i, símbolo wi, estado antes, estado após.",
                                    "Garantir que δ esteja definida para todas as transições (AFD é total).",
                                    "Verificar consistência em cada aplicação de δ."
                                  ],
                                  "verification": "Tabela de transições completa gerada, com estados corretos após cada símbolo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de transições em Excel ou papel quadriculado",
                                    "Diagrama do AFD"
                                  ],
                                  "tips": "Use setas no diagrama para rastrear o caminho da cadeia visualmente.",
                                  "learningObjective": "Executar simulação sequencial de transições em um AFD.",
                                  "commonMistakes": [
                                    "Pular símbolos",
                                    "Aplicar δ incorretamente (ex: δ(q, ab) em vez de sequencial)",
                                    "Perder o rastro do estado atual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o estado final usando a extensão δ̂(q0, w)",
                                  "subSteps": [
                                    "Aplicar δ̂(q0, w) = δ(δ̂(q0, w[1..i-1]), w[i]) recursivamente até o final.",
                                    "Comparar o resultado da simulação passo a passo com o δ̂ direto (se possível).",
                                    "Anotar o estado final qf = δ̂(q0, w).",
                                    "Verificar se há loops ou padrões repetitivos na cadeia longa.",
                                    "Documentar o caminho completo: q0 -> q1 -> ... -> qf."
                                  ],
                                  "verification": "Estado final qf calculado corretamente e documentado com o caminho completo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de cálculo para δ̂",
                                    "Ferramenta online como JFLAP para simulação"
                                  ],
                                  "tips": "Para cadeias longas, identifique ciclos no AFD para otimizar mentalmente.",
                                  "learningObjective": "Dominar o cálculo da função de transição estendida δ̂.",
                                  "commonMistakes": [
                                    "Confundir δ com δ̂",
                                    "Erro de parênteses na composição",
                                    "Ignorar o estado inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar aceitação e testar múltiplas cadeias",
                                  "subSteps": [
                                    "Checar se qf ∈ F; se sim, cadeia aceita; caso contrário, rejeitada.",
                                    "Explicar formalmente: w ∈ L(M) iff δ̂(q0, w) ∈ F.",
                                    "Testar 2-3 cadeias adicionais: uma aceita, uma rejeitada, uma limite.",
                                    "Analisar por que cada cadeia é/ não é aceita.",
                                    "Generalizar o padrão de linguagem aceita pelo AFD."
                                  ],
                                  "verification": "Decisão de aceitação correta para w e testes adicionais documentados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de cadeias de teste",
                                    "JFLAP ou simulador AFD online"
                                  ],
                                  "tips": "Escolha cadeias que explorem bordas: vazia, longa, com loops.",
                                  "learningObjective": "Aplicar critério formal de aceitação e validar com testes.",
                                  "commonMistakes": [
                                    "Verificar F incorretamente",
                                    "Não testar casos limite",
                                    "Confundir rejeição com erro de transição"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere AFD M: Q={q0,q1}, Σ={a,b}, q0 inicial, F={q1}, δ(q0,a)=q1, δ(q0,b)=q0, δ(q1,a)=q0, δ(q1,b)=q1. Para w='aab': Inicie q0. a→q1, a→q0, b→q0 (qf=q0 ∉ F, rejeitada). Teste 'aa': q0-a→q1-a→q0 ∉ F (rejeitada); 'a': q0-a→q1 ∈ F (aceita).",
                              "finalVerifications": [
                                "δ̂(q0, w) calculado corretamente com caminho documentado.",
                                "Estado final pertence a F verificado formalmente.",
                                "Tabela de transições passo a passo completa e precisa.",
                                "Múltiplas cadeias testadas com decisões corretas.",
                                "Explicação formal da aceitação/rejeição fornecida.",
                                "Padrão da linguagem L(M) identificado corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de transições (100% correto).",
                                "Completude da documentação (todos passos e tabelas presentes).",
                                "Correta aplicação do critério formal de aceitação.",
                                "Qualidade dos testes adicionais (cobertura de casos variados).",
                                "Clareza na representação gráfica ou tabular.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (AFD como grafo direcionado).",
                                "Lógica: Funções parciais/totais e composição de relações.",
                                "Programação: Implementação de simuladores de AFD em Python.",
                                "Engenharia de Software: Validação de entradas em parsers.",
                                "Filosofia: Conceitos de formalismo e decidibilidade."
                              ],
                              "realWorldApplication": "Em compiladores, lexers usam AFD para tokenizar código-fonte (ex: identificar identificadores vs. keywords); validação de formatos como emails ou CPFs; análise de padrões em redes para detecção de intrusões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Descrever a linguagem aceita por um AFD",
                            "description": "Analisar um AFD para expressar L(A) em termos de expressões regulares ou propriedades (ex.: todas as strings com paridade par de a's), identificando estados acessíveis e trapaçados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Examinar a Estrutura do AFD",
                                  "subSteps": [
                                    "Ler a definição formal do AFD: (Q, Σ, δ, q0, F).",
                                    "Desenhar o diagrama de estados com transições rotuladas pelo alfabeto Σ.",
                                    "Identificar o estado inicial q0 e os estados finais F.",
                                    "Listar todas as transições δ(q, a) para cada estado q e símbolo a.",
                                    "Verificar se o AFD é completo (transição para todo símbolo de todo estado)."
                                  ],
                                  "verification": "Diagrama desenhado corretamente com todos os estados, transições, q0 e F destacados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis ou ferramenta de desenho digital (ex: Draw.io)",
                                    "Definição do AFD fornecida"
                                  ],
                                  "tips": "Use setas curvas para loops e cores diferentes para estados finais.",
                                  "learningObjective": "Compreender e visualizar os componentes fundamentais de um AFD.",
                                  "commonMistakes": [
                                    "Omitir transições para alguns símbolos",
                                    "Confundir estado inicial com estados finais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Estados Acessíveis e Eliminar Inacessíveis",
                                  "subSteps": [
                                    "Partir do estado inicial q0 e marcar todos os estados alcançáveis via transições.",
                                    "Usar BFS ou DFS para explorar o grafo de estados.",
                                    "Listar estados acessíveis e remover os inacessíveis do diagrama.",
                                    "Atualizar as transições removendo referências a estados eliminados.",
                                    "Verificar se a linguagem aceita permanece a mesma (apenas estados acessíveis importam)."
                                  ],
                                  "verification": "Lista de estados acessíveis coincide com exploração exaustiva do grafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama do Step 1",
                                    "Papel para anotar caminhos"
                                  ],
                                  "tips": "Marque estados com '*' ao visitá-los para evitar reprocessamento.",
                                  "learningObjective": "Dominar a determinação de subautomato acessível para simplificação.",
                                  "commonMistakes": [
                                    "Parar exploração prematuramente",
                                    "Incluir estados inacessíveis por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar e Lidar com Estados Trapaçados (Mortos)",
                                  "subSteps": [
                                    "Identificar estados não-finais dos quais não há caminho para nenhum estado final.",
                                    "Marcar estados trapaçados: sem saída para F, incluindo loops internos.",
                                    "Analisar transições que levam a trapaçados e considerar renomeação ou remoção se possível.",
                                    "Atualizar o diagrama destacando ou removendo trapaçados irrelevantes para L(A).",
                                    "Confirmar que estados trapaçados não afetam strings aceitas."
                                  ],
                                  "verification": "Nenhum estado trapaçado é considerado na descrição da linguagem aceita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama atualizado do Step 2"
                                  ],
                                  "tips": "Teste com strings vazia e símbolos únicos para detectar armadilhas precoces.",
                                  "learningObjective": "Reconhecer estados irrelevantes para otimização do AFD.",
                                  "commonMistakes": [
                                    "Confundir loops em trapaçados com ciclos úteis",
                                    "Ignorar trapaçados acessíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever a Linguagem L(A) via Propriedades ou Expressão Regular",
                                  "subSteps": [
                                    "Traçar todos os caminhos do q0 aos estados F, anotando sequências de símbolos.",
                                    "Generalizar padrões: contagens (paridade de a's), prefixos/sufixos, etc.",
                                    "Converter caminhos em expressão regular usando eliminação de estados ou produto de rótulos.",
                                    "Escrever L(A) em notação descritiva ou regex (ex: (b* (a b* a b*)*)* para paridade par de a's).",
                                    "Validar com exemplos: strings aceitas/rejeitadas."
                                  ],
                                  "verification": "Descrição aceita exatamente as strings testadas e rejeita as inválidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama simplificado",
                                    "Tabela de estados para regex"
                                  ],
                                  "tips": "Comece com AFDs pequenos; use indução em número de estados.",
                                  "learningObjective": "Expressar L(AFD) de forma concisa e precisa.",
                                  "commonMistakes": [
                                    "Sobregeneralizar padrões",
                                    "Esquecer caminhos alternativos"
                                  ]
                                }
                              ],
                              "practicalExample": "AFD com Q={q0,q1}, q0 inicial, q1 final, δ(q0,a)=q1, δ(q1,a)=q0, δ(q0,b)=q0, δ(q1,b)=q1. Estados acessíveis: todos. Sem trapaçados. L(A) = {w ∈ {a,b}* | número de a's em w é par} = (b*(a b* a b*)*)*.",
                              "finalVerifications": [
                                "Estados acessíveis listados corretamente sem omissões.",
                                "Estados trapaçados identificados e excluídos da descrição.",
                                "Descrição de L(A) testada com 3 strings aceitas e 3 rejeitadas.",
                                "Expressão regular ou propriedade equivale ao AFD (simulada manualmente).",
                                "Diagrama final simplificado reflete apenas componentes relevantes.",
                                "Descrição é concisa e cobre todos os casos de aceitação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de acessíveis e trapaçados (100% corretos).",
                                "Completude da descrição de L(A), cobrindo todos caminhos para F.",
                                "Clareza e concisão na expressão regular ou propriedade descritiva.",
                                "Validação com contraexemplos (aceitos/rejeitados).",
                                "Correção formal: L(descrição) = L(AFD).",
                                "Uso adequado de terminologia (ex: paridade, prefixo)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos grafos (alcanceabilidade, ciclos).",
                                "Programação: Implementação de AFD em Python (simulador de autômato).",
                                "Lógica: Equivalência entre modelos formais e expressões.",
                                "Engenharia de Software: Análise léxica em compiladores."
                              ],
                              "realWorldApplication": "Descrição de linguagens em analisadores léxicos de compiladores (ex: identificar tokens com padrões regulares em código-fonte), validadores de protocolos de rede (ex: pacotes com paridade de bits) e motores de busca com filtros de padrões."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Construir um AFD a partir de uma expressão regular simples",
                            "description": "Usar o algoritmo de Thompson para criar um AFN a partir de uma ER, seguido de subset construction para determinizar em AFD, aplicando a expressões como (a|b)*a.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e decompor a expressão regular",
                                  "subSteps": [
                                    "Identifique os símbolos básicos da ER: literais (a, b), união (|), concatenação (juxtaposição), estrela de Kleene (*).",
                                    "Parse a ER em uma árvore sintática, priorizando precedências: * > concatenação > |.",
                                    "Simplifique a ER se possível, removendo parênteses desnecessários ou aplicando identidades como ε* = ε.",
                                    "Defina o alfabeto Σ (ex: {a,b}) e liste exemplos de strings aceitas e rejeitadas.",
                                    "Desenhe um esboço manual da estrutura hierárquica da ER."
                                  ],
                                  "verification": "Verifique se a árvore sintática reproduz corretamente a ER original e gera strings válidas.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta online como RegExr ou JFLAP"
                                  ],
                                  "tips": "Comece pelas expressões mais internas; use parênteses para agrupar explicitamente.",
                                  "learningObjective": "Dominar a análise estrutural de ERs simples para preparar a construção de autômatos.",
                                  "commonMistakes": [
                                    "Ignorar precedência de operadores",
                                    "Confundir união com concatenação",
                                    "Esquecer o alfabeto implícito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o AFN usando o Algoritmo de Thompson",
                                  "subSteps": [
                                    "Construa sub-AFNs para símbolos básicos: literal 'a' tem estado inicial i -> f com 'a'; ε para vazio.",
                                    "Para união (E1|E2): novo i com ε para i1 e i2; f1 e f2 com ε para novo f.",
                                    "Para concatenação (E1E2): f1 com ε para i2; i=i1, f=f2.",
                                    "Para estrela (E*): novo i com ε para iE e novo f; fE com ε para f e iE; iE com ε para f.",
                                    "Monte recursivamente a partir da árvore sintática, numerando estados sequencialmente."
                                  ],
                                  "verification": "Simule a ER no AFN com 3 strings aceitas e 2 rejeitadas, rastreando ε-fechos.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "JFLAP ou Graphviz para visualização"
                                  ],
                                  "tips": "Desenhe sub-AFNs modularmente e colete-os; sempre inclua estados iniciais e finais únicos por sub-AFN.",
                                  "learningObjective": "Aplicar o algoritmo de Thompson para gerar AFNs equivalentes a ERs de forma sistemática.",
                                  "commonMistakes": [
                                    "Esquecer transições ε de retorno na estrela",
                                    "Não tratar corretamente o ε-fecho",
                                    "Estados sobrepostos sem renumeração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Subset Construction para determinizar o AFN em AFD",
                                  "subSteps": [
                                    "Compute o ε-fecho do estado inicial do AFN; esse é o estado inicial S0 do AFD.",
                                    "Para cada estado S do AFD e símbolo a em Σ, compute move(S, a) e ε-fecho(move(S,a)) como próximo estado.",
                                    "Adicione novos estados à fila de processamento até não haver mais; marque estados finais se contiverem o final do AFN.",
                                    "Desenhe o diagrama do AFD, rotulando estados como subconjuntos (ex: {1,3,4}).",
                                    "Elimine estados inalcançáveis ou mortos se presentes."
                                  ],
                                  "verification": "Execute simulações paralelas no AFN e AFD para 5 strings, confirmando aceitação idêntica.",
                                  "estimatedTime": "40-50 minutos",
                                  "materials": [
                                    "Tabela de subset construction",
                                    "Software como JFLAP para automação"
                                  ],
                                  "tips": "Use bitsets ou conjuntos para representar subconjuntos; processe em BFS para evitar loops.",
                                  "learningObjective": "Converter AFN não-determinístico em AFD determinístico preservando a linguagem aceita.",
                                  "commonMistakes": [
                                    "Esquecer ε-fecho após move",
                                    "Não fechar subconjuntos corretamente",
                                    "Perder estados finais no mapeamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e otimizar o AFD construído",
                                  "subSteps": [
                                    "Confira se o AFD aceita exatamente a linguagem da ER original com testes de strings limite.",
                                    "Identifique e remova transições para o estado vazio (dead state) se não essencial.",
                                    "Aplique minimização básica (unir estados equivalentes) usando tabela de distinção.",
                                    "Compare o número de estados: tipicamente, AFD tem até 2^n estados do AFN.",
                                    "Documente o processo com anotações nos diagramas."
                                  ],
                                  "verification": "O AFD deve rejeitar strings inválidas e aceitar todas as válidas da ER.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Lista de strings de teste",
                                    "Ferramenta de simulação como automata simulator online"
                                  ],
                                  "tips": "Teste casos edge: string vazia, prefixos inválidos, loops infinitos simulados.",
                                  "learningObjective": "Garantir correção e eficiência do AFD final através de validação rigorosa.",
                                  "commonMistakes": [
                                    "Não testar strings que exploram não-determinismo",
                                    "Ignorar estado trap",
                                    "Minimizar prematuramente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a ER (a|b)*a: 1. AFN de Thompson tem ~10 estados com ε-transições. 2. Subset construction gera AFD com 3 estados: S0={even a's?}, aceitando strings terminando em 'a'. Simule 'aba' (aceita) vs 'ab' (rejeitada).",
                              "finalVerifications": [
                                "Construir AFN correto para ER com ≤3 operadores.",
                                "Subset construction sem erros de ε-fecho.",
                                "AFD simula corretamente ≥5 strings da linguagem.",
                                "Diagrama do AFD é determinístico (uma transição por símbolo).",
                                "Explicar equivalência ER ↔ AFN ↔ AFD.",
                                "Identificar otimizações manuais no AFD."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção do AFN (100% das transições corretas).",
                                "Correção do subset construction (todos subconjuntos fechados).",
                                "Eficiência do AFD (estados mínimos necessários).",
                                "Validação com testes (cobertura de casos aceita/rejeita).",
                                "Clareza nos diagramas e documentação.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e powerset na subset construction.",
                                "Programação: Implementação de regex em linguagens como Python (re module).",
                                "Lógica: Equivalências formais e provas de correção.",
                                "Engenharia de Software: Validação de inputs em compiladores e parsers."
                              ],
                              "realWorldApplication": "Usado em motores de busca de texto (grep, Ctrl+F), validadores de formulários web (email patterns), analisadores léxicos de compiladores e scanners de antivírus para padrões maliciosos."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Autômatos Finitos Não-Determinísticos (AFN)",
                    "description": "Definição, conversão para AFD e equivalência com expressões regulares e conjuntos regulares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Definição de Autômatos Finitos Não-Determinísticos (AFN)",
                        "description": "Conceito fundamental que define a estrutura formal de um AFN, incluindo estados, alfabeto, função de transição não-determinística, estado inicial e estados de aceitação, destacando transições múltiplas e ε-transições.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Definir formalmente um AFN",
                            "description": "Escrever a definição matemática de um AFN como uma 5-tupla (Q, Σ, δ, q0, F), explicando cada componente e diferenciando da definição de AFD pela não-determinística δ: Q × (Σ ∪ {ε}) → 2^Q.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal de um AFD para estabelecer base de comparação",
                                  "subSteps": [
                                    "Lembre-se da definição de AFD como 5-tupla (Q, Σ, δ, q0, F), onde δ: Q × Σ → Q é determinística.",
                                    "Identifique os componentes: Q (estados), Σ (alfabeto), δ (transição única), q0 (inicial), F (finais).",
                                    "Anote as diferenças chave que serão alteradas no AFN.",
                                    "Crie um diagrama mental simples de um AFD básico.",
                                    "Compare com exemplos conhecidos de AFDs."
                                  ],
                                  "verification": "Escreva a definição de AFD de memória e liste 3 diferenças esperadas para AFN.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas de AFD anteriores",
                                    "Diagrama de AFD exemplo"
                                  ],
                                  "tips": "Use mnemônicos como 'Q-Sigma-Delta-Q0-F' para memorizar a tupla.",
                                  "learningObjective": "Compreender a estrutura base de autômatos finitos para contrastar com AFN.",
                                  "commonMistakes": [
                                    "Confundir δ de AFD com funções parciais",
                                    "Esquecer que Σ não inclui ε em AFD"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os componentes fixos da 5-tupla AFN: Q, Σ, q0 e F",
                                  "subSteps": [
                                    "Defina Q como conjunto finito de estados.",
                                    "Defina Σ como alfabeto finito de símbolos de entrada.",
                                    "Especifique q0 ∈ Q como estado inicial único.",
                                    "Defina F ⊆ Q como conjunto de estados de aceitação.",
                                    "Escreva exemplos concretos para cada componente."
                                  ],
                                  "verification": "Liste Q, Σ, q0 e F para um AFN hipotético simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "Livro de teoria da computação (cap. autômatos)"
                                  ],
                                  "tips": "Sempre use notação de conjunto: Q = {q1, q2, ...}, Σ = {a, b}.",
                                  "learningObjective": "Dominar os quatro componentes comuns entre AFD e AFN.",
                                  "commonMistakes": [
                                    "Permitir Q infinito",
                                    "Incluir ε em Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a função de transição δ não-determinística do AFN",
                                  "subSteps": [
                                    "Escreva δ: Q × (Σ ∪ {ε}) → 2^Q, explicando o domínio estendido com ε.",
                                    "Explique que 2^Q representa subconjuntos de estados (não-determinismo).",
                                    "Diferencie de AFD: δ retorna conjunto possível de estados, não único.",
                                    "Ilustre com exemplo: δ(q0, a) = {q1, q2}.",
                                    "Discuta ε-transições como transições sem consumo de input."
                                  ],
                                  "verification": "Escreva a assinatura de δ para AFN e dê um exemplo com ε-transição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho para diagramas (ex: Draw.io)",
                                    "Exemplos de AFN"
                                  ],
                                  "tips": "Pense em δ como 'múltiplas setas' saindo de um estado.",
                                  "learningObjective": "Entender o cerne do não-determinismo na transição.",
                                  "commonMistakes": [
                                    "Escrever δ → Q em vez de 2^Q",
                                    "Ignorar ε no domínio"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever a definição completa da 5-tupla AFN e sintetizar diferenças com AFD",
                                  "subSteps": [
                                    "Monte a 5-tupla: (Q, Σ, δ, q0, F) com δ não-determinística.",
                                    "Resuma diferenças: domínio de δ inclui ε, imagem é 2^Q vs Q.",
                                    "Crie um exemplo formal completo de AFN.",
                                    "Construa diagrama do AFN exemplo.",
                                    "Explique equivalência de poder com AFDs."
                                  ],
                                  "verification": "Escreva a definição formal completa e um exemplo válido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para diagrama",
                                    "Referência formal (Sipser ou similar)"
                                  ],
                                  "tips": "Verifique se todos componentes estão presentes e δ corretamente tipada.",
                                  "learningObjective": "Sintetizar a definição integral e contrastes.",
                                  "commonMistakes": [
                                    "Esquecer F ⊆ Q",
                                    "Confundir não-determinismo com ambiguidade semântica"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina formalmente um AFN que aceita strings sobre Σ={0,1} com pelo menos um '1': Q={q0,q1}, Σ={0,1}, q0 estado inicial, F={q1}, δ(q0,0)={q0}, δ(q0,1)={q0,q1}, δ(q1,0)={q1}, δ(q1,1)={q1}, com ε-transição δ(q0,ε)={q1}.",
                              "finalVerifications": [
                                "Escreva a 5-tupla de um AFN simples sem olhar notas.",
                                "Explique δ para AFN vs AFD em 2 frases.",
                                "Identifique erro em uma definição incompleta fornecida.",
                                "Construa diagrama de AFN com ε-transição.",
                                "Diferencie aceitação por estado final vs vazio."
                              ],
                              "assessmentCriteria": [
                                "Precisão na assinatura de δ: domínio e codomínio corretos.",
                                "Correta identificação de todos 5 componentes.",
                                "Explicação clara de não-determinismo e ε-transições.",
                                "Exemplo concreto válido e completo.",
                                "Diferenças com AFD explicitadas sem erros.",
                                "Uso consistente de notação matemática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos (2^Q como potência), funções parciais.",
                                "Lógica: Não-determinismo similar a escolha não-determinística em provas.",
                                "Programação: Modelagem de parsers flexíveis em compiladores.",
                                "Filosofia: Analogia com livre-arbítrio vs determinismo."
                              ],
                              "realWorldApplication": "Em compiladores, AFNs modelam analisadores léxicos flexíveis (ex: regex engines como em grep ou Java Pattern), permitindo múltiplos caminhos de parsing eficientemente convertíveis a AFDs via powerset construction."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Construir diagramas de AFN",
                            "description": "Desenhar graficamente um AFN para linguagens simples, representando transições não-determinísticas com setas múltiplas de um estado para vários estados e incluindo ε-transições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes fundamentais do AFN",
                                  "subSteps": [
                                    "Analise a linguagem ou expressão regular fornecida.",
                                    "Defina o alfabeto Σ (ex: {a, b}).",
                                    "Determine o conjunto de estados Q, incluindo estado inicial q0 e estados finais F.",
                                    "Liste as possíveis transições baseadas na linguagem.",
                                    "Anote se há necessidade de não-determinismo ou ε-transições."
                                  ],
                                  "verification": "Verifique se todos os componentes (Q, Σ, q0, F, δ) estão listados corretamente em uma tabela ou lista.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta de desenho como draw.io ou Graphviz"
                                  ],
                                  "tips": "Comece com o mínimo de estados possível para linguagens simples; priorize clareza.",
                                  "learningObjective": "Compreender e listar os 5 componentes tuple de um AFN.",
                                  "commonMistakes": [
                                    "Esquecer o alfabeto Σ",
                                    "Confundir estados finais com iniciais",
                                    "Não identificar necessidade de não-determinismo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Esboçar os estados e o layout gráfico",
                                  "subSteps": [
                                    "Desenhe círculos para representar os estados, numerando-os (q0, q1, etc.).",
                                    "Marque o estado inicial com uma seta de entrada sem origem.",
                                    "Marque estados finais com duplo círculo ou 'F'.",
                                    "Posicione os estados logicamente para evitar cruzamento de setas.",
                                    "Reserve espaço para transições múltiplas."
                                  ],
                                  "verification": "Confira se o layout tem estado inicial marcado corretamente e estados distinguíveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de diagramação"
                                  ],
                                  "tips": "Use layout linear ou em árvore para linguagens simples; alinhe estados por níveis de leitura.",
                                  "learningObjective": "Criar uma representação visual clara dos estados de um AFN.",
                                  "commonMistakes": [
                                    "Setas de inicial não destacadas",
                                    "Estados sobrepostos",
                                    "Falta de numeração única"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar transições regulares e não-determinísticas",
                                  "subSteps": [
                                    "Desenhe setas simples para transições determinísticas (uma seta por símbolo).",
                                    "Para não-determinismo, desenhe múltiplas setas do mesmo estado com o mesmo símbolo para destinos diferentes.",
                                    "Rotule cada seta com o símbolo do alfabeto (ex: 'a', 'b').",
                                    "Verifique funções de transição parciais (estados sem transição são permitidos em AFN).",
                                    "Evite loops desnecessários inicialmente."
                                  ],
                                  "verification": "Teste manualmente uma palavra da linguagem percorrendo o diagrama.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lápis com borracha",
                                    "Exemplos de linguagens simples"
                                  ],
                                  "tips": "Use setas curvas para múltiplas transições do mesmo estado; agrupe rótulos próximos.",
                                  "learningObjective": "Representar corretamente transições não-determinísticas graficamente.",
                                  "commonMistakes": [
                                    "Usar uma seta para múltiplos destinos sem rótulo claro",
                                    "Confundir rótulos de símbolos",
                                    "Transições impossíveis para a linguagem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar ε-transições e refinar o diagrama",
                                  "subSteps": [
                                    "Identifique onde ε-transições simplificam (movimentos sem consumir símbolo).",
                                    "Desenhe setas ε sem símbolo, rotuladas como 'ε'.",
                                    "Ajuste layout para acomodar novas setas sem confusão.",
                                    "Elimine estados ou transições redundantes se possível.",
                                    "Adicione legendas para símbolos e ε."
                                  ],
                                  "verification": "Simule leitura de uma palavra com ε-closures para confirmar aceitação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta digital para edição fácil"
                                  ],
                                  "tips": "ε-transições são opcionais mas úteis para união; limite para evitar complexidade.",
                                  "learningObjective": "Integrar ε-transições para modelar não-determinismo espontâneo.",
                                  "commonMistakes": [
                                    "ε-transições consumindo símbolos",
                                    "Loops ε infinitos não detectados",
                                    "Falta de rótulo 'ε'"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e finalizar o diagrama",
                                  "subSteps": [
                                    "Teste com palavras na linguagem (aceitas) e fora (rejeitadas).",
                                    "Verifique completude: todo caminho possível coberto.",
                                    "Adicione título, alfabeto e linguagem descrita.",
                                    "Limpe o diagrama: alinhamentos, legibilidade.",
                                    "Documente a função de transição δ em tabela opcional."
                                  ],
                                  "verification": "O AFN aceita todas as palavras da linguagem e rejeita as que não são.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de palavras teste"
                                  ],
                                  "tips": "Use 3 palavras positivas e 2 negativas para teste rápido.",
                                  "learningObjective": "Garantir que o AFN atenda à definição formal da linguagem.",
                                  "commonMistakes": [
                                    "Não testar palavras fora da linguagem",
                                    "Diagrama ilegível",
                                    "Falta de validação formal"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um AFN para a linguagem L = {a, bb} sobre Σ = {a, b}. Estados: q0 (inicial), q1, q2 (final). De q0 com 'a' → q2 (final); de q0 com 'b' → q1; de q1 com 'b' → q2. Isso mostra não-determinismo se expandido, mas aqui é direto com ε opcional de q0 para q1.",
                              "finalVerifications": [
                                "O diagrama possui estado inicial claramente marcado.",
                                "Estados finais estão indicados corretamente (duplo círculo).",
                                "Transições não-determinísticas usam múltiplas setas com mesmo símbolo.",
                                "ε-transições, se presentes, estão rotuladas adequadamente.",
                                "O AFN aceita uma palavra de teste da linguagem.",
                                "O diagrama é legível e sem ambiguidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação dos 5 componentes do AFN (20%)",
                                "Correção das transições não-determinísticas e ε (30%)",
                                "Clareza e legibilidade do diagrama gráfico (20%)",
                                "Validação com testes de palavras (15%)",
                                "Minimalismo e eficiência no número de estados (10%)",
                                "Documentação completa (rótulos, legendas) (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Estados como vértices, transições como arestas rotuladas.",
                                "Matemática Discreta: Relações e funções parciais na transição δ.",
                                "Programação: Implementação de FSM em linguagens como Python (automata-lib).",
                                "Lógica: Não-determinismo similar a backtracking em algoritmos.",
                                "Engenharia de Software: Modelagem de parsers e analisadores léxicos."
                              ],
                              "realWorldApplication": "Diagramas de AFN são usados em compiladores para análise léxica (tokenização), reconhecimento de padrões em expressões regulares (ex: grep, regex em editores), e em sistemas de IA para modelagem de comportamentos probabilísticos em jogos ou chatbots."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Simular execução de AFN em strings",
                            "description": "Executar manualmente o AFN em uma entrada específica, rastreando todos os caminhos possíveis no conjunto de estados atuais e determinando aceitação se pelo menos um caminho leva a um estado final.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o AFN e a string de entrada",
                                  "subSteps": [
                                    "Identifique os componentes do AFN: estados Q, alfabeto Σ, função de transição δ, estado inicial q0 e estados finais F.",
                                    "Desenhe ou liste o diagrama do AFN, marcando claramente transições para cada símbolo do alfabeto.",
                                    "Escolha ou forneça uma string de entrada w ∈ Σ* e escreva-a explicitamente.",
                                    "Verifique se o AFN está completo: todos os estados têm transições definidas ou use o conjunto vazio para ausentes.",
                                    "Anote o conjunto de estados iniciais possíveis (geralmente {q0})."
                                  ],
                                  "verification": "Confirme que o diagrama do AFN está desenhado corretamente e a string de entrada está anotada, sem ambiguidades.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de diagramação como Draw.io",
                                    "Definição formal do AFN"
                                  ],
                                  "tips": "Use cores diferentes para estados iniciais (verde), finais (vermelho) e intermediários para visualização clara.",
                                  "learningObjective": "Compreender e representar visualmente os componentes de um AFN antes da simulação.",
                                  "commonMistakes": [
                                    "Esquecer transições para certos símbolos",
                                    "Confundir estados iniciais com finais",
                                    "Não considerar ε-transições se presentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar o conjunto de estados atuais",
                                  "subSteps": [
                                    "Comece com o conjunto de estados atuais S0 = {q0}, onde q0 é o estado inicial.",
                                    "Se houver transições ε do estado inicial, compute o fecho-ε de q0 e adicione ao conjunto.",
                                    "Anote S0 em uma tabela ou linha temporal para a posição 0 da string (antes do primeiro símbolo).",
                                    "Marque se algum estado em S0 é final (aceitação para string vazia).",
                                    "Prepare uma tabela de rastreamento com colunas: posição na string, símbolo lido, conjunto atual."
                                  ],
                                  "verification": "O conjunto S0 está corretamente calculado e anotado, incluindo fechos-ε se aplicável.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela em papel ou planilha Excel/Google Sheets",
                                    "Diagrama do AFN"
                                  ],
                                  "tips": "Use conjunto {} para estados vazios e liste estados em ordem alfabética para consistência.",
                                  "learningObjective": "Inicializar corretamente o estado não-determinístico para simulação.",
                                  "commonMistakes": [
                                    "Ignorar ε-transições iniciais",
                                    "Incluir estados não alcançáveis",
                                    "Confundir S0 com F"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar cada símbolo da string iterativamente",
                                  "subSteps": [
                                    "Para cada posição i de 1 a |w|, pegue o símbolo w[i] e o conjunto atual Si-1.",
                                    "Compute o próximo conjunto Si = ∪ {δ(q, w[i]) | q ∈ Si-1}, lidando com múltiplas transições.",
                                    "Inclua fechos-ε de cada estado em δ(q, w[i]) se ε-transições existirem.",
                                    "Anote Si na tabela de rastreamento e continue para o próximo símbolo.",
                                    "Rastreie todos os caminhos possíveis sem pruning prematuro."
                                  ],
                                  "verification": "Todos os conjuntos Si estão calculados corretamente na tabela, sem erros em transições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de rastreamento iniciada",
                                    "Diagrama do AFN"
                                  ],
                                  "tips": "Processe símbolo por símbolo lentamente; use set notation {q1, q2} para conjuntos.",
                                  "learningObjective": "Simular a transição não-determinística para cada símbolo, gerenciando conjuntos de estados.",
                                  "commonMistakes": [
                                    "Perder caminhos não-determinísticos",
                                    "Não computar fechos-ε após transições",
                                    "Erro em δ para símbolos específicos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar aceitação final e analisar o rastreamento",
                                  "subSteps": [
                                    "Após processar todos os símbolos, examine o conjunto final Sn.",
                                    "Verifique se Sn ∩ F ≠ ∅ (pelo menos um estado final presente).",
                                    "Se sim, a string é aceita; caso contrário, rejeitada. Anote o resultado.",
                                    "Revise a tabela inteira para identificar todos os caminhos que levam a finais.",
                                    "Opcionalmente, destaque o caminho aceitador principal."
                                  ],
                                  "verification": "Resultado de aceitação está correto e justificado pelo conjunto final.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de rastreamento completa"
                                  ],
                                  "tips": "Se rejeitada, explique por que nenhum caminho alcançou F.",
                                  "learningObjective": "Determinar corretamente a aceitação baseada no não-determinismo.",
                                  "commonMistakes": [
                                    "Verificar só o último estado em vez do conjunto",
                                    "Ignorar interseção com F",
                                    "Concluir prematuramente"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um AFN com Q={q0,q1,q2}, Σ={a,b}, q0 inicial, F={q2}. Transições: δ(q0,a)={q0,q1}, δ(q0,b)={q0}, δ(q1,a)={q1}, δ(q1,b)={q2}, δ(q2,a/b)=∅. String: 'ab'. Rastreamento: S0={q0}, S1 (a)={q0,q1}, S2 (b)={q0,q2}. Sn ∩ F = {q2} ≠ ∅ → aceita. Caminho: q0 -a-> q1 -b-> q2.",
                              "finalVerifications": [
                                "Tabela de conjuntos de estados está completa e correta para todos os símbolos.",
                                "Todos os caminhos não-determinísticos foram rastreados sem omissões.",
                                "Conjunto final intersecta corretamente com F.",
                                "Resultado de aceitação/rejeição é justificado.",
                                "Fechos-ε foram computados se aplicáveis.",
                                "Exemplo prático foi simulado com sucesso."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de conjuntos de estados (90% correto).",
                                "Tratamento completo de não-determinismo e múltiplos caminhos.",
                                "Correta identificação de aceitação baseada em F.",
                                "Clareza na tabela de rastreamento e documentação.",
                                "Capacidade de explicar erros comuns evitados.",
                                "Tempo de execução dentro do estimado com qualidade."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: AFN como grafo direcionado multi-aresta.",
                                "Programação: Implementação de simuladores de autômatos em Python/Java.",
                                "Lógica e Probabilidade: Modelagem de escolhas não-determinísticas.",
                                "Análise de Algoritmos: Complexidade O(|Q| * |w|).",
                                "Engenharia de Software: Validação de entradas em parsers."
                              ],
                              "realWorldApplication": "Simulação de AFN é fundamental em compiladores para análise léxica (tokenização), validação de padrões regex em editores de texto (ex: VS Code, grep), e processamento de linguagem natural para matching de padrões em strings de dados reais como logs ou DNA sequences."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Conversão de AFN para AFD",
                        "description": "Processo algorítmico para transformar um AFN em um AFD equivalente usando o método dos subconjuntos de potências, garantindo o mesmo poder expressivo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Descrever o algoritmo de subconjuntos",
                            "description": "Explicar passo a passo o algoritmo: iniciar com o subconjunto {q0}, computar fechamento-ε, expandir via δ para cada símbolo, até fixpoint, identificando estados de aceitação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação e Entendimento dos Conceitos Fundamentais",
                                  "subSteps": [
                                    "Revise a estrutura de um AFN: conjunto de estados Q, alfabeto Σ, função de transição δ: Q × (Σ ∪ {ε}) → P(Q), estado inicial q0, estados finais F.",
                                    "Aprenda a função ε-closure(S): o menor conjunto T ⊇ S tal que nenhum estado em T tem transição ε para fora de T.",
                                    "Estude a função move(T, a): ∪_{q ∈ T} δ(q, a), para a ∈ Σ.",
                                    "Entenda que os estados do AFD serão subconjuntos não-vazios de Q (potência de Q).",
                                    "Desenhe um diagrama do AFN de exemplo para visualizar transições ε."
                                  ],
                                  "verification": "Escreva as definições de ε-closure e move corretamente, com um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama do AFN, notas de teoria de autômatos, papel e caneta.",
                                  "tips": "Use representações gráficas para ε-transições para evitar confusão visual.",
                                  "learningObjective": "Dominar as funções auxiliares necessárias para o algoritmo.",
                                  "commonMistakes": "Confundir ε-closure com transições regulares; esquecer que δ retorna potências de Q."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicialização do Conjunto Inicial",
                                  "subSteps": [
                                    "Identifique o estado inicial q0 do AFN.",
                                    "Compute S0 = ε-closure({q0}).",
                                    "Crie o primeiro estado do AFD: T0 = S0, marque como estado inicial do AFD.",
                                    "Adicione T0 a uma fila de subconjuntos pendentes (frontier) e a uma tabela de estados processados.",
                                    "Verifique se T0 contém algum estado final de F; se sim, marque T0 como final no AFD."
                                  ],
                                  "verification": "Confirme que S0 inclui todos os estados alcançáveis por ε de q0 e liste-os.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama do AFN, tabela para estados do AFD.",
                                  "tips": "Liste explicitamente todos os estados em S0 para evitar omissões em ε-caminhos.",
                                  "learningObjective": "Implementar corretamente o estado inicial do AFD.",
                                  "commonMistakes": "Esquecer ε-transições múltiplas ou ciclos ε infinitos (que não existem em AFNs padrão)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expansão Iterativa dos Subconjuntos",
                                  "subSteps": [
                                    "Enquanto a fila de pendentes não estiver vazia, retire o próximo subconjunto T.",
                                    "Para cada símbolo a ∈ Σ, compute U = move(T, a), então S = ε-closure(U).",
                                    "Se S é novo (não processado), adicione S como novo estado do AFD, enfileire-o e registre a transição T --a--> S.",
                                    "Repita para todos os símbolos a de T.",
                                    "Continue até a fila esvaziar (fixpoint alcançado)."
                                  ],
                                  "verification": "Simule um ciclo completo e confirme que nenhum novo subconjunto é gerado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Fila ou pilha para pendentes, tabela de transições Σ × estados → estados.",
                                  "tips": "Use um conjunto (set) para rastrear estados vistos e evitar duplicatas.",
                                  "learningObjective": "Executar o loop principal do algoritmo até o fixpoint.",
                                  "commonMistakes": "Não aplicar ε-closure após move; processar subconjuntos vazios incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalização e Identificação de Estados de Aceitação",
                                  "subSteps": [
                                    "Para cada estado T do AFD construído, verifique se T ∩ F ≠ ∅; se sim, T é final no AFD.",
                                    "Complete a tabela de transições: para transições não definidas, vão para um 'estado sink' (opcional).",
                                    "Desenhe o diagrama do AFD resultante com estados, transições e iniciais/finais.",
                                    "Valide que o AFD reconhece a mesma linguagem do AFN.",
                                    "Documente todos os subconjuntos gerados e transições."
                                  ],
                                  "verification": "Liste todos os estados finais corretos e verifique uma string de teste na ambos autômatos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela completa de estados e transições, string de teste.",
                                  "tips": "Nomeie estados do AFD como {q1,q3} para clareza.",
                                  "learningObjective": "Concluir a construção e validar o AFD equivalente.",
                                  "commonMistakes": "Marcar estados como finais incorretamente; omitir transições para subconjuntos vazios."
                                }
                              ],
                              "practicalExample": "Considere o AFN M com Q={q0,q1,q2}, Σ={a,b}, q0 inicial, F={q2}, δ: q0-ε→q1, q1-a→q2, q0-a→q0, q1-b→q1. Passo 1: S0=ε-closure({q0})={q0,q1}. Passo 2: move(S0,a)={q0,q2}, ε-closure={q0,q1,q2}; move(S0,b)={q1}, ε-closure={q0,q1}. Novos: T1={q0,q1,q2}, T2={q0,q1}. Expansões subsequentes fecham em fixpoint. Finais: T1 contém q2.",
                              "finalVerifications": [
                                "Descreva os 4 passos principais do algoritmo em ordem correta.",
                                "Compute ε-closure e move para um subconjunto dado em um AFN exemplo.",
                                "Identifique corretamente o fixpoint em uma simulação.",
                                "Marque estados finais do AFD baseados em F do AFN.",
                                "Explique por que o AFD é equivalente ao AFN.",
                                "Desenhe o diagrama completo para um exemplo simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ε-closure e move (100% correto).",
                                "Completude da expansão: todos subconjuntos gerados até fixpoint.",
                                "Correta identificação de estados iniciais e finais.",
                                "Tabela de transições sem erros ou omissões.",
                                "Validação com pelo menos uma string aceita/rejeitada.",
                                "Clareza na representação textual ou gráfica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Construção da potência de conjuntos (2^Q estados possíveis).",
                                "Teoria dos Grafos: Conversão de grafo não-determinístico em determinístico via BFS.",
                                "Lógica e Teoria da Computação: Equivalência de modelos formais.",
                                "Programação: Implementação em algoritmos de busca (fila BFS)."
                              ],
                              "realWorldApplication": "Usado em compiladores (ex: flex/lex para analisadores léxicos) para converter regex em AFNs para AFNs determinísticos eficientes; motores de busca de padrões como grep; validação de protocolos de rede e máquinas de estado finitas em software embarcado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Aplicar conversão em exemplos",
                            "description": "Converter um AFN dado (com ε-transições) em AFD equivalente, construindo a tabela de transições e diagramas, verificando equivalência com simulações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a estrutura do AFN fornecido",
                                  "subSteps": [
                                    "Identifique o alfabeto Σ (símbolos de entrada).",
                                    "Liste todos os estados Q e marque o estado inicial I e os estados finais F.",
                                    "Registre todas as transições δ, destacando as ε-transições.",
                                    "Desenhe o diagrama do AFN para visualização clara.",
                                    "Anote o conjunto de estados acessíveis."
                                  ],
                                  "verification": "Verifique se a lista de estados, transições, inicial e finais está completa e corresponde ao diagrama sem omissões.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis, borracha, diagrama do AFN impresso ou digital.",
                                  "tips": "Use cores diferentes para ε-transições para facilitar a visualização.",
                                  "learningObjective": "Compreender completamente a estrutura do AFN com ε-transições.",
                                  "commonMistakes": "Ignorar ε-transições ou confundir estados iniciais com finais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os fechamentos ε para todos os estados",
                                  "subSteps": [
                                    "Para cada estado q em Q, calcule ε-closure(q): o conjunto de estados alcançáveis por zero ou mais ε-transições a partir de q.",
                                    "Comece pelo estado inicial: ε-closure(I).",
                                    "Use representação em conjunto de potências (notação {q1, q2, ...}).",
                                    "Verifique transitividade: inclua fechamentos de estados intermediários.",
                                    "Liste todos os ε-closure únicos em uma tabela auxiliar."
                                  ],
                                  "verification": "Teste com uma ε-transição simples: o fechamento deve incluir todos os estados conectados por ε.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de cálculo para conjuntos, calculadora gráfica se necessário.",
                                  "tips": "Ordene os estados alfabeticamente nos conjuntos para evitar duplicatas.",
                                  "learningObjective": "Dominar o cálculo de ε-closure como base para determinização.",
                                  "commonMistakes": "Parar em ε-transições diretas sem considerar cadeias múltiplas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o AFD usando o método dos subconjuntos",
                                  "subSteps": [
                                    "Inicie com o estado inicial do AFD: S0 = ε-closure(I).",
                                    "Para cada estado S não processado e cada símbolo a em Σ, calcule move(S, a) e depois T = ε-closure(move(S, a)). Adicione T como novo estado.",
                                    "Repita até não haver novos estados (feche o conjunto de potências).",
                                    "Marque estados finais do AFD: aqueles que contêm pelo menos um estado final do AFN.",
                                    "Construa a tabela de transições completa."
                                  ],
                                  "verification": "Confira que todos os estados do AFD têm transições definidas para todos os símbolos de Σ (totalmente definido).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela em branco para subconjuntos, software como JFLAP (opcional).",
                                  "tips": "Mantenha uma fila de estados pendentes para processar sistematicamente.",
                                  "learningObjective": "Aplicar o algoritmo de construção de subconjuntos para gerar o AFD equivalente.",
                                  "commonMistakes": "Esquecer de aplicar ε-closure após move ou duplicar estados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenhar diagramas e verificar equivalência",
                                  "subSteps": [
                                    "Desenhe o diagrama do AFD usando os subconjuntos como estados (abrevie se necessário, ex: {q0,q1}).",
                                    "Construa a tabela de transições final do AFD.",
                                    "Simule 3-5 cadeias de entrada: teste aceitação no AFN e no AFD para confirmar equivalência.",
                                    "Identifique estados inalcançáveis ou mortos e remova se aplicável.",
                                    "Compare linguagens aceitas."
                                  ],
                                  "verification": "Ambos os autômatos aceitam/rejeitam as mesmas strings de teste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de desenho (Draw.io ou papel), exemplos de strings de teste.",
                                  "tips": "Escolha strings que explorem ε-transições para testes robustos.",
                                  "learningObjective": "Validar a equivalência prática entre AFN e AFD.",
                                  "commonMistakes": "Não testar strings que usam ramificações não-determinísticas."
                                }
                              ],
                              "practicalExample": "Considere o AFN M com Σ={a,b}, estados {q0,q1,q2}, I=q0, F={q2}. Transições: q0 -ε→ q1, q1 -a→ q2, q0 -b→ q2. ε-closure(q0)={q0,q1}, move({q0,q1},a)={q2}, ε-closure({q2})={q2}; move({q0,q1},b)={q2}. AFD: S0={q0,q1} (inicial, não final), S1={q2} (final), transições S0-a→S1, S0-b→S1.",
                              "finalVerifications": [
                                "O AFD tem transições definidas para todos os símbolos em todos os estados.",
                                "Estados finais do AFD correspondem a subconjuntos contendo estados finais do AFN.",
                                "Simulação de pelo menos 5 strings mostra aceitação idêntica no AFN e AFD.",
                                "Número de estados no AFD ≤ 2^|Q| (potência do AFN).",
                                "Diagrama e tabela estão claros e sem erros tipográficos.",
                                "ε-closures foram calculados corretamente para todos os estados relevantes."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de ε-closure e move (sem erros em conjuntos).",
                                "Completude da tabela de transições (totalmente definida).",
                                "Correção na identificação de estados iniciais e finais.",
                                "Qualidade dos diagramas (legíveis e precisos).",
                                "Validação efetiva da equivalência via simulações.",
                                "Eficiência no número de estados (sem redundâncias desnecessárias)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria dos conjuntos e fechamentos transitivos.",
                                "Programação: Implementação de algoritmos em linguagens como Python (simuladores de autômatos).",
                                "Lógica: Equivalência de modelos não-determinísticos e determinísticos.",
                                "Engenharia de Software: Análise léxica em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores e analisadores léxicos (ex: flex), onde AFNs com ε são convertidos em AFDS eficientes para reconhecimento rápido de padrões em código-fonte, como em editores de texto ou scanners de segurança cibernética."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Otimizar AFD resultante",
                            "description": "Identificar e remover estados inalcançáveis ou mortos no AFD obtido, minimizando o autômato sem alterar a linguagem aceita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir o grafo de transições do AFD e identificar o estado inicial",
                                  "subSteps": [
                                    "Desenhe o diagrama do AFD com todos os estados, transições e estados finais.",
                                    "Marque claramente o estado inicial (q0).",
                                    "Liste todos os estados em uma tabela: nome, transições para cada símbolo do alfabeto, se é final.",
                                    "Verifique se o AFD está completo (transição para todo símbolo de todo estado).",
                                    "Anote o alfabeto Σ usado."
                                  ],
                                  "verification": "Grafo/diagrama completo desenhado e tabela de transições preenchida sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de desenho de grafos (ex: Graphviz, draw.io)",
                                    "Definição do AFD original"
                                  ],
                                  "tips": "Use cores diferentes para estados iniciais (verde), finais (azul) e outros (preto) para facilitar visualização.",
                                  "learningObjective": "Entender a estrutura completa do AFD para análise de alcançabilidade.",
                                  "commonMistakes": [
                                    "Esquecer transições para algum símbolo",
                                    "Confundir estados iniciais com finais",
                                    "Não marcar o estado inicial claramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e remover estados inalcançáveis",
                                  "subSteps": [
                                    "Execute uma busca em largura (BFS) ou profundidade (DFS) a partir do estado inicial, seguindo todas as transições possíveis.",
                                    "Marque todos os estados visitados como alcançáveis.",
                                    "Liste os estados não visitados como inalcançáveis.",
                                    "Crie uma cópia do AFD removendo os estados inalcançáveis e suas transições.",
                                    "Atualize os rótulos dos estados restantes se necessário (renomeie para q1, q2...)."
                                  ],
                                  "verification": "Lista de estados alcançáveis cobre todos os estados do novo AFD; teste com caminhos simulados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico do Step 1",
                                    "Folha para BFS/DFS (fila/pilha)"
                                  ],
                                  "tips": "Comece BFS com fila contendo apenas q0; processe transições para todos símbolos.",
                                  "learningObjective": "Dominar detecção de estados inalcançáveis usando busca em grafos.",
                                  "commonMistakes": [
                                    "Parar busca prematuramente",
                                    "Incluir estados inalcançáveis por engano",
                                    "Não atualizar transições de estados que apontavam para inalcançáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar estados mortos nos estados restantes",
                                  "subSteps": [
                                    "A partir de cada estado final, execute busca reversa (invertendo transições) para marcar estados que alcançam um final.",
                                    "Use BFS reverso: comece com estados finais na fila, marque precursores.",
                                    "Identifique estados não marcados como mortos (não alcançam final).",
                                    "Verifique se o estado inicial não é morto.",
                                    "Liste estados mortos explicitamente."
                                  ],
                                  "verification": "Simule strings que levam a estados mortos e confirme que não aceitam corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "AFD sem inalcançáveis do Step 2",
                                    "Tabela de transições invertidas"
                                  ],
                                  "tips": "Crie grafo reverso temporário para facilitar a busca backward.",
                                  "learningObjective": "Compreender estados mortos como aqueles sem caminho para aceitação.",
                                  "commonMistakes": [
                                    "Confundir busca reversa com forward",
                                    "Marcar estados finais como mortos",
                                    "Esquecer transições vazias ou sink states"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Remover estados mortos e validar o AFD otimizado",
                                  "subSteps": [
                                    "Remova estados mortos e transições associadas do AFD.",
                                    "Adicione transições para um novo estado morto único se necessário (para completude).",
                                    "Teste o novo AFD com strings da linguagem original e fora dela.",
                                    "Compare número de estados antes/depois e confirme linguagem preservada.",
                                    "Documente o processo em um relatório resumido."
                                  ],
                                  "verification": "AFD final tem menos estados, aceita mesmas strings que original; |Q'| < |Q|.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "AFD do Step 3",
                                    "Gerador de strings ou simulador de autômato (ex: JFLAP)"
                                  ],
                                  "tips": "Use JFLAP ou similar para automação de testes.",
                                  "learningObjective": "Validar que otimização preserva linguagem exata.",
                                  "commonMistakes": [
                                    "Remover estado inicial ou finais por engano",
                                    "Não completar transições após remoção",
                                    "Alterar linguagem aceita inadvertidamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere AFD com Σ={0,1}, estados {q0,q1,q2,q3,q4}, q0 inicial, q1 final. Transições: q0-0>q1, q0-1>q2; q2-0>q3, q2-1>q3 (q3 inalcançável? Não, wait: ajuste: adicione q4 morto. Após BFS: q3,q4 inalcançáveis se sem caminho. Real: q0 alcança q1,q2; q2 para q3 morto (não alcança final). Remove q3,q4; novo AFD: q0,q1,q2 com q2 agora morto? Ajuste exemplo: estados mortos q2 (sem path to q1). Resultado: só q0,q1.",
                              "finalVerifications": [
                                "Todos estados restantes são alcançáveis do inicial.",
                                "Todo estado restante alcança pelo menos um estado final.",
                                "Número de estados reduzido em pelo menos 1.",
                                "Teste de 5 strings aceitas e 5 rejeitadas iguais ao original.",
                                "Grafo completo sem estados pendentes.",
                                "Linguagem aceita preservada (simulação em ferramenta)."
                              ],
                              "assessmentCriteria": [
                                "Identificação correta de 100% dos estados inalcançáveis e mortos.",
                                "Remoção precisa sem alterar transições válidas.",
                                "Validação com testes de strings demonstra preservação da linguagem.",
                                "Documentação clara do processo com diagramas antes/depois.",
                                "Eficiência: tempo dentro do estimado e sem erros comuns.",
                                "Explicação verbal da busca BFS/DFS reversa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (BFS/DFS, alcançabilidade).",
                                "Programação: Implementação de autômatos em Python/Java (usando queues).",
                                "Engenharia de Software: Otimização de estruturas de dados em compiladores.",
                                "Lógica: Preservação de propriedades formais (equivalência de linguagens)."
                              ],
                              "realWorldApplication": "Em compiladores (lexers otimizados para regex), análise de protocolos de rede (otimizar FSAs para pattern matching eficiente), sistemas de controle (reduzir estados em controladores finitos para hardware embarcado)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Equivalência com AFD, Expressões Regulares e Conjuntos Regulares",
                        "description": "Teoremas que estabelecem a equivalência entre linguagens aceitas por AFN, AFD, geradas por expressões regulares e os conjuntos regulares da hierarquia de Chomsky.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Enunciar teoremas de equivalência",
                            "description": "Declarar formalmente que para todo AFN existe AFD equivalente (e vice-versa), e que L(AFN) é um conjunto regular, citando propriedades de fechamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de AFN e AFD",
                                  "subSteps": [
                                    "Leia a definição formal de Autômato Finito Não-Determinístico (AFN): Q, Σ, δ: Q × Σ → P(Q), q0, F.",
                                    "Compare com a definição de Autômato Finito Determinístico (AFD): Q, Σ, δ: Q × Σ → Q, q0, F.",
                                    "Identifique as diferenças principais: não-determinismo na função de transição do AFN (poder subset).",
                                    "Estude exemplos simples de AFN e AFD que reconhecem a mesma linguagem.",
                                    "Anote as semelhanças em termos de linguagens aceitas."
                                  ],
                                  "verification": "Escreva as definições formais de AFN e AFD de memória e destaque as diferenças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Teoria da Computação (ex: Sipser), notas de aula, diagramas de AFN/AFD.",
                                  "tips": "Use diagramas visuais para representar transições ε e não-determinísticas.",
                                  "learningObjective": "Compreender as estruturas formais de AFN e AFD como base para equivalência.",
                                  "commonMistakes": "Confundir a transição δ de AFN (retorna conjunto) com AFD (retorna estado único)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Teorema de Equivalência AFN ↔ AFD",
                                  "subSteps": [
                                    "Leia o enunciado: Para todo AFN M, existe AFD M' tal que L(M) = L(M'), e vice-versa.",
                                    "Aprenda a prova via construção do autômato dos subconjuntos: estados são subconjuntos de Q do AFN.",
                                    "Implemente mentalmente a construção para um AFN simples com ε-transições.",
                                    "Verifique que a linguagem aceita permanece a mesma.",
                                    "Pratique convertendo um AFN pequeno para AFD manualmente."
                                  ],
                                  "verification": "Construa o AFD equivalente para um AFN dado com 3 estados e confirme L(AFN) = L(AFD).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis para desenhar autômatos, simulador online de autômatos (ex: JFLAP).",
                                  "tips": "Comece com AFNs sem ε-transições para simplificar a compreensão inicial.",
                                  "learningObjective": "Dominar a construção que prova a equivalência entre AFN e AFD.",
                                  "commonMistakes": "Esquecer de incluir o subconjunto vazio ou estados inacessíveis na construção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Linguagens Regulares e Propriedades de Fechamento",
                                  "subSteps": [
                                    "Defina linguagem regular: L é regular se existe AFD (ou AFN) que a aceita.",
                                    "Estude propriedades de fechamento: regulares fechadas sob união, concatenação, estrela de Kleene.",
                                    "Conclua que L(AFN) é regular pois existe AFD equivalente.",
                                    "Cite teoremas formais: Se L1, L2 regulares, então L1 ∪ L2, L1 · L2, L1* regulares.",
                                    "Relacione com expressões regulares via teoremas de Kleene."
                                  ],
                                  "verification": "Enuncie as três propriedades de fechamento principais e dê um exemplo para cada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Notas sobre linguagens regulares, exemplos de expressões regulares.",
                                  "tips": "Use tabelas para listar operações de fechamento e exemplos.",
                                  "learningObjective": "Entender por que L(AFN) pertence à classe das linguagens regulares.",
                                  "commonMistakes": "Confundir fechamento com operações que geram linguagens não-regulares (ex: interseção com complementares)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enunciar Formalmente os Teoremas e Praticar",
                                  "subSteps": [
                                    "Escreva o teorema completo: ∀ AFN M, ∃ AFD M' s.t. L(M) = L(M') e L(M) regular.",
                                    "Inclua vice-versa e cite fechamento para justificar regularidade.",
                                    "Pratique enunciando em voz alta ou por escrito com variações.",
                                    "Resolva exercícios: dado AFN, afirme existência de AFD e regularidade de L.",
                                    "Compare com teoremas relacionados (ex: AFN ≡ expressões regulares)."
                                  ],
                                  "verification": "Escreva o teorema completo sem consultar materiais e explique em 2-3 frases.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Folha de exercícios, gravador de voz para prática oral.",
                                  "tips": "Use símbolos matemáticos precisos: ∀, ∃, L(·), ≡.",
                                  "learningObjective": "Enunciar com precisão e confiança os teoremas de equivalência.",
                                  "commonMistakes": "Omitir 'vice-versa' ou falhar em ligar à regularidade via fechamento."
                                }
                              ],
                              "practicalExample": "Considere o AFN M que aceita strings sobre {a,b} terminando em 'aa': estados {q0,q1,q2}, δ(q0,a)={q0,q1}, δ(q1,a)={q2}, F={q2}. Construa o AFD via subconjuntos: estados {{q0},{q0,q1},{q2}}, provando L(M) regular e equivalente a um AFD.",
                              "finalVerifications": [
                                "Enuncie corretamente o teorema AFN ↔ AFD sem erros formais.",
                                "Explique por que L(AFN) é sempre regular, citando fechamento.",
                                "Construa AFD para um AFN simples fornecido.",
                                "Identifique erros em um enunciado incompleto de teorema.",
                                "Relacione equivalência com expressões regulares."
                              ],
                              "assessmentCriteria": [
                                "Precisão formal no uso de notação matemática (∀, ∃, L(·)).",
                                "Correta inclusão de direção bidirecional e ligação com regularidade.",
                                "Demonstração da construção de subconjuntos em exemplo prático.",
                                "Citação explícita de propriedades de fechamento relevantes.",
                                "Clareza e fluidez na explicação oral ou escrita.",
                                "Ausência de confusões com classes de linguagens superiores."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de conjuntos e funções parciais.",
                                "Lógica: Provas por construção e propriedades de fechamento.",
                                "Programação: Implementação de NFA-to-DFA em linguagens como Python (regex engines).",
                                "Engenharia de Software: Parsers e analisadores léxicos em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores e ferramentas de regex (ex: grep, Python re), AFNs são convertidos em AFDs para eficiência em matching de padrões, garantindo que linguagens regulares sejam processáveis deterministicamente em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Relacionar AFN com expressões regulares",
                            "description": "Explicar a cadeia de equivalências: AFN ≡ AFD ≡ ER ≡ Conjuntos Regulares, esboçando provas via conversão AFN→AFD→ER usando eliminação de estados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de AFN, AFD, ER e Conjuntos Regulares",
                                  "subSteps": [
                                    "Defina formalmente AFN (Autômato Finito Não-Determinístico) com componentes: estados, alfabeto, função de transição (pode ser não-injetiva), estado inicial e estados finais.",
                                    "Defina AFD (Autômato Finito Determinístico) destacando a transição única por estado e símbolo.",
                                    "Explique Expressões Regulares (ER) como operadores união (|), concatenação e estrela de Kleene (*).",
                                    "Descreva Conjuntos Regulares como linguagens reconhecidas por AFN/AFD ou geradas por ER."
                                  ],
                                  "verification": "Liste definições corretas em um diagrama comparativo sem erros conceituais.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel e caneta, tutorial JFLAP ou livro 'Introduction to Automata Theory' de Hopcroft.",
                                  "tips": "Use diagramas visuais para diferenciar AFN (múltiplas transições) de AFD (transições únicas).",
                                  "learningObjective": "Compreender as diferenças e semelhanças formais entre os modelos.",
                                  "commonMistakes": "Confundir não-determinismo com ambiguidade ou ignorar ε-transições em AFN."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar Equivalência AFN ≡ AFD via Construção do Conjunto de Subconjuntos",
                                  "subSteps": [
                                    "Construa o AFD equivalente a partir do AFN usando powerset: estados do AFD são subconjuntos de estados do AFN.",
                                    "Defina a função de transição do AFD: δ(Q, a) = ∪ δ(q, a) para q em Q.",
                                    "Inclua o estado inicial {q0} e estados finais como subconjuntos contendo estados finais do AFN.",
                                    "Prove que L(AFN) = L(AFD) por indução no comprimento da palavra.",
                                    "Implemente em ferramenta para um exemplo simples."
                                  ],
                                  "verification": "Construa corretamente o AFD para um AFN dado com pelo menos 3 estados.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software JFLAP ou Draw.io para diagramas, exemplos de AFN impressos.",
                                  "tips": "Comece com AFN sem ε-transições para simplificar; adicione depois.",
                                  "learningObjective": "Dominar a conversão AFN → AFD e entender por que preserva a linguagem.",
                                  "commonMistakes": "Esquecer de fechar sob transição (não computar todos os subconjuntos alcançáveis)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter AFD para Expressão Regular via Eliminação de Estados",
                                  "subSteps": [
                                    "Aplique o algoritmo de eliminação de estados: para cada estado não-inicial/final, resolva equações de Arden.",
                                    "Elimine estados um a um: substitua transições passando pelo estado eliminado por R1 + R1 S R2, onde S é auto-loop.",
                                    "Reduza até sobrar um estado com ER de inicial para final.",
                                    "Verifique com equações lineares: Qi = ∪ Rj Qi+1 + Fi para estados ordenados.",
                                    "Teste com AFD pequeno derivado de AFN anterior."
                                  ],
                                  "verification": "Derive ER correta para um AFD com 3-4 estados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Folha de cálculo para equações, JFLAP com plugin de regex.",
                                  "tips": "Ordene eliminação: estados sem saída primeiro; anote R(i,j)^k para caminhos.",
                                  "learningObjective": "Executar conversão AFD → ER e esboçar prova de correção.",
                                  "commonMistakes": "Erro na aplicação da regra de eliminação (confundir com composição de regex)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer e Esboçar a Cadeia Completa de Equivalências",
                                  "subSteps": [
                                    "Conecte: AFN ≡ AFD (passo 2) → AFD ≡ ER (passo 3) → ER gera Conjuntos Regulares.",
                                    "Prove ER ≡ Conjuntos Regulares bidirecionalmente (ER → AFD via Thompson, AFD → ER já feito).",
                                    "Esboce provas gerais: todo Conjunto Regular tem AFN (direto), e conversões fecham o ciclo.",
                                    "Discuta propriedades preservadas: fechamento sob união, concatenação, estrela.",
                                    "Resuma em um fluxograma da cadeia AFN → AFD → ER."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a cadeia com esboço de provas para um exemplo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Fluxograma tool como Lucidchart, resumo em Markdown.",
                                  "tips": "Use setas bidirecionais para equivalências; foque em 'preserva linguagem'.",
                                  "learningObjective": "Articular a teoria da equivalência e suas implicações.",
                                  "commonMistakes": "Achar que conversões são 1-1 (são many-to-one, mas preservam L)."
                                }
                              ],
                              "practicalExample": "Considere a linguagem de strings sobre {0,1} com '11' como subpalavra. Construa AFN com não-determinismo (salto para estado que aceita '11'). Converta para AFD via powerset (4 estados). Elimine estados para obter ER: (0|1)*(11)(0|1)*. Verifique aceitando/rejeitando palavras como '0110' (aceita) e '010' (rejeita).",
                              "finalVerifications": [
                                "Converte AFN dado para ER via AFD corretamente.",
                                "Explica cadeia AFN ≡ AFD ≡ ER ≡ Conjuntos Regulares sem falhas.",
                                "Identifica erros em conversões alheias.",
                                "Aplica eliminação de estados em AFD novo.",
                                "Descreve proofs por indução ou invariantes.",
                                "Gera ER para linguagens simples e valida com autômato."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (90% correto).",
                                "Correção nas construções de conversão (sem estados perdidos).",
                                "Clareza no esboço de provas (passos lógicos visíveis).",
                                "Criatividade em exemplos práticos e verificações.",
                                "Profundidade nas conexões teóricas (menciona fechamentos).",
                                "Tempo de execução eficiente das conversões manuais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Indução (powersets, proofs).",
                                "Lógica: Equivalências e Inferência (preservação de propriedades).",
                                "Programação: Regex em Python/Java para validação prática.",
                                "Algoritmos: Otimização de autômatos (minimização AFD)."
                              ],
                              "realWorldApplication": "Em compiladores e editores de texto (VS Code, grep), regex derivadas de AFN modelam padrões como e-mails ou CPFs; otimização via AFD acelera matching em buscas de texto massivo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.1",
                              "10.1.1.5.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Linguagens e Gramáticas Formais",
                "description": "Conceitos de linguagens formais e gramáticas, abrangendo a hierarquia de Chomsky.",
                "totalSkills": 59,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Conceitos Básicos de Linguagens Formais",
                    "description": "Definição formal de alfabeto, palavra, linguagem e operações sobre linguagens.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Alfabeto Formal",
                        "description": "Definição formal de um alfabeto como um conjunto finito e não vazio de símbolos distintos, base fundamental para a construção de palavras e linguagens.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Definir um alfabeto formal",
                            "description": "Explicar que um alfabeto Σ é um conjunto finito de símbolos, como Σ = {0,1} ou Σ = {a,b,c}, e listar suas propriedades essenciais (finito, não vazio).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de um alfabeto formal",
                                  "subSteps": [
                                    "Leia a definição formal: um alfabeto Σ é um conjunto finito de símbolos distintos.",
                                    "Identifique símbolos como caracteres básicos usados para formar palavras ou strings.",
                                    "Diferencie alfabeto de linguagem: alfabeto é apenas os símbolos, não as combinações.",
                                    "Anote exemplos iniciais como Σ = {0,1} para binário.",
                                    "Discuta por que o alfabeto é a base das linguagens formais."
                                  ],
                                  "verification": "Escreva uma definição em suas próprias palavras e compare com a definição padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Teoria da Computação",
                                    "Notebook para anotações",
                                    "Vídeo introdutório sobre linguagens formais (ex: YouTube - Automata Theory)"
                                  ],
                                  "tips": "Use analogia com alfabeto humano (a-z) para fixar o conceito.",
                                  "learningObjective": "Entender que um alfabeto é um conjunto finito de símbolos fundamentais.",
                                  "commonMistakes": [
                                    "Confundir alfabeto com linguagem completa",
                                    "Pensar que pode ser infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar e explicar as propriedades essenciais do alfabeto",
                                  "subSteps": [
                                    "Propriedade 1: Finito - prove com exemplo que conjuntos infinitos não são alfabetos.",
                                    "Propriedade 2: Não vazio - explique por que Σ = {} é inválido.",
                                    "Propriedade 3: Símbolos distintos - demonstre com Σ = {a,a} sendo inválido (duplicatas ignoradas).",
                                    "Propriedade 4: Símbolos atômicos - não decomponíveis.",
                                    "Crie uma tabela resumindo propriedades com exemplos e contraexemplos."
                                  ],
                                  "verification": "Crie uma lista numerada das 4 propriedades principais e justifique cada uma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel ou editor de texto para tabela",
                                    "Referência: Sipser 'Introduction to the Theory of Computation' capítulo 1"
                                  ],
                                  "tips": "Lembre-se: finito e não-vazio são cruciais para computabilidade.",
                                  "learningObjective": "Memorizar e justificar as propriedades que definem um alfabeto válido.",
                                  "commonMistakes": [
                                    "Ignorar 'finito' e sugerir alfabeto com números reais",
                                    "Confundir vazio com singleton {ε}"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar com exemplos e contraexemplos de alfabetos",
                                  "subSteps": [
                                    "Exemplo válido: Σ = {a,b,c} - liste 3 strings possíveis.",
                                    "Exemplo válido: Σ = {0,1} - explique uso em computadores.",
                                    "Contraexemplo: Σ = {todos os números reais} - por quê inválido?",
                                    "Contraexemplo: Σ = {} - consequências para linguagens.",
                                    "Classifique 5 conjuntos dados como alfabeto ou não."
                                  ],
                                  "verification": "Classifique corretamente 5 exemplos fornecidos em um quiz autoavaliado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de exercícios impressa ou Google Docs",
                                    "Exercícios online de Teoria dos Autômatos"
                                  ],
                                  "tips": "Sempre pergunte: finito? Não-vazio? Símbolos distintos?",
                                  "learningObjective": "Aplicar a definição para validar ou refutar alfabetos propostos.",
                                  "commonMistakes": [
                                    "Aceitar conjuntos com duplicatas",
                                    "Permitir símbolos compostos como 'ab' em Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir um alfabeto formal próprio e documentá-lo",
                                  "subSteps": [
                                    "Escolha um contexto (ex: DNA: {A,C,G,T}).",
                                    "Escreva Σ = {...} com notação padrão.",
                                    "Liste propriedades verificadas.",
                                    "Gere 5 strings de exemplo sobre Σ*.",
                                    "Explique uma aplicação simples."
                                  ],
                                  "verification": "Apresente sua definição para um par ou auto-revisão, confirmando todas propriedades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor LaTeX ou Markdown para notação Σ",
                                    "Modelos de exemplos de alfabetos"
                                  ],
                                  "tips": "Use notação matemática precisa: Σ = {s1, s2, ...}.",
                                  "learningObjective": "Criar e justificar uma definição completa de alfabeto formal.",
                                  "commonMistakes": [
                                    "Esquecer de especificar finitude",
                                    "Incluir ε como símbolo sem contexto"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina Σ = {0,1} como o alfabeto binário usado em computadores. Propriedades: finito (2 símbolos), não-vazio. Strings: ε, 0, 1, 00, 01, 10, 11. Aplicação: representar dados em máquinas.",
                              "finalVerifications": [
                                "Pode definir alfabeto Σ em notação matemática correta?",
                                "Lista todas propriedades essenciais sem erros?",
                                "Identifica exemplos e contraexemplos corretamente?",
                                "Explica por que finito e não-vazio são obrigatórios?",
                                "Cria um alfabeto válido para um contexto dado?",
                                "Gera strings básicas sobre Σ*?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (100% das propriedades cobertas)",
                                "Uso correto de notação Σ = {...}",
                                "Qualidade dos exemplos e contraexemplos (relevantes e variados)",
                                "Justificativas lógicas para propriedades",
                                "Criatividade na definição personalizada",
                                "Clareza na explicação escrita/oral"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (finito, não-vazio)",
                                "Linguística: Fonemas como símbolos em linguagens naturais",
                                "Física/Química: Símbolos em genomas (DNA bases)",
                                "Programação: Caracteres ASCII como alfabeto",
                                "Criptografia: Alfabetos em cifras (ex: {A-Z})"
                              ],
                              "realWorldApplication": "Em compiladores, o alfabeto define tokens válidos (ex: Σ = {letras, dígitos, símbolos}); em telecomunicações, Σ = {0,1} para transmissão digital; em bioinformática, Σ = {A,C,G,T,U} para sequências genéticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Identificar símbolos válidos em um alfabeto",
                            "description": "Dado um alfabeto Σ, determinar quais símbolos pertencem a Σ e quais não, distinguindo elementos válidos de inválidos em exemplos concretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de alfabeto formal",
                                  "subSteps": [
                                    "Leia a definição de alfabeto formal: um conjunto finito de símbolos indivisíveis.",
                                    "Compare com exemplos cotidianos, como o alfabeto latino {a,b,c,...,z}.",
                                    "Identifique que símbolos são atômicos e não podem ser decompostos.",
                                    "Diferencie alfabeto de string ou palavra.",
                                    "Anote 3 exemplos de alfabetos em diferentes contextos (binário, decimal)."
                                  ],
                                  "verification": "Explique em suas palavras o que é um alfabeto e dê um exemplo não fornecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro ou notas sobre linguagens formais",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use analogias como 'blocos de construção' para visualizar símbolos.",
                                  "learningObjective": "Compreender a definição fundamental de alfabeto como conjunto finito de símbolos.",
                                  "commonMistakes": [
                                    "Confundir alfabeto com linguagem completa",
                                    "Achar que símbolos podem ser compostos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar a notação de alfabeto Σ",
                                  "subSteps": [
                                    "Estude a notação Σ = {s1, s2, ..., sn}, onde Σ é o nome do alfabeto.",
                                    "Pratique lendo exemplos: Σ = {0,1}, Σ = {a,b,c}.",
                                    "Liste explicitamente os elementos de 5 alfabetos dados.",
                                    "Reconheça que a ordem não importa e duplicatas são ignoradas.",
                                    "Escreva a notação para um alfabeto dado verbalmente."
                                  ],
                                  "verification": "Converta corretamente 3 notações Σ para listas e vice-versa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos impressos de notações Σ",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Sempre use chaves {} para denotar conjuntos.",
                                  "learningObjective": "Dominar a leitura e escrita da notação padrão de alfabetos.",
                                  "commonMistakes": [
                                    "Incluir vírgulas extras ou esquecer chaves",
                                    "Confundir com listas ordenadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar símbolos como válidos ou inválidos",
                                  "subSteps": [
                                    "Dado Σ, para cada símbolo s: se s ∈ Σ, válido; senão, inválido.",
                                    "Pratique com Σ = {a,b}: classifique a, c, b, d.",
                                    "Crie uma tabela: símbolo | válido? | razão.",
                                    "Teste com símbolos especiais: Σ = {0,1,#}, classifique 0, a, #, 2.",
                                    "Repita com 10 símbolos mistos para um Σ dado."
                                  ],
                                  "verification": "Classifique corretamente 10 símbolos para um Σ sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Lista de Σ e símbolos para teste"
                                  ],
                                  "tips": "Use ∈ para checar pertencimento mentalmente.",
                                  "learningObjective": "Aplicar critério de pertencimento a conjuntos para validação.",
                                  "commonMistakes": [
                                    "Achar maiúsculas/minúsculas irrelevantes",
                                    "Confundir com subconjuntos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em exemplos concretos e autoavaliar",
                                  "subSteps": [
                                    "Resolva exercícios mistos: múltiplos Σ e listas de símbolos.",
                                    "Para cada inválido, explique por quê não pertence.",
                                    "Crie seu próprio Σ e teste com 5 símbolos inventados.",
                                    "Compare respostas com soluções modelo.",
                                    "Registre erros e corrija-os imediatamente."
                                  ],
                                  "verification": "Resolva um conjunto de 5 exercícios complexos com 100% acerto.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios impressos ou online",
                                    "Soluções modelo"
                                  ],
                                  "tips": "Sempre justifique inválidos para reforçar raciocínio.",
                                  "learningObjective": "Integrar conhecimento em cenários práticos com auto-correção.",
                                  "commonMistakes": [
                                    "Ignorar símbolos vazios ou nulos",
                                    "Não justificar classificações"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado Σ = {0, 1, #}, classifique: '0' (válido), 'a' (inválido, não pertence), '1' (válido), '$' (inválido), '#' (válido). Crie uma tabela e justifique cada um.",
                              "finalVerifications": [
                                "Lista corretamente todos os símbolos de qualquer Σ dado.",
                                "Classifica 20 símbolos mistos sem erros em 5 minutos.",
                                "Explica a diferença entre válido e inválido com exemplos.",
                                "Cria um Σ próprio e valida símbolos corretamente.",
                                "Identifica erros em classificações de pares.",
                                "Aplica o conceito a alfabetos com símbolos especiais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pertencimento (100% correto).",
                                "Justificativas claras e concisas para cada classificação.",
                                "Velocidade: classifica 10 símbolos em menos de 2 minutos.",
                                "Criatividade em exemplos próprios.",
                                "Ausência de confusão com conceitos relacionados (ex: strings).",
                                "Uso correto da notação Σ em respostas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (pertencimento ∈).",
                                "Lógica: Classificação booleana (verdadeiro/falso).",
                                "Programação: Validação de caracteres em strings (if char in alphabet).",
                                "Linguística: Fonemas como símbolos em alfabetos fonéticos.",
                                "Engenharia: Protocolos de comunicação (alfabetos de sinais válidos)."
                              ],
                              "realWorldApplication": "Em compiladores, validar caracteres de código-fonte contra alfabeto da linguagem; em redes, checar pacotes contra símbolos permitidos para evitar injeções maliciosas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Fornecer exemplos de alfabetos",
                            "description": "Criar e reconhecer exemplos de alfabetos usados em computação, como alfabeto binário {0,1}, alfabeto de letras minúsculas ou símbolos especiais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de alfabeto formal",
                                  "subSteps": [
                                    "Defina alfabeto formal como um conjunto finito de símbolos distintos.",
                                    "Explique que os símbolos são indivisíveis e não têm significado inerente.",
                                    "Discuta propriedades: finito, não vazio, símbolos únicos.",
                                    "Diferencie alfabeto de string ou linguagem.",
                                    "Estude notação: Σ = {a, b} ou Σ = {0, 1}."
                                  ],
                                  "verification": "Escreva uma definição precisa e cite um exemplo simples como Σ = {0, 1}.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notebook ou computador com acesso à internet para referências básicas"
                                  ],
                                  "tips": "Use analogias como 'letras do alfabeto humano' para fixar o conceito.",
                                  "learningObjective": "Entender a definição e propriedades fundamentais de um alfabeto formal.",
                                  "commonMistakes": "Confundir alfabeto com linguagem (alfabeto é só os símbolos básicos)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer exemplos comuns de alfabetos em computação",
                                  "subSteps": [
                                    "Analise alfabeto binário: Σ = {0, 1}, usado em máquinas digitais.",
                                    "Examine alfabeto de letras minúsculas: Σ = {a, b, ..., z}.",
                                    "Estude alfabeto de símbolos especiais: Σ = {+, -, *, /}.",
                                    "Identifique alfabeto ASCII completo ou Unicode básico.",
                                    "Classifique cada exemplo quanto ao tamanho e aplicação."
                                  ],
                                  "verification": "Liste 3 exemplos com notação correta e uma breve justificativa para cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou papel",
                                    "Referências online sobre teoria da computação"
                                  ],
                                  "tips": "Desenhe os conjuntos em um diagrama de Venn para visualizar diferenças.",
                                  "learningObjective": "Identificar e descrever alfabetos padrão usados em contextos computacionais.",
                                  "commonMistakes": "Incluir espaços ou números em alfabetos de letras puras."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar exemplos personalizados de alfabetos",
                                  "subSteps": [
                                    "Escolha um domínio específico (ex: tráfego: {verde, amarelo, vermelho}).",
                                    "Defina o conjunto finito de símbolos relevantes.",
                                    "Escreva em notação formal: Σ = {...}.",
                                    "Valide: símbolos distintos, finito, sem repetições.",
                                    "Crie pelo menos 3 exemplos variados."
                                  ],
                                  "verification": "Apresente 3 alfabetos originais com notação e contexto de uso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Computador com editor de texto",
                                    "Papel para rascunhos"
                                  ],
                                  "tips": "Comece com domínios cotidianos para facilitar a criatividade.",
                                  "learningObjective": "Desenvolver habilidade para construir alfabetos formais adaptados a cenários.",
                                  "commonMistakes": "Criar conjuntos infinitos ou com símbolos duplicados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e validar exemplos em contextos formais",
                                  "subSteps": [
                                    "Combine símbolos de um alfabeto para formar strings curtas (ex: 01, 10).",
                                    "Verifique se todas as strings usam apenas símbolos do alfabeto.",
                                    "Discuta limitações: o que acontece com símbolos externos?",
                                    "Compare seu alfabeto com um padrão computacional.",
                                    "Documente um relatório simples com exemplos."
                                  ],
                                  "verification": "Gere 5 strings válidas de um alfabeto criado e explique por quê.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou planilha",
                                    "Exemplos de livros de teoria da computação"
                                  ],
                                  "tips": "Use ferramentas online como geradores de strings para testar.",
                                  "learningObjective": "Validar e aplicar alfabetos em construções formais básicas.",
                                  "commonMistakes": "Gerar strings com símbolos fora do alfabeto definido."
                                }
                              ],
                              "practicalExample": "Crie um alfabeto para um semáforo inteligente: Σ = {V, A, R}, onde V=verde, A=amarelo, R=vermelho. Gere strings como 'VAR' representando uma sequência de luzes.",
                              "finalVerifications": [
                                "Pode definir alfabeto formal corretamente.",
                                "Lista pelo menos 3 exemplos computacionais com notação Σ.",
                                "Cria 2 alfabetos originais válidos.",
                                "Gera strings usando apenas símbolos do alfabeto.",
                                "Explica diferenças entre alfabeto, string e linguagem.",
                                "Identifica erros comuns em exemplos de pares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e notação formal (Σ).",
                                "Diversidade e relevância dos exemplos fornecidos.",
                                "Corretude na criação de alfabetos personalizados (finito, distintos).",
                                "Capacidade de gerar e validar strings derivadas.",
                                "Clareza na explicação de aplicações computacionais.",
                                "Ausência de confusões conceituais básicas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (alfabeto como conjunto finito).",
                                "Linguística: Fonemas e morfemas como símbolos básicos.",
                                "Física: Sinais digitais (binário em circuitos).",
                                "Artes: Símbolos gráficos em design de interfaces."
                              ],
                              "realWorldApplication": "Em compiladores e parsers, o alfabeto define tokens válidos no código-fonte; em criptografia, alfabetos como {0,1} baseiam codificações seguras; em IA, define vocabulários para processamento de linguagem natural."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Palavra (String)",
                        "description": "Definição formal de uma palavra como uma sequência finita (incluindo vazia) de símbolos provenientes de um alfabeto dado.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Definir e formar palavras sobre um alfabeto",
                            "description": "Explicar que uma palavra w ∈ Σ* é uma concatenação finita de símbolos de Σ, incluindo a palavra vazia ε, e construir palavras simples como 'ab' sobre Σ={a,b}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de alfabeto em linguagens formais",
                                  "subSteps": [
                                    "Defina um alfabeto Σ como um conjunto finito e não vazio de símbolos distintos.",
                                    "Identifique exemplos de alfabetos, como Σ = {a, b} ou Σ = {0, 1}.",
                                    "Explique que os símbolos são os blocos de construção básicos para formar palavras.",
                                    "Liste os elementos de um alfabeto dado, como Σ = {a, b, c}.",
                                    "Diferencie alfabeto de outros conjuntos, enfatizando sua finitude."
                                  ],
                                  "verification": "Escreva a definição de alfabeto e forneça dois exemplos corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples",
                                  "tips": "Use símbolos simples e evite confundir com números ou letras comuns.",
                                  "learningObjective": "Compreender o alfabeto como base para linguagens formais.",
                                  "commonMistakes": "Confundir alfabeto com palavras ou assumir que pode ser infinito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender palavras como concatenações finitas de símbolos",
                                  "subSteps": [
                                    "Explique que uma palavra w é uma sequência finita de símbolos de Σ, denotada w ∈ Σ*.",
                                    "Descreva Σ* como o conjunto de todas as palavras possíveis sobre Σ, incluindo sequências de qualquer comprimento finito.",
                                    "Forme palavras curtas: para Σ = {a, b}, crie 'a', 'b', 'aa', 'ab'.",
                                    "Represente a concatenação: 'a' seguido de 'b' resulta em 'ab'.",
                                    "Calcule o número de palavras de comprimento n: |Σ|^n."
                                  ],
                                  "verification": "Gere 5 palavras diferentes sobre Σ = {a, b} e explique sua formação por concatenação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, caneta e tabela para listar palavras",
                                  "tips": "Visualize concatenação como colar símbolos lado a lado.",
                                  "learningObjective": "Dominar a noção de palavra como concatenação finita.",
                                  "commonMistakes": "Esquecer que a ordem importa ou incluir símbolos fora de Σ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a palavra vazia ε",
                                  "subSteps": [
                                    "Defina ε como a palavra vazia, com comprimento 0, pertencente a Σ* para qualquer Σ.",
                                    "Explique que ε é a identidade para concatenação: w · ε = ε · w = w.",
                                    "Diferencie ε de palavras não vazias e de símbolos únicos.",
                                    "Inclua ε em listas de palavras sobre Σ = {a, b}: ε, a, b, aa, etc.",
                                    "Verifique que ε não contém símbolos, mas é uma palavra válida."
                                  ],
                                  "verification": "Explique o papel de ε em Σ* e demonstre concatenação com uma palavra não vazia.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta",
                                  "tips": "Pense em ε como uma 'caixa vazia' que não altera a concatenação.",
                                  "learningObjective": "Reconhecer a palavra vazia como elemento fundamental de Σ*.",
                                  "commonMistakes": "Confundir ε com um símbolo ou achar que não pertence a Σ*."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e listar palavras simples sobre um alfabeto",
                                  "subSteps": [
                                    "Escolha Σ = {a, b} e liste todas as palavras de comprimento 0, 1 e 2.",
                                    "Construa 'ab' como a · b.",
                                    "Gere palavras aleatórias: combine símbolos em sequências finitas.",
                                    "Verifique se cada palavra usa apenas símbolos de Σ.",
                                    "Crie uma árvore de geração de palavras até comprimento 3."
                                  ],
                                  "verification": "Liste 10 palavras sobre Σ = {a, b}, incluindo ε, e classifique por comprimento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, caneta ou planilha para tabulação",
                                  "tips": "Use uma tabela: linhas para comprimento, colunas para combinações.",
                                  "learningObjective": "Aplicar conceitos para formar palavras concretas.",
                                  "commonMistakes": "Gerar palavras infinitas ou com símbolos inválidos."
                                }
                              ],
                              "practicalExample": "Dado Σ = {a, b}, forme a palavra 'ab' como concatenação de 'a' e 'b'. Liste Σ* parcial: ε, a, b, aa, ab, ba, bb. Verifique: 'ab' ∈ Σ* pois é finita e usa só símbolos de Σ.",
                              "finalVerifications": [
                                "Definição correta de alfabeto e Σ* fornecida.",
                                "Palavra vazia ε explicada com propriedades de concatenação.",
                                "Pelo menos 8 palavras formadas corretamente sobre Σ = {a, b}.",
                                "Exemplo de concatenação demonstrado (ex: 'a' + 'b' = 'ab').",
                                "Número de palavras de comprimento 2 calculado: 4.",
                                "Diferenciação clara entre símbolos, palavras e ε."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de conceitos fundamentais (alfabeto, Σ*, ε).",
                                "Capacidade de formar palavras corretas sem erros de símbolos.",
                                "Compreensão de concatenação via exemplos práticos.",
                                "Inclusão e explicação adequada da palavra vazia.",
                                "Criatividade e completude na listagem de palavras.",
                                "Uso correto de notação matemática (∈, ·)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conjuntos finitos e potências (Σ^n).",
                                "Linguística: Morfemas como símbolos e palavras como sequências.",
                                "Programação: Strings em linguagens como Python (ex: 'ab' = 'a' + 'b').",
                                "Biologia: Sequências de DNA como palavras sobre alfabeto {A, C, G, T}."
                              ],
                              "realWorldApplication": "Em programação, strings são palavras sobre alfabetos (ex: ASCII); em compiladores, tokens são formados assim; em criptografia, mensagens são sequências sobre {0,1}; em genômica, genes como strings de nucleotídeos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Calcular o comprimento de uma palavra",
                            "description": "Determinar o comprimento |w| de uma palavra, contando o número de símbolos, e distinguir palavras vazias (|ε|=0) de não vazias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Formal de Palavra e Comprimento",
                                  "subSteps": [
                                    "Leia a definição: Uma palavra w é uma sequência finita de símbolos de um alfabeto Σ.",
                                    "Entenda que o comprimento |w| é o número total de símbolos na sequência.",
                                    "Identifique exemplos: Para w = 'ab' sobre Σ = {a,b}, |w| = 2.",
                                    "Diferencie de outros conceitos: Comprimento não considera repetições ou ordem.",
                                    "Anote a notação |ε| = 0 para a palavra vazia ε."
                                  ],
                                  "verification": "Escreva a definição de |w| e dê dois exemplos corretos, incluindo ε.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referência de linguagens formais (livro ou PDF)"
                                  ],
                                  "tips": "Use setas para visualizar a sequência: ε → (vazia) |ab| → a-b.",
                                  "learningObjective": "Dominar a definição formal de palavra e seu comprimento.",
                                  "commonMistakes": [
                                    "Confundir comprimento com o número de símbolos únicos",
                                    "Ignorar que ε é uma palavra válida com comprimento 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Comprimento de Palavras Não Vazias Passo a Passo",
                                  "subSteps": [
                                    "Escolha uma palavra w, ex: 'xyz'.",
                                    "Liste cada símbolo individualmente: posição 1: x, 2: y, 3: z.",
                                    "Conte o número de posições ocupadas.",
                                    "Repita para outra palavra com 5+ símbolos.",
                                    "Registre |w| = número de símbolos contados."
                                  ],
                                  "verification": "Calcule |'hello'| e liste os símbolos com posições; resultado deve ser 5.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de palavras de teste (ex: 'cat', 'computer')",
                                    "Marcadores ou contador manual"
                                  ],
                                  "tips": "Conte com os dedos ou use uma tabela para rastrear símbolos.",
                                  "learningObjective": "Executar contagem precisa de símbolos em palavras não vazias.",
                                  "commonMistakes": [
                                    "Contar espaços ou quebras de linha como símbolos",
                                    "Pular símbolos no meio da contagem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Distinguir e Calcular Comprimento da Palavra Vazia",
                                  "subSteps": [
                                    "Defina ε como a sequência com zero símbolos.",
                                    "Visualize: Não há nada para contar, logo |ε| = 0.",
                                    "Compare com palavra de 1 símbolo: |a| = 1 vs |ε| = 0.",
                                    "Identifique em contextos: ε é usada em concatenação wε = w.",
                                    "Pratique afirmando: 'ε é vazia e não vazia é |w| ≥ 1'."
                                  ],
                                  "verification": "Explique por que |ε| = 0 e dê um exemplo de distinção com w = 'a'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama vazio vs não vazio (desenhe)",
                                    "Exemplos de concatenação"
                                  ],
                                  "tips": "Pense em ε como uma caixa vazia; não adiciona símbolos.",
                                  "learningObjective": "Diferenciar corretamente palavras vazias de não vazias pelo comprimento.",
                                  "commonMistakes": [
                                    "Atribuir |ε| = 1 por 'contar o vazio'",
                                    "Confundir ε com símbolo nulo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Cálculos Mistos e Verificar Consistência",
                                  "subSteps": [
                                    "Selecione 5 palavras variadas: ε, 'a', 'bb', 'abcde', 'computacao'.",
                                    "Calcule |w| para cada uma sequencialmente.",
                                    "Compare resultados com uma tabela: palavra | comprimento.",
                                    "Teste distinção: Classifique cada como vazia ou não vazia.",
                                    "Autoavalie: Todos os cálculos batem com a contagem manual?"
                                  ],
                                  "verification": "Crie e complete uma tabela com 5 exemplos corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Gerador de strings aleatórias (opcional)"
                                  ],
                                  "tips": "Use um cronômetro para simular precisão sob pressão.",
                                  "learningObjective": "Aplicar cálculo de comprimento de forma consistente em diversos casos.",
                                  "commonMistakes": [
                                    "Inconsistência na contagem longa",
                                    "Falhar em classificar ε corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule o comprimento da palavra w = 'automata' sobre Σ = {a-z}. Passos: Liste símbolos (a-u-t-o-m-a-t-a), conte 8. Agora ε: 0 símbolos, |ε| = 0. Distinção: 'automata' é não vazia (|w| = 8 > 0).",
                              "finalVerifications": [
                                "Calcula corretamente |w| para palavras de 0 a 10+ símbolos.",
                                "Sempre atribui |ε| = 0 sem exceções.",
                                "Distin gui palavras vazias (|w|=0) de não vazias (|w|≥1).",
                                "Lista símbolos corretamente em contagem manual.",
                                "Mantém consistência em múltiplos exemplos.",
                                "Explica a definição formal quando questionado."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos cálculos de |w|.",
                                "Correta identificação e tratamento de ε.",
                                "Clareza na distinção vazia/não vazia.",
                                "Eficiência no método de contagem (sem erros manuais).",
                                "Capacidade de generalizar para qualquer alfabeto Σ.",
                                "Uso correto de notação formal em respostas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Contagem cardinal de conjuntos finitos.",
                                "Programação: Implementação da função len() em linguagens como Python.",
                                "Linguística: Análise morfológica de morfemas e comprimento silábico.",
                                "Lógica: Conceitos de nulidade em estruturas discretas."
                              ],
                              "realWorldApplication": "Em compiladores e parsers, calcular comprimento de tokens para alocação de memória; validar comprimento mínimo de senhas ou usernames em sistemas; analisar strings em processamento de linguagem natural (NLP) para métricas de texto."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Reconhecer subpalavras e operações básicas",
                            "description": "Identificar prefixos, sufixos e subpalavras em uma dada palavra, como em w=abc, prefixo 'a', sufixo 'c'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender definições básicas de prefixo, sufixo e subpalavra",
                                  "subSteps": [
                                    "Defina prefixo como qualquer sequência inicial de uma palavra (string), ex: para w='abc', prefixos são '', 'a', 'ab', 'abc'.",
                                    "Defina sufixo como qualquer sequência final, ex: '', 'c', 'bc', 'abc'.",
                                    "Defina subpalavra (substring) como qualquer sequência contínua, ex: 'a', 'b', 'c', 'ab', 'bc'.",
                                    "Diferencie subpalavra de subsequência (não contínua).",
                                    "Anote exemplos em uma tabela para fixar."
                                  ],
                                  "verification": "Liste corretamente todos os prefixos, sufixos e substrings de uma string simples como 'ab'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples.",
                                  "tips": "Use strings curtas (até 4 caracteres) para visualizar facilmente.",
                                  "learningObjective": "Dominar as definições precisas de prefixo, sufixo e substring em linguagens formais.",
                                  "commonMistakes": "Confundir substring com subsequência não contínua, como achar que 'ac' é substring de 'abc'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar prefixos e sufixos em palavras dadas",
                                  "subSteps": [
                                    "Dada w='abcd', liste todos os prefixos: '', 'a', 'ab', 'abc', 'abcd'.",
                                    "Liste todos os sufixos: '', 'd', 'cd', 'bcd', 'abcd'.",
                                    "Repita com w='xyz', verificando inclusão do string vazio.",
                                    "Crie uma regra: prefixo de tamanho k é os primeiros k caracteres.",
                                    "Teste com 3 palavras diferentes."
                                  ],
                                  "verification": "Para w='test', produza lista completa de prefixos e sufixos sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Lista de strings exemplo: 'abc', 'test', 'xyz'.",
                                  "tips": "Conte os caracteres da esquerda para prefixos e da direita para sufixos.",
                                  "learningObjective": "Aplicar definições para listar prefixos e sufixos corretamente.",
                                  "commonMistakes": "Esquecer o prefixo/sufixo vazio ou listar duplicatas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer subpalavras (substrings) contínuas",
                                  "subSteps": [
                                    "Para w='abcd', liste substrings: todos prefixos de sufixos, ex: 'a','ab','abc','b','bc','c','cd','d'.",
                                    "Gere sistematicamente: para cada posição inicial i e final j >= i.",
                                    "Exclua subsequências não contínuas como 'ad'.",
                                    "Compare com prefixos/sufixos para ver sobreposições.",
                                    "Pratique com w='hello': liste 10 substrings únicas."
                                  ],
                                  "verification": "Liste todas as 10 substrings únicas de 'abcd' corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Grade para anotar posições i-j ou ferramenta online de strings.",
                                  "tips": "Visualize a string como uma linha e substrings como segmentos contínuos.",
                                  "learningObjective": "Identificar todas as substrings contínuas de uma string.",
                                  "commonMistakes": "Incluir substrings não contínuas ou duplicar listas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar operações básicas com subpalavras",
                                  "subSteps": [
                                    "Verifique se uma string dada é prefixo/sufixo/substring de outra, ex: 'ab' é prefixo de 'abc'.",
                                    "Concatene: mostre que prefixo + resto = string original.",
                                    "Encontre a menor substring que contenha certas letras.",
                                    "Resolva exercícios: dada w='abcde', é 'ace' uma substring? (Não).",
                                    "Crie 5 perguntas de verificação próprias."
                                  ],
                                  "verification": "Resolva 5 exercícios mistos com 100% de acerto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de exercícios com 10 strings variadas.",
                                  "tips": "Sempre confira continuidade para substrings.",
                                  "learningObjective": "Executar verificações e operações básicas envolvendo subpalavras.",
                                  "commonMistakes": "Ignorar casos vazios ou confundir prefixo com substring."
                                }
                              ],
                              "practicalExample": "Dada a palavra w='computacao' (9 caracteres), prefixos incluem 'c', 'comp', 'computa'; sufixos incluem 'o', 'cao', 'tacao'; substrings incluem 'compu', 'puta', 'acao'. Verifique se 'compu' é substring (sim, posições 1-5).",
                              "finalVerifications": [
                                "Lista todos os prefixos e sufixos de uma string de 5 caracteres.",
                                "Identifica corretamente 8/10 substrings em uma string dada.",
                                "Verifica se uma string é prefixo/sufixo/substring de outra com precisão.",
                                "Explica a diferença entre substring e subsequência.",
                                "Aplica concatenação: prefixo + sufixo apropriado = original.",
                                "Resolve problemas com strings vazias ou unitárias."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (100% correto).",
                                "Completude das listas geradas (sem omissões ou extras).",
                                "Velocidade e confiança em identificações (em <2 min por string).",
                                "Capacidade de generalizar para strings longas (>6 chars).",
                                "Correção em verificações de propriedades (prefixo/sufixo/substring).",
                                "Criatividade em exemplos próprios."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Prefixos e sufixos em morfologia da língua portuguesa (ex: 'in-' em 'inativo').",
                                "Programação: Operações de string em Python (startswith(), endswith(), find()).",
                                "Matemática: Subconjuntos e sequências em teoria de conjuntos.",
                                "Biologia: Sequências de DNA como strings, substrings como genes."
                              ],
                              "realWorldApplication": "Em compiladores e parsers, reconhecer prefixos/sufixos para tokenização; em busca de texto (Google), encontrar substrings; em bioinformática, alinhar sequências de DNA; em cibersegurança, detectar padrões em strings maliciosas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Linguagem Formal",
                        "description": "Definição formal de uma linguagem como qualquer subconjunto do conjunto de todas as palavras sobre um alfabeto, denotado por L ⊆ Σ*.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Definir uma linguagem formal",
                            "description": "Explicar que uma linguagem L é um conjunto de palavras sobre Σ, incluindo exemplos como L = {ε, a, aa} ou a linguagem de todas as palavras binárias pares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Alfabeto (Σ)",
                                  "subSteps": [
                                    "Leia a definição formal: Um alfabeto Σ é um conjunto finito e não-vazio de símbolos.",
                                    "Identifique exemplos comuns: Σ = {a, b} ou Σ = {0, 1} para binário.",
                                    "Escreva sua própria definição em palavras simples.",
                                    "Discuta por que o alfabeto deve ser finito.",
                                    "Anote símbolos especiais como ε (string vazia)."
                                  ],
                                  "verification": "Escreva a definição de Σ e forneça 3 exemplos distintos, incluindo um binário.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro ou notas de Teoria da Computação (capítulo de linguagens formais)"
                                  ],
                                  "tips": "Sempre especifique se Σ é finito; isso é crucial para linguagens regulares.",
                                  "learningObjective": "Dominar a noção básica de alfabeto como base para palavras e linguagens.",
                                  "commonMistakes": "Confundir alfabeto com a linguagem inteira ou assumir que pode ser infinito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Palavras (Strings) sobre um Alfabeto",
                                  "subSteps": [
                                    "Defina uma palavra como uma sequência finita de símbolos de Σ, incluindo a vazia ε.",
                                    "Gere todas as palavras de comprimento 0, 1 e 2 sobre Σ = {a, b}.",
                                    "Explique concatenação de palavras: w1 · w2.",
                                    "Calcule o número de palavras de comprimento n: |Σ|^n.",
                                    "Diferencie palavra de símbolo único."
                                  ],
                                  "verification": "Liste todas as palavras de comprimento ≤2 sobre Σ={0,1} e identifique ε.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para potências"
                                  ],
                                  "tips": "Use notação Σ* para o conjunto de todas as palavras finitas.",
                                  "learningObjective": "Reconhecer e gerar palavras corretamente sobre um dado alfabeto.",
                                  "commonMistakes": "Esquecer a string vazia ε ou incluir símbolos fora de Σ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir uma Linguagem Formal L",
                                  "subSteps": [
                                    "Defina L como qualquer subconjunto de Σ* (conjunto de todas as palavras sobre Σ).",
                                    "Escreva L usando notação de conjunto: L = {w ∈ Σ* | propriedade de w}.",
                                    "Diferencie linguagens finitas vs. infinitas.",
                                    "Explique que L pode ser vazia (∅) ou Σ* toda.",
                                    "Verifique se uma palavra pertence a L."
                                  ],
                                  "verification": "Forneça a definição formal de L e prove que {ε, a, aa} é uma linguagem sobre Σ={a}.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência de teoria dos conjuntos"
                                  ],
                                  "tips": "Lembre-se: toda linguagem é um conjunto de strings, não strings soltas.",
                                  "learningObjective": "Articular a definição precisa de linguagem formal com base em Σ.",
                                  "commonMistakes": "Chamar L de 'linguagem' sem especificar Σ ou usar notação incorreta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar com Exemplos e Notação",
                                  "subSteps": [
                                    "Analise L = {ε, a, aa} sobre Σ={a}: liste elementos e propriedades.",
                                    "Defina L = todas as palavras binárias de comprimento par sobre {0,1}.",
                                    "Escreva L = {w ∈ {0,1}* | |w| é par} formalmente.",
                                    "Crie sua própria linguagem e valide 5 palavras (3 em L, 2 não).",
                                    "Compare com expressões regulares simples."
                                  ],
                                  "verification": "Defina duas linguagens próprias, uma finita e uma infinita, com Σ explícito.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de edição de texto para notação"
                                  ],
                                  "tips": "Use |w| para comprimento e verifique pertencência explicitamente.",
                                  "learningObjective": "Aplicar definições em exemplos concretos e criar linguagens originais.",
                                  "commonMistakes": "Confundir comprimento par com número par de 1s ou esquecer Σ."
                                }
                              ],
                              "practicalExample": "Sobre Σ = {0,1}, defina L = {todas as palavras binárias com número par de 1s}. Exemplo: ε ∈ L (0 uns), 0 ∈ L, 11 ∈ L, 01 ∉ L (um 1). Prove gerando palavras de comprimento 0-3.",
                              "finalVerifications": [
                                "Pode definir Σ corretamente com exemplos.",
                                "Gera palavras sobre Σ sem erros.",
                                "Especifica L ⊆ Σ* explicitamente.",
                                "Valida pertencência de palavras a L com justificativa.",
                                "Usa notação padrão como {w ∈ Σ* | cond}."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de Σ, palavras e L (sem ambiguidades).",
                                "Correto uso de notação matemática (conjuntos, ε, |w|).",
                                "Exemplos relevantes e variados (finita/infinitas).",
                                "Validação lógica de pertencência (pelo menos 4 palavras testadas).",
                                "Criatividade na definição de linguagens originais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e cardinalidade.",
                                "Lógica: Predicados e propriedades formais.",
                                "Programação: Expressões Regulares e parsing de strings.",
                                "Linguística: Estruturas sintáticas e gramáticas."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, linguagens formais definem a sintaxe válida de código-fonte, permitindo que parsers identifiquem erros de programação em tempo real, como em linguagens como Python ou Java."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1",
                              "10.1.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Verificar pertencência de palavras a uma linguagem",
                            "description": "Dado L e uma palavra w, determinar se w ∈ L, usando exemplos finitos e infinitos de linguagens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Linguagens Formais",
                                  "subSteps": [
                                    "Defina um alfabeto Σ como um conjunto finito de símbolos.",
                                    "Explique uma linguagem formal L ⊆ Σ* como conjunto de palavras sobre Σ.",
                                    "Descreva o pertencimento w ∈ L como 'w é uma palavra válida em L'.",
                                    "Diferencie Σ* (todas palavras possíveis) de L (subconjunto específico).",
                                    "Identifique exemplos: Σ = {a,b}, L = {a, ab}."
                                  ],
                                  "verification": "Escreva definições próprias e um exemplo de L finita e infinita.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use notação Σ* para enfatizar todas as strings possíveis.",
                                  "learningObjective": "Dominar definições básicas de alfabeto, linguagem e pertencimento.",
                                  "commonMistakes": "Confundir linguagem L com alfabeto Σ ou ignorar a estrela de Kleene (*)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Pertencimento em Linguagens Finitas",
                                  "subSteps": [
                                    "Liste todos os elementos de L finita explicitamente.",
                                    "Compare w caractere por caractere com cada elemento de L.",
                                    "Confirme exata correspondência para afirmar w ∈ L.",
                                    "Se não houver match, conclua w ∉ L.",
                                    "Pratique com L = {ε, a, aa}."
                                  ],
                                  "verification": "Para L = {ab, ba}, teste w='ab' (sim) e w='aa' (não), justificando.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de exemplos impressa",
                                    "Editor de texto simples"
                                  ],
                                  "tips": "Ordene a lista de L alfabeticamente para busca eficiente.",
                                  "learningObjective": "Aplicar verificação exaustiva em linguagens finitas.",
                                  "commonMistakes": "Erros de digitação ao comparar strings ou esquecer ε (string vazia)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Pertencimento em Linguagens Infinitas",
                                  "subSteps": [
                                    "Identifique o padrão ou regra geradora de L (ex: {a^n | n ≥ 1}).",
                                    "Conte o comprimento de w e verifique se satisfaz a regra.",
                                    "Analise estrutura: para L = {a* b}, cheque prefixo de a's seguido de b.",
                                    "Use gramática simples ou autômato mental para validar.",
                                    "Exemplo: w='aaab' ∈ {a* b}?"
                                  ],
                                  "verification": "Justifique para L = {a^n b^n | n ≥ 0}, w='aabb' (sim, n=2).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta online de autômatos (JFLAP)",
                                    "Exemplos de linguagens regulares"
                                  ],
                                  "tips": "Desenhe um autômato finito simples para visualizar aceitação.",
                                  "learningObjective": "Reconhecer e aplicar regras para linguagens infinitas.",
                                  "commonMistakes": "Contar errado o número de símbolos ou ignorar casos n=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Integrar Verificações Mistas",
                                  "subSteps": [
                                    "Misture linguagens finitas e infinitas em exercícios.",
                                    "Resolva 5 problemas: 3 finitas, 2 infinitas.",
                                    "Documente raciocínio passo a passo para cada w.",
                                    "Compare resultados com soluções modelo.",
                                    "Reflita sobre padrões comuns."
                                  ],
                                  "verification": "Resolva conjunto de 5 testes com 100% acerto e explicações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha de exercícios",
                                    "Solução modelo PDF"
                                  ],
                                  "tips": "Comece com w curtos para ganhar confiança.",
                                  "learningObjective": "Consolidar verificação em cenários variados.",
                                  "commonMistakes": "Aplicar método finito a infinitas ou vice-versa."
                                }
                              ],
                              "practicalExample": "L_finita = {λ, 'a', 'ab', 'ba'}; w = 'ab' → Sim, match exato. L_infinita = {a^n | n ≥ 1}; w = 'aaa' → Sim, n=3 satisfaz regra. w = 'aab' → Não, contém 'b' inválido.",
                              "finalVerifications": [
                                "Lista corretamente elementos de L finita.",
                                "Identifica e aplica regra para L infinita.",
                                "Justifica corretamente w ∈ L ou w ∉ L em 90% dos casos.",
                                "Diferencia finita de infinita adequadamente.",
                                "Usa notação correta (Σ*, ∈, ∉).",
                                "Resolve exemplos mistos sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pertencimento (80% peso).",
                                "Clareza no raciocínio passo a passo.",
                                "Correto uso de definições formais.",
                                "Capacidade de lidar com ε e casos edge.",
                                "Eficiência no método (exaustivo para finita, regra para infinita).",
                                "Criatividade em exemplos próprios."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Conjuntos e relações de pertencimento.",
                                "Lógica: Provas por exaustão e indução.",
                                "Programação: Validação de strings em regex ou parsers.",
                                "Linguística: Análise sintática de frases."
                              ],
                              "realWorldApplication": "Em compiladores, validar sintaxe de código (ex: checar se string é identificador válido); em protocolos de rede, verificar formatos de pacotes; em busca de texto, matching de padrões em bancos de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Listar exemplos de linguagens finitas e infinitas",
                            "description": "Classificar linguagens como finitas (ex: L={a,ab}) ou infinitas (ex: L={a^n | n≥0}), justificando com Σ*.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Alfabeto e Σ*",
                                  "subSteps": [
                                    "Defina um alfabeto Σ como um conjunto finito de símbolos.",
                                    "Liste exemplos de alfabetos, como Σ = {a, b} ou Σ = {0, 1}.",
                                    "Explique Σ* como o conjunto de todas as strings finitas possíveis sobre Σ, incluindo a string vazia ε.",
                                    "Calcule Σ* para Σ = {a}: {ε, a, aa, aaa, ...}.",
                                    "Diferencie Σ* (sempre infinita, exceto se Σ vazio) de subconjuntos finitos."
                                  ],
                                  "verification": "Escreva uma definição clara de Σ* e liste os 5 primeiros elementos para Σ = {a, b}.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre linguagens formais",
                                    "Livro de Teoria da Computação (capítulo 1)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Sempre inclua ε em Σ* e lembre que Σ* é contável infinita para Σ não vazio.",
                                  "learningObjective": "Compreender Σ* como base para classificar linguagens finitas e infinitas.",
                                  "commonMistakes": [
                                    "Confundir Σ com Σ*",
                                    "Esquecer a string vazia ε",
                                    "Pensar que Σ* é finita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Linguagens Finitas: Definição e Exemplos",
                                  "subSteps": [
                                    "Defina linguagem finita como um subconjunto finito de Σ*.",
                                    "Crie exemplo: L = {a, ab} sobre Σ = {a, b} (tem 2 strings).",
                                    "Verifique finitude: conte o número de strings em L.",
                                    "Gere mais exemplos: L = {ε, aa} ou L = {aaa}.",
                                    "Compare com Σ*: L finita implica |L| < ∞, enquanto Σ* é infinita."
                                  ],
                                  "verification": "Liste 3 linguagens finitas diferentes com seus alfabetos e conte o número de strings em cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de exercícios em branco",
                                    "Calculadora para contagem (opcional)",
                                    "Referência online sobre linguagens formais"
                                  ],
                                  "tips": "Use chaves {} para denotar o conjunto e verifique se não há infinitude implícita.",
                                  "learningObjective": "Identificar e gerar exemplos precisos de linguagens finitas.",
                                  "commonMistakes": [
                                    "Incluir padrões recursivos como {a^n}",
                                    "Esquecer de especificar Σ",
                                    "Confundir com linguagens regulares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Linguagens Infinitas: Definição e Exemplos",
                                  "subSteps": [
                                    "Defina linguagem infinita como subconjunto infinito de Σ*.",
                                    "Crie exemplo: L = {a^n | n ≥ 0} sobre Σ = {a}, que inclui {ε, a, aa, ...}.",
                                    "Prove infinitude: mostre que para todo n, existe string de comprimento n em L.",
                                    "Gere mais exemplos: L = {a^n b^n | n ≥ 1} ou todas as strings pares sobre {0,1}.",
                                    "Diferencie de finitas: L infinita tem strings arbitrariamente longas."
                                  ],
                                  "verification": "Forneça 3 exemplos de linguagens infinitas e justifique por que cada uma é infinita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de linguagens de um livro-texto",
                                    "Editor de texto para listar strings",
                                    "Vídeo tutorial sobre linguagens formais (5 min)"
                                  ],
                                  "tips": "Use notação {a^n | n ≥ 0} para padrões infinitos e prove com indução simples.",
                                  "learningObjective": "Reconhecer padrões que geram infinitude em linguagens.",
                                  "commonMistakes": [
                                    "Listar conjuntos finitos como infinitos",
                                    "Não especificar condições como n ≥ 0",
                                    "Confundir com linguagens não-regulares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Classificação e Justificativa",
                                  "subSteps": [
                                    "Pegue uma linguagem dada, como L = {a, ab, abc}, e classifique como finita.",
                                    "Para L = {w | w tem igual número de a's e b's}, classifique como infinita e justifique.",
                                    "Use Σ* na justificativa: finita se L ⊆ Σ* com |L| < ∞.",
                                    "Crie tabela: Linguagem | Finitude | Justificativa | Exemplos de strings.",
                                    "Teste 5 linguagens mistas e classifique todas."
                                  ],
                                  "verification": "Classifique corretamente 5 linguagens fornecidas e justifique cada uma usando Σ*.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de 10 linguagens de exemplo (impressa ou digital)",
                                    "Planilha para tabela de classificação"
                                  ],
                                  "tips": "Pergunte: 'Posso listar todas as strings?' Se não, é infinita.",
                                  "learningObjective": "Classificar qualquer linguagem como finita ou infinita com justificativa rigorosa.",
                                  "commonMistakes": [
                                    "Classificar {a^n | n=1 a 10} como infinita",
                                    "Ignorar Σ na justificativa",
                                    "Não provar infinitude explicitamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Classifique L = {ε, a, aa, aaa} sobre Σ = {a}. Resposta: Finita, pois contém exatamente 4 strings, um subconjunto finito de Σ* = {a^n | n ≥ 0}. Para infinita: L' = {a^n | n ≥ 0}, pois gera strings de comprimento arbitrário.",
                              "finalVerifications": [
                                "Liste pelo menos 3 exemplos de linguagens finitas com Σ especificado.",
                                "Liste pelo menos 3 exemplos de linguagens infinitas com prova de infinitude.",
                                "Classifique corretamente L = {ab, ba} como finita e justifique com |L|=2 < ∞.",
                                "Explique por que Σ* é sempre infinita para Σ ≠ ∅.",
                                "Diferencie L = {a^n | n=1,2,3} (finita) de L = {a^n | n ≥ 1} (infinita)."
                              ],
                              "assessmentCriteria": [
                                "Exemplos corretos e variados (finitos vs infinitos).",
                                "Justificativas precisas usando Σ* e contagem/prova de infinitude.",
                                "Notação formal adequada (Σ, { }, | condições).",
                                "Ausência de erros comuns como confundir padrões finitos com infinitos.",
                                "Capacidade de classificar novas linguagens independentemente.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (subconjuntos finitos/infinitos).",
                                "Lógica: Propriedades de conjuntos contáveis e recursão.",
                                "Programação: Regex finitos (linguagens finitas) vs padrões infinitos em parsers.",
                                "Linguística: Modelagem de idiomas naturais como linguagens infinitas."
                              ],
                              "realWorldApplication": "Em compiladores, linguagens finitas modelam tokens fixos (ex: palavras-chave), enquanto infinitas descrevem estruturas recursivas como expressões aninhadas; em validação de dados, distinguir finitude ajuda a otimizar autômatos finitos para padrões limitados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.3.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.4",
                        "name": "Operações sobre Linguagens",
                        "description": "Principais operações binárias e unárias sobre linguagens: união, concatenação, interseção, complemento, estrela de Kleene e potência.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.4.1",
                            "name": "Definir união e concatenação de linguagens",
                            "description": "Explicar L1 ∪ L2 = {w | w ∈ L1 ou w ∈ L2} e L1 · L2 = {uv | u ∈ L1, v ∈ L2}, com exemplos como {a} ∪ {b} = {a,b}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal de união de linguagens",
                                  "subSteps": [
                                    "Revise o conceito de linguagem formal como um conjunto de strings sobre um alfabeto Σ.",
                                    "Leia a definição: L1 ∪ L2 = {w | w ∈ L1 ou w ∈ L2}.",
                                    "Identifique que a união combina todos os elementos únicos de ambas as linguagens.",
                                    "Anote exemplos iniciais: se L1 = {a, aa}, L2 = {b}, então L1 ∪ L2 = {a, aa, b}.",
                                    "Discuta por que elementos duplicados são ignorados (propriedade de conjuntos)."
                                  ],
                                  "verification": "Escreva a definição em suas palavras e liste 3 exemplos corretos de união.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, notas de aula sobre linguagens formais, calculadora de conjuntos online (opcional).",
                                  "tips": "Use diagramas de Venn para visualizar a união intuitivamente.",
                                  "learningObjective": "Dominar a notação e o significado matemático da união de linguagens.",
                                  "commonMistakes": "Confundir união com interseção (∪ vs ∩); incluir duplicatas como elementos separados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a definição formal de concatenação de linguagens",
                                  "subSteps": [
                                    "Leia a definição: L1 · L2 = {uv | u ∈ L1, v ∈ L2}, onde uv é a concatenação de strings u e v.",
                                    "Entenda que todo par (u,v) gera uma nova string única.",
                                    "Calcule manualmente: se L1 = {a}, L2 = {b, bb}, então L1 · L2 = {ab, abb}.",
                                    "Note que a ordem importa: L1 · L2 ≠ L2 · L1 em geral.",
                                    "Compare com multiplicação de conjuntos em teoria de conjuntos."
                                  ],
                                  "verification": "Gere todas as strings de L1 · L2 para L1 = {ε, a}, L2 = {b} e verifique o resultado {εb, ab} = {b, ab}.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta, tabela para listar pares (u,v), software como JFLAP para visualização.",
                                  "tips": "Liste todos os elementos de L1 e L2 em tabelas e 'multiplique' sistematicamente.",
                                  "learningObjective": "Aplicar a construção de strings concatenadas a partir de linguagens dadas.",
                                  "commonMistakes": "Esquecer a string vazia ε se presente; inverter a ordem de concatenação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar com exemplos simples e complexos",
                                  "subSteps": [
                                    "Exemplo dado: {a} ∪ {b} = {a, b}; verifique.",
                                    "Exemplo concatenação: {a} · {b} = {ab}; expanda para L1 = {a, aa}, L2 = {b}.",
                                    "Crie suas próprias linguagens: L3 = {0, 1}*, L4 = {00}, calcule L3 ∪ L4 e L3 · L4.",
                                    "Resolva 3 exercícios: misture finitas e infinitas linguagens.",
                                    "Desenhe autômatos finitos (AFD) equivalentes para visualizar as operações."
                                  ],
                                  "verification": "Resolva 5 problemas variados e confira com soluções modelo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folhas de exercícios impressas, JFLAP ou Draw.io para diagramas de autômatos.",
                                  "tips": "Comece com linguagens finitas pequenas para ganhar confiança antes de infinitas.",
                                  "learningObjective": "Executar operações de união e concatenação em exemplos concretos.",
                                  "commonMistakes": "Tratar linguagens infinitas como finitas; ignorar todas as combinações possíveis na concatenação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar operações e verificar propriedades",
                                  "subSteps": [
                                    "Compare união (não ordenada, idempotente) vs concatenação (ordenada, gera comprimentos somados).",
                                    "Verifique propriedades: (L1 ∪ L2) · L3 = (L1 · L3) ∪ (L2 · L3).",
                                    "Teste com contraexemplos: L1 ∪ L2 = L2 ∪ L1 (comutativa), mas concatenação não é.",
                                    "Resuma diferenças em uma tabela.",
                                    "Aplique a expressões regulares equivalentes."
                                  ],
                                  "verification": "Prove ou refute 3 propriedades usando exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela comparativa em papel, livro de teoria da computação (ex: Sipser).",
                                  "tips": "Use expressões regulares para validar: união é |, concatenação é juxtaposição.",
                                  "learningObjective": "Diferenciar e relacionar união e concatenação com outras operações.",
                                  "commonMistakes": "Assumir comutatividade para concatenação; confundir com produto cartesiano sem concatenação."
                                }
                              ],
                              "practicalExample": "Considere L1 = {a, b} (palavras de comprimento 1 sobre {a,b}) e L2 = {aa, bb} (palavras de comprimento 2 pares). União: L1 ∪ L2 = {a, b, aa, bb}. Concatenação: L1 · L2 = {aaa, aab, baa, bab, aba, abb, bba, bbb} (todas combinações de 1+2=3 letras).",
                              "finalVerifications": [
                                "Defina corretamente união e concatenação com notação formal.",
                                "Calcule L1 ∪ L2 e L1 · L2 para 3 pares de linguagens dadas sem erros.",
                                "Explique a diferença entre as operações com um exemplo numérico.",
                                "Construa um autômato para a união ou concatenação de linguagens simples.",
                                "Identifique se uma linguagem dada é resultado de união/concatenação.",
                                "Prove uma propriedade distributiva básica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (100% correto).",
                                "Corretude em cálculos de exemplos (sem omissões ou duplicatas).",
                                "Profundidade de exemplos (inclui finitas e infinitas).",
                                "Clareza na explicação de diferenças e propriedades.",
                                "Criatividade em aplicações ou contraexemplos.",
                                "Uso adequado de ferramentas visuais como diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos (união, produto cartesiano).",
                                "Programação: Manipulação de strings em Python (set unions, string concatenation).",
                                "Lógica: Operações booleanas em linguagens de programação.",
                                "Engenharia de Software: Construção de gramáticas em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores, união modela alternâncias em gramáticas (ex: expressões regulares com |); concatenação modela sequências de tokens (ex: identificador seguido de operador)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.1.4.2",
                            "name": "Aplicar estrela de Kleene e potência",
                            "description": "Definir L* = ∪_{k=0}^∞ L^k (com L^0={ε}) e calcular exemplos, como ({a} ∪ {b})* = todas as palavras sobre {a,b}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição de Potência de Linguagem",
                                  "subSteps": [
                                    "Defina L^0 = {ε}, onde ε representa a palavra vazia.",
                                    "Defina L^1 = L, a linguagem original.",
                                    "Defina recursivamente L^k = L^{k-1} ⋅ L para k ≥ 2, onde ⋅ denota concatenação de linguagens.",
                                    "Entenda que L^k contém todas as sequências de exatamente k palavras de L concatenadas.",
                                    "Pratique com exemplo simples: Para L = {a}, L^2 = {aa}."
                                  ],
                                  "verification": "Escreva as definições formais e compute L^2 para L = {ab, cd}.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para anotar exemplos"
                                  ],
                                  "tips": "Sempre inclua ε em L^0 para evitar omissões em construções futuras.",
                                  "learningObjective": "Dominar a construção recursiva de potências finitas de linguagens.",
                                  "commonMistakes": [
                                    "Confundir concatenação (sequência) com união (alternativa).",
                                    "Esquecer que L^0 é singleton {ε}."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Potências Finitas de uma Linguagem",
                                  "subSteps": [
                                    "Escolha uma linguagem finita L, como L = {0, 1}.",
                                    "Compute L^0, L^1 e L^2 explicitamente listando elementos.",
                                    "Estenda para L^3: concatene L^2 com L e liste sem duplicatas.",
                                    "Observe o padrão: L^k gera todas as strings binárias de comprimento k.",
                                    "Verifique fechamento sob concatenação para potências."
                                  ],
                                  "verification": "Liste todos os elementos de L^3 para L = {a, b} e confirme o número total (8 elementos).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para contar elementos (opcional)"
                                  ],
                                  "tips": "Use tabelas para organizar concatenações e evitar repetições manuais.",
                                  "learningObjective": "Habilitar cálculo manual de potências para linguagens simples.",
                                  "commonMistakes": [
                                    "Duplicar elementos desnecessariamente.",
                                    "Ignorar a ordem na concatenação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Construir a Estrela de Kleene",
                                  "subSteps": [
                                    "Defina L* = ∪_{k=0}^∞ L^k, a união de todas as potências incluindo L^0.",
                                    "Entenda que L* é a menor linguagem fechada sob concatenação contendo L e ε.",
                                    "Construa L* para L finita: inclua ε e todas concatenações arbitrárias de palavras de L.",
                                    "Exemplo inicial: Para L = {a}, L* = {ε, a, aa, aaa, ...} = a*.",
                                    "Discuta infinitude: L* é infinita se L contém palavras não-vazias."
                                  ],
                                  "verification": "Descreva L* para L = {ab} e liste os 5 primeiros elementos por comprimento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "Referência online sobre linguagens regulares (opcional)"
                                  ],
                                  "tips": "Pense em L* como 'zero ou mais repetições' de elementos de L.",
                                  "learningObjective": "Compreender L* como fechamento sob concatenação repetida.",
                                  "commonMistakes": [
                                    "Excluir ε da união.",
                                    "Confundir L* com L^+ (sem ε)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Estrela de Kleene e Potência em Exemplos",
                                  "subSteps": [
                                    "Dado L = {a} ∪ {b}, compute L^0 = {ε}, L^1 = {a,b}, L^2 = {aa,ab,ba,bb}.",
                                    "Construa L* = união infinita = todas as palavras não-vazias sobre alfabeto {a,b} mais ε.",
                                    "Teste propriedade: Se w ∈ L*, então w = u v com u ∈ L^k, v ∈ L^m para k+m = comprimento.",
                                    "Generalize para L = {00, 11}: L* gera pares de bits iguais repetidos.",
                                    "Verifique com desenho de árvore de concatenações."
                                  ],
                                  "verification": "Prove que ({a} ∪ {b})* = {a,b}* e liste 3 strings de L^3.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de desenho para árvores (ex: Draw.io)",
                                    "Lista de exercícios prévia"
                                  ],
                                  "tips": "Use indução para justificar elementos em L*: base ε, passo concatenação.",
                                  "learningObjective": "Aplicar conceitos em exemplos concretos e generalizar.",
                                  "commonMistakes": [
                                    "Limitar L* a comprimentos finitos.",
                                    "Não reconhecer padrões regulares simples."
                                  ]
                                }
                              ],
                              "practicalExample": "Para L = {a} ∪ {b}, L^0 = {ε}, L^1 = {a, b}, L^2 = {aa, ab, ba, bb}, ..., L* = todas as strings finitas sobre {a, b} incluindo ε, equivalente a (a|b)* em regex.",
                              "finalVerifications": [
                                "Defina corretamente L* e L^k com notação formal.",
                                "Compute L^3 para L = {0,1} e liste todos os 8 elementos.",
                                "Mostre que ε ∈ L* e prove fechamento sob concatenação.",
                                "Dê exemplo onde L* é finita (L vazio ou só ε).",
                                "Aplique a ({ab} ∪ {cd})* e descreva intuitivamente.",
                                "Verifique se w = abab ∈ ({ab} ∪ {cd})*."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (100% corretas).",
                                "Corretude nos cálculos de potências finitas (sem erros de listagem).",
                                "Compreensão conceitual de infinitude e fechamento.",
                                "Criatividade em exemplos personalizados.",
                                "Uso correto de notação (∪, ⋅, ε, ∞).",
                                "Capacidade de generalização para linguagens arbitrárias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e indução infinita.",
                                "Programação: Expressões regulares (regex) em linguagens como Python ou Java.",
                                "Lógica: Construções recursivas e fechamentos em provas formais.",
                                "Engenharia de Software: Modelagem de padrões em autômatos finitos."
                              ],
                              "realWorldApplication": "Em expressões regulares para validar ebuscar padrões flexíveis em texto, como emails (.*@.*\\.com) ou código-fonte, permitindo 'zero ou mais' repetições em ferramentas como grep, editores de texto e compiladores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.4.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.4.3",
                            "name": "Calcular interseção e complemento",
                            "description": "Explicar L1 ∩ L2 e complemento ᾹL = Σ* - L, verificando propriedades como fechamento sob união em regulares (contexto futuro).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Definições Teóricas de Interseção e Complemento",
                                  "subSteps": [
                                    "Revise a definição formal de linguagem formal como subconjunto de Σ*.",
                                    "Estude interseção L1 ∩ L2 = {w | w ∈ L1 e w ∈ L2}.",
                                    "Aprenda complemento ᾹL = Σ* - L = {w ∈ Σ* | w ∉ L}.",
                                    "Analise exemplos simples com Σ = {a,b}, como L = {a}, ᾹL = {b, aa, ab, ba, bb, ...}.",
                                    "Discuta propriedades: regulares fechadas sob interseção e complemento."
                                  ],
                                  "verification": "Escreva definições em suas palavras e dê um exemplo para cada.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Papel e caneta para anotações",
                                    "Notas de aula sobre linguagens formais"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar operações de conjunto.",
                                  "learningObjective": "Dominar as definições formais e intuitivas de interseção e complemento em linguagens formais.",
                                  "commonMistakes": [
                                    "Confundir interseção com união.",
                                    "Esquecer que complemento é relativo a Σ*.",
                                    "Ignorar o alfabeto Σ."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Autômato para Interseção de Linguagens Regulares",
                                  "subSteps": [
                                    "Dado AFNDs M1 e M2 para L1 e L2, construa o produto cartesiano de estados Q = Q1 × Q2.",
                                    "Defina transições δ((q1,q2), a) = (δ1(q1,a), δ2(q2,a)).",
                                    "Estados iniciais: q0 = (q01, q02); estados finais: F = F1 × F2.",
                                    "Converta AFND resultante para AFD se necessário usando powerset.",
                                    "Teste com exemplo: L1 = strings pares de a's, L2 = terminam em b."
                                  ],
                                  "verification": "Construa o autômato de produto e aceite uma string de teste válida/inválida.",
                                  "estimatedTime": "1.5-2 horas",
                                  "materials": [
                                    "Ferramenta online como JFLAP ou draw.io para diagramas",
                                    "Papel quadriculado",
                                    "Exemplos de AFNDs impressos"
                                  ],
                                  "tips": "Rastreie pares de estados sistematicamente para evitar erros em transições.",
                                  "learningObjective": "Construir AFND para L1 ∩ L2 via produto de autômatos.",
                                  "commonMistakes": [
                                    "Esquecer sincronizar transições em ambos autômatos.",
                                    "Não combinar corretamente estados finais.",
                                    "Ignorar ε-transições no AFND."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Autômato para Complemento de Linguagem Regular",
                                  "subSteps": [
                                    "Dado AFD M para L, inverta os estados finais: F' = Q - F.",
                                    "Mantenha estados, transições e inicial iguais; só mude aceitação.",
                                    "Para AFND, elimine ε-transições e minimize primeiro se possível.",
                                    "Calcule Σ* via autômato universal (aceita tudo), então subtraia.",
                                    "Exemplo: L = {w | |w| par}, complemento aceita ímpar."
                                  ],
                                  "verification": "Construa o autômato complementar e verifique com strings em L e não em L.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "JFLAP ou software similar",
                                    "Tabela de transições em Excel",
                                    "Exemplos resolvidos"
                                  ],
                                  "tips": "Sempre minimize o AFD antes para simplificar visualização.",
                                  "learningObjective": "Gerar AFND/DFD para complemento via inversão de aceitação.",
                                  "commonMistakes": [
                                    "Aplicar complemento sem converter para AFD primeiro.",
                                    "Confundir com negação em expressões regulares.",
                                    "Esquecer estados inalcançáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Propriedades e Praticar com Exemplos",
                                  "subSteps": [
                                    "Prove fechamento: interseção via produto (regulares fechadas).",
                                    "Mostre complemento preserva regularidade (invert F).",
                                    "Resolva exercícios: calcule ∩ e complemento para 3 pares de linguagens.",
                                    "Verifique propriedades como L ∩ ᾹL = ∅ e L ∪ ᾹL = Σ*.",
                                    "Discuta limitações para linguagens não-regulares (contexto futuro)."
                                  ],
                                  "verification": "Resolva 5 exercícios independentes e compare com soluções modelo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Lista de exercícios de linguagens formais",
                                    "Soluções comentadas",
                                    "Calculadora para contagens"
                                  ],
                                  "tips": "Use tabelas para listar strings geradas e validar manualmente.",
                                  "learningObjective": "Aplicar operações e verificar propriedades de fechamento em regulares.",
                                  "commonMistakes": [
                                    "Assumir fechamento para context-free sem prova.",
                                    "Erros aritméticos em contagens de strings.",
                                    "Não testar strings de borda como ε."
                                  ]
                                }
                              ],
                              "practicalExample": "Dadas L1 = {w ∈ {a,b}* | número de a's é par} (AFD com 2 estados) e L2 = {w ∈ {a,b}* | termina com b} (AFD simples). Calcule L1 ∩ L2 construindo produto (4 estados), resultando em strings com par de a's terminando em b. Para complemento de L1: inverta F, obtendo ímpar de a's. Teste: 'aab' ∈ L1 ∩ L2? Sim (2 a's par, acaba b). 'aa' ∈ ᾹL1? Sim (par, mas complemento é ímpar).",
                              "finalVerifications": [
                                "Defina corretamente L1 ∩ L2 e ᾹL em notação formal.",
                                "Construa autômato de produto para interseção sem erros.",
                                "Inverta corretamente aceitação para complemento.",
                                "Prove fechamento sob interseção e complemento para regulares.",
                                "Resolva exemplo prático com Σ* - L.",
                                "Identifique L ∩ ᾹL = ∅."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e notações (20%).",
                                "Correção na construção de autômatos produto e complemento (30%).",
                                "Validação com strings de teste (20%).",
                                "Compreensão de propriedades de fechamento (15%).",
                                "Clareza em diagramas e explicações (10%).",
                                "Identificação de erros comuns evitados (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos e Álgebra Booleana.",
                                "Lógica: Operações de negação e conjunção em predicados.",
                                "Programação: Expressões Regulares em Python/Java (re module).",
                                "Engenharia de Software: Análise Léxica em Compiladores.",
                                "Inteligência Artificial: Autômatos Finitos em Modelos de NLP."
                              ],
                              "realWorldApplication": "Essas operações são fundamentais em compiladores (analisadores léxicos usam regex para interseções de padrões), validação de formulários web (complemento para strings inválidas), filtros de busca em bancos de dados (SQL LIKE com padrões), e sistemas de detecção de padrões em segurança cibernética (identificar tráfego malicioso via interseção de assinaturas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.4.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.4.4",
                            "name": "Verificar propriedades de operações",
                            "description": "Demonstrar que operações preservam linguagens regulares ou identificam exemplos onde não, usando conjuntos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos e Verificar União",
                                  "subSteps": [
                                    "Revise definições: linguagem regular (aceita por AFD ou gerada por regex), operação de união L1 ∪ L2.",
                                    "Estude construção de AFD para união: crie novo autômato com estados disjuntos de ambos AFDs, estado inicial com transições epsilon para iniciais originais, estados finais se qualquer um for final.",
                                    "Use exemplo simples: L1 = {a} (AFD com a→final), L2 = {b}, construa AFD para L1 ∪ L2 = {a, b}.",
                                    "Teste o AFD com strings como 'a', 'b', 'aa' para verificar aceitação/rejeição.",
                                    "Prove formalmente: se M1, M2 aceitam L1, L2, o novo M aceita exatamente L1 ∪ L2."
                                  ],
                                  "verification": "Construa e teste manualmente um AFD para união de dois AFDs simples fornecidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Ferramenta online JFLAP ou draw.io",
                                    "Notas sobre AFDs"
                                  ],
                                  "tips": "Desenhe autômatos lado a lado e adicione um 'hub' inicial com epsilons para simplificar.",
                                  "learningObjective": "Compreender e demonstrar que a união preserva regularidade via construção de AFD.",
                                  "commonMistakes": [
                                    "Esquecer transições epsilon do novo inicial",
                                    "Não tratar loops ou estados mortos adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Preservação sob Concatenação",
                                  "subSteps": [
                                    "Defina concatenação: L1 ⋅ L2 = {uv | u ∈ L1, v ∈ L2}.",
                                    "Aprenda construção: Copie estados de M1, dos finais de M1 adicione epsilon-transições para inicial de M2, finais são os de M2.",
                                    "Exemplo concreto: L1 = {ε, a}, L2 = {b}, construa AFD para L1 ⋅ L2 = {b, ab}.",
                                    "Simule execução com strings como 'ab', 'b', 'bb' para validar.",
                                    "Analise: explique por que isso captura todas concatenações sem sobreposições indesejadas."
                                  ],
                                  "verification": "Crie AFD para concatenação de L1={aa} e L2={bb}, teste 'aabb'.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel para esboços",
                                    "JFLAP para simulação",
                                    "Exemplos de regex como referência"
                                  ],
                                  "tips": "Minimize estados removendo epsilons após construção se possível.",
                                  "learningObjective": "Demonstrar closure sob concatenação através de construção determinística.",
                                  "commonMistakes": [
                                    "Adicionar epsilons em locais errados, criando caminhos extras",
                                    "Confundir ordem de concatenação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Fecho de Kleene (Estrela)",
                                  "subSteps": [
                                    "Defina L* = ∪_{n=0}^∞ L^n (L^0 = {ε}).",
                                    "Construção padrão: novo inicial/final com loops; do novo inicial epsilon para antigo inicial e para novo final; dos antigos finais epsilon para antigo inicial e novo final.",
                                    "Exemplo: L = {ab}, construa AFD para L* incluindo ε, ab, abab etc.",
                                    "Teste strings: ε, 'ab', 'abab', rejeite 'a' ou 'aba'.",
                                    "Verifique propriedade: repita concatenações zero ou mais vezes."
                                  ],
                                  "verification": "Construa e valide AFD para ({a})* = a*.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta JFLAP para loops complexos",
                                    "Papel",
                                    "Documentação de regex *"
                                  ],
                                  "tips": "Sempre inclua o caso ε explicitamente com self-loop no novo final.",
                                  "learningObjective": "Provar que o fecho de Kleene preserva regularidade com autômatos.",
                                  "commonMistakes": [
                                    "Omitir transições de volta para repetir",
                                    "Não lidar com ε corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Outras Operações e Contraexemplos",
                                  "subSteps": [
                                    "Discuta interseção e complemento: construções produto para interseção (finais ambos), inverter finais para complemento.",
                                    "Confirme closure: todas operações booleanas + concat/estrela preservam para regulares.",
                                    "Identifique onde não preserva: se L1 regular e L2 não-regular, L1 ∪ L2 geralmente não-regular. Ex: L_regular = {ε}, L_non = {a^n b^n | n≥0}, união não-regular.",
                                    "Exemplo prático: prove {a^n b^n} ∪ {ε} não é regular via pumping lemma.",
                                    "Sintetize: liste propriedades preservadas e condições para falha."
                                  ],
                                  "verification": "Forneça contraexemplo onde operação não preserva regularidade e justifique.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Notas de pumping lemma",
                                    "Papel para provas",
                                    "Exemplos online de linguagens não-regulares"
                                  ],
                                  "tips": "Use pumping lemma para confirmar não-regularidade em contraexemplos.",
                                  "learningObjective": "Identificar cenários onde operações não garantem regularidade.",
                                  "commonMistakes": [
                                    "Assumir preservação universal sem checar inputs",
                                    "Confundir classes (ex: CFGs)"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado L1 = {a, aa} (regex: a(a)?) e L2 = {b} (regex: b), verifique: União L1 ∪ L2 = {a, aa, b} → regex a(a)?|b, regular. Concatenação L1 ⋅ L2 = {ab, aab} → regex a(a)?b, regular. L1* inclui ε, a, aa, aaa..., regular. Contraexemplo: L_non = {a^n b^n}, L1 ∪ L_non não-regular.",
                              "finalVerifications": [
                                "Consegue construir AFDs para união, concatenação e estrela de exemplos simples?",
                                "Explica verbalmente por que regulares são fechadas sob essas operações?",
                                "Identifica corretamente um contraexemplo onde união não preserva regularidade?",
                                "Aplica pumping lemma em um caso não-regular?",
                                "Lista todas as operações que preservam regularidade?",
                                "Testa AFD construído com 5 strings variadas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção das construções de AFD (80% de estados/transições corretas)",
                                "Compreensão conceitual demonstrada em explicações (uso correto de termos)",
                                "Criatividade e validade de exemplos/contraexemplos fornecidos",
                                "Profundidade na análise de verificações e erros comuns",
                                "Eficiência temporal e uso adequado de materiais",
                                "Capacidade de generalizar para novas linguagens simples"
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Conjuntos (Matemática): união, interseção como operações booleanas",
                                "Lógica e Autômatos: Estados como proposições verdadeiras/falsas",
                                "Programação: Regex em Python/Java para padrões reais (re module)",
                                "Algoritmos: Construções semelhantes a compiladores de regex para NFA",
                                "Matemática Discreta: Fechos e indução em provas de closure"
                              ],
                              "realWorldApplication": "Em ferramentas de busca como grep ou editores (VS Code), expressões regulares usam união (|), concatenação e * para validar e-mails, senhas ou código-fonte, garantindo eficiência finita via autômatos; falhas em closure ajudam a detectar padrões não-eficientes (ex: backtracking excessivo em não-regulares aproximados)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.4.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Gramáticas Formais",
                    "description": "Estrutura de uma gramática formal (terminais, não-terminais, produções e axioma).",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Símbolos Terminais",
                        "description": "Os símbolos terminais formam o alfabeto da linguagem gerada pela gramática formal. São os elementos básicos (folhas) que não sofrem mais expansões e aparecem nas palavras finais da linguagem.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Identificar símbolos terminais",
                            "description": "Dado uma gramática formal, distinguir e listar corretamente os símbolos terminais, geralmente representados por letras minúsculas ou números.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e o Papel dos Símbolos Terminais",
                                  "subSteps": [
                                    "Ler a definição formal: Símbolos terminais são os alfabetos básicos de uma linguagem formal, que não são substituídos por regras de produção e representam as unidades leaf na árvore de derivação sintática.",
                                    "Diferenciar de símbolos não-terminais (variáveis), que são geralmente representados por letras maiúsculas e podem ser expandidos.",
                                    "Estudar o papel dos terminais na geração de strings da linguagem gerada pela gramática.",
                                    "Revisar exemplos canônicos, como gramáticas regulares para linguagens simples.",
                                    "Anotar as propriedades chave: finitos, indivisíveis e geram palavras terminais."
                                  ],
                                  "verification": "Explicar em 2-3 frases próprias a diferença entre terminais e não-terminais, com um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre gramáticas formais",
                                    "Livro-texto de Teoria da Computação (capítulo de linguagens formais)",
                                    "Vídeo introdutório online sobre Chomsky Hierarchy"
                                  ],
                                  "tips": "Visualize terminais como 'palavras finais' que param a expansão; associe a folhas de uma árvore.",
                                  "learningObjective": "Definir precisamente símbolos terminais e contrastá-los com não-terminais em gramáticas formais.",
                                  "commonMistakes": [
                                    "Confundir terminais com regras de produção",
                                    "Achar que todos os símbolos minúsculos são terminais sem contexto",
                                    "Ignorar que epsilon pode ser um terminal em alguns contextos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer Convenções de Representação de Terminais",
                                  "subSteps": [
                                    "Memorizar convenções padrão: terminais por letras minúsculas (a,b,c), dígitos (0-9) ou símbolos especiais (+,-,*).",
                                    "Identificar exceções: em algumas gramáticas, terminais podem ser strings curtas ou quotadas.",
                                    "Praticar escaneando gramáticas de exemplo para destacar potenciais terminais pela notação.",
                                    "Comparar múltiplas gramáticas para padrões consistentes.",
                                    "Criar uma tabela de símbolos por tipo de gramática (regulares, livres de contexto)."
                                  ],
                                  "verification": "Listar 5 exemplos de terminais comuns de gramáticas variadas e justificar pela convenção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas impressas ou digitais",
                                    "Ferramenta de edição de texto para destacar símbolos",
                                    "Referência rápida de notações em linguagens formais"
                                  ],
                                  "tips": "Sempre verifique o conjunto explícito de terminais Σ definido na gramática, se fornecido.",
                                  "learningObjective": "Reconhecer e classificar símbolos terminais baseados em convenções tipográficas e contextuais.",
                                  "commonMistakes": [
                                    "Assumir maiúsculas como terminais",
                                    "Incluir espaços ou epsilon sem confirmação",
                                    "Confundir metassímbolos (como →) com terminais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar uma Gramática Formal Dada",
                                  "subSteps": [
                                    "Ler completamente a gramática: identificar produção S → α, onde α contém símbolos.",
                                    "Escanear todas as regras de produção, marcando candidatos a terminais (minúsculas, números).",
                                    "Separar símbolos que aparecem apenas no lado direito sem expansão própria.",
                                    "Verificar consistência: terminais não devem ter regras de produção associadas.",
                                    "Mapear todos os símbolos únicos em um conjunto provisório."
                                  ],
                                  "verification": "Produzir um conjunto provisório de terminais anotado com referências às regras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gramática de exemplo impressa",
                                    "Papel e caneta para anotações ou software de diagramação",
                                    "Lista de regras de produção copiadas"
                                  ],
                                  "tips": "Use cores diferentes para marcar terminais vs. não-terminais durante a leitura.",
                                  "learningObjective": "Extrair sistematicamente símbolos terminais de regras de produção em uma gramática.",
                                  "commonMistakes": [
                                    "Incluir não-terminais que derivam terminais",
                                    "Perder terminais em regras recursivas",
                                    "Duplicar símbolos idênticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Listar, Verificar e Documentar Símbolos Terminais",
                                  "subSteps": [
                                    "Compilar a lista final: ordenar alfabeticamente ou por frequência.",
                                    "Validar: cada terminal aparece apenas como folha, sem produção própria.",
                                    "Testar com derivações: gerar 2-3 strings e confirmar apenas terminais no yield.",
                                    "Documentar o conjunto Σ = {t1, t2, ...} com justificativa breve.",
                                    "Comparar com gramáticas semelhantes para validação cruzada."
                                  ],
                                  "verification": "Apresentar lista final com derivação de exemplo confirmando apenas terminais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de derivação sintática online",
                                    "Planilha para listar e validar símbolos",
                                    "Gramática de referência com Σ conhecida"
                                  ],
                                  "tips": "Escreva Σ explicitamente; é padrão em definições formais de gramáticas.",
                                  "learningObjective": "Produzir uma lista precisa e verificada de terminais para qualquer gramática formal.",
                                  "commonMistakes": [
                                    "Esquecer terminais raros em regras obscuras",
                                    "Incluir símbolos de pontuação como parte do terminal",
                                    "Não ordenar ou formatar a lista claramente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Reforçar com Exercícios Variados",
                                  "subSteps": [
                                    "Resolver 3 gramáticas de dificuldade crescente: simples, recursiva, ambígua.",
                                    "Autoavaliar cada lista contra soluções modelo.",
                                    "Analisar erros passados e ajustar método.",
                                    "Criar uma gramática própria e identificar seus terminais.",
                                    "Discutir com par ou tutor uma gramática desafiadora."
                                  ],
                                  "verification": "Completar portfólio de 3 listas corretas com autoavaliação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Banco de exercícios de gramáticas formais",
                                    "Soluções modelo ocultas",
                                    "Fórum ou parceiro de estudo"
                                  ],
                                  "tips": "Tempo limite por exercício para simular avaliação; revise erros imediatamente.",
                                  "learningObjective": "Aplicar o processo de identificação de forma autônoma e consistente.",
                                  "commonMistakes": [
                                    "Rushing sem verificação dupla",
                                    "Copiar soluções sem entender",
                                    "Ignorar variações em notações não padrão"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática G para expressões aritméticas simples: E → E + T | T; T → T * F | F; F → (E) | id. Terminais: +, *, (, ), id. Processo: Escanear regras, notar minúsculas/símbolos sem expansão (id é terminal), listar Σ = {+, *, (, ), id}. Derivação exemplo: E ⇒ E + T ⇒ T + T ⇒ id + id, yield apenas terminais.",
                              "finalVerifications": [
                                "Lista inclui todos terminais únicos sem duplicatas.",
                                "Nenhum não-terminal está na lista.",
                                "Lista corresponde exatamente ao conjunto Σ implícito ou explícito.",
                                "Derivação de teste gera string só com terminais da lista.",
                                "Convenções de representação respeitadas (minúsculas, símbolos).",
                                "Lista ordenada alfabeticamente para clareza.",
                                "Justificativa breve para cada terminal controverso."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos terminais corretos identificados (peso 40%).",
                                "Completude: Nenhum terminal omitido ou extra (peso 30%).",
                                "Justificativa: Explicação clara com referências a regras (peso 15%).",
                                "Eficiência: Processo lógico e conciso demonstrado (peso 10%).",
                                "Apresentação: Lista formatada, ordenada e legível (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática - Teoria de Conjuntos: Terminais formam o alfabeto Σ finito.",
                                "Linguística - Fonemas e Morfemas: Analogia com unidades básicas de linguagem natural.",
                                "Programação - Análise Léxica: Tokens como terminais em compiladores.",
                                "Lógica - Símbolos Primitivos: Base para axiomas em sistemas formais.",
                                "Filosofia da Linguagem - Significado Terminal: Semântica básica."
                              ],
                              "realWorldApplication": "Em desenvolvimento de compiladores e parsers (ex: lexer do GCC identifica tokens terminais como 'if', '+'); validação de linguagens de programação; processamento de linguagem natural em NLP para tokenização; design de protocolos de rede com símbolos fixos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Explicar o papel dos terminais",
                            "description": "Descrever como os terminais constroem as palavras finais da linguagem, sem possibilidade de substituição adicional, ilustrando com exemplos simples como {a, b} em gramáticas regulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o conceito de símbolos terminais",
                                  "subSteps": [
                                    "Ler a definição formal de terminais em gramáticas formais como elementos do alfabeto Σ que não são variáveis.",
                                    "Identificar a notação padrão: V_T para terminais e V_N para não-terminais.",
                                    "Explicar que terminais representam os símbolos básicos da linguagem e não possuem regras de produção para expansão.",
                                    "Escrever uma definição em suas próprias palavras.",
                                    "Discutir por que terminais são 'finais' na derivação."
                                  ],
                                  "verification": "Redigir uma definição clara e correta de terminais, sem menção a expansões.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (capítulo de gramáticas)",
                                    "Notas de aula sobre linguagens formais"
                                  ],
                                  "tips": [
                                    "Visualize terminais como as letras prontas de uma palavra, sem mais subdivisões."
                                  ],
                                  "learningObjective": "Compreender a definição formal e o papel básico dos terminais.",
                                  "commonMistakes": [
                                    "Confundir terminais com variáveis não-terminais.",
                                    "Acreditar que terminais podem ser substituídos por regras."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar terminais de não-terminais",
                                  "subSteps": [
                                    "Listar características dos não-terminais (V_N): podem ser substituídos por regras de produção.",
                                    "Comparar com terminais: não têm regras de produção associadas.",
                                    "Desenhar um diagrama simples mostrando uma árvore de derivação onde folhas são terminais.",
                                    "Identificar terminais e não-terminais em uma gramática exemplo: S → AB, A → a, B → b.",
                                    "Explicar o impacto dessa distinção na geração de linguagens."
                                  ],
                                  "verification": "Criar uma tabela comparativa entre terminais e não-terminais com pelo menos 4 diferenças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Exemplos de gramáticas de aula"
                                  ],
                                  "tips": [
                                    "Lembre-se: não-terminais 'geram', terminais 'terminam' a palavra."
                                  ],
                                  "learningObjective": "Distinguir claramente terminais de não-terminais em contextos gramaticais.",
                                  "commonMistakes": [
                                    "Tratar terminais como expansíveis.",
                                    "Ignorar a notação V_T vs V_N."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o papel dos terminais na construção de palavras",
                                  "subSteps": [
                                    "Descrever como derivações terminam quando apenas terminais restam (palavra terminal).",
                                    "Analisar uma derivação passo a passo até formar uma palavra só com terminais.",
                                    "Explicar que a linguagem L(G) é o conjunto de todas as palavras formadas unicamente por terminais.",
                                    "Discutir que sem terminais, não há palavras finitas na linguagem.",
                                    "Relacionar com o processo de geração de strings finais."
                                  ],
                                  "verification": "Descrever verbalmente ou por escrito como terminais finalizam uma derivação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de desenho de árvores sintáticas (opcional)",
                                    "Exemplos de derivações"
                                  ],
                                  "tips": [
                                    "Pense na derivação como uma árvore: troncos são não-terminais, folhas são terminais."
                                  ],
                                  "learningObjective": "Entender como terminais constroem as palavras finais da linguagem.",
                                  "commonMistakes": [
                                    "Achar que derivações podem continuar indefinidamente com terminais.",
                                    "Confundir palavra terminal com sentença incompleta."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com exemplos simples em gramáticas regulares",
                                  "subSteps": [
                                    "Analisar gramática regular: S → aS | b, onde terminais {a,b}.",
                                    "Gerar derivações: S ⇒ aS ⇒ ab (palavra terminal ab).",
                                    "Mostrar que linguagem é {a^n b | n≥0}, todas com terminais apenas.",
                                    "Criar um exemplo próprio com terminais {a,b} e verificar.",
                                    "Explicar impossibilidade de substituição adicional em terminais."
                                  ],
                                  "verification": "Gerar 3 palavras da linguagem e provar que são só terminais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de exercícios com gramáticas regulares"
                                  ],
                                  "tips": [
                                    "Use setas ⇒ para mostrar derivações passo a passo."
                                  ],
                                  "learningObjective": "Aplicar o conceito de terminais em exemplos concretos.",
                                  "commonMistakes": [
                                    "Incluir não-terminais em palavras finais.",
                                    "Erros na contagem de derivações."
                                  ]
                                }
                              ],
                              "practicalExample": "Na gramática regular S → aS | b (terminais {a,b}), a derivação S ⇒ aS ⇒ ab produz a palavra 'ab', composta apenas por terminais, sem mais expansões possíveis. Isso gera a linguagem {a^n b | n ≥ 0}.",
                              "finalVerifications": [
                                "Definir corretamente terminais e seu papel sem erros.",
                                "Diferenciar terminais de não-terminais em uma gramática dada.",
                                "Gerar uma palavra terminal a partir de uma derivação.",
                                "Explicar por que terminais não são substituíveis.",
                                "Identificar terminais em exemplos como {a,b} em gramáticas regulares.",
                                "Descrever o conjunto de terminais de uma gramática simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de terminais (sem confusão com não-terminais).",
                                "Clareza na explicação do papel na formação de palavras finais.",
                                "Correta análise de derivações com exemplos.",
                                "Uso apropriado de notação formal (V_T, Σ).",
                                "Capacidade de criar exemplos originais válidos.",
                                "Ausência de erros comuns como expansibilidade de terminais."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: terminais como morfemas finais em análise morfológica.",
                                "Programação: tokens terminais em analisadores léxicos de compiladores.",
                                "Matemática: conjuntos geradores em teoria de conjuntos e álgebras.",
                                "Engenharia de Software: definição de alfabeto em especificações formais."
                              ],
                              "realWorldApplication": "Em compiladores e parsers, terminais representam tokens da linguagem de programação (ex: palavras-chave, operadores), permitindo análise sintática sem expansões adicionais, essencial para ferramentas como yacc ou ANTLR."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Fornecer exemplos de terminais",
                            "description": "Criar exemplos de conjuntos de terminais para linguagens específicas, como Σ = {0,1} para linguagens binárias, e relacionar com a geração de strings.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de símbolos terminais",
                                  "subSteps": [
                                    "Ler a definição formal: símbolos terminais são os elementos básicos de uma gramática que formam as strings finais da linguagem.",
                                    "Diferenciar terminais (Σ) de não-terminais (V): terminais não são substituídos em derivações.",
                                    "Identificar características: finitos, indivisíveis e aparecem nas folhas da árvore de derivação.",
                                    "Estudar notação: Σ = {a, b, c} para alfabeto.",
                                    "Revisar exemplos iniciais: Σ = {0,1} para binário."
                                  ],
                                  "verification": "Escrever uma definição em suas próprias palavras e listar 2 diferenças entre terminais e não-terminais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação ou notas de aula sobre gramáticas formais",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use diagramas de árvore de derivação para visualizar terminais nas folhas.",
                                  "learningObjective": "Dominar a definição e distinção de terminais em gramáticas formais.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Achar que terminais podem ser substituídos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar exemplos clássicos de conjuntos de terminais",
                                  "subSteps": [
                                    "Analisar Σ = {0,1} para linguagens binárias e listar strings como ε, 0, 1, 00.",
                                    "Estudar Σ = {a, b} para linguagens sobre alfabeto simples e gerar palavras como ab, ba.",
                                    "Examinar Σ = {0,1,2,...,9} para linguagens numéricas decimais.",
                                    "Comparar com linguagens reais: Σ = {A-Z, 0-9, _, +} em programação.",
                                    "Praticar notação: Escrever Σ para 3 linguagens diferentes."
                                  ],
                                  "verification": "Listar 3 conjuntos de terminais clássicos com pelo menos uma string gerada cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas formais online ou em PDF",
                                    "Editor de texto para listar strings"
                                  ],
                                  "tips": "Sempre verifique se o conjunto é finito e relevante à linguagem.",
                                  "learningObjective": "Reconhecer e reproduzir exemplos padrão de alfabetos terminais.",
                                  "commonMistakes": [
                                    "Incluir não-terminais no Σ",
                                    "Gerar strings inválidas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar conjuntos de terminais para linguagens específicas",
                                  "subSteps": [
                                    "Definir uma linguagem específica: ex. 'palavras com vogais e consoantes' Σ = {a,e,i,o,u,b,c,d,...}.",
                                    "Selecionar terminais mínimos necessários para cobrir a linguagem.",
                                    "Validar o conjunto: deve gerar todas as strings desejadas sem extras desnecessários.",
                                    "Testar com derivações: aplicar regras de uma gramática simples.",
                                    "Documentar: Escrever Σ e 3 strings de exemplo."
                                  ],
                                  "verification": "Criar e apresentar 2 conjuntos personalizados com justificativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de exercícios ou ferramenta como Overleaf para LaTeX",
                                    "Referências de linguagens formais"
                                  ],
                                  "tips": "Comece com o menor alfabeto possível para simplicidade.",
                                  "learningObjective": "Desenvolver habilidade em construir alfabetos terminais sob medida.",
                                  "commonMistakes": [
                                    "Conjuntos infinitos",
                                    "Terminais irrelevantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar terminais com geração de strings",
                                  "subSteps": [
                                    "Explicar processo: derivações terminam quando só restam terminais.",
                                    "Gerar strings: partir de axioma S → α, substituindo até Σ*.",
                                    "Demonstrar com exemplo: Para Σ={0,1}, gramática S→0S|1S|ε gera todas binárias.",
                                    "Analisar árvores: identificar folhas como terminais.",
                                    "Praticar inverso: dada string, inferir possíveis Σ."
                                  ],
                                  "verification": "Gerar 5 strings de um Σ dado e mostrar derivações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de gramáticas online ou papel para desenhar árvores",
                                    "Exemplos resolvidos"
                                  ],
                                  "tips": "Use notação de derivação esquerda/direita para clareza.",
                                  "learningObjective": "Conectar terminais diretamente à geração de linguagens.",
                                  "commonMistakes": [
                                    "Parar derivação com não-terminais",
                                    "Ignorar ε como string vazia"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a linguagem binária: Σ = {0,1}. Exemplo de geração: S ⇒ 0S ⇒ 01S ⇒ 01 (string '01'). Isso mostra como terminais formam a saída final.",
                              "finalVerifications": [
                                "Pode definir terminais e dar Σ = {0,1} com 3 strings?",
                                "Consegue criar Σ para linguagem de placas de carro (letras + números)?",
                                "Explica como terminais aparecem em derivações?",
                                "Lista erros comuns em conjuntos de terminais?",
                                "Relaciona Σ com L(Σ*)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e notação de Σ",
                                "Diversidade e relevância dos exemplos fornecidos",
                                "Correção nas derivações e geração de strings",
                                "Criatividade em conjuntos personalizados",
                                "Clareza na relação com geração de linguagens",
                                "Ausência de confusão com não-terminais"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (alfabetos como conjuntos finitos)",
                                "Lógica: Símbolos em linguagens formais e autômatos",
                                "Linguística: Fonemas como terminais em gramáticas naturais",
                                "Programação: Tokens léxicos em analisadores"
                              ],
                              "realWorldApplication": "Em compiladores, terminais definem tokens léxicos (ex. Σ inclui keywords, operadores); em NLP, alfabetos de caracteres para modelar texto; em protocolos de rede, símbolos binários para pacotes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Símbolos Não-Terminais",
                        "description": "Os símbolos não-terminais, também chamados de variáveis, são placeholders que podem ser substituídos por sequências de terminais e não-terminais via regras de produção, geralmente representados por letras maiúsculas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Identificar símbolos não-terminais",
                            "description": "Reconhecer e listar símbolos não-terminais em uma gramática, diferenciando-os dos terminais pela convenção de notação (ex.: S, A, B).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entenda os Conceitos Fundamentais de Terminais e Não-Terminais",
                                  "subSteps": [
                                    "Leia a definição formal: terminais são símbolos que aparecem nas strings finais (folhas da árvore de derivação), não-terminais são variáveis que são substituídas por regras de produção.",
                                    "Compare os papéis: terminais terminam a derivação, não-terminais iniciam expansões.",
                                    "Estude exemplos básicos: em S → aS | b, 'a' e 'b' são terminais, S é não-terminal.",
                                    "Anote diferenças chave em um quadro comparativo.",
                                    "Resuma em suas próprias palavras."
                                  ],
                                  "verification": "Escreva uma definição curta e explique a diferença com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre gramáticas formais",
                                    "Livro de Teoria da Computação (capítulo de linguagens formais)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use analogia: não-terminais são como 'pastas' que se abrem, terminais são arquivos finais.",
                                  "learningObjective": "Definir precisamente terminais e não-terminais e diferenciar seus papéis em gramáticas.",
                                  "commonMistakes": [
                                    "Confundir não-terminais com variáveis de programação sem contexto gramatical",
                                    "Achar que todos os símbolos maiúsculos são terminais",
                                    "Ignorar o papel na derivação de strings"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprenda Convenções de Notação Padrão para Identificação",
                                  "subSteps": [
                                    "Memorize convenções: não-terminais geralmente em maiúsculas (S, A, B), terminais em minúsculas ou aspas (a, b, 'if').",
                                    "Estude variações: em alguns textos, não-terminais em itálico ou negrito.",
                                    "Analise regras de produção: lado esquerdo sempre não-terminal.",
                                    "Liste convenções em um glossário pessoal.",
                                    "Identifique em 3 regras de exemplo fornecidas."
                                  ],
                                  "verification": "Classifique 5 símbolos de exemplo como terminal ou não-terminal com justificativa de convenção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas impressas ou digitais",
                                    "Tabela de convenções de notação (Hopcroft & Ullman)",
                                    "Editor de texto para listar"
                                  ],
                                  "tips": "Sempre verifique o lado esquerdo das regras: é sempre um não-terminal único.",
                                  "learningObjective": "Reconhecer padrões de notação usados para distinguir terminais de não-terminais.",
                                  "commonMistakes": [
                                    "Aplicar convenções de programação (ex: camelCase) em vez de teoria formal",
                                    "Confundir símbolos gregos como terminais",
                                    "Ignorar aspas em terminais especiais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Pratique Identificação em Gramáticas Simples",
                                  "subSteps": [
                                    "Pegue uma gramática simples (ex: S → AB, A → a, B → b).",
                                    "Marque todos os símbolos nas regras.",
                                    "Classifique cada um como terminal ou não-terminal usando convenções.",
                                    "Liste apenas os não-terminais únicos.",
                                    "Repita com 2-3 gramáticas variadas."
                                  ],
                                  "verification": "Para uma gramática dada, liste corretamente todos os não-terminais sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de 5 gramáticas simples (exercícios online ou livro)",
                                    "Planilha ou papel quadriculado para marcar"
                                  ],
                                  "tips": "Varra todas as regras primeiro para coletar todos os símbolos antes de classificar.",
                                  "learningObjective": "Aplicar convenções para identificar não-terminais em gramáticas elementares.",
                                  "commonMistakes": [
                                    "Listar duplicatas",
                                    "Incluir terminais na lista de não-terminais",
                                    "Perder símbolos em regras compostas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplique em Gramáticas Complexas e Liste Completamente",
                                  "subSteps": [
                                    "Selecione uma gramática com múltiplos não-terminais (ex: gramática para palíndromos).",
                                    "Identifique todos os símbolos únicos em todas as regras.",
                                    "Diferencie terminais e não-terminais sistematicamente.",
                                    "Escreva a lista final de não-terminais em ordem alfabética.",
                                    "Valide cruzando com derivações de exemplo."
                                  ],
                                  "verification": "Forneça a lista completa de não-terminais para uma gramática complexa e justifique cada escolha.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Gramáticas complexas de exemplos (ex: Chomsky Type 2)",
                                    "Simulador de gramáticas online",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Crie um conjunto: todos símbolos menos terminais identificados = não-terminais.",
                                  "learningObjective": "Listar precisamente todos os símbolos não-terminais em gramáticas reais.",
                                  "commonMistakes": [
                                    "Omitir não-terminais em regras recursivas",
                                    "Confundir ε (vazio) como terminal sem contexto",
                                    "Listar símbolos de strings derivadas como parte da gramática"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática G = (V, Σ, P, S) onde V = {S, A}, Σ = {a, b}, P: S → aAb | ε, A → bA | a. Não-terminais: S, A (identificados por maiúsculas no lado esquerdo e expansões). Liste: ['S', 'A'].",
                              "finalVerifications": [
                                "Liste corretamente os não-terminais em 5 gramáticas variadas sem erros.",
                                "Diferencie terminais de não-terminais em uma gramática com 10+ regras.",
                                "Explique por que um símbolo específico é não-terminal usando convenção.",
                                "Construa o conjunto V a partir de uma gramática dada.",
                                "Identifique erros em uma lista proposta de não-terminais.",
                                "Aplique em derivação: trace não-terminais até terminais."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% correto na identificação e listagem.",
                                "Justificativa: Uso correto de convenções de notação em explicações.",
                                "Completude: Nenhum não-terminal omitido ou terminal incluído.",
                                "Eficiência: Identificação rápida em gramáticas complexas.",
                                "Diferenciação: Distinção clara em contextos variados.",
                                "Aplicação: Correta em derivações e árvores de parsing."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Analogia com categorias sintáticas em gramáticas naturais (ex: NP, VP).",
                                "Programação: Reconhecimento de tokens não-terminais em lexers/parsers (ANTLR, Yacc).",
                                "Matemática: Conjuntos e alfabeto em teoria dos conjuntos.",
                                "Lógica: Símbolos variáveis em sistemas formais lógicos.",
                                "Engenharia de Software: Modelagem de estados em autômatos finitos."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores (ex: GCC, Java Parser), identificar não-terminais é essencial para construir analisadores sintáticos que validam código-fonte, gerando árvores de sintaxe abstrata (AST) para otimização e geração de código."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Diferenciar terminais e não-terminais",
                            "description": "Comparar e contrastar as funções de terminais e não-terminais, explicando por que não-terminais permitem recursão e estrutura hierárquica nas derivações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Aprender Definições Básicas de Terminais e Não-Terminais",
                                  "subSteps": [
                                    "Leia a definição formal: Terminais são símbolos que não podem ser expandidos e formam as folhas das derivações; não-terminais são variáveis que são substituídas por produções.",
                                    "Identifique exemplos: Terminais como 'a', 'b', '+'; não-terminais como S, A, B em uma gramática.",
                                    "Estude a notação padrão: Terminais em minúsculas ou aspas, não-terminais em maiúsculas.",
                                    "Anote diferenças iniciais em um quadro comparativo.",
                                    "Revise com um diagrama simples de árvore de derivação."
                                  ],
                                  "verification": "Crie um quadro comparativo com pelo menos 3 exemplos de cada tipo e explique verbalmente.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (capítulo de gramáticas)",
                                    "Papel e caneta para quadro",
                                    "Vídeo introdutório sobre gramáticas formais"
                                  ],
                                  "tips": [
                                    "Use cores diferentes para terminais (azul) e não-terminais (vermelho) nos diagramas.",
                                    "Comece com gramáticas regulares simples para fixar conceitos."
                                  ],
                                  "learningObjective": "Definir precisamente terminais e não-terminais e fornecer exemplos corretos.",
                                  "commonMistakes": [
                                    "Confundir terminais com literais de código; achar que todos os símbolos maiúsculos são sempre não-terminais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar e Contrastar Funções",
                                  "subSteps": [
                                    "Liste funções dos terminais: Produzem a string final da linguagem, não expansíveis.",
                                    "Liste funções dos não-terminais: Geram estrutura via regras de produção, permitem derivações.",
                                    "Compare em tabela: Colunas para 'Função', 'Expansão possível?', 'Papel na derivação'.",
                                    "Discuta contraste: Terminais 'terminam' a derivação; não-terminais 'continuam' ela.",
                                    "Aplique a uma gramática exemplo: Identifique funções em G = {S → aS | b}."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com 4 linhas de contrastes e valide com um colega ou autoavaliação.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela comparativa",
                                    "Exemplos de gramáticas impressos",
                                    "Ferramenta online de gramáticas formais"
                                  ],
                                  "tips": [
                                    "Foque em 'o que acontece na derivação' para cada tipo.",
                                    "Use setas para mostrar fluxo de expansão."
                                  ],
                                  "learningObjective": "Contrastar funções de terminais (folhas) vs. não-terminais (nós internos).",
                                  "commonMistakes": [
                                    "Ignorar que terminais podem aparecer em lados direitos de produções; superestimar papéis dos terminais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Recursão Permitida por Não-Terminais",
                                  "subSteps": [
                                    "Defina recursão: Produção onde um não-terminal aparece em seu próprio lado direito, direta ou indiretamente.",
                                    "Exemplo direto: S → S a | a.",
                                    "Exemplo indireto: S → A b, A → S c.",
                                    "Simule derivações recursivas: Mostre como gera strings infinitas em teoria.",
                                    "Explique por quê terminais não permitem isso: Sem expansão, sem loop."
                                  ],
                                  "verification": "Gere 3 derivações recursivas de uma gramática e explique o papel do não-terminal.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Simulador de derivações online",
                                    "Papel para desenhar árvores recursivas",
                                    "Notas de aula sobre recursão"
                                  ],
                                  "tips": [
                                    "Desenhe árvores de derivação para visualizar profundidade recursiva.",
                                    "Limite recursão a 3 níveis para evitar confusão inicial."
                                  ],
                                  "learningObjective": "Explicar como não-terminais habilitam recursão em gramáticas.",
                                  "commonMistakes": [
                                    "Confundir recursão com repetição simples de terminais; achar que terminais podem recursar."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Estrutura Hierárquica nas Derivações",
                                  "subSteps": [
                                    "Construa árvore de derivação: Raiz é não-terminal inicial, folhas são terminais.",
                                    "Mostre hierarquia: Não-terminais criam níveis/nós internos.",
                                    "Exemplo: Gramática de expressões aritméticas com E, T, F.",
                                    "Compare com derivação linear: Sem não-terminais, só sequências terminais (sem hierarquia).",
                                    "Discuta impacto: Hierarquia permite parsing ambíguo ou não."
                                  ],
                                  "verification": "Desenhe árvore completa para uma derivação hierárquica e rotule terminais/não-terminais.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Software de desenho de árvores (Draw.io)",
                                    "Gramática exemplo impressa",
                                    "Vídeo sobre árvores de parsing"
                                  ],
                                  "tips": [
                                    "Sempre comece da sentença inicial e expanda camada por camada.",
                                    "Verifique balanceamento de parênteses na árvore."
                                  ],
                                  "learningObjective": "Demonstrar como não-terminais criam estrutura hierárquica em derivações.",
                                  "commonMistakes": [
                                    "Desenhar árvores lineares em vez de hierárquicas; ignorar múltiplos não-terminais na mesma produção."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática para expressões aritméticas: E → E + T | T; T → T * F | F; F → (E) | id. Terminais: +, *, (, ), id (formam o código final). Não-terminais: E, T, F (permitem recursão como E → E + T e hierarquia via subexpressões em parênteses). Derivação: E ⇒ E + T ⇒ T + T ⇒ F + T ⇒ id + T ⇒ id + F ⇒ id + id gera 'id + id'.",
                              "finalVerifications": [
                                "Identificar corretamente todos terminais e não-terminais em uma gramática dada.",
                                "Gerar uma derivação recursiva explicando o não-terminal envolvido.",
                                "Desenhar árvore hierárquica rotulando tipos de símbolos.",
                                "Explicar verbalmente por que terminais não permitem recursão.",
                                "Comparar funções em uma tabela sem erros.",
                                "Aplicar conceitos a uma nova gramática simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (100% correto).",
                                "Qualidade da comparação (cobertura de funções chave).",
                                "Correção em exemplos recursivos e hierárquicos.",
                                "Profundidade na explicação de recursão vs. terminais.",
                                "Criatividade e acurácia no diagrama de árvore.",
                                "Capacidade de aplicação independente."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Analogia com morfemas (terminais) vs. categorias sintáticas (não-terminais) em gramáticas gerativas de Chomsky.",
                                "Matemática: Estruturas de árvores e grafos hierárquicos em teoria dos grafos.",
                                "Programação: Parsing de código-fonte em compiladores (ASTs baseadas em gramáticas).",
                                "Biologia: Hierarquias em filogenia (nós não-terminais para ancestrais, folhas terminais para espécies)."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens de programação como Python ou Java, parsers usam gramáticas com não-terminais para construir árvores de sintaxe abstrata (AST), permitindo análise recursiva de estruturas aninhadas como loops dentro de funções, detectando erros de sintaxe e otimizando código."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Entender expansões de não-terminais",
                            "description": "Analisar como um não-terminal é expandido em derivações, ilustrando com uma árvore de derivação simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Gramáticas Formais e Não-Terminais",
                                  "subSteps": [
                                    "Defina o que é uma gramática formal (G = (V, Σ, P, S)).",
                                    "Identifique não-terminais (V) como símbolos que podem ser substituídos por regras de produção.",
                                    "Diferencie não-terminais de terminais (Σ), que são símbolos finais na string derivada.",
                                    "Examine exemplos simples de não-terminais em gramáticas de contexto livre.",
                                    "Liste funções dos não-terminais como placeholders para estruturas maiores."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre terminais e não-terminais com um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de linguagens formais ou slides sobre gramáticas; papel e caneta para anotações.",
                                  "tips": "Use cores diferentes para destacar não-terminais (azul) e terminais (verde) em exemplos.",
                                  "learningObjective": "Compreender a estrutura fundamental de gramáticas e o papel dos não-terminais.",
                                  "commonMistakes": "Confundir não-terminais com terminais; esquecer que não-terminais só aparecem no lado esquerdo das regras."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Regras de Produção e Expansões Iniciais",
                                  "subSteps": [
                                    "Analise uma regra de produção: A → α, onde A é não-terminal e α é uma string de símbolos.",
                                    "Explique que uma expansão substitui um não-terminal por seu lado direito.",
                                    "Pratique expansões únicas: comece com S e aplique uma regra.",
                                    "Registre a derivação linear: S ⇒ α.",
                                    "Identifique múltiplas expansões possíveis para o mesmo não-terminal (não-determinismo)."
                                  ],
                                  "verification": "Escreva 3 expansões diferentes para um não-terminal dado em uma gramática simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de gramáticas impressas ou em editor de texto; quadro branco.",
                                  "tips": "Sempre escreva a seta de derivação (⇒) para clareza na sequência.",
                                  "learningObjective": "Dominar como aplicar regras de produção para expandir não-terminais.",
                                  "commonMistakes": "Aplicar regras fora de ordem ou ignorar o contexto da gramática."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Derivações Passo a Passo",
                                  "subSteps": [
                                    "Escolha uma palavra terminal alvo e derive-a de S usando expansões sequenciais.",
                                    "Aplique expansões um por vez, substituindo apenas um não-terminal por vez.",
                                    "Documente cada passo da derivação esquerda-mais ou direita-mais.",
                                    "Compare derivações alternativas para a mesma palavra.",
                                    "Verifique se a derivação termina em terminais apenas."
                                  ],
                                  "verification": "Produza uma derivação completa para uma string específica e confirme que leva a terminais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de desenho de árvores ou papel milimetrado; gramática exemplo.",
                                  "tips": "Comece com derivações curtas para construir confiança antes de complexas.",
                                  "learningObjective": "Executar derivações completas rastreando expansões de não-terminais.",
                                  "commonMistakes": "Substituir terminais por engano ou pular passos intermediários."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e Interpretar Árvores de Derivação",
                                  "subSteps": [
                                    "Desenhe a raiz como o símbolo inicial S.",
                                    "Adicione filhos como o lado direito da regra aplicada ao não-terminal pai.",
                                    "Continue ramificando para cada expansão até folhas serem terminais.",
                                    "Rotule arestas com regras usadas e analise a estrutura hierárquica.",
                                    "Interprete a árvore: identifique subárvores correspondentes a expansões específicas."
                                  ],
                                  "verification": "Desenhe uma árvore de derivação para uma derivação linear fornecida e explique sua estrutura.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramenta de diagramação como Draw.io ou papel e lápis; exemplos resolvidos.",
                                  "tips": "Mantenha a árvore balanceada visualmente para melhor legibilidade.",
                                  "learningObjective": "Visualizar e analisar expansões de não-terminais via árvores de derivação.",
                                  "commonMistakes": "Desenhar árvores lineares em vez de hierárquicas; omitir rótulos de regras."
                                }
                              ],
                              "practicalExample": "Considere a gramática S → A | B, A → aA | a, B → b. Para derivar 'aa': S ⇒ A ⇒ aA ⇒ aa. Árvore: S no topo ramifica para A (regra S→A), A ramifica para aA (A→aA), aA para aa (A→a). Isso mostra expansões recursivas de A.",
                              "finalVerifications": [
                                "Explica corretamente o que é uma expansão de não-terminal.",
                                "Produz uma derivação linear válida com pelo menos 3 passos.",
                                "Desenha uma árvore de derivação simples sem erros estruturais.",
                                "Identifica todas as expansões usadas em uma derivação dada.",
                                "Diferencia derivações esquerda-mais e direita-mais.",
                                "Verifica se uma string pertence à linguagem via expansões."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e aplicação de regras de produção (30%).",
                                "Completude das derivações e árvores (25%).",
                                "Clareza na documentação de passos e rótulos (20%).",
                                "Correção na interpretação hierárquica das expansões (15%).",
                                "Criatividade em exemplos alternativos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Analogia com árvores sintáticas em gramáticas naturais.",
                                "Programação: Estruturas de parsing em compiladores (ex: Yacc/Bison).",
                                "Matemática: Teoria de grafos e árvores binárias.",
                                "Engenharia de Software: Modelagem de linguagens de domínio específico."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens de programação, entender expansões de não-terminais permite construir parsers que analisam código fonte, gerando árvores de sintaxe abstrata (AST) para otimização e execução, como no GCC ou JavaScript engines."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Regras de Produção",
                        "description": "As regras de produção são as transformações da forma A → α, onde A é um não-terminal e α é uma string de terminais e/ou não-terminais, definindo as substituições permitidas na gramática.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Escrever regras de produção",
                            "description": "Construir regras de produção válidas para uma gramática simples, respeitando a forma padrão e garantindo que o lado esquerdo seja um único não-terminal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os componentes básicos de uma gramática formal",
                                  "subSteps": [
                                    "Revise a definição de terminais (símbolos folha, como 'a', '+') e não-terminals (variáveis, como S, A).",
                                    "Identifique exemplos de linguagens simples, como {a^n b^n}.",
                                    "Diferencie regras de produção da forma geral α → β, focando na forma padrão A → α onde A é único não-terminal.",
                                    "Liste 3 exemplos de regras válidas e 2 inválidas para prática inicial.",
                                    "Anote as restrições: lado esquerdo deve ser exatamente um não-terminal."
                                  ],
                                  "verification": "Crie um glossário pessoal com definições corretas de terminais, não-terminals e forma padrão, sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de teoria da computação ou notas de aula sobre gramáticas formais; papel e caneta.",
                                  "tips": "Use maiúsculas para não-terminals e minúsculas para terminais como convenção padrão.",
                                  "learningObjective": "Compreender os elementos fundamentais que compõem regras de produção válidas.",
                                  "commonMistakes": "Confundir terminais com não-terminals; permitir múltiplos símbolos no lado esquerdo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e validar o lado esquerdo da regra",
                                  "subSteps": [
                                    "Escolha um único não-terminal (ex: S, E) do conjunto de não-terminals da gramática.",
                                    "Verifique se é exatamente um símbolo e é um não-terminal (não terminal).",
                                    "Considere o contexto da gramática: o não-terminal deve derivar algo útil para a linguagem.",
                                    "Escreva o lado esquerdo isolado: A →",
                                    "Teste com um exemplo: para gramática de palíndromos, use 'S' como LHS."
                                  ],
                                  "verification": "Confirme que o LHS é um único não-terminal escrevendo 3 exemplos válidos isolados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Lista de não-terminals da gramática exemplo; editor de texto simples.",
                                  "tips": "Sempre use setas '→' para indicar produção; evite '=' que é para axiomas.",
                                  "learningObjective": "Garantir que o lado esquerdo siga estritamente a forma padrão de uma regra de produção.",
                                  "commonMistakes": "Usar terminal no LHS (ex: a → b); múltiplos não-terminals (ex: SA → b)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o lado direito da regra",
                                  "subSteps": [
                                    "Defina o RHS como uma cadeia finita de terminais e/ou não-terminals (ex: a S b).",
                                    "Garanta que o RHS gere strings na linguagem alvo através de derivações.",
                                    "Inclua pelo menos um terminal ou recursão para progressão.",
                                    "Escreva variações: regras unitárias (A → B) e não-unitárias (A → a B c).",
                                    "Combine com LHS: complete pelo menos 3 regras completas."
                                  ],
                                  "verification": "Derive uma string simples do axioma usando a nova regra e verifique se pertence à linguagem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para derivações; simulador online de gramáticas (opcional).",
                                  "tips": "Mantenha RHS conciso; vise regras que evitem ambiguidade inicial.",
                                  "learningObjective": "Criar lados direitos que respeitem a semântica da gramática e permitam derivações válidas.",
                                  "commonMistakes": "RHS vazio sem contexto (ε-produções precisam de regras específicas); ciclos infinitos sem base."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar a regra completa",
                                  "subSteps": [
                                    "Escreva a regra na forma A → α e cheque LHS único não-terminal.",
                                    "Teste consistência com outras regras da gramática.",
                                    "Simule derivações de 2-3 passos para verificar utilidade.",
                                    "Identifique e corrija erros: invalide regras com LHS inválido.",
                                    "Documente a regra em um conjunto de 5 regras para uma gramática simples."
                                  ],
                                  "verification": "Uma gramática completa com suas regras gera pelo menos 3 strings válidas da linguagem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de exercícios com linguagens exemplo; calculadora de derivações manual.",
                                  "tips": "Use ferramentas como JFLAP para visualização se disponível.",
                                  "learningObjective": "Produzir regras de produção totalmente válidas e funcionais em uma gramática.",
                                  "commonMistakes": "Ignorar contexto livre (permitir LHS com terminais); regras que não terminam em terminais."
                                }
                              ],
                              "practicalExample": "Para a linguagem de palíndromos pares {ww^R | w em {a,b}*}, crie regra S → a S a | b S b | ε. Verificação: Deriva 'abba' via S => a S a => a b S b a => a b ε b a.",
                              "finalVerifications": [
                                "Lado esquerdo é exatamente um não-terminal.",
                                "Lado direito é uma cadeia válida de terminais e não-terminals.",
                                "Regra permite derivações que geram strings na linguagem alvo.",
                                "Não há violações da forma padrão de gramática tipo 2 (contexto livre).",
                                "Regra é consistente com o conjunto de não-terminals definido.",
                                "Derivação de teste produz string terminal válida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na forma A → α (100% conformidade).",
                                "Validade semântica: regra contribui para a linguagem correta.",
                                "Número de sub-passos executados corretamente (>90%).",
                                "Ausência de erros comuns identificados.",
                                "Criatividade em exemplos práticos e derivações.",
                                "Clareza na documentação da regra e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e relações recursivas.",
                                "Linguística: Estruturas sintáticas semelhantes a regras gramaticais naturais.",
                                "Programação: Parsing em compiladores (ex: YACC/Bison).",
                                "Lógica: Provas por indução em derivações.",
                                "Engenharia de Software: Modelagem formal de linguagens de programação."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, regras de produção definem a sintaxe de linguagens como Python ou Java, permitindo parsers gerarem árvores de análise sintática para código fonte válido."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1",
                              "10.1.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Aplicar derivações usando produções",
                            "description": "Executar uma derivação passo a passo a partir de uma string inicial, aplicando regras de produção sequencialmente até obter uma palavra terminal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática e identificar a string inicial",
                                  "subSteps": [
                                    "Analise a gramática formal fornecida: identifique o alfabeto não-terminal V, terminal Σ, conjunto de regras de produção P e símbolo inicial S.",
                                    "Liste todas as regras de produção relevantes, numerando-as para referência fácil.",
                                    "Confirme a string inicial, geralmente o símbolo S.",
                                    "Escreva a string inicial em uma linha separada para iniciar a derivação.",
                                    "Verifique se a gramática está no formato padrão (esquerda → direita)."
                                  ],
                                  "verification": "A gramática está completamente listada com todos os componentes identificados corretamente em um papel ou editor de texto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou quadro branco"
                                  ],
                                  "tips": "Sempre comece com S e mantenha as regras organizadas em uma tabela para consulta rápida.",
                                  "learningObjective": "Compreender os componentes fundamentais de uma gramática formal e prepará-los para derivação.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Esquecer o símbolo inicial S",
                                    "Listar regras incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a primeira regra de produção",
                                  "subSteps": [
                                    "Selecione uma regra de produção aplicável à string atual (substitua o não-terminal esquerdo pela direita).",
                                    "Escolha a regra baseada no não-terminal mais à esquerda ou conforme orientação (especifique o lado da derivação).",
                                    "Substitua exatamente uma ocorrência do não-terminal pela forma direita da regra.",
                                    "Escreva a nova string resultante abaixo da anterior, usando o símbolo ⇒ para indicar a derivação.",
                                    "Anote qual regra foi usada (ex: P1: S → AB)."
                                  ],
                                  "verification": "A primeira derivação está escrita corretamente com seta ⇒ e referência à regra usada.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Lista de regras impressa"
                                  ],
                                  "tips": "Aplique apenas uma regra por passo para manter a derivação sequencial e rastreável.",
                                  "learningObjective": "Executar a substituição inicial de uma regra de produção de forma precisa.",
                                  "commonMistakes": [
                                    "Substituir múltiplos não-terminais de uma vez",
                                    "Usar regra inaplicável",
                                    "Esquecer de anotar a regra usada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar regras de produção sequencialmente até aproximar o terminal",
                                  "subSteps": [
                                    "Examine a string atual e identifique o próximo não-terminal a ser substituído.",
                                    "Selecione e aplique a regra apropriada, substituindo apenas uma ocorrência por vez.",
                                    "Repita o processo, escrevendo cada nova string com ⇒ e referenciando a regra.",
                                    "Continue até que apenas terminais permaneçam ou nenhum não-terminal aplicável.",
                                    "Monitore o comprimento da string para evitar loops infinitos."
                                  ],
                                  "verification": "Sequência de derivações leva a uma string com poucos ou nenhum não-terminal restante.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para contar passos se necessário"
                                  ],
                                  "tips": "Use derivação por não-terminal mais à esquerda para consistência em gramáticas ambíguas.",
                                  "learningObjective": "Realizar derivações múltiplas de forma sequencial e controlada.",
                                  "commonMistakes": [
                                    "Aplicar regras em ordem errada levando a becos sem saída",
                                    "Entrar em loop infinito sem detectar",
                                    "Substituir terminais acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a derivação e obter a palavra terminal",
                                  "subSteps": [
                                    "Verifique se a string final contém apenas símbolos terminais (sem variáveis não-terminais).",
                                    "Confirme que cada passo da derivação usa uma regra válida da gramática.",
                                    "Compare a palavra terminal com o objetivo ou exemplo dado.",
                                    "Desenhe a árvore de derivação se aplicável para visualização.",
                                    "Documente o número total de passos e regras usadas."
                                  ],
                                  "verification": "String final é uma palavra terminal válida e toda a cadeia de derivações está correta.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta online como GrammarViz para verificação opcional"
                                  ],
                                  "tips": "Revise cada seta ⇒ duas vezes para erros de substituição.",
                                  "learningObjective": "Validar a completude e correção de uma derivação inteira.",
                                  "commonMistakes": [
                                    "Deixar não-terminais na string final",
                                    "Pular validação de regras",
                                    "Confundir palavra gerada com a desejada"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → aS | bA, A → aA | b. String inicial: S. Derivação para 'aabb': S ⇒ aS ⇒ a b A ⇒ a b a A ⇒ a b a b. Cada passo substitui um não-terminal pela direita da regra escolhida.",
                              "finalVerifications": [
                                "Lista completa de regras de produção foi usada corretamente em cada passo.",
                                "String final contém apenas terminais.",
                                "Cadeia de derivações é sequencial sem saltos.",
                                "Número de passos é mínimo ou conforme esperado.",
                                "Nenhuma regra inválida foi aplicada.",
                                "Árvore de derivação (opcional) corresponde à sequência linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de regras (100% corretas).",
                                "Completude da derivação até palavra terminal.",
                                "Clareza na documentação (setas ⇒ e referências a regras).",
                                "Eficiência (sem loops ou passos desnecessários).",
                                "Capacidade de explicar cada substituição verbalmente.",
                                "Detecção e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra simbólica e substituições em expressões.",
                                "Lógica: Raciocínio dedutivo em sequências de regras.",
                                "Linguística: Estruturas gerativas em gramáticas naturais.",
                                "Programação: Recursão e parsing em linguagens de programação."
                              ],
                              "realWorldApplication": "Em compiladores de programação, onde analisadores sintáticos (parsers) usam derivações para validar código-fonte; em processamento de linguagem natural para gerar frases válidas em chatbots ou tradutores automáticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1",
                              "10.1.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Identificar tipos de produções",
                            "description": "Classificar produções como unitárias (A → B), terminais (A → a) ou gerais (A → BC), e discutir implicações para simplificação de gramáticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Definições dos Tipos de Produções",
                                  "subSteps": [
                                    "Estude a definição de produção unitária: uma regra A → B onde A e B são não-terminais.",
                                    "Analise produção terminal: A → a, onde a é um terminal.",
                                    "Revise produção geral: A → BC, onde pelo menos um de B ou C é não-terminal e pode incluir terminais.",
                                    "Memorize as notações padrão: use maiúsculas para não-terminais e minúsculas para terminais.",
                                    "Compare os três tipos em uma tabela comparativa."
                                  ],
                                  "verification": "Crie uma tabela resumindo definições e exemplos simples; verifique se distingue corretamente cada tipo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou editor de texto, tabela de referência de gramáticas formais.",
                                  "tips": "Sempre verifique se o lado direito tem exatamente um não-terminal para unitária.",
                                  "learningObjective": "Dominar as definições precisas dos três tipos de produções em gramáticas.",
                                  "commonMistakes": "Confundir terminais com não-terminais; achar que A → a é unitária."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Praticar a Identificação de Tipos em Exemplos Isolados",
                                  "subSteps": [
                                    "Pegue 5 produções aleatórias e classifique cada uma como unitária, terminal ou geral.",
                                    "Justifique a classificação escrevendo o motivo baseado nas definições.",
                                    "Teste com produções mistas, como A → aB ou A → BC.",
                                    "Use um checklist: contar não-terminais no lado direito.",
                                    "Repita com 10 produções variadas para reforço."
                                  ],
                                  "verification": "Classifique corretamente pelo menos 90% de 10 produções fornecidas ou criadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Lista de exemplos de produções (de livro ou online), planilha para classificação.",
                                  "tips": "Lembre: unitária tem 1 não-terminal e nada mais; terminal tem só terminais.",
                                  "learningObjective": "Aplicar definições para classificar produções com precisão.",
                                  "commonMistakes": "Classificar A → ε (vazio) incorretamente; ignorar múltiplos símbolos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Implicações para Simplificação de Gramáticas",
                                  "subSteps": [
                                    "Explique por que produções unitárias podem ser eliminadas (cadeias de não-terminais).",
                                    "Discuta remoção de produções terminais desnecessárias para normalização.",
                                    "Descreva como gerais permitem recursão e complexidade.",
                                    "Estude teorema de Chomsky sobre simplificação removendo unitárias.",
                                    "Aplique em um exemplo: identifique e sugira remoções."
                                  ],
                                  "verification": "Escreva um parágrafo explicando implicações de cada tipo para simplificação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Livro de teoria da computação (ex: Sipser), notas de aula sobre Chomsky normal form.",
                                  "tips": "Foco em como unitárias criam ciclos desnecessários.",
                                  "learningObjective": "Entender o papel dos tipos na otimização de gramáticas.",
                                  "commonMistakes": "Subestimar impacto de unitárias em parsing eficiente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Classificação em uma Gramática Completa",
                                  "subSteps": [
                                    "Selecione uma gramática de exemplo com 8-10 produções.",
                                    "Classifique todas as produções e agrupe por tipo.",
                                    "Proponha simplificações removendo unitárias ou terminais redundantes.",
                                    "Gere uma versão simplificada e verifique se gera a mesma linguagem.",
                                    "Teste com derivações antes/depois."
                                  ],
                                  "verification": "Produza uma gramática simplificada correta e justifique mudanças.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Editor de texto, gramática exemplo (ex: S → AB | a, A → B | b, etc.).",
                                  "tips": "Substitua cadeias unitárias por produções diretas.",
                                  "learningObjective": "Integrar classificação e simplificação em gramáticas reais.",
                                  "commonMistakes": "Alterar a linguagem ao remover produções."
                                }
                              ],
                              "practicalExample": "Gramática G: S → AB, A → a | BC, B → b, C → c. Classificações: S → AB (geral), A → a (terminal), A → BC (geral), B → b (terminal), C → c (terminal). Simplificação: Remover unitárias se houver; aqui, focar em gerais para CNF.",
                              "finalVerifications": [
                                "Classifica corretamente 10 produções mistas sem erros.",
                                "Explica implicações de unitárias para eliminação em 1 minuto.",
                                "Simplifica uma gramática de 5 produções mantendo a linguagem.",
                                "Identifica todos os tipos em uma gramática padrão de linguagens regulares.",
                                "Discute diferenças entre tipos em contexto de Chomsky Normal Form.",
                                "Aplica classificação em derivação de palavra exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação (100% correto).",
                                "Profundidade na explicação de implicações (detalhes teóricos).",
                                "Criatividade em exemplos práticos e simplificações.",
                                "Clareza na justificativa de cada classificação.",
                                "Capacidade de conectar a simplificação global da gramática.",
                                "Velocidade e confiança na identificação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra e substituição de variáveis em equações.",
                                "Programação: Parsing em compiladores e reconhecimento de padrões.",
                                "Linguística: Análise sintática em gramáticas naturais.",
                                "Lógica: Classificação de regras em sistemas formais."
                              ],
                              "realWorldApplication": "Em compiladores, identificar produções unitárias permite otimizar parsers para linguagens de programação, reduzindo tempo de análise sintática em ferramentas como Yacc/Bison ou em NLP para modelagem de gramáticas probabilísticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.3.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.4",
                        "name": "Símbolo Inicial (Axioma)",
                        "description": "O símbolo inicial, denotado geralmente por S, é o não-terminal raiz de onde todas as derivações começam para gerar palavras da linguagem.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.4.1",
                            "name": "Identificar o símbolo inicial",
                            "description": "Localizar e destacar o axioma em uma definição formal de gramática G = (V, Σ, P, S).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura padrão de uma gramática formal",
                                  "subSteps": [
                                    "Leia a definição formal de gramática G = (V, Σ, P, S).",
                                    "Identifique os quatro componentes principais: V (variáveis), Σ (terminais), P (produções) e S (símbolo inicial).",
                                    "Anote o papel de cada componente, enfatizando que S é o axioma ou ponto de partida para derivações.",
                                    "Compare com exemplos simples para fixar a notação.",
                                    "Pesquise rapidamente a convenção padrão em livros ou notas sobre linguagens formais."
                                  ],
                                  "verification": "Você pode listar e explicar os quatro componentes de G sem consultar materiais?",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Definição de gramática formal (livro ou PDF)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Sempre associe S ao 'start symbol' ou 'axioma' para memorizar.",
                                  "learningObjective": "Entender a composição exata de uma gramática formal e o papel único do símbolo inicial.",
                                  "commonMistakes": [
                                    "Confundir S com elementos de V ou Σ.",
                                    "Ignorar que S pertence a V."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar uma gramática exemplo fornecida",
                                  "subSteps": [
                                    "Selecione uma gramática exemplo, como G = ({S, A}, {a, b}, P, S) onde P inclui S → aA | b.",
                                    "Localize a notação G = (V, Σ, P, S) na definição.",
                                    "Marque cada conjunto: V, Σ, P e destaque S.",
                                    "Desenhe um diagrama simples mostrando S como raiz.",
                                    "Repita com uma segunda gramática para prática."
                                  ],
                                  "verification": "Desenhe ou anote corretamente os componentes de pelo menos duas gramáticas exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas impressos ou digitais",
                                    "Marcadores ou editor de texto para destaque"
                                  ],
                                  "tips": "Use cores diferentes para cada componente: azul para S.",
                                  "learningObjective": "Praticar a localização visual dos componentes em definições reais.",
                                  "commonMistakes": [
                                    "Confundir o último elemento como parte de P.",
                                    "Assumir que o primeiro símbolo listado é sempre S."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar explicitamente o símbolo inicial S",
                                  "subSteps": [
                                    "Na gramática alvo, procure pela posição final na tupla G = (..., S).",
                                    "Confirme que S é um não-terminal (pertence a V).",
                                    "Escreva uma frase: 'O símbolo inicial é [S] porque está na quarta posição da tupla.'",
                                    "Teste removendo temporariamente S e veja se a gramática ainda é válida.",
                                    "Compare com documentação padrão para validar."
                                  ],
                                  "verification": "Pode isolar e nomear S de uma gramática aleatória em menos de 30 segundos?",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Gramática de teste impressa",
                                    "Cronômetro para simular rapidez"
                                  ],
                                  "tips": "Lembre-se: posição fixa na tupla é a chave; não depende do nome.",
                                  "learningObjective": "Desenvolver habilidade de localização precisa e rápida do axioma.",
                                  "commonMistakes": [
                                    "Escolher um terminal como S.",
                                    "Ignorar maiúsculas/minúsculas na notação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e destacar o símbolo inicial em contexto",
                                  "subSteps": [
                                    "Reescreva a gramática destacando S em negrito ou sublinhado.",
                                    "Explique em voz alta por que S é o inicial: 'É o start symbol de onde derivamos strings.'",
                                    "Crie uma derivação curta começando de S para confirmar.",
                                    "Registre em um log de prática para revisão futura.",
                                    "Autoavalie com uma checklist rápida."
                                  ],
                                  "verification": "Produza uma versão anotada da gramática com S destacado e explicação escrita.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de texto ou papel para anotações finais",
                                    "Checklist de verificação personalizada"
                                  ],
                                  "tips": "Sempre derive uma string simples de S para reforçar o conceito.",
                                  "learningObjective": "Consolidar a identificação através de aplicação prática e autoavaliação.",
                                  "commonMistakes": [
                                    "Não verificar se S gera a linguagem.",
                                    "Confundir S com o primeiro não-terminal em P."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática G = ({E, T, F}, {a, +, *, (, )}, P, E), onde P: E → E + T | T, T → T * F | F, F → (E) | a. O símbolo inicial é E, pois ocupa a quarta posição na tupla e é o axioma de onde derivamos expressões como a + a * (a).",
                              "finalVerifications": [
                                "Identifica corretamente S na tupla G = (V, Σ, P, S).",
                                "Explica que S é o não-terminal inicial.",
                                "Destaca S visualmente na definição.",
                                "Deriva uma string simples a partir de S.",
                                "Distingue S de outros elementos de V."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de S (100% correto).",
                                "Explicação clara do papel de S (detalhada e sem erros).",
                                "Uso correto de notação formal.",
                                "Rapidez e confiança na identificação.",
                                "Aplicação em derivação básica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conjuntos e tuplas em teoria dos conjuntos.",
                                "Lógica: Símbolos em provas formais e axiomas.",
                                "Programação: Símbolos start em parsers de linguagens (ex: ANTLR).",
                                "Linguística: Símbolos iniciais em gramáticas naturais.",
                                "Engenharia de Software: Definição de sintaxe em especificações BNF."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, identificar o símbolo inicial é essencial para construir árvores de parsing e gerar código a partir de linguagens de programação, como no desenvolvimento de linguagens DSL ou análise sintática em ferramentas como Yacc/Bison."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.4.2",
                            "name": "Explicar a importância do axioma",
                            "description": "Descrever como o axioma inicia o processo de geração de linguagem, sendo o ponto de partida único para todas as sentenças válidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o conceito de axioma em gramáticas formais",
                                  "subSteps": [
                                    "Revise a estrutura básica de uma gramática formal (V_n, V_t, P, S), destacando S como o axioma.",
                                    "Explique que o axioma é o símbolo inicial não-terminal único.",
                                    "Diferencie o axioma de outros não-terminais: ele é o ponto de partida obrigatório.",
                                    "Estude exemplos simples de axiomas em gramáticas regulares e context-free.",
                                    "Anote a notação padrão: G = (V_n, V_t, P, S)."
                                  ],
                                  "verification": "Escreva uma definição precisa do axioma e identifique-o em uma gramática dada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (capítulo de gramáticas formais)",
                                    "Folha de papel para anotações",
                                    "Exemplos de gramáticas online (ex: Wikipedia)"
                                  ],
                                  "tips": "Use diagramas para visualizar a posição do axioma na gramática.",
                                  "learningObjective": "Compreender a definição formal e o papel único do axioma.",
                                  "commonMistakes": [
                                    "Confundir axioma com terminais",
                                    "Achar que qualquer não-terminal pode iniciar derivações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o papel do axioma no processo de derivação",
                                  "subSteps": [
                                    "Descreva o processo de derivação: começa sempre do axioma S.",
                                    "Simule derivações passo a passo a partir de S até uma palavra terminal.",
                                    "Mostre que todas as sentenças válidas da linguagem L(G) derivam unicamente de S.",
                                    "Discuta como aplicações de regras de produção partem de S.",
                                    "Pratique derivando 3 palavras diferentes de um mesmo axioma."
                                  ],
                                  "verification": "Derive manualmente duas sentenças válidas a partir do axioma e confirme que não há derivações sem ele.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de derivações (ex: JFLAP)",
                                    "Gramática exemplo impressa",
                                    "Calculadora para contar passos"
                                  ],
                                  "tips": "Use setas (⇒) para representar derivações e destaque o início em S.",
                                  "learningObjective": "Dominar como o axioma inicia todas as gerações de linguagem.",
                                  "commonMistakes": [
                                    "Iniciar derivações de outros não-terminais",
                                    "Ignorar a unicidade do ponto de partida"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a importância do axioma para a linguagem gerada",
                                  "subSteps": [
                                    "Explique que sem axioma único, a gramática geraria múltiplas linguagens desconexas.",
                                    "Discuta completude: L(G) = {w | S ⇒* w, w ∈ V_t*}.",
                                    "Aborde unicidade: garante consistência e previsibilidade nas derivações.",
                                    "Compare com axiomas em matemática: ponto de partida para teoremas.",
                                    "Avalie impactos em parsing e reconhecimento de linguagens."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que o axioma é essencial, citando exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo tutorial sobre gramáticas (YouTube: Automata Theory)",
                                    "Artigo sobre Chomsky Hierarchy",
                                    "Notebook para redação"
                                  ],
                                  "tips": "Pense em analogias: axioma como 'casa' em um jogo de construção.",
                                  "learningObjective": "Articular a criticidade do axioma para validade e unicidade da linguagem.",
                                  "commonMistakes": [
                                    "Subestimar a necessidade de unicidade",
                                    "Confundir com recursão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar o entendimento com exemplos práticos",
                                  "subSteps": [
                                    "Construa uma gramática simples sem axioma definido e observe o caos.",
                                    "Corrija adicionando axioma e gere a linguagem.",
                                    "Teste em contextos reais: gramáticas de programação ou expressões aritméticas.",
                                    "Debata em grupo: 'O que acontece se mudarmos o axioma?'",
                                    "Resuma a importância em bullet points."
                                  ],
                                  "verification": "Crie uma gramática com axioma e prove que todas as sentenças derivam dele.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software JFLAP ou Graphviz para gramáticas",
                                    "Exemplos de gramáticas aritméticas",
                                    "Fórum online para discussão"
                                  ],
                                  "tips": "Experimente remover o axioma temporariamente para ver o efeito.",
                                  "learningObjective": "Aplicar o conceito para reforçar sua importância prática.",
                                  "commonMistakes": [
                                    "Não testar derivações exaustivas",
                                    "Esquecer de validar terminais"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática G para expressões aritméticas: S → a | S + S | (S). Aqui, S (axioma) gera todas as expressões válidas como 'a + (a + a)'. Sem S como único início, poderíamos ter derivações desconexas de outros símbolos, gerando inválidos como 'a + b' se b fosse outro não-terminal inicial.",
                              "finalVerifications": [
                                "Explicar verbalmente o papel do axioma em 1 minuto.",
                                "Identificar o axioma em qualquer gramática dada.",
                                "Derivar corretamente 5 sentenças de um axioma fornecido.",
                                "Discutir consequências de múltiplos axiomas.",
                                "Redigir uma definição precisa sem erros.",
                                "Aplicar em um exemplo real de parser."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição do axioma (20%)",
                                "Clareza na explicação do processo de derivação (25%)",
                                "Demonstração da unicidade e completude (20%)",
                                "Uso correto de exemplos e contraexemplos (15%)",
                                "Profundidade na discussão de importância (10%)",
                                "Capacidade de aplicação prática (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Axiomas em geometria euclidiana como ponto de partida.",
                                "Lógica: Axiomas em sistemas formais (ex: Peano).",
                                "Programação: Símbolos iniciais em parsers (ANTLR, Yacc).",
                                "Linguística: Frases iniciando de uma raiz sintática.",
                                "Inteligência Artificial: Gramáticas em processamento de linguagem natural."
                              ],
                              "realWorldApplication": "Em compiladores, o axioma define a raiz da árvore de parsing para código fonte válido; em NLP, inicia geração de sentenças coerentes em chatbots como GPT, garantindo que todas as respostas derivem de uma estrutura consistente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.4.3",
                            "name": "Iniciar derivações do axioma",
                            "description": "Realizar a primeira aplicação de produção a partir do axioma S, gerando strings intermediárias em uma derivação exemplo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o axioma e as regras de produção da gramática",
                                  "subSteps": [
                                    "Leia a definição completa da gramática formal fornecida.",
                                    "Identifique o símbolo inicial (axioma S) e confirme que é um não-terminal.",
                                    "Liste todas as regras de produção que têm S no lado esquerdo.",
                                    "Classifique terminais e não-terminais na gramática.",
                                    "Anote o tipo de gramática (ex: regular, livre de contexto)."
                                  ],
                                  "verification": "Lista completa e correta das produções aplicáveis a S, com distinção clara entre terminais e não-terminais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Definição da gramática formal",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Comece sempre pelo lado esquerdo das produções para filtrar as aplicáveis ao axioma.",
                                  "learningObjective": "Reconhecer os componentes fundamentais de uma gramática formal e o papel do axioma.",
                                  "commonMistakes": [
                                    "Confundir terminais (minúsculas) com não-terminais (maiúsculas)",
                                    "Ignorar restrições de tipo de gramática",
                                    "Listar produções irrelevantes para S"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar a regra de produção inicial para aplicação",
                                  "subSteps": [
                                    "Revise as produções listadas e escolha uma regra válida para substituir S.",
                                    "Verifique se a produção segue a forma α → β, onde α contém S.",
                                    "Justifique a escolha (ex: primeira produção ou aleatória para derivação esquerda/direita).",
                                    "Anote a produção selecionada: S → γ.",
                                    "Confirme que γ contém símbolos válidos da gramática."
                                  ],
                                  "verification": "Produção selecionada anotada corretamente com justificativa escrita.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista de produções do passo 1",
                                    "Folha de rascunho"
                                  ],
                                  "tips": "Em derivações de exemplo, prefira a produção que gere strings intermediárias interessantes.",
                                  "learningObjective": "Aprender a escolher e validar regras de produção aplicáveis ao símbolo inicial.",
                                  "commonMistakes": [
                                    "Escolher produção com lado esquerdo diferente de S",
                                    "Aplicar múltiplas produções de uma vez",
                                    "Usar terminais como lado esquerdo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a produção ao axioma e gerar a string intermediária",
                                  "subSteps": [
                                    "Escreva o axioma inicial: S ⇒",
                                    "Substitua S pela sequência do lado direito da produção escolhida.",
                                    "Registre a derivação: S ⇒ γ (onde γ é a string derivada).",
                                    "Verifique se todos os símbolos em γ pertencem ao alfabeto da gramática.",
                                    "Expanda a notação se necessário (ex: mostrar posição de substituição)."
                                  ],
                                  "verification": "String intermediária gerada corretamente, com derivação anotada: S ⇒ γ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Produção selecionada",
                                    "Exemplo de derivação em diagrama"
                                  ],
                                  "tips": "Use setas (⇒) para indicar derivação direta e mantenha alinhamento para clareza.",
                                  "learningObjective": "Executar a substituição precisa de um não-terminal por sua produção.",
                                  "commonMistakes": [
                                    "Substituir incorretamente os símbolos",
                                    "Gerar loops infinitos inadvertidamente",
                                    "Esquecer de registrar o passo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar e validar a derivação inicial",
                                  "subSteps": [
                                    "Escreva a derivação completa em formato linear ou arbóreo.",
                                    "Confirme que a aplicação é a primeira e gera uma string intermediária válida.",
                                    "Teste se a string pode levar a uma palavra terminal futura.",
                                    "Compare com um exemplo resolvido para validação.",
                                    "Registre observações sobre derivação esquerda vs. direita."
                                  ],
                                  "verification": "Derivação documentada em papel ou digital, validada contra exemplo padrão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo resolvido de derivação",
                                    "Ferramenta online de gramáticas (opcional)"
                                  ],
                                  "tips": "Sempre valide se a string intermediária não é terminal prematura.",
                                  "learningObjective": "Documentar derivações de forma padronizada e verificável.",
                                  "commonMistakes": [
                                    "Não registrar a seta de derivação",
                                    "Confundir ordem de aplicação",
                                    "Validar sem comparar com axioma original"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática G: S → aS | b. Axioma: S. Aplicação primeira: S ⇒ aS (usando S → aS). String intermediária: aS. Isso inicia uma derivação para palavras como 'aab'.",
                              "finalVerifications": [
                                "Gera corretamente a string intermediária a partir de S usando uma produção válida.",
                                "Registra a derivação com notação padrão (S ⇒ γ).",
                                "Distinguir terminais e não-terminais na string resultante.",
                                "Justifica a escolha da produção aplicada.",
                                "Identifica se a derivação é esquerda ou direita.",
                                "Valida que a aplicação é apenas a primeira produção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e aplicação da produção (40%).",
                                "Clareza e correção na documentação da derivação (30%).",
                                "Compreensão conceitual de axioma e componentes (20%).",
                                "Ausência de erros comuns como confusão de símbolos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução e provas por derivação em lógica formal.",
                                "Linguística: Análise sintática e árvores de parsing.",
                                "Programação: Fundamentos de recursão em linguagens de programação.",
                                "Filosofia: Sistemas axiomáticos em lógica proposicional."
                              ],
                              "realWorldApplication": "Essa habilidade é base para o desenvolvimento de parsers em compiladores e interpretadores de linguagens de programação, como no processamento de expressões em Python ou Java, permitindo a geração automática de código a partir de gramáticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.2.2.4.4",
                            "name": "Relacionar axioma com linguagem gerada",
                            "description": "Explicar como todas as palavras da linguagem L(G) são deriváveis exclusivamente do axioma via aplicações repetidas de P.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da gramática formal e o papel do axioma",
                                  "subSteps": [
                                    "Identifique os componentes da gramática G: alfabeto terminal V_T, não-terminal V_N, axioma S e conjunto de produções P.",
                                    "Explique que o axioma S é o símbolo inicial de onde todas as derivações começam.",
                                    "Liste as produções P e classifique-as como regulares, livres de contexto, etc.",
                                    "Desenhe o diagrama da gramática destacando S como raiz.",
                                    "Defina formalmente L(G) como o conjunto de todas as cadeias terminais deriváveis de S."
                                  ],
                                  "verification": "Crie um resumo escrito confirmando os 4 tuplas de G e o papel exclusivo de S.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel, lápis, definição de gramática formal de um livro-texto ou PDF.",
                                  "tips": "Use notação padrão: G = (V_T, V_N, P, S) para clareza.",
                                  "learningObjective": "Dominar os elementos fundamentais de uma gramática e o papel central do axioma.",
                                  "commonMistakes": "Confundir terminais com não-terminais ou ignorar que S deve ser não-terminal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar derivações passo a passo a partir do axioma",
                                  "subSteps": [
                                    "Comece com a sentença inicial: S.",
                                    "Aplique uma produção de P à esquerda ou direita, substituindo o não-terminal.",
                                    "Repita aplicações até obter uma cadeia terminal (sem não-terminais).",
                                    "Registre cada derivação em uma árvore ou sequência linear.",
                                    "Gere pelo menos 3 palavras diferentes em L(G) via derivações distintas."
                                  ],
                                  "verification": "Desenhe árvores de derivação para 3 palavras e confirme que terminam em terminais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, software como draw.io para árvores de derivação.",
                                  "tips": "Sempre indique qual produção foi aplicada em cada passo para rastreabilidade.",
                                  "learningObjective": "Executar derivações manuais demonstrando como S gera palavras específicas.",
                                  "commonMistakes": "Aplicar produções a terminais ou parar com não-terminais restantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar que toda palavra em L(G) é derivável exclusivamente do axioma",
                                  "subSteps": [
                                    "Defina L(G) = { w ∈ V_T* | S ⇒* w }, onde ⇒* significa derivação em zero ou mais passos.",
                                    "Prove por indução: base (w vazio se aplicável), passo indutivo (aplicação de P).",
                                    "Mostre que sem S, nenhuma derivação é possível (exclusividade).",
                                    "Identifique palavras não em L(G) e explique por que não derivam de S.",
                                    "Discuta closure sob concatenação ou outras propriedades."
                                  ],
                                  "verification": "Escreva uma prova curta por indução e liste 2 contraexemplos de palavras fora de L(G).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno de anotações, exemplos de gramáticas padrão (e.g., S → aSb | ε).",
                                  "tips": "Use indução forte sobre o comprimento da palavra para simplicidade.",
                                  "learningObjective": "Provar formalmente a relação exclusiva entre S e L(G).",
                                  "commonMistakes": "Assumir derivações de outros símbolos sem voltar a S; falhar na base da indução."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar propriedades da linguagem gerada e limitações",
                                  "subSteps": [
                                    "Classifique L(G) (regular, CF, CS, etc.) baseado nas produções.",
                                    "Gere um autômato ou diagrama equivalente que aceite L(G).",
                                    "Discuta ambiguidade: múltiplas derivações para a mesma palavra?",
                                    "Compare L(G) com outras linguagens via inclusão ou equivalência.",
                                    "Resuma como mudanças em P afetam L(G) mantendo S fixo."
                                  ],
                                  "verification": "Crie um diagrama de autômato para L(G) e teste com 3 palavras derivadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta JFLAP ou papel para autômatos.",
                                  "tips": "Teste o autômato com palavras de derivações anteriores para validação cruzada.",
                                  "learningObjective": "Conectar derivações do axioma a reconhecimento automatizado de L(G).",
                                  "commonMistakes": "Ignorar ambiguidade ou confundir L(G) com o conjunto de todas as derivações possíveis."
                                }
                              ],
                              "practicalExample": "Para G = ({a,b}, {S}, {S → aSb | ε}, S), derive 'aabbb' (não em L(G)) vs. 'aabb' (S ⇒ aSb ⇒ aεb = ab, espere: S ⇒ aSb ⇒ aaSbb ⇒ aabb). Toda w = a^n b^n deriva exclusivamente de S por n aplicações recursivas.",
                              "finalVerifications": [
                                "Todas as derivações começam e terminam exclusivamente de/para S.",
                                "Nenhuma palavra em L(G) requer símbolos fora de G.",
                                "Prova por indução cobre casos base e indutivo.",
                                "Exemplos incluem palavras dentro e fora de L(G).",
                                "Árvores de derivação estão completas e sem ambiguidades não resolvidas.",
                                "Classificação de L(G) é precisa (e.g., livre de contexto)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de derivações ⇒* (90% correto).",
                                "Qualidade das provas por indução (lógica impecável).",
                                "Número e variedade de exemplos práticos (mín. 3).",
                                "Clareza nos diagramas e árvores de derivação.",
                                "Compreensão de exclusividade do axioma (explicada verbalmente).",
                                "Identificação correta de propriedades de L(G)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução matemática e teoria dos conjuntos.",
                                "Lógica: Provas formais e raciocínio dedutivo.",
                                "Programação: Parsing em compiladores (e.g., YACC/Bison usa axiomas).",
                                "Linguística: Gramáticas gerativas de Chomsky.",
                                "IA: Modelos de linguagem generativa (e.g., GPTs como 'axiomas' probabilísticos)."
                              ],
                              "realWorldApplication": "Em compiladores, o axioma define a raiz da árvore de parsing para validar código fonte; em NLP, gramáticas geram sentenças válidas para chatbots ou tradutores automáticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.3",
                              "10.1.2.2.4.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Hierarquia de Chomsky",
                    "description": "Classificação das gramáticas em tipos 0, 1, 2 e 3, com suas restrições e linguagens correspondentes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Gramáticas Regulares (Tipo 3)",
                        "description": "Classificação das gramáticas regulares na hierarquia de Chomsky, suas restrições de produção (direita-linear ou esquerda-linear) e correspondência com linguagens regulares reconhecidas por autômatos finitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Definir forma de produção de gramáticas tipo 3",
                            "description": "Explicar a restrição de produções na forma A → aB ou A → a, onde A e B são não-terminais e a é terminal, diferenciando formas direita-linear e esquerda-linear.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de gramáticas formais",
                                  "subSteps": [
                                    "Identifique os quatro componentes de uma gramática formal: terminais (V_T), não-terminais (V_N), axioma (S) e conjunto de produções (P).",
                                    "Explique o papel de cada componente com exemplos simples (ex: terminais como 'a', 'b'; não-terminais como 'S', 'A').",
                                    "Diferencie símbolos terminais de não-terminais em uma notação padrão.",
                                    "Escreva uma gramática simples não-regular para contrastar posteriormente.",
                                    "Liste as regras gerais de derivação em gramáticas formais."
                                  ],
                                  "verification": "Escreva os quatro componentes de uma gramática exemplo e identifique corretamente terminais e não-terminais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Teoria da Computação (capítulo de gramáticas formais)",
                                    "Editor de texto para anotar exemplos"
                                  ],
                                  "tips": "Use diagramas para visualizar os componentes; memorize a notação G = (V_N, V_T, P, S).",
                                  "learningObjective": "Compreender os fundamentos de gramáticas formais para contextualizar as restrições do Tipo 3.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Esquecer o axioma como não-terminal especial",
                                    "Ignorar que produções podem ser recursivas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Hierarquia de Chomsky e Gramáticas Tipo 3",
                                  "subSteps": [
                                    "Descreva a Hierarquia de Chomsky: Tipo 0 (não-restritas), Tipo 1 (sensíveis ao contexto), Tipo 2 (livres de contexto), Tipo 3 (regulares).",
                                    "Explique por que o Tipo 3 é o mais restrito e gera linguagens regulares reconhecidas por autômatos finitos.",
                                    "Identifique as propriedades equivalentes: NFAs/DFAs, expressões regulares e gramáticas regulares.",
                                    "Compare com tipos superiores em termos de poder expressivo.",
                                    "Anote exemplos de linguagens regulares vs. não-regulares."
                                  ],
                                  "verification": "Classifique corretamente três linguagens exemplo na hierarquia e justifique o Tipo 3.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para diagramas da hierarquia",
                                    "Recursos online sobre Hierarquia de Chomsky",
                                    "Notas de aula anteriores"
                                  ],
                                  "tips": "Desenhe uma pirâmide para a hierarquia (Tipo 3 no topo como mais restrito); foque em equivalências.",
                                  "learningObjective": "Posicionar gramáticas regulares na hierarquia para entender suas restrições únicas.",
                                  "commonMistakes": [
                                    "Confundir ordem da hierarquia (Tipo 3 é mais restrito)",
                                    "Achar que Tipo 3 gera todas as linguagens livres de contexto",
                                    "Ignorar equivalência com autômatos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a forma exata das produções em gramáticas Tipo 3",
                                  "subSteps": [
                                    "Defina a forma direita-linear: A → aB ou A → a, onde A, B ∈ V_N e a ∈ V_T.",
                                    "Defina a forma esquerda-linear: A → Ba ou A → a, com mesmas restrições.",
                                    "Explique que uma gramática regular é direita-linear OU esquerda-linear.",
                                    "Escreva a definição formal matemática para ambas as formas.",
                                    "Verifique se uma produção dada atende à restrição (ex: S → aS é direita-linear)."
                                  ],
                                  "verification": "Classifique cinco produções exemplo como direita-linear, esquerda-linear ou inválida para Tipo 3.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha com exemplos de produções",
                                    "Calculadora simbólica ou editor para testar",
                                    "Referência: Sipser ou livro similar"
                                  ],
                                  "tips": "Lembre: apenas um terminal à esquerda (direita-linear) ou direita (esquerda-linear); nada no meio.",
                                  "learningObjective": "Memorizar e aplicar precisamente as restrições de produção para Tipo 3.",
                                  "commonMistakes": [
                                    "Permitir A → aBb (isso é Tipo 2)",
                                    "Confundir a com cadeia de terminais (deve ser único terminal)",
                                    "Esquecer que B pode ser ε em alguns contextos, mas focar em definição padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e exemplificar formas direita e esquerda-linear",
                                  "subSteps": [
                                    "Construa uma gramática direita-linear para L = {a^n b | n ≥ 0}: S → aS | b.",
                                    "Construa equivalente esquerda-linear: S → Sa | b (ajuste para simetria).",
                                    "Compare derivações: direita-linear gera prefixos à esquerda; esquerda-linear sufixos à direita.",
                                    "Converta uma gramática direita para esquerda e vice-versa.",
                                    "Identifique por que ambas geram as mesmas linguagens regulares."
                                  ],
                                  "verification": "Gere uma palavra exemplo de cada gramática e derive passo a passo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para derivações em árvore",
                                    "Ferramenta online de gramáticas (ex: JFLAP)",
                                    "Exemplos impressos"
                                  ],
                                  "tips": "Pratique derivações ⇒* para visualizar linearidade; teste com palavras curtas primeiro.",
                                  "learningObjective": "Diferenciar praticamente as formas e validar equivalência.",
                                  "commonMistakes": [
                                    "Produzir gramáticas que geram linguagens não-regulares",
                                    "Confundir ordem de derivação",
                                    "Esquecer casos base como A → a"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a linguagem regular L = {a^n b^m | n,m ≥ 0}, uma gramática direita-linear é: S → aS | T, T → bT | ε. Derive 'aabbb': S ⇒ aS ⇒ aaS ⇒ aaT ⇒ aabT ⇒ aab bT ⇒ aabbT ⇒ aabbb.",
                              "finalVerifications": [
                                "Defina corretamente as formas A → aB / A → a e A → Ba / A → a.",
                                "Classifique uma produção aleatória como Tipo 3 válida ou inválida.",
                                "Construa uma gramática direita-linear para uma linguagem regular simples.",
                                "Explique a diferença entre derivações direita e esquerda-linear.",
                                "Identifique equivalência com autômatos finitos.",
                                "Converta uma gramática direita para esquerda-linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição das restrições de produção (100% correto).",
                                "Capacidade de classificar produções (acertos >90%).",
                                "Construção válida de gramáticas exemplo sem erros.",
                                "Explicação clara da diferenciação linearidade.",
                                "Uso correto de notação formal.",
                                "Compreensão de contexto na hierarquia de Chomsky."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e relações em linguagens formais.",
                                "Linguística: Análise sintática e estruturas lineares em linguagem natural.",
                                "Engenharia de Software: Reconhecimento de padrões em compiladores e parsers.",
                                "Inteligência Artificial: Modelos finitos para processamento de sequências."
                              ],
                              "realWorldApplication": "Gramáticas regulares Tipo 3 são fundamentais em analisadores léxicos de compiladores (ex: lexers em C/Java), validação de expressões regulares em editores de texto (VS Code, grep) e protocolos de rede para parsing de strings simples."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Associar gramáticas tipo 3 a linguagens regulares",
                            "description": "Demonstrar a equivalência entre gramáticas regulares e linguagens reconhecidas por autômatos finitos determinísticos ou não-determinísticos, citando expressões regulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Linguagens Regulares e Gramáticas Tipo 3",
                                  "subSteps": [
                                    "Estudar a definição formal de linguagem regular como conjunto reconhecido por DFA, NFA ou gerado por expressões regulares.",
                                    "Revisar a estrutura de autômatos finitos determinísticos (DFA) e não-determinísticos (NFA), incluindo transições e estados de aceitação.",
                                    "Analisar expressões regulares básicas (união, concatenação, estrela de Kleene).",
                                    "Compreender a definição de gramática Tipo 3 (regular): regras da forma A → aB ou A → a ou A → ε, onde A,B não-terminais, a terminal.",
                                    "Identificar diferenças com outros tipos da Hierarquia de Chomsky."
                                  ],
                                  "verification": "Criar um mapa conceitual ligando os quatro elementos (linguagens regulares, DFA/NFA, regex, gramáticas Tipo 3).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Teoria da Computação' de Sipser",
                                    "Notas de aula sobre linguagens formais",
                                    "Vídeos Khan Academy ou YouTube sobre autômatos"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar sobreposições e equivalências.",
                                  "learningObjective": "Dominar as definições básicas e preparar terreno para demonstração de equivalência.",
                                  "commonMistakes": [
                                    "Confundir gramáticas regulares com context-free (Tipo 2).",
                                    "Esquecer que NFAs podem ter ε-transições."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Forma e Geração de Gramáticas Regulares",
                                  "subSteps": [
                                    "Classificar produções como direita-linear (A → aB) ou esquerda-linear (A → Ba).",
                                    "Gerar o conjunto de strings derivadas de uma gramática simples usando derivações passo a passo.",
                                    "Identificar e corrigir gramáticas inválidas para Tipo 3.",
                                    "Converter uma gramática regular para forma normal (apenas uma não-terminal inicial).",
                                    "Comparar linguagens geradas com representações regex equivalentes."
                                  ],
                                  "verification": "Derivar manualmente 5 strings de uma gramática dada e verificar se pertencem à linguagem regular descrita.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Ferramenta online JFLAP para simulação",
                                    "Exemplos de gramáticas regulares"
                                  ],
                                  "tips": "Comece com gramáticas pequenas para evitar derivações longas.",
                                  "learningObjective": "Entender como gramáticas Tipo 3 geram precisamente linguagens regulares.",
                                  "commonMistakes": [
                                    "Permitir produções com múltiplos não-terminais à direita.",
                                    "Gerar strings infinitas sem padrão."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Equivalências: Gramática ↔ Autômato Fino ↔ Regex",
                                  "subSteps": [
                                    "Construir um NFA a partir de uma gramática regular: estados para não-terminais, transições baseadas em produções.",
                                    "Converter NFA para DFA usando subconjuntos de estados.",
                                    "Eliminar ε-transições e estados inacessíveis no autômato.",
                                    "Derivar uma expressão regular equivalente do autômato usando eliminação de estados.",
                                    "Verificar equivalência gerando as mesmas strings em todas as representações."
                                  ],
                                  "verification": "Converter uma gramática simples para NFA e depois para regex, testando com 3 strings de aceitação/rejeição.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software JFLAP ou draw.io para diagramas de autômatos",
                                    "Tabelas de transição em Excel",
                                    "Exercícios resolvidos de equivalência"
                                  ],
                                  "tips": "Desenhe autômatos à mão antes de usar ferramentas para melhor compreensão.",
                                  "learningObjective": "Demonstrar formalmente a equivalência entre as três representações.",
                                  "commonMistakes": [
                                    "Esquecer transições para o estado final em construções de NFA.",
                                    "Erro na powerset construction para DFA."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar a Equivalência em Exemplos Complexos",
                                  "subSteps": [
                                    "Escolher uma linguagem regular real (ex: strings terminando em '01') e criar gramática, NFA e regex.",
                                    "Provar que uma gramática dada gera linguagem regular via construção de autômato.",
                                    "Testar propriedades de fechamento (união, concatenação, estrela).",
                                    "Discutir teoremas de equivalência (pumping lemma para não-regular, mas foco em regulares).",
                                    "Resolver exercícios mistos de conversão."
                                  ],
                                  "verification": "Resolver 2 problemas completos de conversão e autoavaliar com critérios de corretude.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Lista de exercícios de linguagens formais",
                                    "Ferramentas online como regex101 para teste",
                                    "Compilador regex em Python"
                                  ],
                                  "tips": "Use linguagens familiares como padrões de email para motivação.",
                                  "learningObjective": "Aplicar o conhecimento para associar qualquer gramática Tipo 3 a linguagens regulares.",
                                  "commonMistakes": [
                                    "Aplicar pumping lemma incorretamente para provar regularidade.",
                                    "Ignorar casos vazios ou ε."
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática G: S → 0S | 01. Gera L(G) = {0^n 1 | n ≥ 0}. Construa NFA: estados {S, F}, transições S -0→ S, S -1→ F. Converta para regex: 0*1. Teste: '001' aceito, '010' rejeitado.",
                              "finalVerifications": [
                                "Construir NFA correto a partir de qualquer gramática Tipo 3 simples.",
                                "Converter NFA para regex equivalente sem erros.",
                                "Gerar derivações corretas e prever aceitação em DFA.",
                                "Identificar gramáticas não-regulares e justificar.",
                                "Provar equivalência para uma linguagem dada em múltiplas formas.",
                                "Testar 5 strings contra todas as representações."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas construções de autômatos (100% das transições corretas).",
                                "Corretude das expressões regulares geradas (teste com múltiplas strings).",
                                "Profundidade das derivações em gramáticas (padrões infinitos cobertos).",
                                "Uso correto de teoremas de equivalência.",
                                "Criatividade em exemplos reais e conexões.",
                                "Ausência de erros comuns como loops infinitos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de regex em Python (re module) para parsing.",
                                "Matemática: Álgebra de linguagens formais e teoria dos conjuntos.",
                                "Lógica: Autômatos como modelos computacionais de lógica proposicional.",
                                "Engenharia de Software: Lexers em compiladores (Flex tool).",
                                "Inteligência Artificial: Modelos finitos em reconhecimento de padrões."
                              ],
                              "realWorldApplication": "Desenvolvimento de validadores de padrões como emails/senhas em sites web usando regex derivados de gramáticas regulares; análise léxica em compiladores e motores de busca para matching de queries."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Identificar restrições e exemplos de gramáticas tipo 3",
                            "description": "Reconhecer violações das restrições tipo 3 em produções dadas e construir exemplos simples de gramáticas regulares para linguagens como (a|b)* ou a^n b^n com n≤1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as restrições formais das gramáticas tipo 3",
                                  "subSteps": [
                                    "Estude a definição de gramática regular (Tipo 3): produções na forma A → aB ou A → a, onde A e B são não-terminais e a é terminal.",
                                    "Identifique as formas permitidas: direita-linear (A → aB) e esquerda-linear (A → Ba).",
                                    "Revise a hierarquia de Chomsky e posicione as gramáticas tipo 3 como as mais restritivas.",
                                    "Anote exemplos de produções válidas e inválidas.",
                                    "Compare com tipos 2 e 1 para reforçar diferenças."
                                  ],
                                  "verification": "Liste corretamente 5 produções válidas e 3 inválidas de gramáticas tipo 3.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (ex: Sipser), papel e caneta, slides sobre Hierarquia de Chomsky.",
                                  "tips": "Memorize as formas exatas: apenas um não-terminal à esquerda e terminal seguido de no máximo um não-terminal à direita.",
                                  "learningObjective": "Dominar as regras sintáticas das produções tipo 3.",
                                  "commonMistakes": "Confundir com contexto-livre (permitir A → aBC); ignorar ε-produções ou múltiplos terminais sem não-terminais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar violações de restrições em produções dadas",
                                  "subSteps": [
                                    "Analise uma lista de 10 produções fornecidas e classifique cada uma como válida ou inválida.",
                                    "Para inválidas, especifique a restrição violada (ex: múltiplos não-terminais à direita).",
                                    "Pratique com produções ambíguas, como A → AB ou A → aB C.",
                                    "Crie um fluxograma para verificação rápida.",
                                    "Teste com exemplos de livros ou online."
                                  ],
                                  "verification": "Corretamente identifique violações em pelo menos 8/10 produções de um conjunto teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha com 20 produções exemplo, calculadora simbólica ou editor de texto.",
                                  "tips": "Sempre verifique o lado esquerdo (um único NT) e direito (terminal + opcional um NT).",
                                  "learningObjective": "Desenvolver habilidade de detecção rápida de não-regularidade.",
                                  "commonMistakes": "Aceitar produções com ε sem contexto; confundir terminais com não-terminais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir exemplos simples de gramáticas regulares",
                                  "subSteps": [
                                    "Para L = (a|b)*, defina S → aS | bS | ε.",
                                    "Para L = {a^n b^n | n ≤ 1} = {ε, ab}, crie S → aB | ε, B → b.",
                                    "Construa gramática para outras linguagens regulares simples como a* ou (ab)*.",
                                    "Teste gerando strings da linguagem a partir da gramática.",
                                    "Refatore para minimizar não-terminais."
                                  ],
                                  "verification": "Gere pelo menos 5 strings válidas e confirme que não gera inválidas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel para derivações, simulador de gramáticas online (ex: JFLAP).",
                                  "tips": "Comece com o alfabeto e construa recursivamente para repetições.",
                                  "learningObjective": "Capacitar construção de G equivalente a expressões regulares simples.",
                                  "commonMistakes": "Usar recursão não-linear (ex: S → aS b); exceder forma tipo 3."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e integrar conceitos com exemplos práticos",
                                  "subSteps": [
                                    "Combine passos anteriores: pegue uma produção inválida, corrija para tipo 3.",
                                    "Construa G para (a|b)* e verifique violações em uma G proposta errada.",
                                    "Para a^n b^n n≤1, valide derivações como S ⇒ ab.",
                                    "Discuta ambiguidades e unicidade.",
                                    "Resolva 3 exercícios de verificação completa."
                                  ],
                                  "verification": "Resolva um exercício completo: identifique violação e construa G corrigida.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exercícios impressos, JFLAP ou ferramenta similar.",
                                  "tips": "Sempre derive strings de exemplo para validar a gramática.",
                                  "learningObjective": "Integrar identificação e construção em fluxos completos.",
                                  "commonMistakes": "Construir G que gera linguagem errada; ignorar casos base como ε."
                                }
                              ],
                              "practicalExample": "Dada a produção inválida S → aSB (viola tipo 3 por dois NT à direita), corrija para S → aT, T → bS | ε para aproximar L = a* b*. Verifique gerando: S ⇒ aT ⇒ abS ⇒ abε = ab.",
                              "finalVerifications": [
                                "Lista todas restrições tipo 3 corretamente sem erros.",
                                "Identifica violações em 90% das produções teste.",
                                "Constrói G válida para (a|b)* gerando strings como ε, a, ab, ba.",
                                "Constrói G para a^n b^n n≤1 gerando exatamente {ε, ab}.",
                                "Explica diferenças com tipo 2 em um parágrafo.",
                                "Valida derivações sem ambiguidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de restrições (100% nas regras).",
                                "Correção nas detecções de violações (mínimo 85%).",
                                "Equivalência da G construída à linguagem alvo (testada por derivações).",
                                "Clareza e minimalismo na construção de gramáticas.",
                                "Profundidade nas explicações de erros comuns.",
                                "Integração de exemplos reais nos passos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e indução em linguagens regulares.",
                                "Programação: Regex em linguagens como Python para padrões tipo 3.",
                                "Linguística: Análise sintática em gramáticas gerativas.",
                                "Lógica: Autômatos finitos equivalentes a gramáticas tipo 3."
                              ],
                              "realWorldApplication": "Em compiladores, gramáticas regulares são usadas em analisadores léxicos (lexers) para tokenizar código-fonte, como identificar identificadores (letras seguidas de dígitos*) ou em expressões regulares para validação de padrões em buscas web e processamento de logs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Gramáticas Livres de Contexto (Tipo 2)",
                        "description": "Características das gramáticas livres de contexto na hierarquia de Chomsky, com produções na forma A → α, onde A é não-terminal e α é qualquer cadeia, e sua relação com autômatos de pilha.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Definir restrições de gramáticas tipo 2",
                            "description": "Descrever a forma geral de produções A → α e a propriedade de livre-contexto, contrastando com tipos inferiores e superiores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Hierarquia de Chomsky",
                                  "subSteps": [
                                    "Estude os quatro tipos de gramáticas na hierarquia de Chomsky: Tipo 0 (irrestritas), Tipo 1 (sensíveis ao contexto), Tipo 2 (livres de contexto) e Tipo 3 (regulares).",
                                    "Identifique as restrições principais de cada tipo, focando na progressão de poder expressivo.",
                                    "Anote exemplos simples para cada tipo: ex. Tipo 3 para linguagens regulares como (a|b)*.",
                                    "Compare o poder de geração: Tipo 0 > Tipo 1 > Tipo 2 > Tipo 3.",
                                    "Crie um diagrama mental ou desenhe a hierarquia para visualização."
                                  ],
                                  "verification": "Crie um resumo de 1 página com definições e exemplos de cada tipo; verifique se cobre todos os quatro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Slides sobre Hierarquia de Chomsky",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use mnemônicos como '0 irrestrito, 1 contexto, 2 livre, 3 regular' para memorizar.",
                                  "learningObjective": "Compreender a posição das gramáticas tipo 2 na hierarquia de Chomsky.",
                                  "commonMistakes": "Confundir poder expressivo: lembrar que Tipo 2 não gera todas as linguagens Tipo 1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Forma Geral de Produções em Gramáticas Tipo 2",
                                  "subSteps": [
                                    "Defina os componentes: V_N (não-terminais), V_T (terminais), P (produções), S (axioma).",
                                    "Estude a restrição: toda produção deve ser A → α, onde A ∈ V_N e α ∈ (V_N ∪ V_T)*.",
                                    "Note que α não pode ser ε exceto possivelmente para S → ε.",
                                    "Escreva 3 exemplos de produções válidas e 3 inválidas para praticar.",
                                    "Construa uma gramática simples completa com 4-5 produções."
                                  ],
                                  "verification": "Liste 5 produções válidas e explique por que cada uma segue A → α.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Notas de aula sobre gramáticas formais",
                                    "Editor de texto para escrever gramáticas",
                                    "Referência online: Wikipedia Chomsky Hierarchy"
                                  ],
                                  "tips": "Sempre verifique se o lado esquerdo é um único não-terminal.",
                                  "learningObjective": "Dominar a sintaxe exata das produções em gramáticas livres de contexto.",
                                  "commonMistakes": "Permitir produções com múltiplos não-terminais no lado esquerdo, como AB → C."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Propriedade de Livre-Contexto",
                                  "subSteps": [
                                    "Defina 'livre de contexto': aplicação de produção depende apenas do não-terminal atual, não do contexto.",
                                    "Compare com Tipo 1: em Tipo 1, |α| ≥ |β| em Aα → βBγ, contexto importa.",
                                    "Simule derivações em uma CFG para ver independência de contexto.",
                                    "Discuta equivalência com autômatos de empilhamento pushdown.",
                                    "Resolva exercício: prove que uma dada gramática é tipo 2 analisando produções."
                                  ],
                                  "verification": "Explique em 3 frases o que significa 'livre de contexto' e dê um exemplo de violação.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Vídeo tutorial sobre CFGs (ex: YouTube canal de Teoria da Computação)",
                                    "Simulador de derivações online"
                                  ],
                                  "tips": "Pense em árvores de derivação: cada nó interno é um não-terminal expandido independentemente.",
                                  "learningObjective": "Entender a essência semântica das restrições tipo 2.",
                                  "commonMistakes": "Confundir com gramáticas regulares: CFGs permitem recursão não-linear."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com Tipos Inferiores e Superiores",
                                  "subSteps": [
                                    "Compare com Tipo 3 (regulares): produções A → aB ou A → a; sem recursão à esquerda livre.",
                                    "Compare com Tipo 1: restrição |α| ≤ |β|; contexto via comprimento.",
                                    "Identifique linguagens: {a^n b^n} é tipo 2 mas não tipo 3; {a^n b^n c^n} é tipo 1 mas não tipo 2.",
                                    "Crie tabela de comparação: restrições, autômatos equivalentes, exemplos.",
                                    "Pratique classificando 5 gramáticas em tipos."
                                  ],
                                  "verification": "Preencha tabela de contrastes corretamente para 3 pares de tipos.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Planilha ou tabela em Google Docs",
                                    "Lista de exercícios de classificação de gramáticas"
                                  ],
                                  "tips": "Use contraexemplos para diferenciar poderes: palíndromos para tipo 2 vs regular.",
                                  "learningObjective": "Diferenciar precisamente gramáticas tipo 2 de outras na hierarquia.",
                                  "commonMistakes": "Achar que todas as CFGs são regulares; testar com {ww | w em {a,b}*}"
                                }
                              ],
                              "practicalExample": "Considere a gramática para expressões aritméticas simples: E → E + T | T; T → T * F | F; F → (E) | id. Todas produções seguem A → α (ex: E → E + T), livre de contexto, gera sintaxe válida como id + id * (id).",
                              "finalVerifications": [
                                "Escreva corretamente a forma geral A → α e identifique componentes.",
                                "Classifique uma gramática dada como tipo 2 ou não.",
                                "Explique livre-contexto com exemplo de derivação.",
                                "Dê uma linguagem tipo 2 não regular e uma tipo 1 não tipo 2.",
                                "Construa uma CFG válida para {a^n b^n | n ≥ 0}.",
                                "Identifique erro em produção inválida como 'aA → B'."
                              ],
                              "assessmentCriteria": [
                                "Precisão na forma geral de produções (sem erros sintáticos).",
                                "Compreensão clara de livre-contexto vs dependente de contexto.",
                                "Capacidade de contrastar corretamente com tipos 1 e 3 via exemplos.",
                                "Uso correto de terminologia (V_N, V_T, etc.).",
                                "Habilidade em construir e validar gramáticas simples.",
                                "Identificação precisa de linguagens por tipo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra formal e recursão em estruturas discretas.",
                                "Linguística: Análise sintática de linguagens naturais.",
                                "Engenharia de Software: Parsing em compiladores e interpretadores.",
                                "Inteligência Artificial: Modelos de linguagem em PLN."
                              ],
                              "realWorldApplication": "Gramáticas tipo 2 são fundamentais em compiladores para análise sintaxe de linguagens de programação (ex: parsers LL/LR em GCC ou Java), permitindo estruturas aninhadas como blocos if-else ou expressões recursivas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Relacionar com autômatos de pilha",
                            "description": "Explicar a equivalência entre linguagens livres de contexto e linguagens aceitas por autômatos de pilha não-determinísticos, incluindo exemplos como {a^n b^n | n ≥ 0}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Gramáticas Livres de Contexto (CFLs) e Autômatos de Pilha (PDAs)",
                                  "subSteps": [
                                    "Defina gramática livre de contexto (GLC) e suas regras de produção.",
                                    "Explique a hierarquia de Chomsky e posição das CFLs.",
                                    "Descreva a estrutura de um autômato de pilha não-determinístico (NPDA): estados, alfabeto, pilha, transições.",
                                    "Compare aceitação por pilha vazia vs. estado final.",
                                    "Estude exemplos simples de CFLs como {a^n b^n | n ≥ 0}."
                                  ],
                                  "verification": "Desenhe um diagrama de GLC simples e um NPDA básico, confirmando que ambos geram/aceitam {a^n | n ≥ 0}.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (ex: Sipser), papel e caneta, simulador online de PDA (ex: JFLAP).",
                                  "tips": "Use notação formal: G = (V, Σ, P, S) para GLCs e δ para transições de PDA.",
                                  "learningObjective": "Compreender os componentes teóricos que sustentam a equivalência CFL-NPDA.",
                                  "commonMistakes": "Confundir PDA determinístico (DPDA) com não-determinístico; lembrar que NPDA é mais poderoso."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir um NPDA para a Linguagem {a^n b^n | n ≥ 0}",
                                  "subSteps": [
                                    "Inicie no estado q0 com pilha vazia.",
                                    "Para cada 'a', empilhe um símbolo A e transite para q1.",
                                    "Ao ler 'b', desempilhe um A por 'b', retornando à pilha vazia.",
                                    "Aceite se pilha vazia após entrada e em estado final.",
                                    "Teste com strings: ε, ab, aabb, aaabbb."
                                  ],
                                  "verification": "Simule o NPDA em JFLAP para n=0 a 3, confirmando aceitação correta.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta JFLAP ou papel para diagramas, exemplos de strings impressos.",
                                  "tips": "Use ε-transições para flexibilidade; desenhe o diagrama de estados primeiro.",
                                  "learningObjective": "Implementar um NPDA que reconhece uma CFL clássica, demonstrando uso da pilha para contagem aninhada.",
                                  "commonMistakes": "Esquecer de tratar n=0 (string vazia); não gerenciar overflow/underflow da pilha."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Mesma Linguagem com uma GLC",
                                  "subSteps": [
                                    "Escreva a GLC: S → ε | a S b.",
                                    "Gere derivações para n=0: S ⇒ ε; n=1: S ⇒ a S b ⇒ a ε b = ab; n=2: S ⇒ a S b ⇒ a a S b b ⇒ a a ε b b = aabb.",
                                    "Prove que a linguagem gerada é exatamente {a^n b^n | n ≥ 0}.",
                                    "Compare árvores de derivação com execuções do NPDA.",
                                    "Identifique recursão à esquerda/direita na gramática."
                                  ],
                                  "verification": "Gere manualmente 4 derivações e confirme equivalência com simulações do NPDA do Step 2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel para árvores de derivação, calculadora para contar passos.",
                                  "tips": "Sempre reduza à forma normal de Chomsky para simplificar comparações futuras.",
                                  "learningObjective": "Gerar a mesma linguagem via GLC, destacando simetria com o NPDA.",
                                  "commonMistakes": "Produzir derivações infinitas; confundir não-terminais com terminais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar e Provar a Equivalência Geral CFL ↔ NPDA",
                                  "subSteps": [
                                    "Teorema 1: Toda CFL tem um NPDA (construção bottom-up via parsing CYK ou Earley adaptado).",
                                    "Teorema 2: Todo NPDA gera uma CFL (construção top-down via gramática a partir de transições).",
                                    "Discuta não-determinismo: NPDA pode 'adivinhar' caminhos corretos.",
                                    "Exemplo adicional: ww^R (palíndromos pares).",
                                    "Resuma propriedades: fechamento sob união, concatenação, mas não interseção."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo os teoremas e esboce construções para ambos os sentidos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Notas de aula ou capítulo de livro sobre teoremas de equivalência, quadro branco virtual.",
                                  "tips": "Lembre: DPDA aceita subconjunto estrito de CFLs (ex: {a^n b^n} é determinístico, mas palíndromos não).",
                                  "learningObjective": "Formalizar a bijeção teórica entre GLCs e NPDAs.",
                                  "commonMistakes": "Ignorar o papel da pilha infinita; confundir com autômatos finitos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Testar com Exemplos Avançados",
                                  "subSteps": [
                                    "Construa NPDA para {a^n b^m | n ≤ m ≤ 2n}.",
                                    "Gere GLC correspondente e valide.",
                                    "Simule falhas em strings inválidas (ex: aaabbb para n=3 b=2).",
                                    "Discuta limitações: CFLs não capturam {a^n b^n c^n}.",
                                    "Registre insights sobre poder expressivo."
                                  ],
                                  "verification": "Crie relatório de 1 página com diagramas e simulações para o novo exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "JFLAP, exemplos de linguagens impressos.",
                                  "tips": "Use múltiplos símbolos de pilha para linguagens mais complexas.",
                                  "learningObjective": "Reforçar equivalência através de prática hands-on com variações.",
                                  "commonMistakes": "Não testar casos de borda como n=0 ou strings longas."
                                }
                              ],
                              "practicalExample": "Desenvolva um NPDA para validar expressões balanceadas como (()) ou ()(), correspondente à GLC S → (S)S | ε, simulando em JFLAP e gerando 5 derivações para confirmar equivalência.",
                              "finalVerifications": [
                                "Construir e simular NPDA correto para {a^n b^n | n ≥ 0}.",
                                "Gerar derivações GLC equivalentes sem erros.",
                                "Explicar teoremas de equivalência em termos próprios.",
                                "Identificar pelo menos 2 CFLs adicionais com PDAs.",
                                "Diferenciar NPDA de DPDA com contraexemplo.",
                                "Validar uma string inválida no NPDA."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de NPDA e GLC (sem erros lógicos).",
                                "Clareza nas explicações da equivalência teórica.",
                                "Profundidade nos exemplos e simulações práticas.",
                                "Correta identificação de propriedades e limitações de CFLs.",
                                "Criatividade em conexões com exemplos reais.",
                                "Completude das verificações e testes de borda."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos (estados como nós, transições como arestas).",
                                "Linguagens de Programação: Parsing de sintaxe em compiladores (ex: ANTLR usa ideias de PDAs).",
                                "Inteligência Artificial: Modelos de pilha em processamento de linguagem natural (ex: parsers recursivos).",
                                "Engenharia de Software: Validação de XML/JSON com estruturas aninhadas."
                              ],
                              "realWorldApplication": "Em compiladores, PDAs são base para parsers LL/LR que analisam código fonte (ex: verificar chaves balanceadas em C++ ou tags em HTML), permitindo detecção de erros de sintaxe em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Classificar gramáticas como tipo 2",
                            "description": "Analisar produções para verificar se atendem às restrições livres de contexto e gerar árvores de derivação para palavras em linguagens tipo 2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal de gramáticas livres de contexto (Tipo 2)",
                                  "subSteps": [
                                    "Estude a forma geral de uma gramática: G = (V, Σ, P, S), onde V são não-terminais, Σ terminais, P produções, S axioma.",
                                    "Memorize a restrição principal: Toda produção deve ser A → α, com A ∈ V (único não-terminal à esquerda) e α ∈ (V ∪ Σ)* (qualquer string à direita).",
                                    "Identifique exceções permitidas: ε-produções só do axioma ou A → ε com A não em chamadas de outras produções.",
                                    "Compare com tipos inferiores (3 e 4) para diferenciar: Tipo 3 é regular (A → aB ou A → a), Tipo 4 é finita.",
                                    "Anote exemplos canônicos de gramáticas tipo 2, como S → aSb | ε para {a^n b^n}."
                                  ],
                                  "verification": "Liste corretamente as 4 componentes de G e 3 restrições chave de produções tipo 2 sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser ou similar), notas de aula sobre Hierarquia de Chomsky.",
                                  "tips": "Use mnemônicos: 'A só à esquerda, α livre à direita'.",
                                  "learningObjective": "Compreender precisamente as regras formais que definem uma gramática tipo 2.",
                                  "commonMistakes": "Confundir com tipo 3 (permitir apenas terminais + um NT à direita); ignorar ε-produções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar todas as produções de uma gramática dada",
                                  "subSteps": [
                                    "Liste todas as produções da gramática fornecida em uma tabela: coluna 'Produção', 'Lado Esquerdo', 'Lado Direito'.",
                                    "Classifique cada lado esquerdo: deve ser EXATAMENTE um não-terminal (sem strings ou terminais).",
                                    "Para cada lado direito, verifique se é uma string arbitrária de terminais e não-terminais (pode ser vazia só em casos permitidos).",
                                    "Marque produções inválidas com razões específicas (ex: 'Dois NTs à esquerda' ou 'Terminal à esquerda').",
                                    "Conte o total de produções válidas vs. inválidas."
                                  ],
                                  "verification": "Tabela completa sem erros, com pelo menos 90% das produções corretamente classificadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel ou editor de texto para tabelas, exemplo de gramática impresso ou digital.",
                                  "tips": "Comece pelo axioma S e verifique recursivamente.",
                                  "learningObjective": "Desenvolver habilidade em decompor e inspecionar produções individuais.",
                                  "commonMistakes": "Permitir A → B C onde B e C são NTs à esquerda; confundir terminais maiúsculos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar restrições adicionais e classificar a gramática",
                                  "subSteps": [
                                    "Confirme que o axioma S não aparece no lado direito de nenhuma produção (ou só em contextos livres).",
                                    "Verifique ausência de produções circulares ou inutilizáveis que violem tipo 2.",
                                    "Se todas produções atendem A → α, classifique como 'Tipo 2'; senão, identifique tipo inferior possível.",
                                    "Documente a classificação final com justificativa textual.",
                                    "Teste com uma palavra simples: derive manualmente para validar."
                                  ],
                                  "verification": "Classificação correta com justificativa que cita todas produções problemáticas ou ok.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesma gramática, calculadora de derivações (opcional app ou software como JFLAP).",
                                  "tips": "Use seta ⇒ para derivar e visualizar restrições.",
                                  "learningObjective": "Aplicar regras holísticas para uma classificação precisa.",
                                  "commonMistakes": "Ignorar produções unitárias (A → B, válidas em tipo 2); classificar tipo 3 como 2 sem checar esquerda."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar árvores de derivação para palavras na linguagem tipo 2",
                                  "subSteps": [
                                    "Escolha uma palavra w ∈ L(G), ex: para G de {a^n b^n}, w = aabb.",
                                    "Inicie árvore com raiz S, aplique produções esquerda-mais ou mais profunda.",
                                    "Desenhe nós: não-terminais internos, folhas terminais formando w.",
                                    "Garanta que a árvore reflita apenas produções tipo 2 usadas.",
                                    "Valide: leitura das folhas dá w, sem violações."
                                  ],
                                  "verification": "Árvore desenhada corretamente gera w, com rótulos de produções.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado ou ferramenta como Draw.io, JFLAP para simulação.",
                                  "tips": "Árvores esquerda-derivadas evitam ambiguidades.",
                                  "learningObjective": "Visualizar e construir derivações canônicas para validação.",
                                  "commonMistakes": "Usar ordem errada de derivação; folhas não formam w exata."
                                }
                              ],
                              "practicalExample": "Gramática G: S → AB | a, A → aA | ε, B → bB | ε. Análise: Todas produções A → α (S→AB ok, etc.). Classificação: Tipo 2. Árvore para 'aabbb': S ⇒ AB ⇒ aA B ⇒ a ε B ⇒ a B ⇒ a bB ⇒ a b bB ⇒ a b b ε. Árvore: S / \\ A B /|\\ ε b / \\ b ε.",
                              "finalVerifications": [
                                "Todas produções listadas e validadas como A → α.",
                                "Classificação explícita: 'Tipo 2' ou 'Não tipo 2: razões'.",
                                "Árvore de derivação completa para pelo menos uma palavra w ∈ L(G).",
                                "Nenhuma produção viola restrições (esquerda único NT).",
                                "Derivação manual de w confirma geração correta.",
                                "Justificativa cobre axioma e ε-produções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de produções inválidas (100% corretas).",
                                "Qualidade da árvore de derivação (estrutura hierárquica clara, folhas = w).",
                                "Completude da análise (todas produções cobertas).",
                                "Correção da classificação final com evidências.",
                                "Clareza na documentação (tabelas, diagramas legíveis).",
                                "Tempo de execução dentro do estimado com acertos."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Análise sintática de frases naturais (árvores parse).",
                                "Programação: Parsers em compiladores (Yacc/Bison usam CFGs).",
                                "Matemática: Grafos e árvores para modelagem formal.",
                                "IA: Modelos de linguagem generativa (CFGs em PLN)."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens como C/Python, gramáticas tipo 2 definem sintaxe; classificação garante parse eficiente via pushdown automata, usado em ferramentas como ANTLR para análise de código fonte."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Gramáticas Sensíveis ao Contexto (Tipo 1)",
                        "description": "Restrições das gramáticas sensíveis ao contexto, onde |α| ≤ |β| em produções α → β (exceto S → ε), e correspondência com linguagens sensíveis ao contexto.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Especificar restrições de comprimento em produções tipo 1",
                            "description": "Definir a condição |α| ≤ |β| para produções α → β, com α contendo pelo menos um não-terminal, e exceções para o axioma inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Hierarquia de Chomsky e Gramáticas Tipo 1",
                                  "subSteps": [
                                    "Estude a Hierarquia de Chomsky: Tipos 0 (não restritas), 1 (sensíveis ao contexto), 2 (livres de contexto), 3 (regulares).",
                                    "Identifique as restrições principais de cada tipo, focando no Tipo 1.",
                                    "Defina gramática sensível ao contexto (CSG): G = (V, Σ, P, S) onde P são produções com restrições.",
                                    "Anote exemplos simples de cada tipo para comparação.",
                                    "Crie um diagrama mental ligando restrições a poder de geração de linguagens."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando o que diferencia CSG das outras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre Automata e Linguagens Formais",
                                    "Livro 'Introduction to Automata Theory' (cap. Chomsky)",
                                    "Vídeo Khan Academy ou similar sobre Hierarquia de Chomsky"
                                  ],
                                  "tips": [
                                    "Use mnemônicos: 'Tipo 1: Contexto Sensível, Comprimento Não Diminui'.",
                                    "Compare com Type 2 para fixar diferenças."
                                  ],
                                  "learningObjective": "Compreender o contexto das gramáticas Tipo 1 na hierarquia formal.",
                                  "commonMistakes": [
                                    "Confundir CSG com CFG (Type 2, sem restrição de comprimento)",
                                    "Ignorar que Type 0 é irrestrita",
                                    "Esquecer que S é o axioma inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Estrutura de Produções em Gramáticas Formais",
                                  "subSteps": [
                                    "Defina uma produção genérica: α → β, onde α e β são strings sobre V ∪ Σ.",
                                    "Explique os componentes: terminais (Σ), não-terminais (V), axioma S.",
                                    "Identifique que α deve conter pelo menos um não-terminal (exceto possivelmente para S).",
                                    "Pratique notação: escreva 3 exemplos de produções para diferentes tipos.",
                                    "Discuta o papel do contexto em CSG vs. outros tipos."
                                  ],
                                  "verification": "Construa 2 produções válidas para uma CSG simples e justifique.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Tabela comparativa de tipos de gramáticas"
                                  ],
                                  "tips": [
                                    "Sempre inclua pelo menos um NT em α para produções não-iniciais.",
                                    "Visualize α como 'contexto + NT + contexto'."
                                  ],
                                  "learningObjective": "Dominar a notação e requisitos básicos de produções em CSG.",
                                  "commonMistakes": [
                                    "Escrever α sem não-terminal",
                                    "Usar apenas terminais em α",
                                    "Confundir α (lado esquerdo) com β"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Restrição de Comprimento |α| ≤ |β|",
                                  "subSteps": [
                                    "Defina formalmente: para toda produção α → β (α ≠ S), |α| ≤ |β|.",
                                    "Meça comprimentos: |w| é o número de símbolos em w.",
                                    "Verifique exemplos: para α = AB → ABC, |α|=2 ≤ |β|=3 (válido).",
                                    "Identifique violações: α = A → ε (invalido em CSG).",
                                    "Pratique com 5 produções aleatórias, classificando como válidas ou não."
                                  ],
                                  "verification": "Analise uma lista de 5 produções e marque as que violam a regra.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exercícios impressos ou online de gramáticas formais",
                                    "Calculadora para contar símbolos"
                                  ],
                                  "tips": [
                                    "Conte símbolos incluindo contexto.",
                                    "Lembre: ε tem comprimento 0, então S → ε pode ser exceção."
                                  ],
                                  "learningObjective": "Aplicar corretamente a regra de não-contracão em produções.",
                                  "commonMistakes": [
                                    "Contar apenas não-terminais",
                                    "Permitir |α| > |β| achando que é 'expansão'",
                                    "Esquecer de medir |S| no axioma"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Tratar Exceções e Praticar Especificação Completa",
                                  "subSteps": [
                                    "Explique exceção: produções do axioma S podem ter |S| > |β| (raro, mas possível).",
                                    "Especifique uma CSG completa: defina V, Σ, P, S com restrições.",
                                    "Crie uma gramática para L = {a^n b^n c^n | n ≥ 1}, verificando regras.",
                                    "Teste derivações curtas e valide comprimentos em cada passo.",
                                    "Escreva regras para especificar restrições em um conjunto de produções dado."
                                  ],
                                  "verification": "Construa e valide uma CSG com 4-6 produções respeitando todas regras.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor LaTeX ou texto para gramáticas",
                                    "Exemplos de CSG online (Wikipedia)"
                                  ],
                                  "tips": [
                                    "Comece com S → abc para n=1.",
                                    "Verifique cada produção isoladamente primeiro."
                                  ],
                                  "learningObjective": "Especificar restrições de comprimento em CSG reais, incluindo exceções.",
                                  "commonMistakes": [
                                    "Aplicar |α| ≤ |β| ao axioma S",
                                    "Criar linguagens não-CS achando que são",
                                    "Esquecer NT em α"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática CSG para L = {a^n b^n c^n | n ≥ 1}: V = {S, A, B, C}, Σ = {a,b,c}, S → a S B C | a B C, A → a A | a, B → b B | b, C → c C | c. Verifique: Para S → a S B C, |α|=1 ≤ |β|=5; para A → a A, |α|=2 ≤ |β|=2 (igual ok). Todas satisfazem |α| ≤ |β| e α tem NT.",
                              "finalVerifications": [
                                "Explicar verbalmente a regra |α| ≤ |β| com exemplo.",
                                "Identificar e corrigir uma produção inválida em uma CSG dada.",
                                "Construir uma produção CSG válida para um contexto específico.",
                                "Diferenciar CSG de CFG usando restrição de comprimento.",
                                "Validar completamente uma gramática Tipo 1 com 5+ produções.",
                                "Discutir impacto da exceção do axioma S."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa da regra (30%)",
                                "Correta identificação de NT em α (20%)",
                                "Aplicação consistente de |α| ≤ |β| em exemplos (25%)",
                                "Tratamento adequado de exceções para S (15%)",
                                "Exemplos práticos e verificáveis (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Contagem de Símbolos (|w|).",
                                "Linguística: Análise Sintática e Dependências Contextuais.",
                                "Ciência da Computação: Parsing em Compiladores (Yacc/Bison).",
                                "Inteligência Artificial: Modelos de Linguagem em NLP."
                              ],
                              "realWorldApplication": "Em compiladores, gramáticas CSG modelam análises sintáticas complexas como em linguagens de programação com dependências contextuais (ex: C++ templates); em NLP, para parsing de frases com anáforas dependentes de contexto distante."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Exemplificar linguagens sensíveis ao contexto",
                            "description": "Citar exemplos como {a^n b^n c^n | n ≥ 1} e explicar por que não são livres de contexto, mas são sensíveis ao contexto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Hierarquia de Chomsky e diferenças entre linguagens livres de contexto e sensíveis ao contexto",
                                  "subSteps": [
                                    "Estude a Hierarquia de Chomsky: Type 0 (recursivamente enumeráveis), Type 1 (sensíveis ao contexto), Type 2 (livres de contexto), Type 3 (regulares).",
                                    "Compare regras de produção: Context-Free (Type 2) tem regras A → α onde A é não-terminal único; Context-Sensitive (Type 1) permite α → β onde |β| ≥ |α| e contexto ao redor.",
                                    "Revise o Teorema do Pumping Lemma para linguagens livres de contexto.",
                                    "Liste exemplos clássicos: {a^n b^n | n ≥ 0} é context-free; {a^n b^n c^n | n ≥ 1} não é.",
                                    "Anote as propriedades chave: context-free não 'conta' três ou mais coordenadas independentes."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre Type 1 e Type 2, citando pelo menos duas regras de exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser ou similar), notas de aula sobre Hierarquia de Chomsky, whiteboard ou papel para diagramas.",
                                  "tips": "Use diagramas de árvore de derivação para visualizar regras context-free vs. context-sensitive.",
                                  "learningObjective": "Compreender as diferenças fundamentais entre linguagens context-free e context-sensitive na Hierarquia de Chomsky.",
                                  "commonMistakes": "Confundir context-sensitive com context-free; esquecer que context-sensitive permite regras com contexto não-terminal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir e definir o exemplo de linguagem {a^n b^n c^n | n ≥ 1}",
                                  "subSteps": [
                                    "Defina formalmente L = {a^n b^n c^n | n ≥ 1}, gerando strings como 'abc', 'aabbcc', 'aaabbbccc'.",
                                    "Gere manualmente 5 strings na linguagem para n=1 a 5.",
                                    "Escreva uma gramática sensível ao contexto para L, como S → aSBC | aBC, CB → BC, aB → ab, bB → bb, bC → bc, cC → cc.",
                                    "Explique intuitivamente por que essa linguagem requer 'contagem coordenada' de três símbolos.",
                                    "Compare com {a^n b^n | n ≥ 1}, que é context-free."
                                  ],
                                  "verification": "Escreva a definição formal de L e gere 3 strings corretas; forneça uma gramática básica para ela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto ou papel para escrever strings e gramáticas, calculadora para contar símbolos.",
                                  "tips": "Sempre verifique se o número de a's = b's = c's para validar strings.",
                                  "learningObjective": "Definir precisamente a linguagem exemplo e gerar strings pertencentes a ela.",
                                  "commonMistakes": "Gerar strings inválidas como 'aabbbcc'; confundir com linguagens de dois símbolos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que {a^n b^n c^n | n ≥ 1} não é context-free usando Pumping Lemma",
                                  "subSteps": [
                                    "Enuncie o Pumping Lemma para CFL: Para L CFL, existe p tal que qualquer w em L com |w| ≥ p pode ser dividido em uvxyz com |vxy| ≤ p, |vy| ≥ 1, e uv^k x y^k z em L para todo k ≥ 0.",
                                    "Escolha w = a^p b^p c^p (com |w| ≥ p).",
                                    "Analise casos de divisão: vxy não pode abranger só a's (bomba b's/c's); só b's (bomba c's); etc. Mostre contradição em todos os 5 casos possíveis.",
                                    "Conclua que L não satisfaz o lemma, logo não é CFL.",
                                    "Teste com k=2 e k=0 para ilustrar violações."
                                  ],
                                  "verification": "Escreva a prova completa do Pumping Lemma para L, cobrindo todos os casos e mostrando contradição.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel ou ferramenta digital para diagramas de pumping, exemplos de provas online como referência (não copiar).",
                                  "tips": "Desenhe a string w e marque regiões v, x, y visualmente para cada caso.",
                                  "learningObjective": "Aplicar o Pumping Lemma para demonstrar que uma linguagem não é context-free.",
                                  "commonMistakes": "Ignorar um caso no pumping (ex: vxy cruzando duas regiões); errar a escolha de w."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar que {a^n b^n c^n | n ≥ 1} é sensível ao contexto",
                                  "subSteps": [
                                    "Revise definição de CSG: Regras α → β com |β| ≥ |α|, terminais e não-terminais permitidos.",
                                    "Forneça uma gramática CSG completa para L e derive 'aabbcc' passo a passo.",
                                    "Explique por que a gramática requer contexto (ex: mover B e C através dos a's).",
                                    "Discuta que L é aceita por Linear Bounded Automata (LBA), decisor da classe CS.",
                                    "Compare com linguagens regulares e CFL para reforçar posição na hierarquia."
                                  ],
                                  "verification": "Derive uma string como 'aaabbbccc' usando a gramática CSG fornecida, sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de simulação de gramáticas (opcional, como JFLAP), papel para derivações.",
                                  "tips": "Numere cada passo de derivação para rastrear facilmente.",
                                  "learningObjective": "Demonstrar que a linguagem é gerada por uma gramática sensível ao contexto.",
                                  "commonMistakes": "Escrever regras que violem |β| ≥ |α|; falhar em derivar strings corretamente."
                                }
                              ],
                              "practicalExample": "Considere implementar um validador simples em Python para strings em {a^n b^n c^n | n ≥ 1}: def is_abc_lang(s): counts = {'a':0, 'b':0, 'c':0}; for char in s: if char=='a': counts['a']+=1 elif char=='b' and counts['a']==counts['b']+len([c for c in s if c=='a']): wait, actually use stack or counter: split and check len(s.split('a'))-1 == len(s.split('b'))-1 == len(s.split('c'))-1 but properly. Run tests on 'abc' (true), 'aabbbcc' (false), explaining why parser needs context tracking beyond PDA.",
                              "finalVerifications": [
                                "Pode definir formalmente L = {a^n b^n c^n | n ≥ 1} e gerar 5 strings corretas.",
                                "Aplica corretamente o Pumping Lemma para provar que L não é CFL, cobrindo todos casos.",
                                "Fornece uma gramática CSG válida para L e deriva pelo menos uma string não-trivial.",
                                "Explica intuitivamente por que L requer sensibilidade ao contexto (contagem tripla).",
                                "Distingue L de exemplos CFL como {a^n b^n} e regulares como {a^*}.",
                                "Identifica erros comuns em provas de pumping."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e geração de strings (20%)",
                                "Correção na aplicação do Pumping Lemma (30%)",
                                "Validade da gramática CSG e derivação (25%)",
                                "Clareza na explicação das razões context-sensitive (15%)",
                                "Uso correto de terminologia da Hierarquia de Chomsky (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Indução para provar propriedades de linguagens.",
                                "Lógica e Filosofia: Conceitos de formalismo e limites da computação.",
                                "Programação: Parsers em compiladores que lidam com dependências contextuais.",
                                "Engenharia de Software: Modelagem de linguagens de configuração complexas."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores para linguagens de programação com estruturas aninhadas dependentes (ex: balanceamento de XML com atributos contextuais), ou validação de protocolos de rede que requerem contagens coordenadas de pacotes/headers/payloads, onde PDAs falham mas LBAs succeeds."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Verificar conformidade com tipo 1",
                            "description": "Avaliar se uma gramática dada satisfaz as restrições de comprimento e contexto, identificando violações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal de Gramática Sensível ao Contexto (Tipo 1)",
                                  "subSteps": [
                                    "Leia a definição padrão de CSG: produções α → β onde |α| ≤ |β|, α contém pelo menos um não-terminal no lado esquerdo.",
                                    "Identifique exceções permitidas: S → ε apenas se S não aparece em nenhum lado direito de outras produções.",
                                    "Revise componentes de uma gramática formal: V (não-terminais), Σ (terminais), P (produções), S (inicial).",
                                    "Anote as restrições chave em um papel ou ferramenta digital.",
                                    "Compare com outros tipos da hierarquia de Chomsky para diferenciar."
                                  ],
                                  "verification": "Liste corretamente as 3 principais restrições de CSG sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Notas de aula sobre Hierarquia de Chomsky",
                                    "Folha de papel ou editor de texto"
                                  ],
                                  "tips": "Use diagramas para visualizar LHS vs RHS em produções exemplo.",
                                  "learningObjective": "Dominar as regras exatas que definem uma gramática como Tipo 1.",
                                  "commonMistakes": "Confundir |α| ≤ |β| com |α| ≥ |β| ou ignorar a exigência de não-terminal em α."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a estrutura da gramática fornecida",
                                  "subSteps": [
                                    "Identifique o símbolo inicial S.",
                                    "Liste todos os não-terminais (V) e terminais (Σ).",
                                    "Enumere todas as produções em formato α → β.",
                                    "Marque cada produção com seus comprimentos: |α| e |β|.",
                                    "Verifique se há alguma produção com S → ε."
                                  ],
                                  "verification": "Crie uma tabela com todas as produções, seus comprimentos e componentes identificados corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gramática exemplo impressa ou digital",
                                    "Planilha Excel ou papel quadriculado para tabelas"
                                  ],
                                  "tips": "Padronize a notação: use → para separar LHS e RHS claramente.",
                                  "learningObjective": "Extrair e organizar todos os elementos da gramática de forma precisa.",
                                  "commonMistakes": "Omitir produções ou confundir terminais com não-terminais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar conformidade de comprimento e estrutura em cada produção",
                                  "subSteps": [
                                    "Para cada produção, calcule |α| e |β| e confira se |α| ≤ |β|.",
                                    "Verifique se α contém pelo menos um não-terminal (geralmente à esquerda).",
                                    "Se houver S → ε, cheque se S aparece em qualquer RHS de outras produções.",
                                    "Registre violações em uma lista separada.",
                                    "Confirme que não há produções vazias ou malformadas."
                                  ],
                                  "verification": "Marque cada produção como 'OK' ou 'Violação' com justificativa para todas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabela do Step 2",
                                    "Calculadora para contagem de símbolos"
                                  ],
                                  "tips": "Conte símbolos individualmente: cada letra ou ε conta como 1.",
                                  "learningObjective": "Aplicar regras de comprimento e não-terminal a produções individuais.",
                                  "commonMistakes": "Contar ε como 0 incorretamente ou permitir contrações em produções não-S."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a verificação global e documentar resultados",
                                  "subSteps": [
                                    "Some violações: se zero e exceções OK, é Tipo 1.",
                                    "Se houver violações, classifique o tipo (ex: Tipo 0 se |α| > |β|).",
                                    "Escreva um relatório resumido: conformidade sim/não e lista de problemas.",
                                    "Teste com uma produção alterada para validar entendimento.",
                                    "Revise todo o processo para consistência."
                                  ],
                                  "verification": "Produza um relatório final declarando conformidade com evidências.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Relatório do Step 3",
                                    "Editor de texto para relatório final"
                                  ],
                                  "tips": "Use bullet points no relatório para clareza.",
                                  "learningObjective": "Sintetizar análises em uma conclusão acionável.",
                                  "commonMistakes": "Ignorar exceções de S → ε ou declarar conformidade prematuramente."
                                }
                              ],
                              "practicalExample": "Gramática G: V={S,A,B}, Σ={a,b}, S inicial, P: S→aSAB|λ, AB→BA, aA→abA|ab. Verificação: S→λ (|S|=1 > |λ|=0, mas cheque se S em RHS? Não, OK exceção). Outras: |aSAB|=4 >=4, etc. Conclusão: CSG (exemplo de {a^n b^n c^n}).",
                              "finalVerifications": [
                                "Lista corretamente todas as restrições de CSG.",
                                "Identifica violações em 100% das produções de exemplo.",
                                "Explica exceções para S→ε adequadamente.",
                                "Classifica gramáticas corretamente como Tipo 1 ou não.",
                                "Produz relatório claro e sem erros lógicos.",
                                "Aplica verificação a gramática nova sem orientação."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas contagens de comprimento (100% correto).",
                                "Detecção completa de violações e exceções.",
                                "Clareza na documentação e justificativas.",
                                "Profundidade na análise de cada produção.",
                                "Capacidade de generalizar para novas gramáticas.",
                                "Ausência de confusões com outros tipos de Chomsky."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e relações em linguagens formais.",
                                "Programação: Implementação de verificadores em scripts Python para gramáticas.",
                                "Lógica: Provas formais e verificação de propriedades.",
                                "Engenharia de Software: Análise de especificações em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores e parsers para linguagens de programação com restrições contextuais (ex: verificação de balances em linguagens como C++ com macros), ou em modelagem de protocolos de rede com dependências de comprimento de mensagens."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.4",
                        "name": "Gramáticas Irrestritas (Tipo 0)",
                        "description": "Gramáticas sem restrições de forma, capazes de gerar linguagens recursivamente enumeráveis, reconhecidas por máquinas de Turing.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.4.1",
                            "name": "Caracterizar gramáticas tipo 0",
                            "description": "Descrever produções gerais α → β sem restrições de comprimento ou forma, e sua relação com modelos de computação universal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais das Gramáticas Tipo 0",
                                  "subSteps": [
                                    "Revise a hierarquia de Chomsky e posicione as gramáticas tipo 0 no topo.",
                                    "Defina formalmente uma gramática G = (V, Σ, P, S), destacando que V inclui variáveis e terminais.",
                                    "Explique que as produções não têm restrições de forma ou comprimento.",
                                    "Compare brevemente com tipos inferiores (1, 2, 3).",
                                    "Identifique que tipo 0 gera todas as linguagens recursivamente enumeráveis."
                                  ],
                                  "verification": "Escreva uma definição formal de gramática tipo 0 e liste 3 diferenças chave com tipo 3.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser ou Hopcroft), notas de aula sobre hierarquia de Chomsky.",
                                  "tips": "Use diagramas para visualizar a hierarquia como uma pirâmide.",
                                  "learningObjective": "Compreender a posição e definição básica das gramáticas tipo 0 na teoria formal.",
                                  "commonMistakes": "Confundir com gramáticas livres de contexto (tipo 2), que têm restrições α → β com |α| >= |β|."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever as Produções Gerais α → β",
                                  "subSteps": [
                                    "Defina α como string não-vazia sobre V ∪ Σ, com pelo menos uma variável.",
                                    "Defina β como qualquer string sobre V ∪ Σ (pode ser vazia).",
                                    "Escreva exemplos de produções válidas: S → aSb | ε, ou X → YZab.",
                                    "Explique a aplicação: substitua α por β em derivadas.",
                                    "Destaque que |α| pode ser <, = ou > |β|."
                                  ],
                                  "verification": "Gere 3 produções tipo 0 válidas e invalide uma produção tipo 2 como tipo 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta para anotar produções, simulador online de gramáticas formais.",
                                  "tips": "Sempre inclua pelo menos uma variável em α para evitar ambiguidades.",
                                  "learningObjective": "Dominar o formato exato das regras de produção sem restrições.",
                                  "commonMistakes": "Esquecer que α deve conter variáveis; produções puramente terminais não são permitidas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Ausência de Restrições e Poder Gerativo",
                                  "subSteps": [
                                    "Discuta como a falta de restrições permite simular qualquer computação.",
                                    "Analise exemplos de linguagens só geráveis por tipo 0, como {a^n b^n c^n | n ≥ 1}.",
                                    "Derive uma palavra usando produções gerais passo a passo.",
                                    "Compare poder com tipos inferiores: tipo 0 ⊇ tipo 1 ⊇ ...",
                                    "Introduza o conceito de linguagens RE (recursivamente enumeráveis)."
                                  ],
                                  "verification": "Construa uma derivada para w = aaabbbccc usando uma gramática tipo 0.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Exemplos de gramáticas do livro-texto, quadro branco para derivações.",
                                  "tips": "Comece derivações do símbolo inicial S e rastreie substituições.",
                                  "learningObjective": "Reconhecer o poder expressivo máximo das gramáticas tipo 0.",
                                  "commonMistakes": "Acreditar que toda linguagem é gerável por tipo 3; lembre-se das limitações inferiores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com Modelos de Computação Universal",
                                  "subSteps": [
                                    "Explique o teorema: L(G0) = linguagens aceitas por Máquinas de Turing (MT).",
                                    "Descreva como uma gramática tipo 0 simula uma MT via codificação.",
                                    "Discuta universalidade: MT universal simula qualquer MT, assim como G0 gera RE.",
                                    "Cite teoremas de Rice e undecidibilidade para linguagens RE.",
                                    "Conclua a equivalência formal entre G0 e MT.",
                                    "Dê um exemplo de codificação de MT em gramática tipo 0."
                                  ],
                                  "verification": "Escreva um parágrafo relacionando G0 com MT e cite um teorema chave.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Referências sobre Máquinas de Turing (Sipser Cap. 3-5), diagramas de equivalência.",
                                  "tips": "Pense em 'geração' como 'simulação de computação' para ligar os conceitos.",
                                  "learningObjective": "Estabelecer a conexão profunda entre gramáticas irrestritas e computação universal.",
                                  "commonMistakes": "Confundir RE com recursivas; RE são semi-decidíveis."
                                }
                              ],
                              "practicalExample": "Construa uma gramática tipo 0 para L = {a^n b^n c^n | n ≥ 1}: S → aSbc | abc. Derive 'aabbcc': S ⇒ aSbc ⇒ a(abc)bc ⇒ aabbcc. Isso não é possível em tipos inferiores devido às contagens desbalanceadas.",
                              "finalVerifications": [
                                "Defina corretamente o formato de produção α → β para tipo 0.",
                                "Forneça um exemplo de linguagem só gerável por tipo 0.",
                                "Explique a equivalência com linguagens RE e MT.",
                                "Identifique uma produção inválida para tipo 0.",
                                "Derive uma palavra simples usando produções gerais.",
                                "Discuta undecidibilidade relacionada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (α não-vazia com variável).",
                                "Correta ausência de restrições vs. tipos inferiores.",
                                "Exemplos válidos e derivações sem erros.",
                                "Conexão clara com MT e universalidade.",
                                "Profundidade na discussão de poder gerativo.",
                                "Uso correto de terminologia (RE, irrestrita)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e recursão.",
                                "Lógica: Teoremas de incompletude e undecidibilidade.",
                                "Programação: Simulação de linguagens Turing-completas em Python.",
                                "Filosofia da Computação: Limites da computação."
                              ],
                              "realWorldApplication": "Gramáticas tipo 0 modelam a expressividade total de linguagens de programação (Turing-complete como C++ ou Python), usadas em compiladores para parsing irrestrito e análise de programas que simulam qualquer algoritmo computável, como em verificadores de software ou simuladores universais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3"
                            ]
                          },
                          {
                            "id": "10.1.2.3.4.2",
                            "name": "Associar a máquinas de Turing",
                            "description": "Explicar a equivalência entre linguagens tipo 0 e linguagens recursivamente enumeráveis aceitas por máquinas de Turing, mencionando a tese de Church-Turing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Gramáticas Irrestritas (Tipo 0) e Linguagens Tipo 0",
                                  "subSteps": [
                                    "Defina gramática irrestrita: regras da forma α → β onde α e β são cadeias de símbolos, com pelo menos um não-terminal em α.",
                                    "Explique linguagens tipo 0: conjunto de todas as linguagens geradas por gramáticas irrestritas, sem restrições de forma.",
                                    "Compare com hierarquia de Chomsky: tipo 0 é o mais poderoso, inclui todos os tipos inferiores.",
                                    "Estude exemplos: linguagem {a^n b^n c^n | n ≥ 0}, que não é gerável por tipos inferiores.",
                                    "Pratique conversão de uma gramática irrestrita para forma padrão."
                                  ],
                                  "verification": "Escreva uma definição precisa e um exemplo de linguagem tipo 0 que não seja tipo 1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou Hopcroft)",
                                    "Notas de aula sobre Hierarquia de Chomsky",
                                    "Editor de texto para gramáticas"
                                  ],
                                  "tips": "Use diagramas para visualizar regras de produção irrestritas.",
                                  "learningObjective": "Compreender as características fundamentais das gramáticas tipo 0 e suas linguagens.",
                                  "commonMistakes": [
                                    "Confundir com gramáticas livres de contexto (tipo 2)",
                                    "Achar que tipo 0 tem restrições de forma",
                                    "Ignorar a necessidade de não-terminal em α"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Máquinas de Turing e Linguagens Recursivamente Enumeráveis",
                                  "subSteps": [
                                    "Descreva a máquina de Turing (MT): fita infinita, cabeça de leitura/escrita, estados, função de transição.",
                                    "Defina linguagens aceitas por MT: recursivamente enumeráveis (RE), onde há uma MT que para e aceita strings na linguagem.",
                                    "Diferencie RE de recursivas: RE não requer rejeição explícita para strings fora da linguagem.",
                                    "Exemplo: MT para {a^n b^n c^n}, simulando contadores na fita.",
                                    "Simule manualmente uma MT simples em papel."
                                  ],
                                  "verification": "Desenhe e simule uma MT que reconhece {ww | w em {0,1}*}.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulador online de MT (ex: Turing Machine Simulator)",
                                    "Papel e lápis para simulação manual",
                                    "Vídeos tutoriais sobre MT"
                                  ],
                                  "tips": "Comece com MTs determinísticas simples antes de nondeterminísticas.",
                                  "learningObjective": "Dominar o modelo formal da MT e o conceito de linguagens RE.",
                                  "commonMistakes": [
                                    "Confundir aceitação com halting",
                                    "Esquecer fita infinita bidirecional",
                                    "Misturar RE com decidíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Equivalência entre Linguagens Tipo 0 e RE",
                                  "subSteps": [
                                    "Teorema 1: Toda linguagem tipo 0 é RE (construa MT a partir de gramática tipo 0).",
                                    "Teorema 2: Toda RE é tipo 0 (construa gramática tipo 0 a partir de MT).",
                                    "Detalhe construção: para G → MT, use fita para derivar sentenças; para M → G, simule transições na fita.",
                                    "Prove informalmente usando simulações.",
                                    "Discuta implicações: hierarquia de Chomsky colapsa no topo com MTs."
                                  ],
                                  "verification": "Esboce as duas construções de prova em pseudocódigo ou diagramas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigo ou capítulo sobre teoremas de equivalência",
                                    "Ferramenta de desenho para diagramas de prova"
                                  ],
                                  "tips": "Visualize a fita da MT como simulando derivações da gramática.",
                                  "learningObjective": "Explicar e provar a equivalência formal entre tipo 0 e RE.",
                                  "commonMistakes": [
                                    "Inverter as direções da prova",
                                    "Ignorar loops infinitos em simulações",
                                    "Confundir geração com reconhecimento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar a Tese de Church-Turing",
                                  "subSteps": [
                                    "Defina tese de Church-Turing: todo algoritmo efetivo pode ser simulado por MT.",
                                    "Mencione modelos equivalentes: λ-cálculo, máquinas registradoras, etc.",
                                    "Discuta implicações: limites da computação (problema da parada).",
                                    "Relacione com tipo 0/RE: poder computacional máximo.",
                                    "Debata críticas filosóficas à tese."
                                  ],
                                  "verification": "Redija um parágrafo explicando a tese e sua relação com MTs.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Texto original de Church/Turing ou resumos",
                                    "Vídeos sobre história da computabilidade"
                                  ],
                                  "tips": "Ligue à prática: programação como simulação de MT.",
                                  "learningObjective": "Compreender a tese como ponte entre teoria e prática computacional.",
                                  "commonMistakes": [
                                    "Confundir tese com teorema",
                                    "Achar que prova limites práticos",
                                    "Ignorar caráter conjectural"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa uma MT que aceita a linguagem tipo 0 {a^n b^n c^n | n ≥ 0}: use a fita para marcar a's, copiar para b's e verificar c's, simulando a gramática irrestrita correspondente.",
                              "finalVerifications": [
                                "Defina corretamente linguagens tipo 0 e RE.",
                                "Explique as duas direções da equivalência com construções.",
                                "Mencione a tese de Church-Turing com precisão.",
                                "Simule uma MT para uma linguagem tipo 0 não-context-free.",
                                "Discuta por que tipo 0 = RE no topo da hierarquia."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e teoremas (exata vs. vaga).",
                                "Capacidade de esboçar provas de equivalência.",
                                "Compreensão da tese como hipótese fundamental.",
                                "Uso correto de terminologia (RE vs. recursiva).",
                                "Aplicação em exemplos concretos.",
                                "Identificação de linguagens exclusivas do tipo 0."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e recursão.",
                                "Filosofia: Natureza da mente e computação (Turing Test).",
                                "Lógica: Teoremas de incompletude de Gödel.",
                                "Engenharia de Software: Limites de verificação automática."
                              ],
                              "realWorldApplication": "Fundamenta a teoria da computabilidade, explicando por que certos problemas (ex: halting problem) são indecidíveis, impactando compiladores, verificadores de software e IA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.4.3",
                            "name": "Compreender a hierarquia completa",
                            "description": "Resumir a inclusão estrita entre tipos (Tipo 3 ⊂ Tipo 2 ⊂ Tipo 1 ⊂ Tipo 0) e propriedades como closure e decidibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições básicas da Hierarquia de Chomsky",
                                  "subSteps": [
                                    "Estude as quatro classes de gramáticas: Tipo 0 (irrestritas), Tipo 1 (sensíveis ao contexto), Tipo 2 (independentes do contexto) e Tipo 3 (regulares).",
                                    "Identifique as formas gerais de produção para cada tipo: α → β onde |α| ≤ |β| para Tipo 1, A → γ para Tipo 2, A → aB ou A → a para Tipo 3.",
                                    "Ligue cada tipo à classe de linguagens correspondente: recursivamente enumeráveis (T0), contextuais (T1), livres de contexto (T2), regulares (T3).",
                                    "Anote exemplos clássicos: {a^n b^n c^n | n ≥ 0} para T1, {a^n b^n | n ≥ 0} para T2, (ab)* para T3.",
                                    "Crie um quadro comparativo inicial das restrições sintáticas."
                                  ],
                                  "verification": "Capacidade de listar corretamente as formas de produção e exemplos para cada tipo sem consultar notas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Teoria da Computação (ex: Sipser), notas de aula, quadro branco ou papel.",
                                  "tips": "Use mnemônicos como 'T3 mais restrito, T0 mais poderoso' para lembrar a ordem.",
                                  "learningObjective": "Dominar as definições formais e exemplos representativos de cada nível da hierarquia.",
                                  "commonMistakes": "Confundir formas de produção, como achar que T2 permite variáveis no lado esquerdo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender as inclusões estritas entre classes",
                                  "subSteps": [
                                    "Demonstre matematicamente que toda gramática T3 gera uma linguagem T3 ⊂ T2, provando que autômatos finitos simulam gramáticas regulares.",
                                    "Mostre T2 ⊂ T1 via teorema de normalização de Chomsky para gramáticas livres de contexto.",
                                    "Prove T1 ⊂ T0 observando que T1 são um subconjunto de gramáticas irrestritas com restrição |α| ≤ |β|.",
                                    "Estude teoremas de inclusão estrita: existem linguagens em T(n) não geráveis por T(n+1), como {a^n b^n c^n} em T1 mas não T2.",
                                    "Desenhe um diagrama de Venn ou setas ⊂ representando T3 ⊂ T2 ⊂ T1 ⊂ T0."
                                  ],
                                  "verification": "Desenhar e explicar o diagrama de inclusão com pelo menos um contraexemplo para cada não-inclusão reversa.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel para diagramas, calculadora simbólica ou software como LaTeX para sets, referências teóricas online (Wikipedia Hierarquia de Chomsky).",
                                  "tips": "Lembre-se: a seta ⊂ indica 'é subconjunto estrito', significando poder expressivo crescente de T0 para T3.",
                                  "learningObjective": "Entender e provar as relações de inclusão estrita entre as classes de linguagens.",
                                  "commonMistakes": "Ignorar a estrita inclusão, achando que T3 = T2; sempre teste com linguagens não-regulares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar propriedades de closure e decidibilidade",
                                  "subSteps": [
                                    "Liste operações de closure: união, concatenação, estrela de Kleene – T3 é fechada sob todas; T2 sob união e concatenação mas não inversa de homomorfismo.",
                                    "Estude decidibilidade: para T3, todas as propriedades (vazia, finitas, etc.) são decidíveis; para T0, só problemas como 'aceita alguma string' é semi-decidível.",
                                    "Compare tabelas: T3/T2 decidem pertencência; T1/T0 não decidem halting para MT.",
                                    "Exemplo: L = {a^n b^n | n ≥ 0} é T2, fechada sob união com outra T2, mas verifique decidibilidade de ∅(L).",
                                    "Crie uma tabela resumida de closure e decidibilidade por tipo."
                                  ],
                                  "verification": "Preencher corretamente uma tabela de propriedades sem erros para os 4 tipos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabelas impressas vazias, livro de referência (Hopcroft/Ullman), simulador de autômatos online.",
                                  "tips": "Agrupe: classes regulares/livres de contexto têm mais closures; classes poderosas perdem decidibilidade.",
                                  "learningObjective": "Mapear precisamente as propriedades de closure sob operações e problemas decidíveis por classe.",
                                  "commonMistakes": "Confundir closure de T2: é fechada sob reverso, mas não sob interseção com regulares? Não, é fechada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resumir e integrar a hierarquia completa",
                                  "subSteps": [
                                    "Sintetize um resumo em 1 parágrafo: inclusões, poder crescente, trade-offs em closure/decidibilidade.",
                                    "Crie um mapa mental conectando tipos, linguagens, autômatos (FA, PDA, TM) e propriedades.",
                                    "Resolva exercícios: classifique linguagens dadas e justifique posição na hierarquia.",
                                    "Discuta implicações: por que T2 é prática para compiladores apesar de limitações.",
                                    "Auto-teste com flashcards de inclusões e propriedades."
                                  ],
                                  "verification": "Escrever um resumo coerente e responder 5 perguntas de auto-teste corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Flashcards digitais (Anki), mapa mental software (MindMeister), exercícios de livro-texto.",
                                  "tips": "Use analogia: T3 como 'lego simples', T0 como 'qualquer construção possível'.",
                                  "learningObjective": "Integrar todo o conhecimento em um resumo holístico da hierarquia.",
                                  "commonMistakes": "Esquecer decidibilidade de 'linguagem universal' só para T3/T2."
                                }
                              ],
                              "practicalExample": "Classifique a linguagem L = { ww | w ∈ {a,b}* } na hierarquia: prove que é T1 (não T2 via pumping lemma), mostre inclusão em T0, e verifique closure sob união com {a^n b^n}. Desenhe diagrama e discuta se 'w ∈ L?' é decidível (não para T1).",
                              "finalVerifications": [
                                "Desenhar corretamente o diagrama de inclusão T3 ⊂ T2 ⊂ T1 ⊂ T0 com exemplos exclusivos.",
                                "Listar 3 propriedades de closure únicas para T3 vs. T0.",
                                "Explicar por que pertencência a linguagens T3 é decidível, mas para T0 não.",
                                "Classificar 3 linguagens dadas em tipos corretos com justificativa.",
                                "Resumir trade-off: poder vs. analisabilidade em uma frase.",
                                "Identificar autômatos correspondentes: FA para T3, TM para T0."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas inclusões estritas e contraexemplos (30%).",
                                "Completude na tabela de closure/decidibilidade (25%).",
                                "Clareza no diagrama e resumo integrado (20%).",
                                "Uso correto de teoremas (pumping, normalização) (15%).",
                                "Exemplos relevantes e práticos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos (inclusões estritas ⊂) e lógica formal.",
                                "Lógica: Decidibilidade relaciona-se ao problema da parada de Turing.",
                                "Engenharia de Software: Parsing em compiladores usa T2 (LL/LR).",
                                "Filosofia: Limites da computação (Gödel, Church-Turing)."
                              ],
                              "realWorldApplication": "Em compiladores, gramáticas T2 (livres de contexto) são usadas para parsers sintáticos eficientes; entender a hierarquia guia escolhas entre expressividade (T0 para scripts dinâmicos) e eficiência/decidibilidade (T3 para lexers), impactando design de linguagens como Python vs. regex em buscas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Linguagens Regulares",
                    "description": "Linguagens tipo-3, expressões regulares e propriedades dos conjuntos regulares.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Linguagens Tipo-3",
                        "description": "Definição e características das linguagens regulares na hierarquia de Chomsky tipo-3, incluindo sua correspondência com gramáticas regulares e autômatos finitos determinísticos (AFD).",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Identificar linguagens regulares",
                            "description": "Dado um conjunto de palavras, determinar se ele pertence à classe de linguagens regulares com base na hierarquia de Chomsky e exemplos clássicos como (a|b)* ou a* b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Hierarquia de Chomsky e Definição de Linguagens Regulares",
                                  "subSteps": [
                                    "Liste os quatro tipos da hierarquia de Chomsky (Tipo 0 a Tipo 3) e suas características principais.",
                                    "Identifique que linguagens regulares são do Tipo 3, reconhecidas por autômatos finitos determinísticos (AFD).",
                                    "Estude exemplos clássicos de linguagens regulares, como (a|b)* e a* b.",
                                    "Compare com linguagens de tipos superiores, como {a^n b^n | n ≥ 0} (Tipo 2).",
                                    "Anote propriedades chave: fechamento sob união, concatenação, estrela de Kleene."
                                  ],
                                  "verification": "Recite a hierarquia corretamente e forneça um exemplo de linguagem regular e uma não-regular.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre teoria da computação",
                                    "Livro 'Introduction to Automata Theory' de Hopcroft",
                                    "Vídeo tutorial sobre hierarquia de Chomsky"
                                  ],
                                  "tips": "Use mnemônicos como 'Recursivo > Context-Sensitive > Context-Free > Regular' para lembrar a ordem.",
                                  "learningObjective": "Compreender a posição das linguagens regulares na hierarquia de Chomsky e suas propriedades básicas.",
                                  "commonMistakes": [
                                    "Confundir linguagens regulares com context-free",
                                    "Esquecer que regulares são o tipo mais restrito (Tipo 3)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer Padrões e Construções de Linguagens Regulares",
                                  "subSteps": [
                                    "Analise expressões regulares (ER) como (a|b)* ou a* b e converta para AFD.",
                                    "Identifique linguagens com contagens finitas de memória, como alternância de símbolos ou repetições limitadas.",
                                    "Pratique convertendo descrições informais em ER ou AFD para confirmar regularidade.",
                                    "Verifique fechamento: se L1 e L2 regulares, então L1 ∪ L2, L1 L2, L1* também são.",
                                    "Teste com exemplos simples: L = {a, aa, aaa} é regular?"
                                  ],
                                  "verification": "Construa um AFD ou ER para uma linguagem dada e explique por quê é regular.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online JFLAP para simular AFD",
                                    "Papel e lápis para desenhar autômatos",
                                    "Lista de 10 expressões regulares clássicas"
                                  ],
                                  "tips": "Sempre comece tentando escrever uma ER; se conseguir, é um forte indício de regularidade.",
                                  "learningObjective": "Habilidade para reconhecer e construir provas de regularidade via ER ou AFD.",
                                  "commonMistakes": [
                                    "Assumir que contagens ilimitadas de símbolos iguais são regulares",
                                    "Ignorar estados finitos nos autômatos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Lema de Bombeamento para Identificar Não-Regulares",
                                  "subSteps": [
                                    "Estude o enunciado do Lema de Bombeamento: para L regular, existe p tal que qualquer w ∈ L com |w| ≥ p pode ser dividido em xyz com |xy| ≤ p, |y| ≥ 1, e xy^i z ∈ L para todo i ≥ 0.",
                                    "Aplique a um exemplo não-regular: L = {a^n b^n | n ≥ 0}, assuma regular e encontre contradição bombeando y.",
                                    "Pratique com outros: {ww | w ∈ {a,b}*} ou {a^n b^n c^n}.",
                                    "Diferencie de Myhill-Nerode: distinção infinita de prefixos implica não-regular.",
                                    "Registre passos: assumir regular, escolher w, dividir, mostrar xy^i z ∉ L para algum i."
                                  ],
                                  "verification": "Prove que {a^n b^n | n ≥ 0} não é regular usando o lema, mostrando a contradição explicitamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de exercícios com 5 linguagens candidatas",
                                    "Vídeo explicativo do pumping lemma",
                                    "Simulador online de pumping lemma"
                                  ],
                                  "tips": "Escolha w com comprimento logo acima de p e bombeie para quebrar a igualdade de contagens.",
                                  "learningObjective": "Dominar o uso do pumping lemma para provar que uma linguagem não é regular.",
                                  "commonMistakes": [
                                    "Escolher y que não quebra a propriedade",
                                    "Esquecer de verificar |xy| ≤ p"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Conjuntos de Exemplos Mistos",
                                  "subSteps": [
                                    "Classifique 10 linguagens: 5 regulares e 5 não-regulares, justificando cada uma.",
                                    "Para regulares, forneça ER ou esboce AFD; para não-regulares, aplique pumping lemma.",
                                    "Analise linguagens ambíguas como {a^i | i par} (regular) vs. {a^n b^n c^m | n,m ≥ 0} (regular por separação).",
                                    "Revise erros anteriores e reclassifique.",
                                    "Crie sua própria linguagem e teste com um colega ou autoavaliação."
                                  ],
                                  "verification": "Classifique corretamente um conjunto de 8 linguagens com justificativas completas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de exercícios impressa ou digital com soluções ocultas",
                                    "Timer para simular exame",
                                    "Fórum online para discutir dúvidas"
                                  ],
                                  "tips": "Sempre pergunte: 'Precisa de memória ilimitada?' Se sim, provavelmente não-regular.",
                                  "learningObjective": "Aplicar conhecimentos para identificar rapidamente se uma linguagem é regular em contextos variados.",
                                  "commonMistakes": [
                                    "Classificar erroneamente linguagens com dependências de contagem igual como regulares",
                                    "Não justificar adequadamente as provas"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado o conjunto L = {a^n b^n | n ≥ 0}, determine se é regular. Passos: Assuma regular com constante de bombeamento p. Escolha w = a^p b^p (|w| ≥ p). Divida em xyz com |xy| ≤ p, |y| ≥ 1. Como xy está só em a's, bombeie i=2: mais a's que b's, então xy^2 z ∉ L. Contradição: L não é regular.",
                              "finalVerifications": [
                                "Classificar corretamente (a|b)* como regular com ER equivalente.",
                                "Provar {a^n b^n | n ≥ 0} não-regular via pumping lemma.",
                                "Construir AFD para L = {w | número de a's par}.",
                                "Identificar {ww | w ∈ {a,b}*} como não-regular.",
                                "Explicar fechamento sob união com exemplos.",
                                "Diferenciar hierarquia: dar exemplo Tipo 2 não-Tipo 3."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação (correta para todos os exemplos testados).",
                                "Justificativa completa: ER/AFD para regulares, pumping lemma rigoroso para não-regulares.",
                                "Uso correto da hierarquia de Chomsky em argumentos.",
                                "Clareza na escrita de provas e diagramas de autômatos.",
                                "Identificação de erros comuns e correções.",
                                "Criatividade em exemplos originais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria dos conjuntos e relações de equivalência (Myhill-Nerode).",
                                "Lógica e Prova: Construção de provas por contradição no pumping lemma.",
                                "Programação: Uso de expressões regulares em linguagens como Python (re module).",
                                "Algoritmos: Análise de complexidade em autômatos finitos.",
                                "Linguística Computacional: Modelagem de padrões linguísticos simples."
                              ],
                              "realWorldApplication": "Em compiladores, análise léxica usa AFD para tokenizar código-fonte (ex: identificar identificadores como [a-zA-Z][a-zA-Z0-9]*). Em motores de busca, regex para matching de padrões em queries. Validação de formatos como emails ou URLs em aplicações web."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Reconhecer gramáticas regulares",
                            "description": "Analisar uma gramática formal para verificar se ela é do tipo-3, identificando regras de produção restritas à forma A → aB ou A → a, onde A e B são não-terminais e a é terminal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os componentes básicos de uma gramática formal",
                                  "subSteps": [
                                    "Identifique os quatro componentes de uma gramática formal: alfabeto de terminais (Vt), alfabeto de não-terminais (Vn), conjunto de regras de produção (P) e símbolo inicial (S).",
                                    "Liste exemplos de terminais (símbolos como 'a', 'b') e não-terminais (variáveis como S, A, B).",
                                    "Escreva a notação padrão G = (Vn, Vt, P, S).",
                                    "Diferencie lado esquerdo (sempre não-terminal) e lado direito das regras.",
                                    "Pratique decompondo uma gramática simples em seus componentes."
                                  ],
                                  "verification": "Construa uma gramática simples e rotule corretamente todos os componentes em um papel ou editor de texto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto; referência de livro sobre linguagens formais (ex: 'Introduction to Automata Theory' de Hopcroft).",
                                  "tips": "Use cores diferentes para terminais (azul) e não-terminais (vermelho) ao diagramar.",
                                  "learningObjective": "Compreender a estrutura fundamental de gramáticas formais para análise posterior.",
                                  "commonMistakes": "Confundir terminais com não-terminais; esquecer que o símbolo inicial deve ser um não-terminal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar as regras específicas de gramáticas regulares (Tipo-3)",
                                  "subSteps": [
                                    "Estude a definição: regras na forma A → aB ou A → a, onde A e B são não-terminais, a é terminal.",
                                    "Note que o lado direito tem exatamente um terminal seguido opcionalmente por um não-terminal à direita.",
                                    "Compare com formas proibidas: A → Ba (não-terminal à esquerda do terminal), A → BC (dois não-terminais), A → ε (vazio, exceto possivelmente para S em contextos limitados).",
                                    "Crie flashcards com exemplos válidos e inválidos.",
                                    "Repita a regra verbalmente 5 vezes para fixação."
                                  ],
                                  "verification": "Escreva de memória as duas formas permitidas e liste 3 exemplos inválidos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Flashcards (app como Anki) ou papel; tabela de Chomsky hierarchy.",
                                  "tips": "Lembre-se: 'direita-linear' – terminais vêm primeiro, depois no máximo um não-terminal.",
                                  "learningObjective": "Internalizar as restrições exatas das produções em gramáticas regulares.",
                                  "commonMistakes": "Permitir regras como A → aBb ou A → AB, que são para tipos inferiores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar os componentes de uma gramática dada",
                                  "subSteps": [
                                    "Extraia Vn, Vt, P e S da gramática fornecida.",
                                    "Liste todas as regras de produção numeradas.",
                                    "Classifique cada símbolo em cada regra como terminal ou não-terminal.",
                                    "Verifique se o lado esquerdo de todas as regras é um não-terminal único.",
                                    "Anote qualquer regra que pareça suspeita imediatamente."
                                  ],
                                  "verification": "Crie uma tabela com colunas: Regra #, Lado Esquerdo (Tipo), Lado Direito (Análise).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gramática exemplo impressa ou digital; planilha (Google Sheets ou papel).",
                                  "tips": "Comece sempre pelo símbolo inicial S e trabalhe para baixo na lista de regras.",
                                  "learningObjective": "Desenvolver habilidade em decompor gramáticas para inspeção.",
                                  "commonMistakes": "Ignorar regras recursivas ou múltiplas produções para o mesmo não-terminal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar conformidade de cada regra e concluir",
                                  "subSteps": [
                                    "Para cada regra, cheque se matches A → aB ou A → a exatamente.",
                                    "Marque regras inválidas e explique por quê (ex: 'não-terminal à esquerda de terminal').",
                                    "Confirme que todas as regras são válidas; se uma falhar, a gramática não é regular.",
                                    "Teste com derivações curtas para validar intuitivamente.",
                                    "Escreva uma declaração final: 'É/ Não é gramática regular porque...'."
                                  ],
                                  "verification": "Produza um relatório curto listando status de cada regra e conclusão geral.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesma gramática e tabela do step 3; timer para simular exame.",
                                  "tips": "Use regex mental: lado direito deve ser ^[a-z][A-Z]?$ (simplificado).",
                                  "learningObjective": "Aplicar critérios para classificar gramáticas com precisão.",
                                  "commonMistakes": "Aceitar regras como A → λ (vazio) sem contexto; confundir com Tipo-2."
                                }
                              ],
                              "practicalExample": "Gramática G = ({S, A}, {0,1}, P, S) onde P: S → 0S | 0A | 1, A → 1A | 1. Análise: Todas regras são S → 0S (válida), S → 0A (válida), S → 1 (válida), A → 1A (válida), A → 1 (válida). Conclusão: É gramática regular (gera strings terminando em 1 após zeros). Contraexemplo inválido: S → 1S (inválido, pois 1S tem terminal seguido de não-terminal à direita errada? Espera, 1S é a1 com a=1, B=S? Não: forma é aB onde a terminal, B NT à direita. 1S é válido! Erro: contraexemplo S → S1 (inválido, NT à direita de terminal).",
                              "finalVerifications": [
                                "Lista corretamente todos os componentes (Vn, Vt, P, S).",
                                "Identifica todas as regras inválidas com explicação precisa.",
                                "Conclui corretamente se a gramática é regular ou não.",
                                "Explica pelo menos uma derivação válida usando as regras.",
                                "Distingue entre formas permitidas e proibidas em exemplos.",
                                "Aplica o critério a uma gramática não fornecida previamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de terminais vs. não-terminais (100%).",
                                "Correta classificação de cada regra (sem falsos positivos/negativos).",
                                "Explicações claras e referenciadas à definição formal.",
                                "Uso consistente da notação G = (Vn, Vt, P, S).",
                                "Capacidade de generalizar para novas gramáticas.",
                                "Ausência de erros comuns como permitir regras bi-lineares."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equivalente a autômatos finitos determinísticos (AFDs).",
                                "Programação: Reconhecimento de padrões em expressões regulares (regex).",
                                "Lógica: Análise de estruturas formais semelhantes a provas por casos.",
                                "Engenharia de Software: Fase de análise léxica em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, gramáticas regulares são usadas na análise léxica para tokenizar código-fonte (ex: identificar identificadores, números em linguagens como Python), permitindo scanners eficientes baseados em AFDs para processar grandes volumes de código em tempo real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Relacionar linguagens tipo-3 com autômatos",
                            "description": "Explicar a equivalência entre linguagens reconhecidas por AFD e geradas por gramáticas regulares, com exemplos de conversão básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Linguagens Regulares e AFD",
                                  "subSteps": [
                                    "Defina linguagens regulares como linguagens tipo-3 na hierarquia de Chomsky.",
                                    "Explique a estrutura de uma gramática regular (produções do tipo A → aB ou A → a).",
                                    "Descreva o funcionamento de um Autômato Finito Determinístico (AFD), incluindo estados, alfabeto, função de transição, estado inicial e estados finais.",
                                    "Identifique as linguagens reconhecidas por AFD como exatamente as linguagens regulares."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos e forneça um diagrama simples de AFD.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introdução à Teoria da Computação' de Sipser; slides online sobre linguagens formais.",
                                  "tips": "Use diagramas visuais para representar AFD para melhor compreensão.",
                                  "learningObjective": "Compreender as definições básicas e preparar o terreno para a equivalência.",
                                  "commonMistakes": "Confundir gramáticas regulares com gramáticas livres de contexto; ignorar estados finais em AFD."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Teorema de Equivalência de Kleene",
                                  "subSteps": [
                                    "Enuncie o teorema: Uma linguagem é regular se e somente se é reconhecida por um AFD.",
                                    "Discuta as direções da prova: gramática regular gera linguagem reconhecida por AFD, e vice-versa.",
                                    "Analise intuitivamente por que expressões regulares, gramáticas regulares e AFD são equivalentes.",
                                    "Resolva exercícios simples de identificação de linguagens regulares.",
                                    "Compare com linguagens não-regulares para contrastar."
                                  ],
                                  "verification": "Escreva o teorema e explique cada direção em suas próprias palavras.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Notas de aula sobre Teoria da Computação; vídeo Khan Academy ou YouTube sobre Kleene.",
                                  "tips": "Memorize as três formas equivalentes: regex, gramática regular, AFD.",
                                  "learningObjective": "Dominar a base teórica da equivalência entre linguagens tipo-3 e autômatos.",
                                  "commonMistakes": "Acreditar que toda linguagem de AFD é gerada por gramática regular sem prova; pular a intuição."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender Conversão de Gramática Regular para AFD",
                                  "subSteps": [
                                    "Construa o conjunto de estados como variáveis não-terminais da gramática.",
                                    "Defina a função de transição baseada nas produções (A → aB leva a δ(A, a) = B).",
                                    "Identifique o estado inicial como a variável inicial da gramática.",
                                    "Marque estados finais como variáveis que produzem ε ou terminais.",
                                    "Teste a construção com uma gramática simples."
                                  ],
                                  "verification": "Converta uma gramática regular dada em um AFD e simule uma palavra na linguagem.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": "Papel e lápis para diagramas; simulador online de autômatos como JFLAP.",
                                  "tips": "Comece com gramáticas lineares à direita para simplicidade.",
                                  "learningObjective": "Capacitar-se a construir AFD a partir de gramáticas regulares.",
                                  "commonMistakes": "Esquecer transições para terminais; não tratar produções ε adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aprender Conversão de AFD para Gramática Regular",
                                  "subSteps": [
                                    "Crie variáveis para cada estado do AFD.",
                                    "Defina produções: para cada transição δ(q, a) = p, adicione q → a p.",
                                    "Estado inicial como variável inicial; estados finais com produção para ε.",
                                    "Elimine variáveis desnecessárias se houver.",
                                    "Valide convertendo de volta para AFD."
                                  ],
                                  "verification": "Converta um AFD simples em gramática regular e gere uma palavra derivada.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": "JFLAP ou papel para construções; exemplos de livros-texto.",
                                  "tips": "Use estados nomeados como variáveis para clareza.",
                                  "learningObjective": "Realizar conversões bidirecionais com precisão.",
                                  "commonMistakes": "Produzir gramática não-regular ao adicionar regras erradas; confundir estados finais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar com Exemplos e Verificações",
                                  "subSteps": [
                                    "Escolha uma linguagem regular simples (ex: (ab)*) e converta em ambos os sentidos.",
                                    "Resolva 3-5 exercícios variados de conversão.",
                                    "Compare construções manuais com ferramentas automáticas.",
                                    "Discuta limitações e casos especiais como linguagens vazias.",
                                    "Crie seu próprio exemplo e teste."
                                  ],
                                  "verification": "Documente 2 conversões completas com diagramas e derivações.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Exercícios online (ex: Rosetta Code); JFLAP.",
                                  "tips": "Pratique com linguagens sobre alfabeto {0,1} para padrões binários.",
                                  "learningObjective": "Aplicar conhecimentos em cenários práticos para consolidação.",
                                  "commonMistakes": "Não validar a equivalência simulando palavras; usar exemplos muito complexos inicialmente."
                                }
                              ],
                              "practicalExample": "Considere a gramática regular G: S → aS | bA | ε, A → aA | ε. Converta para AFD: Estados {S, A}, inicial S, finais {S, A}. Transições: δ(S,a)=S, δ(S,b)=A, δ(A,a)=A. Simule palavra 'aba': S -a→ S -b→ A -a→ A (aceita). Inversamente, do AFD gera a mesma gramática.",
                              "finalVerifications": [
                                "Construir corretamente AFD de uma gramática regular dada.",
                                "Gerar gramática regular equivalente de um AFD.",
                                "Simular aceitação/rejeição de palavras em ambos os modelos.",
                                "Explicar o teorema de equivalência sem erros.",
                                "Identificar erros comuns em conversões de pares de exemplos.",
                                "Criar um exemplo original e validar equivalência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de estados e transições (90% correto).",
                                "Correta identificação de estados iniciais/finais.",
                                "Validação por simulação de pelo menos 3 palavras por modelo.",
                                "Explicação clara do teorema e direções da prova.",
                                "Criatividade em exemplos originais com validação.",
                                "Tempo de execução eficiente das conversões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (AFD como grafo direcionado).",
                                "Programação: Implementação de parsers em compiladores (flex/lexer).",
                                "Lógica: Autômatos como modelos computacionais finitos.",
                                "Engenharia de Software: Análise de padrões regulares em expressões regulares."
                              ],
                              "realWorldApplication": "Em compiladores, lexers usam regex (equivalentes a AFD) para tokenização de código-fonte; validação de padrões em ferramentas como grep ou editores de texto; processamento de logs e filtros em sistemas de segurança cibernética."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Expressões Regulares",
                        "description": "Formalização matemática de expressões regulares como uma notação concisa para descrever linguagens regulares, incluindo operações de união, concatenação e estrela de Kleene.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Construir expressões regulares simples",
                            "description": "Dado um alfabeto e uma descrição linguística, criar uma expressão regular equivalente, como para o conjunto de todas as strings com número par de a's.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os elementos básicos das expressões regulares",
                                  "subSteps": [
                                    "Identifique o alfabeto Σ fornecido no problema.",
                                    "Liste os símbolos básicos: letras do alfabeto (a, b), ε (string vazia), φ (linguagem vazia).",
                                    "Revise as operações: união (R|S), concatenação (RS), estrela de Kleene (R*).",
                                    "Estude a precedência: * tem maior precedência que concatenação, que tem maior que união.",
                                    "Pratique notação com parênteses para agrupar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito cada operação com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Tabela de operações de expressões regulares (impressa ou digital)"
                                  ],
                                  "tips": "Use parênteses sempre que houver dúvida sobre precedência para evitar ambiguidades.",
                                  "learningObjective": "Dominar os blocos fundamentais para construir expressões regulares complexas.",
                                  "commonMistakes": [
                                    "Confundir união (|) com concatenação (sequência)",
                                    "Esquecer que ε gera a string vazia",
                                    "Ignorar precedência das operações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a descrição linguística do conjunto de strings",
                                  "subSteps": [
                                    "Leia a descrição e identifique as restrições principais (ex: número par de 'a').",
                                    "Quebre o problema em componentes: strings aceitas vs. rejeitadas.",
                                    "Pense em padrões repetitivos ou estados (ex: paridade de 'a' como par/ímpar).",
                                    "Gere 3 exemplos de strings que pertencem ao conjunto e 3 que não pertencem.",
                                    "Desenhe um diagrama simples de AFD equivalente para visualizar a estrutura."
                                  ],
                                  "verification": "Liste exemplos aceitos/rejeitados e justifique por que atendem/não atendem a descrição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para diagramas de AFD",
                                    "Lista de strings de teste"
                                  ],
                                  "tips": "Sempre considere a string vazia (ε) e verifique se ela satisfaz a condição.",
                                  "learningObjective": "Traduzir descrições linguísticas em estruturas reconhecíveis por regex.",
                                  "commonMistakes": [
                                    "Ignorar strings vazias ou com comprimento zero",
                                    "Focar só em casos simples sem generalizar",
                                    "Confundir contagem total com ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a expressão regular passo a passo",
                                  "subSteps": [
                                    "Comece com o caso base: strings sem 'a' (ex: b* para alfabeto {a,b}).",
                                    "Adicione padrões para manter a propriedade (ex: adicione pares 'aa' ou 'a...a').",
                                    "Use estrela de Kleene para repetições: (padrão_base (padrão_par)*).",
                                    "Inclua outros símbolos livremente onde não afetam a contagem (ex: b* entre 'a's).",
                                    "Simplifique a regex removendo redundâncias e teste equivalência."
                                  ],
                                  "verification": "Construa a regex e compare com uma conhecida para o mesmo conjunto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de regex tester (ex: regex101.com)",
                                    "Exemplos resolvidos de regex semelhantes"
                                  ],
                                  "tips": "Construa recursivamente: pense em como estender uma regex par para mais pares.",
                                  "learningObjective": "Aplicar operações básicas para sintetizar uma regex equivalente à descrição.",
                                  "commonMistakes": [
                                    "Usar + em vez de * quando zero repetições são permitidas",
                                    "Esquecer b* entre elementos restritos",
                                    "Criar regex que aceita ímpares acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar a expressão regular construída",
                                  "subSteps": [
                                    "Teste com strings aceitas: ε, bbb, aabb, ababa.",
                                    "Teste com strings rejeitadas: a, aaab, babaa.",
                                    "Use uma ferramenta para matching e ajuste se necessário.",
                                    "Prove informalmente que a regex gera exatamente o conjunto desejado.",
                                    "Otimize para forma mais concisa se possível."
                                  ],
                                  "verification": "Todos os testes passam e há uma justificativa de correção.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Regex tester online ou Python RE module",
                                    "Lista expandida de 10 strings de teste"
                                  ],
                                  "tips": "Teste casos de borda: vazia, só b's, máxima alternância.",
                                  "learningObjective": "Garantir que a regex é correta e equivalente à descrição linguística.",
                                  "commonMistakes": [
                                    "Testar só strings aceitas",
                                    "Usar ferramentas sem entender o porquê do match",
                                    "Não testar rejeitadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Alfabeto Σ = {a, b}. Conjunto: todas as strings com número par de 'a' (incluindo zero). Regex construída: b* (a b* a b*)*. Exemplo: 'abab' (duas 'a', par) é aceito; 'aba' (três 'a', ímpar) é rejeitado.",
                              "finalVerifications": [
                                "A regex aceita todas as strings com número par de 'a' no exemplo dado.",
                                "A regex rejeita corretamente strings com número ímpar de 'a'.",
                                "String vazia (ε) é aceita se par (zero 'a').",
                                "Testes com 5 strings aceitas e 5 rejeitadas passam 100%.",
                                "Regex é equivalente a um AFD com 2 estados (par/ímpar).",
                                "Nenhuma simplificação adicional é possível sem alterar o conjunto."
                              ],
                              "assessmentCriteria": [
                                "Regex é sintaticamente correta e usa apenas operações básicas.",
                                "Equivalência comprovada com testes exaustivos e justificativa.",
                                "Construção segue passos lógicos sem saltos injustificados.",
                                "Explicação clara da análise linguística e construção.",
                                "Otimização mínima: regex concisa e legível.",
                                "Tratamento correto de casos de borda (ε, só outros símbolos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos, indução e paridade.",
                                "Linguística: Análise de padrões e gramáticas formais.",
                                "Programação: Aplicação em módulos como Python 're' para validação.",
                                "Lógica: Estados finitos e máquinas de Turing básicas.",
                                "Engenharia de Software: Parsing e validação de inputs."
                              ],
                              "realWorldApplication": "Construir validadores para senhas (ex: par de dígitos específicos), parsers de logs (padrões repetidos pares), filtros de busca em textos (ocorrências pares de palavras-chave) em ferramentas como grep, editores de texto e sistemas de segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Aplicar operações em expressões regulares",
                            "description": "Manipular expressões regulares usando união (|), concatenação e estrela (*), simplificando expressões equivalentes como (a|b)*a(a|b)*.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as operações básicas de expressões regulares",
                                  "subSteps": [
                                    "Defina união (|): representa a escolha entre símbolos ou subexpressões.",
                                    "Defina concatenação: sequência de símbolos ou expressões sem operador explícito.",
                                    "Defina estrela (*): zero ou mais repetições da expressão precedente.",
                                    "Estude exemplos simples: a|b (a ou b), ab (a seguido de b), a* (zero ou mais a's).",
                                    "Compare com linguagens geradas: L(a|b) = {a,b}, L(ab) = {ab}, L(a*) = {ε, a, aa, ...}."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o significado de cada operação com um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de símbolos regex básica"
                                  ],
                                  "tips": "Lembre-se: parênteses são usados para agrupar subexpressões e controlar precedência.",
                                  "learningObjective": "Identificar e descrever corretamente união, concatenação e estrela em expressões regulares.",
                                  "commonMistakes": [
                                    "Confundir estrela (*) com mais (+)",
                                    "Ignorar o papel da concatenação implícita",
                                    "Esquecer que ε é gerado por *"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir expressões usando união e concatenação",
                                  "subSteps": [
                                    "Crie expressões para linguagens simples: ex. (a|b)c para {ac, bc}.",
                                    "Pratique precedência: escreva abc|d como (abc)|d vs a(bc|d).",
                                    "Converta diagramas de transição simples em expressões usando essas operações.",
                                    "Gere linguagens para suas expressões e liste 5 palavras de exemplo.",
                                    "Compare expressões equivalentes: a|b vs b|a."
                                  ],
                                  "verification": "Construa 3 expressões corretas para linguagens dadas e liste suas palavras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de linguagens regulares impressas",
                                    "Calculadora de linguagens (opcional)"
                                  ],
                                  "tips": "Sempre use parênteses para evitar ambiguidades na precedência (estrela > concatenação > união).",
                                  "learningObjective": "Construir expressões regulares compostas usando união e concatenação com precisão.",
                                  "commonMistakes": [
                                    "Erro de precedência sem parênteses",
                                    "Gerar linguagens incorretas ao testar",
                                    "Confundir ordem de concatenação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a operação de estrela em expressões",
                                  "subSteps": [
                                    "Aplique * a subexpressões: ex. (a|b)* gera todas as strings sobre {a,b}.",
                                    "Combine com concatenação: (a|b)*a gera strings terminando em a.",
                                    "Entenda propriedades: R* = ε | R | RR | RRR | ...",
                                    "Construa expressões para linguagens como todas as strings com pelo menos um a: (b* a b*)*.",
                                    "Teste gerando palavras e verificando inclusão."
                                  ],
                                  "verification": "Crie uma expressão com * que gere exatamente a linguagem especificada e prove com exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de linguagens exemplos",
                                    "Papel para diagramas de AFs equivalentes"
                                  ],
                                  "tips": "Pense na estrela como 'loop' em autômatos finitos para visualizar a linguagem.",
                                  "learningObjective": "Incorporar a estrela corretamente em expressões para representar repetições.",
                                  "commonMistakes": [
                                    "Esquecer ε na estrela",
                                    "Aplicar * a expressões vazias incorretamente",
                                    "Não agrupar corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simplificar expressões regulares equivalentes",
                                  "subSteps": [
                                    "Aprenda identidades: R|S = S|R, (R|S)* = (S|R)*, R** = R*.",
                                    "Simplifique passo a passo: ex. (a|b)*a(a|b)* → (a|b)*a por idempotência.",
                                    "Use regras: R(R|S)* = (a|b)* para absorção.",
                                    "Pratique o exemplo dado: prove (a|b)*a(a|b)* ≡ (a|b)*a.",
                                    "Verifique equivalência convertendo para AFNs ou gerando linguagens."
                                  ],
                                  "verification": "Simplifique 2 expressões complexas para formas canônicas e prove equivalência.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela de identidades regex",
                                    "Ferramenta online de regex para AFN (opcional)"
                                  ],
                                  "tips": "Aplique regras algebricamente de dentro para fora, priorizando absorção e idempotência.",
                                  "learningObjective": "Aplicar propriedades algébricas para simplificar expressões regulares.",
                                  "commonMistakes": [
                                    "Aplicar regras em ordem errada",
                                    "Ignorar associatividade",
                                    "Concluir equivalência sem prova"
                                  ]
                                }
                              ],
                              "practicalExample": "Simplifique a expressão (a|b)*a(a|b)* para reconhecer todas as strings sobre {a,b} que contêm pelo menos um 'a'. Passo a passo: note que qualquer string terminando em a pode ser prefixada por (a|b)* e sufixada por (a|b)*, mas pela propriedade de prefixo, simplifica para (a|b)*a.",
                              "finalVerifications": [
                                "Construa uma expressão equivalente para uma linguagem dada usando apenas |, concatenação e *.",
                                "Simplifique corretamente (a|b)*a(a|b)* para (a|b)*a e prove gerando contraexemplos para formas erradas.",
                                "Liste a linguagem gerada por uma expressão complexa com pelo menos 5 palavras.",
                                "Identifique erros em simplificações fornecidas.",
                                "Converta uma expressão simplificada em AFN com no máximo 3 estados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de operações: 100% das expressões construídas são corretas.",
                                "Profundidade de simplificação: Reduz expressões a formas mínimas usando identidades adequadas.",
                                "Compreensão conceitual: Explica linguagens geradas sem erros.",
                                "Criatividade em exemplos: Gera aplicações originais e verifica.",
                                "Eficiência: Tempo de resolução dentro do estimado com passos lógicos.",
                                "Verificação rigorosa: Provas de equivalência via geração ou AFNs."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Equivalência com autômatos finitos não-determinísticos.",
                                "Programação: Implementação prática em linguagens como Python (re module).",
                                "Matemática Discreta: Álgebra booleana e monoides livres.",
                                "Lógica: Expressões como fórmulas lógicas com operadores semelhantes."
                              ],
                              "realWorldApplication": "Em ferramentas de busca como grep ou editores de texto (VS Code), simplificar regex otimiza performance de matching em grandes textos; em compiladores, minimiza padrões para parsing eficiente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Converter expressão regular para AFD",
                            "description": "Transformar uma expressão regular em um autômato finito determinístico usando construção de Thompson ou Glushkov, passo a passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar e decompor a expressão regular",
                                  "subSteps": [
                                    "Identifique os operadores principais: união (|), concatenação implícita, fechamento de Kleene (*), e símbolos básicos (a, ε, ∅).",
                                    "Determine a precedência: * > concatenação > união, respeitando parênteses.",
                                    "Construa a árvore sintática da expressão, representando cada sub-expressão como um nó.",
                                    "Anote as sub-expressões primitivas e suas relações hierárquicas.",
                                    "Valide a expressão para erros sintáticos comuns."
                                  ],
                                  "verification": "Árvore sintática completa e correta desenhada, com todos os operadores e precedências identificados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Canetas coloridas",
                                    "Tabela de precedência de operadores regex"
                                  ],
                                  "tips": "Use cores diferentes para operadores para visualizar melhor a hierarquia.",
                                  "learningObjective": "Compreender a estrutura hierárquica e sintática de expressões regulares.",
                                  "commonMistakes": [
                                    "Ignorar precedência de operadores, levando a decomposição errada.",
                                    "Esquecer parênteses aninhados.",
                                    "Confundir concatenação implícita com união."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir NFA usando Construção de Thompson",
                                  "subSteps": [
                                    "Para símbolo básico 'a': Crie dois estados i e f, com transição 'a' de i para f.",
                                    "Para união (E1|E2): Crie novo i e f; adicione ε-transições de i para inícios de E1 e E2; dos fins de E1/E2 para f.",
                                    "Para concatenação (E1E2): Conecte fins de E1 a inícios de E2 via ε-transições.",
                                    "Para estrela de Kleene (E*): Crie novo i e f; ε de i para início de E e para f; ε do fim de E para início de E e para f.",
                                    "Numere todos os estados sequencialmente e marque estado inicial e finais."
                                  ],
                                  "verification": "NFA possui exatamente um estado inicial e um ou mais finais, com todas transições ε e rotuladas corretas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel grande para diagrama",
                                    "Ferramentas de desenho como draw.io ou papel e lápis",
                                    "Referência das regras de Thompson"
                                  ],
                                  "tips": "Construa sub-NFAs primeiro e combine-os para evitar confusão.",
                                  "learningObjective": "Aplicar regras composicionais de Thompson para gerar NFA equivalente à regex.",
                                  "commonMistakes": [
                                    "Esquecer ε-transições de bypass na estrela de Kleene.",
                                    "Não adicionar ε-transições corretas na união.",
                                    "Reutilizar estados incorretamente, violando independência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter NFA para DFA via Subset Construction",
                                  "subSteps": [
                                    "Calcule o epsilon-closure do estado inicial do NFA para formar o estado inicial do DFA.",
                                    "Para cada estado DFA (conjunto de estados NFA) e símbolo σ no alfabeto, compute a transição: move(estado, σ) seguido de epsilon-closure.",
                                    "Adicione novos estados à fila de processamento até não haver mais estados não visitados.",
                                    "Marque estados DFA como finais se contiverem pelo menos um estado final do NFA.",
                                    "Preencha a tabela de transições para garantir determinismo total."
                                  ],
                                  "verification": "Tabela de transição do DFA completa, sem estados não determinísticos ou indefinidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Lista de epsilon-closures pré-calculados",
                                    "Alfabeto da regex"
                                  ],
                                  "tips": "Use notação de potências (2^Q) para rastrear estados e evite duplicatas com um conjunto de vistos.",
                                  "learningObjective": "Dominar a construção de subconjuntos para eliminar não-determinismo.",
                                  "commonMistakes": [
                                    "Esquecer epsilon-closure após move.",
                                    "Não processar todos os símbolos do alfabeto.",
                                    "Confundir estados finais do DFA."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e testar o AFD construído",
                                  "subSteps": [
                                    "Desenhe o diagrama do DFA com estados, transições e rótulos claros.",
                                    "Teste com strings aceitas pela regex original (ex: strings no linguagem).",
                                    "Teste com strings rejeitadas para validar rejeição.",
                                    "Compare o número de estados com o mínimo esperado (opcional: minimize via partições).",
                                    "Documente qualquer otimização realizada."
                                  ],
                                  "verification": "DFA aceita exatamente as strings da linguagem da regex em testes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Strings de teste pré-definidas",
                                    "Simulador de autômatos online (opcional)"
                                  ],
                                  "tips": "Comece com strings curtas e aumente complexidade gradualmente.",
                                  "learningObjective": "Validar corretude do AFD através de testes empíricos.",
                                  "commonMistakes": [
                                    "Não testar casos de borda como ε ou strings vazias.",
                                    "Ignorar transições para estados 'lixo' (dead states)."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a regex (a|b)*a, construa o AFD: 1) Decomponha em árvore; 2) Thompson gera NFA com ~8 estados; 3) Subset construction resulta em DFA com 2 estados (S0: strings não terminando em a; S1: terminando em a), transição a/b em S0 para S0/S1 respectivamente.",
                              "finalVerifications": [
                                "DFA possui transições totais para todos símbolos do alfabeto.",
                                "Estados iniciais e finais estão corretamente identificados.",
                                "O AFD aceita todas as strings geradas pela regex original.",
                                "O AFD rejeita strings fora da linguagem.",
                                "Número de estados é finito e equivalente em poder expressivo.",
                                "Diagrama é legível e sem ambiguidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição da regex (20%)",
                                "Corretude da construção de Thompson (30%)",
                                "Exatidão na subset construction (30%)",
                                "Qualidade dos testes e verificações (10%)",
                                "Clareza do diagrama e documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Conjuntos: Operações de potências e closures.",
                                "Matemática Discreta: Estruturas algébricas e relações.",
                                "Lógica: Equivalências formais e provas de corretude.",
                                "Engenharia de Software: Parsing e análise léxica."
                              ],
                              "realWorldApplication": "Conversão essencial para implementações eficientes de analisadores léxicos em compiladores (ex: Flex/Lex), motores de busca regex em editores (VSCode, grep), validação de padrões em sistemas de segurança e processamento de logs em DevOps."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.4",
                            "name": "Provar equivalência de expressões",
                            "description": "Demonstrar que duas expressões regulares denotam a mesma linguagem usando indução ou autômatos intermediários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar as expressões regulares e preparar a prova",
                                  "subSteps": [
                                    "Leia cuidadosamente as duas expressões regulares (r1 e r2) e identifique o alfabeto Σ.",
                                    "Descreva informalmente a linguagem L(r1) e L(r2) gerando exemplos de strings aceitas e rejeitadas.",
                                    "Escolha o método: autômatos intermediários (NFA → DFA mínimo) ou indução estrutural.",
                                    "Liste propriedades conhecidas: ε-fechamento, reversibilidade, etc.",
                                    "Documente suposições e lema auxiliar se necessário (ex: propriedades de concatenação)."
                                  ],
                                  "verification": "Produza um relatório escrito com descrições linguísticas e pelo menos 5 strings de teste coincidentes para ambas linguagens.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta JFLAP ou regexviz.com",
                                    "Livro de Teoria da Computação (Sipser ou similar)"
                                  ],
                                  "tips": "Gere strings curtas primeiro para validar intuição; use desenhos para visualizar padrões.",
                                  "learningObjective": "Compreender semanticamente as expressões e selecionar método apropriado.",
                                  "commonMistakes": [
                                    "Ignorar o ε (linguagem vazia)",
                                    "Confundir união (|) com concatenação",
                                    "Esquecer strings vazias ou prefixos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir autômatos não-determinísticos (NFAs) para cada expressão",
                                  "subSteps": [
                                    "Aplique o algoritmo padrão de Thompson para converter r1 em NFA1.",
                                    "Repita para r2, construindo NFA2.",
                                    "Valide os NFAs simulando aceitação de strings de teste manualmente.",
                                    "Otimize transições desnecessárias sem alterar a linguagem.",
                                    "Desenhe os diagramas destacando estados iniciais, finais e ε-transições."
                                  ],
                                  "verification": "Simule 3 strings (aceitas e rejeitadas) em cada NFA e confirme resultados idênticos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "JFLAP ou draw.io para diagramas",
                                    "Simulador NFA online"
                                  ],
                                  "tips": "Comece com sub-expressões pequenas; use cores para estados ε.",
                                  "learningObjective": "Dominar construção de NFAs a partir de regex.",
                                  "commonMistakes": [
                                    "Erros em ε-transições de união/estrela",
                                    "Estados finais incorretos em concatenação",
                                    "Não tratar alfabeto vazio"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter NFAs para DFAs mínimos e comparar",
                                  "subSteps": [
                                    "Converta NFA1 para DFA1 usando construção de subconjuntos.",
                                    "Minimize DFA1 para obter Myhill-Nerode equivalente.",
                                    "Repita para NFA2 → DFA2 mínimo.",
                                    "Compare os DFAs mínimos: verifique se transições e estados finais são isomorfos.",
                                    "Se não idênticos, identifique contraexemplo e ajuste."
                                  ],
                                  "verification": "Os diagramas de DFAs mínimos devem ser idênticos (renomeando estados se necessário).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "JFLAP para conversão/minimização",
                                    "Tabela de potências para subconjuntos"
                                  ],
                                  "tips": "Liste todos subconjuntos possíveis sistematicamente; ignore subconjuntos inalcançáveis.",
                                  "learningObjective": "Aplicar powerset e minimização para decidir equivalência.",
                                  "commonMistakes": [
                                    "Subconjuntos incompletos no powerset",
                                    "Não distinguir estados distinguíveis na minimização",
                                    "Esquecer estados mortos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prova alternativa por indução estrutural e verificação final",
                                  "subSteps": [
                                    "Defina base: casos vazios/átomo (ε, a ∈ Σ).",
                                    "Indução: assuma para sub-expressões, prove para união/concat/estrela.",
                                    "Mostre L(r1) ⊆ L(r2) e L(r2) ⊆ L(r1) por casos.",
                                    "Compare com resultado de autômatos para consistência.",
                                    "Gere relatório final com ambos métodos."
                                  ],
                                  "verification": "Prova escrita completa com todos casos indutivos cobertos e sem lacunas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel para árvore de parsing das regex",
                                    "Exemplos de provas de livro"
                                  ],
                                  "tips": "Use lemas auxiliares para estrela; prove inclusão bidirecional.",
                                  "learningObjective": "Usar indução para equivalências estruturais simples.",
                                  "commonMistakes": [
                                    "Falhar em caso estrela (loop indutivo)",
                                    "Não tratar ε em concatenação",
                                    "Assumir simetria sem prova"
                                  ]
                                }
                              ],
                              "practicalExample": "Prove que r1 = (a|b)*a e r2 = a(a|b)* denotam a mesma linguagem sobre Σ = {a,b}. Método autômatos: Construa NFAs (estrela com loop a/b terminando em a), converta para DFAs mínimos (ambos aceitam strings terminando em 'a'). Método indução: Mostre por casos que toda string em L(r1) termina em 'a' e pode ser reescrita como em L(r2), e vice-versa.",
                              "finalVerifications": [
                                "Ambos métodos (autômatos e indução) concluem equivalência.",
                                "Testes com 10 strings aleatórias (curtas/longas) aceitas por ambos.",
                                "DFAs mínimos são isomorfos.",
                                "Prova indutiva cobre todos construtores regex sem exceções.",
                                "Nenhum contraexemplo encontrado.",
                                "Documentação completa com diagramas."
                              ],
                              "assessmentCriteria": [
                                "Correção na construção de NFAs (simulação passa em testes).",
                                "Precisão na conversão powerset e minimização (DFAs idênticos).",
                                "Rigor na prova indutiva (bases e passos indutivos completos).",
                                "Validação com exemplos concretos e contraexemplos negativos.",
                                "Clareza nos diagramas e explicações escritas.",
                                "Eficiência: tempo dentro do estimado sem erros graves."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução matemática e teoria dos conjuntos.",
                                "Lógica: Provas formais e equivalência de estruturas.",
                                "Engenharia de Software: Verificação de compiladores e parsers.",
                                "Algoritmos: Otimização de autômatos em grafos."
                              ],
                              "realWorldApplication": "Em compiladores (lexers como flex), otimizar regex para scanners eficientes; em ferramentas de busca (grep, regex engines) garantir que padrões alternativos sejam semanticamente iguais sem perda de performance; validação de protocolos de rede onde padrões de mensagens devem ser equivalentes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Propriedades dos Conjuntos Regulares",
                        "description": "Propriedades algébricas e teóricas dos conjuntos regulares, incluindo fechamento sob operações booleanas, teorema do bombeamento e testes de decidibilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Aplicar propriedades de fechamento",
                            "description": "Mostrar que a união, interseção, complemento, concatenação e estrela de linguagens regulares resultam em linguagens regulares, com provas usando autômatos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Provar fechamento sob união usando autômatos",
                                  "subSteps": [
                                    "Revise a definição de DFA e NFA para linguagens regulares.",
                                    "Dado dois NFAs M1 e M2 para L1 e L2, crie um novo NFA Mu com novo estado inicial i que tem transições ε para os iniciais de M1 e M2.",
                                    "Os estados finais de Mu são a união dos estados finais de M1 e M2.",
                                    "Copie todas as transições de M1 e M2 para Mu.",
                                    "Teste com uma string em L1 ou L2 para verificar aceitação."
                                  ],
                                  "verification": "Construa o NFA para dois DFAs simples e verifique se aceita strings da união usando simulação manual.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis para desenhar autômatos",
                                    "Ferramenta JFLAP ou Draw.io",
                                    "Exemplos de DFAs para {a} e {b}"
                                  ],
                                  "tips": "Use transições ε para simplificar; depois, se necessário, determinize para DFA.",
                                  "learningObjective": "Compreender a construção de NFA para união de linguagens regulares.",
                                  "commonMistakes": [
                                    "Esquecer de copiar todas as transições de M1 e M2",
                                    "Não marcar corretamente os estados finais da união"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar fechamento sob concatenação e estrela de Kleene",
                                  "subSteps": [
                                    "Para concatenação L1 · L2: Crie NFA Mc com estados de M1 e M2; adicione ε-transições de cada final de M1 para inicial de M2.",
                                    "Para estrela L*: Crie NFA Ms com novo inicial i e novo final f; ε de i para inicial de M e para f; ε de finais de M para inicial de M e para f.",
                                    "Copie transições originais.",
                                    "Verifique com strings vazia (para estrela) e concatenações como ab.",
                                    "Simule a aceitação para exemplos concretos."
                                  ],
                                  "verification": "Construa NFAs para concatenação de {a} e {b} (deve aceitar ab) e estrela de {a} (a* incluindo ε).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "JFLAP para simulação",
                                    "Exemplos de linguagens como a* b*"
                                  ],
                                  "tips": "A estrela sempre aceita a string vazia; teste isso primeiro.",
                                  "learningObjective": "Dominar construções para concatenação e fechamento sob estrela.",
                                  "commonMistakes": [
                                    "Não adicionar loops corretos na estrela",
                                    "Esquecer ε de finais para inicial na concatenação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar fechamento sob interseção usando produto de autômatos",
                                  "subSteps": [
                                    "Dado DFAs M1 e M2, crie DFA Mi com estados pares (q1, q2) de estados de M1 x M2.",
                                    "Inicial: par dos iniciais; final: pares onde ambos são finais.",
                                    "Transições: δ((q1,q2), σ) = (δ1(q1,σ), δ2(q2,σ)).",
                                    "Prove que Mi aceita L1 ∩ L2 simulando caminhos paralelos.",
                                    "Teste com linguagens como pares de a e b."
                                  ],
                                  "verification": "Construa o produto para L1={strings pares de a} e L2={pares de b} e verifique interseção vazia.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de estados para produto",
                                    "JFLAP para DFAs"
                                  ],
                                  "tips": "Use apenas DFAs para interseção; evita não-determinismo.",
                                  "learningObjective": "Aplicar construção de produto para interseção de linguagens regulares.",
                                  "commonMistakes": [
                                    "Transições erradas no produto",
                                    "Marcar par como final se apenas um é final"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar fechamento sob complemento usando DFA completo",
                                  "subSteps": [
                                    "Dado DFA M para L, torne-o completo adicionando estados trap e transições totais.",
                                    "O complemento é trocar estados finais por não-finais (e vice-versa).",
                                    "Crie Mc com mesmos estados e transições, mas inverte finais.",
                                    "Prove que w ∈ L(Mc) iff w ∉ L(M), pois caminhos rejeitados viram aceitos.",
                                    "Teste com exemplo simples como complemento de {a} sobre {a,b}*."
                                  ],
                                  "verification": "Construa DFA para {a} e seu complemento {b}*, teste strings.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplos de DFAs completos",
                                    "Simulador de autômatos"
                                  ],
                                  "tips": "DFA deve ser completo e sem transições indefinidas para complemento funcionar.",
                                  "learningObjective": "Entender inversão de aceitação para complemento.",
                                  "commonMistakes": [
                                    "DFA não completo (transições faltando)",
                                    "Não inverter corretamente os finais"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere L1 = {w | w termina em 'a'} (DFA simples) e L2 = {w | termina em 'b'}. Construa NFA para L1 ∪ L2 (termina em a ou b), depois determinize. Para concatenação, L1 · L2 (termina em ab). Verifique com strings como 'aa' (em L1), 'bb' (em L2), 'aab' (em concatenação). Use JFLAP para visualizar.",
                              "finalVerifications": [
                                "Conseguiu construir NFAs/DFAs corretos para todas as operações citadas.",
                                "Simulações manuais confirmam aceitação/rejeição esperada para exemplos.",
                                "Provas formais explicam por que cada construção preserva regularidade.",
                                "Identificou e corrigiu erros comuns em construções iniciais.",
                                "Aplicou as propriedades a linguagens concretas sem falhas."
                              ],
                              "assessmentCriteria": [
                                "Construções de autômatos precisas e sem erros lógicos.",
                                "Provas completas justificando preservação da regularidade.",
                                "Exemplos práticos testados e validados.",
                                "Uso correto de ε-transições e produtos.",
                                "Clareza na explicação de verificações e simulações.",
                                "Cobertura de todos os casos: união, concatenação, estrela, interseção, complemento."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Conjuntos (Matemática): operações de união, interseção, complemento.",
                                "Lógica e Autômatos: modelagem de estados e transições.",
                                "Programação: expressões regulares em linguagens como Python (re module).",
                                "Compiladores: análise léxica e parsing.",
                                "Matemática Discreta: grafos e produtos cartesianos."
                              ],
                              "realWorldApplication": "Essas propriedades são fundamentais para compiladores e interpretadores, onde expressões regulares são convertidas em autômatos para tokenização eficiente de código-fonte, validação de padrões em ferramentas como grep, editores de texto e sistemas de busca em bancos de dados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Usar o lema do bombeamento",
                            "description": "Aplicar o lema do bombeamento para provar que uma dada linguagem NÃO é regular, decompondo palavras longas em xyz com |xy| ≤ p e |y| > 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar e enunciar precisamente o Lema do Bombeamento",
                                  "subSteps": [
                                    "Leia o enunciado oficial do Lema do Bombeamento para linguagens regulares.",
                                    "Identifique os elementos chave: constante de bombeamento p, decomposição w = xyz com |xy| ≤ p e |y| > 0, e propriedade xy^i z ∈ L para todo i ≥ 0.",
                                    "Escreva o lema em suas próprias palavras, destacando que é usado para prova por contradição.",
                                    "Verifique se entende que assumimos L regular para derivar uma contradição.",
                                    "Compare com exemplos de linguagens regulares para contrastar."
                                  ],
                                  "verification": "Escreva o lema completo e peça a um colega ou tutor para validar a precisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Teoria da Computação (ex: Sipser), papel e caneta, notas de aula.",
                                  "tips": "Memorize as condições |xy| ≤ p e |y| > 0 como 'âncora' para a análise.",
                                  "learningObjective": "Dominar o enunciado exato do lema para aplicação correta em provas.",
                                  "commonMistakes": "Confundir com lema para linguagens livres de contexto; ignorar |xy| ≤ p."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar uma palavra de bombeamento w adequada",
                                  "subSteps": [
                                    "Escolha uma linguagem L não regular suspeita (ex: {a^n b^n | n ≥ 0}).",
                                    "Defina w como uma palavra 'pivotal' que capture a estrutura não regular, com |w| ≥ p (ex: w = a^p b^p).",
                                    "Justifique por que w revela a falha: deve forçar y a 'quebrar' o equilíbrio.",
                                    "Calcule comprimentos para garantir |w| ≥ p.",
                                    "Teste com p pequeno para validar intuitivamente."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que essa w é 'boazinha' para a prova.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado para diagramas de strings, calculadora para comprimentos.",
                                  "tips": "w deve ser parametrizada por p para generalidade (ex: usar p no expoente).",
                                  "learningObjective": "Aprender a escolher w que maximize a contradição em qualquer decomposição.",
                                  "commonMistakes": "Escolher w muito curta (|w| < p) ou sem estrutura repetitiva."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar todas as possíveis decomposições xyz",
                                  "subSteps": [
                                    "Liste casos baseados em |xy| ≤ p: y em a's, y atravessando a-b, y só em b's.",
                                    "Para cada caso, bombeie i=0 (xy^0 z = xz) ou i=2 (xy^2 z) e verifique se ∈ L.",
                                    "Mostre que cada caso leva a uma palavra fora de L (ex: mais a's que b's).",
                                    "Cubra todos os casos exaustivamente sem lacunas.",
                                    "Desenhe diagramas visuais das strings para cada bombeamento."
                                  ],
                                  "verification": "Marque cada caso com ✓ ou ✗ mostrando violação da linguagem.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de texto ou LaTeX para formalizar casos, diagramas ASCII.",
                                  "tips": "Use casos exaustivos: y todo em a's, y inclui transição a-b, y em b's.",
                                  "learningObjective": "Desenvolver análise de casos para cobrir todas as posições possíveis de y.",
                                  "commonMistakes": "Ignorar um caso (ex: y vazio, mas |y|>0 previne isso); não bombeiar i suficiente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a prova por contradição",
                                  "subSteps": [
                                    "Resuma que para todo p, existe w com |w|≥p sem decomposição válida.",
                                    "Reafirme a contradição: hipótese de regularidade falha.",
                                    "Conclua formalmente: 'Portanto, L não é regular'.",
                                    "Discuta limitações: só prova não-regularidade, não construtividade.",
                                    "Aplique a uma segunda linguagem para prática (ex: {a^n b^n c^n})."
                                  ],
                                  "verification": "Escreva parágrafo final da prova e autoavalie lógica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Modelo de prova padrão de um livro-texto para comparação.",
                                  "tips": "Estruture como: Assumimos... Então... Contradição! Logo...",
                                  "learningObjective": "Fechar a prova logicamente, reforçando o método de contradição.",
                                  "commonMistakes": "Falhar em generalizar para 'todo p'; pular conclusão explícita."
                                }
                              ],
                              "practicalExample": "Para L = {a^n b^n | n ≥ 0}, assuma regular com p. Tome w = a^p b^p. Casos: (1) y em a's → xy^2 z tem mais a's; (2) y atravessa → bombeamento altera equilíbrio; (3) y em b's → menos b's em i=0. Nenhuma preserva L.",
                              "finalVerifications": [
                                "Enuncie o lema sem erros.",
                                "Escolha w correta para uma linguagem dada.",
                                "Analise todos os casos de decomposição.",
                                "Mostre explicitamente xy^i z ∉ L para cada caso.",
                                "Conclua corretamente por contradição.",
                                "Aplique a pelo menos duas linguagens diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado do lema (20%).",
                                "Adequação e justificativa de w (25%).",
                                "Exaustividade na análise de casos (30%).",
                                "Correção nas bombeadas e contradições (15%).",
                                "Clareza e formalidade da conclusão (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Prova por contradição e teoria dos conjuntos infinitos.",
                                "Lógica: Análise de casos exaustivos e quantificadores (∀p ∃w).",
                                "Programação: Verificação de padrões em strings e autômatos finitos em código.",
                                "Filosofia: Limites da computação formal (relacionado a Gödel)."
                              ],
                              "realWorldApplication": "Em compiladores, usar para provar que certas verificações de equilíbrio (ex: parênteses aninhados) exigem parsers não-regulares; análise de protocolos de rede para detectar padrões não-regulares em pacotes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Resolver problemas de decidibilidade",
                            "description": "Determinar decidibilidade de propriedades como 'uma linguagem regular contém uma palavra específica?' ou 'duas expressões regulares são equivalentes?', usando minimização de AFD.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Formalizar o Problema de Decidibilidade",
                                  "subSteps": [
                                    "Leia cuidadosamente a declaração do problema, identificando a propriedade em questão (ex.: membership de uma palavra específica ou equivalência entre linguagens regulares).",
                                    "Classifique o tipo de problema: membership (contém uma palavra w?), equivalência (L1 = L2?), ou outro decidível para regulares.",
                                    "Represente as linguagens envolvidas como autômatos finitos determinísticos (AFDs) ou expressões regulares, garantindo que estejam na forma padrão.",
                                    "Defina os parâmetros de entrada: AFDs M1, M2, palavra w, etc.",
                                    "Anote premissas: confirme que as linguagens são regulares, pois decidibilidade aplica-se a elas."
                                  ],
                                  "verification": "Escreva um resumo formal do problema com representações matemáticas (ex.: L(M) contém w?).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, tabela de definições de linguagens regulares, exemplos de problemas de decidibilidade.",
                                  "tips": "Sempre pergunte: 'É uma propriedade decidível para regulares?' para evitar confusão com não-regulares.",
                                  "learningObjective": "Formalizar problemas de decidibilidade em termos precisos de linguagens regulares.",
                                  "commonMistakes": "Confundir membership com inclusão (L1 ⊆ L2); assumir decidibilidade sem verificar regularidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e Minimizar os Autômatos Finitos Determinísticos",
                                  "subSteps": [
                                    "Construa AFDs para cada linguagem ou expressão regular envolvida, usando construção padrão (Thompson ou Glushkov para regex).",
                                    "Converta AFNs para AFDs via subconjuntos se necessário.",
                                    "Aplique o algoritmo de minimização de Hopcroft ou partições para obter AFDs mínimos.",
                                    "Verifique completude: todos estados acessíveis e determinísticos.",
                                    "Rotule estados minimizados para facilitar comparações posteriores."
                                  ],
                                  "verification": "Desenhe os AFDs minimizados e confirme que aceitam o mesmo idioma que as entradas originais via teste em palavras de exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de desenho de autômatos (JFLAP, papel quadriculado), algoritmo de minimização impresso.",
                                  "tips": "Use partições iniciais baseadas em estados finais/não-finais para acelerar Hopcroft.",
                                  "learningObjective": "Dominar construção e minimização de AFDs para preparar testes de decidibilidade.",
                                  "commonMistakes": "Esquecer estados inacessíveis; erros na tabela de transição durante subconjuntos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Testes Específicos de Decidibilidade",
                                  "subSteps": [
                                    "Para membership (L contém w?): Inicie em q0 do AFD minimizado e simule transições com w; verifique se termina em estado final.",
                                    "Para equivalência (L1 = L2?): Compare AFDs minimizados M1 e M2; cheque isomorfismo estrutural (mesma estrutura de estados/transições).",
                                    "Para outros (ex.: vazio?): Verifique se existe caminho de q0 a estado final.",
                                    "Registre o traçado da simulação ou comparação passo a passo.",
                                    "Se aplicável, use complemento para propriedades como 'não contém w'."
                                  ],
                                  "verification": "Produza um traçado escrito ou diagrama mostrando o resultado (aceita/rejeita, equivalentes/não).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "AFDs minimizados do passo anterior, simulador de autômatos (opcional: JFLAP).",
                                  "tips": "Para equivalência, normalize rótulos de estados antes de comparar.",
                                  "learningObjective": "Executar algoritmos decidíveis para propriedades comuns de linguagens regulares.",
                                  "commonMistakes": "Parar simulação cedo sem consumir toda a palavra; ignorar estados equivalentes em minimização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, Concluir e Documentar o Resultado",
                                  "subSteps": [
                                    "Teste o resultado com palavras adicionais de borda (ex.: vazia, prefixos) para validar.",
                                    "Analise se o problema foi resolvido corretamente; discuta limitações (ex.: só para regulares).",
                                    "Escreva a conclusão formal: 'Sim/Não, pois...' com justificativa.",
                                    "Documente lições aprendidas ou variações do problema.",
                                    "Compare com teoremas conhecidos (ex.: equivalência decidível por minimização)."
                                  ],
                                  "verification": "Responda corretamente a perguntas de follow-up sobre o raciocínio usado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Resultados dos passos anteriores, teoremas de decidibilidade anotados.",
                                  "tips": "Sempre inclua contraexemplos se a resposta for 'não'.",
                                  "learningObjective": "Interpretar resultados de decidibilidade e comunicá-los claramente.",
                                  "commonMistakes": "Concluir sem validação cruzada; confundir decidível com trivial."
                                }
                              ],
                              "practicalExample": "Dada a expressão regular r1 = (ab)* e r2 = (a?b?)* com |w|<=2, determine se L(r1) = L(r2). Construa AFDs, minimize: M1 aceita pares 'ab'; M2 aceita sequências mistas. Após minimização, estruturas diferem (M2 aceita 'aa'), logo não equivalentes.",
                              "finalVerifications": [
                                "Corretamente simula membership para uma palavra dada em AFD minimizado.",
                                "Minimiza AFDs e detecta não-equivalência via diferença estrutural.",
                                "Identifica corretamente problemas decidíveis vs. indecidíveis para regulares.",
                                "Valida resultado com testes de palavras de aceitação/rejeição.",
                                "Explica o papel da minimização na decidibilidade de equivalência.",
                                "Documenta formalmente o problema e solução."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formalização do problema (20%)",
                                "Corretude na minimização de AFDs (25%)",
                                "Execução correta do teste de decidibilidade (30%)",
                                "Validação e documentação completa (15%)",
                                "Clareza na explicação e avoidance de erros comuns (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria dos grafos em minimização de autômatos.",
                                "Lógica: Propriedades decidíveis semelhantes a satisfatibilidade em lógica proposicional.",
                                "Programação: Implementação de simuladores de AFD em Python/Java.",
                                "Engenharia de Software: Validação de padrões regex em compiladores.",
                                "Filosofia da Computação: Limites da computação (decidibilidade vs. undecidibilidade)."
                              ],
                              "realWorldApplication": "Em compiladores e analisadores léxicos (ex.: lex/flex), verificar se padrões regex cobrem linguagens esperadas sem ambiguidades; em segurança cibernética, validar se expressões de filtro de rede aceitam/ rejeitam tráfego específico; otimização de queries em bancos de dados com expressões regulares."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.4",
                            "name": "Identificar linguagens não-regulares",
                            "description": "Classificar linguagens como {a^n b^n | n ≥ 0} como não-regulares usando bombeamento e contrastar com regulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Linguagens Regulares e Lema de Bombeamento",
                                  "subSteps": [
                                    "Defina linguagem regular e dê exemplos como {a^n | n ≥ 0} e (a|b)*.",
                                    "Explique o teorema de bombeamento para linguagens regulares: para qualquer AFD M reconhecendo L, existe p tal que para qualquer w em L com |w| ≥ p, w = xyz onde |xy| ≤ p, |y| ≥ 1, e xy^i z em L para todo i ≥ 0.",
                                    "Discuta por que isso captura 'memória limitada' das linguagens regulares.",
                                    "Liste propriedades de linguagens regulares (fechamento sob união, concatenação, estrela, etc.).",
                                    "Compare com linguagens não-regulares que requerem 'contagem' ilimitada."
                                  ],
                                  "verification": "Escreva uma definição precisa do lema de bombeamento e identifique pelo menos 3 exemplos de linguagens regulares.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Teoria da Computação (ex: Sipser), papel e caneta, acesso a notas de aula.",
                                  "tips": "Use diagramas de AFD para visualizar linguagens regulares simples.",
                                  "learningObjective": "Compreender os fundamentos teóricos necessários para aplicar o lema de bombeamento.",
                                  "commonMistakes": "Confundir lema de bombeamento com propriedades de fechamento; ignorar a condição |xy| ≤ p."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Linguagem {a^n b^n | n ≥ 0} e Aplicar o Lema de Bombeamento",
                                  "subSteps": [
                                    "Escreva a linguagem formalmente: L = {a^n b^n | n ≥ 0}.",
                                    "Assuma por contradição que L é regular e tem um AFD com p estados.",
                                    "Escolha w = a^p b^p (com |w| ≥ p). Então w = xyz com |xy| ≤ p e |y| ≥ 1.",
                                    "Como |xy| ≤ p, y é composta só de a's (y = a^k, k ≥ 1). Bombeie i=2: xy^2 z = a^{p+k} b^p, que não está em L.",
                                    "Conclua que L não é regular."
                                  ],
                                  "verification": "Escreva a prova completa por contradição, identificando x, y, z explicitamente para w = a^p b^p.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado para diagramas, calculadora para simular bombeamento.",
                                  "tips": "Sempre escolha w que force 'contagem igual' para expor a falha de memória.",
                                  "learningObjective": "Aplicar o lema de bombeamento para provar que uma linguagem específica não é regular.",
                                  "commonMistakes": "Escolher y que cruze a's e b's (violando |xy| ≤ p); esquecer de verificar xy^i z não em L para i=0 ou i=2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar com Linguagens Regulares",
                                  "subSteps": [
                                    "Pegue L_reg = {a^n | n ≥ 0}, que é regular (AFD com 2 estados).",
                                    "Aplique lema de bombeamento a w = a^p: y = a^k bombeia para a^{p + (i-1)k}, ainda em L_reg.",
                                    "Compare com {a^n b^m | n,m ≥ 0}, regular por concatenação de regulares.",
                                    "Discuta por que {a^n b^n} falha: requer matching de contagens.",
                                    "Crie um AFD simples para uma linguagem regular similar."
                                  ],
                                  "verification": "Construa um AFD para {a^* b^*} e mostre por que bombeamento funciona nele.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta online como JFLAP para simular AFDs, papel.",
                                  "tips": "Desenhe o AFD primeiro para visualizar estados limitados.",
                                  "learningObjective": "Distinguir comportamentos de bombeamento em regulares vs. não-regulares.",
                                  "commonMistakes": "Achar que toda linguagem com a's e b's é não-regular; confundir com context-free."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Outros Exemplos",
                                  "subSteps": [
                                    "Teste {a^n b^n c^n | n ≥ 0} (não-regular, mas use bombeamento para pares).",
                                    "Verifique {ww | w em {a,b}*} (não-regular via bombeamento).",
                                    "Identifique regulares como {a^n b^m | n ≠ m} usando complemento.",
                                    "Resolva 2-3 exercícios: classifique e prove.",
                                    "Registre padrões comuns de não-regulares (contagens iguais, palíndromos)."
                                  ],
                                  "verification": "Classifique corretamente 3 linguagens dadas como regular ou não, com justificativa breve.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Lista de exercícios de livro ou online (ex: Sipser problemas), timer.",
                                  "tips": "Use princípio da casa dos pombos para escolher w com p+1 símbolos iguais.",
                                  "learningObjective": "Generalizar a técnica para identificar linguagens não-regulares.",
                                  "commonMistakes": "Aplicar bombeamento incorretamente a linguagens regulares; ignorar casos base n=0."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Autoavaliar",
                                  "subSteps": [
                                    "Resuma o processo: assunção → escolha w → decomp xyz → bombeie → contradição.",
                                    "Crie uma 'checklist' para provas de não-regularidade.",
                                    "Resolva um problema novo sem consultar notas.",
                                    "Compare sua prova com uma referência padrão.",
                                    "Anote insights sobre limitações de autômatos finitos."
                                  ],
                                  "verification": "Escreva uma prova independente para {a^n b^n} em menos de 10 minutos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Notas anteriores, modelo de prova.",
                                  "tips": "Fale em voz alta a prova para reforçar lógica.",
                                  "learningObjective": "Consolidar a habilidade de forma autônoma.",
                                  "commonMistakes": "Pular verificação para i=0; generalizar prematuramente para context-free."
                                }
                              ],
                              "practicalExample": "Para provar que a linguagem de strings com número igual de a's e b's ({w em {a,b}* | #a(w) = #b(w)}) não é regular: assuma AFD com p estados, w = a^p b^p, y em a's, xy^2 z tem mais a's, contradição.",
                              "finalVerifications": [
                                "Prova correta para {a^n b^n} usando bombeamento.",
                                "AFD construído para uma linguagem regular contrastante.",
                                "3 exemplos adicionais classificados com justificativa.",
                                "Checklist pessoal de passos para identificação.",
                                "Autoavaliação: tempo para prova independente < 10 min.",
                                "Identificação de erros comuns em provas simuladas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação do lema (decomposição xyz correta).",
                                "Escolha adequada de w (|w| ≥ p, expõe falha).",
                                "Contradição clara e verificada para i ≥ 2 e i=0.",
                                "Contraste efetivo com regulares (exemplo com AFD).",
                                "Generalização para novos exemplos sem erros.",
                                "Clareza e completude da prova escrita.",
                                "Tempo de execução dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da casa dos pombos para escolher w.",
                                "Lógica: Provas por contradição e indução.",
                                "Programação: Limitações de parsers finitos em compiladores.",
                                "Filosofia da Ciência: Modelos formais e suas limitações."
                              ],
                              "realWorldApplication": "Em compiladores, identificar quando gramáticas requerem parsers não-finitos (ex: aninhamento em linguagens de programação); design de protocolos de rede que evitam contagens ilimitadas; análise de padrões em DNA ou strings de busca que não cabem em autômatos finitos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Linguagens Livres de Contexto",
                    "description": "Linguagens tipo-2, gramáticas livres de contexto e reconhecimento por autômatos de pilha.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Gramáticas Livres de Contexto",
                        "description": "Gramáticas formais do tipo 2 na hierarquia de Chomsky, compostas por terminais, não-terminais, símbolo inicial e regras de produção da forma A → α, onde A é um não-terminal e α é uma cadeia de terminais e não-terminais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Identificar os componentes de uma gramática livre de contexto",
                            "description": "Dado um conjunto de regras, identificar corretamente os terminais (V_T), não-terminais (V_N), símbolo inicial (S) e o conjunto de produções (P), explicando o papel de cada um na geração de linguagens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal de uma gramática livre de contexto",
                                  "subSteps": [
                                    "Estudar a definição padrão: Uma gramática livre de contexto (GLC) é uma 4-tupla G = (V_N, V_T, P, S), onde V_N são não-terminais, V_T terminais, P produções e S o símbolo inicial.",
                                    "Memorizar as propriedades: Produções têm forma A → α, com A ∈ V_N e α ∈ (V_N ∪ V_T)*.",
                                    "Diferenciar GLC de outras gramáticas (ex: regulares têm A → aB ou A → ε).",
                                    "Revisar exemplos básicos de notação, como maiúsculas para V_N e minúsculas para V_T.",
                                    "Explicar recursivamente como G gera strings a partir de S."
                                  ],
                                  "verification": "Escrever a definição completa de GLC e citar um exemplo simples de cada componente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Notas sobre linguagens formais",
                                    "Vídeo introdutório sobre gramáticas"
                                  ],
                                  "tips": "Sempre use a notação padrão G = (V_N, V_T, P, S) para evitar confusões.",
                                  "learningObjective": "Dominar a estrutura teórica de uma GLC e suas componentes principais.",
                                  "commonMistakes": [
                                    "Confundir GLC com autômatos",
                                    "Ignorar que V_N e V_T são disjuntos",
                                    "Esquecer que S ∈ V_N"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar não-terminais (V_N) e terminais (V_T) em um conjunto de regras",
                                  "subSteps": [
                                    "Analisar todas as regras de produção fornecidas.",
                                    "Coletar símbolos à esquerda das setas (→) como V_N (ex: S, A, B).",
                                    "Identificar símbolos que nunca aparecem à esquerda e são 'folhas' nas derivações como V_T (ex: a, b, 0, 1).",
                                    "Verificar convenções: Maiúsculas para V_N, minúsculas ou símbolos especiais para V_T.",
                                    "Confirmar disjunção: Nenhum símbolo em ambos os conjuntos."
                                  ],
                                  "verification": "Listar V_N e V_T de uma gramática exemplo e justificar cada inclusão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas impressos",
                                    "Editor de texto para anotar regras",
                                    "Tabela de símbolos"
                                  ],
                                  "tips": "Procure padrões: Não-terminais geram outras regras; terminais são o alfabeto final.",
                                  "learningObjective": "Extrair com precisão os vocabulários V_N e V_T de uma GLC.",
                                  "commonMistakes": [
                                    "Incluir terminais em V_N",
                                    "Omitir não-terminais não iniciais",
                                    "Confundir ε (vazio) com terminal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar o símbolo inicial (S) e o conjunto de produções (P)",
                                  "subSteps": [
                                    "Localizar o símbolo inicial S, indicado explicitamente ou como o primeiro não-terminal.",
                                    "Listar todas as regras como pares A → α, numerando-as se necessário.",
                                    "Verificar que todas as regras seguem a forma de GLC (esquerda é único não-terminal).",
                                    "Confirmar que S tem pelo menos uma produção.",
                                    "Organizar P em formato legível, agrupando por não-terminal esquerdo."
                                  ],
                                  "verification": "Especificar S e enumerar todas as produções P de uma gramática dada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramar regras",
                                    "Ferramenta online de gramáticas (ex: JFLAP)"
                                  ],
                                  "tips": "S é sempre um não-terminal; verifique se há múltiplos 'starts' (inválido).",
                                  "learningObjective": "Reconhecer S e compilar P completa e corretamente.",
                                  "commonMistakes": [
                                    "Escolher S errado",
                                    "Omitir produções ε",
                                    "Listar regras duplicadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o papel de cada componente na geração de linguagens",
                                  "subSteps": [
                                    "Descrever V_N: Símbolos que se expandem via produções.",
                                    "Explicar V_T: Alfabeto das strings finais da linguagem.",
                                    "Detalhar S: Ponto de partida para derivações.",
                                    "Definir P: Regras que definem substituições permitidas.",
                                    "Derivar uma string exemplo usando os componentes para ilustrar."
                                  ],
                                  "verification": "Escrever parágrafos explicando cada componente e derivar uma palavra da linguagem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de gramática para derivação",
                                    "Árvore de derivação em papel"
                                  ],
                                  "tips": "Use derivações passo a passo para conectar componentes à linguagem gerada.",
                                  "learningObjective": "Articular funcionalmente como os componentes colaboram para definir L(G).",
                                  "commonMistakes": [
                                    "Subestimar papel de P na recursão",
                                    "Confundir geração com reconhecimento"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → a S b | ε. Componentes: V_N = {S}, V_T = {a, b}, S = 'S', P = {S → a S b, S → ε}. Gera palíndromos pares como ε, abba, aabbaa.",
                              "finalVerifications": [
                                "V_N listado corretamente sem omissões ou erros.",
                                "V_T inclui todos terminais e exclui não-terminais.",
                                "S identificado como o símbolo inicial único.",
                                "P contém todas regras exatas, sem duplicatas.",
                                "Explicação coerente dos papéis em geração de linguagem.",
                                "Derivação válida de pelo menos uma string usando componentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (90-100%).",
                                "Justificativa clara para cada conjunto extraído.",
                                "Explicações funcionais completas e sem ambiguidades.",
                                "Uso correto de notação padrão em todas listas.",
                                "Capacidade de derivar strings ilustrando os componentes.",
                                "Ausência de confusões entre terminais e não-terminais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos e Relações Recursivas.",
                                "Linguística: Análise Sintática e Estruturas Hierárquicas.",
                                "Engenharia de Software: Design de Parsers em Compiladores.",
                                "Inteligência Artificial: Modelagem de Linguagens Naturais.",
                                "Lógica: Sistemas de Reescrita e Provas por Indução."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens de programação (ex: Python, Java), gramáticas livres de contexto definem a sintaxe, permitindo que analisadores sintáticos identifiquem estrutura de código fonte para tradução em bytecode ou assembly."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Validar regras de produção em gramáticas livres de contexto",
                            "description": "Verificar se uma dada regra de produção segue a forma A → α, distinguindo gramáticas livres de contexto de outras classes como regulares ou sensíveis ao contexto, com exemplos de violações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal de regras de produção em gramáticas livres de contexto (GLC)",
                                  "subSteps": [
                                    "Leia a definição: Uma regra de produção em GLC tem a forma A → α, onde A é um não-terminal único e α é uma string (vazia ou não) de terminais e não-terminais.",
                                    "Estude os componentes: V_N (não-terminais), V_T (terminais), S (axioma), P (regras).",
                                    "Compare com outras gramáticas: Regulares (A → aB ou A → a), sensíveis ao contexto (αAβ → αγβ).",
                                    "Anote exemplos válidos: S → AB, A → a.",
                                    "Registre diferenças chave em uma tabela comparativa."
                                  ],
                                  "verification": "Recite a definição exata e dê 2 exemplos válidos sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (cap. Linguagens Formais)",
                                    "Folha de anotações",
                                    "Exemplos online de GLC"
                                  ],
                                  "tips": "Use mnemônicos: 'A' para um único não-terminal à esquerda, 'α' para qualquer coisa à direita.",
                                  "learningObjective": "Entender e recitar a forma canônica de regras em GLC e diferenciá-la de outras classes.",
                                  "commonMistakes": [
                                    "Confundir com regras regulares que só permitem um terminal ou terminal+não-terminal específico.",
                                    "Esquecer que α pode ser vazia (ε-produção)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o lado esquerdo da regra de produção",
                                  "subSteps": [
                                    "Identifique o lado esquerdo: Deve conter exatamente um não-terminal (ex: A, S, B).",
                                    "Verifique violações: Múltiplos símbolos (AB → α), terminais (a → α), ou strings vazias.",
                                    "Classifique símbolos: Use convenções maiúsculas para não-terminais, minúsculas para terminais.",
                                    "Pratique decompondo 3 regras: Escreva o que é inválido no lado esquerdo.",
                                    "Crie uma checklist: 1 símbolo? Não-terminal? Sem terminais?"
                                  ],
                                  "verification": "Analise 3 regras dadas e classifique o lado esquerdo como válido/inválido com justificativa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de 10 regras de exemplo (válidas e inválidas)",
                                    "Caneta e papel"
                                  ],
                                  "tips": "Sempre pergunte: 'O lado esquerdo é EXATAMENTE um não-terminal isolado?'",
                                  "learningObjective": "Identificar e justificar validade do lado esquerdo de uma regra.",
                                  "commonMistakes": [
                                    "Permitir terminais no lado esquerdo, confundindo com gramáticas sensíveis ao contexto.",
                                    "Aceitar múltiplos não-terminais como válidos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o lado direito da regra de produção",
                                  "subSteps": [
                                    "Examine α: Pode ser qualquer string de V_T* V_N* (incluindo ε).",
                                    "Verifique restrições: Sem limitações além da forma geral (diferente de regulares).",
                                    "Identifique tipos: Unitárias (A → B), ε-produções (A → ε), recursivas (A → aAb).",
                                    "Teste 4 exemplos: Classifique cada α e confirme compatibilidade com GLC.",
                                    "Diferencie: Regulares não permitem A → BC (dois não-terminais)."
                                  ],
                                  "verification": "Para 4 regras, descreva o lado direito e confirme se segue α arbitrária.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de regras regulares vs GLC",
                                    "Simulador online de gramáticas (opcional)"
                                  ],
                                  "tips": "Lembre: Em GLC, lado direito é 'livre' – qualquer combinação é ok, desde que lado esquerdo seja correto.",
                                  "learningObjective": "Validar o lado direito e contrastar com classes inferiores/superiores.",
                                  "commonMistakes": [
                                    "Restringir α a apenas terminais+não-terminais lineares, como em regulares.",
                                    "Confundir ε-produções como inválidas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar regras completas e identificar violações em gramáticas",
                                  "subSteps": [
                                    "Combine análises: Para uma regra completa, cheque lado esquerdo E direito.",
                                    "Analise gramáticas inteiras: Verifique TODAS as regras.",
                                    "Corrija violações: Converta AB → a em A → xB, B → y ou similar.",
                                    "Pratique com 2 gramáticas: Uma válida, uma com 3 violações.",
                                    "Documente: Escreva relatório de validação."
                                  ],
                                  "verification": "Valide uma gramática de 5 regras e liste correções necessárias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gramáticas de exemplo (geradas ou de livro)",
                                    "Template de relatório"
                                  ],
                                  "tips": "Procure violações sistemáticas: Sempre cheque esquerda primeiro.",
                                  "learningObjective": "Aplicar validação completa em conjuntos de regras e propor correções.",
                                  "commonMistakes": [
                                    "Ignorar regras unitárias como violações (são válidas em GLC).",
                                    "Não detectar múltiplas violações na mesma gramática."
                                  ]
                                }
                              ],
                              "practicalExample": "Regra dada: AB → aC. Violação: Lado esquerdo tem dois não-terminais (AB). Correção possível: A → aD, D → C (ou similar). Validação: Passo 2 falha → inválida para GLC.",
                              "finalVerifications": [
                                "Recitar forma A → α e dar 3 exemplos válidos/inválidos.",
                                "Analisar 5 regras isoladas com justificativa correta.",
                                "Validar uma gramática completa de 4-6 regras.",
                                "Diferenciar GLC de regular/sensível ao contexto em 2 casos.",
                                "Corrigir 3 violações propostas.",
                                "Explicar papel em parsing de linguagens."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de lado esquerdo (100% correto).",
                                "Correta classificação de α no lado direito.",
                                "Detecção de todas violações em gramáticas (sem falsos positivos).",
                                "Justificativas claras e referenciadas à definição formal.",
                                "Capacidade de correção válida para GLC.",
                                "Diferenciação precisa de classes de gramáticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de linguagens formais e autômatos.",
                                "Programação: Parsing em compiladores (ex: Yacc/Bison para CFGs).",
                                "Lógica: Provas formais e inferência em sistemas axiomáticos.",
                                "Engenharia de Software: Modelagem de sintaxe em DSLs."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens como Python/Java, gramáticas livres de contexto definem a sintaxe; validar regras garante parsers corretos que analisam código fonte sem ambiguidades."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Gerar derivações em gramáticas livres de contexto",
                            "description": "Aplicar sequências de substituições a partir do símbolo inicial para derivar palavras específicas, demonstrando derivações esquerdas, direitas e árvores de derivação sintática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática e identificar componentes essenciais",
                                  "subSteps": [
                                    "Analise a gramática livre de contexto (GLC) fornecida, identificando o símbolo inicial (S).",
                                    "Liste todas as regras de produção no formato A → α, onde A é um não-terminal e α é uma string de terminais e não-terminais.",
                                    "Defina a palavra alvo (w) que deve ser derivada, garantindo que ela pertença à linguagem gerada pela gramática.",
                                    "Crie uma tabela ou diagrama inicial com símbolos terminais (Σ), não-terminais (V) e regras.",
                                    "Verifique se a gramática está na forma padrão (ex: Chomsky Normal Form, se aplicável)."
                                  ],
                                  "verification": "Confirme que todos os componentes (S, regras, w) estão corretamente listados em uma tabela organizada sem erros tipográficos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplo de gramática impressa ou digital",
                                    "Ferramenta de desenho como Draw.io para diagramas"
                                  ],
                                  "tips": [
                                    "Comece sempre pelo símbolo inicial; numerar as regras facilita referências posteriores.",
                                    "Use cores para diferenciar terminais (azul) e não-terminais (vermelho)."
                                  ],
                                  "learningObjective": "Compreender e decompor os elementos fundamentais de uma GLC para derivações.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais.",
                                    "Esquecer de listar todas as regras de produção.",
                                    "Não especificar claramente a palavra alvo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar derivação esquerda passo a passo",
                                  "subSteps": [
                                    "Inicie com o símbolo inicial S.",
                                    "Aplique a regra de produção ao não-terminal mais à esquerda na string atual, substituindo-o pela direita da regra.",
                                    "Repita até obter a palavra alvo w, registrando cada string intermediária.",
                                    "Anote o número da regra usada em cada substituição.",
                                    "Pare quando a string for composta apenas por terminais e corresponder a w."
                                  ],
                                  "verification": "A sequência de strings começa com S e termina com w, com cada passo substituindo apenas o não-terminal esquerdo mais à esquerda.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Marcadores para destacar substituições",
                                    "Software como LaTeX ou Overleaf para notação formal"
                                  ],
                                  "tips": [
                                    "Mantenha as strings alinhadas verticalmente para visualizar a progressão.",
                                    "Se travar, volte e tente outra regra no passo anterior."
                                  ],
                                  "learningObjective": "Dominar o processo de derivação esquerda, aplicando substituições sequenciais do esquerdo para o direito.",
                                  "commonMistakes": [
                                    "Substituir o não-terminal errado (não o mais à esquerda).",
                                    "Aplicar múltiplas substituições em um passo.",
                                    "Gerar uma string que não leva a w."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar derivação direita e comparar com a esquerda",
                                  "subSteps": [
                                    "Reinicie com S e aplique a regra ao não-terminal mais à direita na string atual.",
                                    "Registre cada string intermediária e a regra usada, similar à derivação esquerda.",
                                    "Continue até derivar w, anotando diferenças na sequência de regras.",
                                    "Compare as duas derivações lado a lado, destacando strings comuns e divergências.",
                                    "Calcule o número de passos em cada uma."
                                  ],
                                  "verification": "Ambas as derivações terminam em w, com substituições corretas (esquerda no esquerdo, direita no direito).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Duas colunas em uma planilha (Google Sheets ou Excel)",
                                    "Exemplos de derivações prévias para referência"
                                  ],
                                  "tips": [
                                    "Derivações direitas tendem a expandir o final primeiro; visualize como 'crescimento pela direita'.",
                                    "Use setas → para indicar substituições."
                                  ],
                                  "learningObjective": "Executar e contrastar derivações esquerda e direita, entendendo suas equivalências.",
                                  "commonMistakes": [
                                    "Confundir ordem de substituição entre esquerda e direita.",
                                    "Não registrar regras usadas, dificultando rastreamento.",
                                    "Assumir que são idênticas sem verificar."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e analisar a árvore de derivação sintática",
                                  "subSteps": [
                                    "Use uma das derivações (esquerda ou direita) como base para a árvore.",
                                    "Desenhe o nó raiz como S, com filhos correspondendo à regra aplicada (esquerda para direita).",
                                    "Expanda recursivamente para cada não-terminal, até folhas serem terminais formando w.",
                                    "Rotule arestas com regras usadas e verifique se a fronteira de folhas é w.",
                                    "Anote propriedades como ambiguidade se múltiplas árvores existirem."
                                  ],
                                  "verification": "A árvore reproduz a derivação linear e a leitura das folhas da esquerda para direita é w.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação como Lucidchart ou papel com régua",
                                    "Imagens de árvores de derivação de exemplo"
                                  ],
                                  "tips": [
                                    "Mantenha a árvore balanceada; use ramificações horizontais para clareza.",
                                    "Valide sub-árvores independentemente."
                                  ],
                                  "learningObjective": "Representar derivações graficamente via árvores sintáticas, facilitando análise estrutural.",
                                  "commonMistakes": [
                                    "Ordem errada nos filhos (não seguir esquerda-direita da regra).",
                                    "Esquecer rótulos de regras nas arestas.",
                                    "Folhas não formando exatamente w."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar completude e explorar variações",
                                  "subSteps": [
                                    "Confira se todas as derivações geram w sem loops infinitos.",
                                    "Teste com uma palavra diferente da linguagem para mostrar falha.",
                                    "Identifique se a gramática é ambígua (múltiplas derivações para w).",
                                    "Otimize uma derivação mais curta se possível.",
                                    "Documente insights sobre o processo."
                                  ],
                                  "verification": "Relatório escrito confirma derivações corretas, com pelo menos um teste negativo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook para relatório",
                                    "Lista de palavras na linguagem L(G)"
                                  ],
                                  "tips": [
                                    "Use teorema do pumping para palavras longas se aplicável.",
                                    "Registre tempo gasto por derivação."
                                  ],
                                  "learningObjective": "Validar derivações e reconhecer limitações/ambiguidade em GLCs.",
                                  "commonMistakes": [
                                    "Ignorar ambiguidade.",
                                    "Não testar casos negativos.",
                                    "Aceitar derivações incompletas."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a GLC S → aSb | ε, gerando {a^n b^n | n ≥ 0}. Derive 'aabb' (n=2):\nDerivação esquerda: S ⇒ aSb ⇒ aaSbb ⇒ aabb.\nDerivação direita: S ⇒ aSb ⇒ aεb ⇒ ab (errado? Não: S ⇒ aSb ⇒ aSb b? Correto: S ⇒ a S b ⇒ a (a S b) b ⇒ a a S b b ⇒ a a ε b b ⇒ aabb.\nÁrvore: S\n /   \\\n a    S b\n     /   \\\n    a     S b\n        /   \\\n       ε     (folhas: a a ε b b → aabb).",
                              "finalVerifications": [
                                "Derivação esquerda completa e correta para w.",
                                "Derivação direita alternativa válida.",
                                "Árvore de derivação com folhas exatas de w.",
                                "Todas as regras usadas existem na gramática.",
                                "Nenhum loop infinito ou derivação inválida.",
                                "Identificação correta de ambiguidade, se presente.",
                                "Teste com palavra fora da linguagem falha adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas substituições (100% corretas).",
                                "Completude: todas três representações (esq, dir, árvore).",
                                "Clareza na documentação (diagramas legíveis).",
                                "Eficiência: derivações mínimas em passos.",
                                "Análise de erros e ambiguidade.",
                                "Tempo de execução dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Estruturas sintáticas em gramáticas gerativas (Chomsky).",
                                "Programação: Parsing em compiladores (ex: YACC/Bison para árvores sintáticas).",
                                "Matemática: Árvores e grafos em teoria dos autômatos.",
                                "Inteligência Artificial: Análise de linguagem natural e parsing probabilístico.",
                                "Engenharia de Software: Geração de código e validação de expressões."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, derivações e árvores sintáticas são usadas por parsers (ex: LL/LR) para validar e analisar código fonte, detectando erros sintáticos em linguagens como Python ou Java, essencial para IDEs e ferramentas de desenvolvimento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Linguagens Livres de Contexto",
                        "description": "Família de linguagens geradas por gramáticas livres de contexto (tipo 2), que incluem linguagens não-regulares como {a^n b^n | n ≥ 0} e palíndromos, com propriedades de fechamento sob união, concatenação e estrelas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Definir e exemplificar linguagens livres de contexto",
                            "description": "Descrever formalmente L(G) para uma gramática G e fornecer exemplos clássicos como linguagens de parênteses balanceados ou {ww^R | w em {a,b}*}, contrastando com linguagens regulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal de linguagens livres de contexto",
                                  "subSteps": [
                                    "Estude a definição de gramática livre de contexto (GLC) segundo Chomsky tipo 2: G = (V, Σ, P, S).",
                                    "Aprenda que L(G) é o conjunto de todas as palavras geradas por derivações a partir do axioma S.",
                                    "Revise os tipos de gramáticas e posicione as GLC entre regulares (tipo 3) e sensíveis ao contexto (tipo 1).",
                                    "Analise propriedades chave: não determinísticas, reconhecidas por pushdown automata.",
                                    "Pratique identificando se uma gramática é livre de contexto."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição de L(G) e dê um exemplo simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introdução à Teoria da Computação' de Sipser",
                                    "Wikipedia: Linguagem livre de contexto",
                                    "Ferramenta JFLAP para simulações"
                                  ],
                                  "tips": "Use diagramas de Chomsky normal form para visualizar regras.",
                                  "learningObjective": "Definir formalmente linguagens livres de contexto e sua geração por gramáticas.",
                                  "commonMistakes": [
                                    "Confundir com linguagens regulares",
                                    "Esquecer o não-terminal inicial S",
                                    "Ignorar o alfabeto terminal Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e descrever L(G) para gramática de parênteses balanceados",
                                  "subSteps": [
                                    "Defina a gramática: S → (S) | SS | ε.",
                                    "Gere derivações para strings como (), (()), ()(()).",
                                    "Descreva formalmente L(G) = { w ∈ {(,)}* | w tem parênteses balanceados }.",
                                    "Desenhe árvores de derivação para pelo menos 3 strings.",
                                    "Prove que strings como (() não pertencem a L(G)."
                                  ],
                                  "verification": "Produza derivações completas para 3 strings e explique por que uma inválida falha.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para árvores",
                                    "JFLAP ou online parser generator",
                                    "Notas de aula sobre derivações"
                                  ],
                                  "tips": "Comece com strings curtas e expanda recursivamente.",
                                  "learningObjective": "Descrever L(G) e exemplificar com parênteses balanceados.",
                                  "commonMistakes": [
                                    "Permitir ε em contextos errados",
                                    "Confundir recursão esquerda/direita",
                                    "Gerar strings não balanceadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Exemplificar com a linguagem {ww^R | w ∈ {a,b}*}",
                                  "subSteps": [
                                    "Entenda ww^R como palíndromos pares: w seguido do reverso.",
                                    "Construa gramática: S → aSa | bSb | ε | a a | b b (ajustar para pares).",
                                    "Gramática padrão: S → ε | a S a | b S b.",
                                    "Gere exemplos: ε, aa, aba, abba, etc.",
                                    "Descreva L(G) = { ww^R | w ∈ {a,b}^* }."
                                  ],
                                  "verification": "Gere 4 strings em L(G) com derivações e 1 fora dela.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de texto para gramáticas",
                                    "JFLAP para PDA simulação",
                                    "Exemplos online de CFLs"
                                  ],
                                  "tips": "Pense na pilha do PDA empilhando w e desempilhando w^R.",
                                  "learningObjective": "Construir gramática e descrever L(G) para ww^R.",
                                  "commonMistakes": [
                                    "Confundir com palíndromos ímpares",
                                    "Regras que geram w w em vez de ww^R",
                                    "Esquecer casos vazios"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar linguagens livres de contexto com regulares",
                                  "subSteps": [
                                    "Revise linguagens regulares: reconhecidas por autômatos finitos, geradas por expressões regulares.",
                                    "Use teorema da bombeamento para provar que parênteses balanceados não é regular.",
                                    "Mostre que ww^R requer memória (pilha), não finita.",
                                    "Compare expressões regulares vs. gramáticas para exemplos simples.",
                                    "Discuta hierarquia de Chomsky."
                                  ],
                                  "verification": "Explique por que um exemplo CFL não é regular, com prova de bombeamento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Sipser capítulos 1-2",
                                    "Ferramentas de autômatos online",
                                    "Vídeos Khan Academy sobre linguagens formais"
                                  ],
                                  "tips": "Aplique bombeamento em posições críticas como centro de ww^R.",
                                  "learningObjective": "Contrastar CFLs com regulares usando teoremas e exemplos.",
                                  "commonMistakes": [
                                    "Achar que toda CFL recursiva é regular",
                                    "Mal aplicar teorema da bombeamento",
                                    "Ignorar contraexemplos"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa a gramática G = ({S}, {a,b}, {S → a S a | b S b | ε}, S) e mostre a derivação para 'abba': S ⇒ a S a ⇒ a b S b a ⇒ a b ε b a = abba. Verifique que é ww^R com w=ab.",
                              "finalVerifications": [
                                "Defina corretamente L(G) para uma gramática dada.",
                                "Gere derivações válidas para parênteses balanceados.",
                                "Construa gramática para ww^R e prove propriedades.",
                                "Aplique teorema da bombeamento para mostrar não-regularidade.",
                                "Distinga exemplos CFL de regulares.",
                                "Descreva PDA para reconhecimento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de L(G) (20%)",
                                "Correção das derivações e árvores (25%)",
                                "Qualidade dos exemplos clássicos (20%)",
                                "Profundidade no contraste com regulares (20%)",
                                "Clareza na descrição e provas (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Análise sintática de frases naturais.",
                                "Engenharia de Software: Parsers em compiladores (Yacc/Bison).",
                                "Biologia Computacional: Estruturas secundárias de RNA.",
                                "Matemática: Teoria de autômatos e semigrupos.",
                                "Inteligência Artificial: Parsing em PLN."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores e interpretadores de linguagens de programação, validação de XML/HTML balanceados, análise de estruturas em bioinformática como dobras de proteínas/RNA, e processamento de expressões matemáticas em calculadoras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Listar propriedades de fechamento das linguagens livres de contexto",
                            "description": "Explicar o fechamento sob união, concatenação, inversa e homomorfismo livre, mas não sob interseção ou complemento, com contraexemplos para operações não fechadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de propriedades de fechamento",
                                  "subSteps": [
                                    "Defina propriedades de fechamento para uma família de linguagens como CFLs.",
                                    "Explique que uma classe é fechada sob uma operação se o resultado da operação entre linguagens da classe ainda pertence à classe.",
                                    "Revise definições básicas de linguagens livres de contexto (CFLs) e gramáticas livres de contexto (CFLGs).",
                                    "Liste as operações principais: união, concatenação, inversa, homomorfismo livre, interseção e complemento.",
                                    "Diferencie propriedades de fechamento de não-fechamento com exemplos simples."
                                  ],
                                  "verification": "Escreva uma definição precisa e identifique pelo menos 4 operações, classificando-as como fechadas ou não para CFLs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre linguagens formais",
                                    "Livro texto de Teoria da Computação (ex: Sipser)",
                                    "Quadro ou papel para anotações"
                                  ],
                                  "tips": "Use diagramas de conjuntos para visualizar o fechamento: se L1, L2 ∈ CFL, então op(L1,L2) ∈ CFL?",
                                  "learningObjective": "Dominar o conceito fundamental de closure properties aplicado a CFLs.",
                                  "commonMistakes": "Confundir fechamento com a operação ser total ou com propriedades de linguagens regulares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar fechamento sob união e concatenação",
                                  "subSteps": [
                                    "Construa uma gramática para a união de duas CFLs: introduza novo não-terminal S → S1 | S2.",
                                    "Construa uma gramática para concatenação: S → S1 S2, preservando não-termnais.",
                                    "Verifique com exemplo: L1 = {a^n b^n | n ≥ 0}, L2 = {c^m d^m | m ≥ 0}; mostre gramáticas resultantes.",
                                    "Prove informalmente usando pushdown automata (PDA): simule as duas linguagens em sequência ou alternância.",
                                    "Teste com strings geradas para validar."
                                  ],
                                  "verification": "Construa gramáticas explícitas para união e concatenação de L1 e L2, e derive uma string de cada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de texto para gramáticas",
                                    "Simulador de PDA online (ex: JFLAP)",
                                    "Exemplos de gramáticas pré-escritas"
                                  ],
                                  "tips": "Sempre comece com os axiomas S e preserve a estrutura original das gramáticas.",
                                  "learningObjective": "Construir e validar gramáticas para operações de fechamento sob união e concatenação.",
                                  "commonMistakes": "Esquecer de renomear não-termnais para evitar conflitos ou gerar ambiguidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar fechamento sob inversa e homomorfismo livre",
                                  "subSteps": [
                                    "Explique inversa: se L é CFL, então L^R = {w^R | w ∈ L} é CFL; inverta regras da gramática.",
                                    "Para homomorfismo livre h: construa gramática onde cada produção A → α vira A → h(α), com h(a) terminal ou A → ε | terminal.",
                                    "Exemplo: L = {a^n b^n}, h(a)=ab, h(b)=BA; construa gramática equivalente.",
                                    "Use PDA para inversa: inverta a pilha e transições.",
                                    "Valide com derivações invertidas ou aplicadas."
                                  ],
                                  "verification": "Inverta uma gramática dada e aplique um homomorfismo simples, gerando uma string válida.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "JFLAP ou simulador de gramáticas",
                                    "Lista de homomorfismos de exemplo",
                                    "Papel para derivações"
                                  ],
                                  "tips": "Para inversa, leia regras da direita para esquerda; teste com palíndromos.",
                                  "learningObjective": "Entender e construir equivalências para inversa e homomorfismo livre em CFLs.",
                                  "commonMistakes": "Aplicar homomorfismo não-livre (com variáveis intermediárias) ou inverter incorretamente ε-produções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar não-fechamento sob interseção e complemento com contraexemplos",
                                  "subSteps": [
                                    "Mostre que CFLs não são fechadas sob interseção: L1 = {a^n b^n c^*}, L2 = {a^* b^n c^n}; L1 ∩ L2 = {a^n b^n c^n} não-CFL (pumping lemma).",
                                    "Para complemento: se CFLs fechadas sob complemento, seriam sob interseção (De Morgan), mas não são; exemplo {ww | w ∈ {a,b}^*}^c não-CFL.",
                                    "Aplique pumping lemma para provar que os contraexemplos não são CFLs.",
                                    "Discuta implicações: PDAs não simulam interseção facilmente.",
                                    "Liste formalmente as propriedades."
                                  ],
                                  "verification": "Forneça contraexemplos explícitos e aplique pumping lemma a pelo menos um.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Provas do pumping lemma",
                                    "Ferramenta para testar membership (opcional)",
                                    "Notas sobre teoremas de não-fechamento"
                                  ],
                                  "tips": "Memorize {a^n b^n c^n} como contraexemplo clássico; pratique pumping lemma com passos numerados.",
                                  "learningObjective": "Identificar e provar operações não-fechadas usando contraexemplos rigorosos.",
                                  "commonMistakes": "Usar linguagens regulares como contraexemplos ou falhar na aplicação correta do pumping lemma."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e listar todas as propriedades de fechamento",
                                  "subSteps": [
                                    "Compile uma tabela: operação | fechada? | justificativa/contratexemplo.",
                                    "Liste: fechadas (união, concatenação, inversa, homomorfismo livre); não (interseção, complemento).",
                                    "Crie um fluxograma de decisão para propriedades de CFLs.",
                                    "Resolva exercícios: classifique novas operações ou verifique exemplos.",
                                    "Autoavalie com quiz interno."
                                  ],
                                  "verification": "Escreva a lista completa com uma justificativa curta para cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou tabela em editor de texto",
                                    "Exercícios de revisão"
                                  ],
                                  "tips": "Use mnemônicos: U(nião), C(oncatenação), I(nversa), H(omomorfismo) = fechadas.",
                                  "learningObjective": "Listar precisamente todas as propriedades de fechamento das CFLs.",
                                  "commonMistakes": "Esquecer homomorfismo livre ou confundir com linguagens regulares."
                                }
                              ],
                              "practicalExample": "Considere L1 = {a^n b^n | n ≥ 0} e L2 = {c^m d^m | m ≥ 0}, ambas CFLs. União: nova gramática S → A | C (com A e C para L1,L2). Concatenação: S → A C. Inversa de L1: S → a S b | ε. Interseção simulada como L3 = {a^n b^n c^n} (não CFL, provado por pumping). Complemento de {ww} leva a não-CFL.",
                              "finalVerifications": [
                                "Liste corretamente as 4 operações de fechamento sem erros.",
                                "Forneça contraexemplo válido para interseção com prova via pumping lemma.",
                                "Construa gramática para união ou concatenação de dois exemplos dados.",
                                "Explique por que complemento implica interseção via De Morgan.",
                                "Classifique corretamente homomorfismo livre vs geral.",
                                "Gere uma string válida de uma operação fechada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na lista de propriedades fechadas e não-fechadas (100% correto).",
                                "Qualidade dos contraexemplos e aplicação do pumping lemma (rigorosa).",
                                "Correção das construções de gramáticas para operações fechadas.",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Criatividade em exemplos práticos e conexões.",
                                "Clareza na tabela ou lista final de propriedades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e álgebra (fechamentos sob operações).",
                                "Lógica: Propriedades de classes de complexidade (análoga a NP, P).",
                                "Programação: Parsing em compiladores (CYK para CFLs).",
                                "Engenharia de Software: Modelagem de linguagens de especificação."
                              ],
                              "realWorldApplication": "Em compiladores, entender closure de CFLs permite otimizar analisadores sintáticos (parsers) para linguagens de programação, combinando regras de gramáticas via união/concatenação sem perder eficiência, enquanto evita armadilhas como interseções em validações complexas de código."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Aplicar teorema do bombeamento para linguagens livres de contexto",
                            "description": "Usar o lema do bombeamento de Bar-Hillel, Peters e Shamir para provar que certas linguagens são livres de contexto ou para bombeamento em palavras longas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Enunciado do Lema do Bombeamento para Linguagens Livres de Contexto",
                                  "subSteps": [
                                    "Leia e memorize o enunciado exato do lema de Bar-Hillel, Peters e Shamir: Para toda CFL L, existe um comprimento de bombeamento p tal que para toda palavra w ∈ L com |w| ≥ p, w = uvxyz onde |vy| ≥ 1, |vxy| ≤ p, e ∀ i ≥ 0, uv^i x y^i z ∈ L.",
                                    "Identifique os componentes chave: p (comprimento de bombeamento), divisão em cinco partes (u, v, x, y, z), condições |vy| > 0 e |vxy| ≤ p.",
                                    "Compare com o lema de bombeamento para linguagens regulares para destacar diferenças (5 partes vs 3, condições diferentes).",
                                    "Escreva o lema em suas próprias palavras e verifique contra fontes confiáveis.",
                                    "Resolva exercícios simples de reescrita do lema."
                                  ],
                                  "verification": "Escreva o lema completo sem consultar notas e explique cada condição verbalmente ou por escrito.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser ou Hopcroft/Ullman)",
                                    "Notas de aula sobre linguagens livres de contexto",
                                    "Vídeo tutorial sobre pumping lemma for CFLs"
                                  ],
                                  "tips": [
                                    "Use mnemônicos como 'uvxyz' para lembrar a divisão em 5 partes.",
                                    "Desenhe diagramas da divisão de w para visualizar."
                                  ],
                                  "learningObjective": "Dominar o enunciado preciso e as condições do lema do bombeamento para CFLs.",
                                  "commonMistakes": [
                                    "Confundir com pumping lemma para regulares (xyz vs uvxyz).",
                                    "Esquecer |vy| > 0 ou |vxy| ≤ p.",
                                    "Achar que prova que L é CFL (é só necessário, não suficiente)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Estrutura de Prova para Mostrar que uma Linguagem NÃO é CFL",
                                  "subSteps": [
                                    "Assuma por contradição que L é CFL, então existe p.",
                                    "Escolha uma palavra w ∈ L com |w| ≥ p (geralmente w = a^n b^n c^n com n grande).",
                                    "Considere todas as 5! = 120 casos possíveis de onde vxy pode cair (posições de v, x, y nas partes de w).",
                                    "Para cada caso, mostre que existe i tal que uv^i x y^i z ∉ L (ex: i=0 ou i=2).",
                                    "Conclua que a suposição é falsa, logo L não é CFL.",
                                    "Pratique outline da prova sem exemplo específico."
                                  ],
                                  "verification": "Esboce a estrutura geral de prova para uma linguagem qualquer e identifique os passos chave.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplos de provas em livros ou online (ex: {a^n b^n c^n})",
                                    "Papel e caneta para diagramas de casos",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": [
                                    "Agrupe casos similares (ex: vxy todo em a's) para reduzir de 120 para ~10 grupos.",
                                    "Sempre escolha w com partes distintas para facilitar casos."
                                  ],
                                  "learningObjective": "Masterizar o método de prova por contradição usando o lema.",
                                  "commonMistakes": [
                                    "Não cobrir TODOS os casos possíveis de divisão.",
                                    "Escolher w ∉ L ou |w| < p.",
                                    "Erros em i=0 removendo vy corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Lema em Exemplos Clássicos",
                                  "subSteps": [
                                    "Prove que L1 = {a^n b^n c^n | n ≥ 0} não é CFL: escolha w = a^p b^p c^p, analise casos.",
                                    "Prove que L2 = {ww | w ∈ {a,b}*} não é CFL: w = a^p b^p a^p b^p.",
                                    "Tente (e falhe corretamente) em L3 = {a^n b^n | n ≥ 0}, que É CFL, para ver por que não contradiz.",
                                    "Registre os casos principais e os i que quebram cada um.",
                                    "Resolva 2-3 exemplos adicionais independentes."
                                  ],
                                  "verification": "Escreva provas completas para L1 e L2, checadas por pares ou auto-revisão.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Lista de linguagens não-CFL padrão",
                                    "Solução modelo de pelo menos um exemplo",
                                    "Fórum ou tutor para dúvidas"
                                  ],
                                  "tips": [
                                    "Use subscritos para contar símbolos após bombeamento (ex: número de a's = p + 2|v|).",
                                    "Teste i=2 para desbalancear contagens."
                                  ],
                                  "learningObjective": "Executar provas concretas com confiança em exemplos padrão.",
                                  "commonMistakes": [
                                    "Ignorar casos onde x é vazio ou vy cruza fronteiras.",
                                    "Não verificar que uv^i x y^i z realmente ∉ L.",
                                    "Confundir contagens de símbolos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Aplicações Avançadas e Verificações",
                                  "subSteps": [
                                    "Prove para uma linguagem dada pelo professor ou aleatória (ex: {a^n b^m c^n d^m}).",
                                    "Use o lema positivamente: dado w longa, encontre decomposição uvxyz válida.",
                                    "Crie sua própria linguagem não-CFL e prove.",
                                    "Revise erros comuns de provas anteriores.",
                                    "Discuta limitações do lema (não útil para todas não-CFLs)."
                                  ],
                                  "verification": "Resolva 3 problemas novos sem ajuda e acerte pelo menos 80%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Problemas de exercícios de livros ou sites como StackExchange",
                                    "Timer para simular exame",
                                    "Grupo de estudo virtual"
                                  ],
                                  "tips": [
                                    "Para aplicações positivas, escolha v=y=parte repetida, x=centro.",
                                    "Sempre generalize n > p grande o suficiente."
                                  ],
                                  "learningObjective": "Aplicar o lema de forma independente em contextos variados.",
                                  "commonMistakes": [
                                    "Achar que lema prova CFL (não faz).",
                                    "Erros aritméticos em contagens.",
                                    "Casos incompletos em provas complexas."
                                  ]
                                }
                              ],
                              "practicalExample": "Para provar que L = {a^n b^n c^n | n ≥ 0} não é CFL: Tome p o comprimento de bombeamento. Escolha w = a^p b^p c^p ∈ L. Divida w = uvxyz com |vxy| ≤ p, |vy| ≥ 1. Casos: Se vxy em a's, bombe i=2 → mais a's que b's/c's. Similar para outros blocos ou cruzamentos. Todos levam a desigualdades, contradição.",
                              "finalVerifications": [
                                "Enuncie o lema corretamente incluindo todas condições.",
                                "Prove corretamente que {a^n b^n c^n} não é CFL cobrindo casos principais.",
                                "Identifique por que {a^n b^n} não contradiz o lema.",
                                "Aplique o lema a uma nova linguagem com sucesso.",
                                "Explique diferenças com pumping lemma regular.",
                                "Crie um contraexemplo pessoal válido."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado do lema (todas condições corretas).",
                                "Cobertura completa de casos na prova por contradição.",
                                "Correção nas contagens de símbolos após bombeamento.",
                                "Escolha apropriada de w (∈ L, |w| ≥ p, simétrico).",
                                "Conclusão lógica sem falácias.",
                                "Clareza na escrita e diagramas.",
                                "Tratamento de casos edge (v ou y vazios onde permitido)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Prova por contradição e indução em contagens.",
                                "Lógica: Raciocínio contrapositivo e quantificadores (∀, ∃).",
                                "Algoritmos: Análise de complexidade em parsing de linguagens.",
                                "Linguística Computacional: Modelagem de sintaxe natural.",
                                "Programação: Verificação de propriedades em geradores de linguagens."
                              ],
                              "realWorldApplication": "Em compiladores, usar para provar que certas construções de programação (ex: aninhamento balanceado complexo) requerem mais que gramáticas livres de contexto, guiando design de parsers; em verificação formal de software, analisar linguagens de especificação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Autômatos de Pilha para Reconhecimento",
                        "description": "Modelos de computação com fita de entrada, estados, alfabeto de pilha e transições que empilham/desempilham, equivalentes às linguagens livres de contexto via PDAs não-determinísticos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Descrever a estrutura formal de um autômato de pilha",
                            "description": "Definir os componentes de um AP (Q, Σ, Γ, δ, q0, Z0, F), explicando transições da forma (p, a, X) → (q, α) e o papel da pilha como memória ilimitada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o Conjunto de Estados e o Estado Inicial",
                                  "subSteps": [
                                    "Defina Q como o conjunto finito de estados do autômato.",
                                    "Especifique q0 como o estado inicial único.",
                                    "Explique que Q inclui estados de controle que determinam o comportamento do autômato.",
                                    "Liste exemplos de estados como q_start, q_accept, q_reject.",
                                    "Desenhe um diagrama simples mostrando transições entre estados."
                                  ],
                                  "verification": "Liste corretamente Q e q0 em uma definição formal e desenhe um grafo com pelo menos 3 estados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Livro de Teoria da Computação (capítulo de autômatos)"
                                  ],
                                  "tips": "Comece sempre pelo estado inicial para contextualizar o fluxo.",
                                  "learningObjective": "Compreender o papel dos estados como controladores do processamento.",
                                  "commonMistakes": [
                                    "Confundir estados com símbolos da pilha",
                                    "Esquecer que q0 é único"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Alfabetos de Entrada e Pilha",
                                  "subSteps": [
                                    "Defina Σ como o alfabeto finito de símbolos de entrada.",
                                    "Defina Γ como o alfabeto finito da pilha, onde Γ ⊇ Σ.",
                                    "Introduza Z0 como o símbolo inicial da pilha (bottom marker).",
                                    "Explique que a pilha inicia com Z0 no fundo.",
                                    "Diferencie Σ (entrada lida da fita) de Γ (símbolos empilháveis)."
                                  ],
                                  "verification": "Escreva as definições formais de Σ, Γ e Z0, e explique a relação entre eles.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Quadro branco ou editor de texto para símbolos",
                                    "Exemplos de linguagens livres de contexto"
                                  ],
                                  "tips": "Use notação de conjuntos: Σ = {a, b}, Γ = {a, b, Z0}.",
                                  "learningObjective": "Entender como os alfabetos suportam a entrada e a memória da pilha.",
                                  "commonMistakes": [
                                    "Ignorar que Γ inclui símbolos extras além de Σ",
                                    "Confundir Z0 com estado inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Função de Transição δ",
                                  "subSteps": [
                                    "Defina δ: Q × (Σ ∪ {ε}) × Γ → 2^{Q × Γ*}, onde Γ* é sequências finitas de Γ.",
                                    "Descreva a forma de transição: δ(p, a, X) = {(q1, α1), (q2, α2), ...}.",
                                    "Explique operações na pilha: pop (remover X), push (empilhar α após pop).",
                                    "Inclua transições ε (sem ler entrada ou pop).",
                                    "Escreva um exemplo: δ(q, a, A) = {(p, BC)} significa pop A, push BC, ir para p."
                                  ],
                                  "verification": "Escreva δ para um autômato simples com 2-3 transições e simule uma delas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de simulação de PDA online (ex: JFLAP)",
                                    "Papel para tabelas de transição"
                                  ],
                                  "tips": "Lembre-se: transição consome entrada, pop da pilha e push de string.",
                                  "learningObjective": "Dominar a notação e mecânica das transições com pilha.",
                                  "commonMistakes": [
                                    "Esquecer o poder 2^ para não-determinismo",
                                    "Confundir pop com push"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever Estados Finais e o Papel da Pilha",
                                  "subSteps": [
                                    "Defina F ⊆ Q como o conjunto de estados de aceitação.",
                                    "Explique aceitação por estado final (pilha pode sobrar).",
                                    "Discuta a pilha como memória LIFO ilimitada para linguagens livres de contexto.",
                                    "Compare com autômato finito (sem pilha: só linguagens regulares).",
                                    "Monte a definição completa: AP = (Q, Σ, Γ, δ, q0, Z0, F)."
                                  ],
                                  "verification": "Escreva a tupla completa de um AP exemplo e explique o papel da pilha em uma linguagem não-regular.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JFLAP ou simulador similar",
                                    "Exemplos de linguagens {a^n b^n | n ≥ 0}"
                                  ],
                                  "tips": "A pilha permite contar aninhamentos, como parênteses balanceados.",
                                  "learningObjective": "Integrar todos componentes e destacar poder da pilha.",
                                  "commonMistakes": [
                                    "Confundir aceitação por estado final vs. pilha vazia",
                                    "Subestimar não-determinismo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para reconhecer {a^n b^n | n ≥ 0}: Q = {q0, q1, q2}, Σ = {a,b}, Γ = {a,b,Z0}, δ(q0,a,Z0)={(q0, aZ0)}, δ(q0,b,a)={(q1, ε)}, etc. Simule entrada 'aabbb': empilha a's, desempilha com b's, aceita em q2.",
                              "finalVerifications": [
                                "Pode listar e definir todos os 7 componentes de um AP corretamente?",
                                "Consegue escrever uma transição δ(p, a, X) → (q, α) com exemplo?",
                                "Explica o papel da pilha como memória LIFO ilimitada?",
                                "Diferencia AP de AFD corretamente?",
                                "Simula uma transição simples em um PDA exemplo?",
                                "Identifica linguagens reconhecíveis por AP (ex: livres de contexto)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal (tupla e δ correta).",
                                "Completude: todos componentes explicados.",
                                "Clareza na distinção de entrada vs. pilha.",
                                "Correta descrição de não-determinismo e ε-transições.",
                                "Uso de exemplos concretos para ilustrar conceitos.",
                                "Compreensão do poder expressivo da pilha."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (Q, Σ, Γ como conjuntos finitos) e Relações (δ como função parcial).",
                                "Lógica: Não-determinismo similar a ramificações lógicas em programação.",
                                "Engenharia de Software: Parsing em compiladores usa PDAs para gramáticas livres de contexto.",
                                "Física: Modelos de pilha como stacks em simulações de sistemas LIFO (ex: pilhas de discos).",
                                "Linguística: Análise sintática de linguagens naturais com estruturas aninhadas."
                              ],
                              "realWorldApplication": "Compiladores usam PDAs para análise sintática de código-fonte (parsing de expressões aninhadas como parênteses ou blocos if-else), validadores de XML/JSON para estruturas balanceadas, e simuladores de recursão em linguagens de programação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Construir autômatos de pilha para linguagens livres de contexto",
                            "description": "Projetar APND para linguagens como {a^n b^n | n ≥ 0} ou palíndromos, detalhando o uso da pilha para contar aninhamentos ou simetria.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Linguagem e Identificar o Papel da Pilha",
                                  "subSteps": [
                                    "Leia a definição formal da linguagem livre de contexto (ex: {a^n b^n | n ≥ 0} ou palíndromos).",
                                    "Gere 5-10 strings de exemplo válidas e inválidas para entender o padrão.",
                                    "Identifique o que requer memória não-finita, como contagem de aninhamentos ou simetria.",
                                    "Defina o alfabeto de entrada Σ, símbolos de pilha Γ e o símbolo inicial Z0.",
                                    "Esboce os estados iniciais necessários (q0, estados de empilhamento, desempilhamento)."
                                  ],
                                  "verification": "Lista completa de Σ, Γ, Z0 e pelo menos 3 estados iniciais documentados com exemplos de strings.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Editor de texto ou draw.io para diagramas",
                                    "Referência de linguagens livres de contexto"
                                  ],
                                  "tips": [
                                    "Comece com linguagens simples como {a^n b^n} antes de palíndromos.",
                                    "Use tabelas para listar strings de teste."
                                  ],
                                  "learningObjective": "Reconhecer padrões que demandam pilha para reconhecimento.",
                                  "commonMistakes": [
                                    "Confundir Σ com Γ.",
                                    "Ignorar o símbolo inicial Z0.",
                                    "Não gerar contraexemplos inválidos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Estados e Transições Básicas",
                                  "subSteps": [
                                    "Liste todos os estados Q, incluindo q0, q_accept, q_reject e intermediários.",
                                    "Defina a função de transição δ inicial para leitura sem pilha (ex: mover para estado de empilhamento ao ler 'a').",
                                    "Inclua transições epsilon (sem ler entrada) se necessário para manipular pilha.",
                                    "Garanta que o APND seja determinístico (APND).",
                                    "Desenhe um diagrama parcial dos estados."
                                  ],
                                  "verification": "Diagrama com estados Q, q0 marcado e pelo menos 2 transições iniciais definidas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta JFLAP ou papel milimetrado",
                                    "Tabela de transições em planilha"
                                  ],
                                  "tips": [
                                    "Mantenha poucos estados (3-6) para simplicidade.",
                                    "Rotule transições como (leitura, pop/empilha, novo_estado)."
                                  ],
                                  "learningObjective": "Estruturar formalmente os componentes de um APND.",
                                  "commonMistakes": [
                                    "Estados excessivos desnecessários.",
                                    "Esquecer transições para reject.",
                                    "Transições não determinísticas acidentais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar Transições de Empilhamento e Desempilhamento",
                                  "subSteps": [
                                    "Para empilhamento: defina δ(q, a, Z0) = (q_push, A Z0) para {a^n b^n}.",
                                    "Para desempilhamento: δ(q_push, b, A) = (q_pop, Z0) ou similar.",
                                    "Adapte para palíndromos: empilhe primeira metade até centro, depois match reverso.",
                                    "Inclua verificação de pilha vazia ou overflow.",
                                    "Atualize o diagrama com todas as transições principais."
                                  ],
                                  "verification": "Todas transições de push/pop definidas e diagramadas para o exemplo específico.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "JFLAP para simulação",
                                    "Exemplos impressos de APNDs"
                                  ],
                                  "tips": [
                                    "Use símbolos de pilha intuitivos como A para 'a' match.",
                                    "Teste mentalmente com n=0,1,2."
                                  ],
                                  "learningObjective": "Implementar lógica de matching via pilha.",
                                  "commonMistakes": [
                                    "Pop sem verificar topo da pilha.",
                                    "Não lidar com n=0 (string vazia).",
                                    "Empilhar sem limite."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Condições de Aceitação e Simular Execuções",
                                  "subSteps": [
                                    "Defina estados finais F e critério de aceitação (pilha vazia ou símbolo específico no topo).",
                                    "Simule passo a passo 3 strings válidas e 3 inválidas (ex: aabb aceita, ab rejeitada).",
                                    "Registre configurações (estado, resto_entrada, pilha) em cada passo.",
                                    "Corrija erros na simulação e refine transições.",
                                    "Documente a prova informal de corretude (empilha n A's, desempilha n B's)."
                                  ],
                                  "verification": "Relatório de simulações com tabelas mostrando aceitação/rejeição correta.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "JFLAP para execução automatizada",
                                    "Planilha para tabelas de simulação"
                                  ],
                                  "tips": [
                                    "Simule devagar, anotando pilha como lista.",
                                    "Aceitação por estado final E pilha vazia é comum."
                                  ],
                                  "learningObjective": "Validar o APND através de simulações e corretude.",
                                  "commonMistakes": [
                                    "Aceitar com pilha não vazia.",
                                    "Falhar em strings limite como ε ou aaabbb.",
                                    "Não simular contraexemplos."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar, Testar e Documentar o APND Completo",
                                  "subSteps": [
                                    "Revise o diagrama final e tabela de transições completa.",
                                    "Teste com ferramenta como JFLAP para 10+ strings.",
                                    "Escreva uma descrição formal: (Q, Σ, Γ, δ, q0, Z0, F).",
                                    "Identifique otimizações ou variantes (ex: não-determinístico).",
                                    "Prepare apresentação ou relatório com exemplo resolvido."
                                  ],
                                  "verification": "APND completo funcional em simulador, com documentação formal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "JFLAP ou similar",
                                    "Template de relatório LaTeX ou Word"
                                  ],
                                  "tips": [
                                    "Exporte diagrama para compartilhar.",
                                    "Compare com APNDs padrão online."
                                  ],
                                  "learningObjective": "Produzir um APND pronto para uso e análise.",
                                  "commonMistakes": [
                                    "Transições incompletas (dead states).",
                                    "Documentação vaga.",
                                    "Não testar entradas longas."
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um APND para L = {a^n b^n | n ≥ 0}: Estados {q0, q1, qf}; Σ={a,b}; Γ={Z0, A}; δ(q0,a,Z0)=(q1,A Z0), δ(q1,a,A)=(q1,A A), δ(q1,b,A)=(q1,ε), δ(q1,ε,Z0)=(qf,Z0). Aceita por estado final qf com pilha vazia. Simule 'aabb': empilha AA, desempilha com bb, aceita.",
                              "finalVerifications": [
                                "O APND aceita todas as strings válidas da linguagem (teste 5+ exemplos).",
                                "Rejeita corretamente strings inválidas (ex: mais b's que a's).",
                                "Simulação manual e em ferramenta confirma transições sem loops infinitos.",
                                "Pilha retorna a Z0 ou vazia em aceitações.",
                                "Descrição formal inclui todos componentes sem ambiguidades.",
                                "Prova informal explica por que reconhece exatamente a LC."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das transições δ (sem vazios ou erros).",
                                "Uso correto e minimal da pilha para matching.",
                                "Corretude comprovada por simulações múltiplas.",
                                "Clareza do diagrama e tabela de transições.",
                                "Formalidade na definição (Q, Σ, Γ, etc.).",
                                "Criatividade na adaptação para palíndromos ou variantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Indução matemática para provar propriedades da linguagem.",
                                "Programação: Implementação de pilhas em Python/Java para simular APND.",
                                "Algoritmos: Similaridade com parsing recursivo descendente.",
                                "Lógica: Verificação de corretude via invariantes de pilha.",
                                "Engenharia de Software: Aplicação em validadores de XML/JSON."
                              ],
                              "realWorldApplication": "Compiladores usam APNDs para parsing de gramáticas livres de contexto, como expressões balanceadas em código (parênteses, chaves), validação de estruturas hierárquicas em HTML/XML, e análise sintática em processadores de linguagem natural."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Demonstrar equivalência entre gramáticas livres de contexto e autômatos de pilha",
                            "description": "Explicar e aplicar construções para converter CFG em PDA e PDA em CFG, usando sub-rotinas para simular derivações via pilha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de Gramáticas Livres de Contexto (CFG) e Autômatos de Pilha (PDA)",
                                  "subSteps": [
                                    "Estudar a definição formal de uma CFG: V, Σ, P, S.",
                                    "Revisar derivações em CFG: esquerda, direita e árvores de derivação.",
                                    "Entender a estrutura de um PDA: estados, alfabeto de entrada, pilha, transições δ(q, a, X) = (p, γ).",
                                    "Explorar tipos de PDA: determinístico (DPDA) e não-determinístico (NPDA).",
                                    "Comparar linguagens aceitas: L(G) para CFG e L(M) para PDA."
                                  ],
                                  "verification": "Resumir em um diagrama comparativo CFG vs PDA e listar 3 diferenças principais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to Automata Theory' de Hopcroft & Ullman (cap. 6-7)",
                                    "Notas de aula sobre linguagens formais",
                                    "Ferramenta JFLAP para simular PDA"
                                  ],
                                  "tips": "Use diagramas para visualizar pilha e derivações; foque em exemplos simples como S → aS | ε.",
                                  "learningObjective": "Compreender as bases teóricas para estabelecer a equivalência.",
                                  "commonMistakes": [
                                    "Confundir PDA com AFD (ignorar pilha)",
                                    "Esquecer não-determinismo em PDA"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir um PDA a partir de uma CFG",
                                  "subSteps": [
                                    "Aplicar o algoritmo padrão: PDA simula derivações esquerdas da CFG usando pilha.",
                                    "Implementar sub-rotina para [S → α]: empilhar símbolos não-terminais, processar terminais.",
                                    "Definir transições: para terminais, pop da pilha; para não-terminais, empilhar lado direito da produção.",
                                    "Tratar ε-produções e simular não-determinismo.",
                                    "Testar com exemplo: CFG S → aSb | ε → PDA que aceita {a^n b^n}."
                                  ],
                                  "verification": "Construir PDA para uma CFG dada e simular aceitação de uma palavra válida.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "JFLAP ou simulador online de PDA",
                                    "Folha de exercícios com CFGs simples",
                                    "Pseudocódigo do algoritmo de conversão"
                                  ],
                                  "tips": "Sempre comece com derivação esquerda; use sub-rotinas para evitar explosão de estados.",
                                  "learningObjective": "Dominar a construção prática de PDA equivalente a uma CFG.",
                                  "commonMistakes": [
                                    "Esquecer de empilhar $ no fundo da pilha",
                                    "Não lidar com múltiplas produções corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir uma CFG a partir de um PDA",
                                  "subSteps": [
                                    "Aplicar o algoritmo de conversão: CFG gera caminhos de computação do PDA.",
                                    "Identificar variáveis para subcomputações: X_iq para pilha com X no topo em estado q.",
                                    "Gerar produções baseadas em transições: empurrar/pop e mudanças de estado.",
                                    "Lidar com ε-transições e loops na pilha.",
                                    "Simplificar a CFG resultante removendo variáveis inúteis."
                                  ],
                                  "verification": "Derivar uma palavra aceita pelo PDA usando a CFG gerada.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Exemplos resolvidos de PDA para {a^n b^n}",
                                    "Ferramenta para gerar CFG de PDA",
                                    "Papel e lápis para diagramas de estados"
                                  ],
                                  "tips": "Foque em PDAs com uma cabeça de pilha; memorize o formato das variáveis X_qi.",
                                  "learningObjective": "Capacitar a reversão da conversão, provando reconhecimento mútuo.",
                                  "commonMistakes": [
                                    "Gerar produções cíclicas infinitas",
                                    "Ignorar estados finais na CFG"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar e verificar a equivalência",
                                  "subSteps": [
                                    "Provar L(CFG) ⊆ L(PDA): toda derivação gera uma computação aceita.",
                                    "Provar L(PDA) ⊆ L(CFG): toda computação aceita tem uma derivação correspondente.",
                                    "Implementar simulações bidirecionais com ferramentas.",
                                    "Resolver exercícios mistos: converter ida e volta.",
                                    "Discutir limitações (ex: DPDA vs CFG)."
                                  ],
                                  "verification": "Para uma linguagem dada, construir CFG e PDA equivalentes e testar 3 palavras.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "JFLAP para validação",
                                    "Lista de exercícios de equivalência",
                                    "Teorema formal da equivalência CFL-PDA"
                                  ],
                                  "tips": "Use indução em derivações para provas; valide com palavras limítrofes.",
                                  "learningObjective": "Estabelecer formalmente a equivalência teórica.",
                                  "commonMistakes": [
                                    "Confundir aceitação por estado final vs pilha vazia",
                                    "Não provar ambas as inclusões"
                                  ]
                                }
                              ],
                              "practicalExample": "Para CFG G: S → a S b | ε (L(G) = {a^n b^n | n ≥ 0}). Construa PDA: inicia com Z0, empilha A para S, processa 'a' empilhando A, 'b' desempilhando A, aceita se pilha vazia. Converta de volta para CFG equivalente.",
                              "finalVerifications": [
                                "Construir PDA correto para CFG dada sem erros de transição.",
                                "Gerar CFG válida de um PDA NPDA simples.",
                                "Simular corretamente 5 palavras em ambos os modelos.",
                                "Explicar prova de equivalência em termos de simulação de derivações.",
                                "Identificar quando um PDA é determinístico e sua CFG.",
                                "Resolver exercício completo de conversão bidirecional."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas transições do PDA (100% corretas).",
                                "Correção das produções na CFG gerada (sem variáveis extras).",
                                "Profundidade da prova de equivalência (ambas direções).",
                                "Qualidade de simulações e testes com palavras inválidas/válidas.",
                                "Clareza em diagramas e explicações.",
                                "Tempo de execução eficiente nos passos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos em transições de PDA.",
                                "Programação: Parsers LL/LR em compiladores baseados em stack.",
                                "Lógica: Provas por indução em linguagens formais.",
                                "Engenharia de Software: Verificação formal de linguagens.",
                                "Inteligência Artificial: Modelos de reconhecimento de padrões."
                              ],
                              "realWorldApplication": "Em compiladores (ex: GCC, JavaCC), onde parsers usam stack para análise sintática de linguagens de programação, validando estruturas aninhadas como blocos if/while."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.3",
                              "10.1.2.5.3.2"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.4",
                            "name": "Diferenciar autômatos de pilha determinísticos e não-determinísticos",
                            "description": "Comparar DPDA e NPDA, notando que DCFLs são estritamente contidas em CFLs, com exemplos como {a^n b^n} aceito por DPDA mas ww^R requer NPDA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de Autômatos de Pilha (PDA)",
                                  "subSteps": [
                                    "Estude a definição formal de um PDA: conjunto de estados, alfabeto de entrada, alfabeto da pilha, função de transição, estado inicial, símbolo inicial da pilha e estados de aceitação.",
                                    "Entenda o funcionamento: leitura de símbolos de entrada, empilhamento/desempilhamento na pilha e transições baseadas no topo da pilha.",
                                    "Classifique PDAs em determinísticos (DPDA) e não-determinísticos (NPDA) com base na unicidade das transições.",
                                    "Pratique com um diagrama simples de PDA para linguagem {a^n b^n}.",
                                    "Identifique o papel da pilha como memória ilimitada comparada a AFDs."
                                  ],
                                  "verification": "Desenhe um PDA simples e simule sua execução para uma string de entrada curta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to Automata Theory' de Hopcroft (cap. PDA)",
                                    "Ferramenta online JFLAP para simulação de PDA",
                                    "Notas de aula sobre linguagens livres de contexto"
                                  ],
                                  "tips": "Sempre anote o estado da pilha durante simulações para visualizar melhor.",
                                  "learningObjective": "Compreender a estrutura e operação fundamental de PDAs.",
                                  "commonMistakes": [
                                    "Confundir pilha com fita de Turing",
                                    "Ignorar o símbolo inicial da pilha (geralmente Z0)",
                                    "Esquecer que PDA pode ter ε-transições em NPDA"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Autômatos de Pilha Determinísticos (DPDA)",
                                  "subSteps": [
                                    "Defina DPDA: função de transição única para cada configuração (estado, símbolo de entrada ou ε, topo da pilha).",
                                    "Aprenda que DPDA aceitam Deterministic Context-Free Languages (DCFLs).",
                                    "Construa um DPDA para {a^n b^n | n ≥ 0}: empilhe 'a', desempilhe com 'b'.",
                                    "Simule execuções para strings válidas e inválidas, notando a unicidade do caminho.",
                                    "Discuta propriedades: prefixo livre de ambiguidade."
                                  ],
                                  "verification": "Implemente e teste um DPDA em JFLAP para pelo menos 5 strings de teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "JFLAP software",
                                    "Exemplos de DPDA em slides de Automata Theory",
                                    "Papel e lápis para diagramas"
                                  ],
                                  "tips": "Use ε-movimentos apenas quando necessário para limpar a pilha no final.",
                                  "learningObjective": "Dominar definição, construção e simulação de DPDAs.",
                                  "commonMistakes": [
                                    "Permitir múltiplas transições para a mesma configuração",
                                    "Confundir aceitação por estado final vs. pilha vazia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Autômatos de Pilha Não-Determinísticos (NPDA)",
                                  "subSteps": [
                                    "Defina NPDA: permite múltiplas transições possíveis para uma configuração, com escolha não-determinística.",
                                    "Entenda que NPDA aceitam Context-Free Languages (CFLs), mais poderosas que DCFLs.",
                                    "Construa um NPDA para {ww^R | w ∈ {a,b}*}: adivinhe o meio da string via não-determinismo.",
                                    "Simule com ramificações, escolhendo caminhos que levam à aceitação.",
                                    "Compare poder expressivo: todo DCFL é CFL, mas nem todo CFL é DCFL."
                                  ],
                                  "verification": "Simule um NPDA em JFLAP mostrando ramificações para aceitação de ww^R.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "JFLAP com suporte a NPDA",
                                    "Vídeo tutorial sobre NPDA no YouTube (Automata Tutors)",
                                    "Exemplos de linguagens como palíndromos"
                                  ],
                                  "tips": "Pense no não-determinismo como 'adivinhação' de decisões corretas.",
                                  "learningObjective": "Compreender NPDA e seu maior poder computacional.",
                                  "commonMistakes": [
                                    "Tratar NPDA como determinístico em simulações",
                                    "Esquecer de explorar todas as ramificações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar DPDA e NPDA com exemplos e teoremas",
                                  "subSteps": [
                                    "Liste diferenças: unicidade de transição (DPDA) vs. múltiplas (NPDA); DCFLs ⊂ CFLs estritamente.",
                                    "Exemplo DCFL: {a^n b^n} (DPDA existe).",
                                    "Exemplo CFL não-DCFL: {ww^R} (requer NPDA).",
                                    "Estude teorema: DCFLs são prefixo livres; existe CFL não prefixo livre.",
                                    "Prove ou argumente por que ww^R não tem DPDA (pumping ou ambiguidade)."
                                  ],
                                  "verification": "Escreva um relatório curto comparando os dois com exemplos e cite o teorema de inclusão.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Artigo ou capítulo sobre DCFL vs CFL",
                                    "Proof sketches de impossibilidade para ww^R em DPDA",
                                    "Fórum StackExchange para dúvidas"
                                  ],
                                  "tips": "Use tabelas para comparar características lado a lado.",
                                  "learningObjective": "Diferenciar precisamente DPDA/NPDA e suas linguagens.",
                                  "commonMistakes": [
                                    "Achar que todo CFL tem DPDA",
                                    "Confundir com NPDA de pilha vazia vs. estado final"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um DPDA para L1 = {a^n b^n | n ≥ 0}: estados q0 (empilhar A por a), q1 (desempilhar por b), q2 aceitação. Tente para L2 = {ww^R}: falha pois precisa adivinhar |w|, simulando em JFLAP para ver ambiguidade determinística.",
                              "finalVerifications": [
                                "Explique verbalmente a diferença entre DPDA e NPDA.",
                                "Desenhe DPDA para {a^n b^n} e NPDA para {ww^R}.",
                                "Cite 2 exemplos de DCFLs e 1 CFL não-DCFL.",
                                "Prove que DCFLs ⊆ CFLs estritamente.",
                                "Simule ambas em ferramenta para string ww^R válida.",
                                "Discuta por que NPDA é mais poderoso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de DPDA vs NPDA (80% correto).",
                                "Correção nos diagramas e simulações (sem erros lógicos).",
                                "Identificação correta de exemplos de linguagens (DCFL e não-DCFL).",
                                "Compreensão do teorema de inclusão estrita.",
                                "Capacidade de argumentar impossibilidade de DPDA para ww^R.",
                                "Clareza na explicação de diferenças práticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e relações de inclusão (DCFL ⊂ CFL).",
                                "Programação: Parsers determinísticos em compiladores (ex: LR(0)).",
                                "Lógica: Estados e transições como em máquinas lógicas.",
                                "Engenharia de Software: Modelagem de sistemas com memória em pilha (recursão)."
                              ],
                              "realWorldApplication": "Em compiladores, DPDAs implementam parsers eficientes e determinísticos (ex: LL(1) grammars) para análise sintática rápida, enquanto NPDAs modelam parsers mais expressivos como CYK para linguagens complexas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Linguagens Livres de Contexto e Sensíveis ao Contexto",
                "description": "Análise de linguagens livres de contexto, sensíveis ao contexto e tipo-0.",
                "totalSkills": 44,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Linguagens Livres de Contexto",
                    "description": "Definição formal, gramáticas tipo-2 e equivalência com autômatos de pilha.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Definição Formal de Linguagens Livres de Contexto",
                        "description": "Conceito fundamental que define linguagens livres de contexto (LLC) como o conjunto de linguagens geradas por gramáticas livres de contexto, posicionadas na hierarquia de Chomsky entre linguagens regulares e sensíveis ao contexto.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Definir formalmente uma linguagem livre de contexto",
                            "description": "Explicar a definição formal de uma LLC como L(G) onde G é uma gramática de contexto livre (G = (V, Σ, P, S)), identificando os componentes: alfabeto não-terminal V, terminal Σ, regras de produção P e símbolo inicial S.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral de uma gramática livre de contexto",
                                  "subSteps": [
                                    "Estude a definição básica de gramática formal G = (V, Σ, P, S).",
                                    "Identifique que LLC é gerada por GCL (gramática livre de contexto).",
                                    "Revise conceitos prévios de linguagens formais e autômatos.",
                                    "Anote as propriedades principais de GCL: regras do tipo A → α onde A ∈ V e α ∈ (V ∪ Σ)*.",
                                    "Compare com gramáticas regulares para destacar diferenças."
                                  ],
                                  "verification": "Escreva um resumo de 3 frases explicando G = (V, Σ, P, S) e confirme com um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Hopcroft ou Sipser)",
                                    "Notas de aula sobre linguagens formais",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use mnemônicos: V para variáveis (não-terminais), Σ para símbolos (terminais).",
                                  "learningObjective": "Entender a tupla quádrupla que define uma gramática livre de contexto.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Ignorar a forma das regras de produção"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o alfabeto não-terminal V e terminal Σ",
                                  "subSteps": [
                                    "Defina V como o conjunto finito de símbolos não-terminais (variáveis).",
                                    "Defina Σ como o conjunto finito de símbolos terminais (alfabeto).",
                                    "Exemplifique: V = {S, A}, Σ = {a, b}.",
                                    "Verifique disjointness: V ∩ Σ = ∅.",
                                    "Pratique listando V e Σ para uma gramática simples."
                                  ],
                                  "verification": "Crie conjuntos V e Σ para uma gramática exemplo e prove que são disjuntos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou quadro branco",
                                    "Exemplos de gramáticas de livros-texto"
                                  ],
                                  "tips": "Sempre use maiúsculas para V e minúsculas/grifos para Σ.",
                                  "learningObjective": "Distinguir e formalizar corretamente os conjuntos V e Σ.",
                                  "commonMistakes": [
                                    "Incluir terminais em V",
                                    "Usar símbolos sobrepostos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar as regras de produção P e o símbolo inicial S",
                                  "subSteps": [
                                    "Defina P como conjunto finito de regras A → α, com A ∈ V e α ∈ (V ∪ Σ)*.",
                                    "Escolha S ∈ V como símbolo inicial (axioma).",
                                    "Escreva 3-5 regras de produção exemplo.",
                                    "Valide que todas as regras respeitam a forma livre de contexto.",
                                    "Trace uma derivação inicial a partir de S."
                                  ],
                                  "verification": "Escreva P com pelo menos 3 regras e indique S, simulando uma derivação de 2 passos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de desenho de árvores de derivação (opcional)",
                                    "Folhas de exercícios de gramáticas"
                                  ],
                                  "tips": "Numere as regras em P para facilitar referências em derivações.",
                                  "learningObjective": "Formalizar P e S com precisão sintática.",
                                  "commonMistakes": [
                                    "Regras com múltiplos não-terminais no lado esquerdo",
                                    "S não pertencente a V"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a linguagem L(G) gerada pela gramática",
                                  "subSteps": [
                                    "Defina L(G) = {w ∈ Σ* | S ⇒* w, onde ⇒* é derivação em múltiplos passos}.",
                                    "Gere pelo menos duas palavras em L(G) via derivações.",
                                    "Discuta o processo de geração de linguagem.",
                                    "Compare L(G) com Σ* para enfatizar subconjunto.",
                                    "Teste se uma palavra arbitrária pertence a L(G)."
                                  ],
                                  "verification": "Escreva a definição completa de L(G) e prove membership de uma palavra exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta online de simulador de gramáticas (ex: JFLAP)",
                                    "Exemplos resolvidos"
                                  ],
                                  "tips": "Use ⇒ para um passo e ⇒* para zero ou mais passos.",
                                  "learningObjective": "Compreender e expressar a linguagem como conjunto de derivações terminais.",
                                  "commonMistakes": [
                                    "Confundir derivações com sentenças",
                                    "Esquecer o fechamento sob derivação *"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G = ({S}, {a,b}, P, S) onde P: S → aSb | ε. Então L(G) = {a^n b^n | n ≥ 0}. Derivação exemplo: S ⇒ aSb ⇒ aεb = ab ∈ L(G).",
                              "finalVerifications": [
                                "Escrever corretamente G = (V, Σ, P, S) com componentes válidos.",
                                "Gerar uma derivação completa de S a uma palavra terminal.",
                                "Identificar se uma regra dada é livre de contexto.",
                                "Listar 3 palavras em L(G) e 1 fora de L(G).",
                                "Explicar o papel de cada componente em 1 frase por um.",
                                "Validar disjointness de V e Σ."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (uso correto de símbolos e tuplas).",
                                "Correção das regras de produção (forma A → α).",
                                "Compreensão conceitual via derivações válidas.",
                                "Capacidade de distinguir componentes (V vs Σ, etc.).",
                                "Clareza na definição de L(G) com notação ⇒*.",
                                "Exemplos relevantes e sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e relações (V, Σ como conjuntos disjuntos).",
                                "Lógica: Inferência por derivação e provas por indução em árvores de parsing.",
                                "Programação: Desenvolvimento de parsers e analisadores sintáticos em compiladores.",
                                "Linguística: Modelagem de estruturas sintáticas naturais.",
                                "Engenharia de Software: Especificação formal de DSLs (Domain-Specific Languages)."
                              ],
                              "realWorldApplication": "Em compiladores (ex: GCC, JavaCC), validadores de XML/JSON usam definições formais de LLC para análise sintática, garantindo que código ou dados sigam gramáticas pré-definidas, como em editores de código com autocompletar e highlighting."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Identificar exemplos de linguagens livres de contexto",
                            "description": "Reconhecer e listar exemplos clássicos de LLC, como {a^n b^n | n ≥ 0}, palíndromos sobre {a,b} e expressões balanceadas de parênteses, diferenciando-as de linguagens regulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições básicas de linguagens regulares e livres de contexto",
                                  "subSteps": [
                                    "Leia a definição formal de linguagens regulares (geradas por gramáticas regulares ou reconhecidas por autômatos finitos).",
                                    "Estude a definição de linguagens livres de contexto (geradas por gramáticas livres de contexto ou reconhecidas por pushdown automata).",
                                    "Compare as hierarquias de Chomsky, focando na posição das LLC acima das regulares.",
                                    "Anote as limitações das linguagens regulares (não podem contar ou fazer matching aninhado).",
                                    "Identifique propriedades chave: LLC podem lidar com recursão e dependências de distância arbitrária."
                                  ],
                                  "verification": "Resuma em 3-5 frases as diferenças principais entre regulares e LLC, e liste 2 limitações de cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Notas de aula sobre Hierarquia de Chomsky",
                                    "Wikipedia: Context-free language"
                                  ],
                                  "tips": [
                                    "Use diagramas da Hierarquia de Chomsky para visualizar.",
                                    "Foquem em 'pumping lemma' para regulares vs. propriedades de bombeamento para LLC."
                                  ],
                                  "learningObjective": "Compreender as diferenças fundamentais entre linguagens regulares e livres de contexto.",
                                  "commonMistakes": [
                                    "Confundir gramáticas regulares com expressões regulares avançadas.",
                                    "Ignorar que algumas LLC não são regulares devido a contagens desiguais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o exemplo clássico {a^n b^n | n ≥ 0}",
                                  "subSteps": [
                                    "Escreva a notação formal da linguagem L = {a^n b^n | n ≥ 0}.",
                                    "Construa uma gramática livre de contexto para gerar L: S → aSb | ε.",
                                    "Prove que não é regular usando o lema de bombeamento: assuma w = a^p b^p, mostre violação.",
                                    "Desenhe um pushdown automaton (PDA) não-determinístico que reconhece L.",
                                    "Gere strings de exemplo: ε, ab, aabb, aaabbb."
                                  ],
                                  "verification": "Gere 5 strings em L e prove que uma string como a^{p+1} b^p não está em L.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas de PDA",
                                    "Ferramenta online como JFLAP para simular PDA",
                                    "Exemplos de gramáticas LLC"
                                  ],
                                  "tips": [
                                    "Lembre-se: o stack do PDA conta os a's e matching b's.",
                                    "Teste com pumping lemma passo a passo."
                                  ],
                                  "learningObjective": "Reconhecer {a^n b^n} como LLC clássico e diferenciá-lo de regulares.",
                                  "commonMistakes": [
                                    "Pensar que é regular porque parece simples; esqueça o lema de bombeamento.",
                                    "Confundir com {a^n b^m} que pode ser regular se independente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar palíndromos e expressões balanceadas de parênteses",
                                  "subSteps": [
                                    "Defina palíndromos sobre {a,b}: L_pal = {w w^R | w ∈ {a,b}* }.",
                                    "Construa gramática: S → aSa | bSb | ε.",
                                    "Analise expressões balanceadas: L_par = { (^n )^n | n ≥ 0 } ou mais geral com múltiplos pares.",
                                    "Prove não-regularidade para palíndromos usando pumping lemma.",
                                    "Compare com linguagens regulares como todas as strings pares de a's e b's."
                                  ],
                                  "verification": "Escreva gramáticas para ambos e gere 3 strings não-palíndromos que pumping lemma rejeita.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "JFLAP ou simulador de gramáticas",
                                    "Lista de exemplos de linguagens não-regulares"
                                  ],
                                  "tips": [
                                    "Palíndromos requerem matching simétrico, impossível com estados finitos.",
                                    "Use árvore de derivação para visualizar."
                                  ],
                                  "learningObjective": "Identificar palíndromos e parênteses balanceados como exemplos LLC não-regulares.",
                                  "commonMistakes": [
                                    "Confundir palíndromos finitos (regulares) com infinitos.",
                                    "Ignorar aninhamento em parênteses."
                                  ],
                                  "    ": {
                                    "stepNumber": 4,
                                    "title": "Praticar identificação e diferenciação de exemplos",
                                    "subSteps": [
                                      "Liste 5 linguagens candidatas e classifique como regular ou LLC (ex: {a* b*}, {ww | w ∈ {a,b}*}, etc.).",
                                      "Use testes: pumping lemma para não-regular, gramática ou PDA para LLC.",
                                      "Crie um fluxograma para decidir: 'Pode contar n?' → LLC.",
                                      "Resolva exercícios: identifique 3 LLC clássicos adicionais (ex: {a^n b^n c^n}).",
                                      "Discuta por que {a^n b^{2n}} é LLC."
                                    ],
                                    "verification": "Classifique corretamente 10 linguagens dadas como regular ou LLC com justificativa.",
                                    "estimatedTime": "75 minutos",
                                    "materials": [
                                      "Lista de exercícios de linguagens formais",
                                      "Quiz online sobre teoria da computação"
                                    ],
                                    "tips": [
                                      "Sempre pergunte: requer memória ilimitada? → LLC.",
                                      "Pratique com variações como {a^n b^n c^m}."
                                    ],
                                    "learningObjective": "Listar e diferenciar exemplos LLC de regulares com confiança.",
                                    "commonMistakes": [
                                      "Classificar {a^n b^{n} c^n} como LLC simples (é CSL).",
                                      "Subestimar linguagens regulares aninhadas finitas."
                                    ]
                                  }
                                },
                                {
                                  "practicalExample": "Dado L = {a^n b^n | n ≥ 0}, construa uma gramática G = ({S}, {a,b}, P, S) com P: S → a S b | ε. Prove não-regular com pumping lemma para p=3, w=aaabbb: divida em xyz, bombeie i=2 viola igualdade de a's e b's. Simule PDA: empilhe A por a, desempilhe por b.",
                                  "finalVerifications": [
                                    "Pode listar {a^n b^n}, palíndromos e parênteses balanceados como LLC clássicos?",
                                    "Aplica pumping lemma corretamente para provar {a^n b^n} não-regular?",
                                    "Constrói gramática ou esboça PDA para pelo menos 2 exemplos?",
                                    "Diferencia corretamente 5 linguagens regulares de LLC?",
                                    "Explica por que LLC precisam de stack em PDA?",
                                    "Gera strings válidas e inválidas para cada exemplo?"
                                  ],
                                  "assessmentCriteria": [
                                    "Precisão na identificação de exemplos clássicos (100% correto).",
                                    "Uso correto de pumping lemma em provas (lógica sem falhas).",
                                    "Construção válida de gramáticas ou PDAs (sem erros sintáticos).",
                                    "Diferenciação clara com justificativas teóricas.",
                                    "Profundidade em análise: menciona propriedades como fechamento.",
                                    "Criatividade em exemplos adicionais relevantes."
                                  ],
                                  "crossCurricularConnections": [
                                    "Matemática: Teoria dos conjuntos e indução para provas de n.",
                                    "Programação: Parsing em compiladores (LL/LR parsers para LLC).",
                                    "Lógica: Autômatos como modelos computacionais.",
                                    "Linguística: Gramáticas naturais aproximam LLC."
                                  ],
                                  "realWorldApplication": "Reconhecimento de sintaxe em compiladores (ex: expressões balanceadas em código), validação de XML/JSON (parênteses aninhados), análise de DNA palindrômico em bioinformática."
                                }
                              ]
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Comparar LLC com linguagens regulares",
                            "description": "Demonstrar por que certas LLC não são regulares usando o lema do bombeamento de Ogden ou o teorema de bombeamento para AFD, destacando a necessidade de memória não limitada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Linguagens Regulares e LLC",
                                  "subSteps": [
                                    "Defina linguagens regulares como aquelas reconhecidas por autômatos finitos (AFD), com memória limitada a estados finitos.",
                                    "Descreva linguagens livres de contexto (LLC) como geradas por gramáticas livres de contexto e reconhecidas por empilhadores (pushdown automata - PDA).",
                                    "Compare o poder expressivo: toda linguagem regular é LLC, mas nem toda LLC é regular.",
                                    "Liste exemplos: {a^n b^n | n ≥ 0} é LLC mas não regular.",
                                    "Discuta a necessidade de memória: AFD tem memória finita, PDA tem pilha ilimitada."
                                  ],
                                  "verification": "Escreva definições e exemplos em um papel e confirme com uma fonte confiável como o livro 'Introduction to Automata Theory' de Hopcroft.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro ou PDF de Teoria da Computação"
                                  ],
                                  "tips": "Use diagramas de AFD e PDA para visualizar diferenças.",
                                  "learningObjective": "Compreender as diferenças hierárquicas no modelo de Chomsky.",
                                  "commonMistakes": "Confundir PDA com AFD; lembrar que PDA tem pilha."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Teorema de Bombeamento para Linguagens Regulares",
                                  "subSteps": [
                                    "Enuncie o teorema: Para L regular, existe p (comprimento de bombeamento) tal que para qualquer w ∈ L com |w| ≥ p, w = xyz onde |xy| ≤ p, |y| ≥ 1, e xy^i z ∈ L para todo i ≥ 0.",
                                    "Explique o intuído: reflete estados finitos; y pode ser 'bombado' sem sair de L.",
                                    "Pratique com exemplo regular: L = (ab)*; escolha w = ababab, encontre x,y,z.",
                                    "Discuta limitações: não prova regularidade, só não-regularidade.",
                                    "Compare com Ogden's lemma brevemente: versão marcada para LLC."
                                  ],
                                  "verification": "Aplique o teorema a uma linguagem conhecida regular e verifique se holds.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Quadro branco ou papel",
                                    "Referência online ao pumping lemma"
                                  ],
                                  "tips": "Desenhe o autômato para visualizar o loop de bombeamento.",
                                  "learningObjective": "Dominar a ferramenta para provar não-regularidade.",
                                  "commonMistakes": "Escolher y vazio ou |xy| > p; sempre valide condições."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que {a^n b^n | n ≥ 0} Não é Regular Usando Pumping Lemma",
                                  "subSteps": [
                                    "Assuma L = {a^n b^n | n ≥ 0} regular; tome p o comprimento de bombeamento.",
                                    "Escolha w = a^p b^p ( |w| = 2p ≥ p ).",
                                    "Analise casos: y em a's só → bombe i=2 dá mais a's que b's; y em b's só → i=0 remove b's; y cruza → contradiz |xy|≤p.",
                                    "Conclua contradição: L não regular.",
                                    "Contrastar com LLC: PDA empilha a's, desempilha com b's."
                                  ],
                                  "verification": "Escreva a prova formal e cheque todos casos de posição de y.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel para prova",
                                    "Simulador de PDA online opcional"
                                  ],
                                  "tips": "Use casos exaustivos para y: só a's, só b's, misto.",
                                  "learningObjective": "Aplicar pumping lemma para provar hierarquia.",
                                  "commonMistakes": "Ignorar caso y cruza ab; sempre cubra |xy|≤p."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Necessidade de Memória Ilimitada e Ogden's Lemma",
                                  "subSteps": [
                                    "Explique por que LLC precisam de memória: contar a's e b's requer pilha.",
                                    "Introduza Ogden's lemma para LLC: versão mais forte com posições marcadas.",
                                    "Aplique Ogden brevemente a exemplo: prova mais fina para não-LLC, mas foque em regular vs LLC.",
                                    "Compare teoremas: pumping regular detecta memória finita insuficiente.",
                                    "Resuma: LLC > regulares devido a PDA vs AFD."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que memória finita falha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas anteriores",
                                    "Artigo sobre Ogden's lemma"
                                  ],
                                  "tips": "Pense em compiladores: parsers LLC para sintaxe nested.",
                                  "learningObjective": "Entender implicações arquiteturais de memória.",
                                  "commonMistakes": "Confundir Ogden com pumping padrão; Ogden é para context-free."
                                }
                              ],
                              "practicalExample": "Prove que a linguagem de palíndromos pares {ww^R | w ∈ {a,b}*} não é regular usando pumping lemma: tome w = a^p b^p b^p a^p, analise bombeamento viola equilíbrio.",
                              "finalVerifications": [
                                "Consegue enunciar pumping lemma corretamente?",
                                "Prova completa para {a^n b^n} sem erros lógicos?",
                                "Explica diferença de memória AFD vs PDA?",
                                "Identifica exemplo LLC não regular?",
                                "Aplica Ogden's lemma basicamente?",
                                "Compara hierarquia Chomsky?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na enunciação de teoremas (100% correto).",
                                "Cobertura exaustiva de casos na prova de não-regularidade.",
                                "Clareza na explicação de memória ilimitada.",
                                "Uso correto de exemplos e contraexemplos.",
                                "Profundidade na comparação formal vs intuitiva.",
                                "Criatividade em aplicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e indução em provas.",
                                "Lógica: Contrapositiva e contradição em teoremas.",
                                "Programação: Parsers em compiladores (ex: Yacc/Bison para LLC).",
                                "Engenharia de Software: Modelagem de linguagens em sistemas formais."
                              ],
                              "realWorldApplication": "Em compiladores, parsers LLC analisam estruturas nested como blocos if/while em código, requerendo pilha para memória ilimitada, enquanto lexers usam AFD para tokens simples."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Gramáticas Tipo-2 (Gramáticas Livres de Contexto)",
                        "description": "Estudo das gramáticas na hierarquia de Chomsky tipo-2, caracterizadas por regras de produção do tipo A → α onde A é não-terminal e α é qualquer cadeia.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Descrever a estrutura de uma gramática livre de contexto",
                            "description": "Detalhar os elementos de uma GLC (V, Σ, P, S) e as restrições nas regras de produção (apenas um não-terminal no lado esquerdo), com exemplos de derivações esquerda e direita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os quatro componentes fundamentais de uma Gramática Livre de Contexto (GLC)",
                                  "subSteps": [
                                    "Defina o alfabeto de não-terminais V (variáveis ou símbolos não-terminais).",
                                    "Defina o alfabeto terminal Σ (símbolos terminais que formam as palavras da linguagem).",
                                    "Identifique o símbolo inicial S ∈ V (ponto de partida das derivações).",
                                    "Explique a distinção entre terminais e não-terminais com exemplos simples.",
                                    "Verifique que V e Σ são disjuntos (V ∩ Σ = ∅)."
                                  ],
                                  "verification": "Liste corretamente os quatro componentes com definições e exemplos sem erros conceituais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Teoria da Computação (capítulo sobre GLC)",
                                    "Editor de texto para anotar símbolos"
                                  ],
                                  "tips": "Use notação padrão: G = (V, Σ, P, S). Comece com exemplos pequenos para fixar.",
                                  "learningObjective": "Compreender e nomear precisamente os componentes V, Σ, P e S de uma GLC.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Esquecer que S deve ser um não-terminal",
                                    "Misturar P com os outros componentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever as regras de produção P e suas restrições específicas",
                                  "subSteps": [
                                    "Explique que cada regra é da forma A → α, onde A ∈ V e α ∈ (V ∪ Σ)*.",
                                    "Enfatize a restrição: apenas um não-terminal no lado esquerdo (Tipo-2 na hierarquia de Chomsky).",
                                    "Dê exemplos válidos: S → aSb | ε; exemplos inválidos: ab → cd.",
                                    "Discuta o papel das regras em gerar strings por substituição repetida.",
                                    "Classifique regras como unitárias (A → B) ou não-unitárias (A → XYZ)."
                                  ],
                                  "verification": "Escreva 3 regras válidas e 2 inválidas, justificando as restrições.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para escrever regras",
                                    "Referência online sobre hierarquia de Chomsky"
                                  ],
                                  "tips": "Sempre verifique o lado esquerdo: deve ser EXATAMENTE um não-terminal único.",
                                  "learningObjective": "Dominar a forma canônica das produções e identificar violações.",
                                  "commonMistakes": [
                                    "Permitir múltiplos símbolos no lado esquerdo",
                                    "Confundir com gramáticas regulares (lado direito só terminais ou não-terminal + terminal)",
                                    "Ignorar ε-produções válidas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir uma gramática livre de contexto completa e simples",
                                  "subSteps": [
                                    "Escolha uma linguagem simples, como {a^n b^n | n ≥ 0}.",
                                    "Defina V = {S}, Σ = {a, b}, S = S.",
                                    "Crie P: S → aSb | ε.",
                                    "Valide todos os componentes e regras conforme as definições anteriores.",
                                    "Teste gerando uma string derivada manualmente."
                                  ],
                                  "verification": "Apresente uma GLC completa que gere pelo menos duas strings da linguagem pretendida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto ou ferramenta como Overleaf para LaTeX",
                                    "Exemplos de gramáticas de livros didáticos"
                                  ],
                                  "tips": "Comece com linguagens clássicas como palíndromos ou aninhados para praticar.",
                                  "learningObjective": "Montar uma GLC funcional do zero, integrando todos os componentes.",
                                  "commonMistakes": [
                                    "Regras que violam a forma A → α",
                                    "Símbolos iniciais incorretos",
                                    "Linguagens que não são livres de contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar e comparar derivações esquerda e direita",
                                  "subSteps": [
                                    "Explique derivação esquerda: substitua o mais à esquerda não-terminal possível.",
                                    "Explique derivação direita: substitua o mais à direita não-terminal possível.",
                                    "Aplique na gramática do Step 3 para gerar 'aabb': mostre sequências passo a passo.",
                                    "Compare as árvores de derivação geradas por cada método.",
                                    "Discuta equivalência: ambas geram a mesma linguagem."
                                  ],
                                  "verification": "Gere derivações esquerda e direita para uma string de comprimento ≥ 4, sem erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel milimetrado para árvores de derivação",
                                    "Simulador online de gramáticas (ex: JFLAP)"
                                  ],
                                  "tips": "Use setas ↓ para mostrar substituições e destaque o não-terminal escolhido.",
                                  "learningObjective": "Demonstrar derivações canônicas e suas diferenças práticas.",
                                  "commonMistakes": [
                                    "Escolher ordem errada de substituição",
                                    "Parar derivação prematuramente",
                                    "Confundir com derivações em gramáticas regulares"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática G = ({S}, {a,b}, P, S) onde P: S → aSb | ε. Derivação esquerda para aabb: S ⇒ aSb ⇒ aaSbb ⇒ aabbb (erro intencional para correção; correta: S ⇒ aSb ⇒ a a S b b ⇒ a a ε b b = aabb). Derivação direita: S ⇒ aSb ⇒ aSbb ⇒ a ε bb = abb (corrigir para aabb).",
                              "finalVerifications": [
                                "Descreva V, Σ, P, S sem omissões.",
                                "Identifique regras inválidas em uma lista fornecida.",
                                "Construa GLC para {a^n b^n}.",
                                "Execute derivação esquerda para w = aabbb.",
                                "Compare derivações esquerda/direita em uma árvore.",
                                "Explique por que GLC são Tipo-2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição dos 4 componentes (100% corretos).",
                                "Correta aplicação da restrição nas produções (sem violações).",
                                "Capacidade de gerar strings válidas via derivações.",
                                "Clareza nas sequências de derivação esquerda/direita.",
                                "Uso correto de notação formal.",
                                "Identificação de erros comuns em exemplos dados."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Analogia com regras sintáticas em gramáticas naturais.",
                                "Programação: Estruturas de parsing em compiladores (ex: Yacc/Bison).",
                                "Matemática: Teoria de grafos em árvores de derivação.",
                                "Inteligência Artificial: Modelos de linguagem em NLP generativos."
                              ],
                              "realWorldApplication": "GLCs são base para analisadores sintáticos em compiladores de linguagens de programação (ex: Python, Java), permitindo parsing de estruturas aninhadas como expressões if-then-else ou laços recursivos, essenciais em desenvolvimento de software e processamento de linguagens naturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Converter gramáticas para Forma Normal de Chomsky",
                            "description": "Aplicar algoritmos para transformar uma GLC em Forma Normal de Chomsky (FNC), eliminando regras unitárias, ε-produções e garantindo que regras sejam A → BC ou A → a.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Eliminar ε-produções (produções vazias)",
                                  "subSteps": [
                                    "Identifique todas as variáveis anuláveis (não-terminais que derivam ε)",
                                    "Remova as ε-produções, mas adicione novas produções para todas as combinações possíveis de símbolos não anuláveis",
                                    "Propague a anulabilidade para variáveis que derivam de anuláveis",
                                    "Verifique que nenhuma produção derive ε diretamente ou indiretamente",
                                    "Atualize o símbolo inicial se for anulável, adicionando uma nova variável inicial"
                                  ],
                                  "verification": "Confirme que nenhuma produção é A → ε e que todas as derivações possíveis sem ε estão cobertas",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para gramática",
                                    "Tabela de anulabilidade"
                                  ],
                                  "tips": "Use um conjunto fechado para encontrar anuláveis iterativamente; comece com as óbvias.",
                                  "learningObjective": "Entender e aplicar o algoritmo de remoção de ε-produções preservando a linguagem gerada.",
                                  "commonMistakes": [
                                    "Esquecer de propagar anulabilidade",
                                    "Não adicionar todas as combinações de símbolos opcionais",
                                    "Remover o símbolo inicial sem substituí-lo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Eliminar produções unitárias (A → B)",
                                  "subSteps": [
                                    "Construa o par (A, B) para todas as unitárias A → B",
                                    "Para cada A, encontre todos os B acessíveis via unitárias",
                                    "Substitua cada unitária A → B por A → α onde α são as produções não-unitárias de B",
                                    "Remova todas as unitárias restantes",
                                    "Verifique ciclos de unitárias e resolva-os"
                                  ],
                                  "verification": "Nenhuma produção é da forma A → B onde B é não-terminal único",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráfico de dependências unitárias",
                                    "Lista de produções não-unitárias por não-terminal"
                                  ],
                                  "tips": "Desenhe um grafo direcionado de unitárias para visualizar caminhos.",
                                  "learningObjective": "Aplicar substituição recursiva para remover unitárias sem alterar a linguagem.",
                                  "commonMistakes": [
                                    "Ignorar produções não-unitárias de B",
                                    "Criar loops infinitos em substituições",
                                    "Esquecer produções acessíveis via múltiplas unitárias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter produções para forma binária (A → BC)",
                                  "subSteps": [
                                    "Identifique produções com mais de 2 símbolos no lado direito (RHS)",
                                    "Para uma produção A → X1 X2 ... Xn (n>2), introduza novos não-terminais Cn-1 → Xn-2 Xn-1 ... Xn",
                                    "Substitua progressivamente: A → X1 C2, C2 → X2 C3, etc., até binarizar",
                                    "Aplique a todos os RHS com 3 ou mais símbolos",
                                    "Garanta que novos não-terminais só apareçam em RHS de comprimento 2"
                                  ],
                                  "verification": "Todo RHS com não-terminais tem exatamente 2 símbolos",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Lista de produções longas",
                                    "Nomenclatura para novos não-terminais (ex: A1, A2)"
                                  ],
                                  "tips": "Nomeie novos não-terminais de forma sistemática, como X_{i,j} para substring i a j.",
                                  "learningObjective": "Binarizar gramáticas preservando equivalência linguística.",
                                  "commonMistakes": [
                                    "Usar terminais em novos não-terminais misturados",
                                    "Não binarizar todos os níveis recursivamente",
                                    "Esquecer de renomear corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Garantir produções terminais únicas (A → a)",
                                  "subSteps": [
                                    "Identifique produções mistas: A → wX ou A → Xw onde w é string de terminais >1",
                                    "Para cada terminal t em w, crie novo não-terminal T_t → t",
                                    "Substitua w por sequência de novos não-terminais representando cada t",
                                    "Remova produções originais mistas",
                                    "Verifique que todas produções são A → BC ou A → a (terminal único)"
                                  ],
                                  "verification": "Nenhuma produção tem mais de um terminal ou terminais misturados com não-terminais no RHS",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de terminais por produção",
                                    "Tabela de novos não-terminais por terminal"
                                  ],
                                  "tips": "Crie um não-terminal único por terminal para reutilização: A_a → a.",
                                  "learningObjective": "Finalizar a FNC separando terminais adequadamente.",
                                  "commonMistakes": [
                                    "Criar novos não-terminais desnecessários por ocorrência",
                                    "Deixar strings de terminais longas",
                                    "Misturar novamente terminais em binárias"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática inicial: S → AB | a, A → ε | BC, B → b | A, C → c. Passo 1: Eliminar ε de A, adicionando S → AB | a | B | ε (mas remover ε final), etc. Após todos passos: S → AB | X_a, X_a → a, A → Y_b C | Y_b Z_c, etc. (expansão completa resulta em gramática equivalente em FNC).",
                              "finalVerifications": [
                                "Nenhuma ε-produção existe",
                                "Nenhuma produção unitária A → B",
                                "Todo RHS é exatamente 2 não-terminais ou 1 terminal",
                                "Linguagem gerada é preservada (teste com palavras curtas)",
                                "Símbolo inicial não é anulável",
                                "Sem ciclos ou produções inúteis"
                              ],
                              "assessmentCriteria": [
                                "Precisão na remoção de ε-produções (todas combinações cobertas)",
                                "Correção na eliminação de unitárias (sem perda de derivações)",
                                "Binarização completa sem RHS >2 não-terminais",
                                "Tratamento correto de terminais (apenas A → a)",
                                "Gramática final gera as mesmas palavras que a original",
                                "Eficiência: mínimo de novos não-terminais introduzidos"
                              ],
                              "crossCurricularConnections": [
                                "Compiladores: Gramáticas em FNC facilitam parsing LL(1)",
                                "Algoritmos: Similar a decomposição em árvores binárias",
                                "Linguagens de Programação: Parsing de expressões aritméticas",
                                "Inteligência Artificial: Modelagem de linguagens naturais simplificadas"
                              ],
                              "realWorldApplication": "Em compiladores (ex: GCC, JavaCC), gramáticas em FNC são usadas para gerar parsers eficientes determinísticos, otimizando análise sintática de código-fonte."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Gerar linguagens a partir de gramáticas livres de contexto",
                            "description": "Construir árvores de derivação para palavras específicas em uma GLC dada e provar que uma linguagem é livre de contexto fornecendo uma gramática equivalente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Gramática Livre de Contexto (GLC) Dada",
                                  "subSteps": [
                                    "Identifique os componentes da GLC: não-terminais (V), terminais (Σ), axioma (S) e regras de produção (P).",
                                    "Classifique as regras como livres de contexto (cada regra na forma A → α, onde A é não-terminal).",
                                    "Desenhe o grafo de dependências entre não-terminais para entender a estrutura recursiva.",
                                    "Liste todas as regras de produção e agrupe por não-terminal esquerdo.",
                                    "Verifique se a gramática está na forma normal (ex: Chomsky ou Greibach) se aplicável."
                                  ],
                                  "verification": "Confirme que todos os componentes estão corretamente identificados e listados em um diagrama ou tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, editor de texto ou ferramenta como Graphviz para diagramas.",
                                  "tips": "Comece sempre pelo axioma S para mapear derivações principais.",
                                  "learningObjective": "Compreender a estrutura formal de uma GLC e seus componentes.",
                                  "commonMistakes": "Confundir terminais com não-terminais ou ignorar regras ε-produções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Árvore de Derivação para uma Palavra Específica",
                                  "subSteps": [
                                    "Escolha uma palavra w ∈ L(G) e inicie a derivação do axioma S.",
                                    "Aplique regras de produção passo a passo, ramificando para cada não-terminal.",
                                    "Desenhe a árvore de derivação, com nós internos como não-terminais e folhas como terminais formando w.",
                                    "Marque a ordem de derivação (esquerda-mais, direita-mais ou livre).",
                                    "Valide que a concatenação das folhas resulta exatamente em w."
                                  ],
                                  "verification": "A árvore produz a palavra correta sem ambiguidades ou erros de ramificação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel milimetrado, software de desenho como Draw.io ou LaTeX TikZ.",
                                  "tips": "Use derivação esquerda-mais para simplificar em gramáticas ambíguas.",
                                  "learningObjective": "Dominar a construção visual de derivações em GLCs.",
                                  "commonMistakes": "Aplicar regras em ordem errada ou esquecer ramificações recursivas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar a Linguagem da Gramática (Exemplos de Palavras)",
                                  "subSteps": [
                                    "Gere derivações para palavras de diferentes comprimentos usando o axioma.",
                                    "Explore recursão para gerar famílias de palavras (ex: {a^n b^n}).",
                                    "Liste 5-10 palavras na linguagem e descreva o padrão geral.",
                                    "Use a árvore de derivação para automatizar geração de mais exemplos.",
                                    "Defina formalmente L(G) = {w ∈ Σ* | S ⇒* w}."
                                  ],
                                  "verification": "Pelo menos 5 palavras geradas corretamente pertencem a L(G).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha ou script Python simples para simular derivações.",
                                  "tips": "Limite a profundidade de recursão para evitar derivações infinitas.",
                                  "learningObjective": "Entender como GLCs geram linguagens infinitas finitamente.",
                                  "commonMistakes": "Gerar palavras fora da linguagem por regras inválidas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar que uma Linguagem é Livre de Contexto Fornecendo GLC Equivalente",
                                  "subSteps": [
                                    "Analise a linguagem dada (ex: {a^n b^n | n ≥ 0}) e identifique padrões aninhados.",
                                    "Crie não-terminais para capturar contagens ou estruturas (ex: S → a S b | ε).",
                                    "Escreva regras de produção que gerem exatamente a linguagem.",
                                    "Construa árvores de derivação para provar que L(G') = L dada.",
                                    "Prove equivalência mostrando inclusão mútua via derivações."
                                  ],
                                  "verification": "Gramática G' gera todas e apenas as palavras da linguagem dada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livro de teoria da computação, exemplos de gramáticas padrão.",
                                  "tips": "Use recursão centrada para linguagens como palíndromos ou aninhados.",
                                  "learningObjective": "Capacitar prova de propriedades de linguagens via construção gramatical.",
                                  "commonMistakes": "Criar gramática que gera linguagem estritamente maior ou menor."
                                }
                              ],
                              "practicalExample": "Dada GLC: S → a S b | ε. Para w = 'aabb': Árvore: S → a S b → a (a S b) b → a a ε b b. Prova para L = {a^n b^n}: Use G' idêntica, gerando derivações para n=0,1,2,...",
                              "finalVerifications": [
                                "Árvores de derivação corretas para 3 palavras diferentes.",
                                "Gramática equivalente gera exatamente a linguagem alvo.",
                                "Todos os componentes da GLC analisados sem erros.",
                                "Padrões da linguagem descritos formalmente.",
                                "Derivações livres de ambiguidades desnecessárias.",
                                "Prova de equivalência via exemplos e contraexemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de árvores de derivação (100% match com palavra).",
                                "Corretude da gramática equivalente (L(G') = L).",
                                "Detalhe e clareza nos subpassos e verificações.",
                                "Uso adequado de recursão e não-terminais.",
                                "Identificação correta de erros comuns evitados.",
                                "Profundidade na geração de linguagem (múltiplos exemplos)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Parsing em compiladores (ex: ANTLR usa CFGs).",
                                "Matemática: Indução em estruturas recursivas como árvores.",
                                "Linguística: Análise sintática de frases naturais.",
                                "Inteligência Artificial: Gramáticas em PLN para geração de texto."
                              ],
                              "realWorldApplication": "Desenvolvimento de parsers para linguagens de programação (ex: Python usa gramáticas CF para análise sintática), validação de XML/JSON balanceados e chatbots com geração de respostas estruturadas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Equivalência com Autômatos de Pilha",
                        "description": "Teorema fundamental que estabelece a equivalência entre linguagens livres de contexto e linguagens reconhecidas por autômatos de pilha (APD e APND).",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Definir e descrever autômatos de pilha",
                            "description": "Explicar a estrutura formal de um autômato de pilha não-determinístico (APND): Q, Σ, Γ, δ, q0, Z0, F, incluindo transições que leem entrada, pilha e escrevem na pilha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Autômatos e Pilhas",
                                  "subSteps": [
                                    "Estude a definição de autômato finito determinístico (AFD) e não-determinístico (AFND) para contextualizar limitações.",
                                    "Aprenda o conceito de pilha como estrutura de dados LIFO (Last In, First Out) e suas operações básicas: push, pop e top.",
                                    "Compare AFND com APND, destacando como a pilha fornece memória ilimitada.",
                                    "Visualize diagramas de pilhas em ação durante processamento de strings.",
                                    "Identifique linguagens que AFND não reconhece, mas APND sim, como {a^n b^n}."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre memória finita de AFND e pilha em APND, com um exemplo simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Vídeos tutoriais sobre pilhas (YouTube/Khan Academy)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Use analogias cotidianas como pilha de pratos para entender LIFO.",
                                    "Desenhe diagramas à mão para fixar conceitos visuais."
                                  ],
                                  "learningObjective": "Entender a motivação e os componentes primitivos que justificam o uso de autômatos de pilha.",
                                  "commonMistakes": [
                                    "Confundir pilha com fila (FIFO).",
                                    "Acreditar que APND tem memória finita como AFND.",
                                    "Ignorar o não-determinismo nas transições."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os Sete Componentes Formais do APND",
                                  "subSteps": [
                                    "Liste e defina Q: conjunto finito de estados.",
                                    "Defina Σ: alfabeto de entrada finito.",
                                    "Defina Γ: alfabeto da pilha finito.",
                                    "Especifique q0: estado inicial único.",
                                    "Descreva Z0: símbolo inicial da pilha.",
                                    "Liste F ⊆ Q: conjunto de estados de aceitação.",
                                    "Revise todos os componentes em uma tupla formal: (Q, Σ, Γ, δ, q0, Z0, F)."
                                  ],
                                  "verification": "Escreva a tupla formal completa com descrições breves para cada componente, sem erros de nomenclatura.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de anotações com definições padrão",
                                    "Exemplos de APND de livros ou online (ex: a^n b^n)",
                                    "Editor de texto para formalizar"
                                  ],
                                  "tips": [
                                    "Memorize a ordem padrão da tupla para facilitar recall.",
                                    "Crie flashcards com cada componente e sua descrição."
                                  ],
                                  "learningObjective": "Memorizar e descrever precisamente os sete componentes constitutivos de um APND.",
                                  "commonMistakes": [
                                    "Esquecer Z0 ou confundir com q0.",
                                    "Achar que F é o estado inicial.",
                                    "Misturar Σ (entrada) com Γ (pilha)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Função de Transição δ",
                                  "subSteps": [
                                    "Defina formalmente δ: Q × (Σ ∪ {ε}) × Γ → 2^{Q × Γ}, explicando cada parte.",
                                    "Entenda que δ consome um símbolo de entrada (ou ε), lê o topo da pilha e produz pares (novo estado, símbolo a empilhar).",
                                    "Estude transições ε (sem consumir entrada) e como elas permitem não-determinismo.",
                                    "Escreva exemplos de δ para um APND simples, como δ(q, a, Z0) = {(p, AZ0)}.",
                                    "Simule uma transição passo a passo em uma configuração inicial."
                                  ],
                                  "verification": "Forneça 3 exemplos corretos de entradas para δ e seus outputs, justificando o não-determinismo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulador online de APND (ex: JFLAP)",
                                    "Papel para tabelas de transição",
                                    "Exercícios de livros de teoria"
                                  ],
                                  "tips": [
                                    "Pense em δ como uma 'regra de jogo' que ramifica caminhos não-determinísticos.",
                                    "Use tabelas para organizar múltiplas saídas de δ."
                                  ],
                                  "learningObjective": "Dominar a notação e o comportamento da função de transição, incluindo ε-transições.",
                                  "commonMistakes": [
                                    "Esquecer o 2^ no codomínio (pode ser múltiplas transições).",
                                    "Confundir pop com push na transição.",
                                    "Ignorar ε na entrada."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever Configurações, Computação e Critérios de Aceitação",
                                  "subSteps": [
                                    "Defina configuração: (estado atual, resto da entrada, conteúdo da pilha).",
                                    "Explique uma computação: sequência de configurações via δ até esgotar entrada.",
                                    "Descreva aceitação: atinge estado em F com pilha vazia ou apenas Z0 no topo.",
                                    "Diferencie aceitação por estado final vazio vs. final estado.",
                                    "Simule uma computação completa para uma string de entrada."
                                  ],
                                  "verification": "Simule e descreva uma computação aceitadora e uma rejeitada para um APND exemplo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "JFLAP ou simulador similar",
                                    "Exemplos impressos de computações",
                                    "Vídeos de simulações passo a passo"
                                  ],
                                  "tips": [
                                    "Rastreie configurações em colunas para visualização clara.",
                                    "Comece com strings curtas para prática."
                                  ],
                                  "learningObjective": "Compreender o processo dinâmico de reconhecimento de linguagens por APND.",
                                  "commonMistakes": [
                                    "Aceitar com pilha não-vazia.",
                                    "Confundir rejeição por loop infinito com falha de transição.",
                                    "Esquecer não-determinismo em ramificações."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o APND M que reconhece L = {a^n b^n | n ≥ 0}: Q = {q0, q1, qf}, Σ = {a,b}, Γ = {Z0, A}, δ inclui δ(q0, a, Z0) = {(q0, A Z0)}, δ(q0, ε, A) = {(q1, ε)}, δ(q1, b, A) = {(q1, ε)}, δ(q1, ε, Z0) = {(qf, Z0)}. Simule para 'aabbb': empilha A's com a's, desempilha com b's, aceita em qf com pilha Z0.",
                              "finalVerifications": [
                                "Lista corretamente os 7 componentes da tupla formal sem omissões.",
                                "Escreve a assinatura exata de δ com domínio e codomínio.",
                                "Descreve uma configuração e uma transição válida.",
                                "Explica critérios de aceitação (estado final + pilha apropriada).",
                                "Simula corretamente uma computação para {a^n b^n}.",
                                "Diferencia APND de AFND com exemplo de linguagem."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de todos os componentes (100% correto).",
                                "Correta representação de δ com exemplos não-determinísticos.",
                                "Clareza na descrição de configurações e computações.",
                                "Uso apropriado de notação matemática (tuplas, potências de conjuntos).",
                                "Capacidade de simular e debugar uma execução passo a passo.",
                                "Identificação de linguagens reconhecíveis apenas por APND."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos, funções parciais e potências de conjuntos.",
                                "Lógica: Não-determinismo e ramificações condicionais semelhantes a provas por casos.",
                                "Programação: Implementação de pilhas em linguagens como Python ou C++ para simulação.",
                                "Engenharia de Software: Parsing de linguagens em compiladores (LL/LR parsers)."
                              ],
                              "realWorldApplication": "Autômatos de pilha são fundamentais em compiladores para análise sintática de linguagens de programação livres de contexto, como parsers bottom-up em ferramentas como Yacc/Bison, validando estruturas aninhadas em código fonte."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Provar equivalência entre GLC e APND",
                            "description": "Enunciar e esboçar as provas dos teoremas: toda LLC é reconhecida por um APND e toda linguagem de APND é uma LLC, usando construções de conversão mútua.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Formais de GLC e APND",
                                  "subSteps": [
                                    "Estude a definição formal de uma Gramática Livre de Contexto (GLC): G = (V, Σ, P, S), onde V é o alfabeto de variáveis, Σ terminais, P produções, S axioma.",
                                    "Revise a definição de Autômato de Pilha Não-Determinístico (APND): M = (Q, Σ, Γ, δ, q0, Z0, F), incluindo transições com empilhamento e desempilhamento.",
                                    "Compare as classes de linguagens: LLC vs. linguagens reconhecidas por APND.",
                                    "Identifique propriedades chave: não-determinismo no APND e recursão em GLC.",
                                    "Anote diferenças e semelhanças em um diagrama comparativo."
                                  ],
                                  "verification": "Crie um resumo escrito com definições precisas e um diagrama comparativo sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Notas de aula sobre autômatos",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use tabelas para listar componentes de GLC e APND lado a lado para facilitar a memorização.",
                                  "learningObjective": "Dominar as definições formais para basear as provas de equivalência.",
                                  "commonMistakes": [
                                    "Confundir terminais com variáveis em GLC",
                                    "Esquecer o símbolo inicial Z0 na pilha do APND"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir APND a partir de GLC (GLC → APND)",
                                  "subSteps": [
                                    "Defina estados: um estado inicial q0, estado final f, e estados para cada variável A em V.",
                                    "Simule derivações da GLC na pilha: empilhe variáveis não-terminais, substitua por produções A → α via transições não-determinísticas.",
                                    "Defina transições δ: para A → X1...Xk, pop A e push Xk...X1 (ordem reversa para simular LIFO).",
                                    "Trate terminais: pop terminal e avance leitura da entrada.",
                                    "Aceite quando pilha vazia (exceto Z0 opcional) e entrada consumida.",
                                    "Esboce a construção formal em pseudocódigo ou diagrama."
                                  ],
                                  "verification": "Construa um APND para uma GLC simples (ex: S → aSb | ε) e simule uma palavra como 'aabbb'.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta de desenho de autômatos (JFLAP)",
                                    "Exemplos de GLC de palíndromos ou aninhados"
                                  ],
                                  "tips": "Lembre-se da ordem reversa no push para simular derivações esquerda-direita.",
                                  "learningObjective": "Implementar a construção que prova 'toda LLC é reconhecida por APND'.",
                                  "commonMistakes": [
                                    "Não tratar ε-produções corretamente",
                                    "Esquecer transições para múltiplas produções de uma variável"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir GLC a partir de APND (APND → GLC)",
                                  "subSteps": [
                                    "Analise transições do APND: categorize em push, pop, e match.",
                                    "Crie variáveis para capturar configurações: use [p A q] para estado p, pop A, próximo push em q.",
                                    "Gere produções: para δ(p, a, A) = (q, γ), crie [p A r] → a [q B r] se γ = BC... (ajustar para pilha).",
                                    "Inclua start symbol S → [p0 Z0 f] para simular computação completa.",
                                    "Trate loops e não-determinismo via variáveis auxiliares.",
                                    "Prove que a GLC gera exatamente as palavras aceitas pelo APND."
                                  ],
                                  "verification": "Construa uma GLC para um APND simples reconhecendo {a^n b^n} e gere derivações para n=2.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "JFLAP para simular APND",
                                    "Papel para derivar produções"
                                  ],
                                  "tips": "Use subscritos nos estados para rastrear pilha corretamente.",
                                  "learningObjective": "Implementar a construção que prova 'toda linguagem de APND é LLC'.",
                                  "commonMistakes": [
                                    "Ignorar transições que empilham múltiplos símbolos",
                                    "Não fechar loops entre estados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Correção e Completude das Construções",
                                  "subSteps": [
                                    "Prove correção para GLC → APND: toda palavra gerada por GLC leva a aceitação no APND via simulação de derivação.",
                                    "Prove completude: todo caminho de aceitação no APND corresponde a uma derivação na GLC.",
                                    "Faça o inverso para APND → GLC: simule computações do APND como derivações.",
                                    "Discuta limitações: ambas as construções preservam a linguagem exatamente.",
                                    "Teste com exemplo unificado, como ww^R (palíndromos).",
                                    "Escreva esboço formal das provas de indução sobre comprimento da palavra ou altura da árvore de derivação."
                                  ],
                                  "verification": "Escreva um parágrafo de prova para cada direção sem lacunas lógicas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Modelos de prova de livros-texto",
                                    "Exemplos resolvidos de equivalência"
                                  ],
                                  "tips": "Use indução sobre o número de passos de computação ou derivações.",
                                  "learningObjective": "Esboçar provas formais de equivalência bidirecional.",
                                  "commonMistakes": [
                                    "Confundir simulação com geração",
                                    "Não tratar pilha vazia adequadamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a GLC S → a S b | ε (linguagem {a^n b^n}), construa o APND que empilha 'a' como A, desempilha com 'b', aceitando quando pilha vazia após entrada. Inversamente, do APND para {a^n b^n}, gere GLC com variáveis capturando push/pop de símbolos A para a's e B para b's.",
                              "finalVerifications": [
                                "Construir APND correto a partir de dada GLC simples.",
                                "Gerar GLC equivalente para APND dado.",
                                "Simular aceitação/rejeição de 3 palavras em ambas direções.",
                                "Explicar intuitivamente por que as construções preservam a linguagem.",
                                "Identificar erros em construções fornecidas.",
                                "Esboçar prova de correção sem consultar notas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das definições formais (20%)",
                                "Correção das construções de conversão (30%)",
                                "Clareza e completude das provas de equivalência (30%)",
                                "Uso correto de exemplos e simulações (10%)",
                                "Tratamento de casos especiais como ε-produções (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Prova: Uso de indução e invariantes, similar a provas em Matemática Discreta.",
                                "Programação: Parsing em compiladores (ex: Yacc/Bison usa ideias de GLC/APND).",
                                "Algoritmos: Simulação de pilha em estruturas de dados recursivas.",
                                "Inteligência Artificial: Reconhecedores em PLN para gramáticas context-free."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens de programação, parsers bottom-up usam APND para analisar sintaxe definida por GLC, validando estruturas como expressões aninhadas em código fonte."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Construir APND para linguagens livres de contexto",
                            "description": "Desenhar um APND para exemplos como {a^n b^n | n ≥ 0} ou palíndromos, explicando o uso da pilha para empilhar e desempilhar símbolos correspondentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Linguagem e Definir Componentes Básicos do APND",
                                  "subSteps": [
                                    "Identifique o alfabeto de entrada (Σ), os símbolos da pilha (Γ) e os estados iniciais (Q0).",
                                    "Defina o estado inicial, o símbolo inicial da pilha (geralmente Z0) e os estados de aceitação (F).",
                                    "Escreva a representação formal da linguagem, como L = {a^n b^n | n ≥ 0} ou palíndromos pares/impares.",
                                    "Liste as transições principais necessárias: empilhamento, desempilhamento e matching.",
                                    "Desenhe um esboço inicial do diagrama de estados com pilha vazia."
                                  ],
                                  "verification": "Verifique se todos os componentes formais (Q, Σ, Γ, δ, q0, Z0, F) estão definidos e anotados corretamente.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Papel e lápis ou software de desenho de autômatos como JFLAP ou draw.io",
                                  "tips": "Comece sempre com o caso n=0 (string vazia) para garantir aceitação correta.",
                                  "learningObjective": "Compreender e formalizar os elementos constitutivos de um APND para uma dada LLC.",
                                  "commonMistakes": "Esquecer o símbolo inicial da pilha Z0 ou confundir Σ com Γ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Fase de Empilhamento",
                                  "subSteps": [
                                    "Crie transições para ler símbolos de empilhamento (ex: em {a^n b^n}, δ(q0, a, Z0) = (q1, A Z0) onde A é empilhado).",
                                    "Adicione loops para múltiplos símbolos: δ(q1, a, A) = (q1, A A).",
                                    "Inclua transição para mudar de fase após empilhamento: δ(q1, b, A) = (q2, ε) iniciando desempilhamento.",
                                    "Para palíndromos, empilhe a primeira metade e use um estado central para o meio.",
                                    "Anote todas as transições em uma tabela de transição."
                                  ],
                                  "verification": "Simule manualmente a configuração da pilha após ler 'aaa' para {a^n b^n}, confirmando que a pilha tem 'A A A Z0'.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": "JFLAP ou papel quadriculado para diagramas, tabela de transições em Excel/Google Sheets",
                                  "tips": "Use não-determinismo apenas quando necessário; para LLCs simples, mantenha determinístico onde possível.",
                                  "learningObjective": "Dominar o uso da pilha para armazenar símbolos de uma fase de entrada.",
                                  "commonMistakes": "Empilhar o símbolo errado ou não empilhar sobre o topo correto da pilha."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar Fase de Desempilhamento e Matching",
                                  "subSteps": [
                                    "Defina transições de pop: δ(q2, b, A) = (q2, ε) para matching em {a^n b^n}.",
                                    "Adicione verificação final: δ(q2, ε, Z0) = (qf, Z0) para aceitação quando pilha volta ao inicial.",
                                    "Para palíndromos, desempilhe comparando com símbolos lidos reversamente após o centro.",
                                    "Inclua rejeição implícita para mismatch (sem transição).",
                                    "Desenhe o diagrama completo conectando fases."
                                  ],
                                  "verification": "Trace a configuração para 'aabb': confirme que após 'aa' pilha=AAZ0, após 'bb' pilha=Z0, aceita em qf.",
                                  "estimatedTime": "60-75 minutos",
                                  "materials": "JFLAP para simulação passo-a-passo, folhas para traçar configurações",
                                  "tips": "Sempre pop apenas o topo e use ε para transições sem leitura de entrada.",
                                  "learningObjective": "Implementar lógica de matching LIFO (Last In, First Out) via pilha.",
                                  "commonMistakes": "Pop incorreto (ex: pop Z0 prematuramente) ou falta de loop no desempilhamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, Testar e Refinar o APND",
                                  "subSteps": [
                                    "Teste casos: n=0 (ε aceita), n=1 ('ab'), n=2 ('aabb'), inválidos ('aa', 'abb').",
                                    "Simule em ferramenta como JFLAP e corrija dead-ends ou loops infinitos.",
                                    "Verifique propriedades: aceita apenas LLC, rejeita regulares adequadamente.",
                                    "Adicione anotações explicativas no diagrama.",
                                    "Compare com APND padrão conhecido para o exemplo."
                                  ],
                                  "verification": "O APND aceita todas as strings válidas testadas e rejeita inválidas sem crash.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "JFLAP ou simulador online de APND, exemplos de strings impressos",
                                  "tips": "Teste strings de comprimento desigual primeiro para detectar mismatches rápidos.",
                                  "learningObjective": "Garantir correção e completude do APND através de testes exaustivos.",
                                  "commonMistakes": "Ignorar caso vazio ou aceitar strings inválidas como 'aba' em {a^n b^n}."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Generalizar para Outras LLCs",
                                  "subSteps": [
                                    "Escreva uma explicação textual das transições chave e papel da pilha.",
                                    "Generalize o padrão: empilhar → matching central → desempilhar para palíndromos.",
                                    "Crie variações: ex. {a^n b^n c^n} adicionando segunda pilha lógica.",
                                    "Exporte diagrama em imagem/PDF.",
                                    "Resuma lições aprendidas em bullet points."
                                  ],
                                  "verification": "Documento explica claramente por que o APND reconhece exatamente a LLC dada.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Editor de texto ou LaTeX para documentação, scanner para diagramas manuais",
                                  "tips": "Use pseudocódigo para descrever δ para clareza.",
                                  "learningObjective": "Aplicar o conhecimento para documentar e estender APNDs a novas LLCs.",
                                  "commonMistakes": "Focar só no diagrama sem explicação textual do raciocínio."
                                }
                              ],
                              "practicalExample": "Para L = {a^n b^n | n ≥ 0}: Estados q0 (inicial), q1 (empilhando A's), q2 (desempilhando B's), qf (aceita). Transições: δ(q0,a,Z0)=(q1,A Z0), δ(q1,a,A)=(q1,A A), δ(q1,b,A)=(q2,ε), δ(q2,b,A)=(q2,ε), δ(q2,ε,Z0)=(qf,Z0). Simulação 'aabb': após 'aa' em q1 pilha=AAZ0, após 'bb' em q2 pilha=Z0, aceita.",
                              "finalVerifications": [
                                "O APND aceita a string vazia e strings válidas como 'ab', 'aabb'.",
                                "Rejeita strings inválidas como 'a', 'abb', 'aa'.",
                                "A pilha retorna exatamente a Z0 no final para aceitação.",
                                "Não há loops infinitos ou dead-ends em caminhos válidos.",
                                "Diagrama está completo com todas as transições anotadas.",
                                "Simulação em JFLAP confirma pelo menos 5 casos de teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão das transições δ (correção formal).",
                                "Clareza e legibilidade do diagrama de estados/pilha.",
                                "Cobertura de casos edge (n=0, mismatch).",
                                "Explicação textual do uso da pilha (empilhar/desempilhar).",
                                "Generalização para palíndromos ou variações similares.",
                                "Eficiência: mínimo de estados e transições."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução em n para provar {a^n b^n} é LLC.",
                                "Programação: Implementar APND como stack em Python/Java.",
                                "Lógica: Equivalência PDA ~ Gramáticas Livres de Contexto.",
                                "Engenharia de Software: Parsers descendente/pilha em compiladores."
                              ],
                              "realWorldApplication": "APNDs são base para parsers em compiladores (ex: verificar chaves balanceadas em código fonte) e validadores XML/HTML, processando estruturas aninhadas como tags de abertura/fechamento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.4",
                            "name": "Diferenciar APD determinísticos e não-determinísticos",
                            "description": "Comparar APD (que reconhecem linguagens livres de contexto determinísticas, subconjunto próprio das LLC) com APND, citando exemplos como {ww^R} que requer não-determinismo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as Definições Formais de APD e APND",
                                  "subSteps": [
                                    "Estude a definição formal de um Autômato de Pilha Determinístico (APD): um septeto (Q, Σ, Γ, δ, q0, Z0, F) onde δ: Q × Σ × Γ → Q × Γ* é uma função total e única.",
                                    "Compare com Autômato de Pilha Não-Determinístico (APND): δ: Q × Σ × Γ → fin(P(Q × Γ*)) permitindo múltiplas transições.",
                                    "Revise o conceito de configuração (estado, fita de entrada restante, pilha) e como o não-determinismo cria ramos de computação.",
                                    "Desenhe diagramas simples de APD e APND para linguagens básicas como {a^n b^n}.",
                                    "Identifique que APDs são equivalentes a linguagens livres de contexto determinísticas (DCFLs)."
                                  ],
                                  "verification": "Construa um diagrama de um APD simples e explique verbalmente por que ele é determinístico (sem ambiguidades na transição).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 2)",
                                    "Notas de aula sobre autômatos de pilha",
                                    "Ferramenta JFLAP para simulação"
                                  ],
                                  "tips": "Sempre anote as transições em uma tabela para visualizar a unicidade das escolhas no APD.",
                                  "learningObjective": "Dominar as diferenças formais nas funções de transição entre APD e APND.",
                                  "commonMistakes": [
                                    "Confundir pilha com fita de Turing",
                                    "Ignorar que APD requer função total (sem ε-transições livres)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar os Poderes de Reconhecimento",
                                  "subSteps": [
                                    "Aprenda que todo DCFL é CFL, mas nem todo CFL é DCFL (APND > APD em poder).",
                                    "Estude teoremas: DCFLs são fechadas sob complemento, mas CFLs não; prefixos determinísticos.",
                                    "Analise propriedades: APDs não reconhecem todos os CFLs determinísticos por ambiguidade.",
                                    "Discuta simulações: APND pode ser simulado por APD com pilha extra, mas ineficiente.",
                                    "Liste linguagens DCFL clássicas: {a^n b^n}, parênteses balanceados simples."
                                  ],
                                  "verification": "Liste 3 propriedades exclusivas de DCFLs e prove uma com um exemplo contra-exemplo para CFLs.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigos sobre DCFL vs CFL (Wikipedia ou Stanford notes)",
                                    "Exercícios de Hopcroft/Ullman"
                                  ],
                                  "tips": "Use tabelas comparativas para propriedades (fechamento, determinismo, etc.).",
                                  "learningObjective": "Compreender hierarquia APD ⊂ APND e implicações em linguagens.",
                                  "commonMistakes": [
                                    "Achar que APD = APND em poder",
                                    "Confundir com autômatos finitos determinísticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos que Requerem Não-Determinismo",
                                  "subSteps": [
                                    "Estude o exemplo {ww^R | w ∈ {a,b}*}: palíndromos pares, reconhecível por APND (adivinha meio com não-determinismo).",
                                    "Construa um APND para {ww^R}: empilhe w, não-determinístico pop para w^R.",
                                    "Prove que não é DCFL: use pumping lemma para DCFLs ou ambiguidade no parsing.",
                                    "Compare com {w w | w ∈ {a,b}*}, que também requer APND.",
                                    "Simule em JFLAP para visualizar ramos não-determinísticos."
                                  ],
                                  "verification": "Desenhe o APND para {ww^R} e explique por que um APD falharia (múltiplas possibilidades no meio).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "JFLAP software",
                                    "Exemplos de Sipser Exercício 2.37",
                                    "Paper 'Deterministic Context-Free Languages'"
                                  ],
                                  "tips": "Teste strings como 'ab ba' para ver adivinhação funcionar só em APND.",
                                  "learningObjective": "Identificar linguagens que exigem APND através de exemplos concretos.",
                                  "commonMistakes": [
                                    "Esquecer ε-transições no APND",
                                    "Achar que todo palíndromo é DCFL"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Diferenciação e Verificação",
                                  "subSteps": [
                                    "Resolva exercícios: classifique linguagens como DCFL ou não (ex: {a^n b^m | n≤m} é DCFL?).",
                                    "Construa APD para DCFLs e tente falhar em APND-only.",
                                    "Discuta conversão APND para APD quando possível (usando powerset, mas exponencial).",
                                    "Crie contra-exemplos para propriedades DCFL.",
                                    "Autoavalie com quiz: defina, compare, exemplifique."
                                  ],
                                  "verification": "Resolva 5 exercícios mistos e corrija com soluções padrão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Lista de exercícios de linguagens formais (Sipser problemas)",
                                    "Quiz online sobre PDAs"
                                  ],
                                  "tips": "Sempre pergunte: 'Há escolha única em todo prefixo da entrada?' para DCFL.",
                                  "learningObjective": "Aplicar diferenciação em exercícios variados.",
                                  "commonMistakes": [
                                    "Não considerar pilha vazia em aceitação",
                                    "Ignorar aceitação por estado final vs pilha vazia"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente em JFLAP um APND para reconhecer {ww^R} com w=ab: empilhe 'a','b'; não-determinístico pop 'b','a' enquanto lê 'ba'. Tente converter para APD e veja falhar na adivinhação do comprimento de w.",
                              "finalVerifications": [
                                "Explique formalmente δ de APD vs APND.",
                                "Cite 2 linguagens DCFL e 2 que requerem APND.",
                                "Prove por que {ww^R} não é DCFL usando argumento de ambiguidade.",
                                "Simule uma string em ambos e destaque diferenças.",
                                "Liste 3 propriedades de DCFLs não compartilhadas por todos CFLs.",
                                "Construa diagrama de APND para palíndromo par."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (sem confusões com AFD/AFN).",
                                "Correta identificação de exemplos DCFL vs não-DCFL.",
                                "Compreensão de por que não-determinismo é necessário (ambiguidade).",
                                "Uso correto de ferramentas como JFLAP para simulação.",
                                "Capacidade de provar propriedades com contra-exemplos.",
                                "Clareza em diagramas e explicações verbais."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Ligação com Gramáticas Livres de Contexto.",
                                "Compiladores: Parsing determinístico (LR vs LL).",
                                "Lógica e Matemática: Conceitos de determinismo em provas.",
                                "Programação: Simulação de PDAs em Python recursivo.",
                                "Inteligência Artificial: Não-determinismo em busca (A*).",
                                "Algoritmos: Análise de complexidade em parsing."
                              ],
                              "realWorldApplication": "Em compiladores, parsers determinísticos (DPDA) permitem parsing em tempo linear O(n) para linguadores como C/Java (usando Yacc/Bison LR); APND modela parsers ambíguos como LL para linguagens como palíndromos em verificação de código simétrico ou protocolos de rede."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Autômatos de Pilha",
                    "description": "Modelos determinísticos e não-determinísticos para reconhecimento de linguagens livres de contexto.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Definição e Componentes do Autômato de Pilha",
                        "description": "Conceito fundamental que define a estrutura formal de um autômato de pilha (AP), incluindo seus componentes principais e o papel da pilha na memória auxiliar para reconhecimento de linguagens livres de contexto.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar os componentes formais de um AP",
                            "description": "Listar e descrever os elementos da tupla formal de um autômato de pilha: conjunto de estados Q, alfabeto de entrada Σ, alfabeto da pilha Γ, função de transição δ, estado inicial q0, símbolo inicial da pilha Z0 e estados de aceitação F.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura geral da tupla formal do Autômato de Pilha (AP)",
                                  "subSteps": [
                                    "Leia a definição formal de um AP como uma tupla de 7 componentes: (Q, Σ, Γ, δ, q0, Z0, F).",
                                    "Identifique que Q é o conjunto de estados, Σ o alfabeto de entrada, Γ o alfabeto da pilha, δ a função de transição, q0 o estado inicial, Z0 o símbolo inicial da pilha e F os estados de aceitação.",
                                    "Anote a tupla em um papel ou editor de texto para visualização.",
                                    "Compare com definições de autômatos finitos para destacar diferenças (presença de pilha).",
                                    "Desenhe um diagrama esquemático da tupla com setas conectando os componentes."
                                  ],
                                  "verification": "Conseguir recitar a tupla completa sem consultar notas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Livro ou slides de Teoria da Computação"
                                  ],
                                  "tips": "Use mnemônicos como 'QΣΓδqZ0F' para memorizar a ordem.",
                                  "learningObjective": "Compreender a composição exata da tupla formal de um AP.",
                                  "commonMistakes": [
                                    "Confundir ordem dos componentes",
                                    "Esquecer Z0 ou Γ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar os componentes de estados e entrada (Q, Σ, q0, F)",
                                  "subSteps": [
                                    "Defina Q como conjunto finito de estados e liste exemplos como {q0, q1, q2}.",
                                    "Explique Σ como alfabeto finito de símbolos de entrada, ex: {a, b}.",
                                    "Descreva q0 como o estado inicial único e F como subconjunto de Q de estados aceitadores.",
                                    "Crie exemplos próprios: Q = {q0, q1}, Σ = {0,1}, q0 = q0, F = {q1}.",
                                    "Verifique se q0 ∈ Q e F ⊆ Q."
                                  ],
                                  "verification": "Escrever definições precisas e exemplos corretos para cada um.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula",
                                    "Exemplos de APs online"
                                  ],
                                  "tips": "Pense em Q como 'quartos' do autômato e Σ como 'sinais de entrada'.",
                                  "learningObjective": "Dominar os componentes relacionados a estados e entrada.",
                                  "commonMistakes": [
                                    "Achar que Σ inclui símbolos da pilha",
                                    "Confundir q0 com estados de F"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar componentes da pilha e transição (Γ, Z0, δ)",
                                  "subSteps": [
                                    "Defina Γ como alfabeto finito da pilha, ex: {Z0, A, B}.",
                                    "Explique Z0 como símbolo inicial empilhado no início.",
                                    "Descreva δ: Q × (Σ ∪ {ε}) × Γ → 2^{Q × Γ} (função parcial de transição).",
                                    "Estude a transição: de (estado, entrada/ε, topo pilha) para conjuntos de (novo estado, novo topo).",
                                    "Simule uma transição manual: δ(q0, a, Z0) = {(q1, AZ0)}."
                                  ],
                                  "verification": "Simular corretamente 2-3 transições de exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de AP online ou papel para simulação",
                                    "Pseudocódigo de δ"
                                  ],
                                  "tips": "Visualize a pilha crescendo/encolhendo como uma torre de pratos.",
                                  "learningObjective": "Compreender o papel da pilha na transição.",
                                  "commonMistakes": [
                                    "Ignorar ε em transições",
                                    "Confundir Γ com Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e integração dos componentes",
                                  "subSteps": [
                                    "Analise uma tupla de AP exemplo e rotule cada componente.",
                                    "Construa uma tupla completa para um AP simples (ex: palíndromos pares).",
                                    "Identifique componentes em definições textuais ou diagramas.",
                                    "Compare tuplas de diferentes APs para padrões comuns.",
                                    "Resolva exercícios: 'Dado AP = (Q, Σ,...), liste os 7 itens'."
                                  ],
                                  "verification": "Identificar corretamente componentes em 3 exemplos diferentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exercícios de livros ou sites como GeeksforGeeks",
                                    "Exemplos impressos"
                                  ],
                                  "tips": "Sempre verifique se a tupla tem exatamente 7 elementos.",
                                  "learningObjective": "Aplicar conhecimento para identificar componentes em contextos variados.",
                                  "commonMistakes": [
                                    "Trocar δ por função de aceitação",
                                    "Omitir F"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o AP para a linguagem {ww^R | w ∈ {a,b}*}: Q = {q0, q1, q2}, Σ = {a,b}, Γ = {Z0, a, b}, δ(q0, a, Z0) = {(q1, aZ0)}, δ(q1, a, a) = {(q1, aa)}, δ(q1, ε, a) = {(q2, ε)} (simplificado), q0 = q0, Z0 = Z0, F = {q2}. Identifique: Q é estados, Σ entradas, etc.",
                              "finalVerifications": [
                                "Listar os 7 componentes na ordem correta sem erros.",
                                "Explicar o papel de δ com um exemplo de transição.",
                                "Diferenciar Γ de Σ corretamente.",
                                "Identificar q0 e Z0 em uma tupla dada.",
                                "Reconhecer F como subconjunto de Q.",
                                "Simular aceitação básica de uma palavra."
                              ],
                              "assessmentCriteria": [
                                "Precisão na recitação da tupla (100% dos componentes).",
                                "Correta descrição funcional de cada componente.",
                                "Habilidade em simular transições com pilha.",
                                "Identificação correta em exemplos não triviais.",
                                "Uso adequado de notação formal (ex: δ: Q × ...).",
                                "Ausência de confusões entre componentes semelhantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos (Q, Σ, Γ como conjuntos finitos) e funções parciais.",
                                "Lógica: Estados e transições semelhantes a máquinas de estados lógicas.",
                                "Programação: Implementação de pilhas em linguagens como Python ou Java para simular AP.",
                                "Linguística Computacional: Parsing de gramáticas livres de contexto."
                              ],
                              "realWorldApplication": "Autômatos de pilha são fundamentais em compiladores para análise sintática de linguagens de programação (ex: parsers LL ou LR em ferramentas como Yacc/Bison), validando estruturas aninhadas como chaves {} ou parênteses em código."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Descrever configurações e transições em um AP",
                            "description": "Explicar uma configuração de AP como (q, w, α), onde q é o estado, w a fita de entrada restante e α o conteúdo da pilha, e detalhar como as transições δ(q, a, Z) = (p, γ) alteram estado, consomem entrada e modificam a pilha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes de uma configuração em um Autômato de Pilha (AP)",
                                  "subSteps": [
                                    "Identifique os três elementos principais: estado (q), fita de entrada restante (w) e conteúdo da pilha (α).",
                                    "Aprenda que q ∈ Q (conjunto de estados), w ∈ Σ* (alfabeto de entrada) e α ∈ Γ* (alfabeto da pilha).",
                                    "Estude a representação notacional: (q, w, α), onde α é lida do topo para a base.",
                                    "Diferencie pilha (LIFO) da fita de entrada (sequencial).",
                                    "Anote exemplos simples: configuração inicial (q0, w, ε) onde ε é pilha vazia."
                                  ],
                                  "verification": "Escreva 3 configurações exemplo e explique cada componente verbalmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de AP impresso ou digital"
                                  ],
                                  "tips": "Visualize a pilha como uma pilha de pratos: último empilhado é o primeiro removido.",
                                  "learningObjective": "Definir e representar corretamente os componentes de uma configuração de AP.",
                                  "commonMistakes": "Confundir ordem da pilha (topo é o fim da string α) ou tratar pilha como fila."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a função de transição δ em um AP",
                                  "subSteps": [
                                    "Memorize a assinatura: δ: Q × (Σ ∪ {ε}) × Γ → P(Q × Γ*), onde lê estado, símbolo de entrada (ou ε) e topo da pilha.",
                                    "Entenda a saída: (p, γ), onde p é novo estado e γ substitui o topo Z por uma string γ (pop/push).",
                                    "Classifique transições: pop (γ vazio), push (γ com símbolos novos), replace.",
                                    "Estude transições ε (sem consumir entrada).",
                                    "Liste símbolos: a ∈ Σ (entrada), Z ∈ Γ (topo pilha)."
                                  ],
                                  "verification": "Descreva δ(q, a, Z) = (p, γ) para um exemplo fictício, especificando mudanças.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Quadro branco ou editor de texto",
                                    "Tabela de transições de um AP exemplo"
                                  ],
                                  "tips": "Pense em δ como 'se estado=q E entrada=a E topo=Z, vá para p E troque Z por γ'.",
                                  "learningObjective": "Explicar precisamente como δ é definida e seus parâmetros de entrada/saída.",
                                  "commonMistakes": "Ignorar ε-movimentos ou confundir Σ (entrada) com Γ (pilha)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever como uma transição altera uma configuração",
                                  "subSteps": [
                                    "Dado (q, aw, Zα), aplique δ(q, a, Z) = (p, γ): nova configuração (p, w, γα).",
                                    "Simule passo a passo: consuma a de w, pop Z, push γ no topo.",
                                    "Considere casos: se w vazio, pare; se pilha vazia, verifique rejeição.",
                                    "Registre sequências de configurações: inicial → após transição 1 → ...",
                                    "Pratique com transição ε: (q, w, α) → (p, w, γ resto de α)."
                                  ],
                                  "verification": "Transforme uma configuração inicial em uma após 2 transições, justificando cada mudança.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador online de AP (ex: JFLAP)",
                                    "Papel para desenhar fita e pilha"
                                  ],
                                  "tips": "Desenhe setas: fita ←a (consome), pilha: Z → γ (substitui).",
                                  "learningObjective": "Simular e descrever a evolução de configurações via transições δ.",
                                  "commonMistakes": "Esquecer de concatenar γ com o resto da pilha (γα) ou não consumir entrada corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar descrição completa de configurações e transições",
                                  "subSteps": [
                                    "Escolha um AP simples (ex: reconhecedor de {a^n b^n}).",
                                    "Descreva configuração inicial para entrada 'aabb'.",
                                    "Aplique transições sequencialmente, listando todas configurações.",
                                    "Identifique configuração final de aceitação (estado final, entrada vazia, pilha irrelevante).",
                                    "Compare com rejeição (sem transição possível)."
                                  ],
                                  "verification": "Produza um relatório escrito de 5-10 configurações para uma entrada dada.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "JFLAP ou papel",
                                    "Exemplo de AP com tabela δ"
                                  ],
                                  "tips": "Use tabelas para listar: Passo | Config | Transição aplicada | Nova Config.",
                                  "learningObjective": "Descrever fluentemente sequências de configurações e transições em um AP.",
                                  "commonMistakes": "Parar prematuramente sem esgotar entrada ou ignorar pilha em aceitação."
                                }
                              ],
                              "practicalExample": "Para AP reconhecendo {a^n b^n | n≥0}, configuração inicial: (q0, aabb, ε). Transição δ(q0, a, ε)=(q1, Aε) → (q1, abb, A). Próxima: δ(q1, a, A)=(q1, AA) → (q1, bb, AA), e assim por diante até aceitação em (qf, ε, A...A) após pops com b's.",
                              "finalVerifications": [
                                "Pode representar qualquer configuração como (q, w, α) corretamente?",
                                "Explica δ(q, a, Z)=(p, γ) e suas mudanças em estado, entrada e pilha?",
                                "Simula 3 transições sequenciais sem erros?",
                                "Identifica configuração inicial e de aceitação?",
                                "Diferencia pop, push e ε-transições?",
                                "Descreve verbalmente uma sequência completa para entrada exemplo?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação de configuração (100% dos componentes corretos).",
                                "Correta aplicação de δ: mudanças em q, w, α exatas (90%+ acurácia).",
                                "Detalhe em descrições: inclui todos parâmetros e justificativas.",
                                "Simulação fluida: sequências lógicas sem saltos.",
                                "Uso de exemplos concretos e distinção de casos especiais (ε, pilha vazia).",
                                "Clareza na explicação escrita/oral: acessível e sem ambiguidades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções parciais e relações em teoria dos conjuntos.",
                                "Programação: Estruturas de pilha (stack) em linguagens como Python/Java.",
                                "Lógica: Estados e transições semelhantes a máquinas de estados finitos.",
                                "Engenharia de Software: Parsers descendente/pushdown em compiladores."
                              ],
                              "realWorldApplication": "Autômatos de pilha modelam parsers em compiladores (ex: Yacc/Bison para linguagens de programação), validando sintaxe recursiva como expressões aninhadas, essenciais em desenvolvimento de software e processamento de linguagens naturais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Explicar o papel da pilha como memória auxiliar",
                            "description": "Demonstrar como a pilha permite que o AP reconheça linguagens livres de contexto, como {a^n b^n}, empilhando símbolos de entrada e desempilhando para verificação, superando limitações de autômatos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as limitações dos autômatos finitos (AFAs)",
                                  "subSteps": [
                                    "Revisar a definição de autômatos finitos e suas linguagens regulares.",
                                    "Analisar o exemplo da linguagem {a^n b^n | n ≥ 1} e por que ela não é regular.",
                                    "Aplicar o lema de bombeamento de pumping para provar a não-regularidade.",
                                    "Discutir como a memória finita dos AFAs impede o 'contagem' ilimitada.",
                                    "Comparar com linguagens regulares simples como {a*b*}."
                                  ],
                                  "verification": "Explicar em voz alta ou por escrito por que um AFA falha em reconhecer {a^n b^n} para n grande.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Papel e caneta para diagramas de AFAs",
                                    "Vídeo tutorial sobre lema de bombeamento"
                                  ],
                                  "tips": "Use exemplos concretos com n=1,2,3 para visualizar o problema de memória.",
                                  "learningObjective": "Identificar linguagens não regulares e as limitações inerentes à memória finita dos AFAs.",
                                  "commonMistakes": [
                                    "Confundir {a^n b^n} com linguagens regulares como a*b*",
                                    "Ignorar o lema de bombeamento ao provar não-regularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a estrutura e operações da pilha como memória LIFO",
                                  "subSteps": [
                                    "Definir pilha como estrutura de dados LIFO (Last In, First Out).",
                                    "Explicar operações básicas: push (empilhar), pop (desempilhar), top (topo) e empty (vazia).",
                                    "Desenhar diagramas ilustrando o estado da pilha após cada operação.",
                                    "Comparar com memória finita dos AFAs: pilha permite memória ilimitada e não determinística.",
                                    "Discutir símbolos de pilha e alfabeto da pilha (Γ)."
                                  ],
                                  "verification": "Simular manualmente push/pop para uma sequência de 5 símbolos e descrever o estado final.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama em branco para pilha",
                                    "Simulador online de pilha (ex: visualgo.net)",
                                    "Notas sobre componentes do AP"
                                  ],
                                  "tips": "Pense na pilha como uma 'pilha de pratos': só acessa o de cima.",
                                  "learningObjective": "Dominar as operações fundamentais da pilha e seu papel como memória auxiliar ilimitada.",
                                  "commonMistakes": [
                                    "Confundir LIFO com FIFO (fila)",
                                    "Esquecer que a pilha pode crescer ilimitadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar o uso da pilha no reconhecimento de {a^n b^n}",
                                  "subSteps": [
                                    "Descrever a configuração do AP: estados, transições que empilham 'A' para cada 'a'.",
                                    "Simular empilhamento durante fase de 'a's: push 'A' para cada 'a' lida.",
                                    "Simular desempilhamento durante fase de 'b's: pop 'A' para cada 'b', falha se não combinar.",
                                    "Verificar aceitação: pilha vazia e fim da entrada no estado final.",
                                    "Testar com strings inválidas como 'aaabb' para mostrar rejeição."
                                  ],
                                  "verification": "Executar simulação completa para 'aabbb' e confirmar aceitação passo a passo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabela de transições do AP para {a^n b^n}",
                                    "Ferramenta JFLAP para simulação de AP",
                                    "Papel para rastrear configuração (q, w, γ)"
                                  ],
                                  "tips": "Rastreie sempre a configuração (estado, posição na fita, conteúdo da pilha).",
                                  "learningObjective": "Aplicar a pilha para resolver problemas de contagem balanceada em linguagens livres de contexto.",
                                  "commonMistakes": [
                                    "Empilhar 'b' em vez de 'a'",
                                    "Não verificar pilha vazia no final"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar o papel da pilha e comparar poderes de modelos",
                                  "subSteps": [
                                    "Explicar como a pilha supera AFAs para linguagens livres de contexto (LLC).",
                                    "Discutir equivalência formal: toda LLC é reconhecida por algum AP.",
                                    "Comparar com autômatos de fita (TMs) para linguagens recursivas.",
                                    "Explorar limitações dos APs (não reconhecem {a^n b^n c^n}).",
                                    "Refletir sobre aplicações em parsing e recursão."
                                  ],
                                  "verification": "Resumir em um parágrafo como a pilha habilita reconhecimento de LLCs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela comparativa AFAs vs APs vs TMs",
                                    "Exemplos de LLCs adicionais como parênteses balanceados"
                                  ],
                                  "tips": "Ligue à hierarquia de Chomsky: regulares < LLCs < CSLs.",
                                  "learningObjective": "Compreender o papel transformador da pilha na teoria da computação.",
                                  "commonMistakes": [
                                    "Superestimar poder dos APs (confundir com TMs)",
                                    "Ignorar não-determinismo nos APs"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um AP não-determinístico para {a^n b^n | n ≥ 1} processando 'aaabbb': 1. Leia 'aaa', empilhe três 'A's (pilha: AAA). 2. NDFA adivinha fim de a's, transita para estado de b's. 3. Leia 'bbb', desempilhe um 'A' por 'b' (pilha vazia após terceiro). 4. Aceita se pilha vazia e fim da fita. Para 'aabbb' (n=2,m=3), rejeita ao tentar pop em pilha vazia.",
                              "finalVerifications": [
                                "Explica corretamente por que AFAs falham em {a^n b^n}.",
                                "Descreve operações push/pop/top com exemplos visuais.",
                                "Simula com sucesso o AP para strings válidas e inválidas.",
                                "Identifica o papel LIFO da pilha como chave para LLCs.",
                                "Compara hierarquia: AFAs ⊂ APs.",
                                "Menciona configuração (q, i, γ) do AP."
                              ],
                              "assessmentCriteria": [
                                "Clareza na distinção entre memória finita e ilimitada LIFO.",
                                "Precisão na simulação passo a passo do exemplo {a^n b^n}.",
                                "Uso correto de terminologia (push, pop, γ, não-determinismo).",
                                "Profundidade na generalização para outras LLCs.",
                                "Capacidade de diagramar estados e pilha.",
                                "Identificação de erros comuns em simulações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recursão e indução em contagens balanceadas.",
                                "Programação: Implementação de stacks em linguagens como Python (list.pop()).",
                                "Lógica: Verificação de fórmulas bem-formadas em lógica proposicional.",
                                "Engenharia de Software: Parsing em compiladores (ex: expressões aritméticas)."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, APs modelam analisadores sintáticos para verificar balanceamento de chaves/parênteses em código-fonte, essencial para detecção de erros em linguagens como C++ ou Python, permitindo parsing eficiente de estruturas aninhadas recursivas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Autômatos de Pilha Não-Determinísticos (APND)",
                        "description": "Modelo não-determinístico de autômato de pilha, capaz de múltiplas transições simultâneas, equivalente ao reconhecimento de todas as linguagens livres de contexto por aceitação final ou por pilha vazia.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Definir formalmente um APND",
                            "description": "Especificar a função de transição não-determinística δ: Q × (Σ ∪ {ε}) × Γ → finita(Q × Γ*), permitindo ε-movimentos e múltiplas escolhas, e descrever aceitação por estado final ou pilha vazia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os componentes fundamentais de um Autômato de Pilha Não-Determinístico (APND)",
                                  "subSteps": [
                                    "Identifique os cinco componentes principais de um APND: conjunto de estados Q, alfabeto de entrada Σ, alfabeto da pilha Γ, estado inicial q0 e estados finais F.",
                                    "Diferencie APND de AFD ou AP determinísticos, destacando o uso de pilha e não-determinismo.",
                                    "Estude a notação formal: APND = (Q, Σ, Γ, q0, F, δ), onde δ é a função de transição.",
                                    "Revise exemplos simples de linguagens livres de contexto reconhecidas por APND, como {a^n b^n | n ≥ 0}.",
                                    "Anote as diferenças entre movimentos ε e símbolos de entrada reais."
                                  ],
                                  "verification": "Crie um diagrama esquemático de um APND simples e liste corretamente os 6 componentes formais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Folha de papel e caneta para diagramas",
                                    "Vídeo tutorial sobre autômatos de pilha (YouTube/Khan Academy)"
                                  ],
                                  "tips": [
                                    "Use mnemônicos como 'Q-Sigma-Gamma-q0-F-Delta' para memorizar componentes.",
                                    "Desenhe a pilha como uma torre para visualizar melhor."
                                  ],
                                  "learningObjective": "Compreender e listar todos os componentes formais de um APND.",
                                  "commonMistakes": [
                                    "Confundir Σ (entrada) com Γ (pilha).",
                                    "Esquecer o estado inicial q0 ou estados finais F.",
                                    "Ignorar o não-determinismo na função δ."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os conjuntos básicos e o estado inicial",
                                  "subSteps": [
                                    "Defina Q como um conjunto finito de estados, ex: Q = {q0, q1, qf}.",
                                    "Especifique Σ como alfabeto finito de símbolos de entrada, ex: Σ = {a, b}.",
                                    "Defina Γ como alfabeto finito da pilha, incluindo símbolo inicial Z0, ex: Γ = {a, b, Z0}.",
                                    "Escolha q0 ∈ Q como estado inicial.",
                                    "Defina F ⊆ Q como conjunto de estados finais aceitadores."
                                  ],
                                  "verification": "Escreva definições formais para Q, Σ, Γ, q0 e F para um exemplo específico.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou LaTeX para notação matemática",
                                    "Exemplos de APND de aulas anteriores"
                                  ],
                                  "tips": [
                                    "Sempre inclua Z0 em Γ para marcar o fundo da pilha.",
                                    "Garanta que Q seja finito e discreto."
                                  ],
                                  "learningObjective": "Especificar corretamente os conjuntos e estados iniciais em uma definição formal de APND.",
                                  "commonMistakes": [
                                    "Definir Q ou Σ como infinitos.",
                                    "Omitir Z0 de Γ.",
                                    "Colocar q0 não pertencente a Q."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar a função de transição δ formalmente",
                                  "subSteps": [
                                    "Defina o domínio: Q × (Σ ∪ {ε}) × Γ → potênciado de (Q × Γ*).",
                                    "Explique que δ(q, a, X) é um conjunto finito de pares (p, α), onde α ∈ Γ* (cadeia para empilhar/pop).",
                                    "Inclua ε-movimentos: δ(q, ε, X) permite transições sem consumir entrada.",
                                    "Descreva não-determinismo: múltiplos pares possíveis para a mesma entrada.",
                                    "Escreva exemplos: δ(q0, a, Z0) = {(q1, aZ0)}, δ(q1, ε, a) = {(q1, ε)} para pop."
                                  ],
                                  "verification": "Escreva δ com pelo menos 3 transições, incluindo uma ε e uma com empilhamento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io para grafos de transição",
                                    "Papel para tabelas de δ"
                                  ],
                                  "tips": [
                                    "Use notação de conjunto: δ(q,a,X) = {(p1, γ1), (p2, γ2), ...}.",
                                    "Teste δ com uma string curta para validar."
                                  ],
                                  "learningObjective": "Formalizar a função δ capturando não-determinismo, ε-movimentos e operações na pilha.",
                                  "commonMistakes": [
                                    "Escrever δ como função determinística (retornando um único par).",
                                    "Confundir Γ* com Γ (cadeia vs símbolo único).",
                                    "Esquecer ε no domínio."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever os mecanismos de aceitação",
                                  "subSteps": [
                                    "Explique aceitação por estado final: configuração final em qf ∈ F, independentemente da pilha.",
                                    "Descreva aceitação por pilha vazia: atinge estado com pilha vazia, independentemente de F.",
                                    "Defina configuração: (q, w, α) onde w é resto da entrada, α topo da pilha.",
                                    "Especifique que APND pode usar ambos ou um, mas formalize um.",
                                    "Compare com APD (determinístico) para reforçar diferenças."
                                  ],
                                  "verification": "Redija uma definição completa de APND incluindo o tipo de aceitação escolhido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre linguagens livres de contexto",
                                    "Simulador online de autômatos de pilha (ex: JFLAP)"
                                  ],
                                  "tips": [
                                    "Prefira aceitação por estado final para simplicidade inicial.",
                                    "Simule uma computação passo a passo."
                                  ],
                                  "learningObjective": "Completar a definição formal de APND com critérios de aceitação precisos.",
                                  "commonMistakes": [
                                    "Confundir aceitação por pilha vazia com estado final.",
                                    "Não especificar o tipo de aceitação na definição."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar e validar a definição formal completa de um APND",
                                  "subSteps": [
                                    "Compile todos os componentes em uma tupla: (Q, Σ, Γ, q0, F, δ).",
                                    "Especifique o tipo de aceitação explicitamente.",
                                    "Teste a definição simulando uma string na linguagem-alvo.",
                                    "Verifique se δ respeita o domínio e codomínio corretos.",
                                    "Documente em formato LaTeX ou texto formal."
                                  ],
                                  "verification": "Produza uma definição formal completa e valide com uma simulação de aceitação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JFLAP ou similar para simulação",
                                    "Template LaTeX para definições formais"
                                  ],
                                  "tips": [
                                    "Use δ parcial; nem todas entradas precisam de transições.",
                                    "Sempre valide com string aceita e rejeitada."
                                  ],
                                  "learningObjective": "Construir e validar uma definição formal integral de APND.",
                                  "commonMistakes": [
                                    "Incluir componentes extras ou faltantes na tupla.",
                                    "δ não ser finita ou multivalorada."
                                  ]
                                }
                              ],
                              "practicalExample": "Defina formalmente um APND para L = {a^n b^n | n ≥ 0}: Q = {q0, q1, q2}, Σ = {a, b}, Γ = {a, Z0}, q0 inicial, F = {q2}, δ inclui: δ(q0, a, Z0) = {(q1, aZ0)}, δ(q1, a, a) = {(q1, aa)}, δ(q1, b, a) = {(q1, ε)}, δ(q1, ε, Z0) = {(q2, Z0)}. Aceita por estado final q2.",
                              "finalVerifications": [
                                "Liste corretamente os 6 componentes da tupla APND.",
                                "Escreva δ com ε-movimento e empilhamento/pop.",
                                "Simule aceitação de 'aabb' terminando em estado final.",
                                "Explique não-determinismo com um exemplo de múltiplas transições.",
                                "Diferencie aceitação por estado final vs pilha vazia.",
                                "Valide que δ: Q × (Σ ∪ {ε}) × Γ → finita(Q × Γ*)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal de δ (domínio/codomínio corretos).",
                                "Inclusão de ε-movimentos e não-determinismo explícitos.",
                                "Correção dos componentes Q, Σ, Γ, q0, F.",
                                "Clareza na descrição de aceitação.",
                                "Validação prática via simulação de string.",
                                "Ausência de erros comuns como confusão de símbolos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções multivaloradas.",
                                "Lógica: Não-determinismo similar a escolha não-determinística em provas.",
                                "Programação: Modelagem de parsers recursivos em compiladores.",
                                "Filosofia da Computação: Limites da computabilidade e poder expressivo."
                              ],
                              "realWorldApplication": "APNDs modelam parsers para linguagens de programação (ex: ANTLR usa conceitos semelhantes para gramáticas livres de contexto), validação de XML balanceado e análise sintática em ferramentas de desenvolvimento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Construir e simular um APND para uma linguagem LFC",
                            "description": "Projetar um APND para reconhecer {a^n b^n | n ≥ 0}, simulando passo a passo a execução não-determinística, incluindo ramificações e aceitação se houver pelo menos um caminho bem-sucedido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a linguagem e planejar o comportamento do APND",
                                  "subSteps": [
                                    "Identifique a linguagem L = {a^n b^n | n ≥ 0}, incluindo o caso vazio (ε).",
                                    "Defina o papel da pilha: empilhar símbolos 'A' para cada 'a' lido e desempilhar para cada 'b'.",
                                    "Planeje os estados principais: q0 (inicial), q1 (lendo a's), q2 (lendo b's), qf (aceitação).",
                                    "Considere a não-determinização: transições para adivinhar o fim dos a's.",
                                    "Esboce ramificações potenciais na simulação."
                                  ],
                                  "verification": "Confirme que o plano descreve empilhamento/desempilhamento balanceado e aceitação por caminho bem-sucedido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou editor de texto para anotações.",
                                  "tips": "Comece pelo caso n=0 (ε deve ser aceito sem ler nada).",
                                  "learningObjective": "Compreender como a pilha modela contagens balanceadas em linguagens LFC.",
                                  "commonMistakes": "Esquecer o caso ε ou confundir ordem de empilhamento (não empilhar b's primeiro)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o diagrama formal do APND",
                                  "subSteps": [
                                    "Defina o conjunto de estados: Q = {q0, q1, q2, qf}.",
                                    "Especifique o alfabeto de entrada Σ = {a, b} e pilha Γ = {Z0, A}, com Z0 como fundo.",
                                    "Desenhe transições: δ(q0, ε, Z0) = {(q1, Z0)}, δ(q1, a, Z0) = {(q1, A Z0)}, δ(q1, a, A) = {(q1, A A)}, δ(q1, ε, A) = {(q2, A)}, δ(q2, b, A) = {(q2, ε)}, δ(q2, ε, Z0) = {(qf, Z0)}.",
                                    "Marque estado inicial q0 e final qf.",
                                    "Valide que não há transições para b em q1 ou a em q2."
                                  ],
                                  "verification": "O diagrama deve ter todas as transições listadas corretamente e pilha vazia só em aceitação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de desenho como Draw.io, Lucidchart ou papel quadriculado.",
                                  "tips": "Use setas duplas para não-determinismo e rotule transições como (leitura, pop/empurrar).",
                                  "learningObjective": "Formalizar a definição de um APND com transições de pilha precisas.",
                                  "commonMistakes": "Omitir a transição não-determinística ε de q1 para q2 ou usar pop incorreto em δ(q2, b, A)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular a execução não-determinística passo a passo",
                                  "subSteps": [
                                    "Escolha uma string de teste, ex: w = aabb.",
                                    "Inicie configuração: (q0, aabb, Z0).",
                                    "Expanda ramificações: de q0 → q1 (aabb, Z0); leia primeiro a → q1 (abb, A Z0); segundo a → q1 (bb, A A Z0); ε para q2 (bb, A A Z0).",
                                    "Continue: primeiro b → q2 (b, A Z0); segundo b → q2 (ε, Z0); ε para qf (ε, Z0).",
                                    "Registre caminhos falhos, ex: adivinhar cedo demais leva a rejeição."
                                  ],
                                  "verification": "Pelo menos um caminho atinge qf com pilha só Z0 e fita vazia.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabela de simulação em planilha ou papel com colunas para configuração, fita, pilha, estado.",
                                  "tips": "Desenhe uma árvore de ramificações para visualizar todos os caminhos.",
                                  "learningObjective": "Executar simulação mostrando poder da não-determinização.",
                                  "commonMistakes": "Ignorar ramificações falhas ou confundir pop (remover topo) com push."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar aceitação e testar generalização",
                                  "subSteps": [
                                    "Teste strings aceitas: ε, ab, aabb, aaabbb.",
                                    "Teste rejeitadas: b, aa, abbb, aba.",
                                    "Confirme: aceitação se ∃ caminho para qf com fita e pilha vazia (exceto Z0).",
                                    "Analise por que rejeita: desbalanceamento detectado em todos os caminhos.",
                                    "Documente lições sobre LFC não reconhecíveis por AFD/APD determinísticos."
                                  ],
                                  "verification": "Todas strings de teste têm resultado correto com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesma tabela de simulação do passo anterior.",
                                  "tips": "Automatize testes com software como JFLAP se disponível.",
                                  "learningObjective": "Validar corretude do APND para a linguagem inteira.",
                                  "commonMistakes": "Aceitar incorretamente strings desbalanceadas por erro na simulação."
                                }
                              ],
                              "practicalExample": "Para w = aabb: Caminho bem-sucedido: empilhe A para cada a (pilha: A A Z0), transite não-det. para q2, desempilhe A para cada b, atinja qf com pilha Z0. Caminhos falhos: transitar cedo para q2 rejeita por b sem A topo.",
                              "finalVerifications": [
                                "O APND aceita ε indo diretamente de q0 a qf via transições apropriadas?",
                                "Para aabb, existe pelo menos um caminho que empilha 2 A's e desempilha corretamente?",
                                "String 'abbb' é rejeitada em todos os caminhos devido a b extra?",
                                "String 'aab' é rejeitada por falta de b ou pilha não vazia?",
                                "O diagrama inclui todas as transições necessárias sem ambiguidades?",
                                "Simulação mostra explicitamente ramificações não-determinísticas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão do diagrama de estados e transições de pilha (100% corretas).",
                                "Simulação detalhada com árvore de ramificações para string de teste.",
                                "Correta identificação de aceitação por existência de caminho bem-sucedido.",
                                "Testes em múltiplas strings (aceitas e rejeitadas) com justificativas.",
                                "Explicação clara do papel da pilha no reconhecimento de balanceamento.",
                                "Ausência de erros comuns como confusão entre push/pop."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recursão e indução para provar {a^n b^n} é LFC.",
                                "Programação: Implementação de stack em parsers para parênteses balanceados.",
                                "Lógica: Não-determinismo similar a backtracking em algoritmos de busca.",
                                "Engenharia de Software: Modelagem de linguagens em compiladores."
                              ],
                              "realWorldApplication": "Projetar parsers para linguagens de programação que verificam estruturas balanceadas como chaves {} ou parênteses (), essenciais em compiladores e interpretadores como os do Python ou Java."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Converter modos de aceitação em APND",
                            "description": "Transformar um APND por aceitação final em equivalente por pilha vazia e vice-versa, adicionando estados e símbolos de pilha auxiliares para preservar o poder de reconhecimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o APND Original e Identificar o Modo de Aceitação",
                                  "subSteps": [
                                    "Leia a definição formal do APND: para aceitação final (Q, Σ, Γ, δ, q0, Z0, F); para pilha vazia (Q, Σ, Γ, δ, q0).",
                                    "Identifique o modo de aceitação examinando se há conjunto F de estados finais ou se é especificado como pilha vazia.",
                                    "Trace a computação de uma string de exemplo (aceita e rejeitada), registrando estados, entrada consumida e conteúdo da pilha no final.",
                                    "Desenhe o diagrama de estados e transições, destacando símbolos de pilha envolvidos.",
                                    "Anote o símbolo inicial Z0 e como a pilha evolui."
                                  ],
                                  "verification": "Escreva um resumo da definição formal e traces de 2 strings (uma aceita, uma rejeitada), confirmando o modo de aceitação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Definição formal do APND",
                                    "Papel/caneta ou ferramenta de diagrama como Draw.io",
                                    "Exemplos de linguagens LFC como {a^n b^n}"
                                  ],
                                  "tips": "Use notação formal precisa; trace passo a passo para evitar ambiguidades.",
                                  "learningObjective": "Identificar com precisão o modo de aceitação e simular computações básicas de um APND.",
                                  "commonMistakes": [
                                    "Confundir aceitação por estado final com pilha vazia",
                                    "Ignorar transições ε em pilha ou entrada",
                                    "Não considerar não-determinismo nas branches"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter APND por Aceitação Final para Equivalente por Pilha Vazia",
                                  "subSteps": [
                                    "Crie novo conjunto de estados Q' = Q ∪ {q_start, q_dump}, com q_start inicial.",
                                    "Adicione transição inicial: δ(q_start, ε, ε) = (q0, Z0).",
                                    "Copie todas as transições δ do APND original para Q'.",
                                    "Para cada f ∈ F e X ∈ Γ, adicione δ(f, ε, X) = (q_dump, ε).",
                                    "Para q_dump e todo X ∈ Γ, adicione δ(q_dump, ε, X) = (q_dump, ε) (estado sink para drenar pilha)."
                                  ],
                                  "verification": "Construa a definição formal completa do novo APND e simule uma string aceita, confirmando que pilha esvazia apenas em aceitação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Diagrama do APND original",
                                    "Tabela de transições vazia",
                                    "Símbolos Γ expandidos"
                                  ],
                                  "tips": "Garanta que q_dump seja acessível apenas de estados finais; teste com string que deixa pilha não-vazia sem q_dump.",
                                  "learningObjective": "Construir um APND equivalente por pilha vazia preservando o poder de reconhecimento.",
                                  "commonMistakes": [
                                    "Esquecer cópia das transições originais",
                                    "Não incluir self-loops em q_dump para todos X",
                                    "Usar símbolo Z0 sem empilhá-lo inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter APND por Pilha Vazia para Equivalente por Aceitação Final",
                                  "subSteps": [
                                    "Introduza novo símbolo bottom $ ∉ Γ; crie Q' = Q ∪ {q_start, q_accept}, com F' = {q_accept}, q_start inicial.",
                                    "Adicione transição inicial: δ(q_start, ε, ε) = (q0, $).",
                                    "Copie todas as transições δ do APND original para Q'.",
                                    "Para todo q ∈ Q, a ∈ Σ ∪ {ε}, adicione δ(q, a, $) = (q_accept, $) se não existir.",
                                    "Para q_accept e a ∈ Σ ∪ {ε}, adicione δ(q_accept, a, $) = (q_accept, $)."
                                  ],
                                  "verification": "Defina formalmente o novo APND e trace uma computação onde, ao tentar pop $, transita para q_accept e consome input restante.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Diagrama do APND por pilha vazia",
                                    "Lista de Γ ∪ {$}",
                                    "Ferramenta para tabela δ"
                                  ],
                                  "tips": "O $ atua como marcador; non-det permite escolher ir para q_accept quando pilha é só $.",
                                  "learningObjective": "Construir APND equivalente por estado final, lidando com input restante após esvaziar pilha.",
                                  "commonMistakes": [
                                    "Pop $ em vez de preservá-lo",
                                    "Não adicionar loops em q_accept para input restante",
                                    "Confundir q0 original com q_start"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Equivalência e Testar as Conversões",
                                  "subSteps": [
                                    "Prove informalmente que L(P') = L(P): mostre aceitação em um implica no outro.",
                                    "Simule 3 strings: aceita (deve aceitar em ambos modos), rejeitada por estado/pilha, e edge case (n=0).",
                                    "Compare diagramas: confirme estados/símbolos auxiliares preservam não-determinismo.",
                                    "Identifique linguagens reconhecíveis (ex: LFC context-free).",
                                    "Documente diferenças sutis nos modos."
                                  ],
                                  "verification": "Registre traces comparativos e afirme L(original) = L(convertido) para ambos sentidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambos APNDs convertidos",
                                    "Strings de teste",
                                    "Papel para traces"
                                  ],
                                  "tips": "Use não-determinismo: foque em 'existe branch que aceita'.",
                                  "learningObjective": "Validar que as conversões preservam a linguagem reconhecida.",
                                  "commonMistakes": [
                                    "Ignorar branches não-determinísticas",
                                    "Não testar casos onde pilha não esvazia naturalmente",
                                    "Assumir determinismo"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere APND P por aceitação final reconhecendo {a^n b^n | n≥0}: q0 --a/Z0--> q1/Z0 A; q1 --a/A--> q1/A A; q1 --ε/A--> q0; q0 --b/A--> q0/ε; q0 final. Conversão para pilha vazia: adiciona q_start --ε/ε--> q0/Z0; q_dump sink de q0. Vice-versa: adiciona $ bottom, q_accept de pops simulados em $.",
                              "finalVerifications": [
                                "Construção correta de estados/transições auxiliares em ambas direções.",
                                "Simulação bem-sucedida de string aceita/rejeitada em APNDs convertidos.",
                                "Definição formal completa sem erros de notação.",
                                "Prova informal de equivalência L(P) = L(P').",
                                "Identificação de quando usar cada modo em contextos reais.",
                                "Tratamento correto de ε-transições e não-determinismo."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da definição formal (δ, Q', etc.).",
                                "Correção lógica das transições auxiliares (sink, bottom $).",
                                "Qualidade das simulações e traces (passos detalhados).",
                                "Profundidade da verificação de equivalência.",
                                "Clareza nos diagramas e explicações.",
                                "Cobertura de edge cases (ε, n=0)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Construções e provas de equivalência em autômatos.",
                                "Teoria da Computação: Hierarquia de Chomsky e PDAs.",
                                "Programação: Implementação de PDAs em Python/Java para parsers.",
                                "Lógica: Não-determinismo e ramos condicionais.",
                                "Engenharia de Software: Análise sintática em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores e parsers (ex: ANTLR, Yacc), PDAs simulam análise sintática de linguagens de programação; conversões facilitam implementação unificada de reconhecimento, otimizando ferramentas de validação de código e processamento XML/JSON."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Autômatos de Pilha Determinísticos (APD)",
                        "description": "Versão determinística do autômato de pilha, com transições únicas, que reconhece um subconjunto próprio das linguagens livres de contexto, relevante para parsing determinístico.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Definir formalmente um APD",
                            "description": "Especificar δ: Q × (Σ ∪ {ε}) × Γ → Q × Γ ∪ {reject}, garantindo no máximo uma transição por configuração, sem não-determinismo, e discutir restrições como ausência de ε-movimentos em alguns modelos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os componentes fundamentais de um Autômato de Pilha (AP)",
                                  "subSteps": [
                                    "Identifique os elementos básicos de um AP não-determinístico: tupla (Q, Σ, Γ, δ, q0, Z0, F).",
                                    "Explique o papel de cada componente: Q (estados), Σ (alfabeto de entrada), Γ (alfabeto da pilha), q0 (estado inicial), Z0 (símbolo inicial da pilha), F (estados finais).",
                                    "Diferencie AP de AFD/AFN: uso de pilha para memória ilimitada.",
                                    "Anote exemplos simples de configurações (estado, entrada restante, pilha).",
                                    "Desenhe um diagrama esquemático de um AP básico."
                                  ],
                                  "verification": "Liste corretamente todos os 7 componentes da tupla de um AP com suas descrições em um papel ou documento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 2)",
                                    "Papel e caneta para diagramas",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use mnemônicos como 'Q-Sigma-Gamma-Delta-q0-Z0-F' para memorizar a tupla.",
                                  "learningObjective": "Compreender e listar com precisão os componentes constitutivos de um autômato de pilha.",
                                  "commonMistakes": [
                                    "Confundir Σ (entrada) com Γ (pilha)",
                                    "Esquecer Z0 como símbolo inicial único",
                                    "Ignorar que F pode ser vazio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar os componentes específicos para um APD",
                                  "subSteps": [
                                    "Defina Q, Σ, Γ, q0, Z0 e F para um APD, enfatizando que são finitos.",
                                    "Garanta que δ será determinística: domínio Q × (Σ ∪ {ε}) × Γ com codomínio Q × Γ ∪ {reject}.",
                                    "Escreva a tupla completa: (Q, Σ, Γ, δ, q0, Z0, F).",
                                    "Verifique que q0 ∈ Q, Z0 ∈ Γ, F ⊆ Q.",
                                    "Discuta que APD não aceita por estado vazio da pilha por padrão."
                                  ],
                                  "verification": "Escreva a tupla formal de um APD genérico com todos os componentes corretamente especificados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referência online: Wikipedia 'Pushdown automaton'",
                                    "Editor de texto para formalizar a tupla",
                                    "Exemplos de APD de aulas anteriores"
                                  ],
                                  "tips": "Sempre inclua ∪ {ε} no domínio de δ para entradas vazias.",
                                  "learningObjective": "Construir a estrutura formal base de um APD, diferenciando de AP não-determinístico.",
                                  "commonMistakes": [
                                    "Usar codomínio Q × Γ* em vez de Q × Γ ∪ {reject}",
                                    "Permitir múltiplos símbolos na pilha por transição",
                                    "Confundir APD com APND"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir formalmente a função de transição δ",
                                  "subSteps": [
                                    "Escreva δ: Q × (Σ ∪ {ε}) × Γ → Q × Γ ∪ {reject}.",
                                    "Explique cada entrada: estado atual, símbolo de entrada ou ε, topo da pilha.",
                                    "Saída: novo estado e novo símbolo na pilha (substitui topo), ou reject.",
                                    "Forneça sintaxe para δ(q, a, Z) = (p, Y) ou δ(q, a, Z) = reject.",
                                    "Teste com uma tabela de transição parcial."
                                  ],
                                  "verification": "Construa uma tabela de δ para um APD simples com pelo menos 3 entradas definidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela de transição",
                                    "Papel para esboços",
                                    "Livro de Hopcroft/Ullman 'Formal Languages'"
                                  ],
                                  "tips": "Use notação parcial: δ não precisa ser total, indefinido implica reject.",
                                  "learningObjective": "Especificar δ com precisão matemática, capturando a mecânica de leitura/escrita na pilha.",
                                  "commonMistakes": [
                                    "Permitir múltiplas saídas (não-determinismo)",
                                    "Usar Γ* em vez de Γ único",
                                    "Esquecer ε no domínio"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Garantir determinismo e ausência de não-determinismo",
                                  "subSteps": [
                                    "Verifique: para cada (q, a, Z), existe no máximo uma transição δ(q, a, Z).",
                                    "Discuta: sem branches, diferente de APND.",
                                    "Analise configurações: (q, w, α) → (p, v, β) unicamente determinada.",
                                    "Identifique violações: múltiplas definições para mesma entrada em δ.",
                                    "Compare com AFD: pilha adiciona poder, mas determinismo restringe."
                                  ],
                                  "verification": "Revise uma definição de δ e confirme 'no máximo uma transição por configuração' com prova por contraponto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de APND vs APD de tutoriais online (e.g., GeeksforGeeks)",
                                    "Ferramenta JFLAP para simular transições"
                                  ],
                                  "tips": "Pense em δ como uma função total parcial para evitar ambiguidades.",
                                  "learningObjective": "Validar o determinismo como propriedade central do APD.",
                                  "commonMistakes": [
                                    "Permitir δ(q,a,Z) = (p1,Y1) e (p2,Y2)",
                                    "Confundir com ε-múltiplos em APND"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Discutir restrições e variantes de modelos de APD",
                                  "subSteps": [
                                    "Explique restrição comum: sem ε-movimentos (δ sem ε em entrada) em alguns APD reais.",
                                    "Discuta aceitação: por estado final, pilha pode não estar vazia.",
                                    "Compare DPDA sem ε (mais simples) vs com ε (mais poderoso, mas ainda determinístico).",
                                    "Cite aplicações: parsers LR(0) usam APD sem ε.",
                                    "Resuma diferenças com APND e PDA prefix-free."
                                  ],
                                  "verification": "Escreva um parágrafo discutindo pelo menos duas restrições e suas implicações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo 'Deterministic Pushdown Automata' (PDF acadêmico)",
                                    "Notas de aula sobre compiladores"
                                  ],
                                  "tips": "Lembre: ε-transições mantêm determinismo se únicas por config.",
                                  "learningObjective": "Analisar restrições que tornam APD úteis em aplicações práticas.",
                                  "commonMistakes": [
                                    "Achar que todo APD proíbe ε",
                                    "Confundir rejeição por reject vs loop infinito"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina formalmente um APD que reconhece {a^n b^n | n ≥ 0}: Q = {q0, q1, qf}, Σ = {a,b}, Γ = {Z0, A}, δ(q0, ε, Z0) = (q1, Z0 A), δ(q1, a, A) = (q1, A A), δ(q1, b, A) = (q1, ε), δ(q1, ε, Z0) = (qf, Z0), F = {qf}. Verifique determinismo: única transição por (q,σ,γ).",
                              "finalVerifications": [
                                "Tupla completa (Q, Σ, Γ, δ, q0, Z0, F) está corretamente escrita.",
                                "δ tem assinatura exata: Q × (Σ ∪ {ε}) × Γ → Q × Γ ∪ {reject}.",
                                "Determinismo comprovado: ≤1 transição por configuração.",
                                "Restrições como ε-movimentos discutidas com exemplos.",
                                "Um exemplo simples é definido e simulado manualmente.",
                                "Diferenças com APND explicitadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática da definição de δ (20%)",
                                "Correta garantia de determinismo sem ambiguidades (25%)",
                                "Cobertura completa de todos componentes da tupla (20%)",
                                "Discussão relevante de restrições e variantes (15%)",
                                "Clareza na notação e exemplos práticos (10%)",
                                "Ausência de erros comuns como não-determinismo inadvertido (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Funções parciais e relações em grafos de configuração.",
                                "Lógica: Verificação de propriedades determinísticas via indução.",
                                "Programação: Implementação de parsers em linguagens como Python (simulador de pilha).",
                                "Compiladores: Uso em análise sintática determinística (LR parsers).",
                                "Teoria da Computação: Hierarquia de Chomsky e poder expressivo."
                              ],
                              "realWorldApplication": "APDs são fundamentais em compiladores para parsing determinístico de linguagens de programação (e.g., Yacc/Bison usam modelos semelhantes para gramáticas LR), validação de XML/JSON balanceados em processadores de documentos, e simuladores de memória em sistemas embarcados com pilhas limitadas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Comparar APND e APD em poder de reconhecimento",
                            "description": "Explicar que todo APD é APND, mas não o inverso (ex: palíndromos pares requerem não-determinismo), e citar propriedades como linguagens DCFL reconhecidas por APD em tempo real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de APND e APD",
                                  "subSteps": [
                                    "Defina Autômato de Pilha Não-Determinístico (APND): máquina com pilha e múltiplas transições possíveis.",
                                    "Defina Autômato de Pilha Determinístico (APD): versão sem não-determinismo, exatamente uma transição por estado e entrada.",
                                    "Compare transições: APND permite ε-transições e branches; APD é único caminho.",
                                    "Liste componentes formais: (Q, Σ, Γ, δ, q0, Z0, F) para ambos, destacando δ não-determinística vs. determinística.",
                                    "Estude exemplos simples: APD para parênteses balanceados vs. APND para cenários mais complexos."
                                  ],
                                  "verification": "Escreva definições formais e identifique pelo menos 3 diferenças chave em um diagrama.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Folha de papel para diagramas",
                                    "Simulador de autômatos online (JFLAP)"
                                  ],
                                  "tips": "Use tabelas para comparar componentes; visualize com diagramas de estados.",
                                  "learningObjective": "Compreender as diferenças fundamentais entre APND e APD.",
                                  "commonMistakes": [
                                    "Confundir pilha com fita",
                                    "Ignorar ε-transições no APND",
                                    "Achar que APD permite não-determinismo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar que todo APD é um APND (inclusão)",
                                  "subSteps": [
                                    "Construa um APND idêntico ao APD: δ_APND = δ_APD, sem branches extras.",
                                    "Simule execução: APD segue único caminho, que APND pode replicar deterministicamente.",
                                    "Prove formalmente: Se w ∈ L(APD), então existe path aceitando em APND.",
                                    "Verifique simetria: Linguagens reconhecidas por APD são subset de APND.",
                                    "Teste com exemplo: APD para {a^n b^n} simulado em APND."
                                  ],
                                  "verification": "Construa prova por construção e teste com string de exemplo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "JFLAP para simulação",
                                    "Papel para prova formal",
                                    "Notas de aula sobre linguagens regulares"
                                  ],
                                  "tips": "Pense em APND como 'APD + opção de não-determinismo'; prove por simulação direta.",
                                  "learningObjective": "Demonstrar matematicamente que L(APD) ⊆ L(APND).",
                                  "commonMistakes": [
                                    "Reverter a inclusão",
                                    "Esquecer estados de rejeição",
                                    "Não testar com strings inválidas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar que APND é estritamente mais poderoso (exemplo de palíndromos pares)",
                                  "subSteps": [
                                    "Defina linguagem de palíndromos pares: {ww^R | w ∈ {a,b}* }.",
                                    "Construa APND: adivinha meio com não-determinismo, empilha primeira metade, verifica segunda.",
                                    "Prove que não é DCFL: use pumping lemma para DCFL ou Ogden's lemma.",
                                    "Tente construir APD e mostre falha: sem adivinhação do centro.",
                                    "Simule em JFLAP: APND aceita, APD falha em casos pares longos."
                                  ],
                                  "verification": "Implemente APND em simulador e prove impossibilidade para APD.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "JFLAP ou simulador similar",
                                    "Referência sobre palíndromos pares",
                                    "Pencil para lemma de pumping"
                                  ],
                                  "tips": "Não-determinismo 'adivinha' o pivô; foque em matching simétrico.",
                                  "learningObjective": "Identificar linguagens que requerem não-determinismo.",
                                  "commonMistakes": [
                                    "Confundir com palíndromos ímpares (DCFL)",
                                    "Erro no lemma de pumping",
                                    "APD com estado extra desnecessário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar propriedades como DCFLs reconhecidas por APD em tempo real",
                                  "subSteps": [
                                    "Defina DCFL: Deterministic Context-Free Languages, reconhecidas por APD.",
                                    "Discuta tempo real: APD lê entrada sem atrasos, pilha auxilia matching.",
                                    "Compare poderes: DCFLs propriamente ⊆ CFLs, APND reconhece todos CFLs.",
                                    "Exemplos: {a^n b^n} DCFL (APD), {a^n b^n c^n} CFL não-DCFL (APND requer ND?).",
                                    "Resuma tabela: Poder APD < APND, com exemplos e teoremas."
                                  ],
                                  "verification": "Crie tabela comparativa e cite 2 teoremas chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela comparativa em Excel/Google Sheets",
                                    "Livro Hopcroft/Ullman",
                                    "Notas de DCFL"
                                  ],
                                  "tips": "Lembre: DCFL fechado sob complementares; use para parsing LL(1).",
                                  "learningObjective": "Relacionar classes de linguagens com autômatos correspondentes.",
                                  "commonMistakes": [
                                    "Achar todos CFLs determinísticos",
                                    "Confundir tempo real com polinomial",
                                    "Ignorar closure properties"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar comparação completa e exceções",
                                  "subSteps": [
                                    "Compile hierarquia: Regulares ⊂ DCFL ⊂ CFL = L(APND) ⊂ CSL.",
                                    "Discuta conversões: APND para APND sem ε via powerset (explosão).",
                                    "Analise aplicações: APD para parsing determinístico em compiladores.",
                                    "Liste teoremas: Stearns (APD em tempo real = DCFL), etc.",
                                    "Crie mapa mental da comparação."
                                  ],
                                  "verification": "Desenhe hierarquia e explique 3 teoremas em voz alta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de mindmap (Draw.io)",
                                    "Resumo de teoremas"
                                  ],
                                  "tips": "Use set inclusion diagram; memorize contraexemplos chave.",
                                  "learningObjective": "Integrar conhecimentos em visão unificada de poder de reconhecimento.",
                                  "commonMistakes": [
                                    "Inverter hierarquia",
                                    "Esquecer CFL = L(APND)",
                                    "Generalizar demais"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um APD para {a^n b^n | n≥0} e um APND para palíndromos pares {ww^R}. Simule entrada 'aabb' no APD (aceita) e 'abba' no APND (aceita via adivinhação do centro), mostrando falha do APD no segundo.",
                              "finalVerifications": [
                                "Explicar por que todo APD é APND com prova por construção.",
                                "Construir APND para palíndromos pares e provar não-DCFL.",
                                "Listar 3 linguagens DCFL reconhecíveis por APD em tempo real.",
                                "Desenhar hierarquia de poder: APD ⊂ APND.",
                                "Identificar erro em um APD proposto para linguagem não-determinística.",
                                "Citar teorema relacionando DCFL e APD."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção formal entre APND e APD (90% correto).",
                                "Correta construção e simulação de exemplos (funciona em simulador).",
                                "Prova válida de inclusão APD ⊆ APND.",
                                "Aplicação correta do pumping lemma para contraexemplo.",
                                "Tabela comparativa completa com propriedades e exemplos.",
                                "Explicação clara de aplicações em tempo real."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e inclusão estrita (pumping lemmas).",
                                "Programação: Parsing determinístico em compiladores (Yacc/ANTLR).",
                                "Lógica: Não-determinismo similar a backtracking em algoritmos.",
                                "Engenharia de Software: Modelagem de linguagens em design de DSLs."
                              ],
                              "realWorldApplication": "Em compiladores, APDs são usados para parsing determinístico de gramáticas LL/LR (ex: JavaCC), enquanto APND modela parsers mais flexíveis para linguagens ambíguas como scripts dinâmicos, otimizando reconhecimento em tempo real para eficiência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Construir um APD para uma linguagem determinística",
                            "description": "Projetar um APD para {a^n b^m | n ≤ m ≤ 2n}, gerenciando a pilha para contar e verificar relações prefixadas, simulando execução determinística passo a passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a linguagem e planejar a estratégia de uso da pilha",
                                  "subSteps": [
                                    "Escreva formalmente a linguagem L = {a^n b^m | n ≤ m ≤ 2n}.",
                                    "Identifique as condições: pelo menos n b's (m ≥ n) e no máximo 2n b's (m ≤ 2n), ou seja, 0 ≤ m - n ≤ n.",
                                    "Planeje empilhar símbolo 'A' para cada 'a' para contar n.",
                                    "Planeje fase de matching: para cada um dos primeiros n 'b's, desempilhar 'A' e empilhar 'B' (crédito para até n extras).",
                                    "Planeje fase de extras: desempilhar 'B' para cada 'b' extra até Z0 exposto.",
                                    "Planeje transições determinísticas únicas sem ambiguidades."
                                  ],
                                  "verification": "Crie um documento com análise escrita, diagrama esquemático e estratégia de pilha anotada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para notas"
                                  ],
                                  "tips": "Use desigualdades matemáticas para visualizar n ≤ m ≤ 2n; desenhe pilha evoluindo para n=2.",
                                  "learningObjective": "Entender como a pilha modela relações quantitativas entre símbolos prefixados.",
                                  "commonMistakes": [
                                    "Ignorar o limite superior, permitindo m > 2n.",
                                    "Confundir empilhamento com desempilhamento.",
                                    "Planejar transições não determinísticas (múltiplas opções)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir componentes do APD (estados, alfabetos, pilha)",
                                  "subSteps": [
                                    "Defina estados: q0 (inicial/ a's), q1 (b's matching e extras), qf (aceitação final).",
                                    "Alfabeto de entrada: {a, b, ε (fim de entrada)}.",
                                    "Alfabeto de pilha: {Z0, A, B}.",
                                    "Símbolo inicial da pilha: Z0.",
                                    "Estado inicial: q0; estados finais: {qf}.",
                                    "Liste todas as configurações iniciais: (q0, w, Z0)."
                                  ],
                                  "verification": "Escreva uma tabela ou lista com todos os componentes definidos sem omissões.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Ferramenta digital como Draw.io"
                                  ],
                                  "tips": "Mantenha poucos estados para simplicidade determinística; priorize clareza nos nomes.",
                                  "learningObjective": "Especificar precisamente os elementos de um APD para evitar ambiguidades.",
                                  "commonMistakes": [
                                    "Incluir ε-transições de entrada para 'b'.",
                                    "Esquecer Z0 como marcador de fundo.",
                                    "Definir muitos estados desnecessários."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar as transições determinísticas",
                                  "subSteps": [
                                    "Fase a's: δ(q0, a, Z0) = (q0, A Z0); δ(q0, a, A) = (q0, A A).",
                                    "Início b's: δ(q0, b, A) = (q1, B)  // pop A, push B para crédito.",
                                    "Matching b's: δ(q1, b, A) = (q1, B)  // pop A, push B.",
                                    "Extras b's: δ(q1, b, B) = (q1, ε)  // pop B.",
                                    "Switch para aceitação: δ(q1, ε, Z0) = (qf, Z0); rejeitar se top A ou B no fim ou b/Z0.",
                                    "Adicione rejeição: δ(q1, b, Z0) = rejeitar."
                                  ],
                                  "verification": "Desenhe o diagrama completo de transições e verifique unicidade para cada (q, σ, Γ).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de diagramas (ex: Lucidchart)",
                                    "Papel"
                                  ],
                                  "tips": "Teste mentalmente para n=1: veja se pilha gerencia m=1,2 corretamente.",
                                  "learningObjective": "Criar transições que gerenciem pilha para verificar n ≤ m ≤ 2n deterministicamente.",
                                  "commonMistakes": [
                                    "Transições sobrepostas (não determinísticas).",
                                    "Não tratar top B durante matching.",
                                    "Esquecer transição para fim de entrada."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular execução determinística passo a passo",
                                  "subSteps": [
                                    "Escolha palavra teste na linguagem, ex: aabbb (n=2, m=3).",
                                    "Inicie configuração: (q0, aabbb, Z0).",
                                    "Aplique transições sequencialmente, registrando cada (estado, fita restante, pilha).",
                                    "Simule também palavras fora: aab (m=2=n ok), aabbbb (m=4>4 rejeitar), ab (m=1<1 rejeitar).",
                                    "Registre se aceita em qf com Z0 ou rejeita corretamente.",
                                    "Ajuste transições se simulação falhar."
                                  ],
                                  "verification": "Tabela de simulação completa para 3 palavras, mostrando aceitação/rejeição correta.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabelas",
                                    "Simulador de PDA online opcional"
                                  ],
                                  "tips": "Anote pilha de baixo para cima; avance um símbolo por vez.",
                                  "learningObjective": "Simular APD para validar design e entender execução LIFO.",
                                  "commonMistakes": [
                                    "Erros na ordem LIFO da pilha.",
                                    "Pular transições em tops mistos A/B.",
                                    "Não simular casos limite (m=n, m=2n)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e documentar o APD completo",
                                  "subSteps": [
                                    "Confirme determinismo: uma única transição por (estado, input, top).",
                                    "Teste mais palavras: aa bb (aceitar), aaa bbbbbb (aceitar m=6=2*3).",
                                    "Documente diagrama final, tabela de transições e simulações.",
                                    "Identifique conexões: como pilha verifica prefixos relacionados.",
                                    "Otimize se possível (remover estados mortos)."
                                  ],
                                  "verification": "Relatório final com diagrama, transições e 5 simulações validadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documento final",
                                    "Ferramenta de export PDF"
                                  ],
                                  "tips": "Use cores para fases (azul a's, verde matching, vermelho extras).",
                                  "learningObjective": "Validar e documentar um APD funcional para linguagem sensível ao contexto determinística.",
                                  "commonMistakes": [
                                    "Aceitar palavras inválidas como a^{n} b^{2n+1}.",
                                    "Não documentar rejeições explicitamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Construa o APD conforme steps e simule para 'aabbb' (n=2, m=3 ∈ L): 1. (q0, aabbb, Z0) →a (q0, abbb, A Z0) →a (q0, bbb, A A Z0) →b (q1, bb, B A Z0) [pop A push B] →b (q1, b, A Z0) [pop B] →b (q1, ε, B Z0) [pop A push B] →ε (qf, ε, Z0) [pop B] → aceita. Verifique rejeição para 'aabbbb': tenta b/Z0 → rejeita.",
                              "finalVerifications": [
                                "APD aceita todas w ∈ L e rejeita w ∉ L para n,m ≤ 5.",
                                "Pilha sempre reflete contagens corretas (≤ n B's após matching).",
                                "Execução determinística: único caminho por input.",
                                "Transições cobrem todos casos sem lacunas ou conflitos.",
                                "Simulação manual para n=3, m=4,5,6 correta.",
                                "Diagrama visualiza fluxo claro de estados/pilha."
                              ],
                              "assessmentCriteria": [
                                "Precisão das transições e determinismo (25%)",
                                "Correção das simulações e gerenciamento de pilha (30%)",
                                "Cobertura de casos limite (n=0,1; m=n,2n) (20%)",
                                "Clareza do diagrama e documentação (15%)",
                                "Análise de erros comuns evitados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: desigualdades lineares e indução em contagens.",
                                "Lógica: verificação formal de propriedades por máquina abstrata.",
                                "Programação: implementação de simulador PDA em Python/Java.",
                                "Engenharia de Software: validação de protocolos com bounds em sequências."
                              ],
                              "realWorldApplication": "Em compiladores e parsers, para validar sequências de tokens com relações quantitativas limitadas, como headers com payloads entre tamanho mínimo e dobro (ex: protocolos de rede com buffers redundantes); simulação em verificadores de hardware para contagens de sinais sincronizados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Propriedades das Linguagens Livres de Contexto",
                    "description": "Teorema do bombeamento e hierarquia de Chomsky para tipo-2.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Teorema do Bombeamento para Linguagens Livres de Contexto",
                        "description": "O teorema do bombeamento para linguagens livres de contexto (CFLs) estabelece que, para qualquer CFL L, existe um comprimento p tal que qualquer palavra w em L com |w| >= p pode ser decomposta em w = uvxyz, onde |vxy| <= p, |vy| >= 1, e para todo i >= 0, uv^i x y^i z está em L. Isso é usado para provar que certas linguagens não são livres de contexto.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Enunciar o Teorema do Bombeamento para CFLs",
                            "description": "Capacidade de declarar precisamente o teorema, incluindo as condições de decomposição uvxyz, os limites de comprimento e a propriedade de bombeamento para i >= 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Pré-requisitos de Linguagens Livres de Contexto (CFLs)",
                                  "subSteps": [
                                    "Defina o que é uma Linguagem Livre de Contexto (CFL) e dê um exemplo simples como {a^n b^n | n ≥ 0}.",
                                    "Explique a forma normal de Chomsky (CNF) e por que ela é relevante para o teorema.",
                                    "Recapitule o conceito de comprimento de bombeamento (pumping length) em linguagens formais.",
                                    "Identifique diferenças entre linguagens regulares e CFLs em termos de teoremas de bombeamento."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras confirmando compreensão dos pré-requisitos, sem erros conceituais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre Automata e Linguagens Formais",
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (capítulo sobre CFLs)"
                                  ],
                                  "tips": "Use diagramas de pilha para visualizar CFLs não-regulares.",
                                  "learningObjective": "Estabelecer base conceitual sólida para entender o teorema do bombeamento.",
                                  "commonMistakes": [
                                    "Confundir CFLs com linguagens regulares",
                                    "Ignorar a importância da forma CNF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a Declaração Formal do Teorema",
                                  "subSteps": [
                                    "Leia a declaração completa: Para toda CFL L, existe p tal que todo w ∈ L com |w| ≥ p pode ser dividido em uvxyz onde |vy| > 0, |vxy| ≤ p, e para todo i ≥ 0, uv^i x y^i z ∈ L.",
                                    "Anote as três condições principais: decomposição em 5 partes, limites de comprimento, propriedade de bombeamento.",
                                    "Compare com o teorema de bombeamento para linguagens regulares (3 partes vs 5).",
                                    "Identifique o papel do inteiro p (comprimento de bombeamento)."
                                  ],
                                  "verification": "Recite a declaração palavra por palavra de memória e verifique contra fonte original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo ou slides sobre Teorema do Bombeamento para CFLs",
                                    "Vídeo tutorial no YouTube sobre Pumping Lemma for CFLs"
                                  ],
                                  "tips": "Destaque as palavras-chave como 'uvxyz', '|vy|>0', '|vxy|≤p' e 'i≥0'.",
                                  "learningObjective": "Memorizar a estrutura exata da declaração do teorema.",
                                  "commonMistakes": [
                                    "Esquecer |vy|>0, permitindo bombeamento trivial",
                                    "Confundir ordem da decomposição (é uvxyz, não uvwxy)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Componentes e Condições do Teorema",
                                  "subSteps": [
                                    "Explique cada parte da decomposição: u (prefixo fixo), v e y (partes bombeáveis), x (parte central opcional), z (sufixo fixo).",
                                    "Discuta por que |vy| > 0 garante mudança no bombeamento e |vxy| ≤ p limita a posição.",
                                    "Simule bombeamento para i=0, i=1, i=2 em um exemplo simples.",
                                    "Entenda implicações: usado para provar linguagens NÃO-CFLs por contradição."
                                  ],
                                  "verification": "Crie um diagrama anotado da decomposição uvxyz e liste condições com justificativas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Exemplos de provas de não-CFLs online"
                                  ],
                                  "tips": "Pense em 'v' e 'y' como as partes que 'crescem' simetricamente.",
                                  "learningObjective": "Compreender o mecanismo e propósito matemático do teorema.",
                                  "commonMistakes": [
                                    "Achar que x deve ser não-vazio",
                                    "Ignorar que i pode ser 0, removendo vy"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Enunciação e Aplicação Inicial",
                                  "subSteps": [
                                    "Enuncie o teorema completo 5 vezes em voz alta, cronometrando para fluência.",
                                    "Aplique a uma CFL simples: divida uma string longa e verifique bombeamento.",
                                    "Teste com uma linguagem não-CFL como {a^n b^n c^n} para ver falha.",
                                    "Autoavalie precisão corrigindo erros identificados."
                                  ],
                                  "verification": "Grave áudio da enunciação e compare com versão canônica; acerte 100% em 3 tentativas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gravador de voz ou app de notas",
                                    "Exemplos de CFLs e não-CFLs"
                                  ],
                                  "tips": "Enuncie devagar primeiro, depois acelere para naturalidade.",
                                  "learningObjective": "Dominar a enunciação precisa e intuitiva do teorema.",
                                  "commonMistakes": [
                                    "Trocar limites de comprimento (|vxy|≤p vs |vy|>0)",
                                    "Omitir 'para todo i≥0'"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Reforçar com Verificação e Exemplos Avançados",
                                  "subSteps": [
                                    "Resolva um exercício: enuncie e prove para {ww^R | w ∈ {a,b}*}.",
                                    "Identifique erros comuns em declarações erradas fornecidas em quizzes online.",
                                    "Crie flashcards com partes do teorema para revisão rápida.",
                                    "Discuta com um colega ou fórum para feedback."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas de quiz sobre o teorema sem consulta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quiz online sobre Pumping Lemma CFL",
                                    "Flashcard app como Anki"
                                  ],
                                  "tips": "Use mnemônicos: 'UVXYZ bombeia com VY não-vazio'.",
                                  "learningObjective": "Consolidar memória de longo prazo e aplicação.",
                                  "commonMistakes": [
                                    "Confundir com versão para linguagens regulares",
                                    "Esquecer contexto de CFLs em CNF"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a CFL L = {a^n b^n | n ≥ 0} em CNF. Para w = a^{10} b^{10} com |w| ≥ p, divida em u=a^3, v=a^2, x= a^5, y=b^2, z= b^8 onde |vy|=a^2 b^2 >0, |vxy|=a^7 b^2 ≤p. Então uv^i x y^i z = a^{3+2i +5} b^{2i +8} = a^{8+2i} b^{8+2i} ∈ L para qualquer i≥0.",
                              "finalVerifications": [
                                "Enuncie o teorema completo sem erros em menos de 30 segundos.",
                                "Identifique corretamente todas as 5 partes da decomposição uvxyz.",
                                "Explique os dois limites de comprimento e sua importância.",
                                "Demonstre bombeamento para i=0 e i=2 em um exemplo dado.",
                                "Prove por contradição que uma linguagem dada não é CFL usando o teorema.",
                                "Liste 3 diferenças entre pumping lemma para regulares e CFLs."
                              ],
                              "assessmentCriteria": [
                                "Precisão verbatim da declaração (100% match com fonte padrão).",
                                "Correta identificação e explicação de uvxyz e condições.",
                                "Fluência na enunciação sem hesitação ou pausas.",
                                "Capacidade de aplicar em exemplos concretos sem erros.",
                                "Compreensão de implicações para provas de não-CFLs.",
                                "Uso correto de notação matemática (e.g., |vy|>0, i≥0)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Autômatos (pilhas como grafos).",
                                "Engenharia de Software: Análise sintática em compiladores e parsers.",
                                "Lógica: Provas por contradição e indução em teoremas formais.",
                                "Algoritmos: Verificação de propriedades em linguagens de programação.",
                                "Filosofia da Ciência: Fundamentos da indecidibilidade computacional."
                              ],
                              "realWorldApplication": "O Teorema do Bombeamento é crucial em compiladores para provar limites de linguagens de programação (e.g., aninhamento balanceado é CFL, mas {a^n b^n c^n} não é), auxiliando no design de parsers eficientes e na detecção de linguagens in解析áveis, impactando desenvolvimento de software como Python ou Java."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Aplicar o Teorema para Provar que uma Linguagem Não é CFL",
                            "description": "Usar o teorema do bombeamento para assumir que uma linguagem dada (ex: {a^n b^n c^n | n >= 1}) é CFL e derivar uma contradição ao bombear uma palavra longa, mostrando que pelo menos uma das palavras bombeadas sai da linguagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar e enunciar o Teorema do Bombeamento para CFLs",
                                  "subSteps": [
                                    "Leia o enunciado exato do teorema: Para toda CFL L, existe p (comprimento de bombeamento) tal que para toda w ∈ L com |w| ≥ p, w = uvxyz onde |vxy| ≤ p, |vy| ≥ 1, e para todo k ≥ 0, uv^k x y^k z ∈ L.",
                                    "Explique as condições chave: |vxy| ≤ p limita a posição do bombeamento, |vy| ≥ 1 garante mudança.",
                                    "Assuma por contradição que L é CFL, logo o teorema se aplica.",
                                    "Anote o teorema em suas próprias palavras para fixar.",
                                    "Verifique se entende por que isso captura a 'repetição' em PDAs."
                                  ],
                                  "verification": "Escreva o teorema corretamente sem consultar fontes e identifique todas as condições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre Teorema do Bombeamento",
                                    "Livro texto de Teoria da Computação (ex: Sipser)",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use abreviações como 'pumping length' para agilizar anotações.",
                                  "learningObjective": "Dominar o enunciado preciso e suas implicações para provas de não-CFL.",
                                  "commonMistakes": [
                                    "Confundir com teorema de bombeamento para linguagens regulares (que usa uvw, não uvxyz)",
                                    "Esquecer |vy| ≥ 1 ou |vxy| ≤ p"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar uma palavra w longa o suficiente na linguagem L",
                                  "subSteps": [
                                    "Escolha L = {a^n b^n c^n | n ≥ 1}.",
                                    "Defina p como o comprimento de bombeamento (dado pelo teorema).",
                                    "Escolha n ≥ p, defina w = a^n b^n c^n, garantindo |w| = 3n ≥ p.",
                                    "Justifique por que w ∈ L: tem exatamente n a's, n b's e n c's.",
                                    "Calcule |w| explicitamente e confirme |w| ≥ p."
                                  ],
                                  "verification": "Confirme que w satisfaz a definição de L e |w| ≥ p.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Definição formal de L",
                                    "Papel para calcular |w|"
                                  ],
                                  "tips": "Escolha n = p para simplicidade inicial, mas prove para n arbitrariamente grande.",
                                  "learningObjective": "Identificar palavras representativas que exponham a estrutura sensível de L.",
                                  "commonMistakes": [
                                    "Escolher w muito curta (|w| < p)",
                                    "Não justificar w ∈ L explicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decompor w em uvxyz conforme o teorema",
                                  "subSteps": [
                                    "Pelo teorema, w = uvxyz com |vxy| ≤ p e |vy| ≥ 1.",
                                    "Analise possíveis posições de vxy: regiões de a's (1 a p), a's e b's (p+1 a 2p), b's e c's, etc.",
                                    "Como |vxy| ≤ p < 3n (para n grande), vxy não pode cobrir todas três regiões simultaneamente.",
                                    "Identifique vy: deve inserir cópias extras de símbolos em uma ou duas regiões adjacentes.",
                                    "Esboce a decomposição genérica: u (prefixo), v (início bombeável), x (meio), y (fim bombeável), z (sufixo)."
                                  ],
                                  "verification": "Desenhe w dividida em uvxyz, marcando posições e comprimentos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "w anotada linearmente",
                                    "Marcadores coloridos para regiões (a,b,c)"
                                  ],
                                  "tips": "Visualize w como três blocos iguais: AAA BBB CCC, com vxy em ≤ p símbolos.",
                                  "learningObjective": "Compreender as restrições posicionais impostas por |vxy| ≤ p.",
                                  "commonMistakes": [
                                    "Assumir vxy pode pular regiões (ex: só a's e c's)",
                                    "Ignorar que vy pode estar só em uma região"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar bombeamento e derivar contradição",
                                  "subSteps": [
                                    "Considere bombeamento para k=2: w' = uv^2 x y^2 z.",
                                    "Analise casos baseados na posição de vy:",
                                    "Caso 1: vy só em a's → mais a's que b's/c's.",
                                    "Caso 2: vy só em b's → mais b's.",
                                    "Caso 3: vy só em c's → mais c's.",
                                    "Caso 4: vy em a's e b's → mais a's e/ou b's, mas c's iguais → desbalanceio.",
                                    "Caso 5: vy em b's e c's → similar.",
                                    "Mostre que em todos os casos, contagens de a,b,c em w' diferem, então w' ∉ L.",
                                    "Para k=0: uv^0 x y^0 z = uxz tem menos símbolos em vy, novamente desbalanceado."
                                  ],
                                  "verification": "Para cada caso possível de vy, escreva w' e conte #a, #b, #c; confirme ≠.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Diagrama de w",
                                    "Tabela de casos para vy"
                                  ],
                                  "tips": "Use casos exaustivos baseados nas três regiões para cobrir todas possibilidades.",
                                  "learningObjective": "Executar análise de bombeamento para expor falha estrutural de L.",
                                  "commonMistakes": [
                                    "Não cobrir todos os casos de posição de vy",
                                    "Errar contagens ao bombear (ex: vy com 2a's e 1b → +2a+1b)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir a prova por contradição",
                                  "subSteps": [
                                    "Reafirme a assunção: L é CFL → teorema aplica → existe decomposição.",
                                    "Mostre que bombeamento produz w' ∉ L, contradizendo o teorema.",
                                    "Conclua: L não é CFL.",
                                    "Discuta generalidade: funciona para qualquer n ≥ p.",
                                    "Opcional: Mencione que L é CSL (Context-Sensitive Language)."
                                  ],
                                  "verification": "Escreva parágrafo conclusivo lógico e sem lacunas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Rascunho completo da prova"
                                  ],
                                  "tips": "Estruture como: Assunção → Aplicação → Contradição → Conclusão.",
                                  "learningObjective": "Sintetizar a prova em argumento coerente e convincente.",
                                  "commonMistakes": [
                                    "Pular justificativa da contradição",
                                    "Concluir sem rebater assunção"
                                  ]
                                }
                              ],
                              "practicalExample": "Para L = {a^n b^n c^n | n ≥ 1}, deixe p ser o pumping length. Tome n = p, w = a^p b^p c^p (|w| = 3p ≥ p). Decomponha w = uvxyz com |vxy| ≤ p, |vy| ≥ 1. Para k=2, w' = uv^2xy^2z. vy ⊆ primeiros 2p símbolos (a's e b's iniciais, pois |vxy|≤p <3p). Casos: (1) vy em a's → #a = p + |vy| > p = #b=#c; (2) vy em b's → #b >p; (3) vy em a's e b's → ou #a>p ou #b>p ou ambos, mas #c=p. w' ∉ L. Contradição.",
                              "finalVerifications": [
                                "Teorema do bombeamento enunciado corretamente com todas condições.",
                                "w escolhida com |w| ≥ p e explicitamente em L.",
                                "Todos casos possíveis de posição de vy analisados exaustivamente.",
                                "Para cada bombeamento (k=0 e/ou k=2), contagens de símbolos provam w' ∉ L.",
                                "Conclusão por contradição clara e lógica.",
                                "Prova geral para qualquer n ≥ p."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado do teorema (100% das condições corretas).",
                                "Escolha e justificativa adequadas de w.",
                                "Análise exaustiva e correta dos casos de decomposição.",
                                "Cálculos de bombeamento sem erros aritméticos.",
                                "Lógica da contradição irrefutável.",
                                "Clareza e organização da prova (uso de casos, diagramas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por contradição e análise de casos exaustivos.",
                                "Lógica: Raciocínio dedutivo e propriedades de conjuntos infinitos.",
                                "Programação: Simulação de PDAs em Python para testar bombeamento.",
                                "Filosofia da Ciência: Limites da computação formal."
                              ],
                              "realWorldApplication": "Em design de compiladores, prova que linguagens com dependências triplas (como certas expressões aninhadas) não são parsáveis por parsers livres-de-contexto (LL/LR), exigindo técnicas mais avançadas como Earley ou GLR parsers em ferramentas como ANTLR ou compiladores de linguagens funcionais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Analisar Decomposições Possíveis em uma Palavra Bombeável",
                            "description": "Dado uma palavra w longa em uma suposta CFL, considerar todas as possíveis decomposições uvxyz válidas pelo teorema e demonstrar que nenhuma preserva a linguagem sob bombeamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Teorema do Bombeamento e Preparar a Palavra w",
                                  "subSteps": [
                                    "Relembre a declaração precisa do teorema: Para L CFL, existe p tal que para qualquer w em L com |w| >= p, existe decomposição w=uvxyz com |vxy| <= p, |vy| >=1, e para todo i >=0, uv^i x y^i z em L.",
                                    "Selecione ou confirme a palavra w longa da linguagem suposta CFL, garantindo |w| >= p (use p conhecido ou assuma p <= |w|/2).",
                                    "Defina a linguagem L claramente e verifique que w ∈ L.",
                                    "Anote as propriedades chave de L que serão violadas pelo bombeamento (ex: equilíbrio de símbolos)."
                                  ],
                                  "verification": "Confirme por escrito: teorema citado corretamente, w e L definidos, |w| >= p.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas do teorema do bombeamento",
                                    "Exemplo de linguagem não-CFL (ex: {a^n b^n c^n})",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Sempre cite o teorema verbatim para evitar ambiguidades.",
                                  "learningObjective": "Entender os pré-requisitos exatos do teorema e preparar o setup para análise.",
                                  "commonMistakes": [
                                    "Confundir com teorema de bombeamento para linguagens regulares (apenas uv).",
                                    "Escolher w muito curta (|w| < p)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o Comprimento de Bombeamento p e Posições Possíveis",
                                  "subSteps": [
                                    "Assuma ou derive um valor para p (geralmente p é o tamanho do ACG mínimo ou dado no problema).",
                                    "Identifique todas as substrings de comprimento <= p em w, pois vxy deve estar nessa posição.",
                                    "Marque as posições em w onde |vy| >=1 é possível dentro de |vxy| <= p.",
                                    "Liste as regiões de w: prefixo u, região bombeável vxy, sufixo z."
                                  ],
                                  "verification": "Lista de posições candidatas para vxy anotada, com |vxy| <= p e pelo menos uma posição para vy não-vazia.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "w anotada com índices de caracteres (1 a |w|)",
                                    "Tabela de possíveis |vxy|"
                                  ],
                                  "tips": "Comece assumindo p = número dado; se não, use p conservador como 5-10 para exemplos.",
                                  "learningObjective": "Localizar precisamente a janela de bombeamento na palavra w.",
                                  "commonMistakes": [
                                    "Ignorar |vxy| <= p, permitindo janelas grandes.",
                                    "Esquecer |vy| >=1, permitindo v ou y vazios isolados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Enumerar Todas as Decomposições Válidas uvxyz",
                                  "subSteps": [
                                    "Para cada posição inicial i onde |w[i..i+k-1]| <= p (k=|vxy|), divida em v,x,y com |vy|>=1.",
                                    "Gere sistematicamente: fixe início/fim de vxy, então partitions v-x-y não-vazios onde vy não-vazia.",
                                    "Anote cada decomposição única: escreva u, v, x, y, z explicitamente.",
                                    "Elimine duplicatas ou inválidas (ex: |vy|=0)."
                                  ],
                                  "verification": "Lista exaustiva de 3-10 decomposições válidas, cada uma com strings u,v,x,y,z.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou lista numerada de decomposições",
                                    "Ferramenta como Python para gerar se |w| grande"
                                  ],
                                  "tips": "Use diagramas lineares de w com setas para u|v|x|y|z.",
                                  "learningObjective": "Gerar todas as decomposições conformes ao teorema.",
                                  "commonMistakes": [
                                    "Perder decomposições onde v ou y cruza símbolos críticos.",
                                    "Contar decomposições inválidas com |vy|=0."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Bombeamento para Cada Decomposição",
                                  "subSteps": [
                                    "Para cada uvxyz, compute w_0 = uxz (i=0), w_2 = uv^2 x y^2 z (i=2).",
                                    "Verifique se w_i ∉ L, usando propriedades de L (ex: contagem de a's ≠ b's).",
                                    "Se w_0 ou w_2 em L, teste i=3 ou outros; caso contrário, anote falha.",
                                    "Registre por que falha: desequilíbrio, ordem errada, etc."
                                  ],
                                  "verification": "Para toda decomposição, pelo menos um i onde w_i ∉ L comprovado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Contadores de símbolos para L",
                                    "Exemplos prévios de provas semelhantes"
                                  ],
                                  "tips": "Teste i=0 primeiro (remove vy), depois i=2 (duplica).",
                                  "learningObjective": "Demonstrar falha de preservação da linguagem em cada caso.",
                                  "commonMistakes": [
                                    "Assumir w_i em L sem checar propriedades exatas.",
                                    "Esquecer de testar múltiplos i se um falhar."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir a Análise e Verificar Cobertura Completa",
                                  "subSteps": [
                                    "Confirme que todas decomposições foram analisadas e todas falham.",
                                    "Resuma: 'Nenhuma decomposição preserva L sob bombeamento'.",
                                    "Discuta se alguma decomposição foi perdida ou se p maior mudaria.",
                                    "Escreva a conclusão formal: L não é CFL."
                                  ],
                                  "verification": "Resumo escrito cobrindo todas decomposições com falhas citadas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista de todas análises"
                                  ],
                                  "tips": "Use tabela: Decomposição | i falho | Razão.",
                                  "learningObjective": "Sintetizar prova por contradição usando o teorema.",
                                  "commonMistakes": [
                                    "Concluir prematuramente sem checar todas.",
                                    "Ignorar edge cases como vy em sufixo."
                                  ]
                                }
                              ],
                              "practicalExample": "Para L = {a^n b^n c^n | n≥1}, w = aaabbbccc (n=3, |w|=9, p=5). Decomposições possíveis incluem: u=a, v=a, x=ab, y=b, z=bbccc (bombeia i=2: aaaabbb bcc → a's=4,b's=4,c's=3 ∉ L). Analise todas 4-6 decomposições na janela posições 2-6, mostrando cada falha em contagens.",
                              "finalVerifications": [
                                "Todas decomposições uvxyz listadas exaustivamente?",
                                "Para cada, w_0 e/ou w_2 ∉ L demonstrado?",
                                "Propriedades de L usadas corretamente para refutação?",
                                "Comprimento p e restrições |vxy|<=p, |vy|>=1 respeitados?",
                                "Conclusão formal de não-CFL explícita?",
                                "Nenhuma decomposição preserva L para todos i?",
                                "Análise cobre casos onde vy cruza símbolos?"
                              ],
                              "assessmentCriteria": [
                                "Exaustividade na enumeração de decomposições (sem omissões).",
                                "Precisão na verificação de w_i ∈ L (contagens simbólicas corretas).",
                                "Clareza na documentação de u,v,x,y,z e bombeamentos.",
                                "Uso correto das restrições do teorema.",
                                "Conclusão lógica por contradição robusta.",
                                "Profundidade na análise de falhas (múltiplos i se necessário)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Prova por contradição e exaustão de casos.",
                                "Lógica: Análise de casos exaustivos semelhantes a programação.",
                                "Algoritmos: Verificação de propriedades em autômatos pushdown.",
                                "Teoria da Computação: Paralelo com não-decidibilidade."
                              ],
                              "realWorldApplication": "Em compiladores, provar que certas linguagens de nested structures (ex: balanced XML com constraints) não são CFLs, guiando design de parsers recursivos descent ou uso de ferramentas mais poderosas como ANTLR para CSLs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Hierarquia de Chomsky para Gramáticas Tipo-2 (Livres de Contexto)",
                        "description": "Na hierarquia de Chomsky, as gramáticas tipo-2 são livres de contexto, gerando linguagens reconhecidas por autômatos de pilha. Elas estão entre as regulares (tipo-3) e sensíveis ao contexto (tipo-1), com propriedades de fechamento sob união, concatenação e estrelas, mas não sob interseção ou complemento.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Descrever a Hierarquia de Chomsky Focada em Tipo-2",
                            "description": "Explicar a hierarquia completa (tipos 0 a 3) e posicionar as gramáticas tipo-2, destacando a forma de produções A -> α onde A é não-terminal e α é qualquer cadeia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introduzir a Hierarquia de Chomsky Geral",
                                  "subSteps": [
                                    "Estude a definição da Hierarquia de Chomsky como uma classificação de linguagens formais e gramáticas por poder gerativo.",
                                    "Identifique os quatro tipos principais: Tipo 0 (não restrito), Tipo 1 (sensível ao contexto), Tipo 2 (livre de contexto) e Tipo 3 (regular).",
                                    "Desenhe um diagrama hierárquico mostrando a inclusão: Tipo 3 ⊂ Tipo 2 ⊂ Tipo 1 ⊂ Tipo 0.",
                                    "Memorize as restrições gerais de cada tipo em termos de regras de produção."
                                  ],
                                  "verification": "Crie um diagrama da hierarquia e explique a relação de inclusão para um parceiro de estudo.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Recursos online sobre Hierarquia de Chomsky",
                                    "Livro de Teoria da Computação (ex: Sipser)"
                                  ],
                                  "tips": "Use setas descendentes no diagrama para mostrar poder gerativo decrescente.",
                                  "learningObjective": "Compreender a estrutura geral e as relações de inclusão na hierarquia.",
                                  "commonMistakes": [
                                    "Confundir ordem dos tipos (lembre: números menores = mais poder)",
                                    "Ignorar que é uma hierarquia estrita de inclusão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente os Tipos de Gramáticas",
                                  "subSteps": [
                                    "Defina gramática formal G = (V, Σ, P, S) com não-terminais V, terminais Σ, produções P e axioma S.",
                                    "Descreva Tipo 0: qualquer produção α → β onde α contém pelo menos um não-terminal.",
                                    "Explique Tipo 1: |α| ≤ |β| e α = uAv com u,v em Σ*, A não-terminal.",
                                    "Detalhe Tipo 3: produções A → aB ou A → a (direita-linear) ou similares esquerda-linear.",
                                    "Compare restrições progressivamente mais fortes."
                                  ],
                                  "verification": "Escreva definições formais para cada tipo e valide com exemplos simples.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Vídeos tutoriais sobre gramáticas formais (YouTube/Khan Academy)"
                                  ],
                                  "tips": "Use notação matemática precisa para produções para evitar ambiguidades.",
                                  "learningObjective": "Dominar as definições formais que distinguem cada tipo.",
                                  "commonMistakes": [
                                    "Esquecer a condição de comprimento no Tipo 1",
                                    "Confundir linear com livre de contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Focar na Gramática Tipo-2 (Livre de Contexto)",
                                  "subSteps": [
                                    "Defina produções Tipo-2: A → α onde A é um único não-terminal e α é qualquer cadeia em (V ∪ Σ)*.",
                                    "Explique que não há restrições de comprimento ou contexto ao redor de A.",
                                    "Dê exemplos: S → aSb | ε (linguagem {a^n b^n}).",
                                    "Discuta autômatos equivalentes: empilhadoras determinísticas (DPDA) para linguagens determinísticas livres de contexto.",
                                    "Liste propriedades chave: fechamento sob união, concatenação, mas não interseção."
                                  ],
                                  "verification": "Construa uma gramática Tipo-2 para uma linguagem simples e prove que segue a forma A → α.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Editor de texto para escrever gramáticas",
                                    "Simulador de empilhadora online"
                                  ],
                                  "tips": "Sempre verifique se o lado esquerdo é exatamente um não-terminal.",
                                  "learningObjective": "Explicar precisamente a forma de produções e exemplos do Tipo-2.",
                                  "commonMistakes": [
                                    "Permitir múltiplos não-terminais no lado esquerdo",
                                    "Confundir com Tipo-3 que é linear"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Posicionar Tipo-2 na Hierarquia e Comparar",
                                  "subSteps": [
                                    "Posicione Tipo-2: gera linguagens livres de contexto (CFLs), incluídas em sensíveis ao contexto mas estritamente mais fracas que Tipo-1.",
                                    "Compare com Tipo-1: CFLs não podem contar comprimentos desiguais sem contexto.",
                                    "Compare com Tipo-3: CFLs aninham estruturas (ex: parênteses balanceados) que regulares não podem.",
                                    "Discuta teorema: toda CFL tem gramática Tipo-2 e vice-versa.",
                                    "Resuma importância: ponte entre regulares e mais complexas."
                                  ],
                                  "verification": "Escreva um parágrafo descrevendo o foco em Tipo-2 e sua posição, com comparações.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Exemplos de linguagens de cada tipo",
                                    "Tabela comparativa auto-criada"
                                  ],
                                  "tips": "Use contraexemplos para mostrar diferenças, como ww para Tipo-1 vs CFL.",
                                  "learningObjective": "Integrar Tipo-2 na hierarquia completa com comparações claras.",
                                  "commonMistakes": [
                                    "Achar que Tipo-2 é mais poderoso que Tipo-1",
                                    "Ignorar equivalências com autômatos"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada a gramática G = ({S}, {a,b}, {S → aSb | ε}, S), descreva a hierarquia de Chomsky, posicione-a como Tipo-2 (A → α com A=S, α=aSb ou ε), prove que não é Tipo-3 (não linear) e gere a string aabb.",
                              "finalVerifications": [
                                "Pode listar e definir corretamente os 4 tipos da hierarquia.",
                                "Explica a forma exata de produções Tipo-2: A → α.",
                                "Desenha diagrama de inclusão com Tipo-2 destacado.",
                                "Fornece exemplo válido de gramática Tipo-2 e classifica corretamente.",
                                "Compara Tipo-2 com vizinhos (Tipo-1 e Tipo-3) sem erros.",
                                "Menciona autômatos equivalentes (empilhadoras)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de produções Tipo-2 (100% match com A → α).",
                                "Completude da hierarquia (todos tipos cobertos com inclusão).",
                                "Uso de notação formal correta em exemplos.",
                                "Capacidade de fornecer contraexemplos para diferenças.",
                                "Clareza na explicação focada em Tipo-2.",
                                "Profundidade em propriedades e teoremas relacionados."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Modelos gerativos de linguagem natural (Chomsky humana).",
                                "Compiladores: Parsing sintático com gramáticas livres de contexto (Yacc/Bison).",
                                "Inteligência Artificial: Geração de árvores de análise em NLP.",
                                "Matemática: Teoria dos autômatos e linguagens formais."
                              ],
                              "realWorldApplication": "Gramáticas Tipo-2 são fundamentais em compiladores para analisar sintaxe de linguagens de programação (ex: expressões aninhadas em C++), processamento de XML/HTML balanceado e design de protocolos de comunicação com estruturas recursivas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Comparar Propriedades de Fechamento de CFLs com Outros Tipos",
                            "description": "Listar e justificar propriedades de fechamento das CFLs (fechadas sob união, concatenação, Kleene star; abertas sob interseção e complemento) em relação às regulares e sensíveis ao contexto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Propriedades de Fechamento das Linguagens Regulares",
                                  "subSteps": [
                                    "Defina fechamento sob operações booleanas e algébricas (união, concatenação, Kleene star, interseção, complemento).",
                                    "Liste as propriedades: regulares são fechadas sob todas (união, concatenação, star, interseção, complemento).",
                                    "Estude provas básicas usando autômatos finitos (AFDs/AFNs).",
                                    "Forneça exemplos: L = (a|b)* fechada sob união com (a+b)*.",
                                    "Pratique convertendo AFNs para AFDs para verificar fechamento."
                                  ],
                                  "verification": "Construa um autômato para a união de duas linguagens regulares e simule entradas para validar.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Cap. 1)",
                                    "Ferramenta JFLAP para simulação de autômatos",
                                    "Notas sobre autômatos finitos"
                                  ],
                                  "tips": "Use diagramas de estados para visualizar fechamentos; comece com linguagens simples como (ab)*.",
                                  "learningObjective": "Compreender que linguagens regulares são um modelo fechado robusto.",
                                  "commonMistakes": [
                                    "Confundir fechamento com decidibilidade",
                                    "Esquecer que star preserva regularidade via construção de AFN"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Propriedades de Fechamento das CFLs",
                                  "subSteps": [
                                    "Liste propriedades: fechadas sob união, concatenação, Kleene star; abertas sob interseção e complemento.",
                                    "Estude provas de fechamento: construção de gramáticas livres de contexto (GLCs) para união/concat/star.",
                                    "Aprenda contraexemplos: interseção de {a^n b^n} e {a^n c^n} gera {a^n b^n c^n}, não CFL.",
                                    "Discuta complemento: se L é CFL, complemento pode não ser (ex: {ww | w em {a,b}*}).",
                                    "Pratique derivando gramáticas para operações fechadas."
                                  ],
                                  "verification": "Escreva gramáticas GLCs para união e star de duas CFLs dadas e gere strings para teste.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Sipser Cap. 2 (Pushdown Automata)",
                                    "JFLAP para gramáticas GLC",
                                    "Artigos sobre propriedades de CFLs"
                                  ],
                                  "tips": "Use notação de Chomsky normal form para simplificar provas de fechamento.",
                                  "learningObjective": "Dominar as operações que preservam e quebram o classe das CFLs.",
                                  "commonMistakes": [
                                    "Achar que CFLs são fechadas sob interseção",
                                    "Ignorar necessidade de PDA determinístico para alguns casos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Propriedades de Fechamento das Linguagens Sensíveis ao Contexto (CSLs)",
                                  "subSteps": [
                                    "Defina CSLs como reconhecidas por automatos lineares limitados (ALBs).",
                                    "Liste propriedades: fechadas sob união, concatenação, interseção, complemento (mas não necessariamente star).",
                                    "Compare hierarquia: CSLs contêm CFLs e regulares.",
                                    "Estude provas usando reduções de gramáticas tipo-1.",
                                    "Forneça exemplo: {a^n b^n c^n} é CSL mas não CFL."
                                  ],
                                  "verification": "Prove que a interseção de duas CSLs é CSL via construção de ALB.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Hopcroft & Ullman 'Formal Languages' Cap. 9",
                                    "Notas sobre hierarquia de Chomsky"
                                  ],
                                  "tips": "Lembre que CSLs têm restrição linear no espaço da fita.",
                                  "learningObjective": "Entender o poder expressivo maior das CSLs em relação às CFLs.",
                                  "commonMistakes": [
                                    "Confundir CSLs com recursivas",
                                    "Esquecer que star pode não ser fechado para CSLs não regulares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Justificar Propriedades Entre as Classes",
                                  "subSteps": [
                                    "Crie tabela comparativa: operações vs. classes (Reg, CFL, CSL).",
                                    "Justifique por que CFLs falham em interseção/complemento (bombando lemma).",
                                    "Discuta implicações na hierarquia de Chomsky.",
                                    "Analise exemplos concretos de linguagens que 'escapam' de CFLs para CSLs.",
                                    "Pratique perguntas: 'L1 ∪ L2 é CFL se L1 e L2 são?'"
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas de comparação e justifique com provas/exemplos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de fechamento impressa",
                                    "Exercícios de teoria da computação online (GeeksforGeeks)"
                                  ],
                                  "tips": "Use diagrama de Venn para visualizar inclusões e fechamentos.",
                                  "learningObjective": "Capacitar comparações precisas entre classes de linguagens.",
                                  "commonMistakes": [
                                    "Invertir propriedades de CFLs e regulares",
                                    "Não usar contraexemplos específicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere L1 = {a^n b^n | n ≥ 0} (CFL) e L2 = {a^n c^n | n ≥ 0} (CFL). Sua interseção é {a^n b^n c^n | n ≥ 0}, que não é CFL (pelo lemma de bombamento), demonstrando que CFLs não são fechadas sob interseção, ao contrário das regulares (fechadas) e CSLs (fechadas).",
                              "finalVerifications": [
                                "Lista corretamente as 5 operações e status de fechamento para cada classe.",
                                "Fornece contraexemplo válido para cada propriedade aberta das CFLs.",
                                "Constrói gramática ou autômato para pelo menos duas operações fechadas em CFLs.",
                                "Explica impacto na hierarquia de Chomsky com diagrama.",
                                "Responde perguntas comparativas sem erros.",
                                "Identifica corretamente {a^n b^n c^n} como CSL não-CFL."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas listas de propriedades (100% correto).",
                                "Qualidade das justificativas/provas (uso de lemma de bombamento).",
                                "Criatividade e correção de exemplos/contraexemplos.",
                                "Completude da tabela comparativa.",
                                "Profundidade nas implicações teóricas e práticas.",
                                "Capacidade de reproduzir construções (gramáticas/autômatos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e álgebra (operações em linguagens como conjuntos).",
                                "Lógica: Propriedades de fechamento semelhantes a álgebras booleanas.",
                                "Programação: Análise sintática em compiladores (parsers LL/LR usam CFLs).",
                                "Inteligência Artificial: Modelos de gramáticas em PLN e reconhecimento de padrões.",
                                "Engenharia de Software: Verificação formal de propriedades em sistemas."
                              ],
                              "realWorldApplication": "Em compiladores, entender que parsers context-free (CFLs) lidam bem com concatenação/união em gramáticas, mas falham em interseções ambíguas, exigindo análises sensíveis ao contexto para linguagens como C++ com templates; otimiza design de linguagens de programação e ferramentas de verificação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Relacionar Gramáticas Tipo-2 com Autômatos de Pilha",
                            "description": "Demonstrar a equivalência entre linguagens geradas por gramáticas livres de contexto e linguagens aceitas por autômatos de pilha determinísticos ou não-determinísticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Gramáticas Livres de Contexto (GLC) e Autômatos de Pilha (PDA)",
                                  "subSteps": [
                                    "Defina formalmente uma GLC: G = (V, Σ, P, S), explicando cada componente.",
                                    "Descreva a estrutura de um PDA: estados, alfabeto de entrada, pilha, transições δ(q, a, X) = (p, γ).",
                                    "Compare linguagens geradas por GLC (L(G)) com linguagens aceitas por PDA (L(P)).",
                                    "Estude exemplos simples como {a^n b^n | n ≥ 0} para ilustrar.",
                                    "Identifique propriedades chave: PDA usam pilha para memória ilimitada em altura."
                                  ],
                                  "verification": "Resuma em um diagrama ou tabela comparando GLC e PDA, confirmando definições corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introduction to Automata Theory' de Hopcroft, diagramas em papel ou ferramenta como Draw.io.",
                                  "tips": "Use notação formal precisa para evitar confusões semânticas.",
                                  "learningObjective": "Compreender definições formais e estruturas básicas de GLC e PDA.",
                                  "commonMistakes": "Confundir PDA determinístico (DPDA) com não-determinístico (NPDA); lembrar que GLC equivalem a NPDA."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir PDA a partir de uma Gramática Livre de Contexto",
                                  "subSteps": [
                                    "Aplique o algoritmo padrão: para cada produção A → α, crie transições que empilhem não-terminais e popem terminais.",
                                    "Implemente o processo de 'empty stack acceptance': PDA esvazia pilha ao final da entrada.",
                                    "Trate casos especiais como ε-produções e unitárias.",
                                    "Teste com uma GLC simples: S → aSb | ε.",
                                    "Desenhe o diagrama de estados do PDA resultante."
                                  ],
                                  "verification": "Construa PDA para uma GLC dada e simule aceitação de strings válidas/inválidas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel para diagramas, simulador online de PDA (ex: JFLAP).",
                                  "tips": "Comece com GLC em Forma Normal de Chomsky para simplificar.",
                                  "learningObjective": "Dominar a construção sistemática de PDA equivalente a uma GLC.",
                                  "commonMistakes": "Esquecer de lidar com ε-transições, levando a rejeições incorretas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Gramática Livre de Contexto a partir de um Autômato de Pilha",
                                  "subSteps": [
                                    "Use o método de 'pilha como variáveis': cada símbolo de pilha é uma variável não-terminal.",
                                    "Gere produções baseadas em transições: para δ(q, a, X) = (p, YZ), crie X → a Y Z.",
                                    "Inclua estado inicial como variável inicial e estados finais para aceitação.",
                                    "Elimine produções desnecessárias e normalize a gramática.",
                                    "Valide convertendo de volta para PDA e comparando linguagens."
                                  ],
                                  "verification": "Gere GLC de um PDA e prove que L(GLC) = L(PDA) para strings de teste.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "JFLAP ou software similar, folhas para produções.",
                                  "tips": "Rastreie configurações (q, w, γ) para garantir completude.",
                                  "learningObjective": "Aprender a reversão da construção, solidificando a equivalência.",
                                  "commonMistakes": "Ignorar múltiplas transições para o mesmo símbolo de pilha, resultando em gramáticas incompletas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Equivalência e Aplicar em Exemplos Práticos",
                                  "subSteps": [
                                    "Estude teoremas: Toda GLC gera uma linguagem aceita por NPDA, e vice-versa.",
                                    "Analise linguagem de parênteses balanceados: construa GLC e PDA bidirecionalmente.",
                                    "Discuta limitações: PDAs não aceitam linguagens livres de contexto determinísticas estritamente.",
                                    "Simule execuções passo a passo para validação.",
                                    "Resolva exercícios variados para reforço."
                                  ],
                                  "verification": "Resolva 3 problemas de conversão e prove equivalência com simulações.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Exercícios de livro-texto, JFLAP para simulações.",
                                  "tips": "Use tabelas de configuração para rastrear simulações.",
                                  "learningObjective": "Demonstrar teoremas de equivalência através de provas e exemplos.",
                                  "commonMistakes": "Confundir aceitação por estado final vs. pilha vazia."
                                }
                              ],
                              "practicalExample": "Para a linguagem de parênteses balanceados { (^n $)^n | n ≥ 0 }: GLC: S → (S) | ε. Construa PDA: empilhe '(' em push, pop em ')', aceita se pilha vazia no fim. Converta de volta: variáveis para pilha simulam empilhamento.",
                              "finalVerifications": [
                                "Construir corretamente PDA de uma GLC dada sem erros de transição.",
                                "Gerar GLC equivalente de um PDA simples.",
                                "Simular aceitação/rejeição de 5 strings em PDA construído.",
                                "Explicar teorema de equivalência em palavras próprias.",
                                "Identificar quando usar NPDA vs. DPDA.",
                                "Aplicar em exemplo não-trivial como {a^n b^n c^n} (não-LC, mas testar limites)."
                              ],
                              "assessmentCriteria": [
                                "Precisão formal nas definições e construções (30%).",
                                "Corretude das simulações e provas de equivalência (25%).",
                                "Profundidade nos subpassos e tratamento de casos edge (20%).",
                                "Clareza em diagramas e explicações (15%).",
                                "Criatividade em exemplos e conexões (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Indução para provas de equivalência.",
                                "Lógica: Semântica formal e dedução em sistemas de regras de produção.",
                                "Programação: Parsers recursivos em compiladores (ex: Yacc/Bison)."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens de programação, PDAs e GLCs são usados em analisadores sintáticos para validar estruturas aninhadas como blocos de código ou expressões balanceadas, essenciais em ferramentas como LLVM ou parsers JSON/XML."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.4",
                            "name": "Identificar Exemplos de Linguagens na Hierarquia Tipo-2",
                            "description": "Classificar linguagens como {a^n b^n | n >= 0} (CFL) versus {a^n b^n c^n | n >= 0} (não CFL), usando a hierarquia para justificar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Hierarquia de Chomsky e Características das Gramáticas Tipo-2",
                                  "subSteps": [
                                    "Estude a hierarquia de Chomsky: Tipo-0 (recursivamente enumeráveis), Tipo-1 (sensíveis ao contexto), Tipo-2 (livres de contexto - CFL), Tipo-3 (regulares).",
                                    "Identifique regras de produção para Tipo-2: uma não-terminal no lado esquerdo (A → α), onde α é uma cadeia de terminais e não-terminais.",
                                    "Compare com Tipo-1: restrições de comprimento |α| ≥ |A|.",
                                    "Revise exemplos básicos: linguagens regulares (Tipo-3) vs. CFLs como parênteses balanceados.",
                                    "Anote diferenças chave: CFLs reconhecidas por PDAs (Pushdown Automata)."
                                  ],
                                  "verification": "Crie um diagrama da hierarquia de Chomsky e liste 3 características únicas das gramáticas Tipo-2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre teoria da computação, diagrama da hierarquia de Chomsky (impresso ou digital).",
                                  "tips": "Use setas descendentes no diagrama para mostrar inclusão: Tipo-3 ⊆ Tipo-2 ⊆ Tipo-1 ⊆ Tipo-0.",
                                  "learningObjective": "Compreender a posição e regras das gramáticas Tipo-2 na hierarquia.",
                                  "commonMistakes": "Confundir regras de produção de Tipo-2 com Tipo-1 (ignorar restrição de comprimento)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos de Linguagens Livres de Contexto (CFL)",
                                  "subSteps": [
                                    "Defina {a^n b^n | n ≥ 0} e gere strings: ε, ab, aabb, aaabbb.",
                                    "Construa uma gramática CFG: S → aSb | ε.",
                                    "Desenhe uma árvore de derivação para 'aabb'.",
                                    "Explique reconhecimento por PDA: empilhar 'a's, desempilhar com 'b's.",
                                    "Classifique como Tipo-2 usando a forma da gramática."
                                  ],
                                  "verification": "Gere 5 strings da linguagem e derive uma via CFG.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel para árvores de derivação, simulador de PDA online (ex: JFLAP).",
                                  "tips": "Sempre verifique se n=0 produz ε corretamente.",
                                  "learningObjective": "Identificar e justificar por que uma linguagem é CFL usando gramática e PDA.",
                                  "commonMistakes": "Gerar strings inválidas como 'aabbb' e classificá-las erroneamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Linguagens Não Livres de Contexto Usando o Pumping Lemma",
                                  "subSteps": [
                                    "Enuncie o Pumping Lemma para CFLs: para L CFL, existe p tal que w=uvwxy com |vwx|≤p, |vx|≥1, e uv^k x y^k ∈ L para k≥0.",
                                    "Aplique a {a^n b^n c^n | n ≥ 0}: assuma CFL, pegue w=a^p b^p c^p.",
                                    "Considere casos de divisão (v ou x em regiões diferentes de a's, b's, c's) e mostre que algum k viola a linguagem.",
                                    "Conclua que não é CFL (Tipo-2), mas é CSG (Tipo-1).",
                                    "Compare com hierarquia: requer contexto para contar três símbolos."
                                  ],
                                  "verification": "Escreva prova completa do Pumping Lemma para {a^n b^n c^n}.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de exercícios do Pumping Lemma, calculadora para casos.",
                                  "tips": "Liste todos 9 casos possíveis de divisão para w=a^p b^p c^p.",
                                  "learningObjective": "Usar Pumping Lemma para provar que uma linguagem não é Tipo-2.",
                                  "commonMistakes": "Esquecer |vx|≥1 ou não cobrir todos os casos de bombeamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Classificação e Justificativa de Linguagens",
                                  "subSteps": [
                                    "Classifique novas linguagens: {ww | w ∈ {a,b}*} (não CFL), {a^n b^m | n≤m} (CFL).",
                                    "Justifique usando gramática para CFLs ou Pumping Lemma para não-CFLs.",
                                    "Crie tabela: Linguagem | Tipo | Justificativa.",
                                    "Teste com 3 exemplos mistos e autoavalie.",
                                    "Resuma regras para identificar na hierarquia Tipo-2."
                                  ],
                                  "verification": "Classifique corretamente 5 linguagens dadas e justifique.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Lista de linguagens de teste, quadro branco para tabelas.",
                                  "tips": "Comece com 'pode ser gerada por CFG?' antes de Pumping Lemma.",
                                  "learningObjective": "Aplicar hierarquia para classificar e justificar exemplos.",
                                  "commonMistakes": "Classificar {a^n b^n c^n} como CFL por confusão com dois símbolos."
                                }
                              ],
                              "practicalExample": "Dada a linguagem L = {a^n b^n c^m | n,m ≥ 0}, construa uma CFG (S → aSb | T, T → cT | ε) para provar que é CFL (Tipo-2), justificando pela ausência de dependência entre n e m.",
                              "finalVerifications": [
                                "Classifique {a^n b^n | n ≥ 0} como CFL com gramática exemplo.",
                                "Prove que {a^n b^n c^n | n ≥ 0} não é CFL via Pumping Lemma.",
                                "Desenhe PDA para {a^n b^n}.",
                                "Liste 3 linguagens regulares que são CFLs.",
                                "Explique por que CFLs são estritamente mais poderosas que regulares.",
                                "Identifique uma linguagem CSG que não é CFL."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de regras Tipo-2 (100% corretas).",
                                "Prova correta do Pumping Lemma sem falhas lógicas.",
                                "Justificativas claras ligando à hierarquia de Chomsky.",
                                "Exemplos gerados válidos e árvores de derivação completas.",
                                "Cobertura de casos no bombeamento (todos considerados).",
                                "Aplicação consistente a novos exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e indução para provas.",
                                "Lógica: Raciocínio deductivo no Pumping Lemma.",
                                "Programação: Parsing em compiladores (CFGs para expressões).",
                                "Linguística: Gramáticas gerativas semelhantes a Chomsky.",
                                "Algoritmos: Autômatos como base para máquinas de estados."
                              ],
                              "realWorldApplication": "Em compiladores, CFGs (Tipo-2) parseiam sintaxe de linguagens como Python (expressões aninhadas), enquanto linguagens como {a^n b^n c^n} modelam dependências que requerem parsers sensíveis ao contexto em verificadores avançados."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Linguagens Sensíveis ao Contexto",
                    "description": "Definição, gramáticas tipo-1 e reconhecimento por máquinas lineares limitadas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Definição de Linguagens Sensíveis ao Contexto",
                        "description": "Conceito fundamental que define linguagens sensíveis ao contexto (CSL) como o conjunto de linguagens geradas por gramáticas tipo-1 na hierarquia de Chomsky, posicionadas entre linguagens livres de contexto e recursivamente enumeráveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Definir formalmente linguagens sensíveis ao contexto",
                            "description": "Explicar a definição formal de uma linguagem sensível ao contexto como L(G) onde G é uma gramática tipo-1, destacando restrições no comprimento das derivadas (|α| ≥ |β| para regras α → β).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Hierarquia de Chomsky",
                                  "subSteps": [
                                    "Estude a hierarquia de Chomsky: Tipo 0 (recursivamente enumeráveis), Tipo 1 (sensíveis ao contexto), Tipo 2 (livres de contexto) e Tipo 3 (regulares).",
                                    "Identifique que linguagens sensíveis ao contexto correspondem a gramáticas Tipo 1.",
                                    "Compare o poder expressivo: Tipo 1 ⊆ Tipo 0, mas mais restrito que Tipo 0.",
                                    "Memorize as formas gerais das regras: para Tipo 1, α → β com |α| ≥ |β| (exceto S → ε).",
                                    "Anote exemplos de linguagens para cada tipo."
                                  ],
                                  "verification": "Liste os 4 tipos de gramáticas com uma linguagem exemplo para cada e a restrição de regras do Tipo 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser ou Hopcroft), diagrama da Hierarquia de Chomsky"
                                  ],
                                  "tips": [
                                    "Use a mnemônica 'Ugly Cats Run Fast' para Unrestricted, Context-Sensitive, Context-Free, Regular.",
                                    "Desenhe a pirâmide da hierarquia para visualização."
                                  ],
                                  "learningObjective": "Posicionar gramáticas sensíveis ao contexto na hierarquia formal de linguagens.",
                                  "commonMistakes": [
                                    "Confundir Tipo 1 com Tipo 2 (ex: achar que {a^n b^n} é sensível ao contexto, quando é livre de contexto).",
                                    "Esquecer a exceção para a regra inicial S → ε."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente os Componentes de uma Gramática",
                                  "subSteps": [
                                    "Defina G = (V, Σ, P, S), onde V é alfabeto de variáveis/não-terminais, Σ terminais, P regras de produção, S axioma.",
                                    "Especifique que V ∩ Σ = ∅.",
                                    "Liste regras gerais para Tipo 1: αAβ → αγβ, onde A ∈ V, γ ≠ ε, α, β, γ ∈ V* Σ*.",
                                    "Enfatize que todas as regras devem satisfazer |αAβ| ≥ |αγβ|, exceto possivelmente S → ε.",
                                    "Escreva a notação formal em um papel."
                                  ],
                                  "verification": "Escreva a tupla formal G = (V, Σ, P, S) com exemplos de cada componente para uma gramática Tipo 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referência online sobre gramáticas formais (Wikipedia: Context-sensitive grammar)"
                                  ],
                                  "tips": [
                                    "Sempre inclua S como não-terminal inicial único.",
                                    "Use símbolos padrão: V maiúsculas, Σ minúsculas."
                                  ],
                                  "learningObjective": "Dominar a estrutura formal de uma gramática sensível ao contexto.",
                                  "commonMistakes": [
                                    "Permitir γ = ε em regras não-iniciais.",
                                    "Confundir terminais com não-terminais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Restrição de Comprimento e Derivações",
                                  "subSteps": [
                                    "Explique a condição |α| ≥ |β| para regras α → β: comprimento não diminui (monótono).",
                                    "Discuta derivações: sequências de aplicações de regras iniciando de S até string terminal.",
                                    "Defina L(G) = {w ∈ Σ* | S ⇒* w, sem mais derivações}.",
                                    "Ilustre com uma derivação passo a passo para uma regra simples.",
                                    "Compare com outros tipos: sem essa restrição em Tipo 0."
                                  ],
                                  "verification": "Forneça uma regra exemplo e verifique se |α| ≥ |β|, depois defina L(G) corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora para contar comprimentos de strings",
                                    "Exemplos de gramáticas Tipo 1"
                                  ],
                                  "tips": [
                                    "Conte símbolos explicitamente: |abcA| = 4.",
                                    "Lembre: restrição garante decidibilidade de aceitação em espaço linear."
                                  ],
                                  "learningObjective": "Compreender a restrição não-contrátil e seu papel na definição de L(G).",
                                  "commonMistakes": [
                                    "Permitir contrações como A → ε em regras internas.",
                                    "Confundir L(G) com o conjunto de todas derivadas, incluindo não-terminais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a Definição Completa e Verificar",
                                  "subSteps": [
                                    "Combine tudo: Uma linguagem sensível ao contexto é L(G) para G Tipo 1.",
                                    "Escreva a definição formal completa: 'L é sensível ao contexto se existe G = (V, Σ, P, S) com regras α → β (|α| ≥ |β|) tal que L = L(G)'.",
                                    "Teste com exemplo: gramática para {a^n b^n c^n | n ≥ 1}.",
                                    "Discuta propriedades: fechadas sob união, mas não necessariamente interseção.",
                                    "Crie sua própria definição em palavras e formal."
                                  ],
                                  "verification": "Redija a definição formal completa e valide com um peer ou auto-teste.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo de gramática CSL: {a^n b^n c^n}",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": [
                                    "Pratique verbalizando a definição em voz alta.",
                                    "Use setas ⇒ para derivadas."
                                  ],
                                  "learningObjective": "Articular a definição formal integral de linguagens sensíveis ao contexto.",
                                  "commonMistakes": [
                                    "Omitir a restrição |α| ≥ |β|.",
                                    "Definir L(G) como todas strings deriváveis, não só terminais."
                                  ]
                                }
                              ],
                              "practicalExample": "Defina G = ({S, A, B, C}, {a,b,c}, P, S) com regras como aS → aAC, CB → BC, bB → bc, CA → aC, S → abc | ε (ajustada para |α| ≥ |β|). Então L(G) = {a^n b^n c^n | n ≥ 1}, uma linguagem clássica sensível ao contexto, demonstrando derivações não-contráteis.",
                              "finalVerifications": [
                                "Recitar a definição formal de L(G) para gramática Tipo 1.",
                                "Explicar corretamente a restrição |α| ≥ |β| com exceção.",
                                "Identificar componentes de G = (V, Σ, P, S).",
                                "Classificar uma gramática dada como Tipo 1 ou não.",
                                "Gerar uma derivação válida para uma regra CSL.",
                                "Diferenciar CSL de CFL e Regular."
                              ],
                              "assessmentCriteria": [
                                "Precisão na tupla G e restrições de regras (100% correto).",
                                "Clareza na explicação de L(G) e derivações.",
                                "Correta aplicação da condição de comprimento em exemplos.",
                                "Uso apropriado de notação formal (⇒*, |w|).",
                                "Capacidade de distinguir CSL de outros tipos.",
                                "Profundidade em propriedades e exceções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Autômatos (famílias de linguagens).",
                                "Lógica: Sistemas de Reescrita Formal e Dedução.",
                                "Linguística Computacional: Análise Sintática de Linguagens Naturais.",
                                "Engenharia de Software: Parsing em Compiladores."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens de programação (ex: verificação de tipos sensíveis ao contexto em C++ templates) e processadores de XML/SGML, onde gramáticas CS garantem estruturas balanceadas como {a^n b^n c^n} para validação hierárquica complexa."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Identificar exemplos de linguagens sensíveis ao contexto",
                            "description": "Reconhecer e citar exemplos clássicos como {a^n b^n c^n | n ≥ 1}, que não é livre de contexto mas é sensível ao contexto, e diferenciá-las de linguagens regulares e livres de contexto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Hierarquia de Chomsky e Definições Básicas",
                                  "subSteps": [
                                    "Estude a hierarquia de Chomsky: linguagens regulares (Tipo 3), livres de contexto (Tipo 2) e sensíveis ao contexto (Tipo 1).",
                                    "Leia definições formais: gramáticas regulares, livres de contexto e sensíveis ao contexto.",
                                    "Anote diferenças chave: poder expressivo, tipos de autômatos (AFD, PDA, LBA).",
                                    "Compare com linguagens recursivas (Tipo 0) para contexto.",
                                    "Crie um diagrama resumindo a hierarquia."
                                  ],
                                  "verification": "Capacidade de explicar verbalmente ou por escrito as diferenças entre RL, CFL e CSL com exemplos simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Teoria da Computação (ex: Sipser), slides da hierarquia de Chomsky, papel e caneta para diagrama.",
                                  "tips": "Use mnemônicos: 'Regulares = Finitos, Context-Free = Pilha, Context-Sensitive = Espaço Linear'.",
                                  "learningObjective": "Compreender a posição das CSLs na hierarquia e suas limitações em relação a CFLs.",
                                  "commonMistakes": "Confundir CSL com CFL achando que CSL são 'mais livres'; lembrar que CSL têm regras mais restritivas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos Clássicos de Linguagens Sensíveis ao Contexto",
                                  "subSteps": [
                                    "Estude {a^n b^n c^n | n ≥ 1}: gere strings para n=1,2,3 e visualize por que requer contagem tripla.",
                                    "Compare com {a^n b^n | n ≥ 1} (CFL) e {a^n | n ≥ 1} (RL).",
                                    "Leia provas usando Lemma de Bombeamento para CFL mostrando que não é CFL.",
                                    "Identifique outros exemplos: {a^n b^n c^n d^n | n ≥ 1}, linguagens de cópias.",
                                    "Classifique 5 strings dadas como pertencentes ou não à CSL."
                                  ],
                                  "verification": "Listar 3 exemplos de CSLs e explicar por que não são CFLs usando argumentos intuitivos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Exemplos de linguagens formais online (Wikipedia ou notas de aula), calculadora para gerar strings grandes.",
                                  "tips": "Visualize com blocos coloridos: um para a, b, c – conte manualmente para n=5.",
                                  "learningObjective": "Reconhecer padrões que demandam memória linear, característicos de CSLs.",
                                  "commonMistakes": "Achar que toda linguagem com 'n's iguais é CSL; testar com pumping lemma."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar Ferramentas de Prova: Lemmas de Bombeamento",
                                  "subSteps": [
                                    "Revise Lemma de Bombeamento para RL e CFL.",
                                    "Aprenda adaptação para CSL (Linear Bounded Automata).",
                                    "Aplique ao exemplo {a^n b^n c^n}: assuma CFL, bombeie e derive contradição.",
                                    "Pratique prova em outro exemplo: {ww | w ∈ {a,b}*}.",
                                    "Resolva exercícios: prove que dada linguagem é CSL mas não CFL."
                                  ],
                                  "verification": "Escrever uma prova curta usando pumping lemma para {a^n b^n c^n} não ser CFL.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Tutorial de pumping lemmas (YouTube ou Khan Academy), folhas de exercícios de teoria da computação.",
                                  "tips": "Desenhe o bombeamento: marque i,j,k e mostre como quebra a igualdade.",
                                  "learningObjective": "Usar formalmente ferramentas para diferenciar classes de linguagens.",
                                  "commonMistakes": "Erros no índice de bombeamento; sempre verifique casos base n=1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Diferenciação",
                                  "subSteps": [
                                    "Receba 10 linguagens mistas (RL, CFL, CSL, outras) e classifique cada uma.",
                                    "Cite exemplos clássicos para cada classe e justifique.",
                                    "Crie sua própria CSL não-CFL e teste com pumping.",
                                    "Debata em fórum ou com par: 'É {a^n b^m | n=m+1} CSL?'.",
                                    "Resuma em tabela: Linguagem | Classe | Razão."
                                  ],
                                  "verification": "Tabela completa com 5 exemplos corretamente classificados e justificadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Lista de exercícios de linguagens formais (PDF de universidade), tabela em Excel/Google Sheets.",
                                  "tips": "Comece com linguagens conhecidas antes de novas; memorize {a^n b^n c^n} como benchmark.",
                                  "learningObjective": "Identificar rapidamente CSLs citando exemplos e diferenciando de RL/CFL.",
                                  "commonMistakes": "Classificar CSL como CFL por similaridade superficial; sempre use prova."
                                }
                              ],
                              "practicalExample": "Dada a linguagem L = {a^n b^n c^n | n ≥ 1}, classifique-a: Gere w = aaabbbccc (n=3). Prove não CFL: assuma CFL, pumping lemma dá decomposição onde bombeamento altera contagens desigualmente. É CSL pois aceita por LBA contando com fita linear.",
                              "finalVerifications": [
                                "Citar corretamente {a^n b^n c^n | n ≥ 1} como CSL não-CFL.",
                                "Explicar por que {a^n b^n | n ≥ 1} é CFL mas {a^n b^n c^n} não.",
                                "Aplicar pumping lemma intuitivamente a um novo exemplo.",
                                "Diferenciar RL (ex: (ab)*) de CSL.",
                                "Listar 2 outros exemplos de CSLs clássicos.",
                                "Criar diagrama hierárquico preciso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação de exemplos clássicos (100% correto).",
                                "Uso correto de lemmas de bombeamento em provas (sem erros lógicos).",
                                "Diferenciação clara entre RL, CFL e CSL com justificativas.",
                                "Profundidade nos sub-passos: pelo menos 80% completos.",
                                "Criatividade em exemplos próprios viáveis.",
                                "Tempo de resposta em classificações (<2 min por linguagem)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Indução para provas.",
                                "Lógica: Raciocínio dedutivo em lemmas de bombeamento.",
                                "Programação: Simulação de autômatos em Python para visualização.",
                                "Linguística: Paralelos com gramáticas naturais contextuais."
                              ],
                              "realWorldApplication": "Em compiladores avançados e verificadores formais (ex: análise sintática em linguagens com dependências lineares como certas DSLs em IA), ou em bioinformática para padrões de DNA com contagens proporcionais (ex: genes repetidos)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Posicionar CSLs na hierarquia de Chomsky",
                            "description": "Descrever a hierarquia de Chomsky (Tipo-3 ⊂ Tipo-2 ⊂ Tipo-1 ⊂ Tipo-0) e explicar propriedades como fechamento sob união, concatenação e que CSLs não são necessariamente fechadas sob complemento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Hierarquia de Chomsky Completa",
                                  "subSteps": [
                                    "Estude as quatro classes principais: Tipo-3 (Regular), Tipo-2 (Context-Free), Tipo-1 (Context-Sensitive) e Tipo-0 (Recursively Enumerable).",
                                    "Memorize as inclusões estritas: Type-3 ⊂ Type-2 ⊂ Type-1 ⊂ Type-0.",
                                    "Identifique gramáticas e autômatos associados: Regex para Type-3, PDA para Type-2, LBA para Type-1, TM para Type-0.",
                                    "Anote exemplos clássicos para cada tipo, como {a^n b^n} para Type-2.",
                                    "Desenhe um diagrama da hierarquia com setas de inclusão."
                                  ],
                                  "verification": "Desenhe e explique o diagrama da hierarquia corretamente para um colega ou em voz alta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (ex: Sipser), slides de aula, papel e caneta para diagrama.",
                                  "tips": "Use setas direcionadas para mostrar inclusões estritas e evite confundir com equivalências.",
                                  "learningObjective": "Compreender a estrutura hierárquica completa de linguagens formais.",
                                  "commonMistakes": "Confundir Type-1 com Type-0 ou inverter as inclusões."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Posicionar Linguagens Sensíveis ao Contexto (CSLs, Type-1)",
                                  "subSteps": [
                                    "Defina CSL como linguagens geradas por gramáticas Type-1 (produções α → β onde |β| ≥ |α|).",
                                    "Explique reconhecimento por Linear Bounded Automata (LBA), que usa espaço linear na entrada.",
                                    "Compare com Type-2: CSLs incluem linguagens não context-free, como {a^n b^n c^n}.",
                                    "Liste propriedades únicas: decidibilidade de aceitação (ao contrário de Type-0).",
                                    "Crie uma tabela comparativa de poder expressivo entre Type-1 e vizinhos."
                                  ],
                                  "verification": "Classifique corretamente 3 linguagens exemplo na hierarquia, justificando por que são Type-1.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Notas de aula sobre gramáticas Type-1, exemplos de linguagens online (Wikipedia Chomsky hierarchy).",
                                  "tips": "Lembre-se: CSLs são 'entre' context-free e recursivamente enumeráveis em poder.",
                                  "learningObjective": "Localizar precisamente CSLs na hierarquia e suas características definidoras.",
                                  "commonMistakes": "Achar que todas CSLs são context-free ou ignorar restrição de espaço no LBA."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Propriedades de Fechamento de CSLs",
                                  "subSteps": [
                                    "Verifique fechamento sob união: prove que união de duas CSLs é CSL usando gramática Type-1 modificada.",
                                    "Verifique fechamento sob concatenação: construa gramática para L1 · L2 se L1 e L2 forem CSLs.",
                                    "Discuta não-fechamento sob complemento: dê contraexemplo, como co-{a^n b^n c^n} não CSL.",
                                    "Explore outras operações: fechadas sob interseção com linguagens regulares.",
                                    "Resuma em uma tabela: operações sim/não com justificativa breve."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que CSLs são fechadas sob união e não sob complemento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Referências teóricas (Hopcroft/Ullman), quadro branco para provas.",
                                  "tips": "Para união, use não-terminais para 'escolher' qual linguagem gerar primeiro.",
                                  "learningObjective": "Dominar as propriedades algébricas de fechamento específicas de CSLs.",
                                  "commonMistakes": "Confundir fechamento de CSLs com o de CFLs (CFLs fechadas sob união mas não interseção)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Sintetizar Conhecimento com Exemplos",
                                  "subSteps": [
                                    "Classifique linguagens dadas: ex. {ww | w em {a,b}*} é CSL mas não CFL.",
                                    "Construa uma gramática Type-1 simples para {a^n b^n c^n}.",
                                    "Debata implicações: por que CSLs são úteis apesar de indecidibilidade de algumas propriedades.",
                                    "Crie flashcards com hierarquia, posicionamento e fechamentos.",
                                    "Teste-se resolvendo exercícios de posicionamento."
                                  ],
                                  "verification": "Resolva um quiz com 5 questões sobre hierarquia, CSLs e fechamentos sem erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exercícios de livro-texto, Anki para flashcards.",
                                  "tips": "Pratique com linguagens ambíguas para reforçar diferenças.",
                                  "learningObjective": "Integrar conceitos em classificações práticas e síntese.",
                                  "commonMistakes": "Subestimar poder de CSLs ou errar gramáticas Type-1 (esquecer |β| ≥ |α|)."
                                }
                              ],
                              "practicalExample": "Dada a linguagem L = {a^n b^n c^n | n ≥ 1}, classifique-a como CSL (Type-1) porque não é context-free (falha em bomba de empilhamento para três símbolos), mas reconhecível por LBA que conta a's, b's e c's em espaço linear. Demonstre fechamento sob concatenação com {a^m b^m | m ≥ 1}, resultando em CSL.",
                              "finalVerifications": [
                                "Desenhar corretamente a hierarquia com CSLs como Type-1.",
                                "Explicar definição de CSL via gramática e LBA.",
                                "Listar fechamentos: sim para união/concatenação, não para complemento.",
                                "Classificar 3 linguagens exemplo precisamente.",
                                "Provar verbalmente um fechamento (ex: união).",
                                "Identificar erro comum em uma afirmação falsa sobre CSLs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na hierarquia: inclusões corretas (100%).",
                                "Compreensão de CSLs: definição e autômatos (90%+).",
                                "Análise de fechamento: provas ou contraexemplos válidos.",
                                "Uso de exemplos: relevantes e corretamente classificados.",
                                "Síntese: tabela ou diagrama claro e completo.",
                                "Profundidade: explicações além de memorização superficial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e hierarquias de inclusão.",
                                "Lógica: Propriedades algébricas semelhantes a grupos/anel.",
                                "Linguística: Analogia com níveis de complexidade sintática humana.",
                                "Inteligência Artificial: Modelos de parsing em NLP hierárquicos."
                              ],
                              "realWorldApplication": "Em compiladores avançados, CSLs modelam análises sintáticas complexas como verificação de tipos em linguagens com dependências contextuais (ex: Rust borrow checker), otimizando uso de memória linear em parsers para grandes códigos-fonte."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Gramáticas Tipo-1 (Context-Sensitive Grammars)",
                        "description": "Estudo das gramáticas sensíveis ao contexto, caracterizadas por regras de produção onde o lado esquerdo pode depender do contexto à esquerda e à direita, com restrição monotônica no comprimento.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Descrever regras de produção em gramáticas tipo-1",
                            "description": "Especificar a forma geral das regras αAβ → αγβ, onde A é não-terminal, γ ≠ ε, e |α| ≤ |γ| ≤ |α|, incluindo regras ε-produções apenas para S → ε se S não aparece no lado direito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os componentes básicos de uma gramática formal",
                                  "subSteps": [
                                    "Revise os quatro componentes de uma gramática formal G = (V, T, P, S): variáveis (não-terminais V), terminais T, regras de produção P e símbolo inicial S.",
                                    "Identifique que em gramáticas Tipo-1 (sensíveis ao contexto), as regras P têm forma restrita.",
                                    "Diferencie não-terminais (A ∈ V) de terminais e memorize que apenas não-terminais aparecem isolados no lado esquerdo das regras.",
                                    "Estude exemplos simples de gramáticas Tipo-0 para contrastar com restrições Tipo-1.",
                                    "Anote símbolos comuns: α e β como contextos (cadeias em (V ∪ T)*)."
                                  ],
                                  "verification": "Liste corretamente os 4 componentes de uma gramática e dê um exemplo de não-terminal vs. terminal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência: Livro 'Introduction to Automata Theory' de Hopcroft ou notas online sobre hierarquia de Chomsky"
                                  ],
                                  "tips": "Use diagramas para visualizar V, T, P, S; foque em P como o coração das gramáticas.",
                                  "learningObjective": "Compreender a estrutura fundamental de gramáticas formais antes de especializar em Tipo-1.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Esquecer o símbolo inicial S",
                                    "Ignorar que P é finito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar a forma geral das regras de produção Tipo-1",
                                  "subSteps": [
                                    "Aprenda a forma padrão: α A β → α γ β, onde A é um não-terminal único (A ∈ V), α, β ∈ (V ∪ T)*.",
                                    "Entenda que o contexto esquerdo α e direito β 'sentilizam' a produção de A.",
                                    "Pratique escrevendo a forma em notação matemática, destacando cada parte.",
                                    "Compare com regras Tipo-2 (CFG): em Tipo-1, contexto é obrigatório exceto em casos especiais.",
                                    "Crie 3 exemplos fictícios da forma α A β → α γ β."
                                  ],
                                  "verification": "Escreva 3 regras na forma exata α A β → α γ β com símbolos corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou editor de texto",
                                    "Vídeo tutorial sobre Chomsky Type-1 Grammars no YouTube"
                                  ],
                                  "tips": "Sempre isole A com espaços ou colchetes para visualizar o contexto claramente.",
                                  "learningObjective": "Dominar a sintaxe exata da regra geral de gramáticas sensíveis ao contexto.",
                                  "commonMistakes": [
                                    "Colocar mais de um não-terminal no lado esquerdo",
                                    "Usar terminais isolados no lugar de A",
                                    "Confundir ordem de α e β"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar as condições de comprimento e restrições em γ",
                                  "subSteps": [
                                    "Memorize: γ ≠ ε (γ é não-vazia, |γ| ≥ 1), e |α| ≤ |γ| ≤ |α| (condição de comprimento não-decrescente adaptada).",
                                    "Verifique em exemplos: o lado direito α γ β deve satisfazer a desigualdade de comprimentos.",
                                    "Calcule comprimentos: |LHS| = |α| + 1 + |β| ≤ |RHS| = |α| + |γ| + |β|.",
                                    "Pratique validando 5 regras: marque as que violam γ = ε ou comprimento.",
                                    "Discuta por que isso garante linguagens recursivamente enumeráveis."
                                  ],
                                  "verification": "Valide corretamente 5 regras dadas, identificando violações de γ ≠ ε ou |α| ≤ |γ| ≤ |α|.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou planilha para comprimentos",
                                    "Exercícios impressos de gramáticas Tipo-1"
                                  ],
                                  "tips": "Use |α|_L para comprimento de α; teste com α vazio para regras unitárias.",
                                  "learningObjective": "Aplicar precisamente as restrições matemáticas das regras Tipo-1.",
                                  "commonMistakes": [
                                    "Permitir γ = ε em regras gerais",
                                    "Confundir |α| ≤ |γ| com |γ| ≥ |α| +1",
                                    "Ignorar β no cálculo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar a exceção para produções ε do símbolo inicial",
                                  "subSteps": [
                                    "Aprenda a regra especial: S → ε é permitida apenas se S não aparece no lado direito de nenhuma regra.",
                                    "Verifique em uma gramática: escaneie todas as regras para confirmar ausência de S no RHS.",
                                    "Crie exemplos: uma gramática válida com S → ε e uma inválida.",
                                    "Explique o propósito: permite linguagens vazias sem violar não-decrescência.",
                                    "Integre à forma geral: mencione como exceção única."
                                  ],
                                  "verification": "Descreva uma gramática com S → ε válida e justifique por que é permitida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas de sites como GeeksforGeeks",
                                    "Notas pessoais"
                                  ],
                                  "tips": "Sempre cheque 'S no RHS' como checklist final para ε-produções.",
                                  "learningObjective": "Manejar corretamente a única exceção às regras Tipo-1.",
                                  "commonMistakes": [
                                    "Permitir S → ε quando S aparece em RHS",
                                    "Aplicar exceção a outros não-terminais",
                                    "Esquecer γ ≠ ε na regra geral"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar descrição completa de regras Tipo-1",
                                  "subSteps": [
                                    "Descreva verbalmente uma gramática Tipo-1: 'As regras seguem αAβ → αγβ com γ ≠ ε, |α| ≤ |γ| ≤ |α|, exceto S → ε se aplicável'.",
                                    "Construa uma gramática simples para {a^n b^n c^n} e liste regras.",
                                    "Autoavalie: leia em voz alta e compare com definição padrão.",
                                    "Resolva exercícios: converta regras Tipo-0 para Tipo-1 ou valide.",
                                    "Registre em um template para uso futuro."
                                  ],
                                  "verification": "Escreva uma descrição completa e precisa de regras Tipo-1 para uma gramática exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Template de descrição de gramática",
                                    "Ferramentas online como Grammar Simulator"
                                  ],
                                  "tips": "Use bullet points na descrição para clareza: forma, condições, exceção.",
                                  "learningObjective": "Sintetizar todo o conhecimento em uma descrição fluida e precisa.",
                                  "commonMistakes": [
                                    "Omitir condições de comprimento",
                                    "Não mencionar exceção explicitamente",
                                    "Descrever como Tipo-2 por engano"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a gramática G gerando {a^n b^n | n ≥ 1}: regras como a S b → a A b (α=a, A=S, β=b, γ=A), com |α|=1, |γ|=1 satisfazendo |α| ≤ |γ| ≤ |α|; sem S → ε pois S aparece em RHS.",
                              "finalVerifications": [
                                "Escreve corretamente a forma αAβ → αγβ.",
                                "Explica γ ≠ ε e valida |α| ≤ |γ| ≤ |α| em exemplos.",
                                "Identifica quando S → ε é permitida.",
                                "Lista todas restrições sem omissões.",
                                "Distingue de regras Tipo-2.",
                                "Valida uma gramática completa como Tipo-1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na forma geral da regra (100% match).",
                                "Correta inclusão e explicação de condições de comprimento.",
                                "Tratamento adequado da exceção ε-produção.",
                                "Uso correto de terminologia (não-terminal, contexto).",
                                "Exemplos práticos sem erros.",
                                "Clareza e completude na descrição.",
                                "Ausência de confusões com outros tipos de gramática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e relações em linguagens formais.",
                                "Lógica: Semântica de programação e verificação de propriedades.",
                                "Linguística: Análise sintática contextual em PNL.",
                                "Engenharia de Software: Parsers em compiladores para linguagens sensíveis ao contexto."
                              ],
                              "realWorldApplication": "Em compiladores avançados para linguagens com dependências contextuais (ex: COBOL antigo), processamento de DNA com contextos biológicos, ou verificadores de sistemas distribuídos onde regras de estado crescem não-decrescentemente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Verificar se uma gramática é tipo-1",
                            "description": "Analisar uma gramática dada e determinar se atende às restrições de comprimento e forma das regras tipo-1, identificando violações comuns como contrações (|β| > |α|).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal de gramática Tipo-1",
                                  "subSteps": [
                                    "Leia a definição de gramática sensível ao contexto (Tipo-1): regras da forma α → β onde |α| ≤ |β|, α contém pelo menos um não-terminal à esquerda.",
                                    "Identifique exceções: apenas a regra S → ε é permitida com |β| = 0.",
                                    "Anote os componentes da gramática: não-terminais (V_N), terminais (V_T), símbolo inicial (S), conjunto de regras (P).",
                                    "Liste violações comuns: regras com |α| > |β| (contrações), regras sem não-terminal no lado esquerdo, ou contexto inválido.",
                                    "Crie um checklist para verificação: forma da regra, comprimento, exceções."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases da definição e checklist em suas próprias palavras.",
                                  "estimatedTime": "15-20 minutes",
                                  "materials": [
                                    "Livro ou notas de teoria da computação (capítulo de linguagens formais)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Foquem na hierarquia de Chomsky: Tipo-1 é não-contratante, diferente de Tipo-0.",
                                  "learningObjective": "Compreender precisamente as restrições sintáticas e de comprimento das regras Tipo-1.",
                                  "commonMistakes": [
                                    "Confundir com regras Tipo-2 (lado esquerdo único NT)",
                                    "Ignorar a exceção S → ε",
                                    "Esquecer que contexto é permitido à esquerda e direita do NT"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a estrutura da gramática fornecida",
                                  "subSteps": [
                                    "Identifique todos os componentes: liste V_N, V_T, S e todas as regras P.",
                                    "Numere cada regra sequencialmente (ex: Regra 1: α1 → β1).",
                                    "Para cada regra, destaque o lado esquerdo (α) e direito (β).",
                                    "Marque o símbolo inicial S e verifique se alguma regra usa S → ε.",
                                    "Confirme se todas as regras estão na forma padrão (não regras Tipo-0 arbitrárias)."
                                  ],
                                  "verification": "Crie uma tabela com colunas: Regra #, α, |α|, β, |β|.",
                                  "estimatedTime": "10-15 minutes",
                                  "materials": [
                                    "Gramática dada (impressa ou digital)",
                                    "Planilha ou papel quadriculado para tabela"
                                  ],
                                  "tips": "Use símbolos para contar comprimentos: ignore ε como comprimento 0.",
                                  "learningObjective": "Extrair e organizar precisamente os elementos da gramática para análise.",
                                  "commonMistakes": [
                                    "Não contar corretamente |α| e |β| (inclua contexto)",
                                    "Omitir regras recursivas ou unitárias",
                                    "Confundir terminais com não-terminais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar o comprimento e forma de cada regra",
                                  "subSteps": [
                                    "Para cada regra (exceto S → ε): calcule |α| e |β|, verifique se |α| ≤ |β|.",
                                    "Confirme que α contém exatamente um não-terminal não-terminalizado (padrão αAβ → αγβ).",
                                    "Identifique violações: anote regras onde |α| > |β| ou forma inválida (ex: só terminais em α).",
                                    "Para regras com S: verifique se é S → ε ou cumpre |α| ≤ |β|.",
                                    "Classifique cada regra como 'válida' ou 'inválida' com justificativa.",
                                    "Conte o número total de violações."
                                  ],
                                  "verification": "Preencha a tabela do Step 2 com colunas 'Válida?', 'Motivo' e resuma violações.",
                                  "estimatedTime": "20-25 minutes",
                                  "materials": [
                                    "Tabela do Step 2",
                                    "Calculadora para contagens longas (opcional)"
                                  ],
                                  "tips": "Lembre: |α| é comprimento total de símbolos em α; γ deve ser não-vazio implicitamente.",
                                  "learningObjective": "Aplicar critérios de comprimento e forma para detectar violações sistematicamente.",
                                  "commonMistakes": [
                                    "Permitir |α| > |β| achando que é 'expansão'",
                                    "Ignorar contexto em regras como aAb → aXb",
                                    "Contar erradamente ε"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a classificação e documentar o resultado",
                                  "subSteps": [
                                    "Se zero violações: classifique como 'Tipo-1 válida'.",
                                    "Se qualquer violação: classifique como 'não Tipo-1', liste todas violações.",
                                    "Verifique consistência: todas regras usam símbolos definidos em V_N/V_T.",
                                    "Escreva uma conclusão: 'É Tipo-1? Sim/Não. Violações: [lista]'.",
                                    "Sugira correções para violações encontradas."
                                  ],
                                  "verification": "Produza um relatório final de 1 parágrafo com classificação e evidências.",
                                  "estimatedTime": "10 minutes",
                                  "materials": [
                                    "Tabelas e anotações anteriores"
                                  ],
                                  "tips": "Seja específico nas violações para aprendizado futuro.",
                                  "learningObjective": "Sintetizar análise em uma classificação definitiva com justificativa.",
                                  "commonMistakes": [
                                    "Classificar como válida apesar de uma violação",
                                    "Esquecer verificação de S → ε",
                                    "Não documentar motivos"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática G: V_N={S,A,B}, V_T={a,b}, S=S, P={S→aAB|ε, A→Aa|b, B→bB|c}. Verificação: Regra1 S→aAB: |aS|? Espera forma padrão. Na verdade, reescreva como padrões. Esta tem S→ε (ok), mas S→aAB é |S|=1 ≤ |aAB|=3 (ok), A→Aa: |A|=1 ≤ |Aa|=2 (ok), etc. É Tipo-1. Contra-exemplo violador: A→a ( |A|=1 > |a|=1? Não, = ok? Espera |α|≤|β|. Viola se B→ε sem ser S.",
                              "finalVerifications": [
                                "Todas regras listadas e numeradas corretamente.",
                                "Cálculos de |α| e |β| precisos para cada regra.",
                                "Nenhuma violação de comprimento (|α| > |β|) ignorada.",
                                "Exceção S → ε tratada corretamente.",
                                "Classificação final (Tipo-1 ou não) com lista de violações.",
                                "Relatório inclui justificativas explícitas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes da gramática (100%).",
                                "Correção em verificações de comprimento e forma (90-100%).",
                                "Completude: todas regras analisadas sem omissões (100%).",
                                "Clareza na documentação de violações e conclusão.",
                                "Uso correto da exceção para S → ε.",
                                "Detecção de erros comuns como regras unitárias inválidas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e contagem de strings.",
                                "Programação: Parsing e validação em compiladores (ex: ANTLR).",
                                "Lógica: Verificação formal similar a provas matemáticas.",
                                "Engenharia de Software: Modelagem de linguagens em ferramentas como YACC."
                              ],
                              "realWorldApplication": "Em compiladores e analisadores sintáticos, verificar se uma gramática é sensível ao contexto garante eficiência em parsing de linguagens de programação complexas como C++ ou linguagens naturais processadas em NLP, evitando regras não-terminantes ou ineficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Gerar derivadas em gramáticas CSG",
                            "description": "Aplicar regras de uma gramática sensível ao contexto para derivar palavras específicas, demonstrando derivações em contexto não-linear e monotônicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura e regras de uma Gramática Sensível ao Contexto (CSG)",
                                  "subSteps": [
                                    "Estude a definição formal de CSG: G = (V, Σ, P, S), onde P contém regras α → β com |α| ≤ |β| e α não vazio.",
                                    "Identifique os componentes: variáveis V, terminais Σ, axioma S e regras de produção P.",
                                    "Revise propriedades chave: derivações monotônicas (não contrativas) e dependência de contexto (regras aplicadas em substrings específicas).",
                                    "Diferencie CSG de CFG: CSG permite regras com contexto à esquerda ou direita.",
                                    "Examine exemplos simples de regras CSG, como aB → aC ou AB → a."
                                  ],
                                  "verification": "Liste os 4 componentes de uma CSG e dê um exemplo de regra válida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre linguagens formais",
                                    "Livro 'Introduction to Automata Theory' de Hopcroft",
                                    "Editor de texto para anotar regras"
                                  ],
                                  "tips": "Sempre verifique |β| >= |α| para validar regras; foque em monotonicidade para evitar contrações.",
                                  "learningObjective": "Dominar os elementos fundamentais de CSG e suas regras de produção.",
                                  "commonMistakes": [
                                    "Confundir CSG com CFG (permitir |β| < |α|)",
                                    "Ignorar contexto nas regras (tratar como regulares)",
                                    "Esquecer que S não aparece no lado direito de regras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e preparar a string inicial para derivação",
                                  "subSteps": [
                                    "Comece com o axioma S e escreva a string inicial.",
                                    "Analise a palavra-alvo w ∈ L(G) para planejar a sequência de regras necessárias.",
                                    "Marque posições possíveis de aplicação de regras, considerando contextos à esquerda/direita.",
                                    "Verifique se a derivação será monotônica: comprimento da string não diminui.",
                                    "Esboce um plano de derivação reverso (de w para S) para guiar os passos forward."
                                  ],
                                  "verification": "Dada uma CSG e w, escreva a string inicial e marque pelo menos uma posição de regra aplicável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Ferramenta online de simulação de gramáticas (ex: JFLAP)",
                                    "Exemplos de CSG do contexto curricular"
                                  ],
                                  "tips": "Use setas ↑ para marcar o contexto de aplicação da regra na string atual.",
                                  "learningObjective": "Preparar corretamente o ambiente para uma derivação passo a passo em CSG.",
                                  "commonMistakes": [
                                    "Começar derivação sem o axioma S",
                                    "Aplicar regras sem contexto exato (ex: ignorar símbolos adjacentes)",
                                    "Planejar sem considerar monotonicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar derivação passo a passo aplicando regras CSG",
                                  "subSteps": [
                                    "Escolha uma regra aplicável na posição marcada e substitua α por β.",
                                    "Escreva a nova string resultante, preservando o resto da sentença.",
                                    "Repita para a próxima posição, demonstrando dependência de contexto (não-linear se aplicável em múltiplos locais).",
                                    "Registre cada passo como: sentença_i ⇒ sentença_{i+1} via regra X.",
                                    "Continue até atingir a palavra-alvo w, garantindo exaustividade."
                                  ],
                                  "verification": "Gere uma derivação completa de S para uma w dada, com 3+ passos anotados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou editor para sequências de strings",
                                    "Exemplos resolvidos de derivações CSG",
                                    "Calculadora para contar comprimentos de strings"
                                  ],
                                  "tips": "Aplique regras da esquerda para direita quando possível, mas priorize contexto; numere cada sentença.",
                                  "learningObjective": "Aplicar regras CSG sequencialmente para gerar uma palavra específica.",
                                  "commonMistakes": [
                                    "Aplicar regra em contexto errado (ex: sem prefixo/sufixo exigido)",
                                    "Pular passos intermediários",
                                    "Gerar derivações não-monotônicas (reduzir comprimento)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e verificar a derivação completa, incluindo aspectos não-lineares e monotônicos",
                                  "subSteps": [
                                    "Confirme que todos os passos são monotônicos: |sentença_{i+1}| >= |sentença_i|.",
                                    "Identifique derivações não-lineares: aplicações em posições não-consecutivas ou paralelas.",
                                    "Verifique se w foi derivada corretamente sem ambiguidades desnecessárias.",
                                    "Discuta por que o contexto foi essencial em pelo menos um passo.",
                                    "Compare com derivação em CFG para destacar diferenças."
                                  ],
                                  "verification": "Explique monotonicidade e um exemplo de contexto não-linear na sua derivação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas de árvore de derivação (se aplicável)",
                                    "Referências sobre propriedades de CSG",
                                    "Fórum ou tutor para validação"
                                  ],
                                  "tips": "Use tabelas para listar passos: coluna para sentença, regra, posição; destaque contextos em negrito.",
                                  "learningObjective": "Analisar derivações CSG quanto a propriedades chave como monotonicidade e contexto não-linear.",
                                  "commonMistakes": [
                                    "Afirmar linearidade em derivações com contexto paralelo",
                                    "Ignorar verificação de comprimento monotônico",
                                    "Confundir não-linear com não-determinismo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar derivações complexas e generalizar o processo",
                                  "subSteps": [
                                    "Resolva 2-3 exercícios com CSG fornecidas e palavras-alvo variadas.",
                                    "Gere derivações para w com comprimentos maiores, testando contextos múltiplos.",
                                    "Experimente falhas: tente derivar w ∉ L(G) e explique por quê.",
                                    "Crie uma CSG simples e derive uma w personalizada.",
                                    "Documente padrões comuns em derivações CSG vs. outras gramáticas."
                                  ],
                                  "verification": "Derive corretamente 3 palavras em CSGs diferentes, com análise.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Banco de exercícios de linguagens formais",
                                    "Software JFLAP para simulação CSG",
                                    "Caderno de prática"
                                  ],
                                  "tips": "Tempo limite por exercício: 10 min; revise erros imediatamente para reforço.",
                                  "learningObjective": "Generalizar a geração de derivações em CSG para casos complexos.",
                                  "commonMistakes": [
                                    "Reutilizar derivações sem adaptar contexto",
                                    "Não testar limites (w longa ou com contexto profundo)",
                                    "Generalizar incorretamente para CSG não-monotônicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a CSG G para {a^n b^n c^n | n≥1}: S → aSBC | abc; aB → ab; bB → bb; bC → bc; cC → cc. Derive 'aabbcc': S ⇒ aSBC ⇒ aabcBC ⇒ aabbcC ⇒ aabbcc (mostrando contexto: B consome 'a', C consome 'b').",
                              "finalVerifications": [
                                "Pode derivar uma w dada em CSG com 4+ passos corretos?",
                                "Identifica corretamente contextos não-lineares em uma derivação?",
                                "Verifica monotonicidade em todas as sentenças intermediárias?",
                                "Explica por que uma regra não se aplica em certo contexto?",
                                "Gera uma derivação reversa de w para S?",
                                "Diferencia derivação CSG de CFG na prática?",
                                "Cria uma regra CSG válida para um contexto dado?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de regras com contexto exato (100% correto).",
                                "Número e detalhe de passos na derivação (mín. 3 passos documentados).",
                                "Demonstração clara de monotonicidade e não-linearidade.",
                                "Análise de erros comuns evitados na derivação.",
                                "Criatividade em exemplos práticos ou extensões.",
                                "Clareza na documentação (diagramas/tabelas usados).",
                                "Generalização para novas CSG (pelo menos 2 exemplos independentes)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Formal: Equações lineares e sistemas monotônicos em teoria de semigrupos.",
                                "Linguística Computacional: Modelagem de dependências sintáticas em PNL avançada.",
                                "Lógica e Prova: Demonstrações por indução em propriedades de linguagens.",
                                "Programação: Parsing bottom-up em compiladores com contextos (ex: Yacc com ações semânticas).",
                                "Inteligência Artificial: Geração de árvores de dependência em modelos de linguagem hierárquicos."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens como C++ ou Rust, CSG-like regras modelam dependências contextuais (ex: templates genéricos ou macros), permitindo parsers que geram código derivado monotonicamente de declarações iniciais, essencial para análise semântica e otimização."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Reconhecimento por Máquinas Lineares Limitadas",
                        "description": "Modelos de computação equivalentes às linguagens sensíveis ao contexto, especificamente as Máquinas de Turing com fita limitada ao tamanho da entrada (LBAs).",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Definir Máquinas Lineares Limitadas (LBA)",
                            "description": "Descrever formalmente uma LBA como um não-determinístico TM onde a fita é limitada a O(n) células para entrada de tamanho n, com endmarkers definindo os limites.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Máquinas de Turing Não-Determinísticas (NTM)",
                                  "subSteps": [
                                    "Estude a definição formal de uma NTM como uma 7-tupla (Q, Σ, Γ, δ, q0, B, F).",
                                    "Entenda o funcionamento não-determinístico: múltiplas transições possíveis de um estado.",
                                    "Revise o conceito de fita infinita em ambas as direções em uma NTM padrão.",
                                    "Pratique desenhando o diagrama de uma NTM simples para reconhecimento de palíndromos.",
                                    "Compare NTM com TM determinística, destacando equivalência de poder computacional."
                                  ],
                                  "verification": "Desenhe e simule manualmente uma NTM para uma linguagem simples, confirmando aceitação/rejeição.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 7)",
                                    "Papel e lápis para diagramas",
                                    "Simulador online de TM (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": "Comece com exemplos simples para fixar a não-determinização antes de limitar a fita.",
                                  "learningObjective": "Compreender os componentes e o comportamento de uma NTM como base para LBA.",
                                  "commonMistakes": [
                                    "Confundir não-determinismo com paralelismo real",
                                    "Esquecer que NTM aceita por aceitação em pelo menos um caminho"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Limitações na Fita da TM",
                                  "subSteps": [
                                    "Defina fita limitada: para entrada de tamanho n, fita tem O(n) células (ex: 2n+2 com endmarkers).",
                                    "Explique endmarkers ¢ (esquerda) e $ (direita) que delimitam a fita ativa.",
                                    "Discuta que a cabeça não pode ultrapassar os endmarkers, simulando memória finita linear.",
                                    "Calcule o tamanho exato: tipicamente n + k células, onde k é constante para endmarkers e trabalho auxiliar.",
                                    "Simule uma TM com fita limitada rejeitando entradas que tentem expandir além dos limites."
                                  ],
                                  "verification": "Modifique uma NTM padrão adicionando endmarkers e verifique se ela para ao tentar sair dos limites.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas sobre TM de aula",
                                    "Ferramenta de desenho como Draw.io para diagramas de fita",
                                    "Exemplos de linguagens CSL"
                                  ],
                                  "tips": "Visualize a fita como um array finito para facilitar a compreensão.",
                                  "learningObjective": "Dominar o conceito de fita linearmente limitada e seu impacto no modelo computacional.",
                                  "commonMistakes": [
                                    "Assumir fita infinita mesmo com endmarkers",
                                    "Confundir O(n) com fita fixa de tamanho n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Definição de Máquina Linearmente Limitada (LBA)",
                                  "subSteps": [
                                    "Defina LBA como 7-tupla (Q, Σ, Γ, δ, q0, ¢, $, F), onde δ inclui transições que respeitam endmarkers.",
                                    "Especifique que δ: Q × Γ → finito subconjunto de Q × Γ × {L, R}, mas cabeça para se endmarker bloqueia movimento.",
                                    "Descreva configuração inicial: ¢ w $ com cabeça em q0 sobre primeiro símbolo de w.",
                                    "Explique aceitação: entra em estado final sem rejeitar ou loop infinito dentro da fita limitada.",
                                    "Escreva a definição matemática completa, destacando não-determinismo e limitação O(n)."
                                  ],
                                  "verification": "Escreva a tupla formal de uma LBA exemplo e valide contra a definição padrão.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Referência: Hopcroft & Ullman 'Introduction to Automata Theory' (cap. 10)",
                                    "Editor de texto para fórmulas LaTeX",
                                    "Quadro branco para escrita formal"
                                  ],
                                  "tips": "Use notação precisa: mencione explicitamente os endmarkers na tupla.",
                                  "learningObjective": "Capacitar a descrição formal precisa de uma LBA.",
                                  "commonMistakes": [
                                    "Omitir endmarkers na tupla",
                                    "Confundir LBA com PDA ou TM ilimitada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Propriedades e Exemplos de LBA",
                                  "subSteps": [
                                    "Discuta classe de linguagens: CSL = NSPACE(O(n)), equivalente a linguagens aceitas por LBA.",
                                    "Construa exemplo: LBA para {a^n b^n c^n | n ≥ 1}, usando fita para marcar símbolos.",
                                    "Analise por que LBAs são mais poderosas que PDA mas menos que TM.",
                                    "Simule rejeição por overflow de fita em linguagens não-CSL.",
                                    "Compare determinística vs não-determinística LBA (DLBA ⊂ LBA)."
                                  ],
                                  "verification": "Construa e simule uma LBA para uma linguagem CSL conhecida, confirmando corretude.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulador de LBA online ou JFLAP",
                                    "Exemplos de linguagens CSL de repositórios acadêmicos"
                                  ],
                                  "tips": "Teste com entradas pequenas (n=1,2,3) para depurar simulações.",
                                  "learningObjective": "Aplicar a definição de LBA em contextos práticos e entender seu poder.",
                                  "commonMistakes": [
                                    "Ignorar loops infinitos em não-determinismo",
                                    "Confundir aceitação com halting sempre"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina formalmente uma LBA M que reconhece L = {ww^R | w ∈ {0,1}*}, onde w^R é o reverso de w. Tupla: (Q={q0,q1,qf,qrej}, Σ={0,1}, Γ={0,1,B}, δ com transições para copiar w para trás da fita usando os espaços O(n), comparando com w^R, aceitando em qf se match.",
                              "finalVerifications": [
                                "Descreva corretamente a 7-tupla de uma LBA, incluindo endmarkers.",
                                "Explique como a fita O(n) é implementada com ¢ e $.",
                                "Diferencie LBA de NTM e PDA em termos de poder e limitações.",
                                "Simule uma LBA simples sem erros de overflow.",
                                "Identifique linguagens CSL vs não-CSL baseadas em LBA.",
                                "Escreva δ para uma transição que respeita limites da fita."
                              ],
                              "assessmentCriteria": [
                                "Precisão na tupla formal (todos componentes corretos).",
                                "Compreensão clara da limitação O(n) e endmarkers.",
                                "Capacidade de simular execuções sem erros conceituais.",
                                "Correta distinção entre modelos de autômatos relacionados.",
                                "Uso apropriado de notação matemática e exemplos.",
                                "Identificação de propriedades como NSPACE(O(n))."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Relações de Equivalência (classes de linguagens).",
                                "Lógica: Autômatos e Teorema de Rice para propriedades indecidíveis.",
                                "Engenharia de Software: Modelagem de parsers LL/LR com memória linear.",
                                "Física Computacional: Modelos de computação quântica com qubits limitados."
                              ],
                              "realWorldApplication": "LBAs modelam algoritmos com memória auxiliar linear, essenciais em análise de complexidade para dispositivos embarcados (IoT), compiladores com parsing sensível ao contexto e verificação de software com recursos limitados, como em satélites ou wearables."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Explicar o poder de reconhecimento de LBAs",
                            "description": "Demonstrar que LBAs reconhecem exatamente as linguagens sensíveis ao contexto, provando inclusão e equivalência via simulações de gramáticas tipo-1 em LBAs e vice-versa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de LBAs e Linguagens Sensíveis ao Contexto (CSLs)",
                                  "subSteps": [
                                    "Defina Linear Bounded Automaton (LBA) como um autômato de Turing com fita limitada ao tamanho da entrada.",
                                    "Explique Context-Sensitive Languages (CSLs) como linguagens geradas por gramáticas tipo-1 na hierarquia de Chomsky.",
                                    "Compare LBAs com autômatos de Turing padrão e pushdown automata.",
                                    "Revise exemplos clássicos de CSLs, como {a^n b^n c^n | n ≥ 1}.",
                                    "Discuta a hipótese de que LBAs reconhecem exatamente CSLs."
                                  ],
                                  "verification": "Escreva definições precisas e um diagrama esquemático de um LBA.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introduction to Automata Theory' de Hopcroft e Ullman; simulador online de autômatos (ex: JFLAP).",
                                  "tips": "Use diagramas para visualizar a fita limitada do LBA.",
                                  "learningObjective": "Compreender as definições formais e diferenças entre LBAs e outros autômatos.",
                                  "commonMistakes": "Confundir limite de fita de LBA com nondeterminismo irrestrito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar Inclusão: Toda CSL é Reconhecida por um LBA",
                                  "subSteps": [
                                    "Descreva a construção de um LBA que simula uma gramática tipo-1 G.",
                                    "Explique como o LBA marca posições na fita para simular derivações de sentenças.",
                                    "Detalhe o processo de aplicação de regras de produção sem exceder o espaço da entrada.",
                                    "Implemente uma simulação passo a passo para uma gramática simples CSL.",
                                    "Verifique que o LBA aceita se e somente se a string pertence à L(G)."
                                  ],
                                  "verification": "Construa um LBA para uma gramática tipo-1 dada e teste com entradas válidas/inválidas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis para desenhar transições; software JFLAP ou Turing Machine Simulator.",
                                  "tips": "Comece com gramáticas não-contrativas para evitar loops infinitos.",
                                  "learningObjective": "Dominar a simulação de gramáticas tipo-1 em LBAs.",
                                  "commonMistakes": "Ignorar o limite de fita ao simular expansões de não-terminais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar Equivalência: Toda Linguagem de LBA é uma CSL",
                                  "subSteps": [
                                    "Construa uma gramática tipo-1 que simule as configurações de um LBA.",
                                    "Defina não-terminais para estados, símbolos de fita e posições da cabeça de leitura.",
                                    "Descreva regras que geram todas as sequências de configurações aceitas pelo LBA.",
                                    "Garanta que a gramática só gere strings na linguagem do LBA via simulação exaustiva.",
                                    "Prove que a construção preserva aceitação usando indução em configurações."
                                  ],
                                  "verification": "Escreva a gramática tipo-1 para um LBA simples e gere uma sentença de exemplo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Folhas de cálculo para rastrear configurações; referência 'Theory of Computation' de Sipser.",
                                  "tips": "Use marcadores auxiliares para rastrear a cabeça de leitura na gramática.",
                                  "learningObjective": "Aprender a construir gramáticas tipo-1 a partir de LBAs.",
                                  "commonMistakes": "Permitir contrações na gramática que violem regras tipo-1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Exemplos, Limitações e Teorema Completo",
                                  "subSteps": [
                                    "Aplique as provas a um exemplo concreto como {ww | w ∈ {a,b}*}.",
                                    "Discuta por que LBAs não reconhecem todas as linguagens recursivas.",
                                    "Enuncie o teorema: L(LBA) = CSLs (decidibilidade de aceitação é em aberto).",
                                    "Compare com PDAs e TMs em termos de poder expressivo.",
                                    "Resolva exercícios de simulação mútua."
                                  ],
                                  "verification": "Resolva 3 problemas de prova de inclusão/equivalência com exemplos fornecidos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Exercícios de livros texto; quadro branco para discussões.",
                                  "tips": "Teste simulações com strings curtas primeiro para depuração.",
                                  "learningObjective": "Integrar provas em exemplos e entender implicações.",
                                  "commonMistakes": "Confundir CSLs com linguagens livres de contexto."
                                }
                              ],
                              "practicalExample": "Para a CSL {a^n b^n c^n | n ≥ 1}, construa um LBA que verifica contagens iguais usando marcadores na fita limitada, simulando uma gramática tipo-1 que gera a linguagem via derivações controladas.",
                              "finalVerifications": [
                                "O aluno define corretamente LBA e CSL.",
                                "Constrói LBA simulando gramática tipo-1 para um exemplo dado.",
                                "Gera gramática tipo-1 a partir de LBA simples.",
                                "Explica simulações sem violar limites de fita.",
                                "Enuncia teorema de equivalência com justificativa.",
                                "Identifica exemplo CSL não-CFL reconhecido por LBA."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e construções formais (30%).",
                                "Correção das provas de inclusão e equivalência (40%).",
                                "Qualidade de exemplos e simulações práticas (15%).",
                                "Compreensão de limitações e teoremas relacionados (10%).",
                                "Clareza na explicação oral/escrita (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e indução em provas de equivalência.",
                                "Lógica: Simulações como provas de correção em lógica computacional.",
                                "Programação: Parsers context-sensitive em compiladores avançados.",
                                "Filosofia da Computação: Limites da computação efetiva."
                              ],
                              "realWorldApplication": "Em verificação formal de software e hardware, LBAs modelam analisadores sintáticos para linguagens com dependências contextuais, como em processadores de configuração de sistemas embarcados ou validação de protocolos de rede sensíveis ao contexto."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1",
                              "10.1.3.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Comparar LBAs com outros autômatos",
                            "description": "Diferenciar LBAs de PDAs (mais fracas) e TMs irrestritas (mais poderosas), destacando decidibilidade do problema de aceitação para LBAs como indecidível.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de LBAs, PDAs e TMs",
                                  "subSteps": [
                                    "Defina PDA: autômato com pilha, reconhece linguagens livres de contexto (CFLs).",
                                    "Defina LBA: autômato de Turing com fita limitada ao tamanho da entrada, reconhece linguagens sensíveis ao contexto (CSLs).",
                                    "Defina TM irrestrita: fita infinita, reconhece linguagens recursivamente enumeráveis (RE).",
                                    "Liste componentes comuns: estados, alfabeto, transições, fita.",
                                    "Compare restrições de fita: PDA (pilha ilimitada), LBA (limitada ao input), TM (ilimitada)."
                                  ],
                                  "verification": "Crie um diagrama ou tabela resumindo definições e componentes de cada autômato.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser ou similar), papel e caneta para diagramas, acesso a slides ou vídeos introdutórios.",
                                  "tips": "Use mnemônicos como 'PDA-Pilha', 'LBA-Limitada', 'TM-Tudo' para fixar diferenças.",
                                  "learningObjective": "Entender as definições precisas e componentes para estabelecer base de comparação.",
                                  "commonMistakes": "Confundir pilha de PDA com fita limitada de LBA; achar que LBA tem fita infinita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar Poder de Reconhecimento de Linguagens",
                                  "subSteps": [
                                    "Identifique hierarquia: CFLs ⊂ CSLs ⊂ REs.",
                                    "Exemplo PDA não aceita: {a^n b^n c^n | n ≥ 1} (requer contagem em ambos sentidos).",
                                    "Exemplo LBA aceita o acima, mas não halting problem languages.",
                                    "Exemplo só TM aceita: linguagens como halting problem.",
                                    "Crie tabela de inclusão: PDA < LBA < TM."
                                  ],
                                  "verification": "Liste 2 linguagens para cada autômato e justifique por que não são reconhecidas pelos mais fracos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de exemplos de linguagens, simulador de autômatos online (JFLAP).",
                                  "tips": "Visualize com diagramas de Venn para hierarquia de linguagens.",
                                  "learningObjective": "Dominar a hierarquia de classes de linguagens reconhecidas por cada autômato.",
                                  "commonMistakes": "Achar que PDA reconhece CSLs; ignorar que LBA é determinístico para CSLs."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Decidibilidade do Problema de Aceitação",
                                  "subSteps": [
                                    "Defina problema de aceitação: dada LBA M e string w, M aceita w?",
                                    "Explique decidibilidade para PDA: decidível (empty stack).",
                                    "Para LBA: indecidível (redução ao PCP ou teorema de Rice para CSLs).",
                                    "Para TM: indecidível (halting problem).",
                                    "Discuta implicações: LBA mais poderoso que PDA, mas ainda indecidível."
                                  ],
                                  "verification": "Escreva prova esboçada de indecidibilidade para LBA usando redução.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Artigo ou capítulo sobre decidibilidade (Hopcroft/Ullman), quadro branco.",
                                  "tips": "Lembre: decidível se algoritmo sempre para e responde sim/não.",
                                  "learningObjective": "Compreender por que aceitação é indecidível para LBA apesar da fita limitada.",
                                  "commonMistakes": "Confundir aceitação com vazio de linguagem; achar decidível por fita finita."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Comparação com Tabela e Exemplos Práticos",
                                  "subSteps": [
                                    "Construa tabela comparativa: colunas para PDA, LBA, TM (poder, fita, decidibilidade).",
                                    "Inclua exemplos concretos: ww (PDA sim), a^n b^n c^n (LBA sim), halting (TM sim).",
                                    "Discuta equivalências: LBA ≡ nondet TM com fita limitada.",
                                    "Resuma forças/fraquezas: PDA eficiente, LBA realista para memória, TM teórico.",
                                    "Teste compreensão com perguntas autoavaliativas."
                                  ],
                                  "verification": "Apresente tabela e responda 3 perguntas sobre diferenças chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel/Google Sheets para tabela, exemplos impressos.",
                                  "tips": "Use cores na tabela: verde para 'sim', vermelho para 'não'.",
                                  "learningObjective": "Integrar conhecimentos em uma visão comparativa coesa.",
                                  "commonMistakes": "Omitir decidibilidade na tabela; exemplos incorretos de linguagens."
                                }
                              ],
                              "practicalExample": "Considere a linguagem L = {a^n b^n c^n | n ≥ 1}. Um PDA não pode aceitá-la pois precisa contar três símbolos simultaneamente sem memória suficiente. Um LBA aceita marcando a fita input com símbolos auxiliares dentro do limite. Uma TM aceita facilmente com fita extra, mas o problema 'dado LBA M, aceita M todas as strings de L?' é indecidível.",
                              "finalVerifications": [
                                "Explicar corretamente a hierarquia CFL ⊂ CSL ⊂ RE.",
                                "Identificar pelo menos um exemplo de linguagem reconhecida por LBA mas não PDA.",
                                "Descrever por que aceitação é indecidível para LBAs.",
                                "Preencher tabela comparativa sem erros.",
                                "Comparar restrições de fita com precisão.",
                                "Discutir implicações para computação real."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas definições e hierarquias (30%).",
                                "Qualidade e correção de exemplos de linguagens (25%).",
                                "Explicação clara de indecidibilidade com redução (20%).",
                                "Completude da tabela comparativa (15%).",
                                "Profundidade nas verificações e conexões (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e hierarquias de Chomsky.",
                                "Lógica: Reduções e teoremas de indecidibilidade (Gödel).",
                                "Programação: Simuladores de autômatos em Python/Java.",
                                "Engenharia de Software: Limites de memória em verificadores formais."
                              ],
                              "realWorldApplication": "Em compiladores e verificadores de software, LBAs modelam análises com memória limitada (ex: análise estática em linguagens com restrições de tape), ajudando a entender por que certos bugs são indecidíveis de detectar automaticamente, guiando designs de ferramentas como linters com limites práticos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Linguagens Tipo-0",
                    "description": "Gramáticas irrestritas, linguagens recursivamente enumeráveis e relação com máquinas de Turing.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Gramáticas Irrestritas (Tipo-0)",
                        "description": "Definição formal de gramáticas irrestritas, suas regras de produção sem restrições e capacidade de gerar as linguagens mais poderosas na hierarquia de Chomsky.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Definir uma gramática irrestrita",
                            "description": "Identificar e formalizar os componentes de uma gramática tipo-0 (V, Σ, P, S), reconhecendo que as produções têm a forma α → β onde α e β são cadeias arbitrárias com pelo menos uma variável em α.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes fundamentais de uma gramática formal",
                                  "subSteps": [
                                    "Revise a hierarquia de Chomsky e posicione as gramáticas tipo-0 como irrestritas.",
                                    "Defina V (conjunto de variáveis ou não-terminais).",
                                    "Defina Σ (alfabeto terminal ou símbolos terminais).",
                                    "Identifique S como o símbolo inicial (pertence a V).",
                                    "Entenda P como conjunto de produções."
                                  ],
                                  "verification": "Liste corretamente os quatro componentes (V, Σ, P, S) com suas descrições em um papel.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro ou notas sobre teoria da computação (capítulo de linguagens formais)",
                                    "Acesso online a definições de gramáticas de Chomsky"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar V e Σ como conjuntos disjuntos.",
                                  "learningObjective": "Ao final deste passo, você será capaz de descrever os quatro componentes básicos de qualquer gramática formal.",
                                  "commonMistakes": [
                                    "Confundir terminais (Σ) com variáveis (V)",
                                    "Esquecer que S deve estar em V",
                                    "Achar que P é apenas uma lista de regras sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar as características específicas das gramáticas tipo-0 (irrestritas)",
                                  "subSteps": [
                                    "Aprenda que produções têm forma α → β, onde α e β são cadeias arbitrárias sobre V ∪ Σ.",
                                    "Identifique a restrição: α deve conter pelo menos uma variável (de V).",
                                    "Compare com tipos inferiores: tipo-0 permite α com múltiplos símbolos e contexto.",
                                    "Reconheça que tipo-0 gera linguagens recursivamente enumeráveis.",
                                    "Anote exemplos de produções válidas vs. inválidas."
                                  ],
                                  "verification": "Escreva 3 produções válidas e 2 inválidas para tipo-0, justificando cada uma.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de gramáticas da hierarquia de Chomsky online",
                                    "Simulador ou editor de texto para testar produções"
                                  ],
                                  "tips": "Lembre-se: β pode ser vazia (ε), mas α nunca é apenas terminais.",
                                  "learningObjective": "Ao final deste passo, você entenderá precisamente a forma das produções em gramáticas irrestritas.",
                                  "commonMistakes": [
                                    "Permitir α sem variáveis (isso seria inválido)",
                                    "Confundir com tipo-3 (regulares, apenas A → aB ou A → a)",
                                    "Ignorar que β pode ter variáveis e terminais misturados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar os componentes V, Σ, P e S para uma gramática irrestrita",
                                  "subSteps": [
                                    "Escolha um alfabeto terminal Σ simples, ex: {a, b}.",
                                    "Defina V com símbolos iniciais e auxiliares, ex: {S, A}.",
                                    "Especifique S como o símbolo de partida.",
                                    "Construa P com pelo menos 3-5 produções na forma α → β válida.",
                                    "Garanta que as produções respeitem a regra de α ter pelo menos uma variável."
                                  ],
                                  "verification": "Descreva V, Σ, P e S em notação formal, verificando disjuntividade de V e Σ.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta de LaTeX ou editor de texto para notação formal",
                                    "Referências de exemplos de gramáticas tipo-0"
                                  ],
                                  "tips": "Comece com produções simples e adicione contexto para demonstrar poder irrestrito.",
                                  "learningObjective": "Ao final deste passo, você será capaz de formalizar individualmente cada componente de uma gramática tipo-0.",
                                  "commonMistakes": [
                                    "Incluir terminais em V",
                                    "Produções onde α é só terminais",
                                    "Esquecer de especificar S explicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e validar uma gramática irrestrita completa",
                                  "subSteps": [
                                    "Combine V, Σ, P e S em uma definição G = (V, Σ, P, S).",
                                    "Derive pelo menos duas strings a partir de S usando as produções.",
                                    "Verifique se todas produções cumprem regras tipo-0.",
                                    "Teste se a gramática gera uma linguagem não gerável por tipos inferiores (opcional).",
                                    "Documente a gramática em formato padrão."
                                  ],
                                  "verification": "Gere uma derivação de uma string específica e confirme validade das regras.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Árvore de derivação impressa ou desenhada",
                                    "Software como JFLAP para simulação de gramáticas"
                                  ],
                                  "tips": "Use setas para mostrar derivações passo a passo: S ⇒ α ⇒ β.",
                                  "learningObjective": "Ao final deste passo, você definirá e validará uma gramática irrestrita completa.",
                                  "commonMistakes": [
                                    "Produções que violam a restrição de variáveis em α",
                                    "Derivações infinitas sem término",
                                    "Não especificar a linguagem gerada implicitamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina G = (V, Σ, P, S) onde V = {S, A}, Σ = {a, b}, S = S, P = {S → aA, aA → Ab, Ab → b}. Esta gramática gera {a^n b^n | n ≥ 1}, com derivações como S ⇒ aA ⇒ aAb ⇒ ab para n=2, demonstrando produções com contexto (aA → Ab).",
                              "finalVerifications": [
                                "Liste corretamente V, Σ, P e S para uma gramática dada.",
                                "Identifique se uma produção dada é válida para tipo-0.",
                                "Construa uma derivação de 4 passos a partir de S.",
                                "Explique por que α deve ter pelo menos uma variável.",
                                "Compare com uma gramática tipo-1 (sensível ao contexto).",
                                "Valide uma gramática irrestrita exemplo fornecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição dos quatro componentes (V, Σ, P, S).",
                                "Correção na forma das produções (α com variável, β arbitrário).",
                                "Capacidade de derivar strings válidas.",
                                "Uso correto de notação formal.",
                                "Identificação de erros em produções inválidas.",
                                "Compreensão do poder expressivo tipo-0."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e relações recursivas.",
                                "Linguística: Modelagem de estruturas sintáticas naturais.",
                                "Programação: Fundamentos de parsers e analisadores léxicos em compiladores.",
                                "Lógica: Sistemas axiomáticos e provas formais.",
                                "Filosofia da Computação: Limites da computabilidade (máquinas de Turing)."
                              ],
                              "realWorldApplication": "Gramáticas irrestritas formam a base teórica para máquinas de Turing, usadas em verificação formal de software, design de linguagens de programação e análise de sistemas computáveis em IA e compiladores avançados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Reconhecer produções válidas em gramáticas tipo-0",
                            "description": "Diferenciar produções de gramáticas tipo-0 de tipos inferiores, analisando exemplos como {S → aSb | ε} e verificando a ausência de restrições de comprimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal de Gramáticas Tipo-0",
                                  "subSteps": [
                                    "Estude a hierarquia de Chomsky e localize as gramáticas tipo-0 como irrestritas.",
                                    "Leia a definição: Uma gramática tipo-0 G = (V, Σ, P, S) onde P contém regras α → β com α ∈ V+ (contém pelo menos um não-terminal).",
                                    "Anote exemplos de símbolos terminais (Σ) e não-terminais (V - Σ).",
                                    "Identifique que não há restrições em comprimento ou forma além da presença de não-terminal em α.",
                                    "Revise notação padrão como S → ε sendo permitida."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição completa de uma gramática tipo-0 sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Notas sobre Hierarquia de Chomsky",
                                    "Quadro branco para diagramas"
                                  ],
                                  "tips": "Use diagramas para visualizar a hierarquia: Tipo-3 > Tipo-2 > Tipo-1 > Tipo-0.",
                                  "learningObjective": "Dominar os componentes e ausência de restrições nas gramáticas tipo-0.",
                                  "commonMistakes": [
                                    "Confundir com tipo-1, assumindo restrição |α| >= |β|.",
                                    "Esquecer que α deve ter pelo menos um não-terminal."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a forma geral de produções válidas em Tipo-0",
                                  "subSteps": [
                                    "Analise a regra geral: α → β, onde α é string não-vazia com ≥1 não-terminal, β qualquer string.",
                                    "Classifique símbolos: não-terminais maiúsculos (ex: S, A), terminais minúsculos (ex: a, b).",
                                    "Verifique exemplos válidos: S → aSb, AB → ε, X → YZ.",
                                    "Diferencie de ε-produções em context-free (válidas aqui também).",
                                    "Pratique reescrevendo regras inválidas para torná-las tipo-0."
                                  ],
                                  "verification": "Liste 5 produções e classifique cada uma como válida para tipo-0, justificando.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de exercícios com produções exemplo",
                                    "Ferramenta online de gramáticas formais",
                                    "Caneta e papel"
                                  ],
                                  "tips": "Lembre: qualquer coisa vai, desde que lado esquerdo tenha não-terminal.",
                                  "learningObjective": "Reconhecer instantaneamente a validade sintática de uma produção tipo-0.",
                                  "commonMistakes": [
                                    "Pensar que β deve ser mais curto (restrição tipo-1).",
                                    "Aceitar regras sem não-terminal no LHS como a → b."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar produções Tipo-0 com tipos inferiores",
                                  "subSteps": [
                                    "Revise tipo-3: A → a ou A → aB (linear direita).",
                                    "Tipo-2: A → γ (A único não-terminal à esquerda).",
                                    "Tipo-1: |α| >= |β| para α → β (α com ≥1 não-terminal).",
                                    "Compare: {S → aSb | ε} é tipo-2, mas válida em tipo-0 sem restrição de comprimento.",
                                    "Crie tabela comparativa de restrições para cada tipo."
                                  ],
                                  "verification": "Dada uma produção, identifique o tipo mais restrito possível e explique por que é/ não é tipo-0.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela comparativa impressa",
                                    "Vídeo tutorial sobre Hierarquia de Chomsky",
                                    "Planilha Excel para tabela"
                                  ],
                                  "tips": "Pense em 'Tipo-0 permite tudo que os outros permitem + mais'.",
                                  "learningObjective": "Diferenciar produções por restrições de cada nível da hierarquia.",
                                  "commonMistakes": [
                                    "Confundir tipo-0 com recursivamente enumeráveis sem contexto.",
                                    "Ignorar que tipo-0 permite contrações |β| > |α|."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar exemplos e verificar ausência de restrições",
                                  "subSteps": [
                                    "Pegue exemplo {S → aSb | ε}: valide como tipo-0 (sem restrição comprimento).",
                                    "Teste produções inválidas: a → b (sem não-terminal LHS), corrija para A → b.",
                                    "Analise 3 exemplos complexos: AA → BBB, S → a, XY → ε.",
                                    "Simule derivações curtas para confirmar poder expressivo.",
                                    "Crie sua própria gramática tipo-0 com 3 produções."
                                  ],
                                  "verification": "Analise 4 produções dadas e classifique corretamente todas como tipo-0 ou não.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Lista de 10 exemplos de produções",
                                    "Simulador de gramáticas online",
                                    "Caderno de exercícios"
                                  ],
                                  "tips": "Sempre cheque LHS por não-terminal primeiro.",
                                  "learningObjective": "Aplicar conhecimento para validar produções reais em contexto.",
                                  "commonMistakes": [
                                    "Aplicar regras tipo-1 desnecessariamente.",
                                    "Confundir ε com produção inválida."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise a produção 'AB → aC' em G = ({S,A,B,C}, {a}, P, S). É válida tipo-0? Sim, pois LHS 'AB' tem não-terminais A e B, RHS 'aC' é qualquer string, sem restrições de comprimento ou contexto como em tipos inferiores.",
                              "finalVerifications": [
                                "Classifique corretamente 5 produções como tipo-0 ou não.",
                                "Explique diferença entre tipo-0 e tipo-1 sem erros.",
                                "Identifique violação em produção inválida como 'a → b'.",
                                "Crie uma produção tipo-0 que viole tipo-1 (|β| > |α|).",
                                "Descreva hierarquia e posição do tipo-0.",
                                "Valide exemplo {S → aSb | ε} para todos os tipos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de não-terminal no LHS (100%).",
                                "Correta diferenciação de restrições por tipo (90%+).",
                                "Justificativas claras e concisas para cada análise.",
                                "Capacidade de criar exemplos originais válidos.",
                                "Compreensão de ausência de limites em tipo-0.",
                                "Análise de pelo menos 80% dos exemplos sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e relações em linguagens formais.",
                                "Lógica: Provas de validade semelhantes a teoremas lógicos.",
                                "Programação: Parsing em compiladores usa conceitos semelhantes.",
                                "Filosofia: Modelos computacionais e limites da computação.",
                                "Engenharia de Software: Especificação formal de linguagens."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, gramáticas tipo-0 modelam linguagens de programação completas (Turing-completas), permitindo análise de sintaxe sem restrições artificiais, usadas em ferramentas como Yacc/Bison para parsers irrestritos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Gerar linguagens com gramáticas irrestritas",
                            "description": "Construir derivações em gramáticas tipo-0 para gerar palavras específicas, demonstrando a geração de linguagens recursivamente enumeráveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Gramáticas Irrestritas (Tipo-0)",
                                  "subSteps": [
                                    "Revise a hierarquia de Chomsky: identifique que gramáticas Tipo-0 são as mais poderosas, gerando linguagens recursivamente enumeráveis (RE).",
                                    "Estude a definição formal: G = (V, Σ, P, S), onde regras são α → β com α contendo pelo menos um não-terminal à esquerda.",
                                    "Compare com tipos inferiores: note que não há restrições de comprimento em α ou β.",
                                    "Analise exemplos simples: veja como elas simulam máquinas de Turing.",
                                    "Identifique propriedades chave: RE mas não necessariamente decidíveis."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre Tipo-0 e Tipo-1, com um exemplo de regra exclusiva de Tipo-0.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Cap. 5)",
                                    "Wikipedia: Unrestricted grammar",
                                    "Notas de aula sobre Automata"
                                  ],
                                  "tips": "Use diagramas para visualizar a hierarquia de Chomsky; memorize que Tipo-0 ≡ RE.",
                                  "learningObjective": "Dominar a definição e propriedades de gramáticas irrestritas.",
                                  "commonMistakes": [
                                    "Confundir com gramáticas livres de contexto (ignorar regras com |α| >1 NT)",
                                    "Achar que todas RE são geráveis por Tipo-1",
                                    "Esquecer a exigência de NT em α"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir uma Gramática Tipo-0 para uma Linguagem Recursivamente Enumerável",
                                  "subSteps": [
                                    "Escolha uma linguagem RE simples, como L = {a^n b^n c^n | n ≥ 1}, que é CS mas também Tipo-0.",
                                    "Defina os componentes: V = {S, A, B, C}, Σ = {a, b, c}, S inicial.",
                                    "Crie regras: S → a S B C | a B C; B → b B | b; C → c C | c (ajuste para matching).",
                                    "Para RE genuína, adicione simulação de TM: defina gramática que gera strings aceitas por uma TM específica.",
                                    "Valide a gramática: verifique se todas regras têm NT à esquerda."
                                  ],
                                  "verification": "Escreva uma gramática completa G para L = {ww | w ∈ {a,b}* } e liste 5 regras.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de gramáticas em Hopcroft & Ullman",
                                    "Ferramenta online JFLAP para simulação",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Comece com linguagens conhecidas e estenda regras para simular contadores.",
                                  "learningObjective": "Construir gramáticas Tipo-0 válidas para linguagens RE.",
                                  "commonMistakes": [
                                    "Regras sem NT à esquerda (inválidas)",
                                    "Regras que violam não-terminalismo",
                                    "Gramática que gera linguagem não-RE"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Derivações Passo a Passo para Gerar Palavras Específicas",
                                  "subSteps": [
                                    "Selecione uma palavra alvo, ex: 'aabbcc' para L = {a^n b^n c^n | n=2}.",
                                    "Inicie com S e aplique regras sequencialmente, registrando cada sentença.",
                                    "Registre a árvore de derivação ou sequência linear: S ⇒ a S B C ⇒ ... ⇒ aabbcc.",
                                    "Explore derivações não-terminantes para mostrar poder expressivo.",
                                    "Use notação: escreva α ⇒ β com justificativa da regra."
                                  ],
                                  "verification": "Produza uma derivação completa de 8-10 passos para uma palavra de comprimento 6.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "JFLAP ou editor de texto para derivações",
                                    "Exemplos resolvidos de livros-texto",
                                    "Folhas de cálculo para tracking"
                                  ],
                                  "tips": "Desenhe setas para cada aplicação de regra; pratique com palavras curtas primeiro.",
                                  "learningObjective": "Executar derivações precisas em gramáticas Tipo-0.",
                                  "commonMistakes": [
                                    "Aplicar regras inválidas",
                                    "Perder tracking de não-terminais",
                                    "Derivações cíclicas infinitas sem parar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Geração da Linguagem e Propriedades Recursivamente Enumeráveis",
                                  "subSteps": [
                                    "Teste membership: derive múltiplas palavras e prove que estão em L(G).",
                                    "Discuta não-decidibilidade: explique por que pertence a RE mas não recursiva.",
                                    "Simule enumerador: descreva como uma TM enumeraria L(G).",
                                    "Analise completude: mostre que G gera toda L.",
                                    "Compare com autômatos equivalentes (TM)."
                                  ],
                                  "verification": "Prove que uma palavra está em L e outra não, com derivação ou argumento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Teorema Rice ou notas sobre decidibilidade",
                                    "Simulador de TM online",
                                    "Artigos sobre linguagens RE"
                                  ],
                                  "tips": "Ligue à TM: toda gramática Tipo-0 tem TM equivalente.",
                                  "learningObjective": "Demonstrar compreensão de geração e propriedades RE.",
                                  "commonMistakes": [
                                    "Confundir RE com recursiva",
                                    "Achar todas derivações terminantes",
                                    "Ignorar simulação de TM"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa a gramática Tipo-0 G = ({S,A,B}, {a,b}, P, S) com P: S → a S B | a A B; A → ε; B → b B | b. Derive 'a a b b' (para w=ab, ww=aabb): S ⇒ a S B ⇒ a a S B B ⇒ a a A B B B ⇒ a a B B B ⇒ a a b B B ⇒ a a b b B ⇒ a a b b b (ajuste para exato). Adapte para gerar ww^R ou similar RE.",
                              "finalVerifications": [
                                "Derivação completa e correta para 3 palavras diferentes em L(G).",
                                "Gramática válida com todas regras Tipo-0.",
                                "Explicação de por que L(G) é RE mas não recursiva.",
                                "Identificação de uma derivação não-terminante.",
                                "Simulação manual de enumerador para primeiras 5 palavras de L."
                              ],
                              "assessmentCriteria": [
                                "Precisão das regras e derivações (sem erros sintáticos).",
                                "Profundidade na análise de propriedades RE.",
                                "Criatividade na escolha de exemplos RE não-triviais.",
                                "Clareza na documentação de passos e verificações.",
                                "Conexão com teoria de TM.",
                                "Número e variedade de derivações testadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e recursão.",
                                "Lógica: Decidibilidade e teoremas de Rice.",
                                "Programação: Parsers e interpretadores Turing-completos.",
                                "Inteligência Artificial: Modelos de computação e autômatos.",
                                "Filosofia: Limites da computação (problema da parada)."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores avançados e verificadores formais em software (ex: simuladores de TM em ferramentas de prova como Coq); análise de linguagens de programação Turing-completas; modelagem de sistemas biológicos complexos ou redes neurais via gramáticas universais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Linguagens Recursivamente Enumeráveis",
                        "description": "Conjuntos de palavras gerados por gramáticas tipo-0, equivalentes às linguagens aceitas por máquinas de Turing, e suas propriedades fundamentais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Definir linguagens recursivamente enumeráveis (RE)",
                            "description": "Explicar que uma linguagem é RE se existe uma MT que aceita exatamente suas palavras, distinguindo de linguagens recursivas (decidíveis).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Máquinas de Turing (MT)",
                                  "subSteps": [
                                    "Estude a definição formal de uma Máquina de Turing: fita infinita, cabeçote de leitura/escrita, estados finitos, função de transição.",
                                    "Entenda os componentes: alfabeto de entrada, alfabeto da fita, conjunto de estados, função de transição δ, estado inicial, estados de aceitação e rejeição.",
                                    "Simule uma MT simples manualmente em uma palavra de exemplo, como w = 'aba', rastreando configurações.",
                                    "Identifique halting: quando a MT para em um estado final.",
                                    "Diferencie configuração inicial de configuração final."
                                  ],
                                  "verification": "Desenhe o diagrama de estados de uma MT simples e simule sua execução em uma entrada curta, confirmando halting ou loop.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 3), simulador online de MT como Turing Machine Simulator.",
                                  "tips": "Use diagramas de transição para visualizar melhor do que descrições textuais.",
                                  "learningObjective": "Compreender a estrutura e operação básica de uma MT para basear definições de linguagens.",
                                  "commonMistakes": "Confundir rejeição com loop infinito; lembre que rejeição é halting em estado de rejeição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Linguagens Recursivamente Enumeráveis (RE)",
                                  "subSteps": [
                                    "Defina formalmente: Uma linguagem L é RE se existe uma MT M tal que para toda palavra w ∈ L, M aceita w (halta em estado de aceitação), e para w ∉ L, M ou rejeita ou loopa infinitamente.",
                                    "Escreva a definição em notação: L(M) = {w | M aceita w}.",
                                    "Explique 'aceita exatamente suas palavras': M entra em aceitação iff w ∈ L.",
                                    "Discuta enumeração: RE significa que podemos listar as palavras de L rodando M em todas as entradas em paralelo (dovetailing).",
                                    "Crie uma MT que aceita uma linguagem simples RE, como {a^n b^n | n ≥ 0}."
                                  ],
                                  "verification": "Escreva a definição formal de RE e prove que uma linguagem específica é RE construindo ou descrevendo sua MT.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Notas de aula sobre MT, papel e lápis para diagramas, JFLAP software para simulação de MT.",
                                  "tips": "Lembre: RE permite não-halting em não-membros; foque em aceitação precisa para membros.",
                                  "learningObjective": "Dominar a definição precisa de linguagens RE via MT aceitadoras.",
                                  "commonMistakes": "Pensar que RE requer halting em todos os casos; isso é para recursivas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender Linguagens Recursivas (Decidíveis)",
                                  "subSteps": [
                                    "Defina: Uma linguagem L é recursiva se existe uma MT M que halta em todos os inputs: aceita se w ∈ L, rejeita se w ∉ L.",
                                    "Compare com RE: Recursivas são RE, mas nem todas RE são recursivas.",
                                    "Estude o teorema: Toda linguagem recursiva é RE, mas existe RE não recursiva (ex: halting problem).",
                                    "Construa uma MT decididora para uma linguagem recursiva simples, como palíndromos.",
                                    "Explique o simulador universal de MT para computabilidade."
                                  ],
                                  "verification": "Compare definições lado a lado em uma tabela e dê um exemplo de RE não recursiva.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Vídeo Khan Academy ou YouTube sobre Hierarquia de Chomsky, tabela comparativa em Excel ou papel.",
                                  "tips": "Use uma tabela: Colunas para RE vs Recursiva, linhas para halting em sim/não.",
                                  "learningObjective": "Diferenciar halting total (recursiva) de halting parcial (RE).",
                                  "commonMistakes": "Confundir aceitação com decisão; decisão requer resposta para todos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Distinguir RE de Recursivas e Aplicar Exemplos",
                                  "subSteps": [
                                    "Analise o Problema da Parada (Halting Problem): RE mas não recursiva.",
                                    "Prove que halting é RE: MT que simula M em w e aceita se halta.",
                                    "Mostre por que não é recursiva: reductio via diagonalização de Turing.",
                                    "Classifique linguagens na hierarquia: Tipo-0 = RE, decidíveis ⊂ RE.",
                                    "Resolva exercícios: Dê 3 linguagens e classifique como RE/recursiva."
                                  ],
                                  "verification": "Responda a 5 perguntas de distinção e classifique corretamente 3 linguagens exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exercícios de Sipser (Capítulo 4), flashcards Anki com definições.",
                                  "tips": "Memorize: RE = semi-decidível, Recursiva = decidível.",
                                  "learningObjective": "Aplicar definições para distinguir e classificar linguagens.",
                                  "commonMistakes": "Achar que todas RE são decidíveis; halting counterexemplo."
                                }
                              ],
                              "practicalExample": "Considere a linguagem H = {<M,w> | M halta em w}. É RE: Construa MT M_H que simula M em w; se halta, aceita. Não recursiva: Suponha decididora D; construa diagonal que contradiz.",
                              "finalVerifications": [
                                "Defina RE formalmente sem erros.",
                                "Explique por que recursivas ⊂ RE.",
                                "Dê exemplo de RE não recursiva.",
                                "Descreva MT aceitadora para uma linguagem RE simples.",
                                "Distinja aceitação vs decisão em termos de halting.",
                                "Classifique {a^n | n≥0} como RE e recursiva."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de RE (exata match com MT aceitadora).",
                                "Correta distinção halting para membros/não-membros em RE vs recursivas.",
                                "Uso correto de exemplos como halting problem.",
                                "Capacidade de esboçar MT para linguagens RE.",
                                "Compreensão da hierarquia Chomsky (Tipo-0=RE).",
                                "Ausência de confusões comuns como equiparar RE a decidível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções parciais (domínio de computação).",
                                "Lógica: Provas por contradição e diagonalização (Gödel).",
                                "Programação: Simuladores de MT em Python para computabilidade.",
                                "Filosofia: Limites da computação e decidibilidade."
                              ],
                              "realWorldApplication": "Em verificadores de software e compiladores, entender RE ajuda a reconhecer problemas indecidíveis como análise estática completa; usado em teoria de IA para limites de aprendizado de máquinas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Identificar propriedades das linguagens RE",
                            "description": "Listar e exemplificar propriedades como fechamento sob união, concatenação e estrela de Kleene, mas não sob complemento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e características básicas das linguagens RE",
                                  "subSteps": [
                                    "Revise a definição formal de linguagens recursivamente enumeráveis (RE) como o conjunto de linguagens reconhecidas por máquinas de Turing que param em strings da linguagem.",
                                    "Estude a hierarquia de Chomsky, posicionando RE como Tipo-0.",
                                    "Identifique que RE inclui todas as linguagens decidíveis e algumas indecidíveis.",
                                    "Diferencie RE de linguagens recursivas (R), que são decidíveis.",
                                    "Anote exemplos clássicos como {a^n b^n c^n | n ≥ 0} que é RE mas não recursiva."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras definindo RE e dando um exemplo; verifique se menciona MT e hierarquia.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to Automata Theory' de Hopcroft et al.",
                                    "Notas de aula sobre Teoria da Computação",
                                    "Vídeo Khan Academy sobre Máquinas de Turing"
                                  ],
                                  "tips": "Use diagramas de MT para visualizar aceitação; foque em 'parada em aceitação' vs. 'pode loopar'.",
                                  "learningObjective": "Definir precisamente linguagens RE e diferenciá-las de classes inferiores.",
                                  "commonMistakes": [
                                    "Confundir RE com recursivas (R), esquecendo que RE pode não decidir não-membros.",
                                    "Ignorar que RE inclui todas as linguagens REG, CFL, CSL."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar operações de fechamento das linguagens RE",
                                  "subSteps": [
                                    "Aprenda que RE é fechada sob união: construa MT que simula M1 ou M2 em paralelo.",
                                    "Estude fechamento sob concatenação: MT roda M1, se aceitar, roda M2 no resto da fita.",
                                    "Explore fechamento sob estrela de Kleene: MT tenta desmontar a string em blocos aceitos por M.",
                                    "Verifique fechamento sob homomorfismo e substituição.",
                                    "Pratique construindo diagramas de construção de MT para cada operação."
                                  ],
                                  "verification": "Descreva em pseudocódigo a construção de MT para união de duas RE; confira com referências.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e lápis para diagramas de MT",
                                    "Ferramenta online JFLAP para simular MT",
                                    "Capítulo sobre fechamentos em Sipser 'Theory of Computation'"
                                  ],
                                  "tips": "Pense em 'simulação não-determinística' para estrela; divida a fita em regiões para concatenação.",
                                  "learningObjective": "Listar e justificar fechamentos sob união, concatenação e estrela de Kleene.",
                                  "commonMistakes": [
                                    "Achar que fechamento requer decidibilidade; RE usa simulação parcial.",
                                    "Esquecer que estrela requer ε-produções implícitas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar operações onde RE não é fechada",
                                  "subSteps": [
                                    "Estude não-fechamento sob complemento: se L é RE mas não recursiva, complemento não é RE (teorema de Rice).",
                                    "Aprenda não-fechamento sob interseção: exemplo {a^n b^n c^n} ∩ {a^n b^n d^n} não RE.",
                                    "Discuta diferença: recursivas (R) são fechadas sob complemento, mas RE não.",
                                    "Explore implicações para decidibilidade.",
                                    "Crie contra-exemplos para cada operação não-fechada."
                                  ],
                                  "verification": "Prove que o complemento de {ww | w em {0,1}*} não é RE, citando halting problem.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Artigos sobre halting problem",
                                    "Exercícios resolvidos de teoria da computação online (GeeksforGeeks)"
                                  ],
                                  "tips": "Ligue ao problema da parada: RE corresponde a linguagens semi-decidíveis.",
                                  "learningObjective": "Explicar e exemplificar por que RE não é fechada sob complemento.",
                                  "commonMistakes": [
                                    "Confundir com CFL, que não fecha sob interseção mas fecha sob união.",
                                    "Achar que todas as operações algébricas fecham RE."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar propriedades e praticar identificação",
                                  "subSteps": [
                                    "Compile uma tabela: operação | fechada? | construção/contra-exemplo.",
                                    "Resolva exercícios: dada L1, L2 RE, é L1 ∪ L2 RE? L1^c RE?",
                                    "Compare com classes inferiores (REG fecha sob todas; CFL não sob interseção).",
                                    "Discuta teoremas fundamentais (RE fechada sob operações regulares).",
                                    "Teste com exemplos reais de linguagens indecidíveis."
                                  ],
                                  "verification": "Preencha tabela para 5 operações e justifique 2 não-fechadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela",
                                    "Lista de exercícios de Sipser cap. 9"
                                  ],
                                  "tips": "Use mnemônico: RE fecha sob 'UCS' (união, concat, estrela); quebra em complemento.",
                                  "learningObjective": "Identificar rapidamente propriedades de RE em contextos variados.",
                                  "commonMistakes": [
                                    "Generalizar fechamentos de REG para RE.",
                                    "Ignorar contextos não-regulares."
                                  ]
                                }
                              ],
                              "practicalExample": "Dada L1 = {a^n b^n | n≥0} (CFL, logo RE) e L2 = {a^n b^m | n≠m} (RE via MT), construa MT para L1 ∪ L2 simulando M1 em metade da fita e M2 na outra se falhar; para complemento de L1^c, prove indecidível via redução ao halting problem.",
                              "finalVerifications": [
                                "Lista corretamente fechamentos: união, concatenação, estrela de Kleene.",
                                "Explica não-fechamento sob complemento com contra-exemplo.",
                                "Diferencia RE de R quanto a fechamentos.",
                                "Constrói informalmente MT para uma operação fechada.",
                                "Identifica que RE contém todas as classes inferiores.",
                                "Cita teorema relevante (ex: Rice para não-RE)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na lista de fechamentos (100% correto).",
                                "Qualidade de justificativas/teoremas citados (profunda vs superficial).",
                                "Número e relevância de exemplos/contra-exemplos (mínimo 3).",
                                "Clareza na distinção RE vs outras classes.",
                                "Capacidade de aplicar em exercício novo (sim/não com explicação).",
                                "Uso correto de terminologia (MT, semi-decidível)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de linguagens e monoides livres.",
                                "Lógica: Reduções e teoremas de incompletude (Gödel, halting).",
                                "Programação: Verificação de programas e analisadores sintáticos.",
                                "Filosofia: Limites da computação e decidibilidade."
                              ],
                              "realWorldApplication": "Em compiladores e verificadores de software, entender RE ajuda a modelar problemas indecidíveis como 'dado código, ele sempre para?', guiando designs de ferramentas que usam aproximações semi-decidíveis para análise estática."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Comparar RE com linguagens recursivas",
                            "description": "Diferenciar linguagens RE (semi-decidíveis) de recursivas (totalmente decidíveis), usando exemplos como o problema da paridade de halting.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Definições de Linguagens Recursivas",
                                  "subSteps": [
                                    "Leia a definição formal de linguagens recursivas: linguagens aceitas por Máquinas de Turing (MT) que sempre param (halt) em uma resposta sim/não para qualquer entrada.",
                                    "Estude o conceito de 'totalmente decidível': para toda entrada, a MT para e decide corretamente se pertence ou não à linguagem.",
                                    "Anote propriedades chave: fechadas sob união, interseção, complemento.",
                                    "Compare brevemente com linguagens RE para antecipar diferenças.",
                                    "Resuma em suas palavras as características principais."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras definindo linguagens recursivas e liste 3 propriedades.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Notas de aula sobre Hierarquia de Chomsky",
                                    "Acesso a Wikipedia para definições formais"
                                  ],
                                  "tips": "Use diagramas de MT para visualizar o halting em todos os casos.",
                                  "learningObjective": "Dominar a definição e propriedades de linguagens recursivas.",
                                  "commonMistakes": [
                                    "Confundir com RE achando que ambas param sempre.",
                                    "Ignorar o complemento ser decidível."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Definições de Linguagens Recursivamente Enumeráveis (RE)",
                                  "subSteps": [
                                    "Leia a definição: linguagens aceitas por MT que param e aceitam em entradas da linguagem, mas podem loopar em entradas fora.",
                                    "Aprenda 'semi-decidível': reconhecedor para sim, mas não para não.",
                                    "Estude propriedades: fechadas sob união e interseção, mas não complemento.",
                                    "Entenda enumerabilidade: existe uma MT que lista todas as strings da linguagem.",
                                    "Diferencie de recursivas anotando as diferenças em decidibilidade."
                                  ],
                                  "verification": "Liste 3 propriedades de RE e explique por que o complemento não é RE em geral.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Capítulo sobre MT e Decidibilidade em livro texto",
                                    "Vídeos sobre Hierarquia de Chomsky (YouTube: canais como Neso Academy)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Pense em RE como 'parcialmente decidível' para fixar o conceito.",
                                  "learningObjective": "Compreender linguagens RE e suas limitações em relação às recursivas.",
                                  "commonMistakes": [
                                    "Achar que RE são mais poderosas que recursivas (são iguais em poder gerador, mas diferem em decidibilidade).",
                                    "Confundir enumerável com decidível."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Conceitos de Decidibilidade e Hierarquia",
                                  "subSteps": [
                                    "Estude decidibilidade total (recursivas) vs semi-decidibilidade (RE).",
                                    "Aprenda que toda recursiva é RE, mas nem toda RE é recursiva.",
                                    "Analise a hierarquia: RE ⊃ Recursivas.",
                                    "Discuta o papel do Problema da Parada (Halting Problem): RE mas não recursivo.",
                                    "Crie uma tabela comparativa de propriedades (união, complemento, etc.)."
                                  ],
                                  "verification": "Construa uma tabela comparando 5 propriedades entre RE e recursivas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta de tabela (Google Sheets ou papel)",
                                    "Exercícios de decidibilidade de Sipser",
                                    "Simulador de MT online (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": "Use setas na hierarquia para visualizar inclusões.",
                                  "learningObjective": "Diferenciar decidibilidade e posicionamento na hierarquia de Chomsky.",
                                  "commonMistakes": [
                                    "Invertir a inclusão: achar que recursivas ⊃ RE.",
                                    "Esquecer que halting é RE."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Exemplos e Provas de Separação",
                                  "subSteps": [
                                    "Estude o Halting Problem: mostre que é RE (simulador para sim).",
                                    "Prove que não é recursivo (redução diagonal de Turing).",
                                    "Exemplo de paridade de halting: { <M,w> | M para em w com paridade par de passos}.",
                                    "Compare com linguagens recursivas como { a^n b^n }.",
                                    "Resolva 2 exercícios: classifique linguagens como RE ou recursiva."
                                  ],
                                  "verification": "Prove informalmente por que halting é RE mas não recursivo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exercícios resolvidos de teoria da computação",
                                    "Paper com prova de undecidibilidade",
                                    "Fórum StackExchange para dúvidas"
                                  ],
                                  "tips": "Pratique reduções para provar não-recursividade.",
                                  "learningObjective": "Aplicar exemplos para diferenciar RE de recursivas.",
                                  "commonMistakes": [
                                    "Confundir paridade de halting com halting simples.",
                                    "Achar que todo problema RE tem decididor."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a linguagem H = { <M, w> | M é uma MT que para (halts) em w }. Construa um reconhecedor RE para H (simule M em w até parar). Prove que não é recursiva reduzindo do halting problem clássico, mostrando que um decididor para H levaria a contradição.",
                              "finalVerifications": [
                                "Defina precisamente linguagens RE e recursivas.",
                                "Explique por que RE ⊃ Recursivas com exemplo.",
                                "Classifique halting problem como RE não recursivo.",
                                "Liste 3 propriedades que diferenciam as duas classes.",
                                "Crie um exemplo de linguagem recursiva dentro de RE.",
                                "Discuta implicações para decidibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (sem confusão com decidibilidade).",
                                "Correta identificação de exemplos (halting como separador).",
                                "Uso de provas ou reduções lógicas.",
                                "Compreensão da hierarquia e inclusões.",
                                "Capacidade de gerar contra-exemplos.",
                                "Clareza na tabela comparativa de propriedades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Computabilidade e Lógica (Gödel).",
                                "Programação: Análise de algoritmos e loops infinitos.",
                                "Filosofia: Limites do conhecimento computacional.",
                                "Engenharia de Software: Verificação de programas undecidíveis."
                              ],
                              "realWorldApplication": "Em compiladores e verificadores de software, entender RE ajuda a reconhecer problemas semi-decidíveis como detecção de loops infinitos em análise estática, enquanto linguagens recursivas são usadas em parsers decidíveis para linguagens de programação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Relação com Máquinas de Turing",
                        "description": "Equivalência formal entre gramáticas irrestritas, linguagens RE e máquinas de Turing, incluindo a tese de Church-Turing.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Estabelecer equivalência gramática tipo-0 e MT",
                            "description": "Provar ou descrever teoremas que mostram que L(G) para G tipo-0 é exatamente o conjunto aceito por alguma MT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições fundamentais de gramáticas tipo-0 e Máquinas de Turing",
                                  "subSteps": [
                                    "Estude a definição formal de gramática tipo-0 (produções irrestritas: α → β onde α, β ∈ V* e |α| ≤ |β| opcionalmente).",
                                    "Revise a estrutura de uma Máquina de Turing (MT): fita infinita, cabeçote, estados, função de transição.",
                                    "Compare linguagens geradas por G tipo-0 (L(G)) e linguagens aceitas por MT (L(M)).",
                                    "Identifique propriedades chave: recursivamente enumeráveis (RE).",
                                    "Liste exemplos simples de linguagens RE que não são decidíveis."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças e semelhanças entre G tipo-0 e MT, citando referências formais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Teoria da Computação' de Sipser ou Hopcroft",
                                    "Notas de aula sobre autômatos",
                                    "Wikipedia: Chomsky Hierarchy"
                                  ],
                                  "tips": "Use diagramas para visualizar a fita da MT e árvores de derivação da gramática.",
                                  "learningObjective": "Compreender as bases formais para estabelecer a equivalência.",
                                  "commonMistakes": [
                                    "Confundir tipo-0 com tipo-1 (sensível ao contexto), ignorar bidirecionalidade da prova."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar que toda linguagem gerada por gramática tipo-0 é aceita por uma MT",
                                  "subSteps": [
                                    "Construa uma MT que simule derivações de G tipo-0: use fita para representar sentenças atuais e próximas.",
                                    "Defina estados para 'gerar símbolo', 'mover marcadores' e 'verificar aceitação'.",
                                    "Descreva a simulação passo a passo: non-deterministicamente gerar derivações até aceitar ou rejeitar.",
                                    "Prove formalmente que se w ∈ L(G), existe uma derivação aceita pela MT.",
                                    "Analise complexidade: tempo e espaço ilimitados da MT."
                                  ],
                                  "verification": "Escreva pseudocódigo da função de transição da MT simuladora e teste com uma derivação simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para diagramas de MT",
                                    "Ferramenta JFLAP para simular MT",
                                    "Exemplos de provas em livros de teoria"
                                  ],
                                  "tips": "Comece com uma gramática simples como S → aS | ε para praticar simulação.",
                                  "learningObjective": "Dominar a construção da MT simuladora de gramáticas tipo-0.",
                                  "commonMistakes": [
                                    "Esquecer non-determinismo na simulação de derivações múltiplas",
                                    "Limitar a fita da MT."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que toda linguagem aceita por MT é gerada por uma gramática tipo-0",
                                  "subSteps": [
                                    "Construa uma gramática G que simule o comportamento da MT M: use não-terminais para estados e posições do cabeçote.",
                                    "Defina regras para mover o cabeçote: Esquerda, Direita, Escrever, Mudar estado.",
                                    "Inclua regras para início (q0 em posição inicial) e aceitação (alcançar q_accept).",
                                    "Prove que se M aceita w, existe uma derivação em G que gera w.",
                                    "Verifique que G é tipo-0 (produções irrestritas)."
                                  ],
                                  "verification": "Gere uma derivação manual para uma MT simples que aceita {a^n b^n} e confira.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "JFLAP ou simulador online de gramáticas",
                                    "Exemplos de provas padrão em Sipser Cap. 7"
                                  ],
                                  "tips": "Represente a configuração da MT como XqY onde q é estado, X/Y símbolos.",
                                  "learningObjective": "Construir gramáticas tipo-0 a partir de MT.",
                                  "commonMistakes": [
                                    "Produções que violam tipo-0",
                                    "Não lidar com loops infinitos na simulação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer o teorema de equivalência e explorar implicações",
                                  "subSteps": [
                                    "Enuncie o teorema: L(G tipo-0) = linguagens RE = L(MT).",
                                    "Combine as duas inclusões para provar equivalência bidirecional.",
                                    "Discuta corolários: hierarquia de Chomsky colapsa em tipo-0 para poder computacional.",
                                    "Analise linguagens RE mas não recursivas (ex: halting problem).",
                                    "Crie um exemplo completo bidirecional para uma linguagem específica."
                                  ],
                                  "verification": "Escreva a prova completa do teorema em 1-2 páginas e resolva exercícios relacionados.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Folha de exercícios de teoria da computação",
                                    "Vídeos MIT OCW sobre MT e gramáticas"
                                  ],
                                  "tips": "Use setas para inclusões: L(G) ⊆ L(TM) e L(TM) ⊆ L(G).",
                                  "learningObjective": "Sintetizar as provas em um teorema coeso.",
                                  "commonMistakes": [
                                    "Ignorar que equivalência é para reconhecimento, não geração determinística."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a linguagem L = {a^n b^n c^n | n ≥ 0}, que é RE mas não CSG: 1) Construa MT que conta a's, b's, c's com fita auxiliar. 2) Construa G tipo-0 com regras como S → a S B C | ε, B → b B | C C, etc., simulando contadores. Simule aceitação/derivação para n=2.",
                              "finalVerifications": [
                                "Enuncie corretamente o teorema de equivalência tipo-0 e MT.",
                                "Construa MT simuladora para uma G tipo-0 dada.",
                                "Construa G tipo-0 para uma MT simples.",
                                "Identifique uma linguagem RE mas não recursiva.",
                                "Explique por que a hierarquia colapsa no nível 0.",
                                "Resolva um exercício de prova bidirecional."
                              ],
                              "assessmentCriteria": [
                                "Precisão formal nas definições e provas (sem erros lógicos).",
                                "Correta construção de simuladores MT e G (testáveis).",
                                "Compreensão de não-determinismo e ilimitabilidade.",
                                "Uso adequado de notação matemática (⊆, = para famílias).",
                                "Capacidade de generalizar para exemplos não triviais.",
                                "Clareza na escrita da prova completa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e recursão.",
                                "Lógica: Problemas indecidíveis como halting problem.",
                                "Inteligência Artificial: Modelos computacionais em aprendizado de máquina.",
                                "Compiladores: Parsing irrestrito em linguagens de programação.",
                                "Filosofia da Computação: Limites da computação humana."
                              ],
                              "realWorldApplication": "Essa equivalência fundamenta a teoria da computação, permitindo analisar limites de algoritmos em sistemas complexos como verificadores de software, simuladores de hardware e provas de undecidibilidade em cibersegurança e IA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Explicar a tese de Church-Turing",
                            "description": "Descrever como a tese afirma que MT capturam a noção intuitiva de computação efetiva, relacionando com linguagens RE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a noção intuitiva de computação efetiva",
                                  "subSteps": [
                                    "Defina computação efetiva como um processo mecânico finito que produz resultados a partir de entradas discretas.",
                                    "Liste características chave: determinístico, finito em passos, sem insights criativos ou infinitos.",
                                    "Compare com exemplos cotidianos, como calcular uma soma manualmente versus adivinhação.",
                                    "Discuta limitações intuitivas, como problemas que requerem loops infinitos.",
                                    "Anote exemplos históricos, como algoritmos de Euclides."
                                  ],
                                  "verification": "Escreva uma definição pessoal de computação efetiva e valide com uma fonte confiável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre teoria da computação",
                                    "Vídeo introdutório sobre algoritmos efetivos (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias simples como receitas de cozinha para visualizar processos efetivos.",
                                  "learningObjective": "Identificar e descrever os elementos essenciais da computação efetiva intuitiva.",
                                  "commonMistakes": "Confundir computação efetiva com computação quântica ou heurísticas aproximadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar as capacidades das Máquinas de Turing (MT)",
                                  "subSteps": [
                                    "Revise a estrutura básica de uma MT: fita infinita, cabeçote, estados, tabela de transições.",
                                    "Simule uma MT simples que reconhece uma linguagem regular (ex: {a^n | n >= 0}).",
                                    "Demonstre como MT podem simular qualquer algoritmo efetivo, incluindo loops e condicionais.",
                                    "Discuta linguagens reconhecíveis por MT: Recursivamente Enumeráveis (RE).",
                                    "Execute uma simulação online de MT para um problema como soma de números binários."
                                  ],
                                  "verification": "Crie e execute uma simulação de MT para um exemplo simples e verifique se reconhece entradas corretas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador online de Máquinas de Turing (ex: Turing Machine Simulator)",
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (capítulo relevante)"
                                  ],
                                  "tips": "Comece com MT de 2 estados para evitar sobrecarga cognitiva.",
                                  "learningObjective": "Entender como MT modelam computação efetiva através de simulações práticas.",
                                  "commonMistakes": "Ignorar o papel da fita infinita ou confundir aceitação com decisão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a tese de Church-Turing",
                                  "subSteps": [
                                    "Enuncie a tese: Qualquer função intuitivamente computável pode ser computada por uma MT.",
                                    "Mencione equivalências: MT, λ-cálculo, máquinas registradoras de Post, etc.",
                                    "Explique provas observacionais: todos os modelos propostos capturam a mesma classe de funções.",
                                    "Discuta não formalizável: é uma tese, não teorema, baseada em intuição.",
                                    "Compare com contraexemplos propostos e refutações (ex: oráculos hipercomputadores)."
                                  ],
                                  "verification": "Escreva a tese em suas palavras e cite evidências históricas de Church e Turing.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Artigo original de Turing 'On Computable Numbers'",
                                    "Resumo da tese em Wikipedia ou Stanford Encyclopedia of Philosophy"
                                  ],
                                  "tips": "Memorize a frase chave: 'MT capturam toda computação efetiva' para ancoragem.",
                                  "learningObjective": "Articular precisamente a tese e suas bases observacionais.",
                                  "commonMistakes": "Confundir tese com teorema ou alegar que prova computabilidade universal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar a tese com linguagens RE e implicações",
                                  "subSteps": [
                                    "Defina linguagens RE: aceitas por MT que param em aceitação, mas podem loopar em rejeição.",
                                    "Ligue à tese: linguagens RE são exatamente as 'computavelmente enumeráveis'.",
                                    "Discuta complemento: linguagens recursivas (decidíveis) vs. RE.",
                                    "Exemplo: Problema da Parada é RE mas não recursivo.",
                                    "Reflita sobre impactos: limites da computação automática."
                                  ],
                                  "verification": "Classifique 3 linguagens (ex: {a^n b^n}, halting problem) como RE ou não, justificando.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exercícios de linguagens RE de um livro-texto",
                                    "Ferramenta JFLAP para simular MT em linguagens RE"
                                  ],
                                  "tips": "Use diagramas de MT para visualizar aceitação vs. loop infinito.",
                                  "learningObjective": "Conectar a tese às hierarquias de linguagens formais.",
                                  "commonMistakes": "Confundir RE com decidíveis ou ignorar semi-decidibilidade."
                                }
                              ],
                              "practicalExample": "Explique por que o Problema da Parada (dado programa P e entrada x, P parata em x?) é RE mas não decidível: uma MT simula P em x; se parar, aceita. Isso ilustra a tese, pois captura computação efetiva parcial, mas não total.",
                              "finalVerifications": [
                                "Parafraseie a tese de Church-Turing com precisão.",
                                "Identifique linguagens RE e dê exemplo de MT para uma delas.",
                                "Explique por que a tese é observacional, não provada.",
                                "Discuta uma implicação para linguagens Tipo-0.",
                                "Resolva um exercício simples de reconhecimento por MT.",
                                "Compare MT com outro modelo equivalente (ex: λ-cálculo)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: uso correto de termos como 'computação efetiva' e 'RE' (30%)",
                                "Clareza na explicação: estrutura lógica e exemplos concretos (25%)",
                                "Profundidade: inclusão de provas observacionais e contraexemplos (20%)",
                                "Conexões: relação explícita com MT e linguagens formais (15%)",
                                "Originalidade: parafraseio pessoal sem cópia literal (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Computabilidade e funções recursivas.",
                                "Filosofia: Natureza da mente e limites do mecanicismo (ex: Penrose).",
                                "Lógica: Teorema de incompletude de Gödel e não-computabilidade.",
                                "Inteligência Artificial: Limites de aprendizado de máquina automático."
                              ],
                              "realWorldApplication": "A tese fundamenta a impossibilidade de antivírus perfeitos (Problema da Parada) e guia o design de compiladores, provando que linguagens de programação padrão são equivalentes a MT para computação efetiva."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Converter entre gramática tipo-0 e MT",
                            "description": "Esboçar construções para transformar uma gramática irrestrita em uma MT equivalente e vice-versa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Gramáticas Tipo-0 e Máquinas de Turing",
                                  "subSteps": [
                                    "Estude a definição formal de gramática tipo-0: G = (V, Σ, P, S) onde regras são α → β com α não vazio.",
                                    "Revise Máquinas de Turing: configuração com fita infinita, cabeçote, estados, função de transição δ.",
                                    "Entenda o teorema de equivalência: L(G) = L(M) para gramática irrestrita G e MT M.",
                                    "Analise exemplos simples de linguagens recursivamente enumeráveis, como {a^n b^n c^n | n ≥ 0}.",
                                    "Pratique derivando strings em gramáticas tipo-0 e simulando aceitação em MT."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças e semelhanças entre G tipo-0 e MT, confirmando equivalência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to Automata Theory' de Hopcroft et al.",
                                    "Notas de aula sobre teoria da computação",
                                    "Ferramenta online como JFLAP para simulações"
                                  ],
                                  "tips": "Use tabelas para comparar componentes: variáveis vs. estados, regras vs. transições.",
                                  "learningObjective": "Dominar definições e teorema de equivalência para basear conversões.",
                                  "commonMistakes": [
                                    "Confundir tipo-0 com context-free (sem contexto nas regras), ignorar não-determinismo na MT."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir MT a partir de Gramática Tipo-0",
                                  "subSteps": [
                                    "Crie estados para simular derivações: estado inicial com S na fita.",
                                    "Defina transições para aplicar regras de produção: marque não-terminal ativo com símbolo especial (ex: #X#).",
                                    "Implemente busca pela regra aplicável: escaneie fita para encontrar α → β e substitua.",
                                    "Gerencie iterações até terminal ou loop infinito (MT para se não aceitar).",
                                    "Teste com exemplo: converta G para {ww | w em {a,b}*} em MT."
                                  ],
                                  "verification": "Implemente a MT em simulador e aceite strings válidas de L(G), rejeite inválidas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulador JFLAP ou Turing Machine Simulator online",
                                    "Papel e lápis para esboçar fita",
                                    "Exemplos de gramáticas tipo-0"
                                  ],
                                  "tips": "Use símbolos de fita auxiliares para rastrear posição do não-terminal ativo.",
                                  "learningObjective": "Construir MT que enumere L(G) via simulação de derivações.",
                                  "commonMistakes": [
                                    "Esquecer de restaurar fita após aplicação de regra, não lidar com múltiplas regras aplicáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Gramática Tipo-0 a partir de Máquina de Turing",
                                  "subSteps": [
                                    "Gere símbolos para simular configuração da MT: não-terminais para estados e símbolos de fita.",
                                    "Crie regras para transições: de configuração C a δ(C).",
                                    "Inclua regras para mover cabeçote: símbolos representando direção L/R.",
                                    "Adicione axioma inicial simulando configuração inicial da MT.",
                                    "Garanta aceitação: regras para estado final e limpeza da fita para Σ*."
                                  ],
                                  "verification": "Derive strings aceitas pela MT original usando a nova G e confirme L(G) = L(M).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Papel milimetrado para diagramas de configuração",
                                    "Exemplos de MT para linguagens RE",
                                    "Software como Grammar Simulator"
                                  ],
                                  "tips": "Represente configuração como Q Γ^k, onde Q é estado atual.",
                                  "learningObjective": "Gerar gramática que simule computação da MT via regras de produção.",
                                  "commonMistakes": [
                                    "Não representar corretamente o movimento do cabeçote, regras que permitem derivações inválidas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Equivalência e Testar Conversões",
                                  "subSteps": [
                                    "Compare L(G) e L(M) com strings de teste: aceitação mútua.",
                                    "Analise correção: prove que toda derivação válida em G é aceita por M e vice-versa.",
                                    "Identifique limitações: linguagens RE, não decidibilidade de equivalência.",
                                    "Otimize construções: reduza estados/regras desnecessárias.",
                                    "Documente o processo em relatório com diagramas."
                                  ],
                                  "verification": "Passe em pelo menos 5 strings de teste para cada direção de conversão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Strings de teste pré-definidas",
                                    "Ferramentas de simulação MT e gramáticas"
                                  ],
                                  "tips": "Use propriedades de fechamento para validar.",
                                  "learningObjective": "Validar bidirecionalidade da conversão e entender limites.",
                                  "commonMistakes": [
                                    "Testar apenas strings curtas, ignorar casos de rejeição ou loops infinitos."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere G = ({S}, {a,b,c}, P, S) com P: S → aSbc | abc. Converta para MT que simula derivações produzindo a^n b^n c^n. Inversamente, para MT M que aceita {a^n b^n c^n}, construa G com regras simulando transições de configuração como S → a S b c | a b c.",
                              "finalVerifications": [
                                "MT derivada aceita exatamente L(G).",
                                "Gramática derivada gera exatamente L(M).",
                                "Construções lidam com não-determinismo corretamente.",
                                "Testes com 5+ strings confirmam equivalência.",
                                "Documentação inclui provas de correção.",
                                "Identificados erros comuns evitados."
                              ],
                              "assessmentCriteria": [
                                "Precisão das construções (100% match com teorema).",
                                "Completude de componentes (todos estados/regras definidos).",
                                "Clareza de diagramas e explicações.",
                                "Efetividade nos testes (taxa de acerto >90%).",
                                "Profundidade na análise de limitações.",
                                "Criatividade em otimizações opcionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e recursão.",
                                "Programação: Simulação de MT em Python.",
                                "Lógica: Provas de equivalência e decidibilidade.",
                                "Filosofia da Computação: Limites da computação."
                              ],
                              "realWorldApplication": "Em verificadores de teoremas automatizados e simuladores de computabilidade, como em pesquisas de IA para problemas indecidíveis, ou em compiladores teóricos para linguagens universais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Fundamentos de Análise Sintática (Parsing)",
                "description": "Princípios básicos de parsing e reconhecimento de linguagens.",
                "totalSkills": 41,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Definição de Parsing",
                    "description": "Conceitos básicos de análise sintática e seu papel no reconhecimento de linguagens formais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Definição de Parsing",
                        "description": "Conceito básico de parsing como processo de análise sintática que verifica se uma string de entrada é válida segundo uma gramática formal específica.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Definir Parsing",
                            "description": "Fornecer a definição precisa de parsing como o processo computacional de analisar a estrutura sintática de uma sequência de símbolos (string) em relação a uma gramática formal, produzindo uma árvore de análise ou indicando se a string pertence à linguagem gerada pela gramática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Linguagens Formais",
                                  "subSteps": [
                                    "Revise a definição de linguagem formal como um conjunto de strings geradas por uma gramática.",
                                    "Identifique símbolos terminais e não-terminais em uma gramática simples.",
                                    "Diferencie alfabeto, regras de produção e axioma em uma gramática.",
                                    "Estude exemplos de linguagens regulares e context-free.",
                                    "Anote as relações entre autômatos e linguagens formais."
                                  ],
                                  "verification": "Crie um diagrama simples de uma gramática com terminais e não-terminais identificados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (capítulo de linguagens formais)",
                                    "Notas ou slides sobre gramáticas formais"
                                  ],
                                  "tips": "Use exemplos visuais como diagramas de árvores para fixar os conceitos.",
                                  "learningObjective": "Entender os blocos fundamentais que precedem o parsing.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Ignorar o papel do axioma na geração de strings"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Estrutura de uma Gramática Formal",
                                  "subSteps": [
                                    "Defina gramática formal usando a notação de Chomsky (G = (V, Σ, P, S)).",
                                    "Analise uma gramática de exemplo para context-free languages (CFL).",
                                    "Gere derivadas de strings a partir do axioma usando as regras de produção.",
                                    "Verifique se uma string pertence à linguagem da gramática manualmente.",
                                    "Compare gramáticas regulares, context-free e context-sensitive."
                                  ],
                                  "verification": "Gere pelo menos duas strings válidas de uma gramática dada e prove sua validade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online de gramáticas formais (ex: JFLAP)",
                                    "Papel e caneta para derivadas"
                                  ],
                                  "tips": "Comece com gramáticas simples para evitar sobrecarga cognitiva.",
                                  "learningObjective": "Dominar os componentes de uma gramática que o parsing analisa.",
                                  "commonMistakes": [
                                    "Esquecer de aplicar todas as regras de produção",
                                    "Confundir derivação esquerda com direita"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o Processo de Parsing",
                                  "subSteps": [
                                    "Descreva parsing como análise sintática de uma string contra uma gramática.",
                                    "Explique a produção de uma árvore de análise (parse tree) se válida.",
                                    "Discuta o output: árvore de parsing ou rejeição se inválida.",
                                    "Diferencie parsing top-down (ex: LL) de bottom-up (ex: LR).",
                                    "Estude o papel do parsing em reconhecibilidade de linguagens."
                                  ],
                                  "verification": "Escreva uma definição completa de parsing em 3-5 frases, incluindo gramática e árvore.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Vídeo tutorial sobre parsing (ex: YouTube - Parsing in Compiler Design)",
                                    "Exemplos de árvores de parsing"
                                  ],
                                  "tips": "Relacione parsing à validação de código em editores de texto.",
                                  "learningObjective": "Formular uma definição precisa e completa de parsing.",
                                  "commonMistakes": [
                                    "Limitar parsing apenas a programação, ignorando teoria formal",
                                    "Confundir sintaxe com semântica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Sintetizar o Conceito de Parsing",
                                  "subSteps": [
                                    "Construa uma árvore de parsing para uma string simples em uma gramática dada.",
                                    "Identifique ambiguidades em gramáticas e como parsing as resolve.",
                                    "Compare parsing com lexical analysis (scanning).",
                                    "Pesquise um algoritmo de parsing simples (ex: recursive descent).",
                                    "Resuma a importância do parsing em autômatos e compiladores."
                                  ],
                                  "verification": "Construa manualmente uma árvore de parsing correta para uma expressão aritmética.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de parsing online",
                                    "Exercícios de gramáticas context-free"
                                  ],
                                  "tips": "Pratique com expressões matemáticas familiares para intuitividade.",
                                  "learningObjective": "Integrar a definição de parsing com exemplos práticos.",
                                  "commonMistakes": [
                                    "Não representar a árvore hierarquicamente",
                                    "Ignorar a ordem das regras de produção"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada a gramática S → aSb | ε, parse a string 'aabbbaa' para produzir a árvore de análise mostrando derivadas simétricas de 'a' e 'b'.",
                              "finalVerifications": [
                                "Explique parsing em suas próprias palavras sem consultar materiais.",
                                "Identifique corretamente os componentes de uma gramática formal.",
                                "Construa uma árvore de parsing válida para uma string dada.",
                                "Diferencie parsing de scanning.",
                                "Reconheça quando uma string não pertence à linguagem."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: inclui gramática formal, string, árvore de análise e pertencência à linguagem.",
                                "Clareza na explicação do processo computacional.",
                                "Uso correto de terminologia (sintaxe, parse tree, Chomsky).",
                                "Capacidade de gerar exemplos válidos e inválidos.",
                                "Compreensão de ambiguidades e resolução via parsing.",
                                "Integração com conceitos de linguagens formais."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Análise sintática em gramáticas naturais.",
                                "Matemática: Teoria de grafos e árvores hierárquicas.",
                                "Programação: Fase de parsing em compiladores e interpretadores.",
                                "Inteligência Artificial: Parsing em PLN para análise de frases."
                              ],
                              "realWorldApplication": "Parsing é essencial em compiladores de linguagens de programação (ex: GCC para C++), validadores de JSON/XML em navegadores, e processadores de consultas em bancos de dados SQL."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Identificar Entradas e Saídas do Parsing",
                            "description": "Descrever as entradas típicas de um parser (string de entrada e gramática formal) e as saídas possíveis (aceitação/rejeição da string, árvore de derivação ou parse tree).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a String de Entrada em um Parser",
                                  "subSteps": [
                                    "Defina o que é uma string de entrada: uma sequência finita de símbolos de um alfabeto específico.",
                                    "Identifique o papel da string: representa a linguagem a ser analisada sintaticamente.",
                                    "Discuta exemplos de alfabetos: {a, b} para linguagens regulares ou tokens em linguagens de programação.",
                                    "Explique que a string deve ser válida ou inválida conforme a gramática.",
                                    "Pratique gerando strings simples de um alfabeto dado."
                                  ],
                                  "verification": "Liste 3 exemplos de strings válidas e inválidas para um alfabeto simples, explicando por quê.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Documentação de gramáticas formais básicas (ex: PDF de Chomsky Hierarchy)"
                                  ],
                                  "tips": "Sempre comece definindo o alfabeto Σ explicitamente para evitar ambiguidades.",
                                  "learningObjective": "Identificar e descrever corretamente o conceito e exemplos de string de entrada.",
                                  "commonMistakes": [
                                    "Confundir string com gramática",
                                    "Ignorar o alfabeto finito",
                                    "Usar símbolos fora do alfabeto definido"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Gramática Formal como Entrada",
                                  "subSteps": [
                                    "Defina gramática formal: quadruplete G = (V, Σ, P, S), onde V são não-terminais, Σ terminais, P produções, S axioma.",
                                    "Explique o papel da gramática: define as regras de geração de strings válidas.",
                                    "Classifique tipos: regulares, livres de contexto (CFL), etc., focando em context-free para parsing.",
                                    "Identifique componentes em uma gramática exemplo: S → aSb | ε.",
                                    "Desenhe a estrutura da gramática em diagrama."
                                  ],
                                  "verification": "Descreva todos os componentes de uma gramática simples fornecida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para anotar gramáticas",
                                    "Ferramentas online como JFLAP para visualização"
                                  ],
                                  "tips": "Use notação padrão BNF para clareza nas produções.",
                                  "learningObjective": "Desmontar e explicar os elementos constitutivos de uma gramática formal.",
                                  "commonMistakes": [
                                    "Omitir o símbolo inicial S",
                                    "Confundir terminais com não-terminais",
                                    "Esquecer regras de produção vazia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Saídas Possíveis de um Parser",
                                  "subSteps": [
                                    "Liste saídas básicas: aceitação (string pertence à linguagem) ou rejeição.",
                                    "Descreva árvore de derivação: sequência de aplicações de produções da gramática.",
                                    "Explique parse tree: representação gráfica hierárquica da estrutura sintática.",
                                    "Diferencie árvore de derivação esquerda/direita de parse tree.",
                                    "Discuta saídas adicionais: erros sintáticos localizados."
                                  ],
                                  "verification": "Para uma string e gramática dadas, indique saída esperada e esboce parse tree.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para desenhar árvores",
                                    "Simulador de parser online (ex: LR Parser Generator)"
                                  ],
                                  "tips": "Visualize árvores de cima para baixo, raiz no axioma.",
                                  "learningObjective": "Classificar e representar todas as saídas padrão de um parser.",
                                  "commonMistakes": [
                                    "Confundir aceitação com parse tree completa",
                                    "Ignorar ambiguidades em gramáticas",
                                    "Desenhar árvores incorretas sem seguir produções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Entradas e Saídas em Exemplos Práticos",
                                  "subSteps": [
                                    "Escolha uma gramática simples: S → aS | b.",
                                    "Teste strings: 'aab' (aceita, derive árvore), 'abb' (rejeitada).",
                                    "Gere parse trees para strings aceitas.",
                                    "Analise casos de rejeição: sem derivação possível.",
                                    "Compare múltiplas saídas para a mesma entrada."
                                  ],
                                  "verification": "Crie um relatório com 2 exemplos completos: entradas, saídas e justificativas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas impressas",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Teste strings curtas primeiro para construir confiança.",
                                  "learningObjective": "Aplicar conceitos de entradas e saídas em cenários concretos.",
                                  "commonMistakes": [
                                    "Erros em derivações manuais",
                                    "Parse trees desalinhadas com produções",
                                    "Não justificar rejeições"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: G = ({S}, {a,b}, P, S) onde P: S → aSb | ε. String: 'aabb'. Entradas: string 'aabb' e G. Saídas: Aceitação (pertence L(G)), Parse tree com derivações S → aSb → aaSbb → aabb.",
                              "finalVerifications": [
                                "Descreva corretamente entradas (string + gramática) sem omissões.",
                                "Liste todas saídas possíveis (aceitação/rejeição, árvores).",
                                "Gere parse tree válida para string aceita.",
                                "Justifique rejeição de string inválida.",
                                "Diferencie árvore de derivação de parse tree.",
                                "Identifique alfabeto e não-terminais em gramática dada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de entradas (90% cobertura de componentes).",
                                "Correção das saídas em exemplos (sem erros de derivação).",
                                "Qualidade visual e lógica de parse trees.",
                                "Explicações claras e concisas de aceitação/rejeição.",
                                "Uso correto de terminologia formal.",
                                "Capacidade de generalizar para novas gramáticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (parse trees como árvores hierárquicas).",
                                "Linguística: Análise sintática em linguagens naturais.",
                                "Programação: Implementação de parsers em compiladores (ex: Python's Lark).",
                                "Engenharia de Software: Validação de estruturas em XML/JSON parsers."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens como Python ou Java, parsers recebem código-fonte (string) e gramática da linguagem para produzir árvores sintáticas usadas na geração de código intermediário, detectando erros de sintaxe em editores de código."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Diferenciar Parsing de Análise Léxica",
                            "description": "Explicar a distinção entre análise léxica (tokenização em tokens) e análise sintática (verificação da estrutura gramatical dos tokens), destacando que o parsing opera sobre sequências de tokens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Análise Léxica",
                                  "subSteps": [
                                    "Defina análise léxica como o processo de tokenização de uma sequência de caracteres em tokens significativos.",
                                    "Identifique os tipos comuns de tokens: palavras-chave, identificadores, operadores, literais e símbolos.",
                                    "Explique o papel do lexer (analisador léxico) em ignorar espaços em branco, comentários e formar tokens.",
                                    "Estude expressões regulares como base para reconhecimento de padrões léxicos.",
                                    "Pratique tokenizando uma linha simples de código fonte."
                                  ],
                                  "verification": "Tokenize corretamente uma expressão como 'x = 5;' em tokens: ['x', '=', '5', ';'].",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação sobre lexers",
                                    "Ferramenta online de tokenização (ex: JLex demo)",
                                    "Exemplos de código fonte simples"
                                  ],
                                  "tips": [
                                    "Comece com entradas simples para evitar sobrecarga.",
                                    "Anote cada token e sua classe (ex: ID, OP)."
                                  ],
                                  "learningObjective": "Dominar o conceito de tokenização e seus componentes básicos.",
                                  "commonMistakes": [
                                    "Confundir tokens com palavras completas sem considerar classes.",
                                    "Ignorar tratamento de espaços e comentários.",
                                    "Misturar análise léxica com verificação de estrutura."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender os Fundamentos do Parsing (Análise Sintática)",
                                  "subSteps": [
                                    "Defina parsing como a verificação da estrutura gramatical de uma sequência de tokens.",
                                    "Explique gramáticas livres de contexto (CFG) e árvores de análise sintática.",
                                    "Descreva tipos de parsers: descendente (top-down) e ascendente (bottom-up).",
                                    "Entenda que o parser constrói uma árvore de derivação ou AST (Abstract Syntax Tree).",
                                    "Diferencie erros léxicos de erros sintáticos."
                                  ],
                                  "verification": "Construa uma árvore sintática simples para tokens de 'if (x > 0) stmt;' e identifique a estrutura.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro 'Compilers: Principles, Techniques, and Tools' (cap. 4)",
                                    "Ferramentas como ANTLR ou Yacc demo",
                                    "Diagramas de árvores sintáticas"
                                  ],
                                  "tips": [
                                    "Visualize árvores para entender hierarquia.",
                                    "Use pseudocódigo para simular o parser."
                                  ],
                                  "learningObjective": "Entender o processo de verificação sintática sobre tokens.",
                                  "commonMistakes": [
                                    "Pensar que parsing lida com caracteres brutos.",
                                    "Confundir parsing com geração de código.",
                                    "Ignorar a dependência em tokens pré-processados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Comparar Diferenças Chave",
                                  "subSteps": [
                                    "Liste diferenças: léxica opera em caracteres → tokens; sintática em tokens → estrutura.",
                                    "Compare entradas/saídas: lexer (string → tokens), parser (tokens → árvore).",
                                    "Discuta dependências: parsing requer análise léxica prévia.",
                                    "Analise erros típicos: léxico (token inválido), sintático (sequência inválida).",
                                    "Crie uma tabela comparativa com colunas: Propósito, Entrada, Saída, Ferramentas."
                                  ],
                                  "verification": "Preencha uma tabela comparativa corretamente e explique verbalmente as distinções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Exemplos de compiladores reais (GCC pipeline)"
                                  ],
                                  "tips": [
                                    "Use analogias: lexer como 'dividir palavras', parser como 'montar frases'.",
                                    "Foco em pipeline sequencial."
                                  ],
                                  "learningObjective": "Discernir precisamente as distinções entre os dois processos.",
                                  "commonMistakes": [
                                    "Achar que são intercambiáveis.",
                                    "Reverter ordem: parsing antes de léxica.",
                                    "Subestimar granularidade (caracteres vs tokens)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceitos em um Fluxo Completo",
                                  "subSteps": [
                                    "Simule o pipeline: aplique léxica, depois sintática em um código curto.",
                                    "Identifique onde cada etapa falha em casos de erro.",
                                    "Compare saídas de ferramentas que isolam lexer e parser.",
                                    "Discuta otimizações e interações entre fases.",
                                    "Reflita sobre implicações em compiladores modernos."
                                  ],
                                  "verification": "Processar 'int x=1;' através de ambas as fases e descrever saídas intermediárias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de compilador online (ex: Compiler Explorer)",
                                    "Código fonte de exemplo"
                                  ],
                                  "tips": [
                                    "Teste com erros intencionais para ver diferenças.",
                                    "Registre logs de cada fase."
                                  ],
                                  "learningObjective": "Integrar conhecimentos para diferenciar na prática.",
                                  "commonMistakes": [
                                    "Pular verificação de tokens antes de parsing.",
                                    "Confundir saída léxica com sintática.",
                                    "Ignorar contexto de pipeline."
                                  ]
                                }
                              ],
                              "practicalExample": "Entrada: 'if (x > 0) { y = 1; }'\nAnálise Léxica: Tokens = ['if', '(', 'x', '>', '0', ')', '{', 'y', '=', '1', ';', '}']\nParsing: Verifica estrutura - 'if' seguido de '(' expr ')' '{' stmt '}' → Árvore: IfStmt(cond=BinOp(x>0), body=Assign(y=1))",
                              "finalVerifications": [
                                "Explicar em palavras próprias a distinção entre lexer e parser.",
                                "Tokenizar corretamente uma linha de código e listar classes de tokens.",
                                "Identificar se um erro é léxico ou sintático em um exemplo dado.",
                                "Desenhar uma árvore sintática simples a partir de tokens.",
                                "Descrever o pipeline lexer → parser em um compilador.",
                                "Comparar entradas/saídas de cada fase em uma tabela."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de análise léxica e parsing (90%+ correção).",
                                "Correta identificação de diferenças chave (entrada, saída, dependências).",
                                "Uso de exemplos concretos e tokenização/parsing precisos.",
                                "Compreensão de erros e pipeline sequencial.",
                                "Capacidade de analogias claras e tabela comparativa completa.",
                                "Aplicação prática em cenários reais sem confusões."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Morfologia (léxica) vs. Sintaxe (parsing).",
                                "Programação: Desenvolvimento de scanners/parsers em linguagens como Python (PLY).",
                                "Inteligência Artificial: Processamento de linguagem natural (tokenizers vs. parsers em NLP).",
                                "Matemática: Autômatos finitos (léxica) vs. Pilhas/Pushdown (parsing).",
                                "Engenharia de Software: Ferramentas de build (Make, Antlr) em pipelines de compilação."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou interpretadores como Python's, o lexer (flex) gera tokens para o parser (bison) validar sintaxe, essencial para detecção precoce de erros em desenvolvimento de software e processamento de queries em bancos de dados SQL."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Papel do Parsing no Reconhecimento de Linguagens Formais",
                        "description": "Importância do parsing como mecanismo para reconhecer e validar strings em linguagens formais, especialmente livres de contexto, conectando gramáticas a autômatos como o autômato de pilha.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Explicar Reconhecimento de Linguagens via Parsing",
                            "description": "Descrever como o parsing atua como um reconhecedor de linguagens formais, determinando se uma string pertence à linguagem L(G) gerada por uma gramática G, relacionando com a hierarquia de Chomsky.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Linguagens Formais e Gramáticas",
                                  "subSteps": [
                                    "Defina linguagem formal como um conjunto de strings geradas por regras.",
                                    "Explique gramática G = (V, Σ, P, S) e como ela gera L(G).",
                                    "Discuta tipos de gramáticas na hierarquia de Chomsky (Tipo 0 a 3).",
                                    "Identifique exemplos simples de linguagens regulares e context-free.",
                                    "Crie uma gramática simples de exemplo para uma linguagem básica."
                                  ],
                                  "verification": "Escreva definições precisas e gere pelo menos duas strings derivadas da gramática exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (capítulo de linguagens formais)",
                                    "Papel e caneta ou editor de texto",
                                    "Referência online sobre hierarquia de Chomsky"
                                  ],
                                  "tips": [
                                    "Use notação padrão para gramáticas; visualize árvores de derivação."
                                  ],
                                  "learningObjective": "Compreender os blocos de construção de linguagens formais e gramáticas.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Ignorar o axioma inicial S"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Conceito de Reconhecimento de Linguagens",
                                  "subSteps": [
                                    "Defina reconhecedor como uma máquina ou algoritmo que decide se w ∈ L(G).",
                                    "Diferencie aceitador (sim/não) de gerador (enumera strings).",
                                    "Relacione com autômatos: DFA para regulares, PDA para context-free.",
                                    "Explique decidibilidade para linguagens recursivamente enumeráveis.",
                                    "Discuta o papel do parsing como um método de reconhecimento top-down ou bottom-up."
                                  ],
                                  "verification": "Classifique três linguagens exemplo quanto ao tipo de autômato reconhecedor.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas de autômatos (impressos ou digitais)",
                                    "Simulador de PDA online",
                                    "Notas de aula sobre teoria dos autômatos"
                                  ],
                                  "tips": [
                                    "Pense em reconhecimento como 'validação de membership'; teste com strings válidas/inválidas."
                                  ],
                                  "learningObjective": "Dominar o que significa reconhecer uma linguagem formal.",
                                  "commonMistakes": [
                                    "Confundir reconhecimento com geração",
                                    "Esquecer limitações da hierarquia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Papel do Parsing no Reconhecimento",
                                  "subSteps": [
                                    "Descreva parsing como construção de árvore de análise para verificar w ∈ L(G).",
                                    "Compare parsing LL(k) (top-down) vs LR(k) (bottom-up).",
                                    "Explique como parser determinístico reconhece context-free determinísticas.",
                                    "Ilustre com exemplo: parse 'aabb' em G: S → AB | ε, A → aA | a, B → bB | b.",
                                    "Discuta erros de parsing como rejeição da string."
                                  ],
                                  "verification": "Construa manualmente uma árvore de parse para uma string dada e valide membership.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de parsing online (ex: JFLAP)",
                                    "Gramática exemplo impressa",
                                    "Vídeo tutorial curto sobre parsing"
                                  ],
                                  "tips": [
                                    "Desenhe árvores passo a passo; use shift-reduce para bottom-up."
                                  ],
                                  "learningObjective": "Explicar parsing como mecanismo de reconhecimento.",
                                  "commonMistakes": [
                                    "Ignorar ambiguidades em gramáticas",
                                    "Confundir parse tree com derivation tree"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Parsing com Hierarquia de Chomsky",
                                  "subSteps": [
                                    "Mapeie parsers a tipos: regex para Tipo 3, CYK/Earley para Tipo 2.",
                                    "Discuta limitações: sem parser universal para Tipo 0.",
                                    "Compare eficiência: O(n^3) para context-free geral.",
                                    "Exemplo: use CYK para reconhecer {a^n b^n} via tabela.",
                                    "Conclua como parsing escala com complexidade da linguagem."
                                  ],
                                  "verification": "Crie tabela CYK para string exemplo e classifique na hierarquia.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha para tabela CYK",
                                    "Implementação Python simples de CYK",
                                    "Resumo da hierarquia de Chomsky"
                                  ],
                                  "tips": [
                                    "Lembre: poder de parsing diminui com hierarquia crescente."
                                  ],
                                  "learningObjective": "Integrar parsing à teoria de linguagens formais.",
                                  "commonMistakes": [
                                    "Achar que todo parsing é eficiente",
                                    "Confundir Tipo 2 com Tipo 3"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada gramática context-free G: S → a S b | ε, parse string 'aabb' usando algoritmo bottom-up (shift-reduce). Inicie com pilha vazia, shift 'a', shift 'a', reduce para S (via a S b), shift 'b', shift 'b', reduce para aceitar, confirmando 'aabb' ∈ L(G).",
                              "finalVerifications": [
                                "Explique em 2 frases como parsing decide membership em L(G).",
                                "Classifique corretamente 3 linguagens na hierarquia de Chomsky.",
                                "Construa parse tree válida para string exemplo.",
                                "Diferencie parsing de geração de strings.",
                                "Identifique parser adequado para linguagem dada (ex: regex vs CYK)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem erros.",
                                "Profundidade: inclui exemplos e relações com Chomsky.",
                                "Clareza: explicação lógica e estruturada.",
                                "Aplicação prática: demonstra parsing manual.",
                                "Completude: cobre reconhecimento, parsing e hierarquia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (árvores de parse como grafos).",
                                "Linguística: Análise sintática em linguagem natural.",
                                "Programação: Compiladores e validadores de JSON/XML.",
                                "Inteligência Artificial: Parsing em PLN para gramáticas probabilísticas."
                              ],
                              "realWorldApplication": "Em compiladores (GCC/Clang), parsing verifica sintaxe de código-fonte; em editores (VS Code), real-time syntax highlighting usa parsers para reconhecer linguagens de programação, prevenindo erros antes da compilação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Relacionar Parsing com Autômatos",
                            "description": "Explicar a equivalência entre parsers para gramáticas livres de contexto e autômatos de pilha, ilustrando como o parsing simula o comportamento de um PDA (Pushdown Automaton) para reconhecimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de PDAs e Parsing",
                                  "subSteps": [
                                    "Defina um Autômato de Pilha (PDA): componentes como estados, alfabeto de entrada, alfabeto da pilha, função de transição e configurações iniciais/finais.",
                                    "Explique modos de aceitação de PDA: por estado final ou por pilha vazia, destacando nondeterminismo.",
                                    "Revise gramáticas livres de contexto (CFLs) e sua geração de linguagens via regras de produção.",
                                    "Descreva parsers para CFLs: top-down (LL) e bottom-up (LR), focando no uso de pilha para rastrear contexto.",
                                    "Compare pilha em PDA com pilha de estados/produções em parsers."
                                  ],
                                  "verification": "Crie um diagrama comparativo anotado dos componentes de PDA e parser bottom-up.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 2)",
                                    "Folhas de papel ou ferramenta de diagramação como Draw.io",
                                    "Vídeos Khan Academy sobre autômatos"
                                  ],
                                  "tips": "Desenhe transições de PDA com setas e símbolos de pilha para visualização clara.",
                                  "learningObjective": "Dominar os componentes básicos de PDAs e parsers para estabelecer base conceitual.",
                                  "commonMistakes": [
                                    "Confundir alfabeto de entrada com alfabeto da pilha",
                                    "Ignorar o nondeterminismo essencial em PDAs para CFLs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer Equivalência Teórica entre Parsing e PDAs",
                                  "subSteps": [
                                    "Estude o teorema fundamental: Uma linguagem é CFL se e só se é aceita por um PDA.",
                                    "Descreva construção de PDA a partir de gramática em forma normal de Chomsky (CNF).",
                                    "Explique construção reversa: gramática a partir de PDA via simulação de configurações.",
                                    "Relacione pilha do PDA com árvore de análise sintática no parsing: símbolos não-terminais como contexto.",
                                    "Discuta parsers determinísticos (LR) como PDAs determinísticos para subconjunto de CFLs."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras provando a equivalência com referências aos teoremas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Notas de aula sobre Linguagens Formais",
                                    "Artigo ou capítulo sobre teoremas de Chomsky-Schützenberger",
                                    "Editor de texto para resumos"
                                  ],
                                  "tips": "Use tabelas para mapear construções PDA ↔ Gramática passo a passo.",
                                  "learningObjective": "Compreender e articular teoremas que ligam parsers a PDAs teoricamente.",
                                  "commonMistakes": [
                                    "Achar que todo CFL tem parser determinístico",
                                    "Confundir PDA nondeterminístico com AFAs finitos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Comportamento de Parsing como Execução de PDA",
                                  "subSteps": [
                                    "Modele um parser shift-reduce como PDA: shift empilha símbolos, reduce desempilha via produções.",
                                    "Simule passo a passo: configuração (estado, entrada restante, pilha) em parsing.",
                                    "Ilustre com gramática ambígua resolvida por nondeterminismo do PDA.",
                                    "Compare com parser top-down: pilha como fronteira esquerda da árvore de derivação.",
                                    "Implemente uma simulação manual em pseudocódigo unificando parser e PDA."
                                  ],
                                  "verification": "Execute simulação manual de uma string em gramática simples e anote todas configurações.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Papel milimetrado para tabelas de configuração",
                                    "Ferramenta JFLAP para simular PDAs",
                                    "Exemplos de gramáticas de livros texto"
                                  ],
                                  "tips": "Sempre anote pilha de baixo para cima como em convenções padrão.",
                                  "learningObjective": "Mapear operações de parsing diretamente para transições de PDA.",
                                  "commonMistakes": [
                                    "Esquecer de considerar branches nondeterminísticos",
                                    "Misturar shift com reduce sem verificar pilha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar a Simulação em Exemplos Práticos",
                                  "subSteps": [
                                    "Escolha uma CFL simples (ex: parênteses balanceados) e construa PDA e parser equivalente.",
                                    "Simule reconhecimento de strings válidas/inválidas em ambos.",
                                    "Analise como falhas de parsing correspondem a rejeições de PDA.",
                                    "Discuta extensões: parsers para gramáticas LL/LR como PDAs especiais.",
                                    "Crie variação: adicione contexto para mostrar limites de PDAs."
                                  ],
                                  "verification": "Gere relatório com 3 strings testadas, tabelas de simulação e conclusão de equivalência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "JFLAP ou simulador online de PDA",
                                    "Gramáticas exemplo impressas",
                                    "Planilha Excel para tabelas de configuração"
                                  ],
                                  "tips": "Teste strings de borda como ε (vazia) para validar aceitação por pilha vazia.",
                                  "learningObjective": "Aplicar simulação prática para internalizar a relação parser-PDA.",
                                  "commonMistakes": [
                                    "Não testar strings inválidas",
                                    "Ignorar ambiguidade na equivalência"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a gramática S → (S) | ε (parênteses balanceados), o PDA empilha '(' ao ler (, desempilha ao ler ) verificando topo, aceita por pilha vazia. Um parser shift-reduce simula: shift empilha (, reduce S → (S) desempilha matching pair, replicando exatamente o PDA.",
                              "finalVerifications": [
                                "Construir PDA correto a partir de uma gramática CFL simples.",
                                "Simular parsing de string mostrando configurações PDA equivalentes.",
                                "Explicar verbalmente como pilha de parser modela contexto de PDA.",
                                "Identificar quando um parser LR é um PDA determinístico.",
                                "Provar rejeição de string não-CFL via falha de pilha.",
                                "Comparar aceitação por estado vs pilha vazia em contexto de parsing."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de transições PDA-parser (90% match).",
                                "Correção em simulações manuais sem erros de pilha.",
                                "Profundidade na explicação de teoremas de equivalência.",
                                "Criatividade em exemplos personalizados e variações.",
                                "Clareza em diagramas e tabelas de configuração.",
                                "Capacidade de debugar falhas comuns em simulações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Autômatos e Grafos direcionados com pilha.",
                                "Engenharia de Software: Desenvolvimento de compiladores e analisadores sintáticos.",
                                "Lógica e Provas: Demonstrações de equivalência via construções bidirecionais.",
                                "Algoritmos: Complexidade de parsing CYK O(n^3) ligada a PDAs.",
                                "Inteligência Artificial: Parsing em PLN simulando PDAs para estruturas aninhadas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou LLVM, parsers LR(1) simulam PDAs para análise sintática eficiente de código C++/Rust, detectando erros de balanceamento (chaves, parênteses) e construindo árvores de sintaxe para otimização."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.2",
                              "10.1.4.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Identificar Aplicações do Parsing",
                            "description": "Citar exemplos de uso do parsing em compiladores (fase sintática), interpretadores e verificadores de linguagens formais, enfatizando seu papel na teoria da computação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição e Contexto do Parsing",
                                  "subSteps": [
                                    "Ler a definição formal de parsing como processo de análise sintática em linguagens formais.",
                                    "Diferenciar parsing da análise léxica (scanning) e semântica.",
                                    "Estudar o papel do parsing no reconhecimento de linguagens livres de contexto via autômatos pushdown.",
                                    "Identificar gramáticas que requerem parsing (ex: CFG - Context-Free Grammars).",
                                    "Mapear parsing na teoria da computação como ponte entre linguagens regulares e recursivamente enumeráveis."
                                  ],
                                  "verification": "Explicar em 3 frases o que é parsing e sua distinção de outras análises.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre Autômatos e Linguagens Formais",
                                    "Capítulo de livro sobre teoria da computação (ex: Sipser)",
                                    "Diagrama de fases de um compilador"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar as fases do processamento de linguagens.",
                                  "learningObjective": "Compreender o parsing como etapa central na análise sintática de linguagens formais.",
                                  "commonMistakes": [
                                    "Confundir parsing com tokenização (análise léxica)",
                                    "Ignorar o vínculo com autômatos pushdown",
                                    "Subestimar o papel na hierarquia de Chomsky"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Aplicações em Compiladores",
                                  "subSteps": [
                                    "Descrever a fase sintática em compiladores front-end.",
                                    "Exemplificar com parsers LL(k) ou LR(k) em ferramentas como Yacc/Bison.",
                                    "Explicar como o parser constrói árvores de sintaxe abstrata (AST).",
                                    "Discutir tratamento de erros sintáticos (recovery).",
                                    "Relacionar com teoria: parsing decide aceitação de strings em L(G)."
                                  ],
                                  "verification": "Listar 3 funções específicas do parser em um compilador e citar um exemplo real.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação do GCC ou Clang",
                                    "Exemplos de gramáticas Yacc",
                                    "Vídeo tutorial sobre fases de compiladores"
                                  ],
                                  "tips": "Pratique com gramáticas simples para ver como parsers as processam.",
                                  "learningObjective": "Identificar o parsing como núcleo da fase sintática em compiladores.",
                                  "commonMistakes": [
                                    "Achar que parser faz otimização (isso é back-end)",
                                    "Confundir AST com parse tree",
                                    "Esquecer ambiguidade em gramáticas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Aplicações em Interpretadores",
                                  "subSteps": [
                                    "Comparar parsing em interpretadores vs compiladores (execução imediata).",
                                    "Exemplificar com Python CPython ou JavaScript V8 engine.",
                                    "Descrever parsing recursivo descendente em interpretadores simples.",
                                    "Discutir parsing em tempo real para linguagens dinâmicas.",
                                    "Enfatizar verificação de sintaxe antes da avaliação semântica."
                                  ],
                                  "verification": "Desenhar fluxo de um interpretador destacando o parser e testar com pseudocódigo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código fonte simplificado de interpretador (ex: Tiny Python)",
                                    "Diagramas de interpretadores REPL",
                                    "Ferramenta online como JSFiddle para JS"
                                  ],
                                  "tips": "Teste erros de sintaxe em um REPL para observar o parser em ação.",
                                  "learningObjective": "Reconhecer o parsing como pré-requisito para interpretação dinâmica.",
                                  "commonMistakes": [
                                    "Pensar que interpretadores pulam parsing",
                                    "Confundir avaliação com parsing",
                                    "Ignorar parsing em linguagens interpretadas modernas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar Verificadores de Linguagens Formais e Papel Teórico",
                                  "subSteps": [
                                    "Estudar verificadores como parsers para linguagens de especificação (ex: XML Schema).",
                                    "Explorar ferramentas como ANTLR para validação formal.",
                                    "Discutir teoremas: parsing decidível para CFLs via CYK ou Earley.",
                                    "Enfatizar contribuições na teoria da computação (pumps lemma, closure properties).",
                                    "Sintetizar aplicações unificadas e importância interdisciplinar."
                                  ],
                                  "verification": "Citar 2 teoremas relacionados e 1 verificador real, explicando o parsing.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo sobre algoritmo CYK",
                                    "Ferramenta ANTLR online",
                                    "Resumo da hierarquia de Chomsky"
                                  ],
                                  "tips": "Conecte teoria prática testando um parser gerado em gramática simples.",
                                  "learningObjective": "Enfatizar o parsing como pilar teórico-prático na computação formal.",
                                  "commonMistakes": [
                                    "Limitar a compiladores, ignorando verificadores",
                                    "Confundir decidibilidade com eficiência",
                                    "Subestimar ligações com teoria"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador como o GCC para C++, o parser G++ analisa sintaticamente o código após o scanner cpp, construindo uma AST para 'int main() { return 0; }', detectando erros como ponto-virgula faltante e validando contra gramática formal da linguagem.",
                              "finalVerifications": [
                                "Citar corretamente 3 aplicações principais do parsing (compiladores, interpretadores, verificadores).",
                                "Explicar o papel do parsing na teoria da computação com referência a autômatos ou gramáticas.",
                                "Identificar diferenças entre parsing em compiladores e interpretadores.",
                                "Fornecer exemplo concreto de parser em ferramenta real (ex: Yacc, ANTLR).",
                                "Discutir tratamento de erros sintáticos.",
                                "Relacionar parsing à hierarquia de Chomsky."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara de fases e contextos.",
                                "Profundidade teórica: menção a autômatos pushdown e propriedades de linguagens.",
                                "Exemplos relevantes: uso de ferramentas reais e cenários práticos.",
                                "Completude: cobertura de todas as aplicações solicitadas.",
                                "Clareza na ênfase: destaque ao papel na teoria da computação.",
                                "Criatividade: conexões interdisciplinares ou extensões lógicas."
                              ],
                              "crossCurricularConnections": [
                                "Linguística Computacional: parsing em PLN para análise de frases naturais.",
                                "Engenharia de Software: validação de DSLs (Domain-Specific Languages).",
                                "Inteligência Artificial: parsers em sistemas de query para bancos de dados.",
                                "Matemática Discreta: grafos e árvores de derivação em parsing."
                              ],
                              "realWorldApplication": "Browsers como Chrome usam parsers (ex: Blink) para analisar HTML/CSS/JS em tempo real, permitindo renderização web; ferramentas de linting como ESLint verificam sintaxe em editores VS Code, prevenindo erros em desenvolvimento de software."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.4",
                            "name": "Discutir Limitações Básicas do Parsing",
                            "description": "Apontar limitações iniciais do parsing, como ambiguidade em gramáticas e complexidade computacional para certos tipos de linguagens (ex.: não para linguagens regulares puras).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Ambiguidade em Gramáticas",
                                  "subSteps": [
                                    "Defina ambiguidade em gramáticas context-free (CFG): uma string tem mais de uma árvore de derivação esquerda-direita.",
                                    "Diferencie gramáticas ambíguas de inambíguas usando definições formais.",
                                    "Analise por que a ambiguidade afeta o parsing determinístico.",
                                    "Estude exemplos simples como a gramática de expressões aritméticas: E → E + E | E * E | id.",
                                    "Discuta implicações para reconhecimento de linguagens."
                                  ],
                                  "verification": "Crie uma gramática ambígua e demonstre duas derivações diferentes para a mesma string.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Editor de texto para gramáticas",
                                    "Ferramenta online de visualização de árvores de parsing (ex: JFLAP)"
                                  ],
                                  "tips": "Sempre reduza a gramática ao mínimo para isolar a ambiguidade.",
                                  "learningObjective": "Identificar e explicar ambiguidade em gramáticas formais.",
                                  "commonMistakes": [
                                    "Confundir ambiguidade sintática com semântica",
                                    "Ignorar derivações esquerda-direita específicas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Exemplos de Ambiguidade e suas Consequências",
                                  "subSteps": [
                                    "Construa uma gramática ambígua para expressões if-then-else.",
                                    "Gere árvores de parsing alternativas e compare resultados.",
                                    "Discuta como parsers LL(1) ou LR(1) falham em gramáticas ambíguas.",
                                    "Tente reescrever a gramática para torná-la inambígua.",
                                    "Avalie o impacto em compiladores reais."
                                  ],
                                  "verification": "Forneça um exemplo onde duas árvores levam a comportamentos diferentes e prove a ambiguidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "JFLAP ou parser generator online",
                                    "Papel e lápis para desenhar árvores",
                                    "Documentação de Yacc/Bison"
                                  ],
                                  "tips": "Use notação de árvores de derivação para visualização clara.",
                                  "learningObjective": "Aplicar conceitos de ambiguidade a exemplos concretos.",
                                  "commonMistakes": [
                                    "Assumir que toda CFG ambígua é inutilizável sem tentativa de desambiguação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Complexidade Computacional do Parsing",
                                  "subSteps": [
                                    "Revise classes de linguagens: regulares (O(n)), context-free (O(n^3) com CYK/ Earley).",
                                    "Explique por que parsing determinístico não cobre todas CFGs (LL(k)/LR(k) subsets).",
                                    "Discuta limitações para linguagens não regulares ou não context-free (ex: {a^n b^n c^n}).",
                                    "Calcule complexidades para algoritmos como CYK e compare com regex para regulares.",
                                    "Identifique casos onde parsing é intratável (ex: parsing universal é PSPACE-complete)."
                                  ],
                                  "verification": "Compare tempos de parsing para strings de comprimento n em diferentes algoritmos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha para cálculos de complexidade Big-O",
                                    "Implementação simples de CYK em Python",
                                    "Referências teóricas (Hopcroft/Ullman)"
                                  ],
                                  "tips": "Use tabelas para rastrear complexidades e evite confusão com reconhecimento.",
                                  "learningObjective": "Quantificar limitações computacionais do parsing.",
                                  "commonMistakes": [
                                    "Confundir complexidade de parsing com reconhecimento por pushdown automata"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Limitações e Implicações para Linguagens Formais",
                                  "subSteps": [
                                    "Resuma limitações: ambiguidade inerente, não-decidibilidade de inambiguidade, escalabilidade pobre.",
                                    "Discuta por que parsers não lidam bem com linguagens regulares puras via CFG (desnecessário, mas ilustrativo).",
                                    "Explore trade-offs: precisão vs. eficiência em compiladores.",
                                    "Conecte a hierarquia de Chomsky: parsing forte para Type-2, fraco para Type-0.",
                                    "Proponha soluções práticas como desambiguação heurística."
                                  ],
                                  "verification": "Escreva um relatório de 1 página listando 3 limitações com exemplos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Hierarquia de Chomsky diagram",
                                    "Artigos sobre parsing prático (ex: Dragon Book)"
                                  ],
                                  "tips": "Priorize limitações práticas sobre teóricas puras.",
                                  "learningObjective": "Integrar limitações em uma visão coesa do parsing.",
                                  "commonMistakes": [
                                    "Generalizar limitações de CFGs para todas linguagens formais"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise a gramática ambígua S → S + S | S * S | a para a string 'a + a * a'. Mostre duas árvores: ((a+a)*a) vs (a+(a*a)), destacando como um parser determinístico falharia sem regras de precedência, e calcule O(n^3) para CYK em strings longas.",
                              "finalVerifications": [
                                "Explica ambiguidade com exemplo próprio.",
                                "Identifica quando um parser LL/LR falha devido a ambiguidade.",
                                "Compara complexidades de parsing para diferentes classes de linguagens.",
                                "Lista limitações para linguagens não context-free.",
                                "Propõe uma desambiguação para uma gramática dada.",
                                "Discute impacto em compiladores reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ambiguidade (100% formal).",
                                "Profundidade de exemplos (múltiplas derivações mostradas).",
                                "Correção em análise de complexidade (Big-O exato).",
                                "Conexão clara com hierarquia de Chomsky.",
                                "Criatividade em soluções práticas.",
                                "Clareza na comunicação de limitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (árvores de parsing).",
                                "Programação: Implementação de parsers em linguagens como Python (PLY).",
                                "Lógica: Decidibilidade e não-decidibilidade em teoria da computação.",
                                "Engenharia de Software: Design de linguagens de programação inambíguas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou JavaCC, desenvolvedores usam gramáticas LR(1) inambíguas para evitar ambiguidades em expressões, e otimizam com parsers O(n) para sublinguagens regulares (lexers), lidando com complexidade O(n^3) apenas em casos raros para garantir performance em código real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Gramáticas Livres de Contexto",
                    "description": "Definição formal, Chomsky normal form e árvores de derivação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Definição Formal de Gramáticas Livres de Contexto",
                        "description": "Apresenta a definição precisa de uma gramática livre de contexto (GLC), incluindo seus componentes formais: conjunto de variáveis, terminais, regras de produção e símbolo inicial, além de exemplos e propriedades básicas como geração de linguagens.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Identificar os componentes de uma GLC",
                            "description": "Reconhecer e descrever os quatro componentes formais de uma gramática G = (V, Σ, P, S): variáveis não-terminais V, terminais Σ, conjunto de produções P e símbolo inicial S, com exemplos concretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Formal de uma Gramática Livre de Contexto (GLC)",
                                  "subSteps": [
                                    "Leia a definição formal: Uma GLC é uma 4-tupla G = (V, Σ, P, S).",
                                    "Explique o que cada letra representa: V para variáveis não-terminais, Σ para terminais, P para produções, S para símbolo inicial.",
                                    "Diferencie GLC de outros tipos de gramáticas, focando nos componentes universais das gramáticas formais."
                                  ],
                                  "verification": "Recite verbalmente ou por escrito a definição completa com os quatro componentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Teoria da Computação (ex: Sipser)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use mnemônicos como 'VΣPS' para memorizar a ordem da tupla.",
                                  "learningObjective": "Dominar a estrutura formal básica de uma GLC.",
                                  "commonMistakes": [
                                    "Confundir a ordem dos componentes ou inverter V e Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar os Componentes Terminais (Σ) e Não-Terminais (V)",
                                  "subSteps": [
                                    "Defina terminais Σ: alfabeto finito de símbolos que aparecem nas sentenças finais.",
                                    "Defina não-terminais V: variáveis que podem ser substituídas por produções.",
                                    "Liste exemplos: Σ = {a, b, +, *} para expressões; V = {E, T}."
                                  ],
                                  "verification": "Classifique 5 símbolos de um exemplo como terminal ou não-terminal corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas impressos ou digitais",
                                    "Quadro branco ou app de desenho"
                                  ],
                                  "tips": "Lembre-se: terminais são 'folhas' que não se expandem mais.",
                                  "learningObjective": "Distinguir precisamente entre símbolos terminais e não-terminais.",
                                  "commonMistakes": [
                                    "Incluir não-terminais em Σ ou vice-versa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Símbolo Inicial (S) e o Conjunto de Produções (P)",
                                  "subSteps": [
                                    "Identifique S: o não-terminal raiz de onde todas as derivações começam.",
                                    "Descreva P: conjunto finito de regras da forma α → β, onde α contém pelo menos um não-terminal.",
                                    "Escreva exemplos de produções: E → E + T | T."
                                  ],
                                  "verification": "Apresente uma lista de 3 produções válidas e indique o S correto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto ou LaTeX para notação formal",
                                    "Vídeos tutoriais sobre Chomsky Hierarchy"
                                  ],
                                  "tips": "Verifique se toda produção em P tem pelo menos um não-terminal no lado esquerdo.",
                                  "learningObjective": "Compreender o papel de S como ponto de partida e P como regras de reescrita.",
                                  "commonMistakes": [
                                    "Escolher S como terminal ou produções sem não-terminal à esquerda"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação Completa em Exemplos de GLC",
                                  "subSteps": [
                                    "Pegue uma gramática exemplo e extraia V, Σ, P, S.",
                                    "Crie uma tabela listando cada componente.",
                                    "Valide se a gramática é livre de contexto verificando as formas das produções."
                                  ],
                                  "verification": "Analise uma GLC fornecida e liste todos os componentes sem erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios de gramáticas de sites como GeeksforGeeks",
                                    "Planilha Excel para tabelas"
                                  ],
                                  "tips": "Sempre teste gerando uma derivação curta de S para validar.",
                                  "learningObjective": "Aplicar o conhecimento para decompor GLCs reais.",
                                  "commonMistakes": [
                                    "Omitir símbolos em V ou P, ou listar produções inválidas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Testar Conhecimento com Autoavaliação",
                                  "subSteps": [
                                    "Resuma os quatro componentes em um diagrama.",
                                    "Crie sua própria GLC simples e identifique seus componentes.",
                                    "Compare com exemplos padrão para validar."
                                  ],
                                  "verification": "Construa e decomponha uma GLC original corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação como Draw.io",
                                    "Flashcards personalizadas"
                                  ],
                                  "tips": "Use cores diferentes para V (azul), Σ (verde), etc., no diagrama.",
                                  "learningObjective": "Internalizar a identificação por síntese criativa.",
                                  "commonMistakes": [
                                    "Criar produções que violem regras de GLC"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a GLC para expressões aritméticas simples: G = ({E, T, F}, {a, +, *, (, )}, {E → E + T | T, T → T * F | F, F → (E) | a}, E). Aqui, V = {E, T, F} (não-terminais), Σ = {a, +, *, (, )} (terminais), P = as 5 regras listadas, S = E (inicial). Derive 'a + a' para validar.",
                              "finalVerifications": [
                                "Liste corretamente V, Σ, P e S de uma GLC dada.",
                                "Gere uma derivação válida a partir de S usando P.",
                                "Classifique todos os símbolos em V ou Σ sem erros.",
                                "Explique o papel de cada componente em uma sentença derivada.",
                                "Identifique se uma tupla dada forma uma GLC válida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os 4 componentes (100%).",
                                "Uso correto de notação formal em P (ex: α → β).",
                                "Exemplos fornecidos são válidos e concretos.",
                                "Explicações claras e concisas para cada componente.",
                                "Capacidade de validar uma GLC completa via derivação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (V e Σ como conjuntos finitos).",
                                "Linguística: Análise Sintática e Hierarquia de Chomsky.",
                                "Programação: Parsing em compiladores (ex: ANTLR usa GLCs).",
                                "Lógica: Regras de inferência semelhantes a produções."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens como Python ou Java, parsers bottom-up/top-down usam GLCs para validar sintaxe de código-fonte, identificando componentes para gerar árvores de parsing e detectar erros de programação em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Verificar se uma gramática é livre de contexto",
                            "description": "Analisar uma gramática dada e determinar se ela é livre de contexto, verificando se todas as produções têm a forma A → α, onde A ∈ V e α ∈ (V ∪ Σ)*, identificando violações comuns.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes da gramática",
                                  "subSteps": [
                                    "Leia a definição completa da gramática fornecida, incluindo não-terminais (V_N), terminais (Σ), símbolo inicial (S) e conjunto de produções (P).",
                                    "Liste todos os não-terminais (V_N) e terminais (Σ) explicitamente.",
                                    "Anote o símbolo inicial S e confirme que ele pertence a V_N.",
                                    "Enumere todas as produções em P de forma clara, numerando-as para referência.",
                                    "Crie uma tabela ou lista organizada com todos os componentes para visualização fácil."
                                  ],
                                  "verification": "Confirme que todos os componentes estão listados corretamente e sem omissões, comparando com a gramática original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Definição da gramática impressa ou digital"
                                  ],
                                  "tips": "Use símbolos maiúsculos para não-terminais e minúsculos para terminais como convenção padrão.",
                                  "learningObjective": "Compreender a estrutura formal de uma gramática e extrair seus componentes com precisão.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Omitir produções alternativas",
                                    "Esquecer o símbolo inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar o lado esquerdo (LHS) de cada produção",
                                  "subSteps": [
                                    "Para cada produção em P, isole o lado esquerdo (antes da seta →).",
                                    "Verifique se o LHS consiste exatamente em UM único não-terminal (A ∈ V_N).",
                                    "Identifique se há violações: múltiplos símbolos no LHS, terminais no LHS ou LHS vazio.",
                                    "Marque cada produção como 'válida' ou 'inválida' no LHS e anote o motivo da invalidação.",
                                    "Conte o número total de produções inválidas no LHS."
                                  ],
                                  "verification": "Todas as produções têm LHS marcado corretamente; liste violações específicas se houver.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de componentes do Step 1",
                                    "Marcadores ou highlights no editor"
                                  ],
                                  "tips": "Lembre-se: LHS deve ser EXATAMENTE um não-terminal, como 'S →' ou 'A →', nunca 'AB →' ou 'a →'.",
                                  "learningObjective": "Dominar a regra fundamental do LHS em gramáticas livres de contexto.",
                                  "commonMistakes": [
                                    "Permitir LHS com terminais",
                                    "Ignorar produções com múltiplos não-terminais à esquerda",
                                    "Confundir ε com LHS inválido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar o lado direito (RHS) de cada produção",
                                  "subSteps": [
                                    "Para cada produção válida no LHS, examine o RHS (após a seta →).",
                                    "Confirme que o RHS é uma string finita sobre (V_N ∪ Σ)*, incluindo ε (string vazia).",
                                    "Verifique se todos os símbolos no RHS são conhecidos (de V_N ou Σ); sinalize símbolos desconhecidos.",
                                    "Note se há restrições adicionais como unitárias ou ε-produções, mas confirme que são permitidas em CFG básica.",
                                    "Atualize a marcação de cada produção considerando tanto LHS quanto RHS."
                                  ],
                                  "verification": "Registre status final de cada produção; gramática é CFG só se TODAS passarem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista atualizada do Step 2",
                                    "Tabela de V_N e Σ"
                                  ],
                                  "tips": "RHS pode ser vazio (S → ε) ou unitário (A → B), desde que B ∈ V_N.",
                                  "learningObjective": "Garantir que o RHS atenda à definição formal de CFG sem restrições extras.",
                                  "commonMistakes": [
                                    "Rejeitar ε-produções como inválidas",
                                    "Aceitar símbolos fora de V_N ∪ Σ",
                                    "Confundir unitárias com violações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a análise e justificar a classificação",
                                  "subSteps": [
                                    "Revise todas as produções: se TODAS satisfazem LHS = A ∈ V_N e RHS ∈ (V_N ∪ Σ)*, classifique como CFG.",
                                    "Liste todas as violações encontradas com referências às produções específicas.",
                                    "Escreva uma justificativa concisa explicando a decisão final.",
                                    "Teste com uma produção marginal, como ε ou unitária, para confirmar entendimento.",
                                    "Documente o resultado final: 'É CFG' ou 'Não é CFG' com evidências."
                                  ],
                                  "verification": "Justificativa escrita cobre todos os pontos e matches com análise anterior.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Análise completa dos Steps 1-3"
                                  ],
                                  "tips": "Se houver qualquer violação, a gramática NÃO é CFG; seja absoluto.",
                                  "learningObjective": "Sintetizar a análise em uma conclusão formal e defensável.",
                                  "commonMistakes": [
                                    "Classificar como CFG apesar de uma violação",
                                    "Faltar justificativa detalhada",
                                    "Ignorar o símbolo inicial em S ∈ V_N"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática G1: V_N = {S}, Σ = {a,b}, S = S, P = {S → aS | b}. Análise: Todas produções têm LHS = S (único VN), RHS = aS ou b (em (V_N ∪ Σ)*). É CFG. Gramática G2: V_N = {S}, Σ = {a,b}, P = {a → S | b}. Análise: LHS 'a' é terminal, violação. Não é CFG.",
                              "finalVerifications": [
                                "Todas as produções têm exatamente um não-terminal no LHS?",
                                "Nenhum LHS contém terminais ou múltiplos símbolos?",
                                "Todos os símbolos no RHS pertencem a V_N ∪ Σ?",
                                "Símbolo inicial S está em V_N?",
                                "Nenhuma produção foi omitida na análise?",
                                "Justificativa cobre todas as produções?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (100% corretos).",
                                "Detecção correta de violações em todas as produções.",
                                "Substeps completos e acionáveis em cada step.",
                                "Justificativa lógica e completa sem ambiguidades.",
                                "Uso correto de terminologia formal (V_N, Σ, etc.).",
                                "Análise de exemplos marginais como ε-produções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e linguagens formais.",
                                "Programação: Parsing em compiladores (ex: Yacc/Bison).",
                                "Lógica: Verificação de propriedades formais em autômatos.",
                                "Engenharia de Software: Validação de gramáticas em DSLs."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens de programação (ex: Python, Java), verificar se a gramática do parser é CFG para aplicar algoritmos como CYK ou Earley, garantindo análise sintática eficiente em ferramentas como ANTLR."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Gerar palavras a partir de uma GLC",
                            "description": "Aplicar sequências de substituições a partir do símbolo inicial para derivar palavras terminais em uma GLC, distinguindo derivações esquerdas e direitas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura formal de uma GLC",
                                  "subSteps": [
                                    "Identifique o conjunto de variáveis (não-terminais) V.",
                                    "Liste os terminais Σ.",
                                    "Determine o símbolo inicial S.",
                                    "Enumere todas as produções P no formato α → β, onde α ∈ V e β ∈ (V ∪ Σ)*.",
                                    "Verifique se cada produção é válida (α é um único não-terminal)."
                                  ],
                                  "verification": "Liste corretamente todos os componentes V, Σ, P e S sem erros de classificação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Definição formal de GLC",
                                    "Exemplo de gramática anotada",
                                    "Papel e caneta para diagramar"
                                  ],
                                  "tips": "Use notação padrão: G = (V, Σ, P, S). Destaque não-terminais em maiúsculas.",
                                  "learningObjective": "Dominar os elementos constitutivos de uma gramática livre de contexto.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Omitir o símbolo inicial",
                                    "Listar produções incompletas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar derivação esquerda para gerar uma palavra",
                                  "subSteps": [
                                    "Inicie com a sentença inicial: apenas o símbolo S.",
                                    "Identifique o não-terminal mais à esquerda na sentença atual.",
                                    "Escolha uma produção aplicável para esse não-terminal e substitua-o pela RHS.",
                                    "Repita os passos 2-3 até que a sentença contenha apenas terminais.",
                                    "Registre cada sentença intermediária com setas ⇒."
                                  ],
                                  "verification": "A derivação resulta em uma palavra terminal e cada substituição afeta o leftmost non-terminal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gramática exemplo",
                                    "Folha de exercícios com GLCs simples",
                                    "Calculadora para contar passos se necessário"
                                  ],
                                  "tips": "Sempre priorize o não-terminal mais à esquerda; anote a produção usada em cada passo.",
                                  "learningObjective": "Aplicar corretamente o processo de derivação esquerda passo a passo.",
                                  "commonMistakes": [
                                    "Substituir non-terminal errado (não o mais à esquerda)",
                                    "Parar prematuramente com non-terminais restantes",
                                    "Escolher produções inválidas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar derivação direita para a mesma palavra",
                                  "subSteps": [
                                    "Inicie novamente com o símbolo S.",
                                    "Identifique o não-terminal mais à direita na sentença atual.",
                                    "Aplique uma produção ao rightmost non-terminal, substituindo pela RHS.",
                                    "Continue substituindo o novo rightmost non-terminal até obter apenas terminais.",
                                    "Compare com a derivação esquerda para a mesma palavra terminal."
                                  ],
                                  "verification": "A derivação direita produz a mesma palavra terminal, com substituições sempre no rightmost non-terminal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesma gramática do passo anterior",
                                    "Tabela comparativa esquerda/direita",
                                    "Ferramenta online de visualização de derivações (opcional)"
                                  ],
                                  "tips": "Na sentença, conte da direita para a esquerda para achar o rightmost non-terminal.",
                                  "learningObjective": "Distinguir e executar derivação direita de forma precisa.",
                                  "commonMistakes": [
                                    "Confundir ordem de substituição com esquerda",
                                    "Alterar a ordem das substituições para combinar com esquerda",
                                    "Gerar palavra diferente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e analisar as derivações geradas",
                                  "subSteps": [
                                    "Confirme que ambas as derivações terminam na mesma palavra terminal.",
                                    "Identifique diferenças na sequência de sentenças intermediárias.",
                                    "Construa a árvore de derivação para cada uma (opcional, mas recomendado).",
                                    "Verifique se a palavra pertence à linguagem gerada pela GLC.",
                                    "Discuta quando uma derivação pode falhar (produções exaustivas)."
                                  ],
                                  "verification": "Ambas derivações são válidas, distinguíveis e levam à mesma palavra terminal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Derivações anotadas dos passos anteriores",
                                    "Modelo de árvore de derivação"
                                  ],
                                  "tips": "Use cores diferentes para esquerda (azul) e direita (vermelho) ao comparar.",
                                  "learningObjective": "Analisar e validar derivações, destacando diferenças entre esquerda e direita.",
                                  "commonMistakes": [
                                    "Ignorar diferenças entre esquerda e direita",
                                    "Aceitar derivações que deixam non-terminais",
                                    "Concluir que derivam sempre a mesma sequência"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática G = ({S, A}, {a, b}, P, S) com P: S → A b | a A, A → a | b.\nPara gerar 'a b':\nDerivação esquerda: S ⇒ a A ⇒ a b.\nDerivação direita: S ⇒ A b ⇒ a b (rightmost A substituído primeiro).\nNote as sequências intermediárias diferentes: esquerda passa por 'a A', direita por 'A b'.",
                              "finalVerifications": [
                                "Lista corretamente todos os componentes de uma GLC dada.",
                                "Executa derivação esquerda sem erros para uma palavra alvo.",
                                "Executa derivação direita corretamente para a mesma palavra.",
                                "Identifica e explica diferenças entre derivações esquerda e direita.",
                                "Valida que a palavra final é terminal e pertence à L(G).",
                                "Registra todas as sentenças intermediárias com precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do leftmost/rightmost non-terminal em cada passo (90%+ correto).",
                                "Escolha apropriada de produções levando à palavra desejada.",
                                "Registro completo e legível de todas as sentenças intermediárias.",
                                "Distinção clara entre derivações esquerda e direita.",
                                "Ausência de non-terminais na palavra final.",
                                "Análise coerente das diferenças observadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação como árvores de derivação e teoria de grafos.",
                                "Linguística: Analogia com regras sintáticas em gramáticas naturais.",
                                "Programação: Base para implementações de parsers LL (esquerda) e LR (direita).",
                                "Lógica: Sequências de substituições como provas em sistemas formais."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, derivações esquerda/direita são usadas em parsers recursivos descendentes (top-down, esquerda) e shift-reduce (bottom-up, direita) para analisar sintaxe de linguagens de programação, validando código fonte e gerando árvores de sintaxe abstrata (AST)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Forma Normal de Chomsky",
                        "description": "Explica a Forma Normal de Chomsky (FNC) para GLCs, onde todas as produções são da forma A → BC ou A → a, e detalha o algoritmo de conversão para simplificar análises sintáticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Reconhecer uma gramática em Forma Normal de Chomsky",
                            "description": "Identificar se uma GLC está em FNC, verificando que produções unitárias foram eliminadas e todas as regras são A → BC (com B, C variáveis distintas de S) ou A → a (terminal único).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal de Forma Normal de Chomsky (FNC)",
                                  "subSteps": [
                                    "Leia a definição precisa: uma GLC está em FNC se todas as produções são A → BC (B e C variáveis não-terminais distintas de S) ou A → a (a terminal único), sem produções unitárias ou ε-produções (exceto possivelmente S → ε).",
                                    "Identifique os componentes chave: símbolo inicial S, variáveis, terminais e restrições sobre S no lado direito.",
                                    "Anote as quatro condições principais: (1) sem unitárias, (2) sem ε (geral), (3) formas A→BC ou A→a, (4) S não no RHS.",
                                    "Compare com outras formas normais como Forma Normal de Greibach para diferenciar.",
                                    "Resuma em um fluxograma mental as regras permitidas vs. proibidas."
                                  ],
                                  "verification": "Escreva um resumo da definição com as 4 condições principais sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Definição de FNC de livro-texto ou notas de aula",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": [
                                    "Memorize as formas exatas A→BC e A→a como 'duas variáveis ou um terminal'.",
                                    "Use mnemônicos: 'Chomsky: Dois Companheiros (BC) ou Um Terminal (a)'."
                                  ],
                                  "learningObjective": "Dominar os critérios exatos que definem uma gramática em FNC.",
                                  "commonMistakes": [
                                    "Confundir FNC com FNG (que permite A→aA).",
                                    "Esquecer que B e C devem ser ≠ S, mesmo em A→BC."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar a gramática para análise",
                                  "subSteps": [
                                    "Identifique o símbolo inicial S na gramática dada.",
                                    "Liste todas as produções de forma tabular: coluna para cabeça (A), coluna para corpo.",
                                    "Classifique terminais (folhas) vs. variáveis (nós internos).",
                                    "Marque o símbolo inicial S em todas as listas.",
                                    "Verifique se a gramática é GLC válida (produções A → α com α cadeia de símbolos)."
                                  ],
                                  "verification": "Crie uma tabela completa de todas as produções com S destacado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gramática exemplo impressa ou digital",
                                    "Planilha ou papel quadriculado para tabela"
                                  ],
                                  "tips": [
                                    "Sempre comece listando: isso previne erros de contagem.",
                                    "Use cores: vermelho para S, azul para terminais."
                                  ],
                                  "learningObjective": "Organizar a gramática para inspeção sistemática.",
                                  "commonMistakes": [
                                    "Não notar se S é explicitamente definido.",
                                    "Pular produções recursivas na listagem."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar ausência de produções unitárias e ε-produções",
                                  "subSteps": [
                                    "Inspecione cada produção: se corpo tem exatamente uma variável (A → B), marque como unitária.",
                                    "Se corpo vazio (A → ε), marque como ε-produção (permitida só se A=S e única).",
                                    "Conte e liste todas unitárias e ε encontradas.",
                                    "Confirme: zero unitárias e zero ε (exceto S→ε se aplicável).",
                                    "Registre violações com exemplos específicos."
                                  ],
                                  "verification": "Liste todas produções unitárias/ε encontradas ou confirme 'nenhuma' com justificativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela da Step 2",
                                    "Marcadores coloridos"
                                  ],
                                  "tips": [
                                    "Unitária: corpo | =1 e só variável. ε: corpo vazio.",
                                    "Cheque duplamente: leia em voz alta cada produção."
                                  ],
                                  "learningObjective": "Detectar e eliminar produções proibidas em FNC.",
                                  "commonMistakes": [
                                    "Confundir A→a (terminal) com unitária.",
                                    "Permitir múltiplas ε-produções."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar formas das produções e restrições sobre S",
                                  "subSteps": [
                                    "Para cada produção não-unitária/ε: corpo tem 1 símbolo? Deve ser terminal único (A→a).",
                                    "Corpo tem 2 símbolos? Devem ser ambos variáveis (A→BC), B≠C? Não necessariamente distintos, mas ambos vars.",
                                    "Corpo >2 ou misto (vars+terms)? Inválido.",
                                    "Global: busque S em qualquer RHS; se achar, inválido.",
                                    "Compile relatório: todas OK? Sim/Não com violações listadas."
                                  ],
                                  "verification": "Produza um relatório final: 'Em FNC: Sim/Não' + lista de violações ou confirmações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela atualizada da Step 2",
                                    "Lista de verificações checklist"
                                  ],
                                  "tips": [
                                    "Checklist: |corpo|=1? terminal? |corpo|=2? vars? S no RHS?",
                                    "Processe produção por produção, não global."
                                  ],
                                  "learningObjective": "Aplicar regras de forma e restrições para confirmação de FNC.",
                                  "commonMistakes": [
                                    "Permitir A→aB (misto).",
                                    "Ignorar S em RHS profundo como S→AB, A→S."
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática G1: S→AB|A, A→a, B→b. Análise: S→AB (BC ok, B=A≠S,C=B≠S), S→A (unitária! Violação). Não FNC. G2: S→AB, A→a, B→b. Todas A→BC ou A→a, sem unitárias, S não em RHS. FNC. Use CYK para testar parsing eficiente.",
                              "finalVerifications": [
                                "Liste as 4 condições de FNC sem erros.",
                                "Analise 3 gramáticas exemplo: 2 FNC, 1 não, corretamente.",
                                "Explique por que S não pode estar em RHS.",
                                "Identifique unitária em gramática complexa.",
                                "Confirme FNC em parser CYK simulado."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% na detecção de violações.",
                                "Explicação clara de cada regra aplicada.",
                                "Análise de pelo menos 5 produções sem erros.",
                                "Tempo de análise <5 min por gramática média.",
                                "Capacidade de corrigir gramática para FNC."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Verificação de propriedades em autômatos finitos e grafos de dependência.",
                                "Lógica: Provas por casos exaustivos em teoremas formais.",
                                "Programação: Implementação de algoritmos de validação em Python para gramáticas.",
                                "Linguística Computacional: Modelagem de linguagens naturais em parsers."
                              ],
                              "realWorldApplication": "Em compiladores (ex: GCC, JavaCC), gramáticas em FNC habilitam o algoritmo CYK para parsing O(n^3) eficiente, essencial para análise sintática em linguagens de programação e NLP."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Eliminar produções unitárias em uma GLC",
                            "description": "Aplicar o algoritmo para remover produções do tipo A → B, substituindo-as por todas as produções de B, evitando ciclos e preservando a linguagem gerada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar todas as produções unitárias na gramática",
                                  "subSteps": [
                                    "Liste todas as regras da gramática no formato A → α.",
                                    "Classifique cada produção: unitária se α é um único não-terminal (ex: A → B).",
                                    "Crie uma lista separada de todas as produções unitárias e não-unitárias.",
                                    "Marque os não-terminais envolvidos em unitárias como 'suspeitos'.",
                                    "Verifique se há ciclos óbvios (A → B → A) anotando-os."
                                  ],
                                  "verification": "Lista completa de produções unitárias identificadas e separadas das demais, sem erros de classificação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Definição da gramática de exemplo"
                                  ],
                                  "tips": "Comece pelas variáveis iniciais e percorra alfabeticamente para evitar omissões.",
                                  "learningObjective": "Reconhecer e isolar produções unitárias com precisão.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Ignorar produções como A → ε (vazia, não unitária)",
                                    "Marcar A → aB como unitária"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o conjunto de variáveis alcançáveis via produções unitárias",
                                  "subSteps": [
                                    "Crie um grafo direcionado onde arestas A → B existem para cada unitária A → B.",
                                    "Para cada não-terminal A, compute o conjunto UnitReach(A): todos B alcançáveis de A via caminhos unitários (use DFS ou BFS).",
                                    "Exclua ciclos: se A alcança a si mesmo, anote mas prossiga sem adicionar auto-produções.",
                                    "Liste para cada A: UnitReach(A) = {B1, B2, ..., Bk} onde cada Bi tem pelo menos uma não-unitária.",
                                    "Valide o grafo: verifique conectividade e ausência de loops infinitos."
                                  ],
                                  "verification": "Tabela ou lista mostrando UnitReach(A) para cada A com unitárias, confirmada por rastreamento manual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de grafos como Graphviz ou papel para desenhar",
                                    "Lista de unitárias do passo 1"
                                  ],
                                  "tips": "Use matriz de adjacência para gramáticas pequenas; implemente recursão memoizada para eficiência.",
                                  "learningObjective": "Modelar dependências unitárias como grafo e computar fechamento transitivo.",
                                  "commonMistakes": [
                                    "Não propagar transições múltiplas (ex: A→B→C ignora C)",
                                    "Incluir o próprio A em UnitReach sem ciclo",
                                    "Esquecer variáveis sem unitárias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir produções unitárias pelas não-unitárias equivalentes",
                                  "subSteps": [
                                    "Para cada A com unitárias, e para cada B em UnitReach(A): adicione A → γ para toda não-unitária B → γ.",
                                    "Evite duplicatas: use conjunto para rastrear novas produções de A.",
                                    "Copie todas as produções não-unitárias originais inalteradas.",
                                    "Não adicione produções de variáveis fora de UnitReach.",
                                    "Anote novas produções adicionadas para cada A."
                                  ],
                                  "verification": "Nova gramática com produções expandidas listadas, sem duplicatas ou omissões.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou editor para listar produções",
                                    "UnitReach do passo 2"
                                  ],
                                  "tips": "Processe variáveis em ordem topológica do grafo para evitar redundâncias.",
                                  "learningObjective": "Expandir corretamente preservando a linguagem gerada por cada não-terminal.",
                                  "commonMistakes": [
                                    "Adicionar unitárias nas expansões",
                                    "Duplicar produções existentes",
                                    "Expandir para B não alcançável"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Remover produções unitárias e validar a gramática resultante",
                                  "subSteps": [
                                    "Delete todas as produções unitárias originais da gramática expandida.",
                                    "Escaneie a gramática final: confirme zero produções unitárias.",
                                    "Teste equivalência: derive manualmente 3-5 sentenças chave da original e reproduza na nova.",
                                    "Verifique preservação: L(G') = L(G), sem ciclos introduzidos.",
                                    "Opcional: normalize ε-produções se presentes, mas foque em unitárias."
                                  ],
                                  "verification": "Gramática final sem unitárias, com derivações equivalentes comprovadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gramática expandida do passo 3",
                                    "Exemplos de derivações"
                                  ],
                                  "tips": "Salve cópias antes/depois para comparação lado a lado.",
                                  "learningObjective": "Finalizar remoção garantindo equivalência linguística.",
                                  "commonMistakes": [
                                    "Esquecer de remover alguma unitária",
                                    "Perder produções não-unitárias originais",
                                    "Introduzir novas unitárias acidentalmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática original: S → A | B, A → a | C, C → c, B → b. Unitárias: S→A? Não, A→C sim. UnitReach(A)={C}. Nova para A: A → a | c. Final: S → A | B, A → a | c, C → c (mas C pode ser mantida se usada), B → b. Remover A→C. L(S) preservada: gera a,b,c.",
                              "finalVerifications": [
                                "Nenhuma produção unitária (A → B) permanece na gramática.",
                                "Para cada não-terminal original A, L(A) na nova gramática iguala a original.",
                                "Todas produções não-unitárias originais intactas.",
                                "Sem duplicatas de produções.",
                                "Grafo de unitárias vazio (zero arestas).",
                                "Derivações de sentenças de teste idênticas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de unitárias (100% corretas).",
                                "Correção do UnitReach (todos alcançáveis listados sem erros).",
                                "Expansões sem duplicatas ou omissões (verificação manual).",
                                "Preservação da linguagem comprovada por exemplos.",
                                "Gramática final livre de unitárias.",
                                "Eficiência: sem produções desnecessárias adicionadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (fechamento transitivo, DFS/BFS).",
                                "Engenharia de Software: Refatoração de código (eliminar dependências circulares).",
                                "Compiladores: Pré-processamento para CYK ou Earley parsing.",
                                "Lógica: Equivalência de sistemas formais."
                              ],
                              "realWorldApplication": "Em compiladores, remover unitárias é passo essencial para converter GLCs à Forma Normal de Chomsky, permitindo parsing eficiente em ferramentas como yacc/bison ou analisadores sintáticos de linguagens de programação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Converter uma GLC para Forma Normal de Chomsky",
                            "description": "Executar o processo completo de conversão: eliminar ε-produções, produções unitárias e substituir produções com mais de dois símbolos por equivalentes binários, usando exemplos passo a passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Eliminar Produções Vazias (ε-produções)",
                                  "subSteps": [
                                    "Identifique todas as variáveis anuláveis (nullable): comece com variáveis que têm produção direta para ε e itere adicionando variáveis que derivam para anuláveis.",
                                    "Para cada produção A → α (onde α pode conter anuláveis), gere todas as combinações possíveis removendo anuláveis um de cada vez, incluindo a versão sem remoções.",
                                    "Adicione as novas produções ao conjunto de regras, garantindo que não haja duplicatas.",
                                    "Remova todas as produções originais que eram ε-produções.",
                                    "Verifique se a gramática ainda gera a mesma linguagem (exceto possivelmente a palavra vazia)."
                                  ],
                                  "verification": "Confirme que nenhuma regra termina em ε e que todas as combinações de anuláveis foram geradas corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis ou editor de texto",
                                    "Exemplo de gramática inicial"
                                  ],
                                  "tips": "Use um conjunto para rastrear anuláveis e evite loops infinitos na iteração.",
                                  "learningObjective": "Dominar o algoritmo de eliminação de ε-produções preservando a linguagem gerada.",
                                  "commonMistakes": [
                                    "Esquecer combinações múltiplas de anuláveis",
                                    "Remover ε sem adicionar alternativas",
                                    "Incluir ε novamente acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Eliminar Produções Unitárias",
                                  "subSteps": [
                                    "Identifique todas as produções unitárias (A → B, onde B é uma variável).",
                                    "Para cada unitária A → B, substitua por todas as produções de B: A → γ para cada B → γ onde γ não é unitária.",
                                    "Remova as produções unitárias originais.",
                                    "Repita o processo até que não haja mais unitárias.",
                                    "Use um grafo de dependências para evitar ciclos e garantir terminação."
                                  ],
                                  "verification": "Verifique que não existe nenhuma regra A → B onde B é uma única variável não-terminal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto ou planilha para rastrear substituições",
                                    "Gramática pós-ε-eliminação"
                                  ],
                                  "tips": "Mantenha uma lista de produções não-unitárias para cada variável para agilizar substituições.",
                                  "learningObjective": "Aplicar o algoritmo de remoção de unitárias sem alterar a linguagem.",
                                  "commonMistakes": [
                                    "Não substituir recursivamente em cadeias unitárias",
                                    "Criar loops infinitos por substituições cíclicas",
                                    "Duplicar regras desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter Produções para Forma Binária",
                                  "subSteps": [
                                    "Identifique regras com mais de dois símbolos no lado direito (A → X1 X2 ... Xk, k>2).",
                                    "Para cada tal regra, introduza novas variáveis: A → X1 B1, B1 → X2 B2, ..., B_{k-2} → X_{k-1} Xk.",
                                    "Se Xi for terminal, crie uma regra auxiliar C → Xi e substitua por C.",
                                    "Adicione todas as novas regras e remova as originais longas.",
                                    "Verifique que todas as regras agora têm no máximo dois símbolos no lado direito."
                                  ],
                                  "verification": "Confirme que todo lado direito é ou um terminal, ou duas variáveis, ou variável-terminal.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel milimetrado para diagramas",
                                    "Gramática pós-unitárias"
                                  ],
                                  "tips": "Nomeie novas variáveis de forma sistemática como A1, A2 para evitar confusão.",
                                  "learningObjective": "Transformar gramáticas em Chomsky Normal Form para compatibilidade com algoritmos de parsing.",
                                  "commonMistakes": [
                                    "Esquecer de binarizar regras com terminais mistos",
                                    "Não criar auxiliares para terminais isolados",
                                    "Perder símbolos no encadeamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação Final da Forma Normal de Chomsky",
                                  "subSteps": [
                                    "Revise todas as regras: sem ε (exceto possivelmente S→ε), sem unitárias, no máximo dois símbolos no RHS.",
                                    "Teste a gramática convertida gerando algumas strings originais para validar equivalência.",
                                    "Compare o número de regras e variáveis com o esperado.",
                                    "Documente mudanças em cada passo para auditoria.",
                                    "Otimize removendo variáveis inutilizáveis se necessário."
                                  ],
                                  "verification": "A gramática satisfaz todas as condições CNF e gera as mesmas strings não-vazias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de teste de gramáticas (opcional, como Python com NLTK)"
                                  ],
                                  "tips": "Use tabelas para listar antes/depois de cada transformação.",
                                  "learningObjective": "Validar a conversão completa para CNF.",
                                  "commonMistakes": [
                                    "Ignorar S→ε permitido",
                                    "Não testar equivalência",
                                    "Deixar regras inválidas"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática inicial: S → aS | ε | AB, A → aA | ε, B → bB | ε. Após ε-eliminação: S → aS | AB | A | B | ε, A → aA | ε, B → bB | ε (ajustado). Pós-unitárias: expande. Pós-binarização: introduz C → a, D → b, etc., resultando em regras binárias como S → a S | A B | A | B | ε.",
                              "finalVerifications": [
                                "Nenhuma produção ε exceto possivelmente S → ε.",
                                "Nenhuma produção unitária A → B.",
                                "Todo RHS tem exatamente dois não-terminais ou um terminal ou dois (terminal-variável).",
                                "Novas variáveis introduzidas não violam regras.",
                                "Gramática gera strings originais (teste 3-5 exemplos).",
                                "Sem variáveis inutilizáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na eliminação de ε-produções (todas combinações geradas).",
                                "Correta substituição de unitárias sem loops.",
                                "Binarização completa sem perda de símbolos.",
                                "Equivalência linguística preservada.",
                                "Documentação clara de passos.",
                                "Eficiência (mínimas novas regras)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos para dependências unitárias.",
                                "Linguística: Análise sintática em gramáticas naturais.",
                                "Engenharia de Software: Parsing em compiladores (ex: Yacc/Bison).",
                                "Inteligência Artificial: Modelos probabilísticos de linguagem (PCFGs em CNF)."
                              ],
                              "realWorldApplication": "Essencial para algoritmos de parsing eficientes como Cocke-Younger-Kasami (CYK), usados em compiladores de linguagens de programação, analisadores sintáticos em NLP e verificadores de protocolos em sistemas distribuídos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1",
                              "10.1.4.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Árvores de Derivação",
                        "description": "Descreve as árvores de derivação (ou árvores de análise) para GLCs, representando graficamente derivações leftmost/rightmost e detectando ambiguidade em gramáticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Construir uma árvore de derivação leftmost",
                            "description": "Dado uma palavra e uma GLC, construir a árvore de derivação esquerda, expandindo sempre o terminal mais à esquerda não-terminal em cada passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Gramática Livre de Contexto (GLC) e a Palavra-Alvo",
                                  "subSteps": [
                                    "Escreva formalmente a gramática G = (V, Σ, P, S), identificando variáveis (V), terminais (Σ), axioma S e produções P.",
                                    "Liste todos os símbolos terminais e não-terminais claramente.",
                                    "Confirme que a palavra w pertence a Σ* (composta apenas por terminais).",
                                    "Identifique o símbolo inicial S e verifique se w é não-vazia ou trate casos especiais como ε.",
                                    "Anote as produções aplicáveis a cada não-terminal."
                                  ],
                                  "verification": "Checklist completo: gramática escrita corretamente, símbolos classificados e w validada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou quadro branco"
                                  ],
                                  "tips": "Use tabelas para organizar V, Σ e P para visualização rápida.",
                                  "learningObjective": "Compreender a estrutura formal da GLC e preparar para derivação.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Esquecer o axioma S",
                                    "Não verificar se w usa apenas terminais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iniciar a Derivação Leftmost com o Símbolo Inicial",
                                  "subSteps": [
                                    "Comece com α0 = S (sentença inicial).",
                                    "Identifique o não-terminal mais à esquerda em α0, que é S.",
                                    "Escolha uma produção S → γ aplicável e substitua: α1 = γ.",
                                    "Registre a derivação: α0 ⇒ α1.",
                                    "Verifique se α1 contém terminais iniciais que combinem com o prefixo de w."
                                  ],
                                  "verification": "Primeira derivação registrada corretamente e prefixo de α1 matches prefixo de w.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado para alinhar derivações",
                                    "Ferramenta online como LaTeX para notação"
                                  ],
                                  "tips": "Sempre expanda o NT mais à esquerda, mesmo se houver opções múltiplas (escolha uma que avance).",
                                  "learningObjective": "Executar o primeiro passo da derivação leftmost corretamente.",
                                  "commonMistakes": [
                                    "Expandir NT não-leftmost",
                                    "Usar produção inválida",
                                    "Não registrar a seta de derivação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir Iterativamente o Não-Terminal Mais à Esquerda",
                                  "subSteps": [
                                    "Em αi, localize o NT mais à esquerda (primeiro NT da esquerda para direita).",
                                    "Aplique uma produção apropriada para esse NT, gerando α(i+1).",
                                    "Registre αi ⇒ α(i+1) e verifique se o prefixo terminal de α(i+1) matches mais de w.",
                                    "Repita até que αk consista apenas em terminais e αk = w.",
                                    "Se falhar, backtrack e tente outra produção (registre tentativas).",
                                    "Conte o número de passos e liste todas as αi."
                                  ],
                                  "verification": "Sequência completa de derivações termina em w, com expansões sempre leftmost.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para colunas de derivações",
                                    "Software de desenho para protótipo de árvore"
                                  ],
                                  "tips": "Alinhe derivações em colunas para visualizar o leftmost NT destacado.",
                                  "learningObjective": "Dominar a iteração da derivação leftmost até a palavra-alvo.",
                                  "commonMistakes": [
                                    "Pular NTs à esquerda",
                                    "Expandir terminais",
                                    "Não backtrack em becos sem saída"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a Árvore de Derivação Leftmost",
                                  "subSteps": [
                                    "Use a sequência de derivações para criar nós: raiz é S.",
                                    "Para cada ⇒, adicione filhos ao NT expandido conforme a produção.",
                                    "Conecte left-to-right: esquerda para símbolos à esquerda, etc.",
                                    "Folhas devem formar w da esquerda para direita.",
                                    "Desenhe ramificações mostrando expansões leftmost em ordem.",
                                    "Rotule arestas com símbolos e verifique balanceamento."
                                  ],
                                  "verification": "Árvore desenhada onde leitura das folhas esquerda-direita é w, e caminhos refletem derivações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como draw.io ou papel",
                                    "Sequência de derivações do passo 3"
                                  ],
                                  "tips": "Construa de cima para baixo, expandindo um nó por vez seguindo a ordem leftmost.",
                                  "learningObjective": "Mapear derivação linear em estrutura hierárquica de árvore.",
                                  "commonMistakes": [
                                    "Ordem errada de filhos",
                                    "Folhas não matching w",
                                    "Confundir com rightmost tree"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar a Árvore e a Derivação Completa",
                                  "subSteps": [
                                    "Trace a derivação da árvore: leia leftmost paths para recriar α0 a αk.",
                                    "Confirme que toda expansão foi leftmost (sempre próximo NT à esquerda).",
                                    "Verifique ausência de NTs pendentes e folhas = w.",
                                    "Teste com variação de w ou produção alternativa se aplicável.",
                                    "Documente a árvore final com legenda."
                                  ],
                                  "verification": "Derivação reconstruída da árvore matches a manual, e w derivada corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Árvore desenhada",
                                    "Lista de verificações"
                                  ],
                                  "tips": "Use seta para baixo na árvore para simular derivações leftmost.",
                                  "learningObjective": "Garantir correção e robustez da construção.",
                                  "commonMistakes": [
                                    "Ignorar validação de folhas",
                                    "Não checar ordem leftmost",
                                    "Erros de contagem de símbolos"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → a S b | ε. Palavra: aabb. Derivação leftmost: S ⇒ a S b ⇒ a a S b b ⇒ a a ε b b ⇒ a a b b. Árvore: Raiz S com filhos 'a', S, 'b'; S filho com 'a', S(ε), 'b'; folhas: a a b b.",
                              "finalVerifications": [
                                "Folhas da árvore, lidas esquerda-direita, formam exatamente a palavra w.",
                                "Cada expansão interna reflete uma produção da gramática.",
                                "Ordem das expansões segue estritamente leftmost (NT mais à esquerda primeiro).",
                                "Não há não-terminais não expandido na árvore.",
                                "Reconstrução da derivação linear da árvore matches a manual.",
                                "Comprimento da derivação é mínimo ou plausível para w."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e expansão do leftmost NT em cada passo (100% correto).",
                                "Estrutura da árvore hierárquica reflete fielmente a derivação (sem ramificações erradas).",
                                "Cobertura completa: todas símbolos de w presentes nas folhas.",
                                "Uso correto de produções da gramática sem invenções.",
                                "Clareza visual: árvore legível com rótulos e setas.",
                                "Validação: derivação reversível da árvore para w."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de árvores e grafos acíclicos direcionados.",
                                "Linguística: Análise sintática em linguagens naturais.",
                                "Engenharia de Software: Parsing top-down em compiladores (ex: LL parsers).",
                                "Algoritmos: Recursão e backtracking em geração de linguagens.",
                                "Inteligência Artificial: Modelagem de árvores de decisão em PLN."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores (ex: parsers de linguagens como Python ou JavaScript), árvores de derivação leftmost são usadas em parsing top-down para construir árvores de sintaxe abstrata (AST), analisando código-fonte e detectando erros sintáticos em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Construir uma árvore de derivação rightmost",
                            "description": "Construir a árvore de derivação direita para uma palavra, expandindo o não-terminal mais à direita em cada iteração, e comparar com a leftmost.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática e a string de destino",
                                  "subSteps": [
                                    "Identifique o axioma inicial (S) da gramática livre de contexto (CFG).",
                                    "Liste todas as produções relevantes da gramática.",
                                    "Especifique a string terminal w a ser derivada (ex: 'aabb').",
                                    "Verifique se a gramática é ambígua ou se há múltiplas derivações possíveis.",
                                    "Anote os não-terminais (N) e terminais (Σ) da gramática."
                                  ],
                                  "verification": "Lista completa de produções anotada e string w confirmada como pertencente à linguagem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Editor de texto para anotar gramática"
                                  ],
                                  "tips": "Use abreviações para não-terminais e destaque terminais em negrito para clareza visual.",
                                  "learningObjective": "Compreender os componentes fundamentais de uma CFG e preparar para derivação.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Esquecer produções recursivas",
                                    "Escolher string não gerável pela gramática"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a derivação rightmost passo a passo",
                                  "subSteps": [
                                    "Comece com o axioma S.",
                                    "Em cada iteração, identifique e expanda apenas o não-terminal mais à direita.",
                                    "Substitua pelo lado direito de uma produção aplicável.",
                                    "Continue até que apenas terminais restem, gerando w.",
                                    "Registre cada sentença de derivação com setas →."
                                  ],
                                  "verification": "Sequência de derivações rightmost completa que gera w, com pelo menos 3-5 passos anotados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Marcadores coloridos para destacar não-terminal direito"
                                  ],
                                  "tips": "Sempre leia a sentença da direita para a esquerda para localizar o não-terminal mais à direita.",
                                  "learningObjective": "Dominar o processo de derivação rightmost, diferenciando de leftmost.",
                                  "commonMistakes": [
                                    "Expandir não-terminal errado (ex: leftmost por engano)",
                                    "Aplicar produção inválida",
                                    "Parar prematuramente antes de terminais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a árvore de derivação rightmost",
                                  "subSteps": [
                                    "Desenhe o nó raiz com o axioma S.",
                                    "Para cada expansão rightmost, adicione filhos à direita do nó pai.",
                                    "Rótule arestas com as produções usadas.",
                                    "Continue ramificando apenas o não-terminal direito em cada nível.",
                                    "Termine com folhas como terminais de w, da esquerda para direita."
                                  ],
                                  "verification": "Árvore desenhada onde a ordem de expansão segue rightmost e folhas formam w.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como draw.io ou papel",
                                    "Exemplo impresso de árvore"
                                  ],
                                  "tips": "Use setas descendentes para pai-filho e numere as expansões para rastrear ordem rightmost.",
                                  "learningObjective": "Visualizar graficamente a derivação rightmost como uma árvore hierárquica.",
                                  "commonMistakes": [
                                    "Invertar ordem de irmãos (esquerda-direita)",
                                    "Misturar ordem de expansão left/right",
                                    "Omitir rótulos de produções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com derivação leftmost e verificar correção",
                                  "subSteps": [
                                    "Execute a derivação leftmost para a mesma w usando a mesma gramática.",
                                    "Construa rapidamente a árvore leftmost para comparação.",
                                    "Compare sequências de derivações e estruturas de árvores.",
                                    "Verifique se ambas geram w e note diferenças na ordem de expansão.",
                                    "Analise impactos em parsing (ex: top-down vs bottom-up)."
                                  ],
                                  "verification": "Tabela ou diagrama comparativo mostrando diferenças entre leftmost e rightmost.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Duas folhas de papel lado a lado",
                                    "Marcador para destaques comparativos"
                                  ],
                                  "tips": "Leftmost expande esquerda primeiro; rightmost, direita – memorize pela posição.",
                                  "learningObjective": "Diferenciar e contrastar derivações leftmost e rightmost em árvores.",
                                  "commonMistakes": [
                                    "Confundir ordem de expansão na comparação",
                                    "Ignorar ambiguidades da gramática",
                                    "Não validar geração de w"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → a S b | ε. String: aabb. Derivação rightmost: S ⇒ a S b ⇒ a ε b b ⇒ a b b (árvore: S com filho direito b primeiro, depois ε expandido). Compare com leftmost: S ⇒ a S b ⇒ a a S b b ⇒ a a ε b b.",
                              "finalVerifications": [
                                "A sequência de derivações rightmost gera exatamente a string w.",
                                "A árvore reflete expansões apenas do não-terminal mais à direita em cada passo.",
                                "Folhas da árvore, lidas da esquerda para direita, formam w.",
                                "Comparação com leftmost destaca diferenças na ordem de nós internos.",
                                "Nenhuma produção inválida ou expansão fora de ordem.",
                                "Árvore é hierarquicamente correta sem ciclos infinitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e expansão do não-terminal rightmost (40%).",
                                "Correta representação gráfica da árvore com rótulos (30%).",
                                "Análise comparativa clara com leftmost (20%).",
                                "Detalhes completos em subpassos e verificações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de árvores e grafos recursivos.",
                                "Lógica: Provas por indução em derivações formais.",
                                "Programação: Parsing em compiladores (Yacc usa rightmost).",
                                "Linguística: Análise sintática em gramáticas naturais."
                              ],
                              "realWorldApplication": "Em compiladores, parsing bottom-up (shift-reduce) usa derivações rightmost para construir árvores de sintaxe abstrata (AST) eficientemente, essencial para análise de código em linguagens como C++ ou Java."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Detectar ambiguidade usando árvores de derivação",
                            "description": "Analisar se uma GLC é ambígua verificando se existe uma palavra com múltiplas árvores de derivação leftmost distintas, com exemplos de gramáticas ambíguas e inambíguas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Árvores de Derivação Leftmost em GLCs",
                                  "subSteps": [
                                    "Defina Gramática Livre de Contexto (GLC) e seus componentes: não-terminais, terminais, axioma e regras de produção.",
                                    "Explique derivação leftmost: sempre expandir o terminal mais à esquerda primeiro.",
                                    "Descreva estrutura de uma árvore de derivação: nó raiz (axioma), filhos pelas regras aplicadas, folhas formam a palavra.",
                                    "Diferencie árvores de derivação de sequências de derivação.",
                                    "Estude exemplos simples de derivações leftmost para palavras curtas."
                                  ],
                                  "verification": "Construa manualmente uma árvore de derivação leftmost para uma palavra simples em uma GLC dada e compare com um modelo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de diagramas (ex: Draw.io)",
                                    "Notas de aula sobre GLCs",
                                    "Exemplos de gramáticas básicas"
                                  ],
                                  "tips": [
                                    "Sempre comece pela esquerda; use setas descendentes para mostrar expansões.",
                                    "Desenhe árvores de cima para baixo para clareza visual."
                                  ],
                                  "learningObjective": "Compreender a construção precisa de árvores de derivação leftmost como base para detecção de ambiguidade.",
                                  "commonMistakes": [
                                    "Confundir leftmost com rightmost derivações.",
                                    "Esquecer de aplicar regras apenas em não-terminais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Árvores de Derivação para uma Palavra Específica",
                                  "subSteps": [
                                    "Selecione uma GLC e uma palavra terminal gerada por ela.",
                                    "Inicie a derivação leftmost do axioma até gerar a palavra.",
                                    "Desenhe a árvore correspondente, registrando cada aplicação de regra.",
                                    "Verifique se a sequência de folhas da árvore produz exatamente a palavra.",
                                    "Repita para confirmar que a derivação é válida e leftmost."
                                  ],
                                  "verification": "A árvore gerada deve ter folhas exatas da palavra e todas expansões serem leftmost.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GLC exemplo impressa",
                                    "Papel quadriculado para diagramas",
                                    "Calculadora para contar derivações se necessário"
                                  ],
                                  "tips": [
                                    "Numere as regras usadas em cada nó para rastreabilidade.",
                                    "Use cores diferentes para terminais e não-terminais."
                                  ],
                                  "learningObjective": "Dominar a geração de uma única árvore de derivação leftmost para análise posterior.",
                                  "commonMistakes": [
                                    "Aplicar regras em terminais.",
                                    "Gerar derivações não-leftmost acidentalmente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Buscar Múltiplas Árvores de Derivação Leftmost para a Mesma Palavra",
                                  "subSteps": [
                                    "Tente alternativas em pontos de escolha de regras durante a derivação leftmost.",
                                    "Gere uma segunda derivação leftmost completa para a mesma palavra.",
                                    "Construa a árvore correspondente à segunda derivação.",
                                    "Documente diferenças nas estruturas das árvores (ramos, profundidade, agrupamentos).",
                                    "Se não encontrar segunda, conclua inambígua para essa palavra."
                                  ],
                                  "verification": "Pelo menos duas árvores distintas devem ser desenhadas se ambígua, com folhas idênticas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Mesma GLC e palavra do step 2",
                                    "Ferramenta de diagramação digital",
                                    "Lista de todas regras da gramática"
                                  ],
                                  "tips": [
                                    "Backtrack em escolhas de regras no leftmost mais à esquerda.",
                                    "Compare estruturas árvore por árvore, não só sequências."
                                  ],
                                  "learningObjective": "Identificar existência de múltiplas derivações leftmost distintas para detectar ambiguidade.",
                                  "commonMistakes": [
                                    "Considerar derivações rightmost como alternativas.",
                                    "Ignorar se árvores são sintaticamente idênticas apesar de caminhos diferentes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Concluir Sobre Ambiguidade da Gramática",
                                  "subSteps": [
                                    "Compare as árvores: verifique se são estruturalmente diferentes (ex: diferentes agrupamentos).",
                                    "Se ≥2 árvores distintas para uma palavra, gramática é ambígua.",
                                    "Teste múltiplas palavras para confirmar (ambiguidade requer apenas uma palavra ambígua).",
                                    "Compare com gramática inambígua equivalente.",
                                    "Registre conclusão com justificativa baseada nas árvores."
                                  ],
                                  "verification": "Relatório escrito confirmando ambiguidade com árvores desenhadas como evidência.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Árvores dos steps anteriores",
                                    "Exemplos de gramáticas ambíguas/inambíguas",
                                    "Template de relatório"
                                  ],
                                  "tips": [
                                    "Foquem em distinção estrutural, não em ordem de derivação.",
                                    "Use exemplos clássicos como benchmark."
                                  ],
                                  "learningObjective": "Aplicar critério formal de ambiguidade via árvores para GLCs.",
                                  "commonMistakes": [
                                    "Declarar ambígua só por múltiplas sequências, ignorando árvores idênticas.",
                                    "Testar só uma palavra sem generalizar."
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática ambígua: S → S + S | S * S | a. Palavra: a + a * a. Duas árvores leftmost: 1) (a + a) * a; 2) a + (a * a). Árvores diferem no agrupamento de operadores.",
                              "finalVerifications": [
                                "Construir corretamente árvore leftmost para palavra dada.",
                                "Gerar múltiplas árvores e identificar distinções estruturais.",
                                "Explicar por que gramática é ambígua/inambígua com evidências.",
                                "Diferenciar derivação leftmost de outras.",
                                "Aplicar método a nova GLC sem erros.",
                                "Desenhar árvores precisas e legíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de árvores (100% match com folhas).",
                                "Número e validade de derivações alternativas encontradas.",
                                "Clareza na comparação estrutural das árvores.",
                                "Justificativa lógica para conclusão de ambiguidade.",
                                "Completude de substeps em cada derivação.",
                                "Uso correto de terminais/não-terminais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Árvores (análise estrutural).",
                                "Programação: Parsing em Compiladores (LL/LR parsers determinísticos).",
                                "Linguística: Ambiguidade sintática em linguagens naturais.",
                                "Lógica: Provas de existência/unicidade em sistemas formais."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, detectar ambiguidade garante parsers únicos, evitando erros em linguagens de programação como precedência de operadores em expressões aritméticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.1",
                              "10.1.4.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Autômatos de Pilha (PDA)",
                    "description": "Modelo determinístico e não-determinístico para linguagens livres de contexto.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Autômato de Pilha Não-Determinístico (NPDA)",
                        "description": "Modelo formal do autômato de pilha não-determinístico, incluindo sua definição, transições e mecanismos de aceitação para reconhecimento de linguagens livres de contexto.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Definir formalmente um NPDA",
                            "description": "Descrever a 7-tupla formal (Q, Σ, Γ, δ, q0, Z0, F) que define um autômato de pilha não-determinístico, explicando cada componente: conjunto de estados, alfabeto de entrada, alfabeto da pilha, função de transição δ: Q × (Σ ∪ {ε}) × Γ → finita(Q × Γ*), estado inicial, símbolo inicial da pilha e estados de aceitação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral da 7-Tupla de um NPDA",
                                  "subSteps": [
                                    "Leia a definição formal: Um NPDA é definido como M = (Q, Σ, Γ, δ, q0, Z0, F)",
                                    "Identifique os sete componentes exatos e seus papéis principais",
                                    "Compare com definições de DFA/NFA para destacar a adição da pilha",
                                    "Anote a assinatura da função de transição δ: Q × (Σ ∪ {ε}) × Γ → 2^{Q × Γ*}",
                                    "Revise o conceito de não-determinismo com ε-transições e múltiplas transições"
                                  ],
                                  "verification": "Liste verbalmente ou por escrito os 7 componentes e sua ordem correta sem consultar materiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Notas de aula sobre autômatos",
                                    "Artigo da Wikipedia sobre Pushdown Automata"
                                  ],
                                  "tips": [
                                    "Use mnemônicos como 'Estados, Entrada, Pilha, Delta, Inicial Estado, Inicial Pilha, Finais' para lembrar a ordem.",
                                    "Visualize a tupla como um 'pacote' completo para descrever qualquer NPDA."
                                  ],
                                  "learningObjective": "Reconhecer e recitar precisamente a estrutura da 7-tupla de um NPDA.",
                                  "commonMistakes": [
                                    "Esquecer o expoente de potência 2^ em δ (não-determinismo)",
                                    "Confundir a ordem dos componentes",
                                    "Ignorar ε no domínio de δ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detalhar os Conjuntos Q, Σ e Γ",
                                  "subSteps": [
                                    "Defina Q como o conjunto finito de estados, ex: Q = {q0, q1, q2}",
                                    "Explique Σ como o alfabeto de entrada finito, ex: Σ = {a, b}",
                                    "Descreva Γ como o alfabeto da pilha finito (Γ ⊇ Σ), ex: Γ = {a, b, Z0}",
                                    "Discuta como Q é finito, mas a pilha permite memória ilimitada",
                                    "Escreva exemplos concretos para cada conjunto em um contexto de linguagem específica"
                                  ],
                                  "verification": "Escreva definições precisas para Q, Σ e Γ com exemplos válidos para um NPDA simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Exemplos de linguagens context-free",
                                    "Ferramenta online como JFLAP para visualização"
                                  ],
                                  "tips": [
                                    "Sempre inclua Z0 em Γ como marcador inicial da pilha.",
                                    "Lembre-se: Σ é só entrada, Γ inclui símbolos de pilha extras."
                                  ],
                                  "learningObjective": "Descrever com precisão os conjuntos de estados, entrada e pilha em uma definição formal.",
                                  "commonMistakes": [
                                    "Fazer Γ não conter Σ",
                                    "Permitir Q infinito",
                                    "Confundir Σ com símbolos de saída"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Função de Transição δ",
                                  "subSteps": [
                                    "Analise o domínio: δ: Q × (Σ ∪ {ε}) × Γ → 2^{Q × Γ*}",
                                    "Entenda que δ((q, a, Z)) retorna um conjunto finito de pares (p, γ) onde γ ∈ Γ*",
                                    "Estude exemplos: push (escrever string na pilha), pop (ler e remover), ε-move",
                                    "Diferencie de PDA determinístico (δ retorna no máximo um par)",
                                    "Escreva uma transição exemplo: δ(q0, ε, Z0) = {(q1, aZ0), (q2, ε)}"
                                  ],
                                  "verification": "Construa e explique pelo menos 3 transições δ diferentes para um NPDA hipotético.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "JFLAP ou simulador de PDA online",
                                    "Tabela de transições em papel",
                                    "Exemplos de livros como Ullman"
                                  ],
                                  "tips": [
                                    "Pense em δ como 'possíveis próximos estados e configurações de pilha'.",
                                    "Use notação de conjunto para múltiplas saídas."
                                  ],
                                  "learningObjective": "Especificar corretamente a função de transição δ, incluindo seu tipo e exemplos.",
                                  "commonMistakes": [
                                    "Escrever δ como função total determinística",
                                    "Esquecer Γ* no codomínio",
                                    "Ignorar ε-transições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar com q0, Z0, F e Montar a Definição Formal",
                                  "subSteps": [
                                    "Defina q0 ∈ Q como o estado inicial único",
                                    "Especifique Z0 ∈ Γ como o símbolo inicial no topo da pilha (pilha começa com Z0)",
                                    "Descreva F ⊆ Q como o conjunto de estados de aceitação",
                                    "Monte a tupla completa usando os componentes anteriores",
                                    "Verifique se a definição atende aos critérios de NPDA (não-determinismo, pilha)"
                                  ],
                                  "verification": "Escreva uma 7-tupla completa e válida para um NPDA simples, explicando cada parte.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Modelo de NPDA para palíndromos",
                                    "Checklist de componentes",
                                    "Simulador para teste"
                                  ],
                                  "tips": [
                                    "q0 é único, Z0 marca o fundo da pilha, F pode ser vazio ou múltiplo.",
                                    "Sempre teste se a tupla é bem-formada."
                                  ],
                                  "learningObjective": "Integrar todos os componentes em uma definição formal completa de NPDA.",
                                  "commonMistakes": [
                                    "Colocar Z0 não em Γ",
                                    "Fazer F não subconjunto de Q",
                                    "Esquecer de especificar ∈ corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o NPDA M que reconhece palíndromos pares sobre {a,b}*: M = (Q={q0,q1,qf}, Σ={a,b}, Γ={a,b,Z0}, δ onde δ(q0,ε,Z0)={(q1,Z0Z0)}, δ(q1,a,aZ)={(q1,ε)}, δ(q1,b,bZ)={(q1,ε)}, δ(q1,a,Za)={(q1,ε)}, etc., δ(q1,ε,Z0)={(qf,ε)}, q0, Z0, F={qf}). Isso empurra a entrada na pilha e faz match reverso.",
                              "finalVerifications": [
                                "Recitar a 7-tupla completa sem erros",
                                "Explicar o papel de δ com notação precisa",
                                "Identificar erros em uma definição incompleta fornecida",
                                "Construir uma tupla mínima válida",
                                "Diferenciar NPDA de DPDA",
                                "Descrever aceitação por estado final com pilha vazia opcional"
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática da tupla e δ",
                                "Correta distinção entre componentes (ex: domínio vs. codomínio de δ)",
                                "Uso apropriado de símbolos ∈, ⊆, ∪, ε",
                                "Explicações claras e concisas para cada componente",
                                "Ausência de confusões com autômatos sem pilha",
                                "Capacidade de gerar exemplos válidos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos, Relações e Funções Parciais",
                                "Linguística Computacional: Análise Sintática e Gramáticas Context-Free",
                                "Engenharia de Software: Modelagem de Parsers em Compiladores",
                                "Lógica: Não-Determinismo e Busca em Espaços de Estados"
                              ],
                              "realWorldApplication": "Em compiladores, NPDA são usados em analisadores sintáticos (parsers) para validar estruturas aninhadas como blocos de código {if {else}}, expressões parentesadas ou XML/HTML, permitindo reconhecimento eficiente de linguagens context-free em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Executar transições e configurações em NPDA",
                            "description": "Dada uma string de entrada e um NPDA, simular configurações (estado, resto da entrada, conteúdo da pilha) e aplicar a função de transição não-determinística, ramificando em múltiplas possibilidades e rastreando caminhos de computação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o NPDA e a configuração inicial",
                                  "subSteps": [
                                    "Identifique o estado inicial q0 do NPDA.",
                                    "Registre a string de entrada completa, por exemplo, w = 'aba'.",
                                    "Inicialize a pilha como vazia (Z0 no fundo, se especificado) ou conforme definição.",
                                    "Anote a configuração inicial como (q0, w, Z0).",
                                    "Desenhe um diagrama da configuração para visualização."
                                  ],
                                  "verification": "Confirme que a configuração inicial está corretamente anotada e corresponde à definição do NPDA.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Diagrama do NPDA",
                                    "Papel e caneta ou editor de texto para anotações",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Sempre inclua o símbolo inicial da pilha (Z0) para evitar confusões em transições.",
                                  "learningObjective": "Compreender e representar precisamente a configuração inicial de um NPDA.",
                                  "commonMistakes": [
                                    "Esquecer o símbolo inicial da pilha",
                                    "Não registrar a entrada completa",
                                    "Confundir estado inicial com estados finais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar uma transição não-determinística única",
                                  "subSteps": [
                                    "Examine o estado atual, próximo símbolo da entrada (ou ε) e topo da pilha.",
                                    "Consulte a função de transição δ(q, a, X) para possíveis (p, γ), onde γ é a string a empilhar.",
                                    "Escolha uma transição possível e aplique: avance estado para p, consuma símbolo da entrada se não ε, substitua topo por γ.",
                                    "Atualize a configuração resultante, por exemplo, de (q, aw, Xβ) para (p, w, γβ).",
                                    "Registre a nova configuração."
                                  ],
                                  "verification": "Simule manualmente uma transição e verifique se a nova configuração mantém consistência com a entrada restante e pilha.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Tabela de transições do NPDA",
                                    "Folha de cálculo para configurações"
                                  ],
                                  "tips": "Liste todas as transições possíveis antes de escolher uma para praticar não-determinismo.",
                                  "learningObjective": "Executar corretamente a aplicação de uma regra de transição em uma configuração NPDA.",
                                  "commonMistakes": [
                                    "Ignorar transições ε (sem consumir entrada)",
                                    "Erro no pop/push da pilha",
                                    "Não tratar múltiplas transições do mesmo input"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar ramificações não-determinísticas",
                                  "subSteps": [
                                    "Da configuração atual, liste TODAS as transições possíveis (ramificações).",
                                    "Crie uma árvore de computação: cada nó é uma configuração, arestas são transições.",
                                    "Para cada ramificação, aplique o Step 2 recursivamente até não haver mais transições.",
                                    "Rastreie entradas não consumidas, pilha não vazia ou loops.",
                                    "Use uma fila ou pilha para processar branches em largura/profundidade."
                                  ],
                                  "verification": "Desenhe a árvore completa de pelo menos 3 níveis e confirme que todas as ramificações foram exploradas.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Gráfico em árvore (software como Graphviz ou papel)",
                                    "Simulador online de PDA se disponível"
                                  ],
                                  "tips": "Processe branches em ordem alfabética ou numérica para organização.",
                                  "learningObjective": "Explorar e rastrear múltiplos caminhos de computação devido ao não-determinismo.",
                                  "commonMistakes": [
                                    "Parar em uma branch sem explorar todas",
                                    "Confundir ordem de ramificações",
                                    "Perder rastreamento da pilha em branches paralelas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a simulação e determinar aceitação",
                                  "subSteps": [
                                    "Identifique configurações finais: estado em F, entrada vazia e pilha vazia (ou apenas Z0).",
                                    "Verifique todas as folhas da árvore de computação para aceitação.",
                                    "A string é aceita se pelo menos UMA branch atinge configuração aceitadora.",
                                    "Registre rejeição se NENHUMA branch aceita.",
                                    "Otimize resumindo caminhos rejeitados precocemente."
                                  ],
                                  "verification": "Liste todas as configurações terminais e classifique como aceitas/rejeitadas corretamente.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Árvore de computação do Step 3",
                                    "Definição formal do NPDA"
                                  ],
                                  "tips": "Use cores na árvore: verde para aceito, vermelho para rejeitado.",
                                  "learningObjective": "Avaliar corretamente a aceitação de uma string por um NPDA via simulação completa.",
                                  "commonMistakes": [
                                    "Requerer todas as branches aceitarem (é existencial)",
                                    "Esquecer verificação de pilha vazia",
                                    "Declarar aceitação prematura"
                                  ]
                                }
                              ],
                              "practicalExample": "NPDA para palíndromos pares sobre {a,b}: δ(q0, a, Z0) = (q1, aZ0); δ(q1, a, a) = (q1, ε); δ(q1, b, b) = (q1, ε); δ(q1, ε, a) = (q2, a); etc. Entrada: 'abba'. Simule: inicial (q0, abba, Z0) → ramifica para push 'a' → continua empilhando até meio → desempilha → aceita em (qf, ε, Z0).",
                              "finalVerifications": [
                                "Pode representar qualquer configuração inicial corretamente.",
                                "Aplica transições não-determinísticas sem erros em exemplos simples.",
                                "Desenha árvore de computação para entradas de tamanho 4-6.",
                                "Determina aceitação corretamente para 3 exemplos conhecidos.",
                                "Identifica e evita loops infinitos em simulações.",
                                "Explica diferença entre PDA determinístico e não-determinístico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na atualização de estado, entrada e pilha (90% correto).",
                                "Cobertura completa de todas as ramificações (sem branches perdidas).",
                                "Correta identificação de configurações aceitadoras.",
                                "Clareza na representação gráfica ou tabular da simulação.",
                                "Eficiência no rastreamento (sem redundâncias desnecessárias).",
                                "Capacidade de lidar com ε-transições e múltiplos pops/pushes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos (árvores de computação como grafos direcionados).",
                                "Programação: Recursão e backtracking em algoritmos de busca.",
                                "Lógica: Não-determinismo similar a escolha existencial em provas.",
                                "Física: Modelos probabilísticos (não-determinismo como superposição).",
                                "Engenharia de Software: Parsing em compiladores (LL/LR parsers baseados em PDA)."
                              ],
                              "realWorldApplication": "Simulação de NPDA é fundamental em compiladores para análise sintática de linguagens de programação, onde parsers não-determinísticos lidam com gramáticas ambíguas, como em ferramentas como Yacc/Bison, validando estruturas como expressões balanceadas em código fonte."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Mecanismos de aceitação em NPDA",
                            "description": "Explicar e comparar aceitação por estado final (entrada consumida e estado em F) versus aceitação por pilha vazia (entrada consumida e pilha vazia), demonstrando sua equivalência em termos de linguagens livres de contexto reconhecíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Aceitação por Estado Final em NPDA",
                                  "subSteps": [
                                    "Revise a definição formal de um NPDA: conjunto de estados Q, alfabeto de entrada Σ, alfabeto da pilha Γ, função de transição δ, estado inicial q0, símbolo inicial da pilha Z0, conjunto de estados finais F.",
                                    "Explique o processo de computação: comece em q0 com Z0 na pilha; para cada símbolo de entrada, aplique transições não-determinísticas empilhando/desempilhando.",
                                    "Defina aceitação por estado final: uma string w é aceita se existe uma sequência de computações que consome toda w e termina em um estado q ∈ F, independentemente do conteúdo da pilha.",
                                    "Trace um exemplo simples: para w = 'ab', mostre configurações iniciais e finais.",
                                    "Diferencie de aceitação em DFA/NFA: aqui há pilha e não-determinismo."
                                  ],
                                  "verification": "Desenhe o diagrama de um NPDA simples que aceite {a^n b^n} por estado final e simule w = 'aabb'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Papel e lápis para diagramas",
                                    "Ferramenta online como JFLAP para simulação de PDA"
                                  ],
                                  "tips": "Sempre anote configurações como (estado, resto da entrada, pilha) para rastrear.",
                                  "learningObjective": "Dominar a definição e mecânica de aceitação por estado final em NPDA.",
                                  "commonMistakes": [
                                    "Confundir com aceitação por pilha vazia",
                                    "Ignorar não-determinismo ao simular",
                                    "Esquecer que pilha pode não estar vazia no final"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Aceitação por Pilha Vazia em NPDA",
                                  "subSteps": [
                                    "Defina aceitação por pilha vazia: w é aceita se existe uma computação que consome toda w e esvazia a pilha completamente, independentemente do estado final.",
                                    "Note que não há estados finais F; o estado pode ser qualquer um.",
                                    "Compare com o anterior: foco na pilha em vez de estado.",
                                    "Simule o mesmo exemplo {a^n b^n}: ajuste o NPDA para esvaziar pilha após processar b's.",
                                    "Discuta quando usar: útil para PDAs sem 'retorno' explícito."
                                  ],
                                  "verification": "Construa um NPDA para {a^n b^n} que aceite por pilha vazia e verifique w = 'aabbb'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "JFLAP ou simulador PDA",
                                    "Notas do Step 1",
                                    "Exemplos de linguagens CFL"
                                  ],
                                  "tips": "Use um símbolo especial para sinalizar fim e forçar esvaziamento.",
                                  "learningObjective": "Compreender a definição e simulação de aceitação por pilha vazia.",
                                  "commonMistakes": [
                                    "Assumir estados finais são necessários",
                                    "Deixar símbolos residuais na pilha",
                                    "Confundir consumo de entrada com esvaziamento de pilha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar os Dois Mecanismos de Aceitação",
                                  "subSteps": [
                                    "Liste semelhanças: ambos requerem consumo total da entrada; reconhecem as mesmas CFLs.",
                                    "Liste diferenças: estado final ignora pilha; pilha vazia ignora estado; impacto em design de NPDA.",
                                    "Crie tabela comparativa: colunas para definição, exemplo, prós/contras.",
                                    "Discuta conversão: como modificar um NPDA de um tipo para o outro.",
                                    "Analise exemplo onde um é mais intuitivo: pilha vazia para linguagens 'balanceadas'."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 linhas de diferenças/semelhanças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Exemplos dos steps anteriores"
                                  ],
                                  "tips": "Use diagramas lado a lado para visualização.",
                                  "learningObjective": "Identificar e articular diferenças e semelhanças entre os mecanismos.",
                                  "commonMistakes": [
                                    "Achar que linguagens diferem",
                                    "Ignorar que ambos são para entrada consumida",
                                    "Confundir com DPDA"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Equivalência entre os Mecanismos",
                                  "subSteps": [
                                    "Prove que todo NPDA por estado final pode ser convertido em um por pilha vazia: adicione estados para esvaziar pilha após F.",
                                    "Prove o inverso: simule pilha vazia com estado final após esvaziamento.",
                                    "Mostre formalmente: construções preservam linguagem L(NPDA).",
                                    "Aplique a {a^n b^n}: converta um NPDA de estado final para pilha vazia.",
                                    "Conclua: ambos reconhecem exatamente as CFLs."
                                  ],
                                  "verification": "Escreva as construções de conversão e aplique a um exemplo específico.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Livro-texto para provas formais",
                                    "JFLAP para testar conversões"
                                  ],
                                  "tips": "Comece com construções genéricas antes de exemplos.",
                                  "learningObjective": "Demonstrar matematicamente a equivalência dos mecanismos.",
                                  "commonMistakes": [
                                    "Erros na construção de conversão (ex: loops infinitos)",
                                    "Confundir NPDA com DPDA",
                                    "Omitir casos de pilha não vazia"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o NPDA para L = {a^n b^n | n ≥ 0}. Para aceitação por estado final: empilhe A's em 'a', desempilhe em 'b', aceite em estado final qf após b's. Para pilha vazia: após desempilhar último 'b', transite para esvaziar pilha restante e aceite quando vazia. Simule w = 'aabb': ambas aceitam w, mas pilha pode ter resíduo na primeira.",
                              "finalVerifications": [
                                "Explique verbalmente as definições de ambos mecanismos sem consultar notas.",
                                "Converta um NPDA dado de estado final para pilha vazia corretamente.",
                                "Identifique se um NPDA descrito aceita por qual mecanismo.",
                                "Simule uma string em ambos e compare resultados.",
                                "Prove sucintamente a equivalência para uma CFL simples.",
                                "Discuta por que ambos definem as mesmas classes de linguagens."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (exata correspondência com teoria padrão).",
                                "Correção nas simulações e traçamentos de configurações.",
                                "Clareza na tabela comparativa e construções de equivalência.",
                                "Profundidade na análise de exemplos práticos.",
                                "Identificação correta de erros comuns em cenários dados.",
                                "Demonstração de compreensão conceitual via explicações verbais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e relações (transições como funções parciais).",
                                "Programação: Recursão e pilhas em linguagens como Python (sys.setrecursionlimit).",
                                "Lógica: Não-determinismo similar a backtracking em algoritmos de busca.",
                                "Engenharia de Software: Parsing em compiladores (LL(1) vs. LR usando PDAs)."
                              ],
                              "realWorldApplication": "Em compiladores, NPDA modelam parsers para linguagens de programação (CFLs como expressões balanceadas); escolha de mecanismo afeta design de ferramentas como Yacc/Bison, otimizando para pilha vazia em análises bottom-up."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Autômato de Pilha Determinístico (DPDA)",
                        "description": "Modelo determinístico do autômato de pilha, suas restrições em relação ao NPDA e o reconhecimento de linguagens livres de contexto determinísticas (DCFL).",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Definir formalmente um DPDA",
                            "description": "Descrever a 7-tupla de um DPDA com restrições na função de transição δ: Q × (Σ ∪ {ε}) × Γ → Q × Γ* ∪ {rejeitar}, garantindo no máximo uma transição por configuração (estado, símbolo de entrada ou ε, topo da pilha), sem ε-movimentos em entrada não-vazia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes básicos da 7-tupla de um DPDA",
                                  "subSteps": [
                                    "Liste os sete componentes padrão de um autômato de pilha: Q (estados), Σ (alfabeto de entrada), Γ (alfabeto da pilha), δ (função de transição), q0 (estado inicial), Z0 (símbolo inicial da pilha) e F (estados finais).",
                                    "Descreva Q como um conjunto finito de estados, Σ como alfabeto finito de símbolos de entrada e Γ como alfabeto finito da pilha contendo Z0.",
                                    "Explique que q0 ∈ Q é o estado inicial, Z0 ∈ Γ é o símbolo inicial no topo da pilha e F ⊆ Q são os estados de aceitação.",
                                    "Diferencie DPDA de NPDA destacando o determinismo na transição.",
                                    "Esboce um diagrama simples com os componentes anotados."
                                  ],
                                  "verification": "Escreva a 7-tupla genérica (Q, Σ, Γ, δ, q0, Z0, F) e defina verbalmente cada componente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referência de livro de Teoria da Computação (ex: Sipser)"
                                  ],
                                  "tips": "Use notação matemática padrão para conjuntos e funções para clareza.",
                                  "learningObjective": "Compreender e listar corretamente os sete componentes fundamentais de um DPDA.",
                                  "commonMistakes": [
                                    "Confundir Σ (entrada) com Γ (pilha)",
                                    "Esquecer que F é subconjunto de Q",
                                    "Omitir Z0 como parte de Γ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a assinatura da função de transição δ",
                                  "subSteps": [
                                    "Escreva a assinatura formal: δ: Q × (Σ ∪ {ε}) × Γ → Q × Γ* ∪ {rejeitar}.",
                                    "Explique que o domínio permite leitura de símbolo de entrada ou ε, e topo da pilha.",
                                    "Descreva o codomínio: par (novo estado, string a empilhar ou substituir) ou 'rejeitar'.",
                                    "Note que Γ* permite empilhar zero ou mais símbolos (incluindo pop com string vazia).",
                                    "Dê um exemplo simples: δ(q, a, Z) = (p, ZA) para empilhar A sobre Z ao ler a."
                                  ],
                                  "verification": "Forneça a assinatura exata de δ e um exemplo de transição válida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de equações (ex: LaTeX online)",
                                    "Notas sobre PDA"
                                  ],
                                  "tips": "Sempre inclua {ε} no domínio para movimentos ε, mas restrinja seu uso depois.",
                                  "learningObjective": "Formalizar corretamente a função de transição δ com domínio e codomínio precisos.",
                                  "commonMistakes": [
                                    "Usar Σ × Γ → Q × Γ em vez de Q × (Σ ∪ {ε}) × Γ",
                                    "Esquecer ∪ {rejeitar} no codomínio",
                                    "Confundir Γ* com Γ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer as restrições de determinismo",
                                  "subSteps": [
                                    "Defina determinismo: para cada configuração (q, a ou ε, Z), existe no máximo uma transição δ(q, a/ε, Z).",
                                    "Garanta unicidade: sem duas transições conflitantes para a mesma configuração.",
                                    "Proíba ε-movimentos quando há entrada não-vazia: se |w| > 0 e próximo símbolo ≠ ε, não use ε-transição.",
                                    "Verifique ambiguidade: para cada (q, σ ∈ Σ ∪ {ε}, Z), |δ(q, σ, Z)| ≤ 1.",
                                    "Teste com exemplo: rejeite se duas transições possíveis para mesmo input."
                                  ],
                                  "verification": "Escreva as três restrições principais de determinismo e valide com um contraexemplo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de PDA de aulas anteriores",
                                    "Simulador de autômatos online"
                                  ],
                                  "tips": "Pense em 'determinístico' como 'no máximo uma escolha por momento'.",
                                  "learningObjective": "Aplicar e verificar as restrições que tornam o PDA determinístico.",
                                  "commonMistakes": [
                                    "Permitir múltiplas transições para mesma configuração",
                                    "Ignorar restrição de ε em input não-vazia",
                                    "Confundir com NPDA não-determinístico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e validar a definição completa do DPDA",
                                  "subSteps": [
                                    "Combine todos os componentes em uma 7-tupla explícita para um exemplo.",
                                    "Simule uma configuração inicial: (q0, w, Z0) e trace transições.",
                                    "Verifique aceitação por estado final e pilha vazia ou por estado final.",
                                    "Confirme todas restrições: determinismo total e ausência de ambiguidades.",
                                    "Documente a definição em notação formal completa."
                                  ],
                                  "verification": "Forneça uma 7-tupla completa válida e simule entrada de teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para diagrama de estados",
                                    "Ferramenta JFLAP para simulação"
                                  ],
                                  "tips": "Sempre teste com strings aceitas e rejeitadas para validar.",
                                  "learningObjective": "Construir e validar uma definição formal integral de um DPDA.",
                                  "commonMistakes": [
                                    "Omitir alguma restrição na validação",
                                    "Erro na simulação de pilha",
                                    "Definir sem exemplo concreto"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina um DPDA para L = {a^n b^n | n ≥ 0}: Q = {q0, q1, qf}, Σ = {a,b}, Γ = {Z0, A}, δ(q0, ε, Z0) = (q1, Z0), δ(q1, a, Z0) = (q1, A Z0), δ(q1, a, A) = (q1, A A), δ(q1, b, A) = (q1, ε), δ(q1, ε, Z0) = (qf, Z0), F = {qf}. Verifique determinismo: única transição por config.",
                              "finalVerifications": [
                                "A 7-tupla possui exatamente sete componentes corretos?",
                                "A assinatura de δ inclui Q × (Σ ∪ {ε}) × Γ → Q × Γ* ∪ {rejeitar}?",
                                "Existe no máximo uma transição por (q, σ, Z)?",
                                "Não há ε-movimentos com entrada não-vazia?",
                                "Simulação de string aceita termina em F?",
                                "String rejeitada leva a rejeitar ou loop sem F?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação da 7-tupla e assinatura de δ (20%)",
                                "Correta descrição das restrições de determinismo (25%)",
                                "Validação com exemplo prático e simulação (20%)",
                                "Clareza na explicação de cada componente (15%)",
                                "Ausência de erros comuns como confusão de símbolos (10%)",
                                "Completude das restrições ε e rejeitar (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Funções Parciais",
                                "Lógica: Sistemas de Transição Determinísticos",
                                "Engenharia de Software: Parsers em Compiladores LL(1)",
                                "Linguística Computacional: Análise Sintática Determinística",
                                "Algoritmos: Estruturas de Controle com Pilha"
                              ],
                              "realWorldApplication": "DPDAs são fundamentais em compiladores para parsing determinístico de linguagens de programação (ex: parsers LR(0) em ferramentas como Yacc/Bison), garantindo eficiência O(n) em análise sintática sem backtracking."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Comparar NPDA e DPDA",
                            "description": "Identificar diferenças chave: poder expressivo (todas CFL por NPDA, mas DCFL estritamente mais fracas por DPDA), exemplos como {a^n b^n | n≥0} é DCFL enquanto {ww^R | w∈{a,b}*} requer não-determinismo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de NPDA e DPDA",
                                  "subSteps": [
                                    "Leia a definição formal de um Autômato de Pilha Não-Determinístico (NPDA): conjunto (Q, Σ, Γ, δ, q0, Z0, F) onde δ pode ter múltiplas transições.",
                                    "Leia a definição formal de um Autômato de Pilha Determinístico (DPDA): similar, mas δ tem no máximo uma transição por (estado, símbolo de entrada, topo da pilha).",
                                    "Identifique componentes comuns: estados, alfabeto de entrada, alfabeto da pilha, função de transição, estado inicial, símbolo inicial da pilha e estados finais.",
                                    "Anote diferenças iniciais na função de transição: não-determinismo vs determinismo.",
                                    "Desenhe diagramas simples de um NPDA e um DPDA genérico para visualização."
                                  ],
                                  "verification": "Você pode explicar verbalmente ou por escrito as diferenças nas funções de transição δ de NPDA e DPDA.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Teoria da Computação (capítulo PDA)",
                                    "Folha de papel e caneta para diagramas",
                                    "Notas de aula sobre autômatos"
                                  ],
                                  "tips": "Use tabelas para comparar os conjuntos de definição lado a lado.",
                                  "learningObjective": "Compreender as definições formais e diferenças estruturais básicas entre NPDA e DPDA.",
                                  "commonMistakes": [
                                    "Confundir o papel do não-determinismo com ambiguidade na entrada; lembrar que é na transição."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Poder Expressivo das Linguagens Reconhecidas",
                                  "subSteps": [
                                    "Estude que NPDA reconhece todas as Linguagens Livres de Contexto (CFLs).",
                                    "Aprenda que DPDA reconhece apenas Linguagens Livres de Contexto Determinísticas (DCFLs), um subconjunto próprio das CFLs.",
                                    "Prove ou entenda que toda DCFL é CFL, mas nem toda CFL é DCFL (ex: palíndromos pares requerem não-determinismo).",
                                    "Discuta closure properties: DCFLs são fechadas sob complemento, ao contrário de CFLs.",
                                    "Crie uma tabela comparando classes de linguagens: Regulares ⊂ DCFL ⊂ CFL ⊂ CSL."
                                  ],
                                  "verification": "Construa um diagrama de Venn mostrando a relação DCFL ⊂ CFL e forneça uma CFL não-DCFL.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referências teóricas (Sipser ou Hopcroft/Ullman)",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": "Lembre-se: determinismo restringe o poder, mas permite eficiência em parsing.",
                                  "learningObjective": "Identificar hierarquias de linguagens e por que DCFLs são estritamente mais fracas.",
                                  "commonMistakes": [
                                    "Achar que DPDA reconhece todas CFLs; testar com exemplos como ww^R."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Exemplos Concretos de Diferenças",
                                  "subSteps": [
                                    "Construa um DPDA para L1 = {a^n b^n | n ≥ 0}: empilhe 'a', desempilhe com 'b'.",
                                    "Tente construir um DPDA para L2 = {ww^R | w ∈ {a,b}*}: note que requer adivinhar o meio (não-determinismo).",
                                    "Simule execuções: mostre como NPDA resolve L2 com branches não-determinísticos.",
                                    "Liste mais exemplos: {a^n b^n c^n} é CFL mas nem DCFL nem CSL? Não, é CSL.",
                                    "Compare tempos de simulação: DPDA é O(n), NPDA pode ser exponencial."
                                  ],
                                  "verification": "Desenhe PDAs funcionais para L1 (DPDA) e L2 (apenas NPDA) e simule uma string de cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de PDA online (ex: PDA Simulator)",
                                    "Papel para desenhar transições"
                                  ],
                                  "tips": "Comece com strings curtas como ε, ab, aabb para L2.",
                                  "learningObjective": "Aplicar conceitos a exemplos para evidenciar limitações do determinismo.",
                                  "commonMistakes": [
                                    "Esquecer ε-transições em NPDAs; sempre verificar aceitação por estado final e pilha vazia."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Formalizar a Comparação Completa",
                                  "subSteps": [
                                    "Liste diferenças chave: poder expressivo, propriedades de fechamento, eficiência computacional.",
                                    "Discuta teoremas: Toda DCFL tem DPDA, nem toda CFL tem DPDA.",
                                    "Crie uma tabela de comparação: colunas para NPDA/DPDA com linhas para definição, linguagens, exemplos, aplicações.",
                                    "Pense em conversões: NPDA para CFG, DPDA para gramáticas LR(1).",
                                    "Resuma implicações para parsing: LL/LR parsers usam DPDAs."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras comparando NPDA e DPDA, incluindo exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou documento para tabela",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Use bullet points para clareza na tabela.",
                                  "learningObjective": "Consolidar conhecimento em uma comparação estruturada e abrangente.",
                                  "commonMistakes": [
                                    "Ignorar aplicações práticas; ligue à teoria de compiladores."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um compilador, use DPDA para parsing determinístico de gramáticas LR(1) como em C/Java (ex: Yacc/Bison gera tabelas DPDA), enquanto linguagens ambíguas como palíndromos requerem NPDA para análise teórica.",
                              "finalVerifications": [
                                "Pode listar e explicar pelo menos 3 diferenças chave entre NPDA e DPDA?",
                                "Constrói um DPDA correto para {a^n b^n | n≥0}?",
                                "Explica por que {ww^R | w∈{a,b}*} requer NPDA?",
                                "Identifica DCFLs como fechadas sob complemento?",
                                "Compara hierarquia: Regulares ⊂ DCFL ⊂ CFL?",
                                "Descreve implicações para parsing em compiladores?"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (80% correto).",
                                "Correta identificação de exemplos DCFL vs CFL não-DCFL.",
                                "Compreensão de propriedades teóricas (fechamentos, teoremas).",
                                "Capacidade de desenhar e simular PDAs simples.",
                                "Síntese clara em tabela ou resumo comparativo.",
                                "Ligação a aplicações reais como parsing."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Chomsky Hierarchy e Gramáticas.",
                                "Compiladores: Parsing bottom-up (LR) vs top-down (LL).",
                                "Algoritmos: Não-determinismo vs determinismo em NP vs P.",
                                "Lógica: Modelos computacionais e decidibilidade."
                              ],
                              "realWorldApplication": "No desenvolvimento de compiladores e interpretadores, DPDAs habilitam parsing eficiente e determinístico (ex: ferramentas como Bison para linguagens de programação), enquanto NPDAs modelam análises mais complexas em NLP ou verificação formal de software."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Construir e simular um DPDA simples",
                            "description": "Dado uma linguagem DCFL como {a^n b^n | n≥0}, projetar um DPDA que empilhe 'A' para cada 'a' e desempilhe para cada 'b', simulando sua execução passo a passo em uma string específica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a linguagem DCFL e os componentes de um DPDA",
                                  "subSteps": [
                                    "Analise a linguagem {a^n b^n | n ≥ 0}, identificando que ela requer contagem igual de 'a' e 'b'.",
                                    "Revise a definição formal de DPDA: conjunto de estados Q, alfabeto de entrada Σ = {a,b}, alfabeto da pilha Γ = {A,Z}, estado inicial q0, estado final F, pilha inicial Z (fundo).",
                                    "Estude a função de transição δ: Q × (Σ ∪ {ε}) × Γ → Q × Γ* , garantindo determinismo (uma única transição por configuração).",
                                    "Identifique estados necessários: q0 (inicial), q1 (lendo a's), q2 (lendo b's), qf (final), q_reject.",
                                    "Desenhe esboços iniciais da pilha: Z no fundo, empilhar A para cada 'a', desempilhar para cada 'b'."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases explicando como a pilha simula a contagem de a's e verifica b's.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre PDA/DPDA",
                                    "Papel e caneta para esboços",
                                    "Referência formal de autômatos"
                                  ],
                                  "tips": "Comece com o caso n=0 (string vazia) para testar aceitação imediata.",
                                  "learningObjective": "Dominar os componentes e o papel da pilha em DPDA para DCFLs.",
                                  "commonMistakes": [
                                    "Confundir DPDA com NPDA (permitir múltiplas transições)",
                                    "Esquecer o símbolo inicial Z da pilha",
                                    "Ignorar transições com ε para aceitação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os estados, símbolos e transições de empilhamento",
                                  "subSteps": [
                                    "Defina Q = {q0, q1, q_loop_a, q_loop_b, qf, q_reject}, Σ = {a,b}, Γ = {A, Z}.",
                                    "Especifique transições para fase de 'a': δ(q0, a, Z) = (q_loop_a, A Z), δ(q_loop_a, a, A) = (q_loop_a, A A).",
                                    "Adicione transição para iniciar 'b's: δ(q_loop_a, b, A) = (q_loop_b, ε).",
                                    "Inclua transição para string vazia: δ(q0, ε, Z) = (qf, Z).",
                                    "Verifique determinismo: para cada (estado, input, top_pilha), exatamente uma transição."
                                  ],
                                  "verification": "Liste todas as transições de empilhamento em uma tabela e confirme que cobrem a fase de 'a'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io ou papel quadriculado",
                                    "Tabela de transições em Excel/Google Sheets"
                                  ],
                                  "tips": "Use notação δ(q, σ, X) = (p, α) rigorosamente para evitar ambiguidades.",
                                  "learningObjective": "Projetar transições precisas para a fase de empilhamento em DPDA.",
                                  "commonMistakes": [
                                    "Empilhar múltiplos símbolos desnecessariamente",
                                    "Não tratar o fundo da pilha Z corretamente",
                                    "Permitir loops infinitos sem progresso"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Completar transições de desempilhamento e rejeição",
                                  "subSteps": [
                                    "Defina transições para 'b's: δ(q_loop_b, b, A) = (q_loop_b, ε), δ(q_loop_b, ε, Z) = (qf, Z).",
                                    "Adicione rejeições: δ(q_loop_a, a, A) não existe → reject; δ(q_loop_b, a, qualquer) → reject; δ(q_loop_b, b, Z) → reject.",
                                    "Defina F = {qf}, e garanta que só aceita se pilha volta a Z após b's exatos.",
                                    "Desenhe o diagrama de estados com setas rotuladas (input/top_pilha : empilha).",
                                    "Teste mentalmente para n=1: 'ab' deve ir q0 -a/Z-> q1 -b/A-> qf."
                                  ],
                                  "verification": "Crie uma tabela completa de transições e simule mentalmente 'aabbb' (deve rejeitar).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de autômatos como JFLAP",
                                    "Papel para diagrama"
                                  ],
                                  "tips": "Sempre verifique pop com match exato (b só pop A, não Z prematuramente).",
                                  "learningObjective": "Implementar lógica de desempilhamento e tratamento de erros em DPDA.",
                                  "commonMistakes": [
                                    "Desempilhar Z durante b's",
                                    "Não rejeitar sobras de a's ou b's extras",
                                    "Confundir ε-transições com input real"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular a execução passo a passo em uma string específica",
                                  "subSteps": [
                                    "Escolha string 'aabb' (n=2). Inicie: configuração (q0, aabb, Z).",
                                    "Aplique transições: (q0,a,Z) → (q_loop_a, abb, A Z); continue até fim.",
                                    "Registre cada configuração: estado | resto_input | pilha (top para baixo).",
                                    "Para 'aabb': trace completo deve terminar em (qf, ε, Z).",
                                    "Teste strings inválidas como 'abb' e registre rejeição."
                                  ],
                                  "verification": "Produza uma tabela de simulação com ≥5 configurações, mostrando aceitação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "JFLAP ou simulador online de PDA",
                                    "Planilha para tabela de trace"
                                  ],
                                  "tips": "Escreva pilha com top à esquerda (ex: A A Z).",
                                  "learningObjective": "Executar e depurar simulações manuais de DPDA.",
                                  "commonMistakes": [
                                    "Erros de tracking da pilha",
                                    "Pular ε-transições",
                                    "Confundir ordem de aplicação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a string 'aabb':\n1. (q0, aabb, Z) → δ(a,Z)=(q_loop_a, A Z) → (q_loop_a, abb, A Z)\n2. (q_loop_a, abb, A Z) → δ(a,A)=(q_loop_a, bb, A A Z)\n3. (q_loop_a, bb, A A Z) → δ(b,A)=(q_loop_b, b, A Z)\n4. (q_loop_b, b, A Z) → δ(b,A)=(q_loop_b, ε, Z)\n5. (q_loop_b, ε, Z) → δ(ε,Z)=(qf, ε, Z) → Aceito.",
                              "finalVerifications": [
                                "O DPDA aceita todas as strings {a^n b^n | n≥0} como ε, 'ab', 'aabb'.",
                                "Rejeita strings inválidas como 'abb', 'aaabbb', 'aba'.",
                                "Todas as transições são determinísticas (uma por configuração).",
                                "Pilha retorna exatamente a Z no final para aceitação.",
                                "Diagrama e tabela de transições estão completos e sem erros.",
                                "Simulação de pelo menos duas strings (válida e inválida) está correta."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das transições δ (100% cobertura determinística).",
                                "Correta manipulação da pilha: empilha apenas em 'a', desempilha em 'b'.",
                                "Simulação passo a passo sem erros de configuração.",
                                "Tratamento adequado de casos edge (n=0, rejeições).",
                                "Clareza no diagrama e tabelas (legível e rotulado).",
                                "Explicação coerente do raciocínio de design."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução e contagem em linguagens regulares vs context-free.",
                                "Programação: Implementação de stack em linguagens como Python/C++ para parsers.",
                                "Lógica: Autômatos como base para teoria da computação e verificação formal.",
                                "Engenharia de Software: Parsing sintático em compiladores (ex: JSON parsers)."
                              ],
                              "realWorldApplication": "DPDAs são usados em parsers determinísticos de linguagens de programação para verificar estruturas balanceadas como parênteses, chaves ou tags XML, garantindo sintaxe correta em compiladores e interpretadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Algoritmos de Parsing Top-Down",
                    "description": "Técnicas como LL(1) para análise descendente.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Análise Sintática Top-Down (Descendente)",
                        "description": "Introdução aos algoritmos de parsing que iniciam a partir do símbolo inicial da gramática e descendem recursivamente para produzir a árvore de derivação, comparando com a entrada.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Diferenciar parsing top-down de bottom-up",
                            "description": "Explicar as diferenças fundamentais entre análise sintática descendente (top-down) e ascendente (bottom-up), incluindo vantagens como simplicidade em linguagens LL(k) e desvantagens como backtracking.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Parsing Top-Down",
                                  "subSteps": [
                                    "Defina parsing top-down como uma análise sintática que começa do símbolo inicial da gramática e tenta derivar a string de entrada.",
                                    "Explique que parsers top-down, como LL(k), usam previsibilidade à esquerda sem backtracking em gramáticas LL(k).",
                                    "Descreva o processo recursivo descendente típico.",
                                    "Identifique exemplos comuns como Recursive Descent Parser.",
                                    "Anote as premissas de gramáticas livres de contexto adequadas."
                                  ],
                                  "verification": "Escreva um diagrama ou pseudocódigo de um parser top-down simples e confirme que inicia do símbolo raiz.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Compiladores (ex: Dragon Book)",
                                    "Notas de aula sobre linguagens formais",
                                    "Editor de texto para diagramas"
                                  ],
                                  "tips": "Use setas descendentes no diagrama para visualizar o fluxo top-down.",
                                  "learningObjective": "Entender o mecanismo fundamental do parsing top-down e suas características iniciais.",
                                  "commonMistakes": [
                                    "Confundir com bottom-up achando que começa das folhas",
                                    "Ignorar a necessidade de gramáticas LL(k)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender os Conceitos Básicos de Parsing Bottom-Up",
                                  "subSteps": [
                                    "Defina parsing bottom-up como uma análise que começa dos tokens de entrada e reduz para o símbolo inicial usando produções reversas.",
                                    "Explique parsers como LR(k), que usam tabelas de análise para shifts e reduces.",
                                    "Descreva o processo de pilha e redução bottom-up.",
                                    "Identifique exemplos como Yacc/Bison para LR parsing.",
                                    "Note que funciona bem com gramáticas LR(k), incluindo ambiguidades resolvidas por precedência."
                                  ],
                                  "verification": "Desenhe um exemplo de redução bottom-up para uma string simples e verifique se chega ao símbolo raiz.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta online de parsing LR",
                                    "Exemplos de gramáticas de Dragon Book",
                                    "Papel e caneta para pilha"
                                  ],
                                  "tips": "Visualize a pilha crescendo das folhas para a raiz.",
                                  "learningObjective": "Dominar o mecanismo de parsing bottom-up e suas bases operacionais.",
                                  "commonMistakes": [
                                    "Pensar que requer backtracking como top-down",
                                    "Confundir shift com predict em top-down"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Fundamentais Entre Top-Down e Bottom-Up",
                                  "subSteps": [
                                    "Liste diferenças: direção (raiz-para-folhas vs folhas-para-raiz), uso de lookahead (left-to-right vs table-driven), tratamento de recursão esquerda.",
                                    "Compare poder expressivo: top-down para LL(k), bottom-up para LR(k) mais poderoso.",
                                    "Discuta backtracking: comum em top-down não-LL, raro em bottom-up.",
                                    "Analise eficiência: top-down simples mas pode ser exponencial, bottom-up linear.",
                                    "Crie uma tabela comparativa com colunas para cada aspecto."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 diferenças chave e revise com um colega ou autoavaliação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou tabela Markdown",
                                    "Referências online sobre LL vs LR"
                                  ],
                                  "tips": "Use cores para destacar vantagens/desvantagens em cada célula.",
                                  "learningObjective": "Identificar e articular diferenças precisas entre os dois métodos.",
                                  "commonMistakes": [
                                    "Invertir qual usa backtracking mais",
                                    "Ignorar diferenças em gramáticas suportadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens, Desvantagens e Aplicações",
                                  "subSteps": [
                                    "Liste vantagens top-down: simplicidade, fácil debug, bom para linguagens simples.",
                                    "Liste desvantagens top-down: backtracking, problemas com recursão esquerda.",
                                    "Liste vantagens bottom-up: eficiência, cobre mais gramáticas, sem backtracking.",
                                    "Liste desvantagens bottom-up: tabelas complexas, difícil debug.",
                                    "Discuta cenários de uso: top-down para mini-linguagens, bottom-up para compiladores reais."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo prós/contras e escolha um exemplo real para cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de compiladores como GCC (LR)",
                                    "Parsers JS como Acorn (top-down)"
                                  ],
                                  "tips": "Pense em trade-offs: simplicidade vs poder.",
                                  "learningObjective": "Avaliar contextos onde cada método é preferível.",
                                  "commonMistakes": [
                                    "Superestimar simplicidade bottom-up",
                                    "Esquecer desvantagens de backtracking em top-down"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um parser top-down recursivo para a gramática E -> T + E | T; T -> id em pseudocódigo, depois simule um bottom-up LR(0) para a mesma gramática usando uma pilha, comparando o número de passos e backtracks para a entrada 'id + id'.",
                              "finalVerifications": [
                                "Explique verbalmente as 3 diferenças principais sem hesitação.",
                                "Desenhe árvores de parsing para ambos os métodos em uma gramática dada.",
                                "Identifique se uma gramática dada é LL(1) ou requer LR.",
                                "Liste 2 vantagens e 2 desvantagens de cada abordagem.",
                                "Simule parsing de uma string ambígua em ambos os estilos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e direções de parsing (raiz-folha vs folha-raiz).",
                                "Correta identificação de backtracking e tipos de gramáticas (LL vs LR).",
                                "Profundidade na comparação de eficiência e debugabilidade.",
                                "Uso de exemplos concretos para ilustrar diferenças.",
                                "Clareza na tabela ou diagrama comparativo.",
                                "Compreensão de trade-offs em cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Autômatos pushdown e linguagens livres de contexto.",
                                "Programação: Implementação de interpretadores e compiladores em linguagens como Python ou C.",
                                "Engenharia de Software: Ferramentas como ANTLR (top-down) vs Bison (bottom-up).",
                                "Algoritmos: Análise de complexidade em parsing (O(n) vs exponencial)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou Clang (bottom-up LR para C++), parsers de linguagens web como JavaScript (muitos top-down para simplicidade), e ferramentas de análise de código estático que diferenciam abordagens para otimizar performance em grandes codebases."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Entender o processo recursivo de parsing top-down",
                            "description": "Descrever o algoritmo recursivo descendente, onde cada não-terminal é expandido escolhendo uma produção baseada no lookahead, e identificar problemas como ambiguidade e left-recursion.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Parsing Top-Down Recursivo",
                                  "subSteps": [
                                    "Defina parsing top-down como um processo que começa do símbolo inicial e expande não-terminais descendendo para terminais.",
                                    "Explique recursive descent como uma implementação usando funções recursivas para cada não-terminal.",
                                    "Compare com parsing bottom-up, destacando que top-down usa lookahead para prever expansões.",
                                    "Identifique componentes chave: gramática LL(1), lookahead token e pilha de chamadas recursivas.",
                                    "Estude uma gramática simples, como expressões aritméticas: E → T | E + T."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando os fundamentos e desenhe um diagrama de fluxo básico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Exemplo de gramática LL(1) impressa ou digital"
                                  ],
                                  "tips": "Use analogias como 'árvore de decisão' para visualizar a expansão descendente.",
                                  "learningObjective": "Dominar os conceitos básicos de parsing top-down recursivo e suas diferenças com outros métodos.",
                                  "commonMistakes": [
                                    "Confundir top-down com bottom-up",
                                    "Ignorar a necessidade de lookahead",
                                    "Assumir que toda gramática é adequada para recursive descent"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear o Fluxo Recursivo do Algoritmo",
                                  "subSteps": [
                                    "Descreva o pseudocódigo: para um não-terminal A, chame função A() que verifica lookahead e escolhe produção.",
                                    "Simule o fluxo: ao encontrar não-terminal, recursivamente chame funções filhas até matching terminais.",
                                    "Trace a pilha de chamadas: cada recursão adiciona frame à pilha até backtrack se falhar.",
                                    "Implemente mentalmente para string 'id + id': inicie com E(), lookahead 'id' → expanda para T().",
                                    "Registre o processo de expansão e redução em uma tabela de rastreamento."
                                  ],
                                  "verification": "Trace manualmente o parsing de uma string simples em uma gramática dada, anotando cada recursão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Tabela de rastreamento em planilha ou papel"
                                  ],
                                  "tips": "Pense na recursão como 'mergulhar' na árvore de derivação esquerda-direita.",
                                  "learningObjective": "Traçar o fluxo recursivo completo de um parser top-down em uma entrada.",
                                  "commonMistakes": [
                                    "Esquecer de consumir tokens após matching",
                                    "Não gerenciar backtracking corretamente",
                                    "Perder o controle do lookahead atual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Seleção de Produções com Lookahead",
                                  "subSteps": [
                                    "Construa uma tabela de parsing LL(1): para cada não-terminal e lookahead, associe produção.",
                                    "Calcule FIRST e FOLLOW sets para a gramática para preencher a tabela.",
                                    "Simule seleção: se lookahead em FIRST(produção), expanda; senão, erro ou backtrack.",
                                    "Teste com ambiguidade parcial: escolha produção baseada em lookahead de 1 token.",
                                    "Codifique uma função simples em pseudocódigo que consulta a tabela para decidir expansão."
                                  ],
                                  "verification": "Crie e preencha uma tabela LL(1) para uma gramática simples e valide com 2 strings de teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora de FIRST/FOLLOW online ou manual",
                                    "Gramática de exemplo"
                                  ],
                                  "tips": "Memorize que LL(1) significa Left-to-right, Leftmost derivation com 1 lookahead.",
                                  "learningObjective": "Implementar e usar lookahead para seleção determinística de produções.",
                                  "commonMistakes": [
                                    "Erros em FIRST/FOLLOW calculation",
                                    "Tabela com múltiplas entradas para mesmo lookahead",
                                    "Não tratar epsilon-produções corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Mitigar Problemas: Ambiguidade e Left-Recursion",
                                  "subSteps": [
                                    "Defina ambiguidade: múltiplas árvores de derivação para mesma string; detecte via tabela com conflitos.",
                                    "Explique left-recursion: A → A α | β causa loop infinito; reescreva para A → β A'.",
                                    "Identifique left-recursion indireta e demonstre eliminação passo a passo.",
                                    "Discuta soluções: fatoração à esquerda para ambiguidade, reescrita recursiva para left-recursion.",
                                    "Teste uma gramática ambígua/left-recursive e corrija-a para LL(1)."
                                  ],
                                  "verification": "Transforme uma gramática left-recursive em não-recursiva e verifique parsing sem loops.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas problemáticas",
                                    "Ferramenta online de parsing como JFLAP"
                                  ],
                                  "tips": "Sempre cheque left-recursion primeiro: se A → A ..., reescreva imediatamente.",
                                  "learningObjective": "Diagnosticar e resolver ambiguidade e left-recursion em gramáticas para parsing top-down.",
                                  "commonMistakes": [
                                    "Confundir ambiguidade com não-determinismo",
                                    "Falhar em eliminar recursão indireta",
                                    "Ignorar impactos em tempo de execução"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática E → T | E + T; T → id | (E). Para entrada 'id + id', inicie E(): lookahead 'id' → T(); T(): 'id' match, consuma; back to E, lookahead '+' → E + T; etc. Trace resulta em árvore de parse correta sem recursão infinita.",
                              "finalVerifications": [
                                "Trace corretamente o parsing de 3 strings em uma gramática LL(1).",
                                "Construa tabela LL(1) sem conflitos para gramática dada.",
                                "Elimine left-recursion de uma gramática simples.",
                                "Identifique ambiguidade em gramática e proponha refactor.",
                                "Explique em voz alta o papel do lookahead em 1 minuto.",
                                "Implemente parser recursivo simples em pseudocódigo funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão no trace de parsing recursivo (sem erros de pilha).",
                                "Correção de FIRST/FOLLOW e tabela LL(1).",
                                "Identificação precisa de ambiguidade e left-recursion.",
                                "Capacidade de reescrever gramáticas para LL(1).",
                                "Explicação clara do algoritmo em termos de lookahead e expansão.",
                                "Uso efetivo de verificações em cada step."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e árvores de recursão.",
                                "Programação: Implementação de funções recursivas e backtracking.",
                                "Lógica: Conjuntos FIRST/FOLLOW como predicados lógicos.",
                                "Engenharia de Software: Design de linguagens e compiladores."
                              ],
                              "realWorldApplication": "Usado em compiladores como GCC para C++ (fases iniciais), parsers JSON/XML em navegadores, e ferramentas de desenvolvimento como ANTLR para gerar parsers recursivos descendentes em aplicações web e mobile."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Identificar necessidade de lookahead",
                            "description": "Explicar o papel do lookahead (k=1 para LL(1)) para resolver escolhas de produção sem backtracking, e dar exemplos de gramáticas que requerem lookahead.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Parsing Top-Down e Problemas de Ambiguidade",
                                  "subSteps": [
                                    "Revise o conceito de parsing top-down recursivo descendente (LL).",
                                    "Identifique problemas comuns como recursão à esquerda e fatoração à esquerda.",
                                    "Explique por que o backtracking é necessário em parsers simples sem lookahead.",
                                    "Analise uma gramática simples ambígua sem lookahead, como S → aS | ε.",
                                    "Discuta a ineficiência do backtracking em termos de tempo exponencial."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito um exemplo onde backtracking falha sem lookahead.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas sobre gramáticas livres de contexto",
                                    "Exemplos de gramáticas LL(1)",
                                    "Editor de texto para diagramas"
                                  ],
                                  "tips": "Comece com gramáticas mínimas para visualizar o problema antes de complexas.",
                                  "learningObjective": "Entender as limitações do parsing top-down puro e a motivação para lookahead.",
                                  "commonMistakes": [
                                    "Confundir backtracking com parsing bottom-up",
                                    "Ignorar recursão à esquerda como causa primária",
                                    "Subestimar o custo computacional do backtracking"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Calcular Conjuntos FIRST com Lookahead k=1",
                                  "subSteps": [
                                    "Defina os conjuntos FIRST para não-terminais e produções.",
                                    "Calcule FIRST para uma gramática dada passo a passo.",
                                    "Explique o papel do lookahead k=1 em LL(1): usar o primeiro token para escolher produção.",
                                    "Verifique se uma gramática é LL(1) checando disjointness de FIRST sets para alternativas.",
                                    "Pratique cálculo em 2-3 gramáticas simples."
                                  ],
                                  "verification": "Calcule corretamente os FIRST sets de uma gramática fornecida e identifique sobreposições.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de símbolos terminais/não-terminais",
                                    "Ferramenta online para FIRST sets (opcional)",
                                    "Papel e caneta para tabelas"
                                  ],
                                  "tips": "Use tabelas para rastrear FIRST; lembre-se que FIRST(ε-produção) inclui FOLLOW.",
                                  "learningObjective": "Dominar o cálculo de FIRST e reconhecer quando lookahead resolve ambiguidades.",
                                  "commonMistakes": [
                                    "Incluir ε incorretamente em FIRST",
                                    "Esquecer propagação em produções longas",
                                    "Confundir FIRST com FOLLOW"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Gramáticas que Requerem Lookahead",
                                  "subSteps": [
                                    "Analise gramáticas não LL(1), como S → if C then S | if C then S else S.",
                                    "Destaque onde FIRST se sobrepõem e lookahead=1 falha (ex: precisa ver 'else').",
                                    "Compare com gramáticas LL(1) após left-factoring.",
                                    "Crie uma gramática personalizada e teste necessidade de lookahead.",
                                    "Discuta limitações de k=1 e quando k>1 é necessário."
                                  ],
                                  "verification": "Classifique 3 gramáticas como LL(1) ou não, justificando com FIRST sets.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos clássicos de livros como 'Compilers' de Aho",
                                    "Simulador de parser online",
                                    "Planilha para FIRST/FOLLOW"
                                  ],
                                  "tips": "Sempre left-factor primeiro; lookahead é para casos restantes.",
                                  "learningObjective": "Diagnosticar precisamente quando uma gramática requer lookahead para evitar backtracking.",
                                  "commonMistakes": [
                                    "Não left-factor antes de checar lookahead",
                                    "Ignorar FOLLOW em nullable não-terminais",
                                    "Assumir toda gramática precisa lookahead"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar Necessidade de Lookahead em Exemplos Práticos",
                                  "subSteps": [
                                    "Implemente um parser simples em pseudocódigo com lookahead k=1.",
                                    "Teste com gramática ambígua e observe falhas sem lookahead.",
                                    "Modifique para incluir lookahead e compare desempenho.",
                                    "Gere relatório de casos onde lookahead é essencial.",
                                    "Resolva exercícios variados para reforço."
                                  ],
                                  "verification": "Implemente e execute um parser que usa lookahead corretamente em uma gramática não-trivial.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pseudocódigo ou Python simples para parser",
                                    "Entrada de teste com tokens",
                                    "Debugger ou console"
                                  ],
                                  "tips": "Use tokens de lookahead como uma fila; avance apenas após match.",
                                  "learningObjective": "Aplicar conceitos para identificar e resolver necessidades de lookahead na prática.",
                                  "commonMistakes": [
                                    "Avançar lookahead sem consumir token",
                                    "Não resetar lookahead em backtrack simulado",
                                    "Testar só casos triviais"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática: S → if C then S | if C then S else S | other. Sem lookahead, após 'if C then', o parser não sabe se escolher a primeira ou segunda produção até ver 'else'. Com lookahead k=1 no próximo token ('else' vs outro), decide sem backtracking.",
                              "finalVerifications": [
                                "Calcule FIRST sets corretamente para 3 gramáticas diferentes.",
                                "Identifique e explique lookahead necessário em uma gramática ambígua.",
                                "Implemente um parser LL(1) simples que parse uma string sem erros.",
                                "Diferencie gramáticas LL(1) de não-LL(1) com justificativa.",
                                "Discuta trade-offs de lookahead vs backtracking.",
                                "Resolva um problema inédito envolvendo FOLLOW para nullable."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de FIRST/FOLLOW sets (80% correto).",
                                "Capacidade de diagnosticar necessidade de lookahead em novas gramáticas.",
                                "Clareza na explicação de exemplos com diagramas ou tabelas.",
                                "Implementação funcional de parser com lookahead.",
                                "Identificação correta de erros comuns em parsing top-down.",
                                "Conexão com eficiência computacional (tempo O(n))."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (operações em FIRST/FOLLOW).",
                                "Programação: Implementação de parsers em linguagens como Python ou Java.",
                                "Lógica: Análise de ambiguidades e resolução determinística.",
                                "Engenharia de Software: Design de compiladores e ferramentas de análise.",
                                "Algoritmos: Otimização para evitar backtracking exponencial."
                              ],
                              "realWorldApplication": "Em compiladores reais como GCC ou Clang, lookahead LL(k) é usado em pré-processamento para parsing eficiente de linguagens como C++ ou Java, evitando backtracking em construções condicionais complexas e melhorando performance em código de produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Gramáticas LL(1)",
                        "description": "Propriedades e condições para que uma gramática livre de contexto seja analisável por um parser LL(1), incluindo ausência de left-recursion e FIRST/FOLLOW não sobrepostos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Calcular conjuntos FIRST",
                            "description": "Computar o conjunto FIRST(A) para não-terminais A, considerando produções ε e recursão, com exemplos passo a passo para gramáticas dadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a gramática e identificar símbolos",
                                  "subSteps": [
                                    "Analise a gramática fornecida e liste todos os não-terminais (variáveis, usualmente maiúsculas).",
                                    "Identifique os terminais (símbolos folha, usualmente minúsculas ou especiais).",
                                    "Marque produções que geram ε (produção vazia).",
                                    "Crie uma tabela inicial com colunas para cada não-terminal e suas produções.",
                                    "Verifique se a gramática está em forma normal (sem ε-produções mistas, exceto para start symbol)."
                                  ],
                                  "verification": "Confirme que todos não-terminais e produções estão listados corretamente sem duplicatas ou omissões.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gramática de exemplo em papel ou editor de texto",
                                    "Folha de cálculo ou quadro branco"
                                  ],
                                  "tips": "Use notação padrão: não-terminais em maiúsculas, terminais em minúsculas.",
                                  "learningObjective": "Identificar corretamente os componentes da gramática para cálculo de FIRST.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Ignorar produções ε"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar conjuntos FIRST",
                                  "subSteps": [
                                    "Crie um conjunto vazio FIRST(A) para cada não-terminal A.",
                                    "Para cada produção A → ε, adicione ε diretamente a FIRST(A).",
                                    "Para produções A → a (terminal), adicione 'a' a FIRST(A).",
                                    "Registre as inicializações em uma tabela.",
                                    "Verifique se há recursão direta (A → A ...) e anote para iterações futuras."
                                  ],
                                  "verification": "Todos os FIRST iniciais refletem apenas produções diretas para terminais ou ε.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de FIRST em planilha ou papel",
                                    "Gramática anotada"
                                  ],
                                  "tips": "Use {} para conjuntos vazios e liste elementos separados por vírgula.",
                                  "learningObjective": "Configurar a base para propagação de FIRST sets.",
                                  "commonMistakes": [
                                    "Adicionar elementos prematuramente de não-diretos",
                                    "Esquecer ε em produções vazias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar produções com sequências de símbolos",
                                  "subSteps": [
                                    "Para cada produção A → X1 X2 ... Xk, comece com X1: adicione FIRST(X1) \\ {ε} a FIRST(A).",
                                    "Se ε ∈ FIRST(X1), continue para X2, adicionando FIRST(X2) \\ {ε}, e assim por diante.",
                                    "Se todos Xi derivam ε, adicione ε a FIRST(A).",
                                    "Atualize a tabela de FIRST com novas adições.",
                                    "Repita para todas produções de todos não-terminais."
                                  ],
                                  "verification": "Comparar atualizações: nenhum FIRST mudou sem justificativa de produção.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de FIRST atualizada",
                                    "Lista de produções por não-terminal"
                                  ],
                                  "tips": "Processe uma produção por vez para evitar confusão na propagação.",
                                  "learningObjective": "Aplicar regras de propagação para sequências em produções.",
                                  "commonMistakes": [
                                    "Parar propagação cedo sem verificar ε",
                                    "Adicionar todo FIRST(Xi) incluindo ε quando não deve"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar até fixpoint para recursão e dependências",
                                  "subSteps": [
                                    "Repita o Step 3 para todas produções até que nenhum FIRST mude.",
                                    "Monitore mudanças em cada iteração (use marcações para rastrear).",
                                    "Para recursão esquerda (A → A β), garanta propagação após resolver dependências.",
                                    "Teste convergência: se nenhuma adição em uma iteração completa, pare.",
                                    "Finalize a tabela de FIRST para todos não-terminais."
                                  ],
                                  "verification": "Execute uma iteração extra sem mudanças para confirmar fixpoint.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de FIRST com histórico de iterações",
                                    "Marcadores para mudanças"
                                  ],
                                  "tips": "Ordene não-terminais por dependências topológicas se possível para menos iterações.",
                                  "learningObjective": "Resolver dependências cíclicas via iteração até estabilidade.",
                                  "commonMistakes": [
                                    "Parar iterações prematuramente",
                                    "Ignorar recursão indireta"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e documentar o resultado",
                                  "subSteps": [
                                    "Verifique propriedades: FIRST(A) ⊆ terminais ∪ {ε}, sem não-terminais.",
                                    "Teste com derivações de exemplo: primeiros terminais devem estar em FIRST.",
                                    "Anote o conjunto FIRST final para cada não-terminal.",
                                    "Compare com gramática conhecida ou ferramenta online para validação.",
                                    "Escreva um resumo passo a passo do cálculo."
                                  ],
                                  "verification": "Todos testes de derivação passam e propriedades são satisfeitas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Ferramenta de validação online (opcional)",
                                    "Exemplos de derivações"
                                  ],
                                  "tips": "Use derivações curtas para testes rápidos.",
                                  "learningObjective": "Garantir correção e completude dos conjuntos FIRST.",
                                  "commonMistakes": [
                                    "Incluir não-terminais em FIRST",
                                    "Esquecer ε quando aplicável"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → A | ε, A → a B, B → b | ε. Cálculo: FIRST(S) = {a, ε}, FIRST(A) = {a}, FIRST(B) = {b, ε}. Passos: Inicialize com ε para S e B; propague 'a' para A e S; propague de B para A (incluindo ε, mas já coberto).",
                              "finalVerifications": [
                                "Conjuntos FIRST contêm apenas terminais e/ou ε.",
                                "Para toda produção A → α, FIRST(α) ⊆ FIRST(A).",
                                "Algumas derivações curtas começam com terminais em FIRST(A).",
                                "Fixpoint alcançado sem mudanças em iteração final.",
                                "Produções ε corretamente refletidas.",
                                "Recursão resolvida sem loops infinitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de símbolos e inicialização (20%).",
                                "Correta propagação em sequências e ε-handling (30%).",
                                "Iterações até fixpoint com rastreamento (25%).",
                                "Validação com testes de derivação (15%).",
                                "Documentação clara e sem erros comuns (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e fechamento transitivo.",
                                "Programação: Implementação iterativa como algoritmo de grafos.",
                                "Lógica: Propagação de fatos em sistemas de regras.",
                                "Engenharia de Software: Análise de dependências em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores (ex: GCC, JavaCC), calcular FIRST é essencial para construir tabelas de parsing LL(1), permitindo análise sintática eficiente de código-fonte em linguagens de programação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Calcular conjuntos FOLLOW",
                            "description": "Determinar o conjunto FOLLOW(A), incluindo regras para o símbolo inicial e propagação de terminais/FIRST de produções subsequentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Gramática e Inicializar Conjuntos FOLLOW",
                                  "subSteps": [
                                    "Identifique todos os não-terminais (variáveis) e o símbolo inicial da gramática.",
                                    "Liste todas as produções da gramática em formato A → α.",
                                    "Crie uma tabela ou estrutura vazia para os conjuntos FOLLOW de cada não-terminal (ex: FOLLOW(A) = {} ).",
                                    "Adicione o terminal '$' (fim de entrada) ao FOLLOW do símbolo inicial.",
                                    "Marque quais não-terminais são anuláveis (podem derivar ε)."
                                  ],
                                  "verification": "Confira se a tabela de FOLLOW tem um conjunto não-vazio apenas para o símbolo inicial com '$' e todos os outros vazios.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Gramática de exemplo impressa ou digital"
                                  ],
                                  "tips": "Use abreviações como NT para não-terminais e T para terminais para organizar melhor.",
                                  "learningObjective": "Entender a estrutura inicial dos FOLLOW sets e a regra especial para o símbolo inicial.",
                                  "commonMistakes": [
                                    "Esquecer de identificar o símbolo inicial",
                                    "Inicializar FOLLOW com terminais errados",
                                    "Não listar produções completamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Regra 2: Propagar FIRST de Sequências Seguintes",
                                  "subSteps": [
                                    "Para cada produção A → α B β, compute FIRST(β) excluindo ε.",
                                    "Adicione os terminais de FIRST(β) ao FOLLOW(B).",
                                    "Repita para todas as produções onde B é seguido por β não-vazio.",
                                    "Atualize a tabela de FOLLOW e anote as mudanças.",
                                    "Verifique se FIRST(β) foi calculado corretamente (revisar FIRST sets prévios)."
                                  ],
                                  "verification": "Para cada B seguido por β, confirme que terminais de FIRST(β) estão em FOLLOW(B) sem duplicatas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de FIRST pré-calculada",
                                    "Planilha ou quadro para anotar atualizações"
                                  ],
                                  "tips": "Comece pelas produções mais simples; liste FIRST(β) explicitamente antes de adicionar.",
                                  "learningObjective": "Dominar a propagação de terminais possíveis após um não-terminal via FIRST.",
                                  "commonMistakes": [
                                    "Incluir ε em FIRST(β)",
                                    "Esquecer produções onde β é terminal simples",
                                    "Adicionar não-terminais a FOLLOW"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Regra 3: Propagar FOLLOW através de Produções Anuláveis",
                                  "subSteps": [
                                    "Para cada produção A → α B (β vazio ou anulável), adicione FOLLOW(A) a FOLLOW(B).",
                                    "Identifique produções terminando em B ou com β ⇒* ε.",
                                    "Copie conjuntos FOLLOW(A) para FOLLOW(B) e una aos existentes.",
                                    "Repita para cadeias de anulabilidade (ex: se C anulável e segue B, propague).",
                                    "Atualize a tabela iterativamente até sem mudanças nesta regra."
                                  ],
                                  "verification": "Verifique que todo FOLLOW(B) inclui FOLLOW(A) para produções relevantes com β anulável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de anuláveis marcada",
                                    "Marcadores para rastrear propagação"
                                  ],
                                  "tips": "Use set union (∪) simbolicamente; evite loops manuais rastreando mudanças por iteração.",
                                  "learningObjective": "Compreender a propagação recursiva de FOLLOW em gramáticas com ε-produções.",
                                  "commonMistakes": [
                                    "Não detectar anulabilidade corretamente",
                                    "Propagar em loops infinitos sem fixpoint",
                                    "Ignorar propagação em múltiplos níveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar Regras até Convergência e Finalizar",
                                  "subSteps": [
                                    "Execute regras 2 e 3 em loop até nenhum conjunto FOLLOW mudar.",
                                    "Em cada iteração, aplique todas as produções novamente.",
                                    "Registre o número de iterações necessárias.",
                                    "Remova duplicatas e ordene terminais alfabeticamente nos conjuntos finais.",
                                    "Compare com FIRST para evitar confusões (FOLLOW só terminais)."
                                  ],
                                  "verification": "Confirme que uma iteração extra não altera nenhum FOLLOW set (fixpoint alcançado).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de FOLLOW iterativa",
                                    "Cronômetro para iterações"
                                  ],
                                  "tips": "Limite iterações a |NT| + 1; use pseudocódigo do algoritmo para guiar.",
                                  "learningObjective": "Implementar o algoritmo iterativo completo para FOLLOW sets.",
                                  "commonMistakes": [
                                    "Parar cedo sem fixpoint",
                                    "Confundir FIRST e FOLLOW",
                                    "Incluir $ em FOLLOW não-inicial"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → A | B C; A → a A | ε; B → b; C → c | d C. Inicial: FOLLOW(S)={$}. Regra2: Para B→b em S→B C, FIRST(C)={c,d} → FOLLOW(B). Para C em S→B C, FIRST(ε)=∅. Regra3: FOLLOW(S) para A em S→A; FOLLOW(S) para C via A anulável? Não diretamente. Iterar: FOLLOW(A)={$}, FOLLOW(C)={$ } via S→B C e fim implícito. Fixpoint: FOLLOW(A)={$}, FOLLOW(B)={c,d}, FOLLOW(C)={$}.",
                              "finalVerifications": [
                                "FOLLOW do símbolo inicial contém '$'.",
                                "Todos FOLLOW sets contêm apenas terminais, sem não-terminais ou ε.",
                                "Para toda produção A→α B β, FIRST(β-) ⊆ FOLLOW(B).",
                                "Para toda A→α B ou β anulável, FOLLOW(A) ⊆ FOLLOW(B).",
                                "Algoritmo convergeu sem mudanças em iteração final.",
                                "Conjuntos são minimais (sem duplicatas ou extras)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos terminais corretos em cada FOLLOW.",
                                "Completude: Todas regras aplicadas sem omissões.",
                                "Eficiência: Convergência em ≤ número de não-terminais iterações.",
                                "Clareza: Tabela final organizada e anotada.",
                                "Correção de anulabilidade e FIRST usados.",
                                "Ausência de erros comuns como propagação errada de $."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos (união, inclusão) e fixpoints iterativos.",
                                "Programação: Implementação de algoritmos em loops while (ex: Python sets).",
                                "Lógica: Inferência por regras de produção e propagação.",
                                "Engenharia de Software: Análise de dependências em sistemas formais."
                              ],
                              "realWorldApplication": "Essencial para construir tabelas de parsing LL(1) em compiladores (ex: GCC, JavaCC), validadores sintáticos em IDEs e processadores de linguagens em ferramentas como ANTLR, garantindo parsing eficiente sem backtracking."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Verificar se uma gramática é LL(1)",
                            "description": "Aplicar o teste de LL(1): para cada produção A → α, FIRST(α) e FOLLOW(A) não se intersectam para diferentes produções de A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e organizar os componentes da gramática",
                                  "subSteps": [
                                    "Liste todos os terminais (símbolos foliares) e não-terminais (variáveis).",
                                    "Identifique o símbolo inicial S.",
                                    "Agrupe todas as produções por não-terminal esquerdo (A → α).",
                                    "Verifique se há recursão à esquerda direta (A → A β).",
                                    "Anote se alguma produção tem ε (produção vazia)."
                                  ],
                                  "verification": "Crie uma tabela com colunas: Não-terminal, Produções, Terminais, Não-terminais, Símbolo inicial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou planilha",
                                    "Gramática de exemplo"
                                  ],
                                  "tips": "Use sets para representar símbolos e mantenha consistência na notação (ex: maiúsculas para não-terminais).",
                                  "learningObjective": "Entender a estrutura formal da gramática para análise.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais.",
                                    "Ignorar produções vazias.",
                                    "Esquecer o símbolo inicial."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os conjuntos FIRST para todos os símbolos",
                                  "subSteps": [
                                    "Para terminais t: FIRST(t) = {t}.",
                                    "Para não-terminais A sem recursão: FIRST(A) = ∪ FIRST(primeiro símbolo de cada produção A → Xα).",
                                    "Repita iterativamente até fixpoint para dependências cíclicas.",
                                    "Se uma produção A → ε, inclua ε em FIRST(A).",
                                    "Para cada rhs α = X1 X2..., FIRST(α) = FIRST(X1) se não nullable, senão ∪ FIRST(X2)... até não-nullable ou ε."
                                  ],
                                  "verification": "Tabela com FIRST(símbolo) para cada terminal e não-terminal, sem interseções indevidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha para tabelas de FIRST",
                                    "Algoritmo de FIRST impresso"
                                  ],
                                  "tips": "Comece pelos não-terminais sem dependências; use algoritmo iterativo com fixpoint.",
                                  "learningObjective": "Dominar o cálculo de FIRST considerando nulabilidade.",
                                  "commonMistakes": [
                                    "Não propagar FIRST através de símbolos nullable.",
                                    "Esquecer ε em FIRST.",
                                    "Ciclos não resolvidos por iteração."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os conjuntos FOLLOW para cada não-terminal",
                                  "subSteps": [
                                    "FOLLOW(S) inclui $ (fim de entrada).",
                                    "Para produção A → α B β, adicione FIRST(β) a FOLLOW(B).",
                                    "Se β nullable ou fim, adicione FOLLOW(A) a FOLLOW(B).",
                                    "Repita iterativamente para todas as produções até fixpoint.",
                                    "Verifique consistência sem duplicatas."
                                  ],
                                  "verification": "Tabela com FOLLOW(A) para cada não-terminal A.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha para FOLLOW",
                                    "Lista de produções anotadas"
                                  ],
                                  "tips": "Propague FOLLOW apenas após FIRST calculado; priorize de cima para baixo nas dependências.",
                                  "learningObjective": "Compreender propagação de FOLLOW considerando nulabilidade.",
                                  "commonMistakes": [
                                    "Não incluir $ no FOLLOW inicial.",
                                    "Não propagar através de múltiplos nullables.",
                                    "Confundir FIRST com FOLLOW."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar as condições de LL(1) para cada não-terminal",
                                  "subSteps": [
                                    "Para cada A com múltiplas produções A → α1, A → α2, ..., verifique FIRST(αi) ∩ FIRST(αj) = ∅ para i ≠ j.",
                                    "Se alguma αi nullable (FIRST(αi) contém ε), verifique FIRST(αi sem ε) ∪ FOLLOW(A) disjunto de outros FIRST(αj).",
                                    "Confirme ausência de recursão à esquerda indireta (use algoritmo se necessário).",
                                    "Teste interseções: para cada par de produções, liste símbolos comuns.",
                                    "Conclua: LL(1) se todas disjuntas."
                                  ],
                                  "verification": "Relatório por não-terminal: 'LL(1): sim/não' com justificativa de interseções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabelas de FIRST e FOLLOW",
                                    "Ferramenta de conjuntos como Python sets"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar interseções; teste com |FIRST(αi)| > 0.",
                                  "learningObjective": "Aplicar teste preciso de LL(1) integrando FIRST e FOLLOW.",
                                  "commonMistakes": [
                                    "Ignorar FOLLOW para produções nullable.",
                                    "Permitir interseções parciais.",
                                    "Não detectar left-recursion indireta."
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática G: S → A | B, A → a | ε, B → b. Calcule FIRST: FIRST(A)={a,ε}, FIRST(B)={b}, FIRST(S)={a,b}. FOLLOW(S)={$}, FOLLOW(A)={$}, FOLLOW(B)={$}. Verificação: Para S, FIRST(A)∩FIRST(B)=∅, mas A nullable → FOLLOW(S)∩FIRST(B)={$∩b}=∅. Para A: FIRST(a)∩FIRST(ε) ok com FOLLOW. É LL(1).",
                              "finalVerifications": [
                                "Calculou FIRST e FOLLOW corretamente para todos símbolos.",
                                "Identificou corretamente nulabilidades.",
                                "Verificou disjuntas sem erros em interseções.",
                                "Detectou se a gramática é LL(1) com justificativa.",
                                "Aplicou teste em exemplo sem left-recursion.",
                                "Listou todas produções sem omissões."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de FIRST e FOLLOW (100% correto).",
                                "Correta identificação de nulabilidades e propagação.",
                                "Verificação exaustiva de disjuntas para todos pares de produções.",
                                "Tratamento adequado de FOLLOW em casos nullable.",
                                "Clareza na documentação de passos e tabelas.",
                                "Ausência de left-recursion detectada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e interseções.",
                                "Programação: Implementação de tabelas de parsing em compiladores.",
                                "Lógica: Inferência e algoritmos iterativos fixpoint.",
                                "Engenharia de Software: Análise de gramáticas em ferramentas como ANTLR ou Yacc."
                              ],
                              "realWorldApplication": "Em desenvolvimento de compiladores e interpretadores, verificar LL(1) permite usar parsers preditivos eficientes como LL(1) top-down, otimizando análise sintática em linguagens como JavaScript ou Python parsers personalizados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Algoritmo e Tabela de Parsing LL(1)",
                        "description": "Construção da tabela de parsing preditiva LL(1) e execução do algoritmo não-recursivo usando pilha para análise de strings.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Construir a tabela de parsing LL(1)",
                            "description": "Preencher a tabela M[A, t] com produções baseadas em FIRST(α) ∪ (FIRST(β) se ε em α, com FOLLOW(A)), identificando conflitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática e listar componentes essenciais",
                                  "subSteps": [
                                    "Identifique todos os não-terminais (A), terminais (t) e o símbolo $ (fim de entrada).",
                                    "Liste todas as produções da gramática no formato A → α.",
                                    "Crie uma tabela vazia M com linhas para não-terminais e colunas para terminais + $."
                                  ],
                                  "verification": "Verifique se a lista de produções está completa e a tabela inicial tem as dimensões corretas (ex: 5 linhas x 10 colunas).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou planilha (Google Sheets/Excel)"
                                  ],
                                  "tips": "Use abreviações para terminais longos e organize a tabela com linhas para não-terminais em ordem alfabética.",
                                  "learningObjective": "Entender a estrutura da gramática LL(1) e preparar a tabela de parsing.",
                                  "commonMistakes": [
                                    "Esquecer o símbolo $ nas colunas.",
                                    "Confundir terminais com não-terminais.",
                                    "Não listar todas as produções."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular FIRST(α) para cada lado direito das produções",
                                  "subSteps": [
                                    "Para cada produção A → α, compute o conjunto FIRST(α) seguindo as regras: se α começa com terminal t, FIRST = {t}; se não-terminal, una FIRST dele; propague ε se nullable.",
                                    "Anote FIRST(α) ao lado de cada produção.",
                                    "Verifique se FIRST(α) não contém ε explicitamente aqui (trate nullable separadamente).",
                                    "Registre todos os terminais em FIRST(α)."
                                  ],
                                  "verification": "Compare FIRST(α) com valores conhecidos ou recalcule manualmente para uma produção simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de FIRST pré-calculada (se disponível)",
                                    "Folha de cálculo para conjuntos"
                                  ],
                                  "tips": "Comece pelas produções mais simples (sem recursão) e use set union para combinações.",
                                  "learningObjective": "Dominar o cálculo de FIRST para sequências de símbolos.",
                                  "commonMistakes": [
                                    "Não propagar ε corretamente.",
                                    "Incluir não-terminais em FIRST.",
                                    "Duplicar terminais no conjunto."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar produções nullable e calcular FOLLOW(A)",
                                  "subSteps": [
                                    "Determine quais α derivam ε (produções nullable: A → ε ou cadeia de nullables).",
                                    "Para cada não-terminal A, liste o conjunto FOLLOW(A), assumindo pré-calculado ou compute via algoritmo padrão.",
                                    "Para produções A → α onde ε ∈ FIRST(α), prepare a união FIRST(α) ∪ FOLLOW(A).",
                                    "Anote FOLLOW(A) para cada não-terminal."
                                  ],
                                  "verification": "Teste se FOLLOW(S) contém $ para o axioma inicial S.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Algoritmo de FOLLOW impresso",
                                    "Calculadora para rastrear dependências"
                                  ],
                                  "tips": "FOLLOW propaga de contextos: de produções B → α A β, FOLLOW(A) inclui FIRST(β) e FOLLOW(B) se β nullable.",
                                  "learningObjective": "Aplicar conceitos de nullable e FOLLOW para completar previsões.",
                                  "commonMistakes": [
                                    "Confundir FIRST com FOLLOW.",
                                    "Esquecer FOLLOW em produções recursivas à esquerda.",
                                    "Não incluir $ no FOLLOW do start symbol."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preencher a tabela M[A, t] com as produções",
                                  "subSteps": [
                                    "Para cada produção A → α, adicione 'A → α' nas células M[A, a] para todo a ∈ FIRST(α).",
                                    "Se ε ∈ FIRST(α), adicione também nas células M[A, b] para b ∈ FOLLOW(A).",
                                    "Preencha linha por linha, produção por produção.",
                                    "Use set union para evitar duplicatas iniciais."
                                  ],
                                  "verification": "Conte o número de entradas por linha; deve cobrir todos os terminais relevantes sem lacunas excessivas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela preparada do step 1",
                                    "Lista de FIRST e FOLLOW"
                                  ],
                                  "tips": "Marque células com cor para produções nullable vs. FIRST.",
                                  "learningObjective": "Executar o preenchimento sistemático da tabela LL(1).",
                                  "commonMistakes": [
                                    "Adicionar em colunas erradas (ex: usar FOLLOW sem nullable).",
                                    "Sobrescrever entradas sem notar.",
                                    "Esquecer uniões para múltiplas produções de A."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar conflitos e finalizar a tabela",
                                  "subSteps": [
                                    "Inspecione cada célula: se >1 produção, marque como conflito (LL(1) inválida).",
                                    "Confirme que células vazias são OK (não previsíveis).",
                                    "Copie a tabela final limpa e anote conflitos se houver.",
                                    "Teste com lookahead simples: simule parsing de uma string curta."
                                  ],
                                  "verification": "A tabela é LL(1) se zero conflitos; liste posições de conflitos se existirem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela preenchida",
                                    "Exemplo de string para teste"
                                  ],
                                  "tips": "Conflitos comuns: recursão esquerda ou FIRST sobrepostos; reescreva gramática se necessário.",
                                  "learningObjective": "Identificar e diagnosticar problemas na tabela LL(1).",
                                  "commonMistakes": [
                                    "Ignorar conflitos múltiplos na mesma célula.",
                                    "Marcar vazio como conflito.",
                                    "Não testar com parsing."
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → A | B; A → a A | ε; B → b. Terminais: a,b,$; Não-terminais: S,A,B. FIRST(A)={a,ε}, FOLLOW(A)={b,$} (assumindo). Tabela: M[S,a]='S→A', M[S,b]='S→B'; M[A,a]='A→a A', M[A,b]='A→ε', M[A,$]='A→ε'; M[B,b]='B→b'. Sem conflitos.",
                              "finalVerifications": [
                                "Todas as células M[A,t] estão preenchidas corretamente com produções baseadas em FIRST e FOLLOW.",
                                "Nenhuma célula tem mais de uma produção (zero conflitos para LL(1)).",
                                "FOLLOW é usado apenas para produções nullable.",
                                "A tabela cobre todos terminais e $.",
                                "Simulação de parsing em uma string curta funciona sem erro.",
                                "FIRST e FOLLOW cálculos batem com verificação manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de FIRST(α) e FOLLOW(A): 100% correto.",
                                "Preenchimento da tabela sem erros de posicionamento.",
                                "Detecção correta de conflitos (se aplicável).",
                                "Estrutura da tabela clara e organizada.",
                                "Explicação verbal dos passos lógicos.",
                                "Tempo de execução eficiente dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações com conjuntos (união, FIRST/FOLLOW como funções).",
                                "Programação: Implementação de tabelas em linguagens como Python/Java para parsers.",
                                "Lógica: Tabelas de decisão e automatos finitos.",
                                "Engenharia de Software: Design de compiladores e ferramentas de análise.",
                                "Algoritmos: Similaridade com tabelas de transição em AF/PD."
                              ],
                              "realWorldApplication": "Construção de analisadores sintáticos em compiladores (ex: GCC, ANTLR) para validar sintaxe de códigos em linguagens como C++, Java ou Python, garantindo parsing eficiente e sem ambiguidades em tempo real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Executar parsing LL(1) com tabela",
                            "description": "Simular o algoritmo LL(1) usando pilha: processar entrada com lookahead, consultar tabela e expandir não-terminais ou combinar terminais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os componentes do parser LL(1)",
                                  "subSteps": [
                                    "Obtenha uma gramática LL(1) em forma normal com produções numeradas.",
                                    "Construa ou carregue a tabela de parsing LL(1), indexada por não-terminais e terminais de lookahead.",
                                    "Tokenize a string de entrada, identificando terminais e adicionando o marcador de fim '$'.",
                                    "Inicialize a pilha como vazia e o ponteiro de entrada na posição 0.",
                                    "Anote o estado inicial em papel ou simulador."
                                  ],
                                  "verification": "Gramática, tabela, entrada tokenizada e pilha vazia confirmados sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela LL(1) impressa ou digital",
                                    "Referência de FIRST e FOLLOW sets"
                                  ],
                                  "tips": "Escolha uma gramática simples inicialmente para validar a tabela sem conflitos.",
                                  "learningObjective": "Configurar corretamente todos os pré-requisitos para simulação do parsing.",
                                  "commonMistakes": [
                                    "Esquecer o marcador '$' na entrada.",
                                    "Tabela incompleta ou com células de erro não definidas.",
                                    "Tokenização incorreta de símbolos especiais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a pilha de controle",
                                  "subSteps": [
                                    "Empilhe o símbolo inicial (ex: S') no fundo da pilha.",
                                    "Empilhe o marcador de fim '$' imediatamente acima do símbolo inicial.",
                                    "Confirme que o topo da pilha é '$' e abaixo dele está o símbolo inicial.",
                                    "Registre o lookahead atual (primeiro token da entrada).",
                                    "Verifique se pilha e entrada estão sincronizadas."
                                  ],
                                  "verification": "Pilha configurada como [S', $] (topo à direita), lookahead correto.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Simulador de pilha em papel ou ferramenta online"
                                  ],
                                  "tips": "Represente a pilha visualmente com topo à direita para facilitar visualização.",
                                  "learningObjective": "Entender o estado inicial da máquina de parsing top-down.",
                                  "commonMistakes": [
                                    "Empilhar na ordem errada (esquerda-direita).",
                                    "Confundir símbolo inicial com outros não-terminais.",
                                    "Ignorar o lookahead inicial."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Combinar terminais com a entrada (Match)",
                                  "subSteps": [
                                    "Remova o topo da pilha (X).",
                                    "Se X for um terminal, compare com o lookahead atual (próximo token de entrada).",
                                    "Se coincidir, avance o ponteiro de entrada e prossiga.",
                                    "Se não coincidir, registre erro de mismatch e pare a simulação.",
                                    "Atualize e anote o novo estado da pilha e entrada."
                                  ],
                                  "verification": "Terminal removido da pilha e token consumido corretamente da entrada.",
                                  "estimatedTime": "15 minutos por ciclo",
                                  "materials": [
                                    "Folha de registro de estados"
                                  ],
                                  "tips": "Sempre use comparação exata, ignorando espaços ou case se não especificado.",
                                  "learningObjective": "Executar a fase de reconhecimento de terminais no loop principal.",
                                  "commonMistakes": [
                                    "Avançar entrada sem remover da pilha.",
                                    "Match incorreto devido a tokenização falha.",
                                    "Continuar após mismatch."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expandir não-terminais usando a tabela",
                                  "subSteps": [
                                    "Remova o topo da pilha (A, um não-terminal).",
                                    "Identifique o lookahead atual (próximo token não consumido).",
                                    "Consulte a tabela LL(1)[A, lookahead] para selecionar a produção.",
                                    "Se a célula indicar erro ou sync, registre falha de parsing.",
                                    "Caso contrário, empilhe os símbolos da RHS da produção da direita para a esquerda."
                                  ],
                                  "verification": "Não-terminal substituído corretamente pela RHS conforme tabela.",
                                  "estimatedTime": "20 minutos por expansão",
                                  "materials": [
                                    "Tabela LL(1) ampliada",
                                    "Lista de produções"
                                  ],
                                  "tips": "Push reverso garante que o primeiro símbolo da RHS fique no topo.",
                                  "learningObjective": "Aplicar predictividade LL(1) para escolha única de produção.",
                                  "commonMistakes": [
                                    "Consultar lookahead errado.",
                                    "Empilhar RHS na ordem direta.",
                                    "Ignorar células de erro na tabela."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar término e resultado do parsing",
                                  "subSteps": [
                                    "Repita os passos 3-4 até a pilha estar vazia ou entrada exaurida.",
                                    "Ao final, verifique se pilha está vazia E próximo da entrada é '$'.",
                                    "Se sim, parsing aceito; caso contrário, rejeitado (erro de sintaxe).",
                                    "Construa a árvore de parsing derivada dos estados.",
                                    "Registre o veredicto final e lições aprendidas."
                                  ],
                                  "verification": "Condições de aceitação/rejeição aplicadas corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Histórico de estados"
                                  ],
                                  "tips": "Simule múltiplas iterações para inputs válidos e inválidos.",
                                  "learningObjective": "Detectar sucesso ou falha no algoritmo LL(1).",
                                  "commonMistakes": [
                                    "Parar prematuramente.",
                                    "Confundir fim de pilha com fim de input.",
                                    "Não registrar árvore de parse."
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática LL(1): S → ( S ) | id. Tabela: S['('] = ( S ); S['id'] = id. Input: ( id ) $. Estados: 1. Pilha: S $; lookahead '('. Expand S → ( S ), pilha: ) S ( $. 2. Match '(', pilha: ) S $. 3. Expand S → id, pilha: ) id $. 4. Match 'id', pilha: ) $. 5. Match ')', pilha: $. 6. Match '$', sucesso.",
                              "finalVerifications": [
                                "Pilha vazia após processamento.",
                                "Entrada completamente consumida (ponteiro no fim).",
                                "Nenhum erro de mismatch ou tabela durante execução.",
                                "Expansões de não-terminais seguem a tabela corretamente.",
                                "Lookahead usado consistentemente em todas consultas.",
                                "Árvore de parsing reconstruída sem ambiguidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão na consulta e uso da tabela LL(1).",
                                "Correto matching de terminais com avanço de input.",
                                "Ordem exata de empilhamento da RHS (direita-esquerda).",
                                "Detecção e reporte adequado de erros de parsing.",
                                "Registro completo de estados intermediários.",
                                "Eficiência: execução em tempo linear O(n)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Tabelas de decisão e funções de lookup.",
                                "Algoritmos e Estruturas de Dados: Uso de pilha para controle recursivo descendente.",
                                "Engenharia de Software: Desenvolvimento de compiladores e parsers.",
                                "Lógica e Automata: Transições determinísticas baseadas em lookahead."
                              ],
                              "realWorldApplication": "Implementado em compiladores (GCC, Javac) e geradores de parsers como ANTLR e JavaCC para análise sintática eficiente de código-fonte em linguagens de programação, garantindo detecção rápida de erros de sintaxe."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Analisar erros de parsing LL(1)",
                            "description": "Identificar e diagnosticar erros como 'no production' ou conflitos na tabela, e sugerir correções na gramática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Construção da Tabela LL(1)",
                                  "subSteps": [
                                    "Calcular os conjuntos FIRST para todos os não-terminais.",
                                    "Calcular os conjuntos FOLLOW para todos os não-terminais.",
                                    "Preencher a tabela: para cada produção A → α, para cada a em FIRST(α), colocar A,a → α; se nullable, usar FOLLOW(A).",
                                    "Verificar células vazias (no production) e múltiplas entradas (conflitos).",
                                    "Testar com uma gramática simples sem erros."
                                  ],
                                  "verification": "Construa a tabela para uma gramática LL(1) válida e confirme ausência de erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou planilha",
                                    "Ferramenta online como JFLAP ou ANTLR preview"
                                  ],
                                  "tips": [
                                    "Sempre liste símbolos terminais primeiro.",
                                    "Use diagramas para visualizar FIRST/FOLLOW."
                                  ],
                                  "learningObjective": "Dominar a construção correta da tabela para detectar anomalias.",
                                  "commonMistakes": [
                                    "Ignorar nullable non-terminals em FOLLOW",
                                    "Confundir FIRST com FOLLOW"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Tipos Comuns de Erros",
                                  "subSteps": [
                                    "Estudar 'no production': célula vazia para non-terminal e lookahead esperado.",
                                    "Analisar conflitos: múltiplas produções na mesma célula (ex: left-recursion ou FIRST sobrepostos).",
                                    "Exemplificar left-recursion: A → A α | β causando loop.",
                                    "Exemplificar falta de left-factoring: A → a β | a γ.",
                                    "Relacionar erros com propriedades da gramática (não LL(1))."
                                  ],
                                  "verification": "Classifique 3 gramáticas com erros específicos e descreva o problema na tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas não-LL(1)",
                                    "Editor de texto para anotar tabelas"
                                  ],
                                  "tips": [
                                    "Conflitos indicam ambiguidade; vazios indicam gramática incompleta.",
                                    "Memorize: LL(1) requer FIRST disjuntos e sem left-recursion."
                                  ],
                                  "learningObjective": "Reconhecer padrões de erros comuns em tabelas LL(1).",
                                  "commonMistakes": [
                                    "Atribuir conflito a 'no production'",
                                    "Esquecer propagação de FOLLOW em nullables"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diagnosticar Erros em Gramática Dada",
                                  "subSteps": [
                                    "Receba uma gramática com erro e construa FIRST/FOLLOW.",
                                    "Preencha tabela e localize células problemáticas.",
                                    "Para 'no production': trace o lookahead e verifique cobertura de FIRST/FOLLOW.",
                                    "Para conflito: identifique produções sobrepostas e cause raiz (recursion/factoring).",
                                    "Documente diagnóstico: erro, localização, impacto no parser."
                                  ],
                                  "verification": "Forneça diagnóstico completo para uma gramática com erro fornecido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Gramáticas de teste com erros conhecidos",
                                    "Simulador de parser LL(1)"
                                  ],
                                  "tips": [
                                    "Comece pelo erro reportado pelo parser (ex: 'no viable alternative').",
                                    "Use tracing: simule parse com input problemático."
                                  ],
                                  "learningObjective": "Aplicar diagnóstico sistemático a casos reais.",
                                  "commonMistakes": [
                                    "Parar no sintoma sem raiz (ex: conflito sem checar recursion)",
                                    "Ignorar contexto do input token"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sugerir e Verificar Correções",
                                  "subSteps": [
                                    "Para left-recursion: refatore para right-recursion ou use EBNF.",
                                    "Para left-factoring: extraia prefixo comum em novo não-terminal.",
                                    "Para 'no production': adicione produção ou ajuste FOLLOW.",
                                    "Reconstrua tabela após correção e teste com inputs.",
                                    "Valide com parser: execute strings válidas/inválidas."
                                  ],
                                  "verification": "Aplique correção, reconstrua tabela sem erros e parse uma string.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Parser generator como yacc/bison",
                                    "Exemplos corrigidos"
                                  ],
                                  "tips": [
                                    "Correções mínimas preservam semântica.",
                                    "Teste com casos edge: epsilon, empty input."
                                  ],
                                  "learningObjective": "Transformar diagnóstico em correções acionáveis e verificáveis.",
                                  "commonMistakes": [
                                    "Introduzir novo conflito na correção",
                                    "Não testar FOLLOW após mudanças"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar com Casos Complexos",
                                  "subSteps": [
                                    "Analise gramática ambígua com múltiplos erros.",
                                    "Priorize diagnóstico: conflitos > no production.",
                                    "Proponha refatoração completa (EBNF se necessário).",
                                    "Compare antes/depois: tabelas e parses.",
                                    "Registre lições aprendidas."
                                  ],
                                  "verification": "Resolva 2 gramáticas complexas independentemente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Conjunto de exercícios avançados",
                                    "Ferramenta de visualização de parse trees"
                                  ],
                                  "tips": [
                                    "Use iterative refactoring: corrija um erro por vez.",
                                    "Documente todas mudanças."
                                  ],
                                  "learningObjective": "Lidar com cenários reais de múltiplos erros.",
                                  "commonMistakes": [
                                    "Sobrecorrigir levando a gramática mais complexa",
                                    "Pular verificação final"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática com erro: Expr → Expr + Term | Term; Term → Term * Factor | Factor. Construção da tabela mostra conflito em Expr,+ devido a left-recursion. Diagnóstico: left-recursion em Expr e Term. Correção: refatorar para Expr → Term Expr'; Expr' → + Term Expr' | ε; similar para Term. Nova tabela LL(1) sem conflitos; parse '1+2*3' succeeds.",
                              "finalVerifications": [
                                "Construir tabela LL(1) sem erros para gramática corrigida.",
                                "Identificar corretamente 'no production' em gramática incompleta.",
                                "Diagnosticar causa raiz de conflito (ex: left-recursion).",
                                "Propor correção que resolve erro sem introduzir novos.",
                                "Simular parse de string com/ sem erro e explicar falha.",
                                "Explicar impacto de FIRST/FOLLOW no erro.",
                                "Aplicar a 3 exemplos variados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do erro: 100% match com diagnóstico esperado.",
                                "Correção resolve problema sem novos conflitos.",
                                "Explicação da causa raiz inclui FIRST/FOLLOW.",
                                "Verificação inclui tabela reconstruída e parse bem-sucedido.",
                                "Eficiência: passos mínimos e semântica preservada.",
                                "Tratamento de edge cases (epsilon, múltiplos lookaheads).",
                                "Documentação clara e estruturada."
                              ],
                              "crossCurricularConnections": [
                                "Debugging de código em programação (identificar bugs sintáticos).",
                                "Análise lógica em matemática (provas por contradição).",
                                "Processos de troubleshooting em engenharia de software.",
                                "Modelagem de linguagens em linguística computacional.",
                                "Otimização de regras em design de sistemas."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores (ex: GCC, JavaCC), análise de erros LL(1) permite diagnósticos precisos de sintaxe em código fonte, sugerindo fixes automáticos ou mensagens de erro amigáveis para desenvolvedores, acelerando desenvolvimento de software."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Algoritmos de Parsing Bottom-Up",
                    "description": "Técnicas como LR para análise ascendente.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Parsing Shift-Reduce",
                        "description": "Fundamentos do parsing bottom-up utilizando a técnica shift-reduce, onde se constrói a árvore de derivação de baixo para cima, aplicando reduções em símbolos terminais e não-terminais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Identificar operações shift e reduce",
                            "description": "Diferenciar e aplicar as operações de shift (empilhar símbolo de entrada) e reduce (substituir handle por não-terminal) em uma pilha durante o parsing bottom-up.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a operação Shift",
                                  "subSteps": [
                                    "Estude a definição: Shift empilha o próximo símbolo de entrada na pilha.",
                                    "Visualize a pilha: A pilha cresce à direita com o símbolo shiftado.",
                                    "Analise o lookahead: O shift ocorre quando o topo da pilha + lookahead não forma um handle.",
                                    "Pratique diagramando: Desenhe pilha antes e depois de um shift.",
                                    "Compare com fila: Diferencie shift de enfileiramento em estruturas de dados."
                                  ],
                                  "verification": "Desenhe um diagrama de pilha mostrando um shift e explique o processo em voz alta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de pilha shift-reduce de um tutorial online"
                                  ],
                                  "tips": "Sempre anote o lookahead atual para decidir shift.",
                                  "learningObjective": "Explicar mecânica do shift e identificá-lo em configurações de pilha.",
                                  "commonMistakes": [
                                    "Confundir shift com reduce quando há handle",
                                    "Ignorar lookahead no processo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a operação Reduce",
                                  "subSteps": [
                                    "Defina reduce: Substitui um handle (sequência na pilha) por seu não-terminal correspondente.",
                                    "Identifique handle: Verifique se o topo da pilha + lookahead matches uma produção.",
                                    "Aplique reverso: Pop símbolos do handle e push o não-terminal.",
                                    "Atualize pilha: Mostre redução passo a passo em um diagrama.",
                                    "Verifique gramática: Consulte a tabela de parsing ou regras da gramática."
                                  ],
                                  "verification": "Simule uma redução manual em uma pilha exemplo e confirme o não-terminal correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de itens LR(0) ou SLR",
                                    "Exemplo de gramática simples"
                                  ],
                                  "tips": "Conte os símbolos a popar exatamente pelo tamanho do handle.",
                                  "learningObjective": "Reconhecer handles e executar reduce corretamente.",
                                  "commonMistakes": [
                                    "Reduzir sem match exato no lookahead",
                                    "Popar símbolos errados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Shift de Reduce",
                                  "subSteps": [
                                    "Crie tabela de decisão: Shift se sem handle; reduce se handle presente.",
                                    "Analise configuração: Examine pilha + lookahead para ambas possibilidades.",
                                    "Priorize reduce: Em conflitos, regras de precedência ou tabelas resolvem.",
                                    "Simule ambiguidades: Teste strings que causam shift-reduce conflicts.",
                                    "Pratique identificação: Classifique 5 configurações como shift ou reduce."
                                  ],
                                  "verification": "Classifique corretamente 5 exemplos de configurações de pilha fornecidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de 10 configurações de pilha de exercícios",
                                    "Simulador online de shift-reduce"
                                  ],
                                  "tips": "Sempre cheque o topo da pilha primeiro para handles.",
                                  "learningObjective": "Discernir quando aplicar shift vs reduce baseado em estado atual.",
                                  "commonMistakes": [
                                    "Shiftar quando há handle óbvio",
                                    "Reduzir múltiplos handles de uma vez"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Parsing Completo",
                                  "subSteps": [
                                    "Escolha string de entrada: Ex: id + id * id.",
                                    "Inicie pilha vazia: Comece com estado inicial e processe token por token.",
                                    "Execute loop: Alternar shift/reduce até accept ou error.",
                                    "Registre ações: Anote cada operação com pilha e lookahead.",
                                    "Valide parse tree: Construa árvore sintática final."
                                  ],
                                  "verification": "Parse uma string completa sem erros e gere a árvore sintática.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Gramática aritmética simples",
                                    "Ferramenta como Yacc/Bison demo"
                                  ],
                                  "tips": "Pause após cada ação para confirmar decisão.",
                                  "learningObjective": "Executar parsing shift-reduce identificando operações em sequência.",
                                  "commonMistakes": [
                                    "Parar prematuramente sem accept",
                                    "Ignorar estado implícito em parsing não-tabular"
                                  ]
                                }
                              ],
                              "practicalExample": "Parse a string 'id + id' com gramática E -> E + T | T, T -> id. Inicie pilha: [$]. Lookahead: id. Shift 'id' -> [$ id]. Lookahead: +. Sem handle, shift '+' -> [$ id +]. Lookahead: id. Shift 'id' -> [$ id + id]. Lookahead: $. Agora handle 'id + id' reduz para T -> [$ T]. Então handle 'T' reduz para E -> [$ E $] -> accept.",
                              "finalVerifications": [
                                "Explicar shift vs reduce em 30 segundos.",
                                "Identificar operação correta em qualquer configuração de pilha aleatória.",
                                "Parse uma string simples sem consultar notas.",
                                "Detectar e corrigir shift-reduce conflict em exemplo dado.",
                                "Construir tabela de ações para gramática mínima."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de handles (90%+ acerto).",
                                "Correta simulação de pilha em todos steps.",
                                "Explicação clara de lookahead role.",
                                "Tratamento de ambiguidades resolvido.",
                                "Parse completo resulta em accept válido.",
                                "Uso correto de gramática fornecida."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Pilhas como estrutura de dados recursiva.",
                                "Lógica: Estados finitos e autômatos.",
                                "Engenharia de Software: Compiladores e ferramentas como ANTLR.",
                                "Algoritmos: Análise bottom-up vs top-down."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou JavaCC, shift-reduce parsers processam código-fonte para gerar árvores sintáticas, habilitando análise semântica e otimização de código em apps reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Reconhecer conflitos em shift-reduce",
                            "description": "Detectar e classificar conflitos shift-reduce e reduce-reduce em gramáticas, entendendo quando múltiplas ações são possíveis para o mesmo estado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos do Parsing Shift-Reduce",
                                  "subSteps": [
                                    "Estude a estrutura básica: pilha de estados, buffer de entrada e ações possíveis (shift, reduce).",
                                    "Revise o processo de construção de itens LR(0) para um estado.",
                                    "Analise como ações são determinadas pelo estado atual e lookahead.",
                                    "Identifique os componentes chave: kernel e closure de itens."
                                  ],
                                  "verification": "Construa manualmente a tabela de parsing para uma gramática simples sem conflitos e simule 2-3 shifts e reduces.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Diagrama de itens LR(0) de exemplo",
                                    "Ferramenta online como LR Parser Generator (opcional)"
                                  ],
                                  "tips": "Desenhe a pilha visualmente para cada ação para fixar o conceito.",
                                  "learningObjective": "Compreender o fluxo normal do shift-reduce sem conflitos.",
                                  "commonMistakes": [
                                    "Confundir shift com reduce: shift avança no input, reduce pop da pilha.",
                                    "Ignorar o lookahead na determinação de ações."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Conflitos Shift-Reduce",
                                  "subSteps": [
                                    "Para um estado, liste todas as ações possíveis baseadas nos itens.",
                                    "Identifique quando um item shift (goto em terminal) e um item reduce (ponto no fim) compartilham o mesmo lookahead.",
                                    "Classifique: conflito surge se shift e reduce são viáveis para o mesmo símbolo.",
                                    "Examine exemplos onde o lookahead permite ambas ações."
                                  ],
                                  "verification": "Em uma gramática com shift-reduce conhecido (ex: expr -> expr + term | term), marque o estado conflituoso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de gramática ambígua: S -> A | A a, A -> a",
                                    "Tabela de itens LR(0) pré-construída"
                                  ],
                                  "tips": "Foque no lookahead: conflito só se símbolos coincidem.",
                                  "learningObjective": "Reconhecer precisamente quando shift e reduce competem.",
                                  "commonMistakes": [
                                    "Assumir conflito sem verificar lookahead exato.",
                                    "Confundir com ambiguidades na gramática vs. no parser."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar e Classificar Conflitos Reduce-Reduce",
                                  "subSteps": [
                                    "Liste todos os itens reduce em um estado (múltiplas produções completas).",
                                    "Verifique se algum lookahead permite mais de uma redução.",
                                    "Classifique: reduce-reduce se dois ou mais reduces para o mesmo símbolo.",
                                    "Diferencie de shift-reduce: aqui só reduces competem."
                                  ],
                                  "verification": "Identifique reduce-reduce em gramática como S -> A | B, A -> ε, B -> ε, e aponte o lookahead conflituoso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gramática com reduce-reduce: exemplos de livros como 'Compilers' de Aho",
                                    "Simulador LR online"
                                  ],
                                  "tips": "Reduce-reduce é raro, mas indica gramática não determinística.",
                                  "learningObjective": "Distinguir reduce-reduce de outros conflitos.",
                                  "commonMistakes": [
                                    "Ignorar ε-produções que causam múltiplos reduces vazios.",
                                    "Confundir com conflitos em estados diferentes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Reconhecimento e Análise de Conflitos em Gramáticas Completas",
                                  "subSteps": [
                                    "Construa a coleção de conjuntos de itens LR(0) para uma gramática dada.",
                                    "Inspecione cada estado por múltiplas ações no mesmo lookahead.",
                                    "Classifique todos os conflitos encontrados (shift-reduce ou reduce-reduce).",
                                    "Documente o estado, itens e lookahead para cada conflito."
                                  ],
                                  "verification": "Analise 2 gramáticas: uma sem conflitos e uma com ambos tipos, listando conflitos corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "2 gramáticas de teste: uma boa (aritmética simples), uma ruim (dangling else)",
                                    "Ferramenta JFLAP ou papel"
                                  ],
                                  "tips": "Comece com gramáticas pequenas (3-5 produções) para eficiência.",
                                  "learningObjective": "Aplicar detecção sistemática em cenários reais.",
                                  "commonMistakes": [
                                    "Erro na closure: itens derivados incorretos levam a falsos conflitos.",
                                    "Pular estados não-iniciais."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática: E → E + T | T, T → id. No estado após shift 'id +', lookahead '+' permite shift (para novo T) ou reduce (E → T), criando shift-reduce conflict.",
                              "finalVerifications": [
                                "Construir itens LR(0) corretos para gramática sem erros.",
                                "Identificar shift-reduce em exemplo clássico como 'dangling else'.",
                                "Detectar reduce-reduce em gramática com múltiplas produções nullable.",
                                "Explicar por que conflito ocorre em termos de lookahead.",
                                "Simular parse até conflito e pausar corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de estados conflituosos (100%).",
                                "Classificação correta: shift-reduce vs reduce-reduce.",
                                "Explicação clara do lookahead causador.",
                                "Análise de pelo menos 3 exemplos independentes.",
                                "Uso correto de terminologia LR(0)."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Formal: Similar a resolução de ambiguidades em provas lógicas.",
                                "Programação: Relacionado a precedência de operadores em linguagens.",
                                "Matemática Discreta: Conjuntos de itens como autômatos finitos.",
                                "Engenharia de Software: Detecção de erros em especificações formais."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou ferramentas como Yacc/Bison, reconhecimento de conflitos guia refatoração de gramáticas para parsers determinísticos, essencial para eficiência em linguagens reais como C++ ou Java."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Simular parsing shift-reduce simples",
                            "description": "Executar manualmente o algoritmo shift-reduce em uma gramática livre de contexto simples, rastreando a pilha, entrada e ações até aceitar ou rejeitar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a gramática e a sentença de entrada",
                                  "subSteps": [
                                    "Identifique os terminais (ex: 'id', '+'), não-terminais (ex: 'E', 'T', 'S') e regras de produção de uma gramática livre de contexto simples, como S → E, E → E + T | T, T → id.",
                                    "Escreva a sentença de entrada, como 'id + id', adicionando o marcador de fim '$'.",
                                    "Construa a tabela de parsing shift-reduce se disponível, ou defina critérios manuais para shift/reduce baseados no topo da pilha e próximo símbolo de entrada.",
                                    "Desenhe diagramas iniciais da gramática para visualizar árvores de derivação possíveis.",
                                    "Liste todas as produções reversas para facilitar reduces."
                                  ],
                                  "verification": "Verifique se a gramática está na forma adequada (sem ambiguidades iniciais) e a sentença é válida para a linguagem; confirme com uma derivação leftmost manual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referência de gramática shift-reduce simples"
                                  ],
                                  "tips": "Escolha gramáticas com poucas regras (3-5) para evitar complexidade inicial.",
                                  "learningObjective": "Compreender os componentes fundamentais de uma gramática para parsing bottom-up.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Esquecer o marcador de fim '$'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar as estruturas de parsing",
                                  "subSteps": [
                                    "Crie a pilha inicial vazia ou com símbolo inicial (ex: pilha = [0], onde 0 é o axioma).",
                                    "Configure o buffer de entrada com a sentença + '$' (ex: entrada = [id, +, id, $]).",
                                    "Prepare uma tabela ou lista de ações possíveis: shift(s) para mover símbolo da entrada para pilha, reduce(r) pela produção reversa.",
                                    "Registre o estado inicial: Pilha: [], Entrada: id + id $, Ações: [].",
                                    "Teste a inicialização simulando um shift manual no primeiro símbolo."
                                  ],
                                  "verification": "Confirme que pilha está vazia/inicial e buffer reflete exatamente a entrada; execute um shift teste e reverta.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha ou quadro branco para desenhar pilha e buffer",
                                    "Exemplo de tabela SLR(0) básica"
                                  ],
                                  "tips": "Use símbolos numéricos para não-terminais na pilha para economizar espaço (ex: 1=E, 2=T).",
                                  "learningObjective": "Dominar a configuração inicial do parser shift-reduce.",
                                  "commonMistakes": [
                                    "Iniciar pilha com entrada em vez de vazia",
                                    "Ignorar o end-marker '$'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações de shift e reduce",
                                  "subSteps": [
                                    "Examine o topo da pilha e o próximo símbolo de entrada para decidir: shift se terminal, reduce se corpo de produção reverso combina.",
                                    "Para shift: mova símbolo da entrada para pilha e registre 'shift'.",
                                    "Para reduce: pop o número de símbolos do corpo da produção, push o não-terminal cabeça, registre 'reduce por produção X'.",
                                    "Repita até pilha conter apenas axioma e entrada vazia (aceita) ou sem ação possível (rejeita).",
                                    "Registre cada estado em uma tabela: iteração, pilha, entrada restante, ação."
                                  ],
                                  "verification": "Simule 3-5 iterações e verifique se pilha e entrada evoluem corretamente sem loops infinitos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabela de estados para tracking",
                                    "Calculadora para contar pops em reduces longos"
                                  ],
                                  "tips": "Sempre verifique lookahead (próximo input) antes de decidir ação.",
                                  "learningObjective": "Aplicar regras de decisão shift/reduce de forma iterativa e precisa.",
                                  "commonMistakes": [
                                    "Reduce prematuro sem match exato reverso",
                                    "Shift em não-terminais sem lookahead"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o resultado e verificar aceitação",
                                  "subSteps": [
                                    "Ao fim: se pilha = [S] e entrada vazia, aceite; senão, identifique erro (shift/reduce conflict ou stack overflow).",
                                    "Reconstrua a árvore de parsing a partir das reduces para validar sintaxe.",
                                    "Compare com derivação bottom-up esperada.",
                                    "Anote tempo total, número de shifts/reduces e possíveis otimizações.",
                                    "Teste com variação da entrada (ex: 'id + id + id') para validar robustez."
                                  ],
                                  "verification": "Pilha final contém apenas símbolo inicial e entrada esvaziada; árvore de parsing cobre toda sentença.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico para árvore de parsing",
                                    "Lista de strings de teste válidas/inválidas"
                                  ],
                                  "tips": "Desenhe a árvore de parsing enquanto faz reduces para visualização.",
                                  "learningObjective": "Interpretar resultados de parsing e diagnosticar falhas.",
                                  "commonMistakes": [
                                    "Declarar aceitação sem verificar entrada vazia",
                                    "Ignorar conflitos shift/reduce"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → E (1), E → E + T (2), E → T (3), T → id (4). Entrada: id + id $. Sequência: shift id, shift +, shift id, reduce 4 (T←id), reduce 3 (E←T), shift +, shift id, reduce 4 (T←id), reduce 2 (E←E+T), reduce 1 (S←E). Resultado: aceito, pilha=[S].",
                              "finalVerifications": [
                                "Pilha final contém apenas o axioma S e entrada está vazia.",
                                "Todas ações (shifts/reduces) estão registradas corretamente em sequência.",
                                "Árvore de parsing reconstruída matches a sentença de entrada.",
                                "Nenhum shift/reduce conflict não resolvido ocorreu.",
                                "Simulação completa leva à aceitação/rejeição correta para strings de teste.",
                                "Tempo de execução manual é razoável (<10 minutos para strings curtas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decisão de shift vs reduce (100% correto).",
                                "Rastreamento completo e sem erros na pilha/entrada.",
                                "Identificação correta de conflitos ou rejeições.",
                                "Reconstrução válida da árvore de parsing.",
                                "Eficiência: mínimo de erros em 3 simulações independentes.",
                                "Explicação clara do processo em tabela ou diagrama."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Ligação com pushdown automata (PDA).",
                                "Programação: Implementação de parsers em compiladores (ex: Yacc/Bison).",
                                "Matemática: Grafos e árvores de derivação em linguagens formais.",
                                "Engenharia de Software: Análise sintática em ferramentas de desenvolvimento."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores e interpretadores para linguagens de programação (ex: parsers em Python, JavaScript), validação de sintaxe em editores de código (VS Code), e processamento de linguagens naturais em NLP tools."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Autômatos LR(0) e Itens LR",
                        "description": "Construção de autômatos determinísticos LR(0) a partir de coleções de itens LR, representando estados de configuração do parser.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Definir itens LR(0)",
                            "description": "Construir itens LR(0) para uma gramática, incluindo o ponto de inserção que indica a posição na produção, e formar kernels e closures.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Básico de Itens LR(0)",
                                  "subSteps": [
                                    "Revise a definição de uma gramática formal, focando em não-terminais, terminais e produções.",
                                    "Aprenda que um item LR(0) é uma produção com um ponto (•) indicando a posição de análise.",
                                    "Estude exemplos de itens como [A → •α] onde α é o lado direito da produção.",
                                    "Diferencie itens iniciais (ponto no início) de itens finais (ponto no final).",
                                    "Anote a notação padrão para itens LR(0)."
                                  ],
                                  "verification": "Escreva 3 exemplos de itens LR(0) para uma produção simples e explique o significado do ponto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notebook com gramática de exemplo"
                                  ],
                                  "tips": "Use diagramas para visualizar a posição do ponto como um cursor em uma fita.",
                                  "learningObjective": "Compreender a estrutura fundamental de um item LR(0) e sua representação.",
                                  "commonMistakes": [
                                    "Confundir o ponto com epsilon",
                                    "Esquecer que o ponto pode estar em qualquer posição",
                                    "Ignorar distinção entre não-terminais e terminais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Itens LR(0) para uma Gramática Dada",
                                  "subSteps": [
                                    "Selecione uma gramática simples com 3-4 produções.",
                                    "Para cada produção, gere itens movendo o ponto para todas as posições possíveis.",
                                    "Liste todos os itens possíveis, numerando-os sequencialmente.",
                                    "Verifique se itens duplicados são evitados.",
                                    "Crie uma tabela resumindo produções e itens correspondentes."
                                  ],
                                  "verification": "Gere a lista completa de itens LR(0) para uma gramática com pelo menos 3 produções e confira com uma referência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto ou planilha",
                                    "Gramática de exemplo impressa"
                                  ],
                                  "tips": "Comece com gramáticas regulares para praticar antes de context-free complexas.",
                                  "learningObjective": "Capacitar a geração sistemática de itens LR(0) a partir de produções.",
                                  "commonMistakes": [
                                    "Gerar itens inválidos com ponto após terminais errados",
                                    "Omitir itens com ponto no início ou fim",
                                    "Confundir itens de produções diferentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Closure de um Item LR(0)",
                                  "subSteps": [
                                    "Defina closure como o conjunto de itens derivados adicionando produções de não-terminais imediatamente após o ponto.",
                                    "Inicie com um kernel (item sem closure).",
                                    "Aplique a regra de closure iterativamente até fixpoint: se [A → α•Bβ], adicione [B → •γ] para cada produção de B.",
                                    "Repita para novos não-terminais expandidos.",
                                    "Represente o closure como um conjunto numerado de itens."
                                  ],
                                  "verification": "Calcule o closure de um item dado e liste todos os itens derivados, verificando estabilidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel quadriculado para conjuntos",
                                    "Ferramenta online de parsing opcional"
                                  ],
                                  "tips": "Use set notation { } para closures e marque iterações com setas.",
                                  "learningObjective": "Dominar o algoritmo de closure para expandir itens LR(0).",
                                  "commonMistakes": [
                                    "Parar iteração prematuramente",
                                    "Adicionar closures para terminais",
                                    "Incluir itens já presentes sem verificar duplicatas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Kernels e Formar Conjuntos Iniciais",
                                  "subSteps": [
                                    "Defina kernel como itens com ponto não no início (excluindo closure inicial).",
                                    "Identifique o item inicial: [S' → •S] onde S' é o símbolo start augmentado.",
                                    "Calcule closure do item inicial para formar I0.",
                                    "Diferencie kernel de closure em exemplos.",
                                    "Pratique identificando kernels em closures computados."
                                  ],
                                  "verification": "Para uma gramática, forme I0, identifique seu kernel e closure, e explique diferenças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha para tabelas de itens",
                                    "Exemplos de livros de teoria da computação"
                                  ],
                                  "tips": "Sempre augmentar a gramática com S' → S para consistência.",
                                  "learningObjective": "Distinguir e computar kernels e closures em contextos LR(0).",
                                  "commonMistakes": [
                                    "Confundir kernel com closure completo",
                                    "Esquecer augmentação da gramática",
                                    "Incluir itens iniciais no kernel incorretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática: S → a A b | ε, A → ε. Item inicial: [S' → •S]. Closure: [S' → •S], [S → •a A b], [S → •]. Kernel de I1 (goto em 'a'): [S → a •A b], [A → •].",
                              "finalVerifications": [
                                "Construir itens LR(0) para todas as produções de uma gramática simples.",
                                "Calcular closure corretamente sem loops infinitos.",
                                "Identificar kernel de um conjunto de itens.",
                                "Explicar o papel do ponto em um item LR(0).",
                                "Formar o conjunto inicial I0 para uma gramática augmentada.",
                                "Diferenciar itens shift/reduce."
                              ],
                              "assessmentCriteria": [
                                "Precisão na colocação do ponto em itens (100% corretos).",
                                "Completude do closure (todos os itens derivados incluídos).",
                                "Correta identificação de kernels vs. closures.",
                                "Uso consistente de notação padrão LR(0).",
                                "Explicações claras do processo algorítmico.",
                                "Ausência de erros comuns como closures em terminais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e fechamentos (fixpoints).",
                                "Programação: Implementação em geradores de parsers como Yacc.",
                                "Lógica: Autômatos finitos e estados de reconhecimento.",
                                "Engenharia de Software: Análise sintática em compiladores."
                              ],
                              "realWorldApplication": "Itens LR(0) são fundamentais na construção de parsers bottom-up em compiladores reais, como GCC ou ferramentas como Bison, permitindo análise sintática eficiente de linguagens de programação."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Construir coleção de conjuntos de itens",
                            "description": "Gerar a coleção canônica de conjuntos de itens LR(0) usando funções closure e goto para transições em símbolos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática aumentada e formar o item inicial",
                                  "subSteps": [
                                    "Adicione uma nova produção inicial S' → S à gramática original, onde S é o símbolo inicial.",
                                    "Crie o item LR(0) inicial: [S' → .S], onde o ponto indica a posição atual.",
                                    "Liste todos os símbolos do alfabeto (terminais e não-terminais) para futuras transições goto.",
                                    "Anote a gramática completa com numeração das produções para referência.",
                                    "Verifique se a gramática está na forma padrão sem produções ε vazias diretas no inicial (se houver, trate adequadamente)."
                                  ],
                                  "verification": "Confirme que o item inicial [S' → .S] está corretamente formado e a gramática aumentada está listada sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto; gramática de exemplo fornecida.",
                                  "tips": "Sempre numere as produções para facilitar referências em closures e gotos.",
                                  "learningObjective": "Entender a importância da gramática aumentada e formar o ponto de partida para o autômato LR(0).",
                                  "commonMistakes": "Esquecer de adicionar S' → S ou posicionar incorretamente o ponto no item inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a closure do conjunto inicial C0",
                                  "subSteps": [
                                    "Comece com o item inicial I = {[S' → .S]}.",
                                    "Aplique a função closure: para cada item [A → α.Bβ] onde B é não-terminal, adicione [B → .γ] para cada produção B → γ.",
                                    "Repita o processo recursivamente até que nenhum novo item seja adicionado.",
                                    "Ordene os itens por número de produção e posição do ponto para clareza.",
                                    "Nomeie o conjunto como C0."
                                  ],
                                  "verification": "Todos os itens possíveis pela closure estão no conjunto e não há duplicatas ou itens extras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado para desenhar conjuntos; tabela de produções.",
                                  "tips": "Use indentação para mostrar itens adicionados por closure de um item específico.",
                                  "learningObjective": "Dominar a função closure para expandir estados com previsões de não-terminais.",
                                  "commonMistakes": "Parar a closure prematuramente sem aplicar recursivamente a todos os novos não-terminais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular transições goto a partir de C0 e formar novos conjuntos",
                                  "subSteps": [
                                    "Para cada símbolo X no alfabeto (terminais e não-terminais), compute goto(C0, X): mova o ponto sobre X em todos os itens aplicáveis.",
                                    "Forme o núcleo do novo conjunto: todos os itens [A → αX.β] de C0.",
                                    "Calcule a closure desse núcleo para formar o conjunto completo Cx.",
                                    "Se Cx for novo (não existe na coleção), adicione-o como C1, C2, etc.",
                                    "Registre as transições: C0 --X--> Cx."
                                  ],
                                  "verification": "Cada goto resulta em um conjunto fechado corretamente e transições são anotadas sem ambiguidades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha para tabela de transições; lista de símbolos.",
                                  "tips": "Só compute goto para símbolos que aparecem imediatamente após o ponto em algum item.",
                                  "learningObjective": "Aplicar a função goto para gerar transições e novos estados.",
                                  "commonMistakes": "Mover o ponto incorretamente ou esquecer de aplicar closure no novo núcleo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar o processo até atingir o ponto fixo",
                                  "subSteps": [
                                    "Selecione o próximo conjunto não processado (ex: C1).",
                                    "Repita o cálculo de gotos a partir dele, adicionando novos conjuntos se necessário.",
                                    "Continue iterando sobre todos os conjuntos novos até que nenhum goto gere um conjunto inédito.",
                                    "Mantenha uma fila ou pilha de conjuntos pendentes para rastrear.",
                                    "Atualize a tabela de transições com todas as arestas."
                                  ],
                                  "verification": "Nenhum novo conjunto é gerado e todos os gotos de todos os conjuntos levam a conjuntos existentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama de estados em andamento; fila de pendentes.",
                                  "tips": "Use BFS (fila) para processar em ordem de descoberta, evitando loops.",
                                  "learningObjective": "Completar a construção iterativa alcançando a coleção canônica completa.",
                                  "commonMistakes": "Entrar em loop infinito por não detectar conjuntos duplicados (compare conjuntos inteiros)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar completude, numerar e finalizar a coleção",
                                  "subSteps": [
                                    "Confirme que todos os conjuntos são alcançáveis do C0.",
                                    "Numere os conjuntos sequencialmente de C0 a Cn.",
                                    "Verifique itens reduzíveis ([A → α.] sem ponto no final) e shift.",
                                    "Desenhe o autômato com estados e transições rotuladas.",
                                    "Liste a coleção final com todos os itens por conjunto."
                                  ],
                                  "verification": "A coleção está completa, sem estados órfãos, e o autômato reconhece a linguagem prefixa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Ferramenta de desenho como Draw.io ou papel para grafo.",
                                  "tips": "Compare conjuntos por conteúdo exato (não só núcleos) para evitar duplicatas.",
                                  "learningObjective": "Validar a coleção canônica e visualizá-la como autômato.",
                                  "commonMistakes": "Numerar incorretamente ou ignorar estados não alcançáveis."
                                }
                              ],
                              "practicalExample": "Considere a gramática S → a | b. Aumentada: 0: S' → S; 1: S → a; 2: S → b. C0 = closure([0: S' → .S]) = {[0: S' → .S], [1: S → .a], [2: S → .b]}. Goto(C0,a) = closure([1: S → a.]) = C1 = {[1: S → a.]}. Goto(C0,b) = C2 = {[2: S → b.]}. Goto(C0,S) = C3 = closure([0: S' → S.]) = {[0: S' → S.]}. Nenhum mais novos. Coleção: C0, C1, C2, C3.",
                              "finalVerifications": [
                                "Todos os conjuntos são fechados pela closure.",
                                "Todas as transições goto estão definidas e levam a conjuntos existentes.",
                                "Nenhum novo conjunto pode ser gerado.",
                                "O conjunto inicial C0 contém o item [S' → .S].",
                                "Itens reduzíveis estão presentes apenas em conjuntos sem transições shift.",
                                "A coleção é finita e cobre todos os prefixos de derivações."
                              ],
                              "assessmentCriteria": [
                                "Correta aplicação iterativa de closure e goto sem erros de duplicação.",
                                "Identificação precisa de símbolos para transições.",
                                "Completude: todos estados alcançáveis do inicial.",
                                "Ausência de conflitos na definição de gotos.",
                                "Clareza na numeração e representação tabular/gráfica.",
                                "Validação de itens shift/reduce nos conjuntos finais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções de transição em autômatos finitos.",
                                "Programação: Implementação algorítmica em linguagens como Python para geradores de parsers.",
                                "Engenharia de Software: Fundamento para ferramentas como Yacc/Bison em compiladores.",
                                "Lógica: Raciocínio dedutivo em construções recursivas."
                              ],
                              "realWorldApplication": "Essa coleção forma a base para tabelas de parsing em compiladores reais (ex: GCC, LLVM), permitindo análise sintática eficiente de linguagens de programação como C++, Java, otimizando o reconhecimento de estruturas gramaticais em tempo linear."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Detectar gramáticas LR(0)",
                            "description": "Verificar se uma gramática é LR(0) analisando a ausência de conflitos nos estados do autômato LR(0).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática para análise LR(0)",
                                  "subSteps": [
                                    "Augmente a gramática adicionando uma nova produção S' → S, onde S é o símbolo inicial.",
                                    "Liste todas as produções numeradas e identifique os não-terminais e terminais.",
                                    "Escreva os itens LR(0) possíveis para cada produção no formato [A → α • β, produção #].",
                                    "Verifique se a gramática está na forma padrão (sem ε-produções ou unitárias, se aplicável).",
                                    "Crie uma tabela de símbolos: terminais, não-terminais e fim de entrada ($)."
                                  ],
                                  "verification": "Confirme que a gramática aumentada tem pelo menos uma produção e todos os itens iniciais estão listados corretamente.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Referência: Livro 'Compilers: Principles, Techniques, and Tools' (Dragon Book), Capítulo 4"
                                  ],
                                  "tips": "Sempre numere as produções para facilitar referências nos itens LR(0).",
                                  "learningObjective": "Entender a preparação padrão de uma gramática para construção do autômato LR(0).",
                                  "commonMistakes": [
                                    "Esquecer de augmentar a gramática com S'",
                                    "Confundir terminais com não-terminais",
                                    "Não numerar produções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o estado inicial e seu closure",
                                  "subSteps": [
                                    "Inicie com o item kernel: [S' → • S].",
                                    "Calcule o closure adicionando itens para não-terminais imediatamente após o ponto (•A → ...).",
                                    "Repita o processo recursivamente até que nenhum novo item seja adicionado.",
                                    "Rotule este conjunto como Estado I0.",
                                    "Liste explicitamente todos os itens no closure de I0."
                                  ],
                                  "verification": "O closure de I0 deve conter todos os itens derivados de •S e ser fechado sob a regra de closure.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel quadriculado para diagramas",
                                    "Ferramenta online como LR(0) parser generator (opcional)"
                                  ],
                                  "tips": "Use conjuntos para evitar duplicatas; closure só adiciona itens com kernel vazio.",
                                  "learningObjective": "Dominar a operação de closure para formar estados LR(0).",
                                  "commonMistakes": [
                                    "Parar o closure prematuramente",
                                    "Incluir itens com kernel não-vazio",
                                    "Confundir goto com closure"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar todos os estados usando a função goto",
                                  "subSteps": [
                                    "Para cada estado existente e cada símbolo X (terminal ou não-terminal), compute goto(I, X) = closure({ [A → α • X β] para itens relevantes }).",
                                    "Adicione novos estados à coleção se não existirem.",
                                    "Continue iterativamente até que nenhum novo estado seja gerado.",
                                    "Desenhe o diagrama de estados com transições rotuladas por símbolos.",
                                    "Numere os estados sequencialmente (I0, I1, ...)."
                                  ],
                                  "verification": "Todos os estados devem ser alcançáveis de I0 e o conjunto deve ser fechado sob goto.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Gráficos ou software como Graphviz para visualizar autômatos"
                                  ],
                                  "tips": "Mantenha uma fila para processar estados não visitados (BFS).",
                                  "learningObjective": "Construir o autômato canônico LR(0) completo.",
                                  "commonMistakes": [
                                    "Erro no cálculo de goto (mover o ponto errado)",
                                    "Duplicar estados idênticos",
                                    "Esquecer símbolos no goto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar conflitos em cada estado",
                                  "subSteps": [
                                    "Para cada estado, liste ações: SHIFT para transições em terminais, REDUCE para itens completos [A → α •].",
                                    "Detecte shift-reduce conflict: Item reduce no estado E transições shift em terminal a.",
                                    "Detecte reduce-reduce conflict: Múltiplos itens reduce no mesmo estado.",
                                    "Marque estados com conflitos explicitamente.",
                                    "Ignore conflitos envolvendo apenas não-terminais ou $ em contextos apropriados."
                                  ],
                                  "verification": "Liste todos os conflitos encontrados, se houver, com o estado e símbolos envolvidos.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Tabela de parsing em branco para preencher ações"
                                  ],
                                  "tips": "Shift-reduce ocorre se há [A→α•] e goto em terminal; reduce-reduce se >1 reduce.",
                                  "learningObjective": "Reconhecer e classificar conflitos LR(0).",
                                  "commonMistakes": [
                                    "Confundir SHIFT com GOTO para não-terminais",
                                    "Ignorar conflitos em estados finais",
                                    "Não checar todos os símbolos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir se a gramática é LR(0)",
                                  "subSteps": [
                                    "Revise todos os estados: zero shift-reduce e zero reduce-reduce conflicts.",
                                    "Confirme que o estado com [S' → S •] existe e é aceit (sem conflitos).",
                                    "Se nenhum conflito, declare LR(0); caso contrário, liste os conflitos.",
                                    "Opcional: Preencha tabela de parsing completa.",
                                    "Documente o autômato final."
                                  ],
                                  "verification": "A gramática é LR(0) se e somente se o autômato tem zero conflitos.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Lista de verificação impressa"
                                  ],
                                  "tips": "LR(0) é estrito; qualquer conflito invalida.",
                                  "learningObjective": "Aplicar o critério definitivo de LR(0).",
                                  "commonMistakes": [
                                    "Declarar LR(0) apesar de conflitos menores",
                                    "Esquecer o estado de aceitação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática aumentada: 0: S' → S, 1: S → aS, 2: S → b. Construa I0: closure([S'→•S]) = {[S'→•S,0], [S→•aS,1], [S→•b,2]}. Goto em 'a' leva a I1: {[S→a•S,1], [S→•aS,1], [S→•b,2]}. Sem conflitos em nenhum estado: é LR(0).",
                              "finalVerifications": [
                                "Construa corretamente o autômato LR(0) para uma gramática dada.",
                                "Identifique shift-reduce e reduce-reduce conflicts em estados específicos.",
                                "Explique por que uma gramática com conflito não é LR(0).",
                                "Preencha uma tabela de parsing parcial sem erros.",
                                "Diferencie closure de goto com exemplos.",
                                "Verifique o estado de aceitação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de closures e gotos (sem itens faltantes ou extras).",
                                "Detecção correta de todos os conflitos (zero falsos positivos/negativos).",
                                "Clareza no diagrama de estados e labeling.",
                                "Explicação coerente dos passos e raciocínio.",
                                "Eficiência temporal: completa em <2 horas.",
                                "Uso correto de terminologia LR(0)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Autômatos: Estados como AFDs com itens.",
                                "Teoria dos Grafos: Autômato como grafo direcionado.",
                                "Matemática Discreta: Operações em conjuntos (closure, união).",
                                "Programação: Implementação de parsers em ferramentas como Yacc.",
                                "Lógica: Análise de conflitos como violações de determinismo."
                              ],
                              "realWorldApplication": "Em compiladores (ex: GCC, JavaCC), detectar se uma gramática permite parsing eficiente sem backtracking; usado em ferramentas como Bison/Yacc para gerar parsers determinísticos em linguagens de programação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Tabelas de Parsing LR e Classes Avançadas",
                        "description": "Geração de tabelas de ação e goto para parsers SLR(1), LR(1) e LALR(1), incluindo lookahead para resolver ambiguidades.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Construir tabela SLR(1)",
                            "description": "Calcular FOLLOW para gramáticas e preencher tabelas de ação e goto usando FOLLOW para ações de reduce em parsers SLR(1).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a gramática e calcular os conjuntos FIRST",
                                  "subSteps": [
                                    "Liste todas as produções da gramática, incluindo a produção aumentada S' → S.",
                                    "Identifique terminais e não-terminais.",
                                    "Calcule FIRST para cada terminal (é o próprio terminal).",
                                    "Calcule FIRST para não-terminais: comece pelos que não têm recursão, adicione FIRST(α) para A → α, considerando nullable.",
                                    "Itere até fixpoint para resolver dependências."
                                  ],
                                  "verification": "Verifique se os conjuntos FIRST estão corretos comparando com uma gramática conhecida ou simulando derivações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gramática de exemplo anotada",
                                    "Tabela de símbolos"
                                  ],
                                  "tips": "Sempre marque símbolos nullable para propagar ε corretamente.",
                                  "learningObjective": "Dominar o cálculo de FIRST sets para prever símbolos iniciais de sentenças.",
                                  "commonMistakes": [
                                    "Esquecer de propagar ε através de símbolos nullable",
                                    "Incluir o não-terminal no seu próprio FIRST sem cuidado com recursão esquerda"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os conjuntos FOLLOW",
                                  "subSteps": [
                                    "Inicialize FOLLOW(S') = {$}.",
                                    "Para cada produção A → αBβ, adicione FIRST(β) a FOLLOW(B).",
                                    "Se β é nullable ou vazio, adicione FOLLOW(A) a FOLLOW(B).",
                                    "Para A → αB, adicione FOLLOW(A) a FOLLOW(B).",
                                    "Itere até que não haja mudanças."
                                  ],
                                  "verification": "Teste com regras: todo FOLLOW deve conter apenas terminais ou $; verifique com derivações de sentenças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Conjuntos FIRST calculados",
                                    "Lista de produções"
                                  ],
                                  "tips": "Use uma tabela para rastrear adições em cada iteração para evitar loops infinitos.",
                                  "learningObjective": "Compreender como FOLLOW captura contextos terminais após não-terminais.",
                                  "commonMistakes": [
                                    "Não propagar FOLLOW(A) quando β é nullable",
                                    "Confundir FIRST e FOLLOW"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir os conjuntos de itens canônicos (estados LR(0))",
                                  "subSteps": [
                                    "Inicie com I0 = CLOSURE({S' → .S}).",
                                    "Aplique CLOSURE: adicione itens para não-terminais após o ponto.",
                                    "Compute GOTO(I, X) para cada símbolo X: itens com ponto movido sobre X, aplique CLOSURE.",
                                    "Repita até não gerar novos estados, numerando-os sequencialmente.",
                                    "Desenhe o automato de estados com transições."
                                  ],
                                  "verification": "Todos estados alcançáveis de I0; sem duplicatas; closure completo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lista de símbolos",
                                    "Funções CLOSURE e GOTO anotadas"
                                  ],
                                  "tips": "Represente itens como A → α.β; use conjuntos para evitar redundâncias.",
                                  "learningObjective": "Construir o automato LR(0) subjacente ao parser SLR(1).",
                                  "commonMistakes": [
                                    "Esquecer closure recursiva em não-terminais",
                                    "Não numerar estados corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preencher a tabela ACTION",
                                  "subSteps": [
                                    "Para cada estado i e terminal a: se GOTO(I_i, a) = I_j, ACTION[i,a] = sj (shift j).",
                                    "Para itens reduce A → α. em I_i: ACTION[i, b] = r_k para cada b em FOLLOW(A), onde k é índice da produção.",
                                    "Se S' → S. em I_i, ACTION[i,$] = accept.",
                                    "Detecte conflitos: shift-reduce (SLR resolve com FOLLOW) ou reduce-reduce.",
                                    "Preencha células vazias com erro."
                                  ],
                                  "verification": "Sem conflitos shift-reduce em FOLLOW; aceita strings válidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela ACTION vazia (linhas: estados, colunas: terminais+$)",
                                    "Estados e FOLLOW"
                                  ],
                                  "tips": "Use FOLLOW para restringir reduces e evitar conflitos shift-reduce.",
                                  "learningObjective": "Aplicar regras de shift, reduce e accept na tabela ACTION.",
                                  "commonMistakes": [
                                    "Aplicar reduce em todo estado sem checar FOLLOW",
                                    "Confundir shift com goto"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Preencher a tabela GOTO e validar a tabela SLR(1)",
                                  "subSteps": [
                                    "Para cada estado i e não-terminal A: se GOTO(I_i, A) = I_j, GOTO[i,A] = j.",
                                    "Revise toda a tabela por completude.",
                                    "Simule parsing de 2-3 strings válidas e inválidas.",
                                    "Confirme ausência de conflitos para SLR(1).",
                                    "Documente a tabela final."
                                  ],
                                  "verification": "Parsing simulado aceita linguagem da gramática; rejeita inválidas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela completa ACTION/GOTO",
                                    "Strings de teste"
                                  ],
                                  "tips": "GOTO é só para não-terminais; mantenha consistente com automato.",
                                  "learningObjective": "Finalizar tabela e validar propriedades SLR(1).",
                                  "commonMistakes": [
                                    "Preencher GOTO com terminais",
                                    "Ignorar conflitos detectados"
                                  ]
                                }
                              ],
                              "practicalExample": "Gramática SLR(1): S' → S, S → A, A → aA | b. FIRST(S)={a,b}, FOLLOW(S)={$}, FOLLOW(A)={$}. Estados: I0=CLOSURE(S'→.S, S→.A, A→.aA, A→.b), etc. Tabela ACTION: shift em a/b, reduce r1 em $ para S→A, etc. Simule input 'bb$' → accept.",
                              "finalVerifications": [
                                "Conjuntos FIRST e FOLLOW corretos para todos não-terminais.",
                                "Automato LR(0) completo com 5-10 estados sem duplicatas.",
                                "Tabela ACTION sem conflitos shift-reduce usando FOLLOW.",
                                "GOTO preenchido corretamente para transições em não-terminais.",
                                "Simulação de parsing aceita strings da linguagem e rejeita inválidas.",
                                "Ausência de reduce-reduce conflicts."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de FIRST/FOLLOW (100% correto).",
                                "Completude dos estados e closure/goto (todos itens incluídos).",
                                "Correta aplicação de regras SLR(1) para reduces.",
                                "Ausência de erros na tabela final.",
                                "Capacidade de simular parsing manualmente.",
                                "Clareza na documentação e explicação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de autômatos finitos e grafos direcionados.",
                                "Programação: Implementação de parsers em linguagens como Python ou C.",
                                "Engenharia de Software: Ferramentas como Yacc/Bison para compiladores.",
                                "Lógica: Inferência bottom-up e redução de problemas.",
                                "Algoritmos: Construção de AFND e determinização."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores e interpretadores para linguagens de programação (ex: parsers em GCC, JavaCC), análise sintática em ferramentas de processamento de linguagem natural e validação de configurações em sistemas embarcados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Diferenciar classes LR",
                            "description": "Comparar SLR(1), LR(1) e LALR(1), entendendo suas capacidades e como LR(1) usa itens com lookahead para maior precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Parsing LR e Itens com Lookahead",
                                  "subSteps": [
                                    "Defina itens LR(0) e explique como eles representam estados do autômato de parsing.",
                                    "Introduza o conceito de lookahead em itens LR(1), formatados como [produção, lookahead].",
                                    "Compare itens LR(0) vs. LR(1), destacando como lookahead resolve ambiguidades.",
                                    "Liste closure e goto para itens LR(1) usando uma gramática simples.",
                                    "Identifique conflitos shift-reduce e reduce-reduce em contextos sem lookahead."
                                  ],
                                  "verification": "Construa manualmente o conjunto de itens iniciais para uma gramática dada e explique o papel do lookahead.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, diagrama de gramática de exemplo (ex: S -> A | B, A -> a, B -> b), livro de compiladores (cap. LR parsing).",
                                  "tips": "Sempre escreva itens completos com lookahead para visualizar diferenças precocemente.",
                                  "learningObjective": "Compreender a base teórica de itens LR e o impacto do lookahead na precisão.",
                                  "commonMistakes": "Confundir LR(0) com LR(1); ignorar que lookahead é um terminal único por item."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e Analisar Tabelas SLR(1)",
                                  "subSteps": [
                                    "Construa os estados canônicos LR(0) para uma gramática.",
                                    "Calcule FOLLOW sets para cada não-terminal.",
                                    "Preencha a tabela SLR(1): ações shift/reduce baseadas em FOLLOW para reduces.",
                                    "Identifique conflitos SLR(1) em uma gramática com ambiguidade sutil.",
                                    "Simule parsing de uma string na tabela SLR(1) para validar."
                                  ],
                                  "verification": "Detecte e explique um conflito shift-reduce em uma tabela SLR(1) construída.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha ou ferramenta online para tabelas LR (ex: JFLAP), gramática exemplo com conflito SLR.",
                                  "tips": "Use FOLLOW sets precisos; teste com strings que causem conflitos para prática.",
                                  "learningObjective": "Dominar construção de tabelas SLR(1) e reconhecer suas limitações devido a FOLLOW aproximado.",
                                  "commonMistakes": "Calcular FOLLOW incorretamente; assumir que ausência de conflito SLR implica LR(1)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Tabelas LR(1) e LALR(1) com Lookahead Preciso",
                                  "subSteps": [
                                    "Construa autômato LR(1) completo, propagando lookaheads via closure e goto.",
                                    "Compare estados LR(1) com LR(0), notando splits por lookahead diferente.",
                                    "Gere tabela LALR(1) mesclando estados LR(1) com mesmos núcleos LR(0).",
                                    "Identifique quando mesclagem LALR introduz conflitos não presentes em LR(1).",
                                    "Simule parsing em ambas tabelas para uma gramática SLR-conflictiva."
                                  ],
                                  "verification": "Construa tabelas LR(1) e LALR(1) para uma gramática e mostre resolução de conflito SLR.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ferramenta de parsing como Bison/Yacc para gerar tabelas, gramática if-then-else.",
                                  "tips": "Visualize estados mesclados em LALR com diagramas; pratique com gramáticas reais de programação.",
                                  "learningObjective": "Entender como LR(1) usa lookahead contextual para máxima precisão e LALR como compactação.",
                                  "commonMistakes": "Esquecer propagação de lookahead em LR(1); confundir núcleo LR(0) com itens completos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Capacidades e Limitações das Classes LR",
                                  "subSteps": [
                                    "Classifique gramáticas por poder: SLR(1) ⊂ LALR(1) ⊂ LR(1).",
                                    "Forneça exemplos: gramática SLR mas não LR(0), LALR-conflictiva mas LR(1)-ok.",
                                    "Discuta trade-offs: tamanho de tabela (LR(1) grande, SLR pequena), tempo de construção.",
                                    "Analise quando usar cada: SLR para simples, LALR para prático (Yacc), LR(1) para poderoso.",
                                    "Resuma diferenças em tabela comparativa: precisão lookahead, conflitos comuns."
                                  ],
                                  "verification": "Crie uma tabela comparativa e classifique 3 gramáticas em classes LR.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela modelo em Excel/Google Sheets, exemplos de gramáticas padrão (ex: dangling else).",
                                  "tips": "Memorize hierarquia com mnemônico: 'Simple Lookahead Reduction' vs. 'Full Lookahead'.",
                                  "learningObjective": "Diferenciar capacidades, escolher classe apropriada por contexto.",
                                  "commonMistakes": "Achar SLR(1) = LR(1); ignorar que LALR pode introduzir conflitos extras."
                                }
                              ],
                              "practicalExample": "Considere a gramática if-then-else: S → if E then S | if E then S else S | other. SLR(1) tem shift-reduce conflito no 'else' devido a FOLLOW(S) incluindo 'else'. LR(1) resolve com lookahead preciso por contexto, priorizando shift. LALR(1) mescla estados e mantém resolução se núcleos compatíveis, como em compiladores reais.",
                              "finalVerifications": [
                                "Construa tabela SLR(1) e identifique conflito em gramática padrão.",
                                "Explique como lookahead em LR(1) resolve conflito SLR sem mesclagem.",
                                "Gere tabela LALR(1) via Yacc e compare com LR(1).",
                                "Classifique gramática: SLR? LALR? LR(1)?",
                                "Simule parsing de string ambígua em todas classes.",
                                "Liste 3 limitações de cada classe."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de itens LR(1) e propagação de lookahead (30%).",
                                "Detecção correta de conflitos e resoluções específicas por classe (25%).",
                                "Comparação clara de capacidades com exemplos concretos (20%).",
                                "Uso correto de FOLLOW vs. lookahead contextual (15%).",
                                "Análise de trade-offs práticos (tamanho/tempo) (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Hierarquia de linguagens LR(k) vs. LL(k).",
                                "Engenharia de Software: Design de linguagens e ferramentas como ANTLR.",
                                "Algoritmos: Autômatos finitos com lookahead em reconhecimento.",
                                "Inteligência Artificial: Parsing em PLN (ex: Chart Parsing em NLP)."
                              ],
                              "realWorldApplication": "Em compiladores como GCC/Clang, LALR(1) é usado em Yacc/Bison para parsing eficiente de linguagens C++/Java, balanceando precisão LR(1) com tabelas compactas; SLR para protótipos simples, evitando overhead de parsers full LR(1)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Gerar tabela LALR(1)",
                            "description": "Mesclar estados LR(1) para formar autômatos LALR(1), propagando lookaheads e verificando conflitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir o autômato LR(1) canônico inicial",
                                  "subSteps": [
                                    "Obtenha a gramática aumentada e compute os itens LR(1) iniciais com lookahead $ para a produção S' → .S",
                                    "Calcule os fechamentos dos itens usando a função CLOSURE, propagando lookaheads não-triviais",
                                    "Construa as transições GOTO para símbolos não-terminais e terminais, criando novos estados",
                                    "Repita o processo até esgotar todos os estados, numerando-os sequencialmente",
                                    "Represente o autômato como um grafo com estados e arestas rotuladas"
                                  ],
                                  "verification": "Verifique se todos os estados foram gerados sem duplicatas e se as transições cobrem todos os itens possíveis; compare com um exemplo conhecido",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gramática de exemplo em notação BNF",
                                    "Papel quadriculado ou software como Graphviz para visualizar o autômato",
                                    "Tabela de FIRST e FOLLOW pré-computada"
                                  ],
                                  "tips": "Comece sempre pelo estado 0; use conjuntos para representar itens e evite ordenação prematura",
                                  "learningObjective": "Entender a construção bottom-up do autômato LR(1) completo antes da mesclagem",
                                  "commonMistakes": [
                                    "Esquecer de propagar lookaheads em CLOSURE",
                                    "Não incluir o lookahead inicial $",
                                    "Duplicar estados desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar núcleos de estados para mesclagem",
                                  "subSteps": [
                                    "Extraia o núcleo de cada estado LR(1), ignorando lookaheads (apenas posições do ponto e não-terminais)",
                                    "Agrupe estados pelo núcleo idêntico em uma estrutura de dados como um mapa (núcleo → lista de estados)",
                                    "Para cada grupo com múltiplos estados, liste os lookaheads espontâneos de cada item",
                                    "Crie um novo estado LALR(1) representando a mesclagem desses estados LR(1)",
                                    "Mantenha um mapeamento de estados LR(1) originais para o novo estado mesclado"
                                  ],
                                  "verification": "Confirme que todos os estados foram agrupados corretamente e que núcleos iguais têm lookaheads listados; sem grupos vazios",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de estados LR(1) do Step 1",
                                    "Planilha ou código Python para agrupamento por núcleo"
                                  ],
                                  "tips": "Use hashing de núcleos para eficiência; núcleos são independentes de lookaheads",
                                  "learningObjective": "Dominar a identificação de equivalências de núcleo para redução de estados",
                                  "commonMistakes": [
                                    "Confundir núcleo com itens completos",
                                    "Ignorar estados com núcleos únicos (não mesclados)",
                                    "Erro no hashing de núcleos multi-itens"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Propagar lookaheads e mesclar estados",
                                  "subSteps": [
                                    "Para cada par de estados mescláveis conectados por uma transição espontânea, propague lookaheads via regras de propagação (transitiva)",
                                    "Itere até convergência: adicione lookaheads propagados aos itens dos estados receptores",
                                    "Una os lookaheads de todos os estados de um núcleo em conjuntos disjuntos por item",
                                    "Atualize as transições GOTO no autômato mesclado, apontando para estados mesclados correspondentes",
                                    "Registre todas as propagações em um log para depuração"
                                  ],
                                  "verification": "Verifique convergência (sem mudanças em iterações sucessivas) e ausência de lookaheads perdidos; teste com grafo de dependências",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Autômato LR(1) agrupado",
                                    "Algoritmo de propagação em pseudocódigo",
                                    "Ferramenta de visualização de grafos de propagação"
                                  ],
                                  "tips": "Modele propagações como um grafo dirigido; use fixpoint iteration para eficiência",
                                  "learningObjective": "Aplicar propagação de lookaheads para preservar precisão sem explodir estados",
                                  "commonMistakes": [
                                    "Propagação não transitiva",
                                    "Mesclar lookaheads sem disjunção",
                                    "Ciclos infinitos sem detecção de fixpoint"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a tabela de parsing LALR(1) e verificar conflitos",
                                  "subSteps": [
                                    "Preencha a tabela de AÇÃO: shift/reduce por lookahead, reduce por itens completos",
                                    "Preencha a tabela GOTO para não-terminais usando transições mescladas",
                                    "Para cada célula, cheque conflitos: shift-reduce ou reduce-reduce por lookahead sobreposto",
                                    "Se conflito detectado, marque a gramática como não-LALR(1); caso contrário, valide a tabela",
                                    "Gere a tabela final em formato legível (linhas=estados, colunas=símbolos)"
                                  ],
                                  "verification": "Simule parsing em uma string válida; confirme sem conflitos e ações corretas em todos lookaheads",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Autômato LALR(1) mesclado",
                                    "Lista completa de terminais/não-terminais",
                                    "Planilha para tabela"
                                  ],
                                  "tips": "Ordene colunas alfabeticamente; use conjuntos de lookaheads para checagem eficiente",
                                  "learningObjective": "Gerar e validar tabela de parsing otimizada para uso em compiladores",
                                  "commonMistakes": [
                                    "Esquecer lookaheads propagados em ações",
                                    "Conflitos falsos por não-disjunção",
                                    "GOTO incorreto pós-mesclagem"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar a tabela LALR(1)",
                                  "subSteps": [
                                    "Teste a tabela com strings de entrada válidas e inválidas usando simulador de parsing",
                                    "Compare o autômato LALR(1) com LR(1) original: confirme poder de parsing equivalente",
                                    "Otimize representações (compactar lookaheads, numerar estados minimamente)",
                                    "Documente diferenças em tamanho e potenciais trade-offs",
                                    "Exporte para formato utilizável (ex: código C para Yacc)"
                                  ],
                                  "verification": "Parsing bem-sucedido em 5+ exemplos; zero conflitos reportados; tamanho reduzido vs LR(1)",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de parsing LR online ou código Python",
                                    "Exemplos de gramáticas LALR(1) e não-LALR(1)"
                                  ],
                                  "tips": "Use gramáticas padrão como if-then-else para testar ambiguidades",
                                  "learningObjective": "Garantir corretude e eficiência da tabela gerada no contexto real",
                                  "commonMistakes": [
                                    "Não testar ambiguidades conhecidas",
                                    "Assumir LALR(1) sem validação completa",
                                    "Perder otimizações de representação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática S → A | a; A → ε | aA. Construa LR(1): estados com núcleos iguais (ex: dois estados com S' → .S) são mesclados, propagando lookahead 'a' de um para outro via transição em 'a'. Tabela final: shift em 'a' para estado 1, reduce S→A em $ sem conflito.",
                              "finalVerifications": [
                                "Autômato LALR(1) tem menos estados que LR(1) equivalente",
                                "Todos lookaheads foram propagados corretamente sem perda",
                                "Tabela parseia strings válidas sem erros",
                                "Nenhum shift-reduce ou reduce-reduce conflito detectado",
                                "GOTO transições preservadas pós-mesclagem",
                                "Comparação com ferramenta como Bison confirma output idêntico"
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção do LR(1) inicial (100% estados corretos)",
                                "Correta identificação e mesclagem de núcleos (sem falsos merges)",
                                "Propagação de lookaheads convergente e completa",
                                "Tabela de parsing livre de conflitos com ações válidas",
                                "Validação prática via simulação de parsing (sucesso em 90%+ casos)",
                                "Eficiência: tempo de execução dentro de estimativas"
                              ],
                              "crossCurricularConnections": [
                                "Teoria de Grafos: autômatos como DGAs, propagação como fixpoint em SCCs",
                                "Algoritmos e Estruturas de Dados: hashing de núcleos, union-find para merges",
                                "Compiladores: Integração com Yacc/Bison para geração de parsers reais",
                                "Otimização: Redução de estados como compressão de autômatos finitos",
                                "Verificação Formal: Detecção de conflitos via análise estática"
                              ],
                              "realWorldApplication": "Usado em ferramentas como Yacc e Bison para gerar parsers eficientes em compiladores (GCC, LLVM), reduzindo memória em 50-90% vs LR(1) sem perda de precisão para a maioria das linguagens de programação."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.4",
                            "name": "Aplicar parser LR em exemplo prático",
                            "description": "Implementar ou simular um parser LR completo para uma gramática de expressões aritméticas, usando tabela gerada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a gramática aumentada e calcular o estado inicial",
                                  "subSteps": [
                                    "Escreva a gramática para expressões aritméticas: E → E + T | T, T → T * F | F, F → (E) | id.",
                                    "Augmente a gramática adicionando S' → E.",
                                    "Calcule o closure do item inicial [S' → •E].",
                                    "Liste todos os itens no estado 0 usando regras de closure LR.",
                                    "Verifique se o estado inicial está completo."
                                  ],
                                  "verification": "O estado 0 contém itens como [S' → •E], [E → •E + T], [E → •T], etc., sem erros de closure.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Editor de texto para anotar gramática"
                                  ],
                                  "tips": "Sempre comece com o ponto antes do primeiro símbolo não-terminal e aplique closure recursivamente.",
                                  "learningObjective": "Compreender a construção de itens LR e closure para iniciar o autômato.",
                                  "commonMistakes": [
                                    "Esquecer de augmentar a gramática",
                                    "Não aplicar closure em todos os não-terminais acessíveis",
                                    "Confundir terminais com não-terminais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir todos os estados canônicos do autômato LR",
                                  "subSteps": [
                                    "Do estado 0, compute goto para cada símbolo (shift): +, *, (, id, E, T, F.",
                                    "Calcule closure para cada novo kernel e adicione como novo estado.",
                                    "Continue iterativamente até não haver novos estados (geralmente 8-10 estados para esta gramática).",
                                    "Numere os estados sequencialmente (0 a N).",
                                    "Desenhe o diagrama de transição entre estados."
                                  ],
                                  "verification": "Todos os estados são fechados sob closure e cobrem todas as transições possíveis; sem estados duplicados.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Planilha ou ferramenta como JFLAP",
                                    "Papel para diagrama"
                                  ],
                                  "tips": "Mantenha uma tabela de estados visitados para evitar duplicatas; use kernels como identificadores.",
                                  "learningObjective": "Dominar a construção determinística dos estados LR a partir de kernels.",
                                  "commonMistakes": [
                                    "Erro no goto para símbolos vazios",
                                    "Duplicar estados idênticos",
                                    "Esquecer closure após shift"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar a tabela de parsing LR (ação e goto)",
                                  "subSteps": [
                                    "Para cada estado e terminal ( +, *, (, ), id, $ ): preencha 'shift sK' se houver transição, 'reduce A→α' se item completo, 'accept' para S'→E•, 'error' caso contrário.",
                                    "Para não-terminais (E, T, F): preencha 'goto K' com o estado de destino.",
                                    "Use FOLLOW sets para SLR(1) se conflitos (calcule FOLLOW(E)={$,)}, FOLLOW(T)={+,)}, etc.).",
                                    "Resolva conflitos shift/reduce consultando FOLLOW.",
                                    "Valide a tabela para ausência de conflitos múltiplos."
                                  ],
                                  "verification": "Tabela completa sem conflitos irredutíveis; aceita strings válidas como 'id'.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela",
                                    "Lista de FIRST/FOLLOW pré-calculados"
                                  ],
                                  "tips": "Para gramáticas sem conflitos LR(0), é SLR(1); teste com FOLLOW para reduces.",
                                  "learningObjective": "Aprender a popular tabelas de ação e goto baseadas em estados.",
                                  "commonMistakes": [
                                    "Colocar shift em vez de reduce em itens completos",
                                    "Ignorar FOLLOW para reduces",
                                    "Erro nos números de estados de destino"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o algoritmo do parser LR usando a tabela",
                                  "subSteps": [
                                    "Implemente em pseudocódigo ou Python: pilha de estados, pilha de símbolos, buffer de entrada.",
                                    "Loop: consulte tabela[estado_top][símbolo] para shift, reduce, accept, error.",
                                    "Para reduce: pop 2*|α| símbolos/estados, push A, goto novo estado.",
                                    "Adicione stack de árvore sintática para reconstruir parse tree.",
                                    "Teste dry-run manual na tabela."
                                  ],
                                  "verification": "Código simula corretamente shift/reduce sem loops infinitos ou crashes.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Python ou pseudocódigo editor (VS Code)",
                                    "Tabela de parsing impressa"
                                  ],
                                  "tips": "Use pilha única para estados e símbolos; indexe símbolos como dict para lookup rápido.",
                                  "learningObjective": "Implementar o core loop de parsing bottom-up LR.",
                                  "commonMistakes": [
                                    "Pop incorreto no reduce (esquece |α|)",
                                    "Não tratar accept/end corretamente",
                                    "Confundir pilha de estados com símbolos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar o parser com exemplos práticos",
                                  "subSteps": [
                                    "Execute o parser na entrada 'id + id * id$' e trace pilha/tabela.",
                                    "Teste inválidas: 'id + * id', ')id(' para rejeição.",
                                    "Reconstrua e visualize a árvore de parsing.",
                                    "Depure erros comparando com trace manual.",
                                    "Otimize e documente casos edge."
                                  ],
                                  "verification": "Parser aceita válidas, rejeita inválidas, produz árvore correta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código do parser",
                                    "Entradas de teste variadas"
                                  ],
                                  "tips": "Registre traces em log para comparar com simulação manual.",
                                  "learningObjective": "Validar implementação através de testes abrangentes.",
                                  "commonMistakes": [
                                    "Não lidar com end-of-input ($)",
                                    "Parse tree incorreta em reduces",
                                    "Aceitar inválidas por erro na tabela"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um parser LR(1) para a gramática de expressões: E → E + T | T; T → T * F | F; F → (E) | id. Use a tabela gerada para parsear 'id + (id * id)' e produzir a árvore sintática: E[+] com filhos E[id], +, T[*] com T[id], *, F[id].",
                              "finalVerifications": [
                                "Parser aceita corretamente strings válidas como 'id + id * id' com accept.",
                                "Rejeita inválidas como 'id +' ou '+ id' com error.",
                                "Tabela de parsing reproduz estados canônicos sem conflitos.",
                                "Árvore sintática reconstruída reflete precedência (* > +).",
                                "Trace de pilha mostra shifts/reduces corretos.",
                                "Implementação lida com parênteses aninhados."
                              ],
                              "assessmentCriteria": [
                                "Correção da construção de estados e tabela (sem erros em itens/goto).",
                                "Implementação fiel do algoritmo LR (shift/reduce/accept/error).",
                                "Tratamento preciso de FOLLOW sets para reduces.",
                                "Testes abrangentes cobrindo casos válidos/inválidos/edge.",
                                "Documentação clara da tabela e traces.",
                                "Eficiência: O(n) tempo para parsing."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Autômatos: Estados como DFA para reconhecimento sintático.",
                                "Matemática Discreta: Conjuntos, relações e fechamentos.",
                                "Programação: Estruturas de dados (pilhas, tabelas hash).",
                                "Compiladores: Integração com lexical analysis (tokens id,+,*, etc.).",
                                "Algoritmos: Bottom-up vs top-down parsing."
                              ],
                              "realWorldApplication": "Parsers LR são o coração de compiladores em linguagens como C, Java, Python (usando Yacc/Bison ou ANTLR), processando código-fonte em tempo real para IDEs, interpreters e ferramentas de análise estática."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Autômatos de Pilha",
                "description": "Modelos de autômatos de pilha para linguagens livres de contexto.",
                "totalSkills": 48,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Definição Formal do Autômato de Pilha",
                    "description": "Estrutura formal incluindo estados, alfabeto de entrada, alfabeto da pilha, função de transição, estado inicial e estados de aceitação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Conjuntos Básicos do Autômato de Pilha",
                        "description": "Inclui o conjunto finito de estados (Q), o alfabeto de entrada (Σ) e o alfabeto da pilha (Γ), que formam a base estática da estrutura formal do autômato de pilha (PDA).",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Identificar o conjunto de estados Q",
                            "description": "Reconhecer e descrever Q como um conjunto finito de estados que representam as configurações internas do autômato de pilha, permitindo modelar o controle de fluxo não-determinístico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal do Autômato de Pilha (PDA)",
                                  "subSteps": [
                                    "Estude a tupla formal de um PDA: (Q, Σ, Γ, δ, q0, Z0, F).",
                                    "Identifique cada componente: Q (estados), Σ (alfabeto de entrada), Γ (alfabeto da pilha), δ (função de transição), q0 (estado inicial), Z0 (símbolo inicial da pilha), F (estados finais).",
                                    "Anote especificamente que Q é o conjunto finito de estados.",
                                    "Compare com autômatos finitos (FA) para notar similaridades em Q.",
                                    "Desenhe um diagrama esquemático da estrutura do PDA destacando Q."
                                  ],
                                  "verification": "Confirme entendendo verbalmente ou por escrito a composição da tupla PDA, listando todos os 7 componentes corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro ou notas sobre Automata e Linguagens Formais",
                                    "Papel e caneta para diagramas",
                                    "Exemplo de definição formal de PDA online ou em PDF"
                                  ],
                                  "tips": "Use cores diferentes para destacar Q nos diagramas para fixação visual.",
                                  "learningObjective": "Compreender a posição e o papel sintático de Q na definição formal do PDA.",
                                  "commonMistakes": [
                                    "Confundir Q com Σ ou Γ",
                                    "Achar que Q é infinito",
                                    "Ignorar o aspecto finito de Q"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Papel Conceitual de Q no Controle de Fluxo",
                                  "subSteps": [
                                    "Explique que Q representa configurações internas do PDA, como 'lendo entrada' ou 'empilhando'.",
                                    "Discuta como Q modela o controle não-determinístico via transições δ: Q × (Σ ∪ {ε}) × Γ → 2^{Q × Γ*}.",
                                    "Simule uma transição simples: de q em Q, consumindo símbolo, alterando pilha e indo para q' em Q.",
                                    "Compare determinístico vs. não-determinístico em termos de ramificações em Q.",
                                    "Crie uma tabela de estados hipotéticos para um PDA simples."
                                  ],
                                  "verification": "Descreva em 2-3 frases o que Q representa e dê um exemplo de transição envolvendo Q.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io ou papel",
                                    "Exemplos de PDAs de aula (ex: para a^n b^n)",
                                    "Vídeo tutorial curto sobre PDAs"
                                  ],
                                  "tips": "Pense em Q como 'modos' de uma máquina de lavar roupa: lavando, enxaguando, etc.",
                                  "learningObjective": "Graspar o significado semântico de Q como modelador de estados internos e fluxo não-determinístico.",
                                  "commonMistakes": [
                                    "Reduzir Q apenas a 'inicial/final'",
                                    "Não reconhecer o não-determinismo em Q",
                                    "Confundir estados com símbolos da pilha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar a Identificação de Q em Definições e Diagramas",
                                  "subSteps": [
                                    "Pegue 3 exemplos de PDAs (ex: palíndromos pares, a^n b^n, ww^R) e extraia Q explicitamente.",
                                    "Em notação textual, circule ou liste Q da tupla.",
                                    "Em diagramas de transição, rotule todos os estados e verifique se formam Q finito.",
                                    "Crie uma lista: 'Q = {q0, q1, q_loop, qf}' para cada exemplo.",
                                    "Teste alterando Q minimamente e observe impacto no reconhecimento."
                                  ],
                                  "verification": "Identifique corretamente Q em pelo menos 3 PDAs diferentes, listando-os sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "3 exemplos de PDAs impressos ou digitais",
                                    "Planilha para listar Qs",
                                    "Simulador de PDA online se disponível"
                                  ],
                                  "tips": "Sempre verifique se Q é finito e inclui q0 e F.",
                                  "learningObjective": "Desenvolver habilidade prática de localizar e extrair Q de representações formais e gráficas.",
                                  "commonMistakes": [
                                    "Incluir estados não declarados",
                                    "Esquecer estados de loop",
                                    "Copiar Σ como Q"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Sintetizar o Conhecimento sobre Q",
                                  "subSteps": [
                                    "Resuma Q em uma definição própria: 'Conjunto finito de estados internos para controle'.",
                                    "Crie um PDA minimalista com Q = {q0, q1} e descreva seu Q.",
                                    "Compare Q em PDA vs. NFA/DFA para reforçar similaridades.",
                                    "Resolva um exercício: dado PDA incompleto, complete Q.",
                                    "Autoavalie respondendo: 'Por que Q deve ser finito?'."
                                  ],
                                  "verification": "Escreva uma definição precisa de Q e aplique em um novo exemplo sem consulta.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para síntese",
                                    "Exercícios de PDA de um workbook",
                                    "Notas anteriores"
                                  ],
                                  "tips": "Ensine o conceito a um 'aluno imaginário' para fixar.",
                                  "learningObjective": "Consolidar a identificação de Q de forma autônoma e explicativa.",
                                  "commonMistakes": [
                                    "Definir Q de forma vaga",
                                    "Não enfatizar finitude",
                                    "Confundir com alfabeto de estados de outros autômatos"
                                  ]
                                }
                              ],
                              "practicalExample": "No PDA para reconhecer {a^n b^n | n ≥ 0}, Q = {q0, q1, qf}, onde q0 é inicial (lê a's, empilha A's), q1 (lê b's, desempilha A's), qf final (aceita se pilha vazia). Identifique Q na tupla (Q, {a,b}, {A,Z0}, δ, q0, Z0, {qf}) e no diagrama: setas de q0 para q1 em loop com a/AZ0 → AA Z0, etc.",
                              "finalVerifications": [
                                "Lista corretamente Q de uma tupla PDA dada.",
                                "Explica o papel de Q em uma transição δ.",
                                "Identifica Q em um diagrama de PDA.",
                                "Distingue Q de outros componentes como Σ e Γ.",
                                "Cria um Q simples para um PDA minimalista.",
                                "Verifica finitude e inclusão de q0/F em Q."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de Q (100% dos estados corretos).",
                                "Explicação clara do papel semântico de Q (profunda vs. superficial).",
                                "Capacidade de aplicar em exemplos variados (3+ PDAs).",
                                "Uso correto de terminologia formal (finito, não-determinístico).",
                                "Detecção de erros comuns em Q proposto.",
                                "Síntese autônoma sem consulta (definição própria)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (Q como conjunto finito).",
                                "Lógica: Estados como proposições em máquinas de Turing primitivas.",
                                "Programação: Estados em Finite State Machines (FSM) em linguagens como Python (ex: bibliotecas FSM).",
                                "Engenharia de Software: Estados em diagramas UML para controle de fluxo.",
                                "Física: Estados quânticos analógicos em modelagem não-determinística."
                              ],
                              "realWorldApplication": "Em compiladores, Q modela estados do parser (shift/reduce em YACC); em protocolos de rede (TCP states: LISTEN, SYN_SENT); em jogos (estados de personagem: idle, attacking); em UI/UX (estados de formulários: validando, submetendo)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Descrever o alfabeto de entrada Σ",
                            "description": "Explicar Σ como o conjunto finito de símbolos que formam as strings de entrada processadas pelo PDA, distinguindo-o do alfabeto da pilha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de alfabeto em teoria da computação",
                                  "subSteps": [
                                    "Defina alfabeto como um conjunto finito de símbolos indivisíveis.",
                                    "Identifique exemplos clássicos, como Σ = {0,1} para binário.",
                                    "Explique que strings são sequências finitas de símbolos de Σ.",
                                    "Discuta por que o alfabeto deve ser finito em autômatos.",
                                    "Pratique listando símbolos de alfabetos comuns."
                                  ],
                                  "verification": "Escreva uma definição precisa de alfabeto e forneça dois exemplos de Σ com strings sobre eles.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de teoria da computação",
                                    "Livro 'Introduction to Automata Theory' de Hopcroft",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": [
                                    "Sempre especifique Σ como conjunto finito {s1, s2, ..., sn}",
                                    "Use notação de conjunto para clareza",
                                    "Visualize strings como concatenações de símbolos"
                                  ],
                                  "learningObjective": "Dominar a definição formal de alfabeto e sua role em linguagens formais.",
                                  "commonMistakes": [
                                    "Confundir alfabeto com linguagem (Σ gera strings, mas não é a linguagem)",
                                    "Incluir símbolos infinitos",
                                    "Esquecer a finitude"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o papel do alfabeto de entrada em autômatos",
                                  "subSteps": [
                                    "Descreva como Σ define as entradas lidas pelo autômato.",
                                    "Compare com AFAs: Σ é o mesmo, mas PDA usa pilha adicionalmente.",
                                    "Analise como o PDA consome símbolos de Σ da fita de entrada.",
                                    "Crie diagramas mostrando leitura sequencial de Σ.",
                                    "Liste propriedades: Σ finito, ε-transições possíveis."
                                  ],
                                  "verification": "Desenhe um diagrama simples de PDA lendo uma string w ∈ Σ* e rotule Σ.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de desenho como Draw.io",
                                    "Exemplos de PDA online",
                                    "Quadro branco"
                                  ],
                                  "tips": [
                                    "Lembre-se: PDA processa w ∈ Σ* simbolicamente",
                                    "Foquem na transição δ: Q × Σε × Γε → 2^{Q × Γ}",
                                    "Pratique com strings vazias (ε ∈ Σ*)"
                                  ],
                                  "learningObjective": "Entender como Σ estrutura as entradas em autômatos de pilha.",
                                  "commonMistakes": [
                                    "Confundir leitura de Σ com manipulação da pilha",
                                    "Ignorar ε em Σε",
                                    "Pensar Σ como infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir formalmente Σ no contexto do PDA",
                                  "subSteps": [
                                    "Estude a definição formal do PDA: M = (Q, Σ, Γ, δ, q0, Z0, F).",
                                    "Explique Σ como alfabeto de entrada finito para strings w.",
                                    "Escreva Σ explicitamente para PDAs exemplo.",
                                    "Verifique consistência: todos símbolos de entrada em Σ.",
                                    "Pratique descrevendo Σ para linguagens como {a^n b^n}."
                                  ],
                                  "verification": "Escreva a tupla completa de um PDA exemplo, destacando Σ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de fórmulas de PDA",
                                    "Exercícios de linguagens context-free",
                                    "Calculadora para contar símbolos"
                                  ],
                                  "learningObjective": "Capacitar-se a declarar Σ corretamente na definição formal do PDA.",
                                  "commonMistakes": [
                                    "Omitir Σ na tupla",
                                    "Incluir símbolos da pilha em Σ",
                                    "Usar Σ para pilha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Distinguir Σ do alfabeto da pilha Γ",
                                  "subSteps": [
                                    "Defina Γ como alfabeto da pilha, contendo símbolos de stack.",
                                    "Compare: Σ para entrada (fita), Γ para pilha (LIFO).",
                                    "Dê exemplos: Σ={a,b}, Γ={a,b,Z0} para palíndromos.",
                                    "Analise transições: δ lê de Σε e Γε, empilha/pop de Γ.",
                                    "Crie tabela comparativa Σ vs Γ."
                                  ],
                                  "verification": "Crie uma tabela comparando Σ e Γ com exemplos e funções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela comparativa template",
                                    "Exemplos de PDA resolvidos",
                                    "Marcadores para quadro"
                                  ],
                                  "tips": [
                                    "Σ: leitura unidirecional; Γ: push/pop bidirecional",
                                    "Z0 ∈ Γ sempre",
                                    "Símbolos podem sobrepor, mas funções diferem"
                                  ],
                                  "learningObjective": "Diferenciar precisamente Σ e Γ para evitar confusões em PDAs.",
                                  "commonMistakes": [
                                    "Misturar símbolos: achar Σ inclui Z0",
                                    "Pensar Γ como entrada",
                                    "Ignorar sobreposição possível"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar descrição completa de Σ em PDAs",
                                  "subSteps": [
                                    "Escolha uma linguagem CFL e defina PDA com Σ explícito.",
                                    "Descreva verbalmente: 'Σ é o conjunto finito {...}'",
                                    "Teste com strings inválidas (símbolos fora de Σ).",
                                    "Revise definições de múltiplos PDAs.",
                                    "Autoavalie descrições."
                                  ],
                                  "verification": "Descreva Σ para 3 PDAs diferentes em parágrafos curtos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de linguagens CFL",
                                    "Simulador de PDA online",
                                    "Timer para prática"
                                  ],
                                  "learningObjective": "Aplicar descrição de Σ de forma fluida e precisa.",
                                  "commonMistakes": [
                                    "Descrições vagas sem lista explícita",
                                    "Confundir com alfabeto de saída",
                                    "Esquecer distinção em exemplos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um PDA que reconhece a linguagem {a^n b^n | n ≥ 0}, defina Σ = {a, b}. Isso significa que as strings de entrada são formadas apenas por 'a' e 'b', como ε, ab, aabb. Distinga de Γ = {a, Z0}, onde Z0 é o fundo da pilha e 'a' é usado na pilha para contar, mas não lido da entrada.",
                              "finalVerifications": [
                                "Definição correta de Σ como conjunto finito de símbolos de entrada.",
                                "Explicação clara da distinção entre Σ e Γ.",
                                "Exemplo válido de Σ com strings sobre Σ*.",
                                "Uso correto na tupla formal do PDA.",
                                "Identificação de erros comuns em descrições.",
                                "Descrição verbal fluida e precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% dos elementos corretos).",
                                "Clareza na distinção Σ vs Γ (sem confusões).",
                                "Relevância e correção de exemplos fornecidos.",
                                "Completude na descrição (inclui finitude e role em entradas).",
                                "Capacidade de aplicar em contextos variados de PDA.",
                                "Ausência de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (Σ como conjunto finito).",
                                "Linguística: Símbolos fonéticos em fonologia formal.",
                                "Programação: Tokens e lexers em compiladores (análogos a Σ).",
                                "Lógica: Símbolos em sistemas formais deductivos."
                              ],
                              "realWorldApplication": "Em compiladores e parsers (ex: yacc/bison), Σ representa tokens ou caracteres do código-fonte processados sequencialmente, enquanto a pilha gerencia estruturas aninhadas como blocos if/else, permitindo análise sintática eficiente de linguagens de programação."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Explicar o alfabeto da pilha Γ",
                            "description": "Definir Γ como o conjunto finito de símbolos utilizados na pilha, incluindo o símbolo inicial Z0, que permite armazenar informações auxiliares durante o processamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito geral de alfabeto em linguagens formais",
                                  "subSteps": [
                                    "Revisar a definição de alfabeto como um conjunto finito de símbolos (ex: Σ para entrada).",
                                    "Identificar exemplos de alfabetos em autômatos finitos (AF) e autômatos de pilha (AP).",
                                    "Diferenciar alfabeto de entrada (Σ) de alfabeto de pilha (Γ).",
                                    "Listar propriedades de um alfabeto: finito, não-vazio e composto por símbolos indivisíveis.",
                                    "Estudar notação padrão: Γ é um conjunto finito Γ ⊆ {Z0, outros símbolos}."
                                  ],
                                  "verification": "Escrever uma definição clara de alfabeto e dar um exemplo com Σ e Γ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Notas de aula sobre autômatos",
                                    "Quadro branco ou papel para anotações"
                                  ],
                                  "tips": "Sempre associe o alfabeto a conjuntos matemáticos para fixar o conceito.",
                                  "learningObjective": "Dominar a noção básica de alfabeto como base para símbolos em autômatos.",
                                  "commonMistakes": "Confundir alfabeto de pilha (Γ) com alfabeto de entrada (Σ); assumir que Γ é infinito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o alfabeto da pilha Γ no contexto do Autômato de Pilha (AP)",
                                  "subSteps": [
                                    "Ler a definição formal de AP: (Q, Σ, Γ, δ, q0, Z0, F).",
                                    "Explicar que Γ é o conjunto finito de símbolos que podem ser empilhados.",
                                    "Destacar que Γ inclui símbolos de Σ ou símbolos auxiliares exclusivos da pilha.",
                                    "Analisar a transição δ: δ(q, a, Z) = (p, γ), onde γ ∈ Γ*.",
                                    "Verificar que |Γ| é finito para garantir decidibilidade."
                                  ],
                                  "verification": "Desenhar o componente Γ em um diagrama de AP e explicar seu papel.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama formal de AP impresso",
                                    "Editor de texto para fórmulas",
                                    "Vídeo tutorial sobre PDA (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use notação LaTeX ou pseudocódigo para representar Γ com clareza.",
                                  "learningObjective": "Entender Γ como o 'vocabulário' da pilha no AP.",
                                  "commonMistakes": "Omitir que Γ pode conter símbolos não presentes em Σ; ignorar finitude."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o símbolo inicial Z0 em Γ",
                                  "subSteps": [
                                    "Definir Z0 como o símbolo inicial único em Γ, colocado no topo da pilha vazia.",
                                    "Descrever o estado inicial: pilha = Z0 (pilha com apenas Z0).",
                                    "Exemplificar transições que pop/push Z0: δ(q0, ε, Z0) = (q1, Z0 A).",
                                    "Discutir por que Z0 é obrigatório: marca o 'fundo' da pilha.",
                                    "Comparar com pilha vazia em outras estruturas."
                                  ],
                                  "verification": "Simular uma transição inicial com Z0 e verificar se a pilha começa corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Simulador de PDA online (ex: JFLAP)",
                                    "Papel para simular pilha manualmente"
                                  ],
                                  "tips": "Sempre escreva a pilha de baixo para cima: Z0 no fundo.",
                                  "learningObjective": "Compreender Z0 como marcador essencial para o funcionamento da pilha.",
                                  "commonMistakes": "Confundir Z0 com símbolo de entrada; esquecer que Z0 permanece no fundo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o uso de Γ para armazenamento de informações auxiliares",
                                  "subSteps": [
                                    "Explicar que símbolos em Γ armazenam 'memória' não disponível em AF (ex: contar a's).",
                                    "Dar exemplo: em {a^n b^n}, Γ = {Z0, A}, A conta a's empilhados.",
                                    "Simular processamento: empilhar A por a, desempilhar por b, aceitar se Z0 exposto.",
                                    "Discutir limitações: pilha LIFO, Γ finito limita poder (não Turing-completo).",
                                    "Relacionar com poder expressivo: AP reconhece linguagens livres de contexto."
                                  ],
                                  "verification": "Criar um exemplo simples de Γ auxiliar e simular aceitação/rejeição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JFLAP ou simulador PDA",
                                    "Exemplos de linguagens CFL"
                                  ],
                                  "tips": "Pense na pilha como 'auxiliar' para matching, não para entrada.",
                                  "learningObjective": "Reconhecer como Γ habilita reconhecimento de linguagens mais complexas.",
                                  "commonMistakes": "Achar que Γ armazena ordem arbitrária (é LIFO); exagerar poder de AP."
                                }
                              ],
                              "practicalExample": "No AP para {a^n b^n | n ≥ 0}: Σ = {a,b}, Γ = {Z0, A}. Início: pilha = Z0. Para 'aabbb': leia a (push A, pilha=Z0 A), a (push A, Z0 A A), b (pop A, Z0 A), etc. Aceita se após b's, topo=Z0 e fim de entrada.",
                              "finalVerifications": [
                                "Definir corretamente Γ como conjunto finito de símbolos da pilha.",
                                "Explicar o papel obrigatório de Z0 como símbolo inicial.",
                                "Diferenciar Γ de Σ com exemplo.",
                                "Simular uma transição δ envolvendo símbolos de Γ.",
                                "Identificar como Γ armazena info auxiliar em um PDA simples.",
                                "Verificar finitude e LIFO da pilha."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de Γ e Z0 (sem omissões).",
                                "Correta diferenciação entre Σ, Γ e seu uso em transições.",
                                "Uso de exemplos concretos e simulações sem erros.",
                                "Compreensão do armazenamento auxiliar via símbolos em Γ.",
                                "Clareza na explicação verbal ou escrita.",
                                "Identificação de limitações de Γ (finito, LIFO)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (Γ como conjunto finito).",
                                "Lógica: Estados e transições finitas em autômatos.",
                                "Programação: Estruturas de pilha (stacks em Python/Java para parsing).",
                                "Linguística: Análise sintática de linguagens naturais (parsing recursivo)."
                              ],
                              "realWorldApplication": "Em compiladores (ex: parsers LL/LR usam pilhas com símbolos auxiliares para validar expressões balanceadas como parênteses ou tags XML), permitindo análise de código fonte eficiente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Função de Transição δ",
                        "description": "A função de transição δ: Q × (Σ ∪ {ε}) × Γ → ℘(Q × Γ*), que especifica as transições possíveis consumindo um símbolo de entrada (ou ε), lendo o topo da pilha e empilhando uma string finita de símbolos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Entender o domínio da função δ",
                            "description": "Analisar o domínio composto por estado atual, símbolo de entrada (incluindo ε para transições espontâneas) e topo da pilha, destacando o caráter não-determinístico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal do Autômato de Pilha (PDA)",
                                  "subSteps": [
                                    "Relembre os componentes de um PDA: Q (estados), Σ (alfabeto de entrada), Γ (alfabeto da pilha), δ (função de transição), q0 (estado inicial), Z0 (símbolo inicial da pilha), F (estados finais).",
                                    "Identifique que δ é a função central que define as transições.",
                                    "Desenhe um diagrama esquemático de um PDA simples para visualizar a estrutura.",
                                    "Explique verbalmente como a pilha diferencia um PDA de um AFD.",
                                    "Liste exemplos de linguagens reconhecidas por PDAs (ex: {a^n b^n})."
                                  ],
                                  "verification": "Capacidade de listar e descrever todos os 7 componentes do PDA sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Teoria da Computação, quadro branco ou papel para diagramas.",
                                  "tips": "Use mnemônicos como 'QΣΓδqZ F' para memorizar componentes.",
                                  "learningObjective": "Compreender o contexto geral do PDA antes de focar em δ.",
                                  "commonMistakes": "Confundir pilha com fita de Turing ou ignorar o símbolo inicial Z0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os três elementos do domínio da função δ",
                                  "subSteps": [
                                    "Defina o domínio de δ como δ: Q × (Σ ∪ {ε}) × Γ → finito subconjuntos de Q × Γ*.",
                                    "Descreva o primeiro elemento: estado atual q ∈ Q.",
                                    "Descreva o segundo: símbolo de entrada a ∈ Σ ∪ {ε} (transições ε espontâneas sem consumir entrada).",
                                    "Descreva o terceiro: topo da pilha γ ∈ Γ.",
                                    "Escreva a notação formal δ(q, a, γ) = {(q1, α1), (q2, α2), ...}."
                                  ],
                                  "verification": "Escrever corretamente a assinatura da função δ em notação matemática.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de anotações, exemplos de definições formais de PDA.",
                                  "tips": "Pense no domínio como uma 'chave de transição': (estado + input + stack-top).",
                                  "learningObjective": "Memorizar e articular precisamente os componentes do domínio.",
                                  "commonMistakes": "Esquecer ε no domínio de entrada ou confundir Γ com Σ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o papel de cada componente e o não-determinismo",
                                  "subSteps": [
                                    "Analise como o estado atual determina o 'contexto de controle'.",
                                    "Discuta como o símbolo de entrada (incluindo ε) permite transições sem leitura.",
                                    "Explique como o topo da pilha fornece 'memória finita ilimitada' via push/pop.",
                                    "Ilustre o não-determinismo: δ pode mapear para múltiplas transições possíveis.",
                                    "Simule uma transição não-determinística em um PDA exemplo."
                                  ],
                                  "verification": "Explicar por que o PDA é mais poderoso que um AFD usando o domínio de δ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulador de PDA online ou software como JFLAP.",
                                  "tips": "Visualize não-determinismo como 'escolhas ramificadas' em um jogo.",
                                  "learningObjective": "Entender funcionalmente como o domínio habilita reconhecimento de linguagens CFL.",
                                  "commonMistakes": "Interpretar δ como determinística ou ignorar que imagem é subconjunto finito."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar análise de domínios em exemplos reais",
                                  "subSteps": [
                                    "Pegue um PDA para {ww^R | w ∈ {a,b}*} e liste domínios possíveis para δ.",
                                    "Compute δ(q0, ε, Z0) e discuta múltiplas saídas.",
                                    "Trace uma configuração de PDA: (q, w, γZ0) → δ(q, próximo símbolo ou ε, γ).",
                                    "Compare com domínio de AFD: Q × Σ (sem pilha ou ε livre).",
                                    "Crie seu próprio exemplo mínimo de δ com não-determinismo."
                                  ],
                                  "verification": "Resolver 3 exercícios de análise de δ corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Exercícios impressos ou JFLAP para simulação.",
                                  "tips": "Sempre anote a configuração completa: estado, resto da entrada, pilha inteira.",
                                  "learningObjective": "Aplicar o entendimento do domínio em cenários concretos.",
                                  "commonMistakes": "Não considerar todas as combinações possíveis no domínio ou esquecer pop/push."
                                }
                              ],
                              "practicalExample": "Em um PDA reconhecendo palíndromos pares {ww^R}, δ(q0, ε, Z0) = {(q1, Z0 A Z0)} inicia empilhando o primeiro símbolo sem ler entrada (ε-transição), onde domínio é (q0, ε, Z0); depois δ(q1, a, A) = {(q1, A A)} empilha 'a' lendo 'a'. Não-determinismo surge se múltiplas opções para pop.",
                              "finalVerifications": [
                                "Pode listar os 3 elementos exatos do domínio de δ?",
                                "Explica corretamente o papel de ε no domínio?",
                                "Descreve o não-determinismo via subconjuntos finitos na imagem?",
                                "Distingue domínio de PDA vs. AFD?",
                                "Simula uma transição δ com configuração correta?",
                                "Identifica quando uma transição é espontânea (ε)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal do domínio (100% correto).",
                                "Compreensão demonstrada do não-determinismo (exemplos múltiplos).",
                                "Capacidade de análise em exemplos concretos (sem erros em simulações).",
                                "Explicação clara do papel da pilha no domínio.",
                                "Integração com conceitos maiores de PDA (poder expressivo).",
                                "Criatividade em exemplos personalizados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de funções parciais e conjuntos (domínio e imagem).",
                                "Lógica: Não-determinismo similar a provas não-determinísticas em complexidade.",
                                "Programação: Análogo a parsers recursivos descendentes em compiladores.",
                                "Física: Estados e transições como autômatos em simulações quânticas (não-determinismo)."
                              ],
                              "realWorldApplication": "Em compiladores, a função δ modela parsers LL/LR que usam pilha para sintaxe aninhada (ex: chaves em C++), lidando com ambiguidades via lookahead (não-determinismo resolvido por tabelas)."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Interpretar o codomínio de δ",
                            "description": "Compreender que δ mapeia para subconjuntos finitos de Q × Γ*, permitindo múltiplas transições simultâneas (não-determinismo) e operações como empilhar, desempilhar ou manter o topo da pilha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a assinatura formal da função de transição δ",
                                  "subSteps": [
                                    "Relembrar o domínio de δ: Q (estados) × (Σ ∪ {ε}) (símbolos de entrada) × Γ (símbolos da pilha).",
                                    "Identificar o codomínio: subconjuntos finitos de Q × Γ* (pares estado × string finita da pilha).",
                                    "Consultar a definição formal em um livro ou referência de autômatos de pilha.",
                                    "Escrever a assinatura δ: Q × (Σ ∪ {ε}) × Γ → 2^(Q × Γ*) em suas próprias palavras."
                                  ],
                                  "verification": "Escrever e verbalizar a assinatura completa de δ, confirmando domínio e codomínio.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Notas de aula sobre PDA",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Preste atenção aos símbolos ε, que permitem transições sem consumir input ou pilha.",
                                  "learningObjective": "Compreender os tipos de entrada e saída da função δ em autômatos de pilha.",
                                  "commonMistakes": [
                                    "Confundir com função de transição de AFD (simples par, não subconjunto).",
                                    "Ignorar Γ* e assumir apenas símbolos únicos da pilha."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o codomínio como conjunto de transições possíveis",
                                  "subSteps": [
                                    "Analisar que cada elemento (p, γ) ∈ δ(q, a, Z) indica: ir para estado p e substituir Z por γ.",
                                    "Explicar que o subconjunto finito permite múltiplas transições simultâneas de um mesmo input.",
                                    "Diferenciar de funções determinísticas: aqui, |δ(q,a,Z)| pode ser >1.",
                                    "Desenhar um diagrama simples mostrando δ(q,a,Z) = {(p1, γ1), (p2, γ2)}."
                                  ],
                                  "verification": "Listar 2 exemplos de codomínio e explicar o que cada par representa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de desenho (ex: Draw.io)",
                                    "Referência de PDA não-determinísticos"
                                  ],
                                  "tips": "Pense no codomínio como 'opções' que o autômato explora em paralelo.",
                                  "learningObjective": "Reconhecer que subconjuntos finitos codificam não-determinismo inerente ao PDA.",
                                  "commonMistakes": [
                                    "Interpretar subconjunto como sequência linear em vez de branches paralelas.",
                                    "Esquecer que é finito, permitindo computação efetiva."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar operações na pilha via elementos de Γ*",
                                  "subSteps": [
                                    "Classificar γ = ε: desempilhar (pop).",
                                    "Classificar |γ| = 1: substituir topo (manter ou replace).",
                                    "Classificar |γ| > 1: empilhar símbolos adicionais (push).",
                                    "Mapear essas operações para mudanças na configuração da pilha.",
                                    "Simular uma transição com cada tipo em um exemplo simples."
                                  ],
                                  "verification": "Para um dado δ(q,a,Z), listar as operações de pilha para cada elemento do codomínio.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de PDA online (ex: JFLAP)",
                                    "Exemplos de transições anotadas"
                                  ],
                                  "tips": "Sempre verifique o comprimento de γ para identificar push/pop/keep.",
                                  "learningObjective": "Associar elementos do codomínio a manipulações concretas na pilha.",
                                  "commonMistakes": [
                                    "Confundir ε com empilhar vazio (ε é pop).",
                                    "Assumir Γ* permite pilha infinita em uma transição (é finita)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a interpretação em um exemplo completo de não-determinismo",
                                  "subSteps": [
                                    "Escolher um PDA simples (ex: reconhecimento de palíndromos pares).",
                                    "Computar δ para um estado específico com múltiplas saídas.",
                                    "Traçar as branches não-determinísticas e suas implicações na pilha.",
                                    "Discutir como o codomínio permite 'escolhas' resolvidas por aceitação."
                                  ],
                                  "verification": "Simular 3 configurações sucessivas usando o codomínio de δ.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "JFLAP ou simulador similar",
                                    "Papel para traçar configurações (q, w, α)"
                                  ],
                                  "tips": "Use cores diferentes para branches não-determinísticas no diagrama.",
                                  "learningObjective": "Integrar interpretação do codomínio com execução real de PDA.",
                                  "commonMistakes": [
                                    "Ignorar ε-moves na entrada ou pilha durante simulação.",
                                    "Confundir rejeição precoce com não-determinismo inválido."
                                  ]
                                }
                              ],
                              "practicalExample": "No PDA para {ww^R | w ∈ {a,b}*}, δ(q0, ε, Z) = {(q1, Z), (q2, Z)} permite branches: uma para rejeitar imediatamente (q2 rejeita), outra para prosseguir empilhando (q1). Isso demonstra múltiplas transições simultâneas do mesmo input ε, com keep na pilha.",
                              "finalVerifications": [
                                "Descrever corretamente o codomínio de δ como 2^(Q × Γ*).",
                                "Explicar não-determinismo via |δ(q,a,Z)| > 1.",
                                "Identificar pop (γ=ε), push (|γ|>1), replace (|γ|=1).",
                                "Simular uma transição com múltiplas saídas.",
                                "Diferenciar PDA de AFD pela natureza do codomínio."
                              ],
                              "assessmentCriteria": [
                                "Precisão na assinatura de δ (100% correta).",
                                "Correção em classificação de operações de pilha (todos os tipos cobertos).",
                                "Clareza na explicação de não-determinismo com diagrama.",
                                "Profundidade na simulação de exemplo (pelo menos 2 branches).",
                                "Uso correto de terminologia formal (Q, Γ*, ε)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e funções multivaluadas (potência 2^S).",
                                "Programação: Estruturas de pilha e recursão em linguagens como Python/C++.",
                                "Lógica: Não-determinismo vs. determinismo em modelos computacionais.",
                                "Engenharia de Software: Parsing e análise sintática em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores, PDAs modelam parsers que verificam balanceamento de chaves/parênteses em código-fonte, usando não-determinismo para lidar com ambiguidades gramaticais e empilhando símbolos para contextos aninhados."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Representar transições formalmente",
                            "description": "Escrever notações como δ(q, a, A) = {(p, α), (r, β)} para ilustrar transições que alteram estado e pilha, diferenciando pop, push e ε-movimentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os componentes de entrada da função de transição δ",
                                  "subSteps": [
                                    "Identifique os três argumentos de entrada: estado atual q ∈ Q, símbolo de entrada a ∈ Σ ∪ {ε}, e símbolo do topo da pilha A ∈ Γ.",
                                    "Revise as definições formais: Q (estados), Σ (alfabeto de entrada), Γ (alfabeto da pilha).",
                                    "Pratique identificando cada componente em exemplos simples de PDAs.",
                                    "Diferencie ε como símbolo vazio para transições sem entrada ou pop/push.",
                                    "Anote exemplos onde um ou mais são ε."
                                  ],
                                  "verification": "Liste corretamente os três componentes de entrada com exemplos para um PDA dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Definição formal de PDA (notas ou livro-texto)",
                                    "Exemplos de PDAs básicos"
                                  ],
                                  "tips": "Sempre escreva δ(q, a, A) explicitamente para visualizar os inputs.",
                                  "learningObjective": "Compreender e identificar precisamente os três parâmetros de entrada da função δ.",
                                  "commonMistakes": [
                                    "Confundir símbolo de entrada com símbolo da pilha",
                                    "Esquecer que ε pode aparecer em qualquer posição de entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar os tipos de operações na pilha (pop, push, ε)",
                                  "subSteps": [
                                    "Aprenda pop: α = ε (remove topo sem adicionar).",
                                    "Aprenda push: α com |α| > 1 (adiciona símbolos, primeiro à esquerda vai para o fundo).",
                                    "Aprenda replace: |α| = 1 (substitui topo).",
                                    "Identifique ε-movimentos: transições sem mudar entrada ou pilha.",
                                    "Classifique 5 exemplos de transições em pop, push ou replace."
                                  ],
                                  "verification": "Classifique corretamente 5 transições dadas como pop, push, replace ou ε.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de tipos de transições em PDAs",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Lembre-se: a string α é processada da esquerda para a direita na pilha (esquerda é fundo).",
                                  "learningObjective": "Diferenciar operações de pilha e representá-las corretamente em δ.",
                                  "commonMistakes": [
                                    "Inverter ordem de push (esquerda é fundo)",
                                    "Confundir pop com replace"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever a notação básica para uma única transição",
                                  "subSteps": [
                                    "Escreva δ(q, a, A) = {(p, α)} para uma transição simples.",
                                    "Pratique com pop: δ(q, a, A) = {(p, ε)}.",
                                    "Pratique com push: δ(q, ε, B) = {(p, aA)} (empilha 'a' sobre A).",
                                    "Inclua ε-transições: δ(q, ε, ε) = {(p, γ)}.",
                                    "Valide a sintaxe: parênteses, vírgulas e chaves corretas."
                                  ],
                                  "verification": "Escreva 3 transições corretas para cenários dados (pop, push, ε).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Modelos de notação formal",
                                    "Exercícios de transições isoladas"
                                  ],
                                  "tips": "Use conjuntos {} mesmo para uma transição única para consistência.",
                                  "learningObjective": "Construir notações δ precisas para transições unitárias.",
                                  "commonMistakes": [
                                    "Omitir chaves ou parênteses",
                                    "Usar colchetes em vez de chaves para múltiplos pares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Representar transições múltiplas e complexas",
                                  "subSteps": [
                                    "Escreva δ(q, a, A) = {(p, α), (r, β)} para ramificações.",
                                    "Combine tipos: inclua pop e push na mesma δ.",
                                    "Pratique com ε-movimentos múltiplos.",
                                    "Construa uma função δ parcial para um PDA pequeno (3-5 transições).",
                                    "Verifique consistência com diagrama de estados."
                                  ],
                                  "verification": "Crie e valide uma δ com pelo menos 3 transições múltiplas para um exemplo dado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Diagrama de PDA exemplo",
                                    "Ferramenta de desenho ou papel quadriculado"
                                  ],
                                  "tips": "Ordene pares logicamente (ex: por estado destino) para clareza.",
                                  "learningObjective": "Lidar com não-determinismo representando múltiplas saídas em δ.",
                                  "commonMistakes": [
                                    "Duplicar pares idênticos",
                                    "Esquecer vírgulas entre pares"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um PDA que reconhece {a^n b^n | n ≥ 0}, escreva: δ(q0, a, ε) = {(q1, a)}, δ(q1, a, a) = {(q1, aa)}, δ(q1, b, a) = {(q1, ε)}, δ(q1, ε, a) = {(q0, ε)}.",
                              "finalVerifications": [
                                "Escreva δ corretamente para 5 transições variadas (pop, push, ε, múltiplas).",
                                "Diferencie pop vs push em 3 exemplos.",
                                "Construa δ parcial para um PDA simples sem erros sintáticos.",
                                "Explique verbalmente uma transição complexa.",
                                "Valide δ contra um diagrama de PDA dado.",
                                "Identifique erros em 3 notações δ incorretas."
                              ],
                              "assessmentCriteria": [
                                "Precisão sintática: uso correto de δ(q,a,A) = {(p,α), ...}.",
                                "Correta diferenciação de pop (α=ε), push (|α|>1), replace (|α|=1).",
                                "Manuseio de ε em entradas e saídas.",
                                "Representação precisa de não-determinismo com múltiplos pares.",
                                "Consistência com convenções formais (estados, símbolos válidos).",
                                "Clareza e ordenação lógica das transições."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções parciais e relações em teoria dos conjuntos.",
                                "Lógica: Representação formal de regras de inferência.",
                                "Programação: Semelhança com funções de parsing em compiladores (ex: shift-reduce).",
                                "Linguística Computacional: Modelagem de gramáticas livres de contexto.",
                                "Engenharia de Software: Especificação formal de comportamentos de sistemas."
                              ],
                              "realWorldApplication": "Em compiladores, PDAs modelam parsers para linguagens de programação, onde δ define como processar tokens e gerenciar pilha de símbolos durante análise sintática, essencial para detectar erros de matching como parênteses desbalanceados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Estado Inicial, Símbolo Inicial e Estados de Aceitação",
                        "description": "Componentes q0 ∈ Q (estado inicial), Z0 ∈ Γ (símbolo inicial da pilha) e F ⊆ Q (estados de aceitação), que definem o ponto de partida e critério de aceitação por estado final.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Descrever o estado inicial q0 e Z0",
                            "description": "Explicar que a configuração inicial é (q0, ε, Z0), onde a pilha começa com Z0 no fundo, iniciando o processamento da string de entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de configuração em Autômatos de Pilha",
                                  "subSteps": [
                                    "Estude a definição formal de uma configuração em PDA: tripla (q, w, γ), onde q é o estado atual, w é a string de entrada não processada e γ é o conteúdo da pilha (do topo ao fundo).",
                                    "Identifique que no início, w = ε (string vazia, pois nada foi lido).",
                                    "Aprenda que a pilha é uma estrutura LIFO (Last In, First Out).",
                                    "Revise exemplos de transições que alteram a configuração.",
                                    "Anote os três componentes essenciais de qualquer configuração."
                                  ],
                                  "verification": "Liste e explique os três componentes de uma configuração PDA com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Slides ou capítulo de livro sobre Autômatos de Pilha (ex: 'Teoria da Computação' de Sipser), quadro branco para diagramas.",
                                  "tips": "Visualize a configuração como um 'instantâneo' do autômato em um momento específico.",
                                  "learningObjective": "Dominar os componentes fundamentais de uma configuração em PDA.",
                                  "commonMistakes": "Confundir w (entrada restante) com o símbolo lido ou inverter a ordem da pilha (topo vs. fundo)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e descrever o estado inicial q0",
                                  "subSteps": [
                                    "Defina q0 como o estado de partida único do autômato, indicado na definição formal Q × Γ → Q × Γ* × {ε, δ, γ}.",
                                    "Explique que todas as computações começam em q0, independentemente da entrada.",
                                    "Diferencie q0 dos estados de aceitação F.",
                                    "Pratique identificando q0 em diagramas de PDA.",
                                    "Escreva uma frase descrevendo o papel de q0 no processamento inicial."
                                  ],
                                  "verification": "Apresente um PDA simples e aponte corretamente q0 como estado inicial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagramas de PDA impressos ou ferramenta online como JFLAP.",
                                  "tips": "q0 é sempre o 'ponto de entrada'; marque-o com uma seta dupla em diagramas.",
                                  "learningObjective": "Explicar precisamente o papel e a unicidade do estado inicial q0.",
                                  "commonMistakes": "Confundir q0 com estados de aceitação ou assumir múltiplos estados iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o símbolo inicial da pilha Z0",
                                  "subSteps": [
                                    "Defina Z0 como o símbolo especial de fundo da pilha (bottom-of-stack symbol), pertencente a Γ mas não a Σ.",
                                    "Descreva que a pilha inicia com apenas Z0, servindo como marcador para evitar pilha vazia.",
                                    "Entenda que Z0 permite empilhar e desempilhar sem esvaziar completamente a pilha.",
                                    "Compare Z0 com $ em parsers LR.",
                                    "Desenhe a pilha inicial mostrando Z0 no fundo."
                                  ],
                                  "verification": "Desenhe a pilha inicial e rotule Z0 corretamente, explicando sua função.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta para desenhos de pilha, vídeo tutorial sobre PDA.",
                                  "tips": "Pense em Z0 como um 'tapete' que sempre fica no fundo da pilha.",
                                  "learningObjective": "Compreender o propósito e a colocação de Z0 na pilha inicial.",
                                  "commonMistakes": "Tratar Z0 como um símbolo da entrada (Σ) ou assumir pilha vazia no início."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever a configuração inicial completa (q0, ε, Z0)",
                                  "subSteps": [
                                    "Combine os conceitos: configuração inicial é (q0, ε, Z0), pronta para processar a string de entrada.",
                                    "Explique o fluxo: do estado q0, com entrada ε (início) e pilha Z0, a primeira transição lê o primeiro símbolo.",
                                    "Pratique verbalizando: 'A configuração inicial é (q0, ε, Z0), onde a pilha começa com Z0 no fundo'.",
                                    "Simule uma transição inicial em um exemplo.",
                                    "Resuma em um diagrama unificado."
                                  ],
                                  "verification": "Explique oralmente ou por escrito a configuração inicial e simule o primeiro passo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta simuladora de PDA (ex: JFLAP), resumo escrito dos passos anteriores.",
                                  "tips": "Sempre recite a tripla completa para fixar a memória.",
                                  "learningObjective": "Integrar q0, ε e Z0 em uma descrição fluida da configuração inicial.",
                                  "commonMistakes": "Esquecer ε ou inverter a notação da pilha (Z0 no topo)."
                                }
                              ],
                              "practicalExample": "Em um PDA que reconhece palíndromos pares sobre {a,b}*, a configuração inicial é (q0, ε, Z0). De q0, lendo o primeiro 'a', empilha 'a' sobre Z0, resultando em (q1, resto_da_entrada, a Z0). Isso inicia o empilhamento da primeira metade da string.",
                              "finalVerifications": [
                                "Descreva verbalmente a configuração inicial (q0, ε, Z0) sem erros.",
                                "Desenhe a pilha inicial com Z0 corretamente posicionado.",
                                "Explique o que acontece na primeira transição a partir dessa configuração.",
                                "Diferencie configuração inicial de uma configuração intermediária.",
                                "Identifique q0 e Z0 em um diagrama de PDA fornecido.",
                                "Resuma o propósito de cada componente em uma frase."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de q0 como estado único inicial.",
                                "Correta descrição de ε como entrada não processada vazia.",
                                "Explicação clara do papel de Z0 como marcador de fundo da pilha.",
                                "Uso consistente da notação (q0, ε, Z0) em exemplos.",
                                "Capacidade de simular transições iniciais sem confusões.",
                                "Integração correta dos três componentes em uma configuração coesa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e relações (estados Q, alfabeto pilha Γ).",
                                "Programação: Estruturas de dados pilha em linguagens como Python ou C++.",
                                "Lógica e Matemática Discreta: Autômatos finitos como base para PDA.",
                                "Engenharia de Software: Parsers em compiladores usando pilhas."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores (ex: parsers LL ou LR), a configuração inicial com estado start e símbolo de fundo da pilha inicia a análise sintática de código-fonte, empilhando não-terminais para validar estruturas como expressões balanceadas."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Explicar os estados de aceitação F",
                            "description": "Definir que uma string é aceita se, após processar toda a entrada, o PDA estiver em um estado de F, independentemente do conteúdo da pilha (aceitação por estado final).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os componentes básicos de um Autômato de Pilha (PDA)",
                                  "subSteps": [
                                    "Identificar os elementos principais de um PDA: conjunto de estados Q, alfabeto de entrada Σ, alfabeto da pilha Γ, função de transição δ, estado inicial q0, símbolo inicial Z0 e conjunto de estados de aceitação F.",
                                    "Explicar o papel de cada componente, com ênfase nos estados Q e F.",
                                    "Desenhar um diagrama esquemático de um PDA simples para visualizar os estados.",
                                    "Listar exemplos de PDAs conhecidos, como o reconhecedor de palíndromos.",
                                    "Discutir como o PDA processa uma string de entrada consumindo símbolos e manipulando a pilha."
                                  ],
                                  "verification": "O aluno desenha corretamente um diagrama de PDA com estados Q e F destacados e explica verbalmente cada componente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Referência: Livro de Teoria da Computação (Sipser ou similar)",
                                    "Ferramenta online como JFLAP para simulação"
                                  ],
                                  "tips": "Comece sempre pelo estado inicial q0 e trace o caminho até possíveis estados F.",
                                  "learningObjective": "Compreender os componentes fundamentais de um PDA, preparando o terreno para a aceitação por estados finais.",
                                  "commonMistakes": [
                                    "Confundir alfabeto de entrada Σ com alfabeto da pilha Γ",
                                    "Esquecer o símbolo inicial Z0",
                                    "Ignorar que F é um subconjunto de Q"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o conjunto de estados de aceitação F",
                                  "subSteps": [
                                    "Definir F como um subconjunto finito de Q, onde F ⊆ Q.",
                                    "Explicar que F representa os estados 'aceitadores' do PDA.",
                                    "Discutir que o PDA pode ter múltiplos estados em F ou apenas um.",
                                    "Exemplificar com notação formal: PDA = (Q, Σ, Γ, δ, q0, Z0, F).",
                                    "Criar uma tabela simples listando estados Q e marcando quais pertencem a F."
                                  ],
                                  "verification": "O aluno escreve a definição formal de F e cria uma tabela correta para um PDA exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Exemplos de PDAs impressos ou digitais"
                                  ],
                                  "tips": "Lembre-se: F indica sucesso, independentemente da pilha.",
                                  "learningObjective": "Ser capaz de definir precisamente o conjunto F na estrutura formal de um PDA.",
                                  "commonMistakes": [
                                    "Pensar que F inclui todos os estados Q",
                                    "Confundir F com o estado inicial q0",
                                    "Esquecer que F pode ser vazio, tornando o PDA não-aceitador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o critério de aceitação por estado final",
                                  "subSteps": [
                                    "Descrever o processo: uma string w ∈ Σ* é aceita se existe uma sequência de transições que consome toda w e termina em um estado f ∈ F.",
                                    "Enfatizar que o conteúdo da pilha é ignorado na aceitação por F.",
                                    "Simular passo a passo o processamento de uma string curta em um PDA.",
                                    "Comparar com rejeição: se não termina em F após consumir w, rejeita.",
                                    "Formalizar: L(PDA) = {w | (q, α) ∈ δ̂(q0, Z0, w) com q ∈ F, α ∈ Γ*}, onde δ̂ é a transição estendida."
                                  ],
                                  "verification": "O aluno simula corretamente a aceitação de uma string w em um PDA, confirmando término em F.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador JFLAP ou papel para rastreamento manual",
                                    "Exemplo de string: 'ab' para um PDA simples"
                                  ],
                                  "tips": "Rastreie sempre o estado, pilha e posição na entrada simultaneamente.",
                                  "learningObjective": "Entender e aplicar o critério exato de aceitação por estado final em PDAs.",
                                  "commonMistakes": [
                                    "Verificar a pilha vazia em vez de estado F",
                                    "Parar antes de consumir toda a entrada",
                                    "Confundir aceitação com loops infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar aceitação por F de aceitação por pilha vazia",
                                  "subSteps": [
                                    "Explicar aceitação por pilha vazia: aceita se pilha estiver vazia após w, ignorando estado.",
                                    "Comparar linguagens: algumas PDAs aceitam a mesma L por F ou pilha vazia, mas nem sempre.",
                                    "Converter um PDA de pilha vazia para F (adicionar estado final após esvaziar pilha).",
                                    "Discutir vantagens: F é mais flexível para certas linguagens context-free.",
                                    "Analisar um exemplo onde diferem, como {a^n b^n | n ≥ 0}."
                                  ],
                                  "verification": "O aluno explica a diferença e converte um PDA simples de um tipo para o outro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dois diagramas de PDA lado a lado",
                                    "Referência teórica sobre linguagens livres de contexto"
                                  ],
                                  "tips": "Aceitação por F é comum em definições padrão de PDAs determinísticos/não-determinísticos.",
                                  "learningObjective": "Distinguir e relacionar os dois métodos de aceitação em PDAs.",
                                  "commonMistakes": [
                                    "Achar que são equivalentes para todas as linguagens",
                                    "Ignorar não-determinismo na conversão",
                                    "Confundir os critérios na simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um PDA não-determinístico que reconhece {ww^R | w ∈ {a,b}*}, palíndromos pares. Estados: q0 (inicial), q1 (empilhando w), q2 (desempilhando w^R), f ∈ F (aceitação). Após processar toda a entrada, se estiver em f (pilha pode ter lixo), aceita; caso contrário, rejeita. Simule 'abba': empilha 'a','b'; desempilha com 'b','a'; termina em f.",
                              "finalVerifications": [
                                "Define corretamente F como subconjunto de Q.",
                                "Explica que aceitação ocorre após consumir toda entrada em estado de F, ignorando pilha.",
                                "Simula aceitação/rejeição de uma string em PDA por F.",
                                "Diferencia aceitação por F de pilha vazia.",
                                "Escreve a definição formal de L(PDA) com F.",
                                "Converte PDA de pilha vazia para F."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de F (100% correto).",
                                "Correção na simulação de processamento de strings (sem erros de transição).",
                                "Clareza na distinção entre critérios de aceitação.",
                                "Capacidade de exemplificar com diagrama ou tabela.",
                                "Compreensão de independência da pilha na aceitação por F.",
                                "Aplicação em exemplos reais de linguagens context-free."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e relações (F ⊆ Q).",
                                "Lógica e Filosofia: Conceitos de 'aceitação' e 'decidibilidade'.",
                                "Engenharia de Software: Parsing em compiladores (estados finitos em analisadores sintáticos).",
                                "Linguística Computacional: Modelagem de gramáticas context-free."
                              ],
                              "realWorldApplication": "Em compiladores, PDAs com aceitação por estado F modelam analisadores sintáticos LL(1) ou LR, verificando se código-fonte válido termina em estado aceitador após parsing, ignorando pilha auxiliar, essencial para linguagens como C++ ou Java."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Montar a tupla formal completa do PDA",
                            "description": "Combinar todos os componentes em (Q, Σ, Γ, δ, q0, Z0, F), reconhecendo-a como a definição formal padrão de um autômato de pilha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os componentes da definição formal do PDA",
                                  "subSteps": [
                                    "Liste os sete componentes da tupla formal: Q (conjunto de estados), Σ (alfabeto de entrada), Γ (alfabeto da pilha), δ (função de transição), q0 (estado inicial), Z0 (símbolo inicial da pilha) e F (conjunto de estados de aceitação).",
                                    "Estude a notação padrão para cada componente, consultando definições em livros ou notas.",
                                    "Anote exemplos simples para cada componente, como Q = {q0, q1, qf} ou Σ = {a, b}.",
                                    "Desenhe um diagrama esquemático mostrando como os componentes se interligam na tupla.",
                                    "Compare com definições de AFAs e AMAs para destacar a adição da pilha (Γ, Z0, δ expandida)."
                                  ],
                                  "verification": "Crie uma tabela com os sete componentes, suas descrições e exemplos; verifique se todos estão corretamente identificados sem erros de nomenclatura.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, livro de Teoria da Computação (ex: Sipser), notas de aula sobre autômatos.",
                                  "tips": "Use mnemônicos como 'Q-Sigma-Gamma-Delta-q0-Z0-F' para memorizar a ordem.",
                                  "learningObjective": "Compreender precisamente o papel e a notação de cada componente na tupla formal do PDA.",
                                  "commonMistakes": "Confundir Σ (entrada) com Γ (pilha); esquecer que δ é uma função de 4 argumentos (estado, entrada, topo da pilha -> estados e strings da pilha)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e especificar cada componente de um PDA exemplo",
                                  "subSteps": [
                                    "Escolha um PDA simples, como o que reconhece {a^n b^n | n ≥ 0}.",
                                    "Defina Q: liste estados como {q0, q1, q2} onde q0 inicial, q2 aceitação.",
                                    "Defina Σ = {a, b}, Γ = {Z0, A} onde Z0 é fundo da pilha e A empilha 'a'.",
                                    "Especifique q0, Z0 e F explicitamente.",
                                    "Descreva δ com pelo menos 3-4 transições exemplo, como δ(q0, a, Z0) = {(q1, A Z0)}."
                                  ],
                                  "verification": "Escreva cada componente isoladamente e confirme que eles formam um PDA válido para o exemplo escolhido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado para diagramas de transição, simulador online de PDA (opcional).",
                                  "tips": "Comece pelo estado inicial e construa transições logicamente para evitar inconsistências.",
                                  "learningObjective": "Extrair e notate corretamente valores concretos para cada componente de uma especificação de PDA.",
                                  "commonMistakes": "Definir δ como relação em vez de função parcial; omitir o fundo da pilha Z0 em Γ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar a tupla formal na ordem correta",
                                  "subSteps": [
                                    "Coloque os componentes na sequência exata: (Q, Σ, Γ, δ, q0, Z0, F).",
                                    "Escreva a tupla completa usando notação de conjunto, como Q = {...}, δ = {((q0,a,Z0),(q1,AZ0)), ...}.",
                                    "Verifique parênteses e vírgulas para precisão formal.",
                                    "Rotule cada posição na tupla para reforçar a ordem.",
                                    " Reescreva a tupla duas vezes para prática de memorização."
                                  ],
                                  "verification": "Compare a tupla montada com um modelo padrão; certifique-se de que não há erros tipográficos ou de ordem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de rascunho, editor de texto para notação formal.",
                                  "tips": "Use cor diferente para cada componente ao montar para visualização clara.",
                                  "learningObjective": "Combinar componentes em uma tupla formal precisa e na ordem padrão.",
                                  "commonMistakes": "Errar a ordem (ex: colocar δ antes de Γ); esquecer parênteses em δ ou usar listas em vez de conjuntos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar a tupla montada",
                                  "subSteps": [
                                    "Simule uma entrada curta (ex: 'ab') na tupla para verificar se aceita corretamente.",
                                    "Cheque se todos os elementos de Q aparecem em δ ou F; valide tipos (δ produz pares (estado, string)).",
                                    "Identifique se q0 ∈ Q, Z0 ∈ Γ, F ⊆ Q.",
                                    "Compare com definições formais de referências para confirmar padronização.",
                                    "Documente qualquer ajuste necessário e refaça a tupla."
                                  ],
                                  "verification": "A tupla simula corretamente pelo menos duas strings (uma aceita, uma rejeitada).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Simulador de PDA ou tabela de transição impressa.",
                                  "tips": "Teste com ε-transições se aplicável, mas foque em casos básicos primeiro.",
                                  "learningObjective": "Reconhecer uma tupla formal completa e válida como definição padrão de PDA.",
                                  "commonMistakes": "Ignorar verificações de consistência, como estados inacessíveis; confundir aceitação por estado vs. pilha vazia."
                                }
                              ],
                              "practicalExample": "Para o PDA que reconhece {a^n b^n | n ≥ 0}: ( {q0, q1, q2}, {a, b}, {Z0, A}, δ onde δ(q0, a, Z0) = {(q1, A Z0)}, δ(q1, a, A) = {(q1, A A)}, δ(q1, b, A) = {(q1, ε)}, δ(q1, ε, Z0) = {(q2, Z0)}, q0, Z0, {q2} ).",
                              "finalVerifications": [
                                "A tupla possui exatamente 7 componentes na ordem (Q, Σ, Γ, δ, q0, Z0, F).",
                                "q0 pertence a Q e F é subconjunto de Q.",
                                "Z0 pertence a Γ.",
                                "δ é definida como função parcial de Q × (Σ ∪ {ε}) × Γ para potências finitas de Γ × Q.",
                                "Todos os estados em Q são referenciados em δ ou F.",
                                "Notação usa conjuntos, parênteses corretos e sem ambiguidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e notação de cada componente (peso 30%).",
                                "Correta ordenação e formatação da tupla formal (peso 25%).",
                                "Consistência lógica e completude dos elementos (peso 20%).",
                                "Capacidade de simular entrada simples na tupla (peso 15%).",
                                "Reconhecimento da tupla como definição padrão de PDA (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Relações (Q, Σ como conjuntos; δ como relação).",
                                "Programação: Estruturas de Dados (pilha como stack em linguagens como Python/C++).",
                                "Lógica: Máquinas de Turing e formalismos computacionais.",
                                "Linguística Computacional: Parsing de gramáticas context-free."
                              ],
                              "realWorldApplication": "Em compiladores, PDAs são usados em parsers bottom-up (ex: LR parsers no GCC) para analisar sintaxe de linguagens de programação, validando estruturas aninhadas como blocos if-else ou expressões balanceadas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1",
                              "10.1.5.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Configurações e Transições em Autômatos de Pilha",
                    "description": "Conceito de configuração instantânea, pilha e regras de transição com empilhamento e desempilhamento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Configuração Instantânea",
                        "description": "Uma configuração instantânea em um autômato de pilha (AP) é um triplo (q, w, γ), onde q é o estado atual, w é a suffix da fita de entrada ainda não lida (com ε para fita vazia), e γ é o conteúdo da pilha, lido do topo para o fundo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Identificar componentes de uma configuração instantânea",
                            "description": "Dado um exemplo de configuração (q, w, γ), identificar e descrever cada componente: estado q, entrada restante w e pilha γ, incluindo casos especiais como pilha vazia (Z0 ou ε).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a notação e definição de configuração instantânea",
                                  "subSteps": [
                                    "Leia a definição formal: uma configuração instantânea é uma tripla (q, w, γ), onde q é o estado atual, w é a string de entrada restante e γ é o conteúdo da pilha (do topo ao fundo).",
                                    "Identifique os símbolos: q ∈ Q (conjunto de estados), w ∈ Σ* (alfabeto de entrada), γ ∈ Γ* (alfabeto da pilha).",
                                    "Estude representações: pilha vazia como Z0 (símbolo bottom-of-stack) ou ε.",
                                    "Anote exemplos simples de cada componente isolado.",
                                    "Compare com configurações iniciais (qi, w0, Z0) e finais (qf, ε, γ')."
                                  ],
                                  "verification": "Escreva uma definição própria da tripla e liste os três componentes com suas descrições em suas palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro ou slides sobre autômatos de pilha",
                                    "Folha de anotações",
                                    "Exemplos de configurações básicas"
                                  ],
                                  "tips": [
                                    "Use cores diferentes para destacar q, w e γ em exemplos escritos.",
                                    "Lembre-se: a ordem da tripla é sempre (estado, entrada, pilha)."
                                  ],
                                  "learningObjective": "Dominar a estrutura formal da configuração instantânea (q, w, γ).",
                                  "commonMistakes": [
                                    "Confundir γ com a entrada w.",
                                    "Esquecer que γ é lida do topo ao fundo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e descrever o componente estado q",
                                  "subSteps": [
                                    "Localize q na tripla: é sempre o primeiro elemento, um símbolo de estado como q0, q1, q_rejeita.",
                                    "Descreva seu papel: indica o estado atual do controle do autômato.",
                                    "Diferencie estados iniciais (qi), finais (qf) e intermediários.",
                                    "Pratique extraindo q de 3 configurações exemplo: (q1, ab, Z0A) → q = q1.",
                                    "Explique como q muda em transições: δ(q, a, X) = (p, α)."
                                  ],
                                  "verification": "Para 3 configurações dadas, isole e descreva corretamente o q em cada uma.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de 5 configurações exemplo",
                                    "Diagrama de autômato de pilha simples"
                                  ],
                                  "tips": [
                                    "q nunca contém símbolos de entrada ou pilha; é sempre um identificador de estado."
                                  ],
                                  "learningObjective": "Reconhecer e explicar precisamente o papel do estado q.",
                                  "commonMistakes": [
                                    "Interpretar q como parte da entrada.",
                                    "Confundir q com símbolos da pilha."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e descrever a entrada restante w",
                                  "subSteps": [
                                    "Localize w: segundo elemento da tripla, uma string em Σ* como 'aab' ou ε (vazia).",
                                    "Descreva seu significado: símbolos ainda não consumidos pela cabeça de leitura.",
                                    "Identifique casos: w = ε indica que toda entrada foi processada.",
                                    "Pratique: Em (q2, bc, Z0BB), w = 'bc' (restante da entrada original).",
                                    "Relacione com transições: em cada passo, o primeiro símbolo de w é lido."
                                  ],
                                  "verification": "Extraia w de 4 exemplos variados, incluindo w=ε, e explique o que significa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos com entradas longas e curtas",
                                    "Simulador de PDA online (opcional)"
                                  ],
                                  "tips": [
                                    "w é consumida da esquerda para a direita; nunca altere sua ordem manualmente."
                                  ],
                                  "learningObjective": "Identificar w e seu papel dinâmico no processamento.",
                                  "commonMistakes": [
                                    "Confundir w com a pilha γ.",
                                    "Pensar que w inclui símbolos já processados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e descrever a pilha γ, incluindo casos especiais",
                                  "subSteps": [
                                    "Localize γ: terceiro elemento, string em Γ* como 'Z0AB' (topo à esquerda).",
                                    "Descreva convenções: topo da pilha é o primeiro símbolo; Z0 é bottom-of-stack.",
                                    "Casos especiais: γ = Z0 ou ε (pilha vazia, mas geralmente Z0 permanece).",
                                    "Pratique: Em (q3, ε, Z0), γ = Z0 (pilha com apenas bottom).",
                                    "Explique pop/push: transições modificam γ removendo/adicionando no topo."
                                  ],
                                  "verification": "Descreva γ completamente em 3 exemplos, notando topo, casos vazios e Z0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos com pilhas complexas",
                                    "Vídeo curto sobre operações de pilha"
                                  ],
                                  "tips": [
                                    "Sempre escreva γ com topo à esquerda: pop remove o primeiro símbolo."
                                  ],
                                  "learningObjective": "Mestre a representação e casos especiais da pilha γ.",
                                  "commonMistakes": [
                                    "Ler pilha da direita para a esquerda.",
                                    "Ignorar Z0 em pilhas vazias."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar identificação completa de configurações",
                                  "subSteps": [
                                    "Pegue uma configuração completa: isole q, w, γ.",
                                    "Descreva cada um em uma frase.",
                                    "Identifique se é inicial, intermediária ou final.",
                                    "Resolva 5 exercícios mistos.",
                                    "Compare sua análise com soluções modelo."
                                  ],
                                  "verification": "Analise corretamente 5 configurações variadas sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de exercícios com 10 configurações",
                                    "Chave de respostas"
                                  ],
                                  "tips": [
                                    "Verifique a tripla: 1º=q, 2º=w, 3º=γ."
                                  ],
                                  "learningObjective": "Integrar todos os componentes em análises fluidas.",
                                  "commonMistakes": [
                                    "Pular casos especiais como ε ou Z0."
                                  ]
                                }
                              ],
                              "practicalExample": "Dada a configuração (q1, abcd, Z0AA): q1 é o estado atual (intermediário); abcd é a entrada restante a processar (cabeça em 'a'); Z0AA é a pilha com topo 'A', depois 'A', e Z0 no fundo (pronto para pop de 'A').",
                              "finalVerifications": [
                                "Identificar corretamente q, w e γ em 90% dos exemplos dados.",
                                "Descrever casos especiais (w=ε, γ=Z0) sem erros.",
                                "Explicar o papel dinâmico de cada componente em uma transição.",
                                "Analisar uma configuração inicial, intermediária e final.",
                                "Diferenciar notações Z0 vs ε para pilha vazia.",
                                "Montar uma tripla a partir de descrições isoladas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de cada componente (100% correto).",
                                "Descrições claras e completas, incluindo papéis funcionais.",
                                "Tratamento correto de casos especiais (ε, Z0).",
                                "Uso consistente da notação (topo da pilha à esquerda).",
                                "Capacidade de relacionar componentes a transições.",
                                "Análise integrada sem confusões entre componentes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reconhecimento de tuplas ordenadas e strings formais.",
                                "Lógica: Estados como nós em grafos de transição.",
                                "Programação: Pilhas em linguagens como Python (stack data structure).",
                                "Engenharia de Software: Máquinas de estado em parsers e compiladores.",
                                "Física: Modelos de sistemas dinâmicos com pilhas de estados."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens de programação (ex: parsers LL/LR usam PDAs para sintaxe), configurações instantâneas rastreiam o estado de parsing, entrada não processada e pilha de contexto para validar código-fonte em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Representar configuração inicial e de aceitação",
                            "description": "Definir e representar a configuração inicial (q0, w, Z0) e configurações de aceitação por estado final ou pilha vazia, distinguindo entre aceitação por estado final ou por pilha vazia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes da configuração instantânea em Autômatos de Pilha",
                                  "subSteps": [
                                    "Revise a definição de configuração instantânea como uma tripla (q, w, γ), onde q é o estado atual, w é a string restante de entrada e γ é o conteúdo da pilha.",
                                    "Identifique q0 como o estado inicial, w como a string de entrada completa e Z0 como o símbolo inicial da pilha.",
                                    "Estude exemplos de configurações em diagramas de PDA para visualizar transições.",
                                    "Anote as diferenças entre configuração inicial e configurações intermediárias.",
                                    "Pratique identificando componentes em um PDA simples fornecido."
                                  ],
                                  "verification": "Liste corretamente os três componentes de uma configuração instantânea dada e identifique q0, w inicial e Z0 em um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Teoria da Computação, slides sobre PDA, quadro branco para diagramas.",
                                  "tips": "Use setas para representar transições e destaque q0 com uma seta inicial.",
                                  "learningObjective": "Dominar a estrutura tripla da configuração instantânea e seus papéis específicos.",
                                  "commonMistakes": "Confundir w (entrada restante) com a entrada total; esquecer Z0 na pilha inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar a configuração inicial (q0, w, Z0)",
                                  "subSteps": [
                                    "Escreva a configuração inicial explicitamente: (q0, w, Z0), onde w é a entrada completa.",
                                    "Desenhe um diagrama visual com estado q0, fita com w e pilha com Z0 no topo.",
                                    "Pratique com entradas variadas, como w = 'ab' e Z0 = '$'.",
                                    "Verifique se a representação segue a notação padrão sem ambiguidades.",
                                    "Compare sua representação com exemplos de livros ou aulas."
                                  ],
                                  "verification": "Crie e explique a configuração inicial para um PDA com w = 'aabb' e Z0 = '⊥'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta para diagramas, simulador online de PDA (ex: JFLAP).",
                                  "tips": "Sempre inclua parênteses e vírgulas para clareza: (q0, aabb, ⊥).",
                                  "learningObjective": "Representar com precisão a configuração inicial usando notação padrão.",
                                  "commonMistakes": "Escrever w como string vazia inicialmente; omitir Z0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e representar configurações de aceitação",
                                  "subSteps": [
                                    "Aprenda aceitação por estado final: configuração (qf, ε, γ) onde qf é estado final e ε é entrada esgotada.",
                                    "Aprenda aceitação por pilha vazia: configuração (q, ε, ε) onde pilha está vazia após esgotar entrada.",
                                    "Represente ambas em notação: destaque qf ou pilha vazia.",
                                    "Diferencie: estado final foca em qf, pilha vazia em γ = ε.",
                                    "Exercite convertendo PDA de um tipo para o outro."
                                  ],
                                  "verification": "Dada uma configuração final, classifique como aceitação por estado ou pilha vazia e justifique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de PDAs de aula, ferramenta JFLAP para simulação.",
                                  "tips": "Use ε para string/pilha vazia e sublinhe estados finais.",
                                  "learningObjective": "Distinguir e representar corretamente os dois tipos de aceitação.",
                                  "commonMistakes": "Confundir ε na entrada com ε na pilha; ignorar requisito de entrada esgotada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar distinção e representação completa de configurações",
                                  "subSteps": [
                                    "Simule um PDA completo desde inicial até aceitação, registrando configurações chave.",
                                    "Crie representações para PDAs que aceitam por estado final e por pilha vazia.",
                                    "Compare representações lado a lado para um mesmo idioma.",
                                    "Resolva exercícios: identifique se PDA aceita por qual método e desenhe configs.",
                                    "Autoavalie com pares ou professor."
                                  ],
                                  "verification": "Simule um PDA para w='aba' e forneça configs inicial e final corretas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "JFLAP ou simulador PDA, exercícios impressos.",
                                  "tips": "Rastreie configs em tabela: coluna para step, q, w, γ.",
                                  "learningObjective": "Integrar conhecimentos para representar e distinguir configs em contextos reais.",
                                  "commonMistakes": "Não esgotar entrada antes de checar aceitação; erros de notação."
                                }
                              ],
                              "practicalExample": "Para um PDA que reconhece { ww^R | w em {a,b}* } por pilha vazia: Config inicial: (q0, ww^R, ⊥). Após processamento, config final: (q1, ε, ε) – pilha vazia confirma aceitação.",
                              "finalVerifications": [
                                "Configuração inicial corretamente notada como (q0, w completa, Z0).",
                                "Config de aceitação por estado final: q em F e w=ε.",
                                "Config de aceitação por pilha vazia: pilha=ε e w=ε.",
                                "Distinção clara entre os dois métodos de aceitação.",
                                "Representações visuais/diagramas precisos sem ambiguidades.",
                                "Simulação completa de pelo menos um PDA com configs chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação tripla (q, w, γ): 25%.",
                                "Correta identificação de componentes iniciais (q0, w, Z0): 20%.",
                                "Domínio de aceitação por estado final vs. pilha vazia: 25%.",
                                "Qualidade de diagramas e exemplos práticos: 15%.",
                                "Capacidade de simular transições e configs: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Relações e funções em estados/transições.",
                                "Lógica: Condições booleanas para aceitação (qf ou pilha vazia).",
                                "Programação: Pilhas em linguagens como Python (stack data structure).",
                                "Linguagens Formais: Conexão com gramáticas e parsing."
                              ],
                              "realWorldApplication": "Em compiladores, PDAs modelam parsing de linguagens de programação, onde configurações iniciais definem entrada fonte e aceitação por pilha vazia valida sintaxe balanceada como chaves {}."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Diferenciar configurações paradas",
                            "description": "Reconhecer configurações paradas quando não há transição possível: sem símbolo de entrada ou topo da pilha compatível com δ a partir do estado atual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Configurações Instantâneas em Autômatos de Pilha",
                                  "subSteps": [
                                    "Defina configuração instantânea como tripla (q, w, γ), onde q é o estado atual, w é a string de entrada restante e γ é o conteúdo da pilha do topo para a base.",
                                    "Explique o papel de cada componente: q determina transições possíveis, w indica input pendente, γ fornece símbolos para pop/push.",
                                    "Diferencie pilha (LIFO) de fita de input (sequencial).",
                                    "Forneça um exemplo simples: (q0, 'ab', 'Z0') em PDA para linguagem de parênteses."
                                  ],
                                  "verification": "Descreva corretamente os três componentes de uma configuração instantânea com um exemplo próprio.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama formal de PDA",
                                    "Notas sobre notação de PDA (δ: Q × (Σ ∪ {ε}) × Γ → 2^{Q × Γ*} )"
                                  ],
                                  "tips": "Sempre escreva a configuração na ordem (estado, input restante, pilha com topo à esquerda).",
                                  "learningObjective": "Compreender a estrutura exata de uma configuração instantânea em PDA.",
                                  "commonMistakes": [
                                    "Confundir ordem da pilha (topo vs. base)",
                                    "Ignorar ε em input ou pilha",
                                    "Esquecer que w pode ser ε"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Transições e Função de Transição δ",
                                  "subSteps": [
                                    "Descreva δ(q, a, X) = conjunto de (p, γ'), onde a ∈ Σ ∪ {ε}, X topo da pilha ∈ Γ.",
                                    "Explique aplicação: consuma a do input (ou ε), pop X, push γ', vá para p.",
                                    "Identifique quando transição é possível: existe regra δ compatível com estado atual, próximo input/topo pilha.",
                                    "Pratique com exemplo: δ(q0, '(', Z0) = {(q1, '(Z0')} em PDA de parênteses."
                                  ],
                                  "verification": "Aplique δ corretamente em uma configuração dada e liste sucessoras possíveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de transição de um PDA exemplo",
                                    "Simulador online de PDA (ex: JFLAP)"
                                  ],
                                  "tips": "Verifique sempre compatibilidade exata: símbolo input, topo pilha e estado atual.",
                                  "learningObjective": "Dominar como transições alteram configurações em PDA.",
                                  "commonMistakes": [
                                    "Aplicar δ sem matching exato de input/topo",
                                    "Confundir push/pop com substituição simples",
                                    "Ignorar múltiplas transições possíveis (nondeterminismo)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Condições para Configurações Paradas",
                                  "subSteps": [
                                    "Defina configuração parada: nenhuma transição δ aplicável a partir de (q, w, γ).",
                                    "Caso 1: w = ε e sem δ(q, ε, topo(γ)).",
                                    "Caso 2: w ≠ ε, mas sem δ(q, primeiro(w), topo(γ)).",
                                    "Confirme: se pilha vazia ou estado sem regras, é parada.",
                                    "Diferencie de rejeição: parada indica fim de computação sem aceitação/loop."
                                  ],
                                  "verification": "Classifique 3 configurações como paradas ou não, justificando com δ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de 5 configurações exemplo com δ parcial",
                                    "Folha de exercícios sobre δ"
                                  ],
                                  "tips": "Sempre cheque input restante E topo pilha juntos para δ.",
                                  "learningObjective": "Reconhecer precisamente as condições de ausência de transições.",
                                  "commonMistakes": [
                                    "Considerar só input vazio como parada",
                                    "Esquecer ε-transições quando w=ε",
                                    "Confundir parada com aceitação (depende de estado final)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Diferenciação de Configurações Paradas",
                                  "subSteps": [
                                    "Analise PDA exemplo (palíndromos ou {a^n b^n}): trace configs até parada.",
                                    "Identifique configs paradas em traces: marque sem sucessoras.",
                                    "Compare com configs ativas: liste δ possível vs. impossível.",
                                    "Crie sua própria config parada/não parada e valide.",
                                    "Avalie em cenários nondeterminísticos: escolha branches sem moves."
                                  ],
                                  "verification": "Em um trace de PDA, identifique todas configs paradas corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de traces de PDA (imagens ou texto)",
                                    "Ferramenta JFLAP para simulação stepwise"
                                  ],
                                  "tips": "Simule passo a passo: anote configs sucessoras ou 'parada' em árvore.",
                                  "learningObjective": "Diferenciar fluentemente configs paradas de ativas em contextos reais.",
                                  "commonMistakes": [
                                    "Parar prematuramente em loops ε",
                                    "Ignorar nondet: cheque todas branches",
                                    "Confundir pilha vazia com input vazio"
                                  ]
                                }
                              ],
                              "practicalExample": "Em PDA para {a^n b^n | n≥0}: Configuração inicial (q0, aabb, Z0). Transição possível. Após processar 'aabb': (qf, ε, Z0). Se δ(qf, ε, Z0)=∅, é parada (aceitação se qf final). Contraexemplo não parada: (q0, a, Z0) com δ existente.",
                              "finalVerifications": [
                                "Explicar definição de config parada sem erros.",
                                "Classificar 80% de configs exemplo corretamente.",
                                "Trace um PDA até config parada.",
                                "Diferenciar parada de aceitação/rejeição.",
                                "Identificar por que uma config específica é parada.",
                                "Listar condições exatas para ausência de δ.",
                                "Aplicar em PDA nondet com >1 branch."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de paradas (>90%).",
                                "Justificativa completa com referência a δ (>80% casos).",
                                "Uso correto de notação de config (100%).",
                                "Diferenciação clara de casos edge (ε-input, pilha vazia).",
                                "Explicações concisas e lógicas.",
                                "Tratamento de nondeterminismo sem confusão.",
                                "Velocidade: <5min por análise complexa."
                              ],
                              "crossCurricularConnections": [
                                "Lógica proposicional: condições booleanas para δ aplicável.",
                                "Algoritmos: detecção de estados terminais em grafos.",
                                "Programação: validação de parsers stack-based (ex: JSON).",
                                "Matemática discreta: relações finitas e funções parciais.",
                                "Engenharia de software: análise de deadlock em stacks."
                              ],
                              "realWorldApplication": "Em compiladores (parsers LL/LR), detectar fim de input sem erros de pilha pendente; validação de expressões balanceadas em editores de código; simulações de chamadas recursivas em debuggers para evitar stack overflow sem saída."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Estrutura e Operações na Pilha",
                        "description": "A pilha em um AP é uma estrutura LIFO (Last In, First Out) que armazena uma sequência finita de símbolos do alfabeto da pilha Γ, com um símbolo inicial Z0 no fundo, permitindo operações de empilhamento (push), desempilhamento (pop) e inspeção do topo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Descrever operações básicas na pilha",
                            "description": "Explicar push (empilhar string γ), pop (remover topo X substituindo por ε) e peek (inspecionar topo sem remover), usando notação como γX → γ para pop.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura e representação da pilha",
                                  "subSteps": [
                                    "Estude a convenção de notação da pilha, onde o topo está à direita (ex: γX significa γ no fundo e X no topo).",
                                    "Identifique o símbolo ε como representando a pilha vazia.",
                                    "Pratique desenhando pilhas vazias e com símbolos únicos.",
                                    "Diferencie pilha de fita ou lista simples, enfatizando LIFO (Last In, First Out).",
                                    "Revise exemplos de configurações iniciais em autômatos de pilha."
                                  ],
                                  "verification": "Desenhe 3 configurações de pilha diferentes e explique cada uma oralmente ou por escrito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de pilha impresso ou digital"
                                  ],
                                  "tips": "Sempre escreva o topo à direita para evitar confusão.",
                                  "learningObjective": "Representar corretamente qualquer configuração de pilha usando notação padrão.",
                                  "commonMistakes": [
                                    "Confundir topo com fundo da pilha",
                                    "Esquecer de usar ε para vazio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a operação PUSH (empilhar)",
                                  "subSteps": [
                                    "Defina PUSH: adicionar um símbolo γ ao topo da pilha atual.",
                                    "Exemplo: pilha γ → γγ após PUSH(γ).",
                                    "Simule PUSH em pilha vazia: ε → γ.",
                                    "Pratique com múltiplos PUSH: ε → A → AB.",
                                    "Relacione com transição de autômato: (estado, entrada, topo) → novo estado, PUSH."
                                  ],
                                  "verification": "Simule 5 sequências de PUSH e verifique se a notação final está correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de pilha online (ex: JFLAP)",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Pense no PUSH como 'colocar em cima', mantendo o ordem LIFO.",
                                  "learningObjective": "Descrever e simular PUSH com notação precisa em qualquer configuração.",
                                  "commonMistakes": [
                                    "Adicionar ao fundo em vez do topo",
                                    "Não atualizar a notação corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar a operação POP (desempilhar)",
                                  "subSteps": [
                                    "Defina POP: remover o topo X, substituindo por ε no topo (ex: γX → γ).",
                                    "Simule POP em pilha com um símbolo: A → ε.",
                                    "Pratique sequências: AB → A (pop B) → ε (pop A).",
                                    "Integre com transições: inspecionar topo X e aplicar POP se matching.",
                                    "Compare com PUSH para entender equilíbrio."
                                  ],
                                  "verification": "Resolva 4 exercícios de POP, comparando antes/depois.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JFLAP ou papel",
                                    "Exemplos de transições PDA"
                                  ],
                                  "tips": "POP só ocorre se pilha não vazia; verifique topo antes.",
                                  "learningObjective": "Executar e notate POP corretamente em simulações.",
                                  "commonMistakes": [
                                    "Remover do fundo",
                                    "Deixar resíduo no topo após POP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar a operação PEEK (espiar topo)",
                                  "subSteps": [
                                    "Defina PEEK: inspecionar topo sem remover (ex: γX → γX, lê X).",
                                    "Diferencie de POP: nenhuma mudança na pilha.",
                                    "Simule em transições: usar topo para decidir próximo passo sem alterar.",
                                    "Pratique: em AB, PEEK retorna B, pilha permanece AB.",
                                    "Combine com PUSH/POP em fluxos condicionais."
                                  ],
                                  "verification": "Descreva 3 cenários onde PEEK é usado sem alteração na pilha.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para diagramas",
                                    "Vídeo tutorial sobre PDA"
                                  ],
                                  "tips": "PEEK é 'olhar sem tocar'; ideal para condições em autômatos.",
                                  "learningObjective": "Explicar uso de PEEK em decisões de transição.",
                                  "commonMistakes": [
                                    "Confundir com POP",
                                    "Alterar pilha acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar operações em descrições de transições",
                                  "subSteps": [
                                    "Escreva regras de transição usando notação: δ(q, a, X) = (p, αγ) para PUSH γ após POP X.",
                                    "Simule sequência completa: PUSH A, PEEK A, POP.",
                                    "Crie exemplos para linguagens como {a^n b^n}.",
                                    "Descreva verbalmente uma transição com todas operações.",
                                    "Revise erros comuns em notação formal."
                                  ],
                                  "verification": "Escreva 2 transições completas e valide com diagrama.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "JFLAP para simulação",
                                    "Folha de fórmulas PDA"
                                  ],
                                  "tips": "Sempre especifique entrada, topo e ação na pilha.",
                                  "learningObjective": "Descrever operações básicas em contexto de autômatos de pilha.",
                                  "commonMistakes": [
                                    "Notação inconsistente",
                                    "Omitir ε ou topo"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um autômato de pilha para {a^n b^n}: Inicie com pilha ε. Para cada 'a', PUSH(A). Para 'b', PEEK(A) → POP. Aceita se pilha ε no fim. Exemplo: 'aabbb' → PUSH A (A), PUSH A (AA), PEEK A→POP (A), PEEK A→POP (ε), erro no extra b.",
                              "finalVerifications": [
                                "Descreva notação γX → γ para POP.",
                                "Simule PUSH γ em ε → γγ? Corrija se errado.",
                                "Explique diferença PEEK vs POP com exemplo.",
                                "Escreva transição δ(q0, a, ε) = (q1, A).",
                                "Identifique erro em pilha AB → A (POP correto?).",
                                "Descreva pilha após PUSH B, POP em BA."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação de pilha (topo à direita, ε correto).",
                                "Clareza na distinção entre PUSH, POP e PEEK.",
                                "Capacidade de simular sequências sem erros LIFO.",
                                "Uso correto em transições de PDA.",
                                "Explicações verbais concisas e sem ambiguidades.",
                                "Identificação de erros comuns em simulações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas algébricas e mônoides (pilha como semigrupo).",
                                "Programação: Implementação de Stack em linguagens como Python ou C++.",
                                "Lógica: Autômatos finitos vs. com memória (pilha como memória finita).",
                                "Engenharia de Software: Pilhas em parsing de expressões.",
                                "Física: Modelos de pilhas em sistemas de partículas ou buffers."
                              ],
                              "realWorldApplication": "Em compiladores, pilhas gerenciam chamadas de funções e parsing de sintaxe (ex: undo no Word, navegação browser back)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Representar mudanças no conteúdo da pilha",
                            "description": "Dado γ (conteúdo atual) e uma operação de transição que substitui topo X por α, calcular o novo conteúdo da pilha α seguido do resto de γ sem X.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a representação da pilha atual γ",
                                  "subSteps": [
                                    "Escreva a string γ com o topo à direita (ex: γ = abcA significa A é o topo).",
                                    "Identifique o comprimento de γ e seus símbolos individuais.",
                                    "Confirme a convenção: pilha cresce à direita, topo é o último símbolo.",
                                    "Desenhe a pilha visualmente como uma torre para reforçar a compreensão.",
                                    "Anote o 'resto' β como γ sem o último símbolo."
                                  ],
                                  "verification": "Pode decompor γ em β (resto) e X (topo) corretamente em pelo menos 3 exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, quadro branco ou editor de texto simples.",
                                  "tips": "Sempre leia γ da esquerda para a direita, com topo no final.",
                                  "learningObjective": "Compreender a notação padrão de pilha em autômatos.",
                                  "commonMistakes": "Confundir topo com o primeiro símbolo (esquerda); lembrar que topo é direita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o topo X e a operação de transição",
                                  "subSteps": [
                                    "Extraia X como o último símbolo de γ.",
                                    "Leia a operação: 'substituir topo X por α' (α é uma string, possivelmente vazia ou múltiplos símbolos).",
                                    "Verifique se o topo atual é exatamente X (correspondência exata).",
                                    "Registre α explicitamente, separando seus símbolos se necessário.",
                                    "Confirme que a transição só se aplica se topo == X."
                                  ],
                                  "verification": "Liste X e α corretamente para uma transição dada, sem erros de extração.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplos de transições impressos ou em PDF de teoria de autômatos.",
                                  "tips": "Use setas para mostrar: γ → X (topo) → α (substituição).",
                                  "learningObjective": "Reconhecer condições de transição na pilha.",
                                  "commonMistakes": "Ignorar que α pode ter comprimento >1; assumir pop simples."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o novo conteúdo da pilha",
                                  "subSteps": [
                                    "Remova X do final de γ para obter β (resto da pilha).",
                                    "Anexe α ao final de β para formar novo γ' = β α.",
                                    "Se α vazio, novo γ' = β (pop efetivo).",
                                    "Se α tem múltiplos símbolos, escreva-os na ordem correta (topo à direita).",
                                    "Valide o comprimento: novo = |γ| -1 + |α|."
                                  ],
                                  "verification": "Compute γ' manualmente e compare com simulação passo a passo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Simulador online de autômato de pilha ou planilha para tracking.",
                                  "tips": "Pense como concatenação de strings: γ' = γ[1..n-1] + α.",
                                  "learningObjective": "Executar a operação de substituição na pilha.",
                                  "commonMistakes": "Inserir α no lugar errado (ex: no início); esquecer ordem dos símbolos em α."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e representar a mudança",
                                  "subSteps": [
                                    "Escreva a transição: γ ⊢ β α.",
                                    "Desenhe pilha antes/depois para visualização.",
                                    "Teste com input de exemplo: aplique múltiplas transições sequenciais.",
                                    "Confirme novo topo de γ'.",
                                    "Documente em formato padrão para relatórios."
                                  ],
                                  "verification": "Gere representação correta para 5 sequências de transições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta de desenho como Draw.io ou papel para diagramas.",
                                  "tips": "Use notação ⊢ para transições: γ ⊢ γ'.",
                                  "learningObjective": "Documentar mudanças de forma padronizada.",
                                  "commonMistakes": "Não atualizar topo corretamente em α longo."
                                }
                              ],
                              "practicalExample": "Dado γ = abA (topo A), transição: substituir A por BC. Novo γ' = abBC (topo C, pilha: a b B C).",
                              "finalVerifications": [
                                "Decompor corretamente γ em β e X em 90% dos casos.",
                                "Aplicar substituição produzindo γ' exata.",
                                "Lidar com α vazia (pop) e |α|>1 (push múltiplo).",
                                "Representar diagrama antes/depois sem erros.",
                                "Simular 3 transições em sequência corretamente.",
                                "Verificar comprimento: |γ'| = |γ| -1 + |α|."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de topo X (100% match).",
                                "Correção na concatenação β + α.",
                                "Tratamento de casos especiais (α=ε, |α|>1).",
                                "Clareza na representação escrita e visual.",
                                "Eficiência em sequências múltiplas.",
                                "Ausência de erros comuns como inversão de ordem."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação de strings e concatenação.",
                                "Lógica: Condições de transição como predicados booleanos.",
                                "Programação: Estruturas de pilha em linguagens como Python (list.pop() + extend()).",
                                "Linguagens Formais: Relação com gramáticas e parsing."
                              ],
                              "realWorldApplication": "Em compiladores, representar pilha de parsing para validar expressões aninhadas como {[( )]}; em editores de texto para undo/redo (pilha de estados)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Identificar pilha vazia e símbolo inicial",
                            "description": "Reconhecer quando a pilha está vazia (apenas Z0 removido ou ε) e o papel do símbolo inicial Z0 que nunca é removido em definições padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Pilha em Autômatos de Pilha",
                                  "subSteps": [
                                    "Revise a estrutura básica de uma pilha: topo e fundo, com operações push e pop.",
                                    "Identifique que a pilha inicia com o símbolo inicial Z0 no fundo.",
                                    "Entenda que Z0 marca o fundo da pilha e nunca é removido em definições padrão.",
                                    "Diferencie pilha vazia (apenas Z0 removido ou representada por ε) de pilha com Z0 presente.",
                                    "Desenhe um diagrama simples de pilha inicial com Z0."
                                  ],
                                  "verification": "Desenhe e rotule corretamente uma pilha inicial e uma vazia.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, quadro branco ou software de desenho como Draw.io.",
                                  "tips": "Sempre represente Z0 no fundo para evitar confusão com pilha realmente vazia.",
                                  "learningObjective": "Explicar a função do Z0 como marcador de fundo da pilha.",
                                  "commonMistakes": "Confundir Z0 com um símbolo popável; lembrar que Z0 é permanente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer Estados de Pilha Vazia",
                                  "subSteps": [
                                    "Estude a notação: pilha vazia é quando apenas Z0 foi 'removido' ou denotada por ε.",
                                    "Analise configurações de autômato: (q, w, Z0 γ) onde γ é a string na pilha acima de Z0.",
                                    "Identifique aceitação por pilha vazia: pilha retorna a apenas Z0 ou ε após processamento.",
                                    "Compare com aceitação por estado final: foco na pilha, não no estado.",
                                    "Pratique notação: escreva configurações antes/depois de transições que esvaziam a pilha."
                                  ],
                                  "verification": "Classifique 3 configurações como 'pilha vazia' ou 'não vazia' com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de configurações de autômatos de pilha impressos ou digitais.",
                                  "tips": "Use ε para pilha vazia em diagramas para clareza visual.",
                                  "learningObjective": "Distinguir pilha vazia (ε ou só Z0 removido) de pilha com conteúdo.",
                                  "commonMistakes": "Achar que pilha com Z0 é vazia; Z0 indica não-vazia inicialmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Papel do Símbolo Inicial Z0",
                                  "subSteps": [
                                    "Explique por que Z0 nunca é popado: previne pop em pilha vazia real.",
                                    "Trace transições: pop só ocorre se topo ≠ Z0.",
                                    "Simule uma transição que tenta pop em Z0: transição não existe ou falha.",
                                    "Compare definições padrão vs. variantes sem Z0 (endmarkers alternativos).",
                                    "Documente regras de transição envolvendo Z0 em pseudocódigo."
                                  ],
                                  "verification": "Simule 2 transições mostrando que Z0 bloqueia pop indevido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela de transições de um autômato de pilha exemplo.",
                                  "tips": "Pense em Z0 como 'parede de fundo' da pilha.",
                                  "learningObjective": "Demonstrar como Z0 garante integridade da pilha.",
                                  "commonMistakes": "Permitir pop de Z0; regras padrão proíbem isso explicitamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Exemplos Completos",
                                  "subSteps": [
                                    "Escolha um autômato para {a^n b^n}: trace entrada 'aabbb' até aceitação por pilha vazia.",
                                    "Identifique momento exato da pilha vazia: após último pop de b.",
                                    "Varie entradas: valide aceitação/rejeição baseada em pilha.",
                                    "Crie seu próprio exemplo simples e marque pilha vazia.",
                                    "Resuma diferenças entre pilha inicial (Z0) e vazia (ε)."
                                  ],
                                  "verification": "Trace um autômato completo e aponte configuração de pilha vazia.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Autômato de pilha exemplo para palíndromos ou {a^n b^n}.",
                                  "tips": "Simule passo a passo em tabela para visualizar mudanças na pilha.",
                                  "learningObjective": "Aplicar conceitos em simulações reais de autômatos.",
                                  "commonMistakes": "Ignorar Z0 na contagem inicial; sempre inclua no fundo."
                                }
                              ],
                              "practicalExample": "Em um PDA para {a^n b^n | n ≥ 0}, a pilha inicia com Z0. Para 'ab': push A em Z0 (pilha: Z0 A), pop A com b (pilha: Z0), aceita por pilha vazia (considerando Z0 como ε efetivo). Identifique: pilha vazia após pop final, Z0 nunca removido.",
                              "finalVerifications": [
                                "Explicar verbalmente o que significa pilha vazia em PDAs.",
                                "Desenhar pilha inicial vs. vazia corretamente.",
                                "Identificar Z0 em 5 configurações dadas.",
                                "Simular uma transição que falha por tentar pop Z0.",
                                "Diferenciar aceitação por pilha vazia vs. estado final."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre pilha com Z0 e vazia (ε).",
                                "Correta simulação de transições sem pop de Z0.",
                                "Uso consistente de notação padrão (Z0, ε).",
                                "Identificação correta em pelo menos 90% dos exemplos.",
                                "Explicação clara do papel protetor de Z0."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Pilhas como estruturas recursivas em indução.",
                                "Programação: Stacks em linguagens com recursão (ex: parsers LL).",
                                "Lógica: Estados finitos e condições de parada semelhantes a axiomas.",
                                "Física: Modelos de empilhamento em simulações de partículas."
                              ],
                              "realWorldApplication": "Em compiladores, PDAs com pilha vazia validam balanceamento de parênteses em código-fonte, garantindo sintaxe correta sem overflows (Z0 previne pops inválidos, como em editores de texto com undo limitado pela stack base)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Regras de Transição",
                        "description": "A função de transição δ: Q × (Σ ∪ {ε}) × Γ → 2^{Q × Γ*} mapeia (estado atual, símbolo de entrada ou ε, topo da pilha) para um conjunto de pares (novo estado, string a empilhar substituindo o topo).",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Ler e interpretar a função de transição δ",
                            "description": "Dado δ(q, a, X) = {(p, α)}, explicar que consome a (ou ε), remove X do topo e empilha α (pode ser ε para pop, ou string para push múltiplo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os parâmetros de entrada da função de transição δ",
                                  "subSteps": [
                                    "Examine a notação δ(q, a, X), onde q é o estado atual.",
                                    "Identifique a como o símbolo de entrada do alfabeto de entrada (pode ser ε para transição ε).",
                                    "Reconheça X como o símbolo no topo da pilha.",
                                    "Anote os tipos de cada parâmetro: q ∈ Q, a ∈ Σ ∪ {ε}, X ∈ Γ."
                                  ],
                                  "verification": "Liste corretamente os três parâmetros e seus significados em uma tabela.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Diagrama de autômato de pilha, papel e caneta",
                                  "tips": "Sempre comece pela esquerda: estado, entrada, pilha.",
                                  "learningObjective": "Compreender os três argumentos de entrada da função δ.",
                                  "commonMistakes": "Confundir a (entrada) com X (pilha) ou ignorar ε."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o consumo do símbolo de entrada",
                                  "subSteps": [
                                    "Verifique se a é um símbolo do alfabeto Σ ou ε.",
                                    "Se a ∈ Σ, a transição consome um símbolo da fita de entrada.",
                                    "Se a = ε, a transição ocorre sem consumir entrada (movimento espontâneo).",
                                    "Confirme que o cabeçote de leitura avança apenas se a ≠ ε.",
                                    "Descreva o novo posição da entrada após a transição."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que acontece com a fita de entrada para δ(q, a, X).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplo de fita de entrada anotada, quadro branco",
                                  "tips": "Visualize o cabeçote movendo-se à direita após consumir a.",
                                  "learningObjective": "Dominar o impacto da transição no processamento da entrada.",
                                  "commonMistakes": "Assumir sempre consumo de entrada, ignorando transições ε."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a manipulação da pilha pela transição",
                                  "subSteps": [
                                    "Identifique X como o símbolo removido do topo da pilha.",
                                    "Analise α na saída (p, α): α é uma string em Γ* (pode ser ε para pop simples).",
                                    "Se α = ε, apenas remove X (pop).",
                                    "Se |α| > 1, empilha α da direita para esquerda após remover X.",
                                    "Descreva o estado da pilha após a operação."
                                  ],
                                  "verification": "Simule a pilha antes e depois em um desenho.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Pilha simulada com post-its ou software como JFLAP",
                                  "tips": "Lembre: empilhar α significa colocar o último símbolo de α no topo.",
                                  "learningObjective": "Explicar precisamente as operações pop e push na pilha.",
                                  "commonMistakes": "Empilhar α da esquerda para direita ou esquecer de remover X primeiro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a transição completa e resultados",
                                  "subSteps": [
                                    "Combine consumo de entrada, manipulação de pilha e mudança de estado para p.",
                                    "Note que δ retorna um conjunto de pares {(p1, α1), (p2, α2), ...} para não-determinismo.",
                                    "Descreva a configuração resultante: novo estado p, entrada restante, pilha atualizada.",
                                    "Teste com uma configuração inicial exemplo.",
                                    "Explique rejeição se δ(q, a, X) indefinida."
                                  ],
                                  "verification": "Aplique δ a uma configuração completa e descreva o resultado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplos de configurações de AP, calculadora de transições",
                                  "tips": "Pense em δ como uma 'regra de produção' para configurações.",
                                  "learningObjective": "Integrar todos os elementos para interpretar uma transição δ integral.",
                                  "commonMistakes": "Ignorar não-determinismo ou múltiplas saídas."
                                }
                              ],
                              "practicalExample": "Dado δ(q0, a, Z0) = {(q1, Ab)}, em uma configuração (q0, aAb$, Z0Ab$): consome 'a' (fita vira Ab$), remove Z0 do topo, empilha b então A (pilha vira Ab$), vai para q1. Nova configuração: (q1, Ab$, Ab$).",
                              "finalVerifications": [
                                "Explicar corretamente os três parâmetros de entrada de δ.",
                                "Simular consumo de entrada e ε-transições.",
                                "Desenhar pilha antes/depois para pop e push múltiplo.",
                                "Interpretar saídas não-determinísticas.",
                                "Aplicar δ a uma configuração completa sem erros.",
                                "Identificar quando uma transição é indefinida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de q, a, X e seus papéis.",
                                "Correta descrição do avanço na fita de entrada.",
                                "Exatidão na simulação de operações de pilha (pop/push).",
                                "Compreensão de ε e não-determinismo.",
                                "Capacidade de sintetizar configuração resultante.",
                                "Uso de terminologia formal correta."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções parciais e conjuntos (δ como relação).",
                                "Lógica: Não-determinismo similar a ramificações lógicas.",
                                "Programação: Similar a chamadas de pilha em recursão.",
                                "Linguística: Parsing de linguagens formais."
                              ],
                              "realWorldApplication": "Em compiladores, interpretar transições δ simula o analisador sintático pushdown para validar estruturas aninhadas como parênteses em código ou expressões matemáticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1",
                              "10.1.5.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Aplicar uma única transição",
                            "description": "Dada uma configuração (q, wa, γX) e δ(q, a, X) = (p, α), calcular a configuração sucessora (p, w, αγ).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes da configuração inicial",
                                  "subSteps": [
                                    "Leia a configuração dada no formato (q, wa, γX)",
                                    "Extraia o estado atual q",
                                    "Separe wa em w (resto da fita) e a (símbolo de entrada atual)",
                                    "Identifique γ (parte inferior da pilha) e X (topo da pilha)",
                                    "Anote todos os componentes claramente"
                                  ],
                                  "verification": "Confirme que q, w, a, γ e X foram extraídos corretamente escrevendo-os separadamente",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama do autômato de pilha"
                                  ],
                                  "tips": [
                                    "Sempre escreva a configuração de forma explícita para evitar confusões",
                                    "Lembre-se: pilha tem topo à direita (X é o topo)"
                                  ],
                                  "learningObjective": "Extrair com precisão os elementos chave da configuração inicial de um autômato de pilha",
                                  "commonMistakes": [
                                    "Confundir a ordem da pilha (topo à esquerda)",
                                    "Misturar w e a na fita de entrada",
                                    "Ignorar γ como parte fixa da pilha"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar e aplicar a regra de transição",
                                  "subSteps": [
                                    "Consulte a função de transição δ do autômato",
                                    "Busque especificamente δ(q, a, X)",
                                    "Identifique o resultado δ(q, a, X) = (p, α), onde p é o novo estado e α é a string a empilhar",
                                    "Anote p e α separadamente",
                                    "Verifique se a transição é aplicável (existe δ para esses símbolos)"
                                  ],
                                  "verification": "Escreva a regra encontrada: δ(q, a, X) = (p, α) e confirme com a tabela de transições",
                                  "estimatedTime": "7 minutos",
                                  "materials": [
                                    "Tabela de transições δ do autômato",
                                    "Exemplo anotado"
                                  ],
                                  "tips": [
                                    "δ é uma função parcial; se não existir, a transição não é possível",
                                    "α pode ser ε (vazia), um símbolo ou string"
                                  ],
                                  "learningObjective": "Localizar e extrair corretamente o resultado de uma transição específica em δ",
                                  "commonMistakes": [
                                    "Usar símbolo errado de pilha ou entrada",
                                    "Confundir pop com push",
                                    "Ignorar que α pode ser múltiplos símbolos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os novos componentes da configuração",
                                  "subSteps": [
                                    "Atualize a fita: novo w é o resto após consumir a (w permanece como definido)",
                                    "Atualize a pilha: remova X do topo e empilhe α no final de γ, resultando em γα",
                                    "Mantenha γ intacto como base da pilha",
                                    "Combine: novo estado p, nova fita w, nova pilha γα",
                                    "Esboce a transformação visualmente (opcional, mas recomendado)"
                                  ],
                                  "verification": "Compare os novos w e pilha com os originais para confirmar mudanças exatas",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Papel para desenhar pilha e fita",
                                    "Marcadores para destacar mudanças"
                                  ],
                                  "tips": [
                                    "Pilha cresce à direita: γα significa α no novo topo",
                                    "Se α=ε, pilha vira apenas γ"
                                  ],
                                  "learningObjective": "Realizar as modificações precisas na fita e pilha conforme a transição",
                                  "commonMistakes": [
                                    "Não remover X da pilha",
                                    "Concatenar α incorretamente",
                                    "Alterar w errado (sempre consome só a)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar e validar a configuração sucessora",
                                  "subSteps": [
                                    "Escreva a nova configuração no formato (p, w, γα)",
                                    "Verifique se todos os símbolos estão corretos (estados, strings)",
                                    "Compare com a definição formal: de (q, wa, γX) para (p, w, αγ) – note a ordem α após γ",
                                    "Teste mentalmente se a transição faz sentido no contexto do autômato",
                                    "Registre a configuração final"
                                  ],
                                  "verification": "A configuração final deve corresponder exatamente à regra aplicada; recite em voz alta",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Folha de verificação",
                                    "Exemplo resolvido para comparação"
                                  ],
                                  "tips": [
                                    "Ordem da pilha é crucial: sempre γα com topo à direita",
                                    "Pratique com ε para pop simples"
                                  ],
                                  "learningObjective": "Construir e validar a configuração sucessora completa",
                                  "commonMistakes": [
                                    "Erro na concatenação γα (esquecer ordem)",
                                    "Manter a na fita",
                                    "Estado errado"
                                  ]
                                }
                              ],
                              "practicalExample": "Configuração inicial: (q0, ab, Z0 A), δ(q0, a, A) = (q1, BC). Sucessora: w = 'b' (remove a), pilha = Z0 BC (remove A, push BC). Resultado: (q1, b, Z0 B C).",
                              "finalVerifications": [
                                "Extrai corretamente q, a, X de qualquer configuração dada",
                                "Localiza δ(q, a, X) sem erros em tabela fornecida",
                                "Constrói pilha γα e fita w precisos",
                                "Escreve configuração sucessora no formato exato",
                                "Explica verbalmente o processo passo a passo",
                                "Aplica em 2 exemplos variados (com ε e sem)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de componentes (100% correto)",
                                "Correta localização e aplicação de δ",
                                "Transformação exata de fita e pilha",
                                "Formato final da configuração válido",
                                "Ausência de erros comuns como ordem da pilha",
                                "Tempo de execução eficiente e explicação clara"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aplicação de funções parciais e concatenação de strings",
                                "Lógica: Dedução passo a passo e verificação de condições",
                                "Programação: Simulação de pilhas (stacks) em linguagens como Python ou Java",
                                "Física/Engenharia: Modelagem de estados em sistemas dinâmicos"
                              ],
                              "realWorldApplication": "Em compiladores e parsers (ex: análise sintática de linguagens de programação como C ou XML), onde autômatos de pilha simulam chamadas de função e balanceamento de parênteses em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.2",
                              "10.1.5.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Simular sequência de transições",
                            "description": "Dado um AP e entrada inicial, executar 3-5 passos de computação, listando configurações sucessoras e justificando cada transição com δ específica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e Representar a Configuração Inicial",
                                  "subSteps": [
                                    "Identifique o autômato de pilha (AP) dado, incluindo estados Q, alfabeto de input Σ, alfabeto da pilha Γ, função de transição δ, estado inicial q0, símbolo inicial da pilha Z0 e estados finais F.",
                                    "Especifique a entrada inicial w (string a ser processada).",
                                    "Formate a configuração inicial como (q0, w, Z0), onde q é o estado atual, o input restante é w e a pilha é representada pelo topo primeiro (ex: α = Z0).",
                                    "Anote qualquer símbolo de fim de input $ se aplicável.",
                                    "Verifique se a notação está correta e consistente com a definição formal."
                                  ],
                                  "verification": "A configuração inicial está corretamente notada e corresponde aos componentes do AP fornecidos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Definição do AP",
                                    "Papel e caneta",
                                    "Exemplo de input w"
                                  ],
                                  "tips": "Sempre use a notação padrão (estado, input restante, pilha com topo à esquerda) para evitar confusões.",
                                  "learningObjective": "Compreender e representar precisamente a configuração inicial de um AP.",
                                  "commonMistakes": [
                                    "Confundir ordem da pilha (topo deve ser à esquerda)",
                                    "Esquecer o símbolo inicial Z0",
                                    "Não incluir o input completo inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Justificar a Primeira Transição",
                                  "subSteps": [
                                    "Examine o estado atual q, o primeiro símbolo do input u (ou ε se input vazio) e o topo da pilha γ.",
                                    "Localize na função δ(q, u, γ) a transição aplicável (pode haver múltiplas; escolha não-determinística se for NPA).",
                                    "Registre a transição: δ(q, u, γ) = (p, β), onde p é novo estado e β é string a empilhar (pode substituir γ).",
                                    "Justifique por que essa é a transição correta, citando os argumentos exatos.",
                                    "Prepare para aplicar: novo estado p, input restante após u, pilha atualizada (remover γ, empilhar β com topo à esquerda)."
                                  ],
                                  "verification": "A transição δ é corretamente identificada e justificada com argumentos exatos, e a nova configuração é esboçada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de transição δ do AP",
                                    "Configuração inicial anotada"
                                  ],
                                  "tips": "Em APs não-determinísticos, liste todas as transições possíveis se houver ramificações.",
                                  "learningObjective": "Aplicar corretamente a regra de transição δ para gerar a configuração sucessora.",
                                  "commonMistakes": [
                                    "Ler símbolo errado do input ou pilha",
                                    "Ignorar ε-transições se aplicáveis",
                                    "Não justificar com δ(q,u,γ) explicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Transições Subsequentes (Passos 2 a 4)",
                                  "subSteps": [
                                    "Usando a configuração do passo anterior como atual, repita o processo de identificação de transição para o passo 2.",
                                    "Aplique δ para gerar configuração sucessora do passo 2, justificando completamente.",
                                    "Repita para o passo 3: identifique, aplique e justifique.",
                                    "Continue para o passo 4 se necessário, listando cada configuração sucessora sequencialmente.",
                                    "Mantenha uma tabela ou lista numerada: Config0 → Config1 → Config2 → etc."
                                  ],
                                  "verification": "Todas as configurações intermediárias (3-4 sucessoras) estão listadas corretamente com justificativas δ para cada transição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Configurações anteriores",
                                    "Papel para tabela de simulação"
                                  ],
                                  "tips": "Desenhe setas entre configurações para visualizar a sequência claramente.",
                                  "learningObjective": "Executar múltiplas transições de forma iterativa e precisa em um AP.",
                                  "commonMistakes": [
                                    "Perder o controle do input restante (consumir símbolos extras)",
                                    "Erro cumulativo na pilha devido a pop/push incorreto",
                                    "Não numerar passos sequencialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar Sequência Completa e Verificar Consistência",
                                  "subSteps": [
                                    "Liste todas as configurações: inicial + 3-5 sucessoras em formato padronizado.",
                                    "Para cada transição i→i+1, anote explicitamente δ(q_i, u_i, γ_i) = (q_{i+1}, β_i).",
                                    "Verifique se input e pilha evoluem logicamente (ex: input encurta, pilha cresce/encolhe conforme δ).",
                                    "Identifique se alguma transição leva a rejeição (pilha vazia inválida ou sem δ aplicável).",
                                    "Resuma o progresso da computação após os passos simulados."
                                  ],
                                  "verification": "Sequência completa de 3-5 passos está documentada com todas as justificativas δ e sem inconsistências.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de configurações dos passos anteriores"
                                  ],
                                  "tips": "Use cores ou negrito para destacar mudanças em input/pilha/estado em cada config.",
                                  "learningObjective": "Consolidar a simulação em uma narrativa coerente e verificável.",
                                  "commonMistakes": [
                                    "Inconsistência entre configs sucessoras",
                                    "Esquecer justificativa δ em algum passo",
                                    "Parar prematuramente antes de 3-5 passos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados da Simulação",
                                  "subSteps": [
                                    "Compare as configurações finais com critérios de aceitação (estado final e pilha vazia ou Z0).",
                                    "Discuta ramificações não-determinísticas se o AP permitir múltiplas δ.",
                                    "Avalie se a sequência demonstra comportamento esperado do AP (ex: matching de símbolos).",
                                    "Anote observações sobre o poder expressivo do AP vs. autômatos finitos.",
                                    "Prepare para extensão: como continuar a simulação além dos 5 passos."
                                  ],
                                  "verification": "Análise inclui verificação de aceitação preliminar e insights sobre a computação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Sequência completa documentada"
                                  ],
                                  "tips": "Pense em como isso se relaciona com reconhecimento de linguagens livres de contexto.",
                                  "learningObjective": "Interpretar o significado computacional da sequência de transições simulada.",
                                  "commonMistakes": [
                                    "Concluir aceitação sem verificar estado F e pilha",
                                    "Ignorar não-determinismo"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o AP determinístico M para {a^n b^n | n≥0} com estados {q0,q1,qf}, Σ={a,b}, Γ={Z0,A}, δ(q0,a,Z0)=(q1,AZ0), δ(q1,a,A)=(q1,AA), δ(q1,b,A)=(q1,ε), δ(q1,ε,Z0)=(qf,ε). Input w='aabbb'. Config inicial: (q0, aabbb$, Z0). Passo1: δ(q0,a,Z0)=(q1,AZ0) → (q1,abbb$,AZ0). Passo2: δ(q1,a,A)=(q1,AA) → (q1,bbb$,AAZ0). Passo3: δ(q1,b,A)=(q1,ε) → (q1,bb$,AZ0). E assim por diante até 5 passos.",
                              "finalVerifications": [
                                "Configuração inicial corretamente representada como (q0, w, Z0).",
                                "Cada transição justificada com δ(q,u,γ) exata.",
                                "Lista de 3-5 configurações sucessoras sem erros de input/pilha.",
                                "Transições aplicadas consistentemente (input encurta, pilha atualiza).",
                                "Nenhuma transição inválida (ex: pop de pilha vazia).",
                                "Sequência numerada e legível.",
                                "Análise preliminar de progresso computacional."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de δ (100% das transições corretas).",
                                "Justificativas completas e explícitas para cada passo (sem ambiguidades).",
                                "Notação consistente de configurações em todos os passos.",
                                "Cobertura de pelo menos 3-5 transições sucessivas.",
                                "Detecção correta de erros potenciais ou ramificações.",
                                "Clareza na documentação (tabelas ou diagramas usados).",
                                "Profundidade na análise de mudanças em estado/input/pilha."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções parciais e relações em teoria dos autômatos.",
                                "Lógica: Raciocínio dedutivo em sequências de regras de transição.",
                                "Programação: Simulação de pilhas em linguagens como Python (stack operations).",
                                "Teoria da Computação: Hierarquia de Chomsky (context-free languages).",
                                "Engenharia de Software: Parsing em compiladores (shift-reduce)."
                              ],
                              "realWorldApplication": "Simulação de transições em autômatos de pilha é fundamental em compiladores para análise sintática de linguagens de programação (ex: parsers LL/LR usam pilhas para matching de estruturas aninhadas como expressões e blocos), validação de XML/JSON balanceados e processamento de linguagens naturais em NLP."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.4",
                            "name": "Tratar transições ε e não-determinismo",
                            "description": "Explicar transições ε (sem consumir entrada) e quando δ retorna múltiplos pares, levando a ramificações não-determinísticas na computação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Transições ε em Autômatos de Pilha",
                                  "subSteps": [
                                    "Defina transição ε como uma transição que não consome símbolo de entrada, apenas altera o estado e/ou pilha.",
                                    "Explique o papel das transições ε: permitir movimentos 'gratuitos' para preparar a pilha ou estado sem avançar na entrada.",
                                    "Diferencie de transições regulares que consomem input.",
                                    "Ilustre com diagrama simples: de q1 --ε/ push(A)--> q2.",
                                    "Discuta impacto na configuração: (q, w, γ) -> (p, w, β) sem mudar w."
                                  ],
                                  "verification": "Desenhe um grafo com pelo menos uma transição ε e descreva sua configuração inicial e final.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis ou ferramenta de desenho como Draw.io; notas de aula sobre PDA.",
                                  "tips": "Sempre anote o símbolo ε explicitamente para evitar confusão com transições vazias.",
                                  "learningObjective": "Identificar e descrever o funcionamento de transições ε em PDAs.",
                                  "commonMistakes": "Confundir ε com transições que consomem λ (fim de string); esquecer de manter a entrada inalterada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Não-Determinismo nas Transições δ",
                                  "subSteps": [
                                    "Defina não-determinismo: δ(q, a, X) retorna conjunto de pares (p, α), possivelmente múltiplos.",
                                    "Compare com determinismo: onde δ retorna exatamente um par ou vazio.",
                                    "Explique ramificações: de uma configuração, múltiplas próximas possíveis.",
                                    "Discuta ε-Não-Determinismo: combinação onde δ inclui transições ε levando a mais branches.",
                                    "Liste tipos: ND puro, ε-ND, ambos."
                                  ],
                                  "verification": "Escreva a definição formal de δ não-determinística e dê um exemplo com 2 saídas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Livro-texto de teoria da computação (Sipser ou similar); editor de texto.",
                                  "tips": "Use conjuntos {} para representar múltiplas transições em δ.",
                                  "learningObjective": "Diferenciar determinismo de não-determinismo em funções de transição de PDA.",
                                  "commonMistakes": "Assumir que ND sempre aceita mais linguagens (não é conversível para determinístico em PDAs context-free)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Configurações com ε e Não-Determinismo",
                                  "subSteps": [
                                    "Aprenda ε-closure: conjunto de estados alcançáveis por ε-transições de um estado.",
                                    "Simule passo a passo: de configuração inicial, aplique todas transições possíveis (incluindo ε).",
                                    "Mantenha fila ou árvore de configurações pendentes para branches ND.",
                                    "Implemente algoritmo de simulação: priorize ε antes de input.",
                                    "Trace exemplo: entrada 'ab', configuração com branches."
                                  ],
                                  "verification": "Simule manualmente 3 passos de uma PDA ε-ND e liste todas configurações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador online de PDA (ex: JFLAP); planilha para rastrear configurações.",
                                  "tips": "Use abreviações para pilha longa; priorize depth-first para evitar explosão.",
                                  "learningObjective": "Executar simulação de PDA com ε-transições e ramificações ND.",
                                  "commonMistakes": "Esquecer ε-closures entre transições de input; loop infinito em ε-ciclos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Exemplos e Verificar Aceitação",
                                  "subSteps": [
                                    "Construa PDA ε-ND para {a^n b^n | n>=0} com push/pop e ε para matching.",
                                    "Simule aceitação/rejeição para strings 'abb', 'aaabbb', inválida 'aab'.",
                                    "Analise por que ND é necessário (ex: adivinhar quando pop).",
                                    "Converta para forma equivalente sem ε (opcional, via construção).",
                                    "Teste com variações: adicione mais ND."
                                  ],
                                  "verification": "Crie e simule PDA para uma linguagem simples, mostrando aceitação.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "JFLAP ou papel; exemplos de linguagens context-free.",
                                  "tips": "Comece com PDAs conhecidos e adicione ε/ND gradualmente.",
                                  "learningObjective": "Construir e validar PDAs que usam ε e ND para linguagens específicas.",
                                  "commonMistakes": "Não detectar rejeição quando todas branches falham; confundir aceitação por estado final vs pilha vazia."
                                }
                              ],
                              "practicalExample": "Em um PDA para {ww^R | w em {a,b}*}, use ε para mover para estado de pop após push completo (ND para decidir fim de w), simulando: entrada 'ababba', branches para timing de pop.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença entre ε e input-transição.",
                                "Simular PDA ε-ND com 5 passos sem erros.",
                                "Identificar todas branches em δ(q,a,A) com 3 saídas.",
                                "Construir PDA simples com ε-ND.",
                                "Detectar loop ε ou rejeição em simulação.",
                                "Descrever ε-closure de um estado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de ε e ND (90% correto).",
                                "Correção em simulações manuais (todas configurações listadas).",
                                "Criatividade em exemplos personalizados.",
                                "Identificação de erros comuns em cenários dados.",
                                "Explicação clara de ramificações e aceitação.",
                                "Uso adequado de ferramentas como JFLAP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos (estados como nós, transições como arestas multiplas).",
                                "Programação: Recursão e backtracking em parsers (ex: CYK algorithm).",
                                "Probabilidade: Modelar ND como distribuições de branches.",
                                "Lógica: Não-determinismo similar a escolha não-determinística em proofs."
                              ],
                              "realWorldApplication": "Compiladores usam PDAs ε-ND em parsers bottom-up (LR parsers) para analisar sintaxe de linguagens de programação, lidando com ambiguidades via lookahead e stack."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Mecanismos de Aceitação",
                    "description": "Aceitação por estado final e por pilha vazia, com demonstração de equivalência entre os dois.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Aceitação por Estado Final",
                        "description": "Mecanismo de aceitação em autômatos de pilha (AP) no qual uma string é aceita se, após processar toda a entrada, o AP estiver em um estado final (membro do conjunto F), independentemente do conteúdo da pilha.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Definir formalmente a aceitação por estado final",
                            "description": "Especificar a definição formal de um autômato de pilha determinístico ou não-determinístico que aceita linguagens livres de contexto por estado final, incluindo a configuração de computação e a condição de aceitação L(M) = {w | existe uma computação de M em w que termina em estado q ∈ F}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal de Autômato de Pilha (PDA)",
                                  "subSteps": [
                                    "Estude a estrutura quíntupla de um PDA: M = (Q, Σ, Γ, δ, q0, Z0, F), identificando cada componente: estados Q, alfabeto de entrada Σ, alfabeto da pilha Γ, função de transição δ, estado inicial q0, símbolo inicial da pilha Z0 e estados finais F.",
                                    "Diferencie PDA determinístico (DPDA) de não-determinístico (NPDA), notando que δ é uma função para DPDA e uma relação para NPDA.",
                                    "Desenhe um diagrama esquemático de um PDA, destacando a pilha como memória LIFO.",
                                    "Liste exemplos de linguagens livres de contexto aceitas por PDAs, como {a^n b^n | n ≥ 0}.",
                                    "Pratique convertendo uma descrição informal de PDA em notação formal."
                                  ],
                                  "verification": "Escreva a definição formal completa de um PDA exemplo e verifique se todos os 7 componentes estão corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser ou similar), quadro branco ou papel para diagramas, notas de aula sobre autômatos.",
                                  "tips": "Use mnemônicos como 'QΣΓδqZ F' para lembrar os componentes.",
                                  "learningObjective": "Compreender a estrutura base de um PDA antes de definir mecanismos de aceitação.",
                                  "commonMistakes": "Confundir alfabeto de entrada Σ com alfabeto da pilha Γ; esquecer o símbolo inicial Z0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Configurações de Computação em PDAs",
                                  "subSteps": [
                                    "Defina uma configuração de computação como uma tríplice (q, w, α), onde q é o estado atual, w a string restante de entrada e α o conteúdo da pilha (topo à esquerda).",
                                    "Explique a relação de configuração inicial: (q0, w, Z0) para entrada w.",
                                    "Descreva a relação de transição entre configurações: (q, wa, γβ) ⊢ (p, a, β) se δ(q, a, γ) contém (p, β).",
                                    "Estenda para ε-transições e transições de pilha vazia em NPDAs.",
                                    "Simule 3-5 passos de computação em um PDA simples, anotando configurações sequenciais."
                                  ],
                                  "verification": "Simule uma computação completa em um PDA exemplo e liste todas as configurações corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador de PDA online (ex: JFLAP), papel para rastrear configurações.",
                                  "tips": "Sempre escreva a pilha com topo à esquerda para evitar confusão.",
                                  "learningObjective": "Dominar como rastrear o 'estado' de uma computação em PDA.",
                                  "commonMistakes": "Esquecer de consumir símbolos de entrada ou inverter a orientação da pilha."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Aceitação por Estado Final",
                                  "subSteps": [
                                    "Estabeleça que um PDA M aceita por estado final se, para w ∈ L(M), existe uma computação de (q0, w, Z0) terminando em (q, ε, α) onde q ∈ F (ε indica entrada consumida).",
                                    "Especifique que a pilha pode conter qualquer conteúdo α ao aceitar (diferente de aceitação por pilha vazia).",
                                    "Compare com aceitação por pilha vazia, destacando que estado final ignora o conteúdo final da pilha.",
                                    "Formalize para NPDAs: aceitação se pelo menos um caminho leva a q ∈ F.",
                                    "Escreva a definição em notação matemática precisa."
                                  ],
                                  "verification": "Redija a definição formal de aceitação por estado final e valide contra um exemplo padrão.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Referência formal (Hopcroft/Ullman), editor de texto para fórmulas.",
                                  "tips": "Lembre: aceitação depende só do estado final, não da pilha.",
                                  "learningObjective": "Articular precisamente o mecanismo de aceitação por estado final.",
                                  "commonMistakes": "Exigir pilha vazia na definição; confundir com aceitação por pilha vazia."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a Linguagem Aceita L(M)",
                                  "subSteps": [
                                    "Defina L(M) = {w ∈ Σ* | (q0, w, Z0) ⊢* (q, ε, α) para algum q ∈ F e qualquer α ∈ Γ*}.",
                                    "Prove que PDAs por estado final aceitam todas as CFLs (equivalência com gramáticas CFG).",
                                    "Construa um PDA que aceita {a^n b^n | n ≥ 0} por estado final.",
                                    "Discuta conversão entre PDA por estado final e por pilha vazia.",
                                    "Teste a definição com contraexemplos para linguagens não livres de contexto."
                                  ],
                                  "verification": "Escreva L(M) formalmente e valide com um PDA exemplo aceitando uma string válida e rejeitando inválida.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "JFLAP ou simulador PDA, exemplos de CFLs.",
                                  "tips": "Use ⊢* para denotar sequências de transições.",
                                  "learningObjective": "Integrar configuração e aceitação na definição completa de L(M).",
                                  "commonMistakes": "Omitir ε na entrada final ou restringir α a ε."
                                }
                              ],
                              "practicalExample": "Considere o PDA M para {a^n b^n | n ≥ 0}: Empilhe A por cada 'a', desempilhe por cada 'b'. Ao consumir toda entrada em estado qf ∈ F, aceite independentemente da pilha restante. Simulação: Para w=abab, configurações terminam em (qf, ε, A) ∈ F.",
                              "finalVerifications": [
                                "Pode recitar a definição formal de PDA e seus componentes?",
                                "Rastreia corretamente uma computação com 5+ configurações?",
                                "Escreve precisamente a condição de aceitação por estado final?",
                                "Define L(M) corretamente, incluindo ⊢* e q ∈ F?",
                                "Distingue aceitação por estado final de por pilha vazia?",
                                "Constrói um PDA simples por estado final para uma CFL básica?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal (uso correto de símbolos como ⊢, δ, etc.).",
                                "Compreensão de configurações de computação e transições.",
                                "Correta diferenciação entre DPDA e NPDA na aceitação.",
                                "Capacidade de formalizar L(M) sem ambiguidades.",
                                "Aplicação em exemplos concretos sem erros lógicos.",
                                "Identificação de erros comuns em definições alternativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e relações (configurações como tríplices).",
                                "Lógica: Noções de não-determinismo semelhantes a provas não-construtivas.",
                                "Compiladores: Parsing bottom-up em analisadores sintáticos.",
                                "Algoritmos: Memória LIFO como em recursão e chamadas de pilha."
                              ],
                              "realWorldApplication": "Em compiladores, PDAs por estado final modelam parsers LR para linguagens de programação, validando estruturas aninhadas como expressões balanceadas em código fonte, essencial para ferramentas como GCC ou sintaxe em editores IDE."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Construir exemplo de AP com aceitação por estado final",
                            "description": "Desenhar um autômato de pilha simples que reconhece uma linguagem livre de contexto, como {a^n b^n | n ≥ 0}, especificando transições, estados iniciais, finais e símbolos da pilha, e verificar aceitação de strings específicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os componentes básicos do autômato de pilha (AP)",
                                  "subSteps": [
                                    "Identifique a linguagem alvo: {a^n b^n | n ≥ 0}.",
                                    "Defina o alfabeto de entrada: Σ = {a, b}.",
                                    "Defina os símbolos da pilha: Γ = {Z0, A}, onde Z0 é o símbolo inicial da pilha.",
                                    "Especifique os estados necessários: q0 (inicial), q1 (empilhando a's), q2 (desempilhando b's), qf (final).",
                                    "Marque q0 como estado inicial e qf como estado final."
                                  ],
                                  "verification": "Lista completa de Σ, Γ, Q (conjunto de estados), q0 e F (estados finais) está documentada corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e lápis ou software de desenho como Draw.io ou Lucidchart.",
                                  "tips": "Use notação padrão: Q, Σ, Γ, δ (função de transição), q0, Z0, F.",
                                  "learningObjective": "Compreender e especificar os elementos fundamentais de um AP.",
                                  "commonMistakes": "Esquecer o símbolo inicial da pilha Z0 ou confundir alfabeto de entrada com símbolos da pilha."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar transições para empilhar símbolos 'A' ao ler 'a'",
                                  "subSteps": [
                                    "Da transição inicial: δ(q0, a, Z0) = (q1, A Z0) para empilhar A sobre Z0.",
                                    "Em q1: δ(q1, a, A) = (q1, A A) para empilhar mais A's.",
                                    "Adicione transição para passar para b's: δ(q1, ε, A) = (q2, A) se necessário, mas foque em empilhamento.",
                                    "Desenhe o diagrama parcial mostrando q0 -> q1 com empilhamento.",
                                    "Verifique que a pilha cresce com n A's para n a's lidas."
                                  ],
                                  "verification": "Diagrama mostra transições corretas de empilhamento sem pop prematuro.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Ferramenta de desenho de diagramas, tabela de transições em planilha.",
                                  "tips": "Use notação δ(estado, input/pilha, novo_estado, push/pop). Represente push como escrever na pilha.",
                                  "learningObjective": "Dominar transições de empilhamento para matching de a's.",
                                  "commonMistakes": "Empilhar em estado errado ou não lidar com Z0 corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar transições para desempilhar ao ler 'b' e alcançar estado final",
                                  "subSteps": [
                                    "De q1 para q2 ao ler primeiro b: δ(q1, b, A) = (q2, ε) para pop A.",
                                    "Em q2: δ(q2, b, A) = (q2, ε) para continuar desempilhando.",
                                    "Ao esvaziar: δ(q2, b, Z0) = (qf, ε) ou ajuste para estado final quando pilha tem só Z0.",
                                    "Adicione δ(q2, ε, Z0) = (qf, Z0) para aceitação por estado final sem input restante.",
                                    "Garanta que só aceita se n a's == n b's."
                                  ],
                                  "verification": "Simule manualmente para string 'aabbb' (inválida) e veja rejeição.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para simulação passo-a-passo, simulador de PDA online se disponível.",
                                  "tips": "Sempre pop um A por b, e cheque pilha vazia (só Z0) no final.",
                                  "learningObjective": "Implementar lógica de matching via pilha LIFO.",
                                  "commonMistakes": "Permitir desempilhamento excessivo ou não detectar mismatch."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar o diagrama e definir todas as transições restantes",
                                  "subSteps": [
                                    "Adicione transições para ε (vazio) onde necessário para limpeza da pilha.",
                                    "Inclua rejeição: estados de sink para mismatches como mais a's ou b's extras.",
                                    "Desenhe o diagrama completo com setas duplas para push/pop.",
                                    "Especifique a função de transição δ completa em tabela.",
                                    "Confirme que aceita por estado final (estar em qf com pilha só Z0 após input)."
                                  ],
                                  "verification": "Tabela de δ cobre todos casos possíveis sem ambiguidades.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software de diagrama para versão final.",
                                  "tips": "Teste com n=0: string vazia deve aceitar indo direto a qf.",
                                  "learningObjective": "Construir AP completo e determinístico/não-determinístico conforme necessário.",
                                  "commonMistakes": "Esquecer transições para ε ou estados de erro."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar aceitação de strings específicas",
                                  "subSteps": [
                                    "Simule '': deve aceitar (q0 -> qf via ε).",
                                    "Simule 'ab': empilha A, pop com b, volta a Z0, vai a qf.",
                                    "Simule 'aabb': empilha AA, pop AA, aceita.",
                                    "Simule 'aaab': rejeita (mais a's).",
                                    "Simule 'abb': rejeita (mais b's primeiro)."
                                  ],
                                  "verification": "Tabela de simulação mostra aceitação/rejeição correta para 5 strings.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha para rastrear configuração (estado, input restante, pilha).",
                                  "tips": "Registre configuração em cada passo: (q, w, γ).",
                                  "learningObjective": "Validar o AP através de simulações manuais.",
                                  "commonMistakes": "Erros na contagem da pilha durante simulação."
                                }
                              ],
                              "practicalExample": "Construa um AP para {a^n b^n | n ≥ 0}: Estados: q0, q1, q2, qf. Transições chave: δ(q0,a,Z0)=(q1,AZ0); δ(q1,a,A)=(q1,AA); δ(q1,b,A)=(q2,ε); δ(q2,b,A)=(q2,ε); δ(q2,ε,Z0)=(qf,Z0). Simule 'aabb': aceita em qf.",
                              "finalVerifications": [
                                "AP reconhece corretamente {a^n b^n | n ≥ 0} e rejeita outras strings.",
                                "Diagrama completo com todas transições rotuladas (input/pilha -> push).",
                                "Simulações de pelo menos 3 strings válidas e 2 inválidas corretas.",
                                "Estado final qf alcançado exatamente quando pilha tem só Z0 e input consumido.",
                                "Função δ definida para todos casos relevantes sem lacunas.",
                                "Notação consistente e legível."
                              ],
                              "assessmentCriteria": [
                                "Precisão das transições de push/pop para matching LIFO (80% peso).",
                                "Correção na aceitação por estado final vs. pilha vazia.",
                                "Completude do diagrama e tabela de transições.",
                                "Validação via simulações com strings variadas.",
                                "Clareza e legibilidade do design (rótulos, setas).",
                                "Tratamento de casos edge (n=0, mismatches)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e relações (linguagens regulares vs. livres de contexto).",
                                "Programação: Estruturas recursivas e pilhas em linguagens como Python (stack para parsing).",
                                "Lógica: Provas por indução para correção de linguagens.",
                                "Engenharia de Software: Modelagem de parsers em compiladores."
                              ],
                              "realWorldApplication": "Desenvolvimento de compiladores e interpretadores de linguagens de programação, onde PDAs modelam parsing de estruturas balanceadas como parênteses ou blocos if-then, usados em ferramentas como ANTLR ou yacc."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Simular processamento por estado final",
                            "description": "Executar passo a passo a computação de um AP dado sobre uma entrada específica, rastreando estados, pilha e entrada restante, determinando aceitação baseada no estado final.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura formal do Autômato de Pilha (AP)",
                                  "subSteps": [
                                    "Identifique os componentes: conjunto de estados Q, alfabeto de entrada Σ, alfabeto de pilha Γ, função de transição δ, estado inicial q0, símbolo inicial Z0.",
                                    "Liste os estados finais F para aceitação por estado final.",
                                    "Desenhe o diagrama do AP ou tabule as transições relevantes.",
                                    "Analise o papel da pilha: símbolos empilhados/pop e ε-transições.",
                                    "Verifique se o AP é determinístico ou não-determinístico."
                                  ],
                                  "verification": "Crie um resumo escrito ou diagrama da estrutura do AP com todos os componentes corretamente identificados.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Definição formal do AP",
                                    "Papel e caneta ou software de diagramação como Draw.io",
                                    "Exemplo de entrada fornecida"
                                  ],
                                  "tips": "Comece pelos estados iniciais e finais; foque em transições que envolvem a pilha.",
                                  "learningObjective": "Dominar os componentes formais de um AP para preparar a simulação.",
                                  "commonMistakes": [
                                    "Confundir alfabeto de entrada com pilha",
                                    "Ignorar o símbolo inicial Z0",
                                    "Esquecer estados finais F"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a configuração inicial da simulação",
                                  "subSteps": [
                                    "Defina a configuração inicial: (q0, entrada completa w, pilha com apenas Z0).",
                                    "Escreva a entrada w como uma sequência de símbolos.",
                                    "Registre o estado atual, posição na entrada (início) e conteúdo da pilha.",
                                    "Prepare uma tabela de rastreamento com colunas: Passo, Estado, Entrada Restante, Pilha.",
                                    "Confirme que não há movimento inicial sem ler entrada."
                                  ],
                                  "verification": "A configuração inicial está corretamente registrada na tabela sem erros de notação.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Tabela de rastreamento em papel ou planilha",
                                    "Definição do AP e entrada w"
                                  ],
                                  "tips": "Use notação padrão: (estado, entrada restante, pilha) para clareza.",
                                  "learningObjective": "Estabelecer o ponto de partida preciso para a simulação passo a passo.",
                                  "commonMistakes": [
                                    "Iniciar pilha vazia em vez de Z0",
                                    "Confundir entrada restante com pilha",
                                    "Pular registro inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar transições passo a passo rastreando mudanças",
                                  "subSteps": [
                                    "No passo atual, olhe o estado atual, próximo símbolo da entrada (ou ε) e topo da pilha.",
                                    "Aplique δ: encontre todas as transições possíveis (se não-determinístico, ramifique).",
                                    "Atualize: novo estado, consuma símbolo da entrada se lido, empilhe/pop da pilha.",
                                    "Registre na tabela: novo estado, entrada restante, pilha após mudança.",
                                    "Repita até entrada esgotada e sem ε-transições ou sem transições possíveis."
                                  ],
                                  "verification": "Cada linha da tabela reflete corretamente uma transição válida do AP.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Tabela de rastreamento expandida",
                                    "Lista completa de transições δ"
                                  ],
                                  "tips": "Prossiga um símbolo por vez; pause se ramificações surgirem em ND-AP.",
                                  "learningObjective": "Simular dinamicamente o comportamento do AP com rastreamento preciso.",
                                  "commonMistakes": [
                                    "Aplicar transição errada (símbolo/pilha incorretos)",
                                    "Não atualizar pilha corretamente",
                                    "Ignorar ε-movimentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar aceitação baseada no estado final",
                                  "subSteps": [
                                    "Após esgotar a entrada, verifique se o estado atual pertence a F (estados finais).",
                                    "Confirme que a pilha está em estado válido (geralmente com Z0 ou vazia, conforme definição).",
                                    "Se múltiplas ramificações (ND), verifique se alguma atinge estado em F.",
                                    "Registre o resultado: aceito/rejeitado e configuração final.",
                                    "Documente o caminho de aceitação/rejeição completo."
                                  ],
                                  "verification": "Resultado de aceitação está justificado pelo estado final e tabela completa.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Tabela de rastreamento finalizada",
                                    "Lista de estados F"
                                  ],
                                  "tips": "Aceitação é SOLELY pelo estado final, ignorando pilha a menos que especificado.",
                                  "learningObjective": "Aplicar critério de aceitação por estado final corretamente.",
                                  "commonMistakes": [
                                    "Confundir com aceitação por pilha vazia",
                                    "Parar prematuramente antes de esgotar entrada",
                                    "Erro em ramificações ND"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o AP para {a^n b^n | n ≥ 0}: Q={q0,q1,qf}, Σ={a,b}, Γ={A,Z}, q0 inicial, Z inicial, F={qf}. Transições: δ(q0,a,Z)=(q0,AZ), δ(q0,a,A)=(q0,AA), δ(q0,b,A)=(q1,ε), δ(q1,b,A)=(q1,ε), δ(q1,ε,Z)=(qf,ε). Simule sobre w='aabb': Início (q0, aabb, Z) → (q0, abb, AZ) → (q0, bb, AAZ) → (q1, b, AZ) → (q1, ε, Z) → (qf, ε, Z). Aceito pois qf ∈ F.",
                              "finalVerifications": [
                                "Tabela de simulação completa sem erros de transição.",
                                "Estados, entrada restante e pilha rastreados corretamente em todos os passos.",
                                "Entrada totalmente consumida antes da verificação final.",
                                "Decisão de aceitação baseada exclusivamente no estado final.",
                                "Exemplo prático simulado com resultado correto.",
                                "Documentação clara de configurações intermediárias."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de δ (100% das transições corretas).",
                                "Rastreamento completo de pilha e entrada (sem omissões).",
                                "Correta identificação de estados finais e decisão de aceitação.",
                                "Manejo adequado de não-determinismo se aplicável.",
                                "Clareza e organização da tabela de simulação.",
                                "Tempo de simulação eficiente sem retrocessos desnecessários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Modelagem de transições como relações em grafos direcionados.",
                                "Programação: Implementação de stack e estado em linguagens como Python ou Java.",
                                "Lógica Computacional: Estados como predicados em máquinas de Turing abstratas.",
                                "Engenharia de Software: Simulação de parsers LL(1) baseados em pilha.",
                                "Teoria da Computação: Ligação com linguagens livres de contexto."
                              ],
                              "realWorldApplication": "Simulação de PDAs é fundamental em compiladores para análise sintática (parsing), onde pilhas rastreiam estruturas aninhadas como chaves em código-fonte, determinando se o programa é sintaticamente válido pelo estado final do parser."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Aceitação por Pilha Vazia",
                        "description": "Mecanismo de aceitação em autômatos de pilha no qual uma string é aceita se, após processar toda a entrada, a pilha estiver completamente vazia, independentemente do estado atual do autômato.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Definir formalmente a aceitação por pilha vazia",
                            "description": "Formalizar a definição de aceitação por pilha vazia em AP, onde L(M) = {w | existe uma computação de M em w que consome toda a entrada e esvazia a pilha}, destacando diferenças com aceitação por estado final.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Autômatos de Pilha e Aceitação por Estado Final",
                                  "subSteps": [
                                    "Relembre a estrutura formal de um Autômato de Pilha (AP): M = (Q, Σ, Γ, δ, q0, Z0), onde Q é estados, Σ alfabeto de entrada, Γ símbolos da pilha, δ função de transição, q0 estado inicial, Z0 símbolo inicial da pilha.",
                                    "Defina aceitação por estado final: L(M) = {w ∈ Σ* | existe computação de M em w terminando em estado final F ⊆ Q após consumir toda a entrada}.",
                                    "Descreva uma computação de AP: sequência de configurações (q, w, α), onde q é estado, w entrada restante, α conteúdo da pilha.",
                                    "Identifique que na aceitação por estado final, a pilha pode não estar vazia ao final.",
                                    "Anote exemplos simples de linguagens reconhecidas por AP com aceitação por estado final, como {a^n b^n | n ≥ 0}."
                                  ],
                                  "verification": "Escreva a definição formal de AP e de L(M) por estado final sem consultar materiais; confira com referências padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser), notas de aula sobre AP",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use diagramas de transição para visualizar; foque em como a pilha armazena contexto.",
                                  "learningObjective": "Compreender a base conceitual de AP para contrastar com aceitação por pilha vazia.",
                                  "commonMistakes": [
                                    "Confundir Σ (entrada) com Γ (pilha)",
                                    "Esquecer que F é conjunto de estados finais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito Intuitivo de Aceitação por Pilha Vazia",
                                  "subSteps": [
                                    "Explique intuitivamente: aceitação ocorre se, após consumir toda a entrada, a pilha estiver completamente vazia.",
                                    "Compare com aceitação por estado: pilha vazia ignora estado atual, focando apenas no esvaziamento da pilha.",
                                    "Descreva uma computação aceita: inicia com Z0 na pilha, termina com pilha ε (vazia) e entrada consumida.",
                                    "Discuta motivação: útil para linguagens context-free onde balanceamento é chave, sem necessidade de estados especiais.",
                                    "Crie um exemplo verbal: para {a^n b^n}, empilhe 'A' por 'a', desempilhe por 'b'; aceita se pilha vazia no fim."
                                  ],
                                  "verification": "Desenhe uma computação passo a passo para w = 'aabb' em um AP simples, mostrando pilha vazia no final.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de AP online (ex: JFLAP)",
                                    "Folha para desenhar configurações"
                                  ],
                                  "tips": "Sempre represente pilha com topo à esquerda (ex: Z0 α significa Z0 no fundo).",
                                  "learningObjective": "Diferenciar conceitualmente aceitação por pilha vazia da por estado final.",
                                  "commonMistakes": [
                                    "Achar que estado inicial importa para aceitação",
                                    "Ignorar que entrada deve ser totalmente consumida"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Definição Matemática de L(M) por Pilha Vazia",
                                  "subSteps": [
                                    "Escreva a definição: L(M) = {w ∈ Σ* | (q0, w, Z0) ⊢* (q, ε, ε) para algum q ∈ Q}, onde ⊢* é relação de computação em zero ou mais passos.",
                                    "Defina configuração: tripla (q, w, α) com α ∈ Γ* (pilha com topo à esquerda).",
                                    "Especifique transição: δ(q, a, X) = {(p, γ) | ...}, estendendo para λ (entrada vazia).",
                                    "Inclua computação por ε-transições se aplicável, garantindo pilha esvaziada.",
                                    "Prove que é equivalente em poder para linguagens livres de contexto, mas com estruturas diferentes."
                                  ],
                                  "verification": "Escreva a definição formal exata de L(M) e valide com um exemplo onde pilha esvazia corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência formal (ex: Hopcroft/Ullman)",
                                    "Editor de texto para fórmulas LaTeX opcionais"
                                  ],
                                  "tips": "Use notação precisa: ε para pilha/entrada vazia; ⊢ para um passo, ⊢* para múltiplos.",
                                  "learningObjective": "Dominar a notação matemática precisa para aceitação por pilha vazia.",
                                  "commonMistakes": [
                                    "Escrever pilha como ε no início",
                                    "Confundir topo da pilha na notação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Diferenças e Construir um Exemplo Completo",
                                  "subSteps": [
                                    "Liste diferenças: (1) Não usa estados finais; (2) Pilha deve ser ε; (3) Estado final irrelevante; (4) Pode requerer AP não-determinístico.",
                                    "Construa AP para {ww^R | w ∈ {a,b}*}: empilhe w, desempilhe comparando w^R.",
                                    "Simule aceitação: para w='ab', entrada 'abab', pilha esvazia após matching.",
                                    "Converta um AP por estado final para pilha vazia adicionando transições para esvaziar pilha.",
                                    "Discuta limitações: nem todo AP por estado é diretamente convertível sem modificações."
                                  ],
                                  "verification": "Construa e simule um AP completo para uma linguagem simples, confirmando aceitação por pilha vazia.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "JFLAP ou papel para diagrama de AP",
                                    "Exemplos de linguagens DCFL"
                                  ],
                                  "tips": "Teste com entradas inválidas para garantir rejeição correta (pilha não vazia ou entrada sobrando).",
                                  "learningObjective": "Aplicar a definição formal e contrastá-la efetivamente com aceitação por estado.",
                                  "commonMistakes": [
                                    "Esquecer não-determinismo",
                                    "Não consumir toda entrada antes de checar pilha"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere M um AP para L = {a^n b^n | n ≥ 0}. δ(q0, a, Z0) = {(q0, A Z0)}, δ(q0, b, A) = {(q0, ε)}, δ(q0, ε, Z0) = {(qf, ε)}. Para w = aabb, computação: (q0, aabb, Z0) ⊢* (q0, ε, ε), logo w ∈ L(M) por pilha vazia, independentemente de qf.",
                              "finalVerifications": [
                                "Escreva corretamente L(M) = {w | (q0, w, Z0) ⊢* (q, ε, ε)} sem erros.",
                                "Explique verbalmente 3 diferenças chave com aceitação por estado final.",
                                "Simule uma computação aceita e uma rejeitada para um AP simples.",
                                "Construa diagrama de AP que aceita por pilha vazia para {a^n b^n}.",
                                "Identifique se um AP dado usa pilha vazia ou estado final corretamente.",
                                "Prove que aceitação por pilha vazia reconhece todas DCFL."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal (100% correta).",
                                "Clareza na distinção conceitual com aceitação por estado.",
                                "Capacidade de simular computações com pilha esvaziando corretamente.",
                                "Exemplos relevantes e sem erros lógicos.",
                                "Compreensão de equivalência com modelos padrão de PDA.",
                                "Uso adequado de terminologia (configuração, ⊢*, ε)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos e Relações (computações como caminhos em grafos).",
                                "Lógica: Autômatos como modelos formais de dedução.",
                                "Programação: Parsing recursivo em compiladores (stack-based).",
                                "Engenharia de Software: Verificação formal de protocolos com pilhas.",
                                "Filosofia da Computação: Limites da computação determinística."
                              ],
                              "realWorldApplication": "Em compiladores, parsers bottom-up (LR) usam pilhas para matching de gramáticas context-free, esvaziando pilha ao reduzir produções, similar à aceitação por pilha vazia para validar sintaxe balanceada em linguagens como C++ ou XML."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Construir exemplo de AP com aceitação por pilha vazia",
                            "description": "Criar um autômato de pilha para uma linguagem como {ww^R | w ∈ {a,b}*}, usando apenas aceitação por pilha vazia, definindo transições que empilham e desempilham adequadamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a linguagem {ww^R} e aceitação por pilha vazia",
                                  "subSteps": [
                                    "Analise a linguagem {ww^R | w ∈ {a,b}*}: identifique que são palíndromos pares onde a segunda metade é o reverso da primeira.",
                                    "Revise definição de PDA: conjunto (Q, Σ, Γ, δ, q0, Z0), com aceitação por pilha vazia (pilha vazia após ler toda entrada).",
                                    "Entenda não-determinismo: PDA pode 'adivinhar' o fim de w via transição ε.",
                                    "Estude exemplo simples: para w=ε, εε^R=ε aceito imediatamente; para w=a, aa^R=aa.",
                                    "Anote símbolos: Σ={a,b}, Γ={a,b,Z0} com Z0 inicial opcional (pilha inicia vazia)."
                                  ],
                                  "verification": "Escreva um resumo de 1 parágrafo explicando aceitação por pilha vazia vs. por estado final, e dê 2 exemplos de strings na linguagem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, caneta, notas de aula sobre PDAs",
                                  "tips": "Desenhe uma tabela comparando aceitação por pilha vazia (ignora estado final) com por estado final.",
                                  "learningObjective": "Dominar conceitos fundamentais para evitar confusões em design.",
                                  "commonMistakes": "Confundir com aceitação por estado final; ignorar não-determinismo necessário para detectar meio da string."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir configuração formal inicial do PDA",
                                  "subSteps": [
                                    "Defina Q = {q0, q1}, onde q0 é estado de empilhamento, q1 de desempilhamento.",
                                    "Especifique Σ = {a,b}, Γ = {a,b}, q0 inicial, pilha inicia vazia (sem Z0 explícito).",
                                    "Crie esboço de diagrama de estados com setas iniciais.",
                                    "Liste transições δ iniciais vazias para preparar.",
                                    "Confirme que aceitação ocorre se pilha vazia após fim da entrada, em qualquer estado."
                                  ],
                                  "verification": "Escreva a tupla formal (Q, Σ, Γ, δ=∅, q0) e desenhe diagrama básico com 2 estados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis para diagramas",
                                  "tips": "Use notação padrão: δ(q, input/pilha) = (p, pop/push).",
                                  "learningObjective": "Estabelecer base formal precisa para transições.",
                                  "commonMistakes": "Incluir estado final desnecessário; usar alfabeto de pilha incorreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar transições de empilhamento em q0",
                                  "subSteps": [
                                    "Defina δ(q0, a, ε) = (q0, a) : empilha 'a' sem pop.",
                                    "Defina δ(q0, b, ε) = (q0, b) : empilha 'b' sem pop.",
                                    "Explique: em q0, empilha cada símbolo de w repetidamente.",
                                    "Teste mentalmente: para 'ab', pilha fica b (top) a (base).",
                                    "Adicione transições para loops em q0."
                                  ],
                                  "verification": "Liste as 2 transições e simule pilha para input 'ab' terminando em q0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha para simular pilha (desenhe colunas para estados/pilha)",
                                  "tips": "Sempre especifique pop como ε para empilhar puro.",
                                  "learningObjective": "Implementar fase de construção da pilha para primeira metade.",
                                  "commonMistakes": "Popar em vez de empilhar; esquecer de ficar em q0 para múltiplos símbolos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Projetar transição não-determinística e desempilhamento em q1",
                                  "subSteps": [
                                    "Defina δ(q0, ε, ε) = (q1, ε) : não-det. transita para matching sem ler input.",
                                    "Defina δ(q1, a, a) = (q1, ε) : pop 'a' se top=a.",
                                    "Defina δ(q1, b, b) = (q1, ε) : pop 'b' se top=b.",
                                    "Explique: após transitar, desempilha w^R comparando tops.",
                                    "Adicione rejeição implícita se mismatch ou pilha sobra."
                                  ],
                                  "verification": "Liste as 3 novas transições e confirme diagrama completo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama anterior, canetas coloridas para tipos de transições",
                                  "tips": "Use ε para transições sem input/pilha quando apropriado.",
                                  "learningObjective": "Capturar matching reverso via não-determinismo.",
                                  "commonMistakes": "Transição sem ε para adivinhar meio; push em vez de pop em q1."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar PDA com testes e formalizar definição",
                                  "subSteps": [
                                    "Trace para 'abba': empilha a,b -> pilha=b a; ε->q1; b pop b, a pop a -> vazia.",
                                    "Teste inválido 'abc': não match ou sobra na pilha.",
                                    "Verifique strings vazia, 'aa', 'bb'.",
                                    "Escreva definição δ completa como conjunto de 5-tuplas.",
                                    "Desenhe diagrama final com todas setas."
                                  ],
                                  "verification": "Simule 3 strings (2 aceitas, 1 rejeitada) mostrando pilha final vazia apenas para aceitas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabelas de simulação, software como JFLAP opcional",
                                  "tips": "Registre todas branches não-det.; só uma leva a pilha vazia para strings válidas.",
                                  "learningObjective": "Garantir corretude via testes exaustivos.",
                                  "commonMistakes": "Ignorar branches não-det.; errar ordem de pilha (LIFO)."
                                }
                              ],
                              "practicalExample": "Para w=ab, construa PDA: de q0 leia 'a' empilha A (pilha: A), 'b' empilha B (pilha: B A); ε -> q1; leia 'b' pop B (pilha: A), 'a' pop A (pilha: vazia) -> aceito. Diagrama: q0 --a/ A--> q0, q0 --ε/ε--> q1, q1 --b/B--> q1, etc.",
                              "finalVerifications": [
                                "Pilha está vazia após processar strings válidas como 'abba', 'aa'.",
                                "Pilha não vazia ou travada para inválidas como 'aba', 'ab'.",
                                "Todas transições δ cobrem empilhamento, transição ε e desempilhamento.",
                                "Não-determinismo permite adivinhar |w| corretamente em pelo menos um caminho.",
                                "Diagrama visual completo com 2 estados e loops corretos.",
                                "Definição formal como 5-tupla precisa e completa."
                              ],
                              "assessmentCriteria": [
                                "Precisão das transições δ (todas 5 corretas).",
                                "Uso correto de não-determinismo via ε-transição.",
                                "Simulações de traços mostram pilha vazia só para L({ww^R}).",
                                "Diagrama claro e legível com labels padrão.",
                                "Ausência de estados/aceitação por estado final desnecessários.",
                                "Explicação escrita coerente dos mecanismos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Grafos direcionados (estados/transições como arestas).",
                                "Engenharia de Software: Parsing descendente recursivo em compiladores.",
                                "Lógica Computacional: Não-determinismo simulando backtracking em algoritmos.",
                                "Algoritmos: Estruturas LIFO como pilhas em recursão."
                              ],
                              "realWorldApplication": "Projetar analisadores sintáticos para linguagens de programação (ex: verificar balanceamento de chaves {} ou tags XML), validação de protocolos de rede com estruturas reversíveis, e modelagem de sistemas reativos com memória LIFO em processadores de eventos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Simular processamento por pilha vazia",
                            "description": "Simular a execução de um AP com aceitação por pilha vazia em uma string dada, verificando se a pilha fica vazia ao final, e analisando rejeições por pilha não vazia ou entrada não consumida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Autômato de Pilha (AP) e a String de Entrada",
                                  "subSteps": [
                                    "Identifique os componentes do AP: estados, alfabeto de entrada, alfabeto da pilha, função de transição δ, estado inicial q0 e símbolo inicial da pilha Z0 (geralmente vazio para aceitação por pilha vazia).",
                                    "Desenhe ou liste o diagrama de transições do AP em uma tabela ou grafo simples.",
                                    "Escreva a string de entrada w explicitamente e marque sua posição inicial (cabeça de leitura em 1).",
                                    "Confirme que o AP é projetado para aceitação por pilha vazia: aceita se pilha estiver vazia após consumir toda w.",
                                    "Anote possíveis casos de rejeição: pilha não vazia no fim ou entrada não totalmente consumida."
                                  ],
                                  "verification": "Verifique se todos os componentes do AP estão listados corretamente e a string w está pronta para simulação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama do AP impresso ou digital",
                                    "Exemplo de string de teste"
                                  ],
                                  "tips": "Use uma tabela para δ(q, a, X) → (p, γ) para clareza visual.",
                                  "learningObjective": "Compreender a estrutura formal de um AP para aceitação por pilha vazia.",
                                  "commonMistakes": [
                                    "Ignorar o símbolo inicial Z0",
                                    "Confundir alfabeto de entrada com pilha",
                                    "Não especificar o estado inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a Configuração Inicial da Simulação",
                                  "subSteps": [
                                    "Configure o estado atual como q0.",
                                    "Inicialize a pilha como vazia ou com Z0 (conforme definição; para pilha vazia, tipicamente sem Z0 inicial).",
                                    "Posicione a cabeça de leitura no primeiro símbolo de w.",
                                    "Registre a configuração inicial: (q0, w, ε) onde ε é pilha vazia.",
                                    "Teste uma transição manual inicial para validar setup."
                                  ],
                                  "verification": "A configuração inicial está anotada corretamente: estado, resto de entrada e pilha.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de simulação em tabela (colunas: Passo, Estado, Entrada Restante, Pilha)",
                                    "Caneta"
                                  ],
                                  "tips": "Represente pilha com topo à direita: ε | Z0 para visualização.",
                                  "learningObjective": "Configurar corretamente o estado inicial de uma simulação de AP.",
                                  "commonMistakes": [
                                    "Iniciar pilha com símbolos errados",
                                    "Posicionar cabeça de leitura incorretamente",
                                    "Esquecer estado q0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Transições Passo a Passo",
                                  "subSteps": [
                                    "Para cada configuração atual (q, xa, γ), aplique δ(q, a, topo(γ)) se definido.",
                                    "Atualize: novo estado p, substitua topo por γ' na pilha, avance cabeça se a consumida.",
                                    "Se ε-transição permitida, aplique sequencialmente até não mais possível.",
                                    "Continue até não haver transição ou fim de w.",
                                    "Registre cada configuração em uma tabela sequencial."
                                  ],
                                  "verification": "Tabela completa de transições sem lacunas ou erros de aplicação de δ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de simulação",
                                    "Definição exata de δ do AP"
                                  ],
                                  "tips": "Processe uma transição por vez; pause se pilha ou entrada travar.",
                                  "learningObjective": "Aplicar corretamente a função de transição em simulações de AP.",
                                  "commonMistakes": [
                                    "Aplicar transição errada para símbolo",
                                    "Pop errôneo sem match",
                                    "Ignorar ε-transições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Condição de Aceitação por Pilha Vazia",
                                  "subSteps": [
                                    "Após processar toda w, cheque se pilha é ε (vazia).",
                                    "Confirme se entrada foi totalmente consumida (cabeça após último símbolo).",
                                    "Se ambos verdadeiros, marque como aceito; senão, rejeitado.",
                                    "Anote configuração final explicitamente.",
                                    "Compare com definição formal de aceitação."
                                  ],
                                  "verification": "Configuração final documentada com status de aceitação/rejeição justificado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de simulação finalizada"
                                  ],
                                  "tips": "Aceitação requer AND: pilha vazia E w consumida.",
                                  "learningObjective": "Distinguir aceitação por pilha vazia de outros mecanismos.",
                                  "commonMistakes": [
                                    "Aceitar só por pilha vazia ignorando entrada restante",
                                    "Confundir com aceitação por estado final"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Casos de Rejeição e Patrones",
                                  "subSteps": [
                                    "Identifique rejeição por pilha não vazia: explique símbolos residuais.",
                                    "Identifique rejeição por entrada não consumida: símbolos restantes.",
                                    "Teste strings variantes para padrões (ex: uma a mais/falta).",
                                    "Descreva correções ou linguagens reconhecidas.",
                                    "Resuma lições da simulação."
                                  ],
                                  "verification": "Relatório de rejeições com pelo menos 2 exemplos e análises.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Strings de teste adicionais",
                                    "Notas da simulação"
                                  ],
                                  "tips": "Use contraexemplos para validar limites da linguagem.",
                                  "learningObjective": "Diagnosticar e explicar falhas em simulações de AP.",
                                  "commonMistakes": [
                                    "Não testar casos de borda",
                                    "Atribuir rejeição errada",
                                    "Ignorar loops infinitos"
                                  ]
                                }
                              ],
                              "practicalExample": "AP para parênteses balanceados: Estados {q0}, δ(q0, '(', ε) = (q0, '('); δ(q0, ')', '(') = (q0, ε). String: ()(). Simulação: Início (q0, ()(), ε). Após '(': (q0, )(), '('). Após ')': (q0, (), ε). Após '(': (q0, ), '('). Após ')': (q0, ε, ε). Pilha vazia e entrada consumida → Aceito. Para ()) : Final (q0, ε, '(') → Rejeitado (pilha não vazia).",
                              "finalVerifications": [
                                "Simule corretamente uma string aceita, mostrando pilha vazia no fim.",
                                "Identifique rejeição por pilha não vazia em contraexemplo.",
                                "Identifique rejeição por entrada não consumida em outro exemplo.",
                                "Preencha tabela de simulação sem erros de transição.",
                                "Explique formalmente por que uma string é aceita/rejeitada.",
                                "Teste pelo menos 3 strings diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de transições δ (sem erros).",
                                "Correta identificação de configuração final e aceitação.",
                                "Análise completa de rejeições com justificativas.",
                                "Uso adequado de tabela/notação para simulação.",
                                "Clareza na documentação de passos e configurações.",
                                "Tratamento de casos de borda e ε-transições."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar simulação em Python com lista como pilha.",
                                "Matemática: Modelos formais e teoria dos conjuntos.",
                                "Lógica: Análise de estados e condições booleanas (AND para aceitação).",
                                "Engenharia de Software: Verificação de parsers e balanceamento em código.",
                                "Algoritmos: Estruturas de dados como pilhas em recursão."
                              ],
                              "realWorldApplication": "Em compiladores e parsers (ex: verificar balanceamento de chaves/ parênteses em código fonte); validação de XML/HTML; análise sintática em processadores de linguagens naturais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Equivalência entre Aceitação por Estado Final e por Pilha Vazia",
                        "description": "Demonstração teórica de que os dois mecanismos de aceitação definem a mesma classe de linguagens livres de contexto, via construções de conversão mútua entre autômatos equivalentes.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Provar conversão de AP por estado final para pilha vazia",
                            "description": "Construir e provar corretude de um AP' equivalente a um AP que aceita por estado final, adicionando estados e transições para esvaziar a pilha após alcançar estado final, preservando L(AP) = L(AP').",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e descrever o autômato de pilha (AP) original por aceitação em estado final",
                                  "subSteps": [
                                    "Revise a definição formal de um AP por estado final: Q, Σ, Γ, δ, q0, Z0, F.",
                                    "Identifique os componentes chave: estados finais F indicam aceitação independentemente do conteúdo da pilha.",
                                    "Desenhe um diagrama do AP original, destacando transições e estados F.",
                                    "Explique como uma string w é aceita: existe uma computação que consome w e termina em f ∈ F.",
                                    "Anote suposições padrão: Z0 é marcador de fundo e não é removido prematuramente."
                                  ],
                                  "verification": "Desenho completo do AP original com legendas explicando aceitação por estado final.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de desenho como draw.io",
                                    "Referência de teoria da computação (ex: Sipser)"
                                  ],
                                  "tips": "Use setas coloridas para diferenciar transições de empilhamento, pop e epsilon.",
                                  "learningObjective": "Compreender precisamente o mecanismo de aceitação por estado final em APs.",
                                  "commonMistakes": [
                                    "Confundir aceitação por estado final com pilha vazia",
                                    "Ignorar não-determinismo nas transições"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o AP' equivalente por aceitação em pilha vazia",
                                  "subSteps": [
                                    "Adicione novo estado inicial q0' com transição δ'(q0', ε, ε) = (q0, Z0) para empilhar Z0.",
                                    "Copie todos os estados Q' = Q ∪ {qε} e transições δ do AP original para δ'.",
                                    "Para cada f ∈ F e γ ∈ Γ, adicione δ'(f, ε, γ) = (qε, ε) iniciando o esvaziamento.",
                                    "Defina δ'(qε, ε, γ) = (qε, ε) para todo γ ∈ Γ (popa qualquer símbolo até pilha vazia).",
                                    "Verifique que AP' = (Q', Σ, Γ, δ', q0', Z0, ∅) aceita por pilha vazia."
                                  ],
                                  "verification": "Diagrama completo de AP' com novas transições destacadas e tabela de δ' escrita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho de autômatos",
                                    "Folha para tabela de transições"
                                  ],
                                  "tips": "Rotule novas transições como 'dump_start' e 'dump_pop' para clareza.",
                                  "learningObjective": "Construir formalmente o AP' que simula AP e esvazia a pilha após estado final.",
                                  "commonMistakes": [
                                    "Esquecer de empilhar Z0 no início",
                                    "Não adicionar pops para todos γ no estado qε"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que L(AP) ⊆ L(AP') (se aceito por estado final, então por pilha vazia)",
                                  "subSteps": [
                                    "Assuma w ∈ L(AP): existe computação ρ que consome w, termina em f ∈ F com pilha não-vazia.",
                                    "Em AP', a computação inicia empilhando Z0, simula ρ até f (mesmo prefixo).",
                                    "De f, use transições ε para ir a qε e popar toda pilha (incluindo Z0) via loops em qε.",
                                    "Após input consumido, pilha vazia: w aceito por AP'.",
                                    "Argumente por indução na comprimento da computação que simulação preserva configuração."
                                  ],
                                  "verification": "Escrita formal da prova com lema de simulação e indução explícita.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel para prova matemática",
                                    "Exemplo simples de AP para testar"
                                  ],
                                  "tips": "Use notação de configuração (q, resto_input, pilha) para precisão.",
                                  "learningObjective": "Dominar prova por simulação e indução para inclusão de linguagens.",
                                  "commonMistakes": [
                                    "Não considerar epsilon-moves após input",
                                    "Ignorar conteúdo residual da pilha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar que L(AP') ⊆ L(AP) (se aceito por pilha vazia, então por estado final) e concluir equivalência",
                                  "subSteps": [
                                    "Assuma w ∈ L(AP'): existe computação que consome w e esvazia pilha.",
                                    "A computação deve empilhar Z0, simular AP até f ∈ F (único caminho para dump), então popar.",
                                    "Prove que sem visitar f, Z0 não é popado (invariante: dump só de f).",
                                    "Assim, prefixo até f simula aceitação em AP: w ∈ L(AP).",
                                    "Conclua L(AP) = L(AP') por simetria das inclusões."
                                  ],
                                  "verification": "Prova completa escrita com invariante e contradição para caminhos alternativos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel para prova",
                                    "Diagrama de AP' para referência"
                                  ],
                                  "tips": "Defina invariante: 'Z0 permanece na base até dump iniciar'.",
                                  "learningObjective": "Completar prova de equivalência usando invariantes e contradição.",
                                  "commonMistakes": [
                                    "Assumir determinismo",
                                    "Não tratar branches não-determinísticos que evitam f"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere AP para {a^n b^n | n≥0} por estado final: q0 empilha A em a; q1 popa A em b; qf final em Z0 após b's. Construa AP': adicione q0' → (q0,Z0); de qf, pop tudo via qε. Prove: para w=abab, simula até qf com pilha Z0 AA (após ajustes), então dump para vazia.",
                              "finalVerifications": [
                                "Descreva corretamente todas as novas transições em AP'.",
                                "Escreva prova => sem gaps na simulação.",
                                "Identifique invariante chave na prova <=",
                                "Aplique a construção a um AP exemplo e verifique L igual.",
                                "Explique por que Z0 é essencial.",
                                "Discuta impacto do não-determinismo."
                              ],
                              "assessmentCriteria": [
                                "Precisão formal na construção de AP' (todos componentes corretos).",
                                "Rigor matemático nas provas (indução, invariantes explicitados).",
                                "Clareza e completude: todos casos (não-determinismo, ε-moves) tratados.",
                                "Uso correto de notação teórica (configurações, δ).",
                                "Conclusão explícita de equivalência de linguagens.",
                                "Ausência de erros comuns como pop prematuro de Z0."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por indução estrutural em computações.",
                                "Lógica: Equivalências e invariantes em sistemas formais.",
                                "Programação: Simulação de PDAs em Python para verificação empírica.",
                                "Engenharia de Software: Parsers stack-based em compiladores.",
                                "Filosofia: Modelos formais de computação e limites."
                              ],
                              "realWorldApplication": "Essa equivalência permite unificar definições em compiladores e parsers (ex: Yacc usa stack para linguagens livres de contexto), facilitando provas de corretude em analisadores sintáticos de linguagens de programação."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1",
                              "10.1.5.3.2"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Provar conversão de AP por pilha vazia para estado final",
                            "description": "Desenvolver construção de AP'' a partir de AP por pilha vazia, modificando para detectar pilha vazia via um estado final único, provando equivalência de linguagens via simulações bidirecionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Autômatos de Pilha por Pilha Vazia e por Estado Final",
                                  "subSteps": [
                                    "Defina formalmente um AP por pilha vazia (AP_ε): conjunto de estados Q, alfabeto de entrada Σ, alfabeto da pilha Γ, função de transição δ, estado inicial q0 e aceitação quando pilha está vazia após leitura da entrada.",
                                    "Defina formalmente um AP por estado final (AP_f): similar, mas aceitação ocorre ao alcançar um estado em F ⊆ Q, independentemente da pilha.",
                                    "Compare as diferenças principais: AP_ε não tem estados finais explícitos, enquanto AP_f ignora o conteúdo da pilha no final.",
                                    "Estude exemplos simples de cada tipo para linguagens como {a^n b^n | n ≥ 0}."
                                  ],
                                  "verification": "Escreva as definições formais em um papel e identifique pelo menos duas diferenças chave entre AP_ε e AP_f.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Teoria da Computação (ex: Sipser), papel e lápis, acesso a notas de aula sobre autômatos de pilha.",
                                  "tips": "Use notação padrão (Q, Σ, Γ, δ, q0) para consistência nas definições.",
                                  "learningObjective": "Compreender as diferenças fundamentais nos mecanismos de aceitação de AP_ε e AP_f.",
                                  "commonMistakes": "Confundir aceitação por pilha vazia com pilha com símbolo especial; ignorar que AP_f permite pilha não vazia."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Formalmente o AP_f a partir de AP_ε",
                                  "subSteps": [
                                    "Crie um novo estado final único q_f não presente em Q.",
                                    "Modifique a transição δ para adicionar transições que, ao empilhar o último símbolo na pilha, permitam ir para q_f em vez de continuar normalmente.",
                                    "Garanta que AP_f simule AP_ε exatamente até o momento em que a pilha ficaria vazia em AP_ε, então transite para q_f.",
                                    "Defina o novo conjunto de estados Q' = Q ∪ {q_f}, F' = {q_f}, e ajuste δ' adequadamente para simular δ.",
                                    "Verifique que δ' preserva todas as transições originais de AP_ε."
                                  ],
                                  "verification": "Desenhe os diagramas de transição de AP_ε e AP_f lado a lado, confirmando que toda computação de AP_ε que esvazia a pilha corresponde a uma que atinge q_f em AP_f.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel quadriculado para diagramas de autômatos, software de desenho como Draw.io (opcional), exemplos de AP_ε de livros-texto.",
                                  "tips": "Introduza q_f apenas para entradas que levariam à pilha vazia; mantenha simulação fiel.",
                                  "learningObjective": "Dominar a construção padrão de AP_f equivalente a um dado AP_ε.",
                                  "commonMistakes": "Adicionar q_f prematuramente sem sincronizar com esvaziamento da pilha; esquecer transições para símbolos de pilha restantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar Inclusão L(AP_ε) ⊆ L(AP_f)",
                                  "subSteps": [
                                    "Assuma w ∈ L(AP_ε), significando que existe computação de AP_ε em w terminando com pilha vazia em q ∈ Q.",
                                    "Mostre por indução no comprimento de w que a computação correspondente em AP_f atinge q_f.",
                                    "Caso base: ε leva a pilha vazia imediatamente, transite para q_f.",
                                    "Passo indutivo: Toda transição preservada leva ao estado correto, e ao esvaziar pilha, vai para q_f.",
                                    "Conclua que w é aceito por AP_f ao atingir estado final."
                                  ],
                                  "verification": "Escreva a prova formal por indução, verificando casos base e indutivo explicitamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel para prova matemática, exemplos de sequências de configurações de AP.",
                                  "tips": "Use configurações (q, pilha) para rastrear simulações paralelas.",
                                  "learningObjective": "Aplicar indução para provar preservação de aceitação na direção AP_ε para AP_f.",
                                  "commonMistakes": "Falhar no caso base para ε; não lidar com loops que esvaziam pilha múltiplas vezes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Inclusão L(AP_f) ⊆ L(AP_ε) e Completar a Equivalência",
                                  "subSteps": [
                                    "Assuma w ∈ L(AP_f), significando computação atinge q_f com alguma pilha restante.",
                                    "Construa uma simulação reversa: desde q_f, reverta transições para mostrar que pilha pode ser esvaziada em AP_ε.",
                                    "Mostre que ao atingir q_f, a pilha em AP_f corresponde exatamente à vazia em AP_ε via construção.",
                                    "Use simulação bidirecional para provar igualdade de linguagens.",
                                    "Discuta generalizações e por que isso prova L(AP_ε) = L(AP_f)."
                                  ],
                                  "verification": "Escreva a prova reversa e confirme que L(AP_ε) = L(AP_f) para o AP construído.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Papel para provas bidirecionais, exemplo concreto de AP para {a^n b^n}.",
                                  "tips": "Pense em termos de simulações mutuamente reversíveis entre AP_ε e AP_f.",
                                  "learningObjective": "Completar a prova de equivalência via simulações bidirecionais.",
                                  "commonMistakes": "Ignorar pilha não vazia em AP_f; assumir unidirecionalidade sem reversa."
                                }
                              ],
                              "practicalExample": "Para AP_ε aceitando {a^n b^n | n ≥ 0}: estados {q0, q1}, empilha A em 'a', desempilha em 'b', aceita por pilha vazia em q1 após b's. Construa AP_f adicionando q_f: em transição que desempilharia último A (simulando vazia), vá para q_f. Simule w = aabb: AP_ε esvazia pilha em q1; AP_f atinge q_f.",
                              "finalVerifications": [
                                "Consegui definir formalmente AP_f a partir de AP_ε com q_f único.",
                                "Provei L(AP_ε) ⊆ L(AP_f) por indução sem falhas.",
                                "Provei L(AP_f) ⊆ L(AP_ε) via simulação reversa.",
                                "Verifiquei com exemplo {a^n b^n} que linguagens coincidem.",
                                "Identifiquei e corrigi erros comuns na construção.",
                                "Desenhei diagramas mostrando simulação bidirecional."
                              ],
                              "assessmentCriteria": [
                                "Precisão da construção formal de AP_f (transições corretas, q_f único).",
                                "Correção da prova por indução para ⊆ (casos base e indutivo claros).",
                                "Validade da simulação reversa para ⊇.",
                                "Uso correto de notação e configurações de AP.",
                                "Profundidade no exemplo prático com rastreamento de pilha.",
                                "Identificação de erros comuns e dicas preventivas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução matemática e teoria dos conjuntos para provas de inclusão.",
                                "Lógica: Raciocínio formal e simulações bidirecionais semelhantes a equivalências lógicas.",
                                "Engenharia de Software: Modelagem de parsers em compiladores usando PDAs equivalentes.",
                                "Filosofia da Ciência: Conceitos de equivalência computacional e modelos formais."
                              ],
                              "realWorldApplication": "Em compiladores, PDAs por estado final facilitam parsing LL(k) para linguagens context-free, permitindo aceitação sem verificação manual de pilha vazia, otimizando analisadores sintáticos em ferramentas como ANTLR ou Yacc."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1",
                              "10.1.5.3.2"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Aplicar equivalência em exemplos",
                            "description": "Converter um AP de aceitação por estado final para pilha vazia e vice-versa em um exemplo concreto, como balanced parentheses, verificando aceitação de strings iguais nos dois.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Autômato de Pilha (AP) original por aceitação por estado final",
                                  "subSteps": [
                                    "Desenhe o diagrama do AP para reconhecimento de parênteses balanceados usando aceitação por estado final.",
                                    "Identifique os estados iniciais, finais e transições, empilhando '(' e desempilhando com ')' .",
                                    "Especifique a pilha inicial vazia e o alfabeto de entrada { (, ) }.",
                                    "Teste manualmente uma string válida como (()) para confirmar aceitação no estado final.",
                                    "Anote todas as transições em uma tabela formal."
                                  ],
                                  "verification": "O diagrama está completo e aceita corretamente strings balanceadas terminando em estado final.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, tabela de transições em branco",
                                  "tips": "Use setas curvas para transições de pilha e destaque o estado inicial com seta de entrada.",
                                  "learningObjective": "Compreender a estrutura de um AP com aceitação por estado final para linguagens context-free.",
                                  "commonMistakes": "Esquecer transições para pilha vazia ou confundir pop com push."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter o AP por estado final para aceitação por pilha vazia",
                                  "subSteps": [
                                    "Adicione um novo símbolo de pilha inicial Z0 no fundo da pilha.",
                                    "Modifique o estado inicial para empilhar Z0 e transitar para o estado original inicial.",
                                    "Torne todos os estados originais não-finais; aceitação ocorre apenas quando pilha esvazia após Z0 removido.",
                                    "Ajuste transições para que pop de Z0 ocorra apenas em configurações aceitantes originais.",
                                    "Verifique o novo AP com a mesma string (()) para confirmar esvaziamento da pilha."
                                  ],
                                  "verification": "O novo AP aceita por pilha vazia a mesma string que o original por estado final.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama do Step 1, lápis para modificações",
                                  "tips": "Copie o diagrama original e marque mudanças em negrito para facilitar comparação.",
                                  "learningObjective": "Dominar a construção padrão de conversão adicionando símbolo bottom-of-stack.",
                                  "commonMistakes": "Não propagar Z0 corretamente ou manter estados finais ativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e converter um AP por pilha vazia de volta para estado final",
                                  "subSteps": [
                                    "Comece com o AP do Step 2 (pilha vazia) como base.",
                                    "Crie um novo estado final F que é acessível apenas quando pilha esvazia, simulando aceitação.",
                                    "Adicione transições ε de estados relevantes para F após pop final de Z0.",
                                    "Remova aceitação por pilha vazia e defina F como único estado final.",
                                    "Simule passo a passo com string inválida )) para rejeição."
                                  ],
                                  "verification": "A conversão reversa produz um AP equivalente ao original do Step 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagramas anteriores, software de desenho opcional como Draw.io",
                                  "tips": "Use ε-transições para conectar ao estado final sem consumir entrada.",
                                  "learningObjective": "Entender a simetria da equivalência entre os dois mecanismos de aceitação.",
                                  "commonMistakes": "Adicionar loops infinitos com ε ou ignorar rejeição de strings inválidas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar equivalência testando strings idênticas nos dois APs",
                                  "subSteps": [
                                    "Selecione 3 strings: válida balanceada ((())), inválida desbalanceada (()), e vazia ε.",
                                    "Execute simulação paralela nos dois APs para cada string, rastreando configuração (estado, pilha, resto entrada).",
                                    "Registre aceitação/rejeição para cada: estado final vs. pilha vazia.",
                                    "Compare resultados e identifique qualquer discrepância.",
                                    "Documente em tabela: String | AP1 Aceita? | AP2 Aceita? | Configuração Final."
                                  ],
                                  "verification": "Todas as strings têm aceitação idêntica nos dois APs convertidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabelas de simulação, strings de teste escritas",
                                  "tips": "Simule na mão com pilha física (folhas de papel) para visualização.",
                                  "learningObjective": "Aplicar testes empíricos para validar teoremas de equivalência.",
                                  "commonMistakes": "Erros de contagem de parênteses ou esquecer ε no final da entrada."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e generalizar a equivalência",
                                  "subSteps": [
                                    "Explique por que as conversões preservam o poder de reconhecimento da linguagem.",
                                    "Discuta limitações: APs determinísticos vs. não-determinísticos.",
                                    "Crie um fluxograma resumindo as regras de conversão bidirecional.",
                                    "Teste uma string adicional complexa como (()(())) para robustez.",
                                    "Escreva uma declaração formal de equivalência para o exemplo."
                                  ],
                                  "verification": "Fluxograma e declaração capturam corretamente a equivalência observada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Resumo dos Steps anteriores",
                                  "tips": "Use teorema padrão: Todo AP por estado final ≡ por pilha vazia.",
                                  "learningObjective": "Generalizar o exemplo para qualquer AP, preparando para provas formais.",
                                  "commonMistakes": "Confundir com APs determinísticos, onde equivalência pode falhar."
                                }
                              ],
                              "practicalExample": "Para o AP de parênteses balanceados: Converta o AP1 (aceita em qf após processar (())) para AP2 (pilha vazia após Z0 pop). Teste string (()) : AP1 termina em qf com pilha possivelmente não vazia; AP2 esvazia pilha exatamente. Inverso: AP2 para AP1' com novo qf'. Ambas aceitam/rejeitam ((())), (()), )) igualmente.",
                              "finalVerifications": [
                                "AP convertido aceita todas as strings balanceadas por pilha vazia iff original por estado final.",
                                "AP reverso converte de volta ao original sem perda de linguagem.",
                                "Simulações de 5+ strings (válidas/inválidas) mostram aceitação idêntica.",
                                "Diagramas incluem Z0 corretamente sem loops infinitos.",
                                "Tabela de transições formais bate com desenhos.",
                                "Declaração escrita prova equivalência para o exemplo específico."
                              ],
                              "assessmentCriteria": [
                                "Precisão das transições de pilha (push/pop/ε) em ambos APs (80% correto).",
                                "Correção das simulações em strings de teste (todas iguais).",
                                "Completude dos diagramas com estados, transições e símbolos de pilha.",
                                "Explicação clara da regra de conversão (Z0 e ε-transições).",
                                "Identificação e correção de erros comuns como pilha não esvaziada.",
                                "Generalização para outras linguagens context-free simples."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equivalências em teoria dos conjuntos e autômatos finitos.",
                                "Programação: Parsing de expressões em compiladores (stack-based).",
                                "Lógica: Verificação de propriedades em sistemas formais.",
                                "Engenharia de Software: Modelagem de estados em verificadores de sintaxe."
                              ],
                              "realWorldApplication": "Em compiladores e parsers (ex: JSON/XML validation), onde stacks verificam balanceamento de tags/chaves, permitindo otimização de memória ao esvaziar pilha vs. checar estados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.3.1",
                              "10.1.5.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Linguagens Reconhecidas por Autômatos de Pilha",
                    "description": "Teorema que relaciona autômatos de pilha às linguagens livres de contexto.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Definição de Linguagens Reconhecidas por Autômatos de Pilha",
                        "description": "Compreensão formal das linguagens aceitas por autômatos de pilha (AP), incluindo AP determinísticos e não-determinísticos, e o papel da pilha na aceitação de strings.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Definir formalmente uma linguagem reconhecida por AP",
                            "description": "Explicar a definição formal de um autômato de pilha (AP) como um septeto (Q, Σ, Γ, δ, q0, Z0, F) e descrever como uma linguagem L ⊆ Σ* é reconhecida por aceitação por estado final ou por pilha vazia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal do Autômato de Pilha (AP)",
                                  "subSteps": [
                                    "Estude a estrutura básica de um AP como um septeto: (Q, Σ, Γ, δ, q0, Z0, F).",
                                    "Identifique Q como o conjunto finito de estados.",
                                    "Defina Σ como o alfabeto de entrada.",
                                    "Explique Γ como o alfabeto da pilha.",
                                    "Descreva q0 como o estado inicial e Z0 como o símbolo inicial da pilha."
                                  ],
                                  "verification": "Liste corretamente os 7 componentes do septeto e seus significados em um papel ou documento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Teoria da Computação ou notas de aula sobre autômatos; quadro branco ou editor de texto.",
                                  "tips": "Use mnemônicos para lembrar a ordem: Q Σ Γ δ q0 Z0 F.",
                                  "learningObjective": "Compreender os componentes constitutivos de um AP.",
                                  "commonMistakes": "Confundir Σ (entrada) com Γ (pilha); esquecer que Q é finito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a função de transição δ",
                                  "subSteps": [
                                    "Defina δ: Q × (Σ ∪ {ε}) × Γ → 2^{Q × Γ*} , explicando que é uma função parcial.",
                                    "Analise como δ processa entrada, topo da pilha e estado atual.",
                                    "Estude transições com ε (vazio) para entrada ou pilha.",
                                    "Exemplo: δ(q, a, Z) = {(p, YZ)} significa ir para p, pop Z e push YZ.",
                                    "Pratique notação formal com um exemplo simples."
                                  ],
                                  "verification": "Escreva a assinatura formal de δ e dê um exemplo de transição válida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de APs de livros ou online (ex: Sipser); simulador de AP opcional.",
                                  "tips": "Pense em δ como uma 'regra de movimento' que consulta estado, input e pilha.",
                                  "learningObjective": "Dominar a mecânica da função de transição em APs.",
                                  "commonMistakes": "Esquecer o 2^ (poder de conjunto) ou confundir pop/push na notação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender aceitação por estado final",
                                  "subSteps": [
                                    "Defina F ⊆ Q como estados finais.",
                                    "Explique que uma string w é aceita se, após processar w, o AP está em q ∈ F (pilha pode ter conteúdo).",
                                    "Trace um exemplo: configuração (q, w, γ) leva a aceitação.",
                                    "Diferencie de AFDs: pilha permite memória não-linear.",
                                    "Formalize L(AP) = {w ∈ Σ* | δ̂(q0, w, Z0) contém (q, ε, α) com q ∈ F}."
                                  ],
                                  "verification": "Simule aceitação de uma string curta por estado final em um AP simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para traçar configurações; exemplos de palíndromos.",
                                  "tips": "Desenhe configurações como triplas (estado, resto-input, pilha).",
                                  "learningObjective": "Compreender o critério de aceitação por estado final.",
                                  "commonMistakes": "Ignorar que a pilha não precisa estar vazia nesse modo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aprender aceitação por pilha vazia",
                                  "subSteps": [
                                    "Defina aceitação quando, após processar w, a pilha está vazia (ε).",
                                    "Formalize: w aceita se δ̂(q0, w, Z0) contém (q, ε, ε) para algum q.",
                                    "Compare com estado final: aqui F pode ser Q inteiro.",
                                    "Exemplo: AP que reconhece {a^n b^n} por pilha vazia.",
                                    "Note que linguagens são equivalentes em poder."
                                  ],
                                  "verification": "Explique a diferença e dê formalização para ambos os modos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas comparativas; simulador de pilha.",
                                  "tips": "Lembre: pilha vazia é mais 'purista' para context-free.",
                                  "learningObjective": "Distinguir e formalizar os dois modos de aceitação.",
                                  "commonMistakes": "Confundir os modos ou achar que pilha vazia requer estado específico."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Formalizar a linguagem reconhecida por um AP",
                                  "subSteps": [
                                    "Defina L(AP) ⊆ Σ* como o conjunto de strings aceitas por AP.",
                                    "Especifique: 'L é reconhecida por AP se existe AP tal que L = L(AP)'.",
                                    "Integre septeto e modos: L(AP) depende do modo escolhido.",
                                    "Pratique: 'A linguagem de palíndromos pares é reconhecida por AP tal que...'",
                                    "Verifique propriedades: fechamento sob complemento? Não."
                                  ],
                                  "verification": "Escreva a definição completa de 'linguagem reconhecida por AP' usando o septeto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de exercícios; referência formal (ex: Hopcroft-Ullman).",
                                  "tips": "Sempre especifique o modo de aceitação na definição.",
                                  "learningObjective": "Sintetizar a definição formal completa de uma linguagem reconhecida por AP.",
                                  "commonMistakes": "Omitir o modo de aceitação ou errar a notação de L ⊆ Σ*."
                                }
                              ],
                              "practicalExample": "Defina formalmente que a linguagem L = { ww^R | w ∈ {a,b}* } (palíndromos pares sobre {a,b}) é reconhecida por um AP M = (Q, {a,b}, {a,b,Z0}, δ, q0, Z0, {qf}) por aceitação por estado final, descrevendo brevemente δ para empilhar w e desempilhar comparando com w^R.",
                              "finalVerifications": [
                                "Pode recitar o septeto (Q, Σ, Γ, δ, q0, Z0, F) sem erros.",
                                "Explica corretamente os dois modos de aceitação com exemplos.",
                                "Formaliza L(AP) para um AP dado.",
                                "Distingue AP de AFDs pela pilha.",
                                "Identifica erros comuns em definições formais.",
                                "Aplica a definição a uma linguagem simples como {a^n b^n}."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal do septeto e δ.",
                                "Clareza na distinção entre aceitação por estado final e pilha vazia.",
                                "Correção na definição de L ⊆ Σ* reconhecida por AP.",
                                "Uso apropriado de símbolos matemáticos (ex: δ̂ para fechamento).",
                                "Capacidade de integrar componentes em uma definição coesa.",
                                "Exemplos relevantes e sem ambiguidades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções parciais.",
                                "Lógica: Autômatos como modelos computacionais formais.",
                                "Programação: Parsing em compiladores (ex: LL parsers usam pilhas).",
                                "Linguística: Gramáticas context-free e análise sintática."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, APs modelam analisadores sintáticos para linguagens de programação context-free, como expressões balanceadas em Python ou Java, validando estruturas como chaves {} ou parênteses () em código fonte."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Diferenciar APND e APD",
                            "description": "Comparar autômatos de pilha não-determinísticos (APND) e determinísticos (APD), destacando que APND reconhecem todas as linguagens de APD, mas nem todas as linguagens de APND são reconhecidas por APD.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de APND e APD",
                                  "subSteps": [
                                    "Ler a definição formal de Autômato de Pilha Não-Determinístico (APND): conjunto de estados, alfabeto, pilha, transições múltiplas possíveis.",
                                    "Ler a definição formal de Autômato de Pilha Determinístico (APD): transições únicas para cada configuração (estado, símbolo de entrada, topo da pilha).",
                                    "Identificar componentes comuns: estados Q, alfabeto Σ, símbolos de pilha Γ, função de transição δ.",
                                    "Destacar diferenças iniciais: δ_APND ⊆ Q × (Σ∪{ε}) × Γ → fin( Q × Γ* ), δ_APD: Q × (Σ∪{ε}) × Γ → Q × Γ*.",
                                    "Anotar exemplos simples de configurações iniciais para ambos."
                                  ],
                                  "verification": "Escrever definições formais em um papel ou documento e confirmar que distinguem múltiplas transições (APND) vs única (APD).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Teoria da Computação (ex: Sipser), notas de aula, quadro branco.",
                                  "tips": "Use diagramas para visualizar transições; comece com APND para entender não-determinismo.",
                                  "learningObjective": "Compreender as estruturas formais básicas de APND e APD.",
                                  "commonMistakes": "Confundir pilha com fita (confundir com MT); ignorar ε-transições em APD."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Diferenças no Comportamento e Transições",
                                  "subSteps": [
                                    "Simular uma transição APND com ramificações não-determinísticas em um exemplo simples como palíndromos pares.",
                                    "Simular a mesma entrada em APD, notando restrição a uma única transição.",
                                    "Comparar poder expressivo: todo APD é APND (simular determinismo com não-determinismo trivial).",
                                    "Discutir aceitação por estado final vs pilha vazia para ambos.",
                                    "Listar propriedades: APND pode 'adivinhar' caminhos corretos; APD deve decidir unicamente."
                                  ],
                                  "verification": "Executar simulação manual de 2-3 strings em ambos autômatos e registrar caminhos tomados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador online de autômatos (ex: JFLAP), papel para desenhar diagramas de transição.",
                                  "tips": "Desenhe árvores de computação para APND para visualizar ramificações.",
                                  "learningObjective": "Identificar como o não-determinismo afeta o comportamento operacional.",
                                  "commonMistakes": "Assumir que APD pode ter ε-transições livres como APND; esquecer que APD rejeita se transição indefinida."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Hierarquia de Linguagens Reconhecidas",
                                  "subSteps": [
                                    "Provar que L(APD) ⊆ L(APND): construir APND que simula APD.",
                                    "Estudar exemplo de linguagem em L(APND) \\ L(APD), como { ww^R | w ∈ {a,b}* } (palíndromos ímpares centrados).",
                                    "Analisar por que DCFL (Deterministic CFL) são propriamente contidos em CFL.",
                                    "Revisar teoremas: todo DCFL aceito por DPDA por estado final; CFL por PDA por pilha vazia.",
                                    "Classificar linguagens conhecidas: {a^n b^n} em ambos; ww^R só em APND."
                                  ],
                                  "verification": "Escrever prova informal da inclusão e esboçar APND para linguagem não-DCFL.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "JFLAP ou papel para construir autômatos, tabela de linguagens CFL/DCFL.",
                                  "tips": "Use contra-exemplos para mostrar não-equivalência; memorize ww^R como clássico não-DCFL.",
                                  "learningObjective": "Dominar a relação de inclusão estrita L(APD) ⊂ L(APND).",
                                  "commonMistakes": "Pensar que todas CFL são DCFL; confundir aceitação por pilha vazia com estado final."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceitos em Exemplos e Contra-Exemplos",
                                  "subSteps": [
                                    "Construir APND para {a^n b^n c^n} (não CFL, mas reforçar limites).",
                                    "Converter APD simples para APND e vice-versa quando possível.",
                                    "Testar strings em autômatos existentes e prever aceitação.",
                                    "Discutir normalizações: APND em forma normal (aceitação por estado final).",
                                    "Resumir tabela comparativa: poder, determinismo, aplicações."
                                  ],
                                  "verification": "Criar tabela comparativa com 5 diferenças chave e 2 exemplos de linguagens.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta JFLAP, exemplos de linguagens de referências acadêmicas.",
                                  "tips": "Sempre teste com strings específicas para validar construções.",
                                  "learningObjective": "Aplicar diferenças para classificar linguagens e autômatos.",
                                  "commonMistakes": "Ignorar ambiguidade em APND; superestimar poder de APD."
                                }
                              ],
                              "practicalExample": "Considere a linguagem de palíndromos pares { ww^R | w ∈ {a,b}* }. Um APND pode não-determinísticamente adivinhar o centro e combinar símbolos da entrada com pilha. Um APD falha porque não pode decidir quando inverter sem ambiguidade determinística, provando L(APND) ⊃ L(APD). Simule 'ab ba' em ambos.",
                              "finalVerifications": [
                                "Explicar verbalmente por que todo APD é APND, mas não inverso.",
                                "Classificar {a^n b^n} como DCFL e ww^R como CFL não-DCFL.",
                                "Desenhar δ para transição não-determinística vs determinística.",
                                "Provar inclusão com construção de autômato.",
                                "Identificar 3 diferenças estruturais principais.",
                                "Simular aceitação/rejeição de string exemplo em APND/APD."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (δ, componentes).",
                                "Compreensão correta da inclusão estrita de linguagens.",
                                "Uso correto de exemplos e contra-exemplos clássicos.",
                                "Habilidade em simular execuções manualmente.",
                                "Identificação de erros comuns em não-determinismo.",
                                "Clareza na tabela comparativa e provas informais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e relações de inclusão.",
                                "Lógica: Não-determinismo como busca em árvores de decisão.",
                                "Programação: Parsers LL/LR (determinísticos) vs parsers não-determinísticos.",
                                "Engenharia de Software: Análise de complexidade em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores, APD (DPDA) são usados para parsers determinísticos eficientes como LR(1) para linguagens de programação sem ambiguidade; APND modelam parsers mais poderosos para linguagens context-free ambíguas, auxiliando em ferramentas de análise sintática como ANTLR."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Identificar exemplos de linguagens de AP",
                            "description": "Reconhecer linguagens como {a^n b^n | n ≥ 0} ou palíndromos sobre {a,b} como exemplos clássicos reconhecidos por AP, e contrastar com linguagens regulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Linguagens Regulares",
                                  "subSteps": [
                                    "Relembre a definição de autômatos finitos determinísticos (AFD) e não-determinísticos (AFN).",
                                    "Liste propriedades das linguagens regulares, como fechamento sob união, concatenação e estrela de Kleene.",
                                    "Estude o lema do bombeamento para linguagens regulares.",
                                    "Identifique exemplos clássicos de linguagens regulares, como (a|b)* ou a* b.",
                                    "Pratique convertendo expressões regulares em AFDs simples."
                                  ],
                                  "verification": "Construa um AFD para uma linguagem regular simples e teste com 3 strings.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser ou similar), papel e caneta, simulador de autômatos online (ex: JFLAP).",
                                  "tips": "Desenhe diagramas de estados para visualizar transições claramente.",
                                  "learningObjective": "Compreender as limitações das linguagens regulares para preparar o contraste com linguagens de AP.",
                                  "commonMistakes": "Confundir linguagens regulares com context-free sem usar teoremas de decisão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Exemplos Clássicos de Linguagens de AP",
                                  "subSteps": [
                                    "Defina formalmente a linguagem {a^n b^n | n ≥ 0} e explique por que requer memória (pilha).",
                                    "Descreva um autômato de pilha (AP) não-determinístico que reconhece {a^n b^n}.",
                                    "Analise a linguagem de palíndromos pares sobre {a,b}, como ww^R onde w em {a,b}*.",
                                    "Liste outros exemplos: {a^n b^n c^n | n ≥ 0} (não-AP, mas context-free).",
                                    "Simule manualmente o AP em strings como 'aabb' ou 'ab'."
                                  ],
                                  "verification": "Desenhe o diagrama de um AP para {a^n b^n} e simule aceitação/rejeição de 2 strings.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "JFLAP ou Draw.io para diagramas de AP, exemplos de strings impressos.",
                                  "tips": "Use símbolos de pilha como Z0 (fundo), A e B para empilhar/desempilhar.",
                                  "learningObjective": "Reconhecer linguagens que dependem de empilhamento/desempilhamento igual.",
                                  "commonMistakes": "Esquecer o estado inicial/final ou transições epsilon."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar Linguagens de AP com Regulares",
                                  "subSteps": [
                                    "Aplique o lema do bombeamento regular à {a^n b^n} para provar que não é regular.",
                                    "Explique por que palíndromos requerem pilha para comparar lados simetricamente.",
                                    "Compare com linguagens regulares: mostre que {a^n b^m | n,m ≥ 0} é regular.",
                                    "Discuta a hierarquia de Chomsky: regulares ⊂ context-free (AP reconhece DCFL).",
                                    "Resolva exercícios: classifique 5 linguagens como regular ou AP."
                                  ],
                                  "verification": "Prove usando lema do bombeamento que {a^n b^n} não é regular.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Folhas de exercícios de teoria da computação, calculadora para contagens grandes.",
                                  "tips": "Escolha i=1 no bombeamento para gerar desigualdade de a's e b's.",
                                  "learningObjective": "Diferenciar matematicamente linguagens de AP das regulares.",
                                  "commonMistakes": "Aplicar lema incorretamente, ignorando a posição do bombeamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Verificação",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: exemplos regulares vs. AP vs. não-context-free.",
                                    "Teste strings em AP simulados: aceite 'aabbb' em {a^n b^n}? Não.",
                                    "Construa AP para palíndromos e teste 'aba' ou 'abba'.",
                                    "Resolva problemas: 'É {a^n b^n c^m} uma linguagem de AP?'.",
                                    "Autoavalie com quiz de 10 questões sobre identificação."
                                  ],
                                  "verification": "Classifique corretamente 5 linguagens dadas como regular, AP ou outra.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Quiz impresso ou online (ex: de universidades), timer.",
                                  "tips": "Sempre pergunte: 'Precisa contar igualdades dependentes?' -> AP.",
                                  "learningObjective": "Aplicar conhecimento para identificar exemplos de linguagens de AP autonomamente.",
                                  "commonMistakes": "Classificar {a^n b^n c^n} como AP (é context-free, mas não determinístico AP)."
                                }
                              ],
                              "practicalExample": "Dado o alfabeto {a,b}, construa um AP para reconhecer {a^n b^n | n ≥ 0}. Simule a string 'aaabbb': empilhe 3 A's ao ler 'aaa', desempilhe ao ler 'bbb', aceite vazio na pilha.",
                              "finalVerifications": [
                                "Lista pelo menos 3 exemplos clássicos de linguagens de AP ({a^n b^n}, palíndromos pares, {a^n b a^n}).",
                                "Prova usando lema do bombeamento que {a^n b^n} não é regular.",
                                "Desenha e simula um AP correto para {a^n b^n} com 2 strings de teste.",
                                "Diferencia corretamente 5 linguagens como regular ou não-regular.",
                                "Explica o papel da pilha em linguagens de AP.",
                                "Identifica limitações: linguagens como {a^n b^n c^n} não são AP determinísticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de exemplos clássicos de AP (90% correto).",
                                "Correta aplicação do lema do bombeamento em provas (sem erros lógicos).",
                                "Diagramas de AP completos com estados, transições e símbolos de pilha.",
                                "Simulações manuais precisas de strings em AP.",
                                "Contraste claro com linguagens regulares via exemplos e teoremas.",
                                "Criatividade em exemplos práticos e conexões hierárquicas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e indução para provas de n igual.",
                                "Lógica: Equivalência entre AP e gramáticas livres de contexto.",
                                "Programação: Parsing de expressões balanceadas (parênteses) em compiladores.",
                                "Algoritmos: Uso de pilhas em estruturas de dados para simular AP."
                              ],
                              "realWorldApplication": "Em compiladores, autômatos de pilha verificam balanceamento de chaves/parênteses em código-fonte, como {a^n b^n} modela matching de tags XML ou expressões aritméticas aninhadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Linguagens Livres de Contexto (LLC)",
                        "description": "Fundamentos das linguagens geradas por gramáticas livres de contexto (GLC), preparando o terreno para a equivalência com linguagens de AP.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Definir linguagens livres de contexto",
                            "description": "Descrever uma LLC como o conjunto de sentenças derivadas de uma gramática de Chomsky tipo-2, com produções na forma A → α onde A é um não-terminal e α é uma cadeia de terminais e não-terminais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Gramáticas Formais",
                                  "subSteps": [
                                    "Estude a hierarquia de Chomsky, focando no Tipo-2 (Context-Free Grammars - CFG).",
                                    "Identifique os componentes básicos: alfabeto de terminais (V_T), não-terminais (V_N), axioma (S) e conjunto de produções (P).",
                                    "Revise exemplos simples de gramáticas regulares (Tipo-3) para contrastar com CFG.",
                                    "Anote as diferenças chave entre gramáticas contextuais e livres de contexto.",
                                    "Pratique identificando terminais e não-terminais em uma gramática dada."
                                  ],
                                  "verification": "Liste corretamente os quatro componentes de uma CFG com um exemplo simples.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Notas ou quadro branco",
                                    "Vídeo introdutório sobre hierarquia de Chomsky"
                                  ],
                                  "tips": "Use diagramas para visualizar a hierarquia; comece com exemplos familiares como expressões aritméticas.",
                                  "learningObjective": "Dominar os componentes constitutivos de uma gramática livre de contexto.",
                                  "commonMistakes": [
                                    "Confundir terminais com não-terminais",
                                    "Ignorar o axioma como ponto de partida",
                                    "Misturar com gramáticas regulares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Forma das Produções em CFG",
                                  "subSteps": [
                                    "Aprenda a notação padrão: A → α, onde A ∈ V_N e α ∈ (V_N ∪ V_T)*.",
                                    "Identifique restrições: lado esquerdo deve ser um único não-terminal.",
                                    "Classifique produções em unitárias (A → B) e não-unitárias (A → aB ou A → ε).",
                                    "Escreva 3 exemplos de produções válidas e 2 inválidas, explicando por quê.",
                                    "Verifique se uma gramática dada segue as regras de Chomsky Tipo-2."
                                  ],
                                  "verification": "Escreva uma produção inválida e corrija-a para torná-la CFG válida.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Folha de exercícios com gramáticas",
                                    "Ferramenta online de gramáticas formais",
                                    "Caneta e papel"
                                  ],
                                  "tips": "Lembre-se: o contexto à esquerda é 'livre', sem dependência de outros símbolos.",
                                  "learningObjective": "Reconhecer e construir produções conformes à definição de CFG.",
                                  "commonMistakes": [
                                    "Permitir múltiplos não-terminais no lado esquerdo",
                                    "Confundir ε-produções com loops infinitos",
                                    "Usar apenas terminais no lado direito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Processo de Derivação de Sentenças",
                                  "subSteps": [
                                    "Entenda derivações lineares: aplicar produções sequencialmente a partir do axioma.",
                                    "Diferencie derivações de esquerda para direita e de qualquer posição.",
                                    "Simule uma derivação para gerar uma sentença específica em uma CFG simples.",
                                    "Identifique árvores de derivação como representação gráfica.",
                                    "Discuta terminais de derivação (sem não-terminais restantes)."
                                  ],
                                  "verification": "Gere uma sentença passo a passo a partir de S usando uma CFG dada.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas impressas",
                                    "Software de desenho de árvores (ex: Draw.io)",
                                    "Vídeos sobre derivações em CFG"
                                  ],
                                  "tips": "Sempre marque o símbolo atual com underline para rastrear derivações.",
                                  "learningObjective": "Executar e visualizar derivações em gramáticas livres de contexto.",
                                  "commonMistakes": [
                                    "Aplicar produções em ordem errada",
                                    "Gerar loops infinitos sem detectar",
                                    "Confundir derivação com reconhecimento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Formalmente Linguagens Livres de Contexto",
                                  "subSteps": [
                                    "Defina L(G) = {w ∈ V_T* | S ⇒* w, onde ⇒* é derivação em zero ou mais passos}.",
                                    "Explique que LLC é gerada por CFG, sem ambiguidades na definição.",
                                    "Compare com linguagens regulares: LLC podem aninhar estruturas (ex: parênteses).",
                                    "Forneça uma definição completa em suas palavras, incluindo todos os elementos.",
                                    "Teste a definição com um exemplo não-LLC (ex: {a^n b^n c^n})."
                                  ],
                                  "verification": "Escreva a definição formal de LLC e aplique-a a uma gramática exemplo.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Resumo da definição de LLC",
                                    "Quiz online sobre linguagens formais"
                                  ],
                                  "tips": "Memorize a fórmula L(G) para respostas rápidas em provas.",
                                  "learningObjective": "Articular a definição precisa de uma linguagem livre de contexto.",
                                  "commonMistakes": [
                                    "Definir LLC como 'qualquer CFG'",
                                    "Omitir o papel das derivações",
                                    "Confundir geração com reconhecimento por AP"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a gramática G = ({S}, {a,b}, S, {S → aSb | ε}). As derivações como S ⇒ aSb ⇒ aεb = ab geram L(G) = {a^n b^n | n ≥ 0}, uma LLC clássica de strings balanceadas.",
                              "finalVerifications": [
                                "Explique verbalmente a definição de LLC usando a notação formal.",
                                "Identifique se uma gramática dada é Tipo-2.",
                                "Gere uma sentença de uma CFG simples.",
                                "Distinga LLC de linguagens contextuais.",
                                "Forneça um exemplo de LLC não-regular.",
                                "Desenhe uma árvore de derivação básica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação A → α e componentes de CFG (peso: 30%).",
                                "Correta descrição do processo de derivação (peso: 25%).",
                                "Definição formal completa de L(G) (peso: 20%).",
                                "Exemplos relevantes e não-triviais (peso: 15%).",
                                "Ausência de confusões com outros tipos de gramáticas (peso: 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Análise sintática de frases naturais.",
                                "Compiladores: Fase de parsing em linguagens de programação.",
                                "Inteligência Artificial: Modelagem de estruturas hierárquicas em PLN.",
                                "Matemática: Teoria de conjuntos e relações recursivas."
                              ],
                              "realWorldApplication": "Em compiladores como GCC ou parsers de JSON/XML, LLCs definem a sintaxe de linguagens de programação e dados, permitindo análise eficiente de estruturas aninhadas como blocos de código ou árvores de documentos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Reconhecer propriedades das LLC",
                            "description": "Listar propriedades como fechamento sob união, concatenação e Kleene, mas não sob interseção ou complemento, e citar o lema do bombeamento para LLC.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar propriedades de fechamento positivas das LLC",
                                  "subSteps": [
                                    "Revise as definições de união, concatenação e fechamento de Kleene para linguagens formais.",
                                    "Aprenda que LLC são fechadas sob união: se L1 e L2 são LLC, então L1 ∪ L2 é LLC, provado via construção de AP não-determinístico.",
                                    "Entenda fechamento sob concatenação: L1 ⋅ L2 é LLC, usando estados que simulam APs sequencialmente.",
                                    "Memorize fechamento sob estrela de Kleene: L* é LLC, com ε-transições e loops no AP.",
                                    "Pratique com exemplos simples, como L1 = {a^n b^n} e L2 = {c^m d^m}, mostrando L1 ∪ L2."
                                  ],
                                  "verification": "Liste corretamente as três operações e dê um esboço de prova para cada uma sem consultar notas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to Automata Theory' de Hopcroft e Ullman (cap. 7)",
                                    "Notas de aula sobre APs",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Desenhe os autômatos de pilha (AP) para visualizar as construções; comece com união que é a mais intuitiva.",
                                  "learningObjective": "Identificar e explicar por que LLC são fechadas sob união, concatenação e Kleene.",
                                  "commonMistakes": [
                                    "Confundir fechamento com reconhecimento (fechamento é sobre classes de linguagens), esquecer de mencionar não-determinismo nos APs."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar propriedades de não-fechamento das LLC",
                                  "subSteps": [
                                    "Estude por que LLC não são fechadas sob interseção: exemplo {a^n b^n c^n | n ≥ 0} não é LLC, mas interseção de duas LLC.",
                                    "Aprenda sobre complemento: o complemento de {a^n b^n | n ≥ 0} é LLC, mas em geral não (use propriedades de linguagens regulares para contrastar).",
                                    "Construa contra-exemplos: mostre que interseção de {a^n b^n} e {b^n c^n} dá {a^n b^n c^n}, que requer dois contadores.",
                                    "Discuta teoremas: Ogden's lemma ou bombeamento para provar não-LLC.",
                                    "Compare com linguagens regulares, que são fechadas sob todas essas operações."
                                  ],
                                  "verification": "Forneça um contra-exemplo específico para interseção e complemento, explicando por quê não é LLC.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Sipser 'Introduction to the Theory of Computation' (cap. 2.3)",
                                    "Exemplos online de linguagens {a^n b^n c^n}",
                                    "Simulador de AP opcional"
                                  ],
                                  "tips": "Sempre use o lema do bombeamento para provar que um contra-exemplo não é LLC; memorize {a^n b^n c^n} como exemplo clássico.",
                                  "learningObjective": "Reconhecer e justificar por que LLC falham em fechamento sob interseção e complemento.",
                                  "commonMistakes": [
                                    "Achar que todo complemento de LLC é LLC (contra-exemplo: complemento de {ww | w em {a,b}*}); ignorar necessidade de dois contadores independentes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender e citar o Lema do Bombeamento para LLC",
                                  "subSteps": [
                                    "Leia a enunciação precisa: Para toda LLC L e w em L com |w| ≥ p (constante de bombeamento), w = uvxyz com |vxy| ≤ p, |vy| ≥ 1, e uv^k x y^k z em L para todo k ≥ 0.",
                                    "Entenda as partes: u, v, x, y, z onde v e y vão para a pilha.",
                                    "Diferencie do lema para linguagens regulares (sem pilha).",
                                    "Pratique bombeando palavras como w = a^n b^n em {a^n b^n}, mostrando vxy na região a* ou b*.",
                                    "Aplique para provar não-LLC: para {a^n b^n c^n}, qualquer bombeamento viola contagens iguais."
                                  ],
                                  "verification": "Escreva o lema verbatim e aplique-o a um exemplo simples como {a^n b^n}.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Notas sobre teorema de bombeamento para LLC",
                                    "Vídeo explicativo no YouTube (busque 'pumping lemma context-free')",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Lembre: pilha permite v e y serem 'empilhados/desempilhados'; pratique com desenhos da pilha durante bombeamento.",
                                  "learningObjective": "Citar corretamente o lema do bombeamento e usá-lo para caracterizar LLC.",
                                  "commonMistakes": [
                                    "Confundir com lema de Starling para regulares (3 partes: xyz); esquecer |vxy| ≤ p ou k ≥ 0."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar propriedades e praticar reconhecimento",
                                  "subSteps": [
                                    "Liste todas as propriedades: fechadas: união, concatenação, Kleene; não: interseção, complemento.",
                                    "Crie uma tabela comparativa com linguagens regulares e recursivas.",
                                    "Resolva exercícios: dado L1 e L2 LLC, é L1 ∩ L2 LLC? Por quê?",
                                    "Aplique lema do bombeamento em 2-3 linguagens duvidosas.",
                                    "Discuta implicações: por que isso importa para parsing em compiladores."
                                  ],
                                  "verification": "Responda a um quiz com 5 perguntas sobre propriedades e lema sem erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de exercícios de propriedades de LLC",
                                    "Quiz autoavaliativo impresso"
                                  ],
                                  "tips": "Use mnemônicos: 'UCK sim, IC não' (União, Concatenação, Kleene sim; Interseção, Complemento não).",
                                  "learningObjective": "Reconhecer holisticamente as propriedades chave das LLC.",
                                  "commonMistakes": [
                                    "Generalizar demais: nem todo complemento falha, mas a classe não é fechada."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere L1 = {a^n b^n | n ≥ 0} e L2 = {c^m d^m | m ≥ 0}, ambas LLC. Mostre que L1 ∪ L2 é LLC construindo um AP com branches; L1 ⋅ L2 também. Mas L1 ∩ {a^n c^n | n ≥ 0} = vazio (trivial), use {a^n b^n} ∩ {a^n c^n} = {a^n b^n c^n? não}. Bombeie w=abc em {a^n b^n c^n} para mostrar não LLC.",
                              "finalVerifications": [
                                "Liste corretamente as 3 propriedades de fechamento e 2 de não-fechamento.",
                                "Cite o lema do bombeamento sem erros na enunciação.",
                                "Forneça um contra-exemplo válido para interseção de LLC não sendo LLC.",
                                "Prove usando bombeamento que {a^n b^n c^n} não é LLC.",
                                "Explique diferença entre fechamento de LLC e linguagens regulares.",
                                "Crie uma linguagem LLC e aplique Kleene star manualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem de propriedades (100% correto).",
                                "Correta enunciação e aplicação do lema do bombeamento.",
                                "Qualidade dos contra-exemplos e provas (lógicos e concisos).",
                                "Compreensão de construções de AP para fechamentos positivos.",
                                "Capacidade de integrar propriedades em argumentos coerentes.",
                                "Ausência de confusões com outras classes de linguagens."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e operações de fechamento.",
                                "Lógica: Lemas de bombeamento semelhantes a teoremas de incompletude.",
                                "Engenharia de Software: Parsing de gramáticas livres de contexto em compiladores.",
                                "Algoritmos: Simulação de pilha em estruturas de dados."
                              ],
                              "realWorldApplication": "Em compiladores, parsers bottom-up (como CYK) usam propriedades de LLC para analisar sintaxe de linguagens de programação; entender não-fechamento sob interseção ajuda a evitar erros em validações complexas de código."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Teorema de Equivalência entre AP e LLC",
                        "description": "Enunciado e ideias das provas que estabelecem a equivalência entre as linguagens reconhecidas por autômatos de pilha e as linguagens livres de contexto.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Enunciar o teorema principal",
                            "description": "Afirmar que uma linguagem é livre de contexto se e somente se é reconhecida por um autômato de pilha: L é LLC ⇔ existe AP tal que L = L(AP).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições fundamentais de LLC e AP",
                                  "subSteps": [
                                    "Leia a definição formal de Linguagem Livre de Contexto (LLC) como a linguagem gerada por uma gramática livre de contexto.",
                                    "Estude a estrutura de um Autômato de Pilha (AP), incluindo estados, alfabeto de entrada, pilha e transições.",
                                    "Defina L(AP) como o conjunto de palavras reconhecidas pelo AP.",
                                    "Compare LLC com linguagens regulares para destacar diferenças.",
                                    "Anote exemplos clássicos, como {a^n b^n | n ≥ 0}."
                                  ],
                                  "verification": "Escreva as definições em suas próprias palavras e valide com uma fonte confiável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre Autômatos e Linguagens",
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Diagrama de AP básico"
                                  ],
                                  "tips": "Use mnemônicos para lembrar: LLC = gramática sem contexto, AP = memória em pilha.",
                                  "learningObjective": "Dominar os termos chave para contextualizar o teorema.",
                                  "commonMistakes": [
                                    "Confundir AP determinístico com não-determinístico.",
                                    "Achar que toda LLC é regular."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a direção 'LLC ⇒ L(AP)'",
                                  "subSteps": [
                                    "Analise como uma gramática G gera uma LLC L(G).",
                                    "Descreva a construção de um AP que simula a derivação da gramática usando pilha para não-terminais.",
                                    "Trace um exemplo simples: empilhar não-terminais e processar terminais.",
                                    "Verifique que todo L(G) é aceito pelo AP construído.",
                                    "Registre os passos da prova de conversão."
                                  ],
                                  "verification": "Construa manualmente um AP para uma gramática simples e teste com uma palavra.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas LLC",
                                    "Simulador de AP online ou papel",
                                    "Pseudocódigo da construção"
                                  ],
                                  "tips": "Visualize a pilha como 'histórico de derivação' da gramática.",
                                  "learningObjective": "Entender por que toda LLC é reconhecida por um AP.",
                                  "commonMistakes": [
                                    "Ignorar o papel da pilha em simular recursão.",
                                    "Confundir geração com reconhecimento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a direção 'L(AP) ⇒ LLC'",
                                  "subSteps": [
                                    "Explique como o comportamento de um AP pode ser capturado por uma gramática.",
                                    "Descreva a construção de uma gramática G a partir de um AP, usando pilha para estados e símbolos.",
                                    "Trace a simulação: gramática gera sequências que o AP aceitaria.",
                                    "Confirme que L(G) = L(AP) pela equivalência.",
                                    "Anote diferenças com autômatos finitos."
                                  ],
                                  "verification": "Construa uma gramática para um AP simples e gere palavras aceitas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de AP para LLC",
                                    "Papel para desenhar gramáticas",
                                    "Referência teórica"
                                  ],
                                  "tips": "Pense na gramática como 'inverso' do AP: gera em vez de reconhecer.",
                                  "learningObjective": "Entender por que toda L(AP) é uma LLC.",
                                  "commonMistakes": [
                                    "Esquecer símbolos de pilha na gramática.",
                                    "Achar que AP reconhece LLC estritamente mais fracas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e memorizar o enunciado completo do teorema",
                                  "subSteps": [
                                    "Combine as direções: L é LLC ⇔ ∃ AP tal que L = L(AP).",
                                    "Escreva o teorema em notação formal exata.",
                                    "Pratique verbalizando: 'uma linguagem é livre de contexto se e somente se...'.",
                                    "Explique o bicondicional (⇔) com exemplos contrafactuais.",
                                    "Teste variações: substitua LLC por regular e veja por que falha."
                                  ],
                                  "verification": "Enuncie o teorema para um parceiro ou grave-se e compare com a versão original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ficha de resumo do teorema",
                                    "Gravador de voz ou espelho",
                                    "Quiz autoaplicado"
                                  ],
                                  "tips": "Use flashcards: um lado definição, outro teorema completo.",
                                  "learningObjective": "Enunciar precisamente o teorema de equivalência.",
                                  "commonMistakes": [
                                    "Omitir 'existe AP tal que L = L(AP)'.",
                                    "Confundir com teorema de Chomsky."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere L = {a^n b^n | n ≥ 0}. É LLC, gerada por G: S → a S b | ε. Há um AP que empilha 'A' para cada 'a' e desempilha para cada 'b', aceitando se pilha vazia no final. Assim, L é LLC ⇔ reconhecida por AP.",
                              "finalVerifications": [
                                "Enuncie o teorema completo sem consultar notas.",
                                "Explique corretamente o significado de '⇔'.",
                                "Dê um exemplo de LLC reconhecida por AP.",
                                "Identifique por que {a^n b^n c^n} viola o teorema.",
                                "Compare com teorema para linguagens regulares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal (LLC, AP, L(AP), ⇔).",
                                "Correção lógica das duas direções do bicondicional.",
                                "Capacidade de exemplificar sem erros.",
                                "Clareza na verbalização ou escrita.",
                                "Compreensão de implicações (não para linguagens livres).",
                                "Ausência de confusões com classes menores (regulares)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoremas de equivalência e bicondicionais lógicos.",
                                "Lógica Formal: Provas por construção e simulação.",
                                "Programação: Modelagem de parsers em compiladores (LL/LR).",
                                "Teoria da Computação: Hierarquia de Chomsky.",
                                "Engenharia de Software: Análise sintática de linguagens."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, o teorema justifica o uso de autômatos de pilha (pushdown automata) para parsing de gramáticas livres de contexto em linguagens como C++, Java ou Python, permitindo análise sintática eficiente."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Esboçar construção de AP a partir de GLC",
                            "description": "Descrever a construção de um APND que simula derivações em uma GLC usando a pilha para armazenar o lado direito das produções e mover não-determinísticamente pela árvore de derivação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Gramática Livre de Contexto (GLC)",
                                  "subSteps": [
                                    "Identifique os terminais (Σ), não-terminais (V) e o símbolo inicial (S).",
                                    "Liste todas as produções no formato A → α, onde A é não-terminal e α é string de terminais e não-terminais.",
                                    "Classifique produções por não-terminal esquerdo para facilitar transições.",
                                    "Desenhe a árvore de derivação possível para uma palavra de exemplo.",
                                    "Verifique se a GLC está em Forma Normal de Chomsky (FNC) ou normalize se necessário."
                                  ],
                                  "verification": "Lista completa de terminais, não-terminais, símbolo inicial e todas as produções anotadas corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, definição da GLC exemplo, tabela de símbolos.",
                                  "tips": "Use cores diferentes para terminais e não-terminais para visualização clara.",
                                  "learningObjective": "Compreender a estrutura da GLC para mapear em componentes do AP.",
                                  "commonMistakes": "Confundir terminais com não-terminais ou omitir produções ε."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Estados e Configuração Inicial do AP",
                                  "subSteps": [
                                    "Crie estados q0 (inicial), q1 (loop de derivação), q2 (aceitação) e q_rejeita.",
                                    "Configure pilha inicial com símbolo $ (fundo) e S (inicial da GLC).",
                                    "Defina alfabeto da pilha Γ como V ∪ Σ ∪ {$}.",
                                    "Especifique δ(q0, ε, $) = (q1, $S) para empilhar S.",
                                    "Desenhe diagrama de estados iniciais."
                                  ],
                                  "verification": "Diagrama com estados q0, q1, q2 e configuração inicial da pilha descrita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta de desenho como Draw.io ou papel quadriculado.",
                                  "tips": "Mantenha poucos estados para simplicidade; foque em q1 como estado principal.",
                                  "learningObjective": "Estabelecer base para simulação não-determinística de derivações.",
                                  "commonMistakes": "Esquecer o fundo da pilha $ ou estado de rejeição."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Transições para Simular Derivações",
                                  "subSteps": [
                                    "Para cada produção A → α, adicione δ(q1, ε, A) = (q1, α) (não-determinístico).",
                                    "Para terminais: δ(q1, a, a) = (q1, ε) para consumir input e esvaziar pilha.",
                                    "Inclua transição para ε-produções: δ(q1, ε, A) = (q1, ε) se A → ε.",
                                    "Liste todas as transições em tabela: (estado, input, topo_pilha) → (novo_estado, push/pop).",
                                    "Teste mentalmente uma derivação curta."
                                  ],
                                  "verification": "Tabela de transições completa cobrindo todas produções e terminais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela em Excel ou papel, exemplo de palavra a ser derivada.",
                                  "tips": "Agrupe transições por não-terminal para evitar duplicatas.",
                                  "learningObjective": "Implementar mecânica de pilha para expansão de não-terminais e matching de terminais.",
                                  "commonMistakes": "Pop incorreto em terminais ou não empilhar lado direito completo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Condições de Aceitação e Verificar Equivalência",
                                  "subSteps": [
                                    "Defina aceitação por pilha vazia: δ(q1, ε, $) = (q2, $) em q1 com input esgotado.",
                                    "Adicione loops de rejeição para casos inválidos.",
                                    "Simule o AP em uma palavra aceita pela GLC (ex: árvore de derivação esquerda).",
                                    "Simule em palavra rejeitada para validar.",
                                    "Documente prova de corretude: todo caminho aceito corresponde a derivação válida."
                                  ],
                                  "verification": "Simulações bem-sucedidas para pelo menos duas palavras (aceita e rejeitada).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulador de AP online ou papel para rastrear configurações.",
                                  "tips": "Use derivação mais esquerda para padronizar simulação.",
                                  "learningObjective": "Garantir que AP reconhece exatamente L(G).",
                                  "commonMistakes": "Aceitar com pilha não-vazia ou falhar em ε-palavras."
                                }
                              ],
                              "practicalExample": "Para GLC G: S → aSb | ε. AP: q0 empilha S sobre $; em q1, δ(q1,ε,S)=(q1,aSb) ou (q1,ε); δ(q1,a,a)=(q1,ε); δ(q1,b,b)=(q1,ε). Aceita 'aabb' via derivação S⇒aSb⇒aεb⇒aabb, consumindo input enquanto esvazia pilha até $.",
                              "finalVerifications": [
                                "Tabela de transições cobre todas produções da GLC.",
                                "Simulação aceita palavra conhecida de L(G) com pilha vazia.",
                                "Simulação rejeita palavra fora de L(G).",
                                "Estados e alfabeto da pilha definidos corretamente.",
                                "Prova esboçada de simulação de derivações esquerda.",
                                "Diagrama do AP desenhado sem ambiguidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de transições para produções (100% cobertura).",
                                "Correta simulação de pelo menos uma derivação completa.",
                                "Identificação de não-determinismo na escolha de produções.",
                                "Equivalência demonstrada entre L(AP) e L(G).",
                                "Clareza no diagrama e documentação.",
                                "Tratamento correto de ε-produções e pilha vazia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (transições como arestas rotuladas).",
                                "Programação: Implementação de parsers recursivos descendentes.",
                                "Lógica: Não-determinismo similar a backtracking em algoritmos.",
                                "Engenharia de Software: Modelagem de linguagens em compiladores."
                              ],
                              "realWorldApplication": "Construção de parsers em compiladores (ex: LLVM para linguagens de programação), validação de XML/JSON estruturados e análise sintática em ferramentas de processamento de linguagem natural."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Esboçar construção de GLC a partir de AP",
                            "description": "Explicar a conversão de um AP em uma GLC equivalente, usando não-terminais que codificam configurações (estado, pilha restante) para simular transições do AP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura formal do Autômato de Pilha (AP) e configurações",
                                  "subSteps": [
                                    "Defina formalmente um AP como uma 7-tupla: (Q, Σ, Γ, δ, q₀, Z₀, F), explicando cada componente.",
                                    "Descreva uma configuração de AP como (q, w, γ), onde q é o estado atual, w a palavra restante e γ o conteúdo da pilha (topo à esquerda).",
                                    "Explique o processo de computação: transições via δ(q, a, A) = (p, α), atualizando configuração.",
                                    "Discuta aceitação por estado final e pilha reduzida a Z₀ (símbolo inicial não removível).",
                                    "Diferencie transições com pop, push e ε-moves."
                                  ],
                                  "verification": "Escreva a definição formal de um AP exemplo e simule 3 configurações sucessivas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 2)",
                                    "Folha de papel e caneta para diagramas",
                                    "Ferramenta online como JFLAP para simular AP"
                                  ],
                                  "tips": "Visualize a pilha crescendo para a direita, com topo à esquerda para facilitar a notação.",
                                  "learningObjective": "Dominar os componentes e dinâmica de um AP para preparar a simulação via GLC.",
                                  "commonMistakes": [
                                    "Confundir ordem da pilha (topo esquerdo vs. direito)",
                                    "Ignorar ε-transições ou aceitação por pilha vazia vs. Z₀"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os não-terminais e símbolos da Gramática Livre de Contexto (GLC)",
                                  "subSteps": [
                                    "Crie não-terminais [q, A] para cada par (estado q ∈ Q, símbolo de pilha A ∈ Γ), representando configuração com estado q e topo A.",
                                    "Defina o símbolo inicial S = [q₀, Z₀].",
                                    "Inclua terminais Σ do AP e variáveis V = {[p, B] | p ∈ Q, B ∈ Γ}.",
                                    "Introduza regras auxiliares para simular pilha restante em pushes múltiplos.",
                                    "Verifique que todos os estados e símbolos de pilha estão cobertos."
                                  ],
                                  "verification": "Para um AP com 3 estados e 2 símbolos de pilha, liste todos os não-terminais e o inicial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de estados e símbolos do AP",
                                    "Editor de texto para listar símbolos"
                                  ],
                                  "tips": "Use notação [q,A] consistentemente para evitar confusão com estados puros.",
                                  "learningObjective": "Mapear configurações do AP para não-terminais da GLC de forma precisa.",
                                  "commonMistakes": [
                                    "Esquecer não-terminais para todos os pares (q,A)",
                                    "Confundir terminais com símbolos de pilha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir regras de produção para simular transições do AP",
                                  "subSteps": [
                                    "Para δ(q, a, A) = (p, B₁B₂...Bₖ), crie regra [q, A] → a [p, B₁] B₂ ... Bₖ (topo B₁).",
                                    "Para δ(q, ε, A) = (p, B₁B₂...Bₖ), crie [q, A] → [p, B₁] B₂ ... Bₖ.",
                                    "Para δ(q, a, A) = (p, ε), crie [q, A] → a [p, Z₀] (ou ajuste para não pop Z₀).",
                                    "Inclua regras para estados espontâneos e múltiplos símbolos empilhados.",
                                    "Garanta que as regras preservem a ordem LIFO da pilha."
                                  ],
                                  "verification": "Dada uma transição específica, escreva a regra de produção correspondente e simule uma derivação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela de transições δ do AP",
                                    "Papel para derivar exemplos de regras"
                                  ],
                                  "tips": "Lembre-se da inversão lógica: GLC gera de cima para baixo, simulando pilha de baixo para cima.",
                                  "learningObjective": "Gerar regras que simulem fielmente todas as transições do AP.",
                                  "commonMistakes": [
                                    "Erro na ordem dos símbolos empilhados (B₁ topo primeiro)",
                                    "Omitir ε-moves ou pops"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar a GLC com regras de aceitação e verificar equivalência",
                                  "subSteps": [
                                    "Adicione regras de aceitação: para cada f ∈ F, [f, Z₀] → ε.",
                                    "Compile todas as regras em uma gramática completa G = (V, Σ, P, S).",
                                    "Simule uma derivação para uma palavra aceita pelo AP.",
                                    "Verifique que L(G) ⊆ L(AP) e L(AP) ⊆ L(G) conceitualmente.",
                                    "Teste com uma palavra não aceita para confirmar rejeição."
                                  ],
                                  "verification": "Esboce a GLC completa para o AP e derive uma palavra aceita.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplo de AP completo",
                                    "Ferramenta como JFLAP ou papel para derivações"
                                  ],
                                  "tips": "Comece com AP simples para validar antes de generalizar.",
                                  "learningObjective": "Completar a construção e entender a prova de equivalência.",
                                  "commonMistakes": [
                                    "Regras de aceitação só para Z₀, não pilha vazia total",
                                    "Não simular derivação para validar"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere AP M para L = {aⁿbⁿ | n ≥ 0}: estados {q0,q1,qf}, Σ={a,b}, Γ={Z,A}, δ(q0,a,Z)=(q0,AZ), δ(q0,ε,Z)=(q1,Z), δ(q1,b,A)=(q1,ε), δ(q1,ε,A)=(qf,Z). Não-terminais: [q0,Z], [q0,A], etc. Regras: [q0,Z] → a [q0,A] Z (errado, corrija para padrão), mas esboce [q0,Z] → a [q0,A], [q0,A] → a [q0,A], [q0,A] → b [q1,ε], [qf,Z] → ε. Derivação: [q0,Z] ⇒ a [q0,A] ⇒ ... ⇒ aⁿ bⁿ.",
                              "finalVerifications": [
                                "Lista correta de não-terminais cobrindo todos pares (q,A).",
                                "Regras de produção para todas transições δ, incluindo ε-moves.",
                                "Símbolo inicial [q₀,Z₀] e regras de aceitação [f,Z₀] → ε.",
                                "Simulação de derivação para pelo menos uma palavra aceita.",
                                "Explicação conceitual de por que L(GLC) = L(AP).",
                                "Identificação de erros comuns em construções semelhantes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na codificação de configurações (30%).",
                                "Correção e completude das regras de produção (30%).",
                                "Validação via exemplo prático e derivação (20%).",
                                "Compreensão da equivalência teórica (10%).",
                                "Clareza no esboço diagrama ou textual (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Grafos e autômatos como modelos formais.",
                                "Programação: Simulação de pilha em linguagens como Python (stack data structure).",
                                "Lógica: Provas de equivalência e indução em linguagens formais.",
                                "Engenharia de Software: Parsers em compiladores (LL(1), LR)."
                              ],
                              "realWorldApplication": "Essa construção é fundamental para provar propriedades de linguagens em compiladores, onde autômatos de pilha modelam parsers sintáticos para linguagens livres de contexto, como validação de chaves balanceadas em JSON/XML ou expressões aritméticas em linguagens de programação."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.4",
                            "name": "Aplicar o teorema em exemplos",
                            "description": "Dado um AP ou GLC, afirmar que a linguagem é LLC e esboçar a direção da equivalência, referenciando Sipser ou Hopcroft para detalhes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Teorema de Equivalência entre AP e LLC",
                                  "subSteps": [
                                    "Ler a declaração formal do teorema em Sipser (Capítulo 2.5) ou Hopcroft/Ullman (Capítulo 7).",
                                    "Identificar as duas direções: (1) Toda LLC é reconhecida por algum AP; (2) Toda linguagem reconhecida por AP é uma LLC.",
                                    "Analisar intuitivamente as provas: conversão de GLC para AP via simulação de derivações de esquerda a direita.",
                                    "Analisar conversão de AP para GLC via regras que simulam push/pop da pilha.",
                                    "Anotar as páginas exatas das referências para uso futuro."
                                  ],
                                  "verification": "Escrever um resumo de 3-5 frases explicando o teorema e suas direções, incluindo referências.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser",
                                    "Livro 'Introduction to Automata Theory, Languages, and Computation' de Hopcroft/Ullman",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Use diagramas para visualizar as conversões sem entrar em construções algébricas detalhadas.",
                                  "learningObjective": "Compreender o teorema de equivalência e suas direções de prova.",
                                  "commonMistakes": "Confundir as direções do teorema ou assumir equivalência sem referenciar as provas de conversibilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o teorema a partir de um Autômato de Pilha (AP)",
                                  "subSteps": [
                                    "Dado um AP M, afirmar explicitamente: 'L(M) é uma LLC pelo teorema de equivalência'.",
                                    "Esboçar a direção AP → LLC: existe uma construção efetiva de GLC G tal que L(G) = L(M).",
                                    "Descrever como a GLC simula a pilha do AP usando não-terminais para estados e símbolos da pilha.",
                                    "Referenciar Sipser (p. 126-130) ou Hopcroft (Seção 7.3) para detalhes da construção.",
                                    "Verificar que o esboço não requer construção completa da GLC."
                                  ],
                                  "verification": "Produzir uma declaração escrita com afirmação, direção e referência para um AP exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de AP (ex: reconhecedor de {ww^R | w em {a,b}*})",
                                    "Livros de referência citados",
                                    "Papel para esboços"
                                  ],
                                  "tips": "Foque na simulação da pilha como 'histórico de computação' na GLC.",
                                  "learningObjective": "Aplicar corretamente a direção AP → LLC com esboço e referência.",
                                  "commonMistakes": "Esboçar a direção errada (GLC → AP) ou omitir a referência bibliográfica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o teorema a partir de uma Gramática Livre de Contexto (GLC)",
                                  "subSteps": [
                                    "Dada uma GLC G, afirmar: 'L(G) é reconhecida por um AP pelo teorema de equivalência'.",
                                    "Esboçar a direção GLC → AP: construir AP que simula derivações de esquerda a direita da GLC.",
                                    "Descrever como o AP usa a pilha para armazenar o lado direito das produções não processadas.",
                                    "Referenciar Sipser (p. 124-126) ou Hopcroft (Seção 7.2) para a prova detalhada.",
                                    "Confirmar que o esboço destaca a simulação bottom-up."
                                  ],
                                  "verification": "Escrever afirmação, direção e referência para uma GLC exemplo (ex: gramática de palíndromos).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de GLC (ex: S → aSa | bSb | ε)",
                                    "Livros de referência",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Pense na pilha como 'fila de espera' para símbolos não expandidos.",
                                  "learningObjective": "Dominar a aplicação da direção GLC → AP com justificativa precisa.",
                                  "commonMistakes": "Inverter a simulação (top-down vs bottom-up) ou esquecer a referência específica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e praticar aplicações em exemplos mistos",
                                  "subSteps": [
                                    "Selecionar 2-3 exemplos: um AP, uma GLC e uma linguagem conhecida (ex: {a^n b^n}).",
                                    "Para cada, afirmar 'é LLC' e esboçar a direção relevante com referência.",
                                    "Combinar direções bidirecionais para provar LLC em casos duplos.",
                                    "Discutir limitações: o teorema não classifica linguagens não-LLC.",
                                    "Autoavaliar esboços comparando com livros."
                                  ],
                                  "verification": "Gerar relatório de 1 página com 3 exemplos resolvidos, incluindo afirmações e esboços.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos impressos ou digitais de AP/GLC",
                                    "Livros de referência",
                                    "Ferramenta de desenho para diagramas (opcional)"
                                  ],
                                  "tips": "Use exemplos canônicos como palíndromos para reforçar confiança.",
                                  "learningObjective": "Aplicar o teorema de forma fluida em exemplos variados, integrando ambas direções.",
                                  "commonMistakes": "Aplicar direção errada para o artefato dado ou generalizar sem referência."
                                }
                              ],
                              "practicalExample": "Dado o AP M que reconhece {a^n b^n | n ≥ 0}: Afirme 'L(M) é LLC'. Esboço: Construa GLC G com regras simulando push de 'a' e pop com 'b' (direção AP → LLC, Sipser p. 128). Inverso: GLC S → a S b | ε gera AP que empilha 'a' e verifica 'b' (GLC → AP, Hopcroft p. 234).",
                              "finalVerifications": [
                                "Afirma corretamente que L(AP) ou L(GLC) é LLC.",
                                "Esboça a direção exata da equivalência (AP→LLC ou GLC→AP).",
                                "Cita referências precisas (Sipser/Hopcroft com seções).",
                                "Identifica corretamente simulações de pilha ou derivações.",
                                "Discute bidirecionalidade quando aplicável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na afirmação de LLC (100% correto).",
                                "Qualidade do esboço da direção (detalhes intuitivos presentes).",
                                "Correção das referências bibliográficas (páginas/seções exatas).",
                                "Clareza na descrição de simulações (pilha/derivações).",
                                "Capacidade de lidar com exemplos variados sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Formal: Provas de existência e construções efetivas em teoria dos conjuntos.",
                                "Lógica Computacional: Relação entre modelos formais e semântica.",
                                "Engenharia de Software: Design de parsers LL/LR baseados em AP para compiladores.",
                                "Teoria da Computação: Hierarquia de Chomsky e classes de linguagens."
                              ],
                              "realWorldApplication": "No desenvolvimento de compiladores, o teorema justifica o uso de pushdown automata para parsing de linguagens de programação livres de contexto, como expressões aritméticas ou estruturas de controle, permitindo ferramentas como Yacc/Bison que simulam AP para análise sintática eficiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Autômatos de Pilha Determinísticos vs. Não-Determinísticos",
                    "description": "Diferenças entre DPDA e NPDA, e suas classes de linguagens reconhecidas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Autômato de Pilha Determinístico (DPDA)",
                        "description": "Definição formal, componentes e funcionamento de um autômato de pilha que possui uma única transição possível para cada configuração de entrada, estado e símbolo da pilha.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Definir formalmente um DPDA",
                            "description": "Especificar a estrutura quíntupla de um DPDA (Q, Σ, Γ, δ, q0, Z0, F), destacando que a função de transição δ é parcial e única para cada (estado, símbolo de entrada, símbolo topo da pilha).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar componentes básicos e introduzir a estrutura quíntupla",
                                  "subSteps": [
                                    "Relembre a definição de autômato de pilha (PDA) genérico.",
                                    "Identifique as diferenças chave entre PDA não-determinístico e DPDA.",
                                    "Liste os 7 elementos da tupla formal: Q, Σ, Γ, δ, q0, Z0, F.",
                                    "Explique que δ é a função de transição parcial e determinística.",
                                    "Anote por que o DPDA é mais restrito que o PDA."
                                  ],
                                  "verification": "Escreva a tupla quíntupla completa e justifique cada componente em uma folha.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas de aula sobre PDA",
                                    "Referência: Livro Sipser 'Introdução à Teoria da Computação'"
                                  ],
                                  "tips": "Use mnemônicos como 'Estados, Entrada, Pilha, Transição, Início Estado/Pilha, Finais' para memorizar.",
                                  "learningObjective": "Compreender a estrutura geral de um DPDA e sua tupla formal.",
                                  "commonMistakes": [
                                    "Confundir o número de elementos (é 7, não 5 como FA)",
                                    "Ignorar que Z0 é o símbolo inicial da pilha",
                                    "Esquecer que F é conjunto de estados finais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os conjuntos de estados, alfabeto de entrada e símbolos da pilha",
                                  "subSteps": [
                                    "Defina Q como o conjunto finito de estados.",
                                    "Defina Σ como o alfabeto finito de símbolos de entrada.",
                                    "Defina Γ como o alfabeto finito de símbolos da pilha (Γ ⊇ Σ ∪ {Z0}).",
                                    "Especifique exemplos concretos para cada conjunto em um DPDA simples.",
                                    "Verifique se os conjuntos são finitos e não-vazios onde aplicável."
                                  ],
                                  "verification": "Crie conjuntos exemplo para Q, Σ e Γ para um DPDA que reconhece palíndromos pares.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para diagramas ASCII"
                                  ],
                                  "tips": "Sempre inclua Z0 em Γ e garanta que Σ e Γ sejam disjoint se possível para clareza.",
                                  "learningObjective": "Especificar corretamente Q, Σ e Γ com exemplos.",
                                  "commonMistakes": [
                                    "Confundir Σ (entrada) com Γ (pilha)",
                                    "Fazer Q infinito",
                                    "Esquecer Z0 em Γ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar estados e símbolos iniciais e estados finais",
                                  "subSteps": [
                                    "Escolha q0 ∈ Q como estado inicial.",
                                    "Defina Z0 ∈ Γ como símbolo inicial da pilha.",
                                    "Defina F ⊆ Q como conjunto de estados de aceitação.",
                                    "Explique o papel de cada um na configuração inicial: (q0, ε, Z0).",
                                    "Verifique consistência com os conjuntos definidos anteriormente."
                                  ],
                                  "verification": "Anote q0, Z0 e F para o exemplo de palíndromos e descreva a configuração inicial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagramas de PDA prévios"
                                  ],
                                  "tips": "q0 é único, Z0 é único, F pode ser vazio mas geralmente não.",
                                  "learningObjective": "Identificar e justificar q0, Z0 e F em uma definição formal.",
                                  "commonMistakes": [
                                    "Definir múltiplos q0",
                                    "Colocar Z0 fora de Γ",
                                    "Confundir F com estados de erro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir a função de transição δ e propriedades do DPDA",
                                  "subSteps": [
                                    "Defina δ: Q × (Σ ∪ {ε}) × Γ → Q × Γ* como função parcial.",
                                    "Enfatize determinismo: no máximo uma transição por (q, a, Z).",
                                    "Dê exemplo de δ com pop, push e ε-moves limitados.",
                                    "Explique parcialidade: nem toda configuração tem transição.",
                                    "Monte a tupla completa com δ exemplo."
                                  ],
                                  "verification": "Escreva δ formal para um DPDA simples e prove que é determinístico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta JFLAP para simulação (opcional)"
                                  ],
                                  "tips": "Use notação δ(q, a, Z) = (p, α) onde α ∈ Γ*.",
                                  "learningObjective": "Formalizar δ destacando parcialidade e unicidade.",
                                  "commonMistakes": [
                                    "Permitir múltiplas transições (não-determinismo)",
                                    "Definir δ total",
                                    "Confundir ε em entrada com ε na pilha"
                                  ]
                                }
                              ],
                              "practicalExample": "DPDA para palíndromos pares sobre {a,b}: Q = {q0, q1, qf}, Σ = {a,b}, Γ = {a,b,Z0}, q0 inicial, Z0 inicial pilha, F = {qf}. δ inclui: δ(q0, a, Z0) = (q1, aZ0), δ(q1, a, a) = (q1, ε), δ(q1, ε, Z0) = (qf, ε), etc., garantindo determinismo.",
                              "finalVerifications": [
                                "Liste corretamente os 7 componentes da tupla.",
                                "Explique por que δ é parcial e determinística.",
                                "Forneça um exemplo válido de δ sem ambiguidades.",
                                "Descreva configuração inicial e aceitação por estado final e pilha vazia.",
                                "Diferencie DPDA de PDA não-determinístico.",
                                "Construa tupla completa para um exemplo dado."
                              ],
                              "assessmentCriteria": [
                                "Correção na estrutura quíntupla (todos 7 elementos).",
                                "Precisão na definição de δ (parcial, única transição).",
                                "Uso correto de notação formal matemática.",
                                "Consistência entre componentes (ex: q0 ∈ Q).",
                                "Capacidade de exemplificar com DPDA válido.",
                                "Entendimento de determinismo vs. não-determinismo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções parciais.",
                                "Lógica: Autômatos como modelos computacionais.",
                                "Programação: Parsing em compiladores (LL(1)).",
                                "Engenharia de Software: Verificação formal de sistemas.",
                                "Filosofia da Computação: Limites da computação determinística."
                              ],
                              "realWorldApplication": "DPDA são fundamentais em analisadores sintáticos de compiladores (ex: Yacc/Bison para gramáticas LL(1)), processamento de linguagens naturais determinísticas e verificação de protocolos em sistemas embarcados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Construir um DPDA simples",
                            "description": "Desenhar e simular um DPDA para reconhecer uma linguagem específica, como {a^n b^n | n ≥ 0}, demonstrando transições determinísticas e uso da pilha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a linguagem e os componentes básicos de um DPDA",
                                  "subSteps": [
                                    "Analise a linguagem {a^n b^n | n ≥ 0}, identificando que ela requer contagem igual de 'a' e 'b'.",
                                    "Revise a definição formal de DPDA: (Q, Σ, Γ, δ, q0, Z0, F), onde δ é a função de transição determinística.",
                                    "Identifique os elementos chave: estados finitos, pilha, transições baseadas em estado atual, símbolo de entrada e topo da pilha.",
                                    "Desenhe um esboço inicial com estado inicial q0, estados finais e símbolo inicial da pilha Z0.",
                                    "Liste as condições de aceitação por estado final e pilha vazia."
                                  ],
                                  "verification": "Verifique se você pode explicar verbalmente ou por escrito os componentes do DPDA e por que a linguagem requer uma pilha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Documentação de teoria de autômatos",
                                    "Software JFLAP ou simulador online de DPDA"
                                  ],
                                  "tips": [
                                    "Comece sempre pela linguagem para guiar o design.",
                                    "Use diagramas simples para visualizar estados."
                                  ],
                                  "learningObjective": "Entender os fundamentos teóricos de um DPDA e sua adequação para linguagens sensíveis ao contexto como {a^n b^n}.",
                                  "commonMistakes": [
                                    "Confundir DPDA com NPDA, ignorando determinismo.",
                                    "Esquecer que aceitação é por estado final e pilha vazia.",
                                    "Não identificar o papel da pilha na contagem."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar os estados e o uso inicial da pilha",
                                  "subSteps": [
                                    "Defina os estados mínimos: q0 (inicial), q1 (lendo 'a's), q2 (lendo 'b's), qf (final).",
                                    "Escolha o alfabeto da pilha Γ = {Z0, A}, onde Z0 é o fundo e A marca cada 'a'.",
                                    "Planeje empilhar A para cada 'a' lida em q0 para q1.",
                                    "Desenhe transições iniciais: de q0, em 'a' e Z0, empilhe A e vá para q1.",
                                    "Garanta que não haja ε-transições, mantendo determinismo."
                                  ],
                                  "verification": "Confira se o diagrama tem estados conectados logicamente e pilha usada apenas para contagem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel milimetrado ou ferramenta de desenho como Draw.io",
                                    "JFLAP para prototipagem"
                                  ],
                                  "tips": [
                                    "Mantenha poucos estados para simplicidade.",
                                    "Rotule transições como (entrada, pop/push, próximo estado)."
                                  ],
                                  "learningObjective": "Projetar a estrutura de estados e pilha para capturar a simetria da linguagem.",
                                  "commonMistakes": [
                                    "Criar estados desnecessários.",
                                    "Usar pop sem push correspondente.",
                                    "Ignorar o fundo da pilha Z0."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir todas as transições determinísticas",
                                  "subSteps": [
                                    "Em q1, para 'a' e topo A ou Z0, empilhe A e fique em q1.",
                                    "Em q1, para 'b' e topo A, pop A e vá para q2.",
                                    "Em q2, para 'b' e topo A, pop A e fique em q2.",
                                    "Em q2, para ε e topo Z0, vá para qf (aceitação).",
                                    "Adicione transições de rejeição para entradas inválidas, como 'b' em q0 ou 'a' em q2."
                                  ],
                                  "verification": "Teste manualmente transições para strings como ε, ab, aabb, garantindo uma única transição por configuração.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabela de transições em planilha",
                                    "Simulador JFLAP"
                                  ],
                                  "tips": [
                                    "Use notação δ(q, a, X) = (p, α) para clareza.",
                                    "Verifique determinismo: no máximo uma transição por (estado, entrada, topo)."
                                  ],
                                  "learningObjective": "Implementar transições que garantam reconhecimento correto e determinismo.",
                                  "commonMistakes": [
                                    "Permitir múltiplas transições para mesma configuração.",
                                    "Esquecer transições de rejeição.",
                                    "Confundir pop com push na fase de 'b's."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, testar e validar o DPDA",
                                  "subSteps": [
                                    "Simule em JFLAP ou manualmente strings aceitas: ε, ab, aabb, aaabbb.",
                                    "Teste strings rejeitadas: a, b, aaab, abbb, aba.",
                                    "Verifique se a pilha esvazia corretamente no final para aceitação.",
                                    "Analise o caminho de execução, registrando configurações (estado, resto da fita, pilha).",
                                    "Documente o diagrama completo e a tabela de transições."
                                  ],
                                  "verification": "O DPDA aceita exatamente {a^n b^n | n ≥ 0} sem ambiguidades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "JFLAP ou simulador online",
                                    "Papel para rastreamento manual de pilha"
                                  ],
                                  "tips": [
                                    "Simule passo a passo, desenhando a pilha.",
                                    "Registre rejeições para depuração."
                                  ],
                                  "learningObjective": "Validar o DPDA através de simulações para confirmar corretude.",
                                  "commonMistakes": [
                                    "Não testar casos limite como n=0.",
                                    "Ignorar sobras na pilha.",
                                    "Confundir aceitação por estado vazio com pilha vazia."
                                  ]
                                }
                              ],
                              "practicalExample": "Para {a^n b^n | n ≥ 0}: Estados q0, q1, q2, qf. Pilha: Z0 inicial. Transições: δ(q0,a,Z0)=(q1,AZ0); δ(q1,a,A)=(q1,AA); δ(q1,b,A)=(q2,ε); δ(q2,b,A)=(q2,ε); δ(q2,ε,Z0)=(qf,ε). Simulação para 'aabb': q0 -a-> q1 (AZ0) -a-> q1 (AAZ0) -b-> q2 (AZ0) -b-> q2 (Z0) -ε-> qf (Z0). Aceito.",
                              "finalVerifications": [
                                "O DPDA tem transições determinísticas sem ambiguidades.",
                                "Aceita todas as strings {a^n b^n | n ≥ 0}, incluindo ε.",
                                "Rejeita strings inválidas como 'a', 'b', 'aab', 'abbb'.",
                                "A pilha esvazia exatamente no estado final para aceitação.",
                                "Diagrama e tabela de transições estão completos e legíveis.",
                                "Simulações manuais confirmam o comportamento esperado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal do DPDA (componentes corretos).",
                                "Determinismo estrito nas transições (uma por configuração).",
                                "Uso correto da pilha para matching de 'a' e 'b'.",
                                "Cobertura completa de casos de aceitação e rejeição.",
                                "Clareza no diagrama e documentação.",
                                "Validação através de simulações sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Contagem por indução e funções geradoras.",
                                "Programação: Implementação de pilhas em linguagens como Python ou Java.",
                                "Lógica: Estados finitos e tabelas de verdade para transições.",
                                "Engenharia de Software: Parsing em compiladores (ex: expressões balanceadas)."
                              ],
                              "realWorldApplication": "DPDAs são usados em compiladores para análise sintática de linguagens de programação, validando estruturas balanceadas como parênteses ou tags XML, garantindo parsing eficiente e determinístico em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Simular a execução de um DPDA",
                            "description": "Passo a passo, rastrear a configuração (estado, posição na fita, conteúdo da pilha) em uma palavra de entrada, identificando aceitação por estado final ou pilha vazia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o DPDA e a configuração inicial",
                                  "subSteps": [
                                    "Identificar todos os componentes do DPDA: estados Q, alfabeto de entrada Σ, alfabeto da pilha Γ, função de transição δ, estado inicial q0, símbolo inicial da pilha Z0, estados finais F.",
                                    "Diagramar o autômato com estados, transições rotuladas como (σ,γ)/β onde σ é símbolo de entrada ou ε, γ topo da pilha, β string a empilhar após pop.",
                                    "Escrever a palavra de entrada w explicitamente, numerando posições de 0 a |w|-1 (posição 0 antes do primeiro símbolo).",
                                    "Inicializar a configuração: (q0, posição=0, pilha=Z0). Preparar uma tabela com colunas: Passo, Estado, Posição, Símbolo lido, Topo pilha, Transição aplicada, Nova pilha, Nova posição.",
                                    "Verificar se a pilha é representada corretamente com o topo à direita (ex: ZA significa bottom Z, top A)."
                                  ],
                                  "verification": "Tabela inicial preenchida com configuração (q0, 0, Z0) e diagrama completo sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de diagramas",
                                    "Definição formal do DPDA",
                                    "Exemplo de palavra de entrada"
                                  ],
                                  "tips": "Use setas claras nas transições e destaque ε-moves. Represente pilha como string com topo à direita para evitar confusão.",
                                  "learningObjective": "Dominar a representação formal e visual de um DPDA antes da simulação.",
                                  "commonMistakes": [
                                    "Esquecer o símbolo inicial Z0 na pilha.",
                                    "Confundir ordem da pilha (topo esquerdo vs. direito).",
                                    "Não listar todas as transições possíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular transições durante a leitura da entrada",
                                  "subSteps": [
                                    "Para cada posição i de 0 a |w|-1: identificar símbolo atual w_i.",
                                    "Consultar δ(estado atual, w_i, topo da pilha) para obter (novo_estado, β).",
                                    "Pop o topo da pilha, empilhe β (da esquerda para direita, topo à direita).",
                                    "Atualizar estado, posição (i+1), e registrar na tabela.",
                                    "Se não houver transição definida para (q, w_i, γ), rejeitar imediatamente e parar."
                                  ],
                                  "verification": "Tabela preenchida até posição = |w|, com todas transições de leitura aplicadas corretamente, sem rejeição prematura.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela preparada do passo 1",
                                    "Regra de transição δ listada"
                                  ],
                                  "tips": "Sempre verifique se a transição é determinística: no máximo uma por (q,σ,γ). Anote 'pop γ, push β' explicitamente.",
                                  "learningObjective": "Executar transições determinísticas com manipulação precisa da pilha durante consumo da entrada.",
                                  "commonMistakes": [
                                    "Avançar posição sem ler símbolo corretamente.",
                                    "Empilhar β na ordem errada (esquecer topo à direita).",
                                    "Ignorar que DPDA é determinístico e tentar escolhas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar transições ε após o fim da entrada",
                                  "subSteps": [
                                    "Com posição = |w| (fim da entrada), repetir enquanto possível: consultar δ(estado atual, ε, topo da pilha) = (novo_estado, β).",
                                    "Aplicar: pop topo, push β, atualizar estado e registrar na tabela.",
                                    "Continuar até não haver mais transição ε possível do estado atual.",
                                    "Se em qualquer ponto não houver transição ε definida, parar.",
                                    "Garantir que não haja loops infinitos (verificar se pilha diminui ou estados progridem)."
                                  ],
                                  "verification": "Tabela mostra todas ε-moves possíveis exauridas, sem loops, chegando a configuração final estável.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela atualizada do passo 2"
                                  ],
                                  "tips": "Marque transições ε com 'ε' na coluna símbolo lido. Pare apenas quando δ(q,ε,γ) indefinida.",
                                  "learningObjective": "Compreender o papel das ε-transições para finalizar processamento pós-entrada.",
                                  "commonMistakes": [
                                    "Executar ε-moves antes do fim da entrada.",
                                    "Entrar em loop infinito sem detectar estagnação na pilha/estado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar condições de aceitação",
                                  "subSteps": [
                                    "Checar se estado final pertence a F.",
                                    "Verificar se pilha está vazia (ou apenas símbolo inicial Z0, dependendo da definição).",
                                    "Se aceitação por estado final OU pilha vazia, marcar como aceito; caso contrário, rejeitado.",
                                    "Analisar configuração final: listar estado, posição=|w|, pilha completa.",
                                    "Documentar razão exata de aceitação/rejeição com referência à definição."
                                  ],
                                  "verification": "Conclusão clara de aceito/rejeitado com justificativa baseada em F ou pilha vazia.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela completa"
                                  ],
                                  "tips": "Alguns DPDA aceitam só por estado final; confirme a definição do autômato.",
                                  "learningObjective": "Aplicar critérios precisos de aceitação em DPDA.",
                                  "commonMistakes": [
                                    "Confundir aceitação por estado com pilha vazia.",
                                    "Considerar pilha 'vazia' se Z0 ainda presente quando não deve."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere DPDA para {a^n b^n | n≥0}: Estados {q0,q1,qf}, Σ={a,b}, Γ={Z,A}, q0 init, Z bottom, F={qf}.\nTransições (topo direito):\nδ(q0,a,Z)=(q0,ZA), δ(q0,a,A)=(q0,AA), δ(q0,b,A)=(q1,ε),\nδ(q1,b,A)=(q1,ε), δ(q1,ε,Z)=(qf,Z).\nEntrada: aabb\n1. (q0,0,Z) -a-> (q0,1,ZA)\n2. (q0,1,ZA)-a-> (q0,2,ZAA) [pop A push AA → Z A A]\n3. (q0,2,ZAA)-b-> (q1,3,ZA) [pop A push ε]\n4. (q1,3,ZA)-b-> (q1,4,Z) [pop A push ε]\n5. (q1,4,Z)-ε-> (qf,4,Z)\nAceito por estado qf em F.",
                              "finalVerifications": [
                                "Configuração inicial correta com q0, pos=0, pilha=Z0.",
                                "Todas transições aplicadas sem ambiguidades determinísticas.",
                                "Rastreamento preciso de pilha (topo à direita) em cada passo.",
                                "Transições ε exauridas no final.",
                                "Conclusão de aceitação/rejeição matches definição (F ou pilha vazia).",
                                "Tabela completa sem erros de pop/push.",
                                "Análise detecta rejeições prematuras corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de δ (100% correto).",
                                "Manipulação correta da pilha em todas configs (sem erros de ordem).",
                                "Tratamento adequado de ε-moves e fim de entrada.",
                                "Justificativa clara de aceitação/rejeição.",
                                "Tabela organizada e legível.",
                                "Detecção de casos de rejeição (transição indefinida).",
                                "Eficiência: sem passos extras ou loops."
                              ],
                              "crossCurricularConnections": [
                                "Raciocínio lógico e dedutivo (Matemática).",
                                "Modelagem de algoritmos e fluxogramas (Programação).",
                                "Análise de sistemas finitos (Engenharia de Software).",
                                "Teoria de linguagens formais (Linguística Computacional)."
                              ],
                              "realWorldApplication": "Simular DPDAs é essencial em compiladores para parsing determinístico (ex: LL parsers em ferramentas como ANTLR), validando sintaxe de código com stack para precedência e balanceamento, garantindo eficiência em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Autômato de Pilha Não-Determinístico (NPDA)",
                        "description": "Definição formal e características de um autômato de pilha que permite múltiplas transições possíveis, incluindo ε-transições, para cada configuração.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Definir formalmente um NPDA",
                            "description": "Descrever a estrutura quíntupla de um NPDA, enfatizando que δ pode mapear para conjuntos finitos de transições, permitindo não-determinismo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes básicos de estados, alfabetos e pilha",
                                  "subSteps": [
                                    "Liste os cinco componentes principais da tupla quíntupla de um NPDA: Q (estados), Σ (alfabeto de entrada), Γ (alfabeto da pilha), δ (função de transição), q0 (estado inicial) e F (estados finais).",
                                    "Defina Q como um conjunto finito de estados, Σ como alfabeto finito de símbolos de entrada e Γ como alfabeto finito de símbolos da pilha.",
                                    "Explique que ε denota o símbolo vazio para entrada e pilha.",
                                    "Crie exemplos simples: Q = {q0, q1, qf}, Σ = {a, b}, Γ = {A, B, Z}."
                                  ],
                                  "verification": "Escreva definições precisas para Q, Σ e Γ com exemplos corretos sem erros.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Notas de aula sobre autômatos de pilha",
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Use notação matemática padrão: |Q| para cardinalidade finita.",
                                    "Lembre-se: todos os conjuntos devem ser finitos."
                                  ],
                                  "learningObjective": "Compreender e definir precisamente os conjuntos Q, Σ e Γ em um NPDA.",
                                  "commonMistakes": [
                                    "Confundir Σ (entrada) com Γ (pilha).",
                                    "Esquecer que conjuntos são finitos.",
                                    "Incluir ε como símbolo em Σ ou Γ explicitamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar o estado inicial e estados de aceitação",
                                  "subSteps": [
                                    "Defina q0 ∈ Q como o estado inicial único.",
                                    "Defina F ⊆ Q como o conjunto finito de estados finais (de aceitação).",
                                    "Discuta que aceitação pode ser por estado final ou pilha vazia (mas foque em estado final para NPDA padrão).",
                                    "Exemplo: q0 = q0, F = {qf}.",
                                    "Verifique consistência: q0 deve estar em Q, F não vazio tipicamente."
                                  ],
                                  "verification": "Identifique corretamente q0 e F em uma tupla parcial e explique seu papel.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Diagramas de PDA existentes",
                                    "Editor de texto para notação formal"
                                  ],
                                  "tips": [
                                    "q0 é único; F pode ser vazio teoricamente, mas evite em exemplos práticos."
                                  ],
                                  "learningObjective": "Dominar a especificação de q0 e F na definição formal de NPDA.",
                                  "commonMistakes": [
                                    "Confundir aceitação por estado final com pilha vazia.",
                                    "Definir múltiplos q0.",
                                    "Esquecer que F é subconjunto de Q."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a função de transição δ com ênfase no não-determinismo",
                                  "subSteps": [
                                    "Defina δ: Q × (Σ ∪ {ε}) × (Γ ∪ {ε}) → ℘(Q × Γ*), onde ℘ denota conjunto das partes (subconjuntos finitos).",
                                    "Explique que δ(q, a, X) retorna um conjunto finito de pares (p, α), permitindo múltiplas transições (não-determinismo).",
                                    "Exemplo: δ(q0, ε, Z) = {(q1, AZ), (q2, BZ)} – duas opções.",
                                    "Compare com DPDA: δ mapeia para no máximo um par.",
                                    "Pratique notação: Γ* para strings finitas da pilha."
                                  ],
                                  "verification": "Escreva δ corretamente para um exemplo simples, mostrando múltiplas saídas.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Exemplos de NPDA de livros",
                                    "Ferramenta online de autômatos (ex: JFLAP)"
                                  ],
                                  "tips": [
                                    "Sempre use ℘ ou 2^ para indicar subconjuntos.",
                                    "Visualize ramificações como árvore de computação."
                                  ],
                                  "learningObjective": "Entender e formalizar δ, destacando o poder do não-determinismo via múltiplas transições.",
                                  "commonMistakes": [
                                    "Escrever δ como função total (apenas um output).",
                                    "Confundir Γ com Γ*.",
                                    "Ignorar ε em entrada ou pilha."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e validar a definição completa da tupla quíntupla",
                                  "subSteps": [
                                    "Combine todos: NPDA = (Q, Σ, Γ, δ, q0, F).",
                                    "Valide: δ bem-definida, domínios corretos, consistência de símbolos.",
                                    "Crie um NPDA completo simples para linguagem {a^n b^n | n≥0}.",
                                    "Teste mentalmente uma string: trace ramificações não-determinísticas.",
                                    "Discuta equivalência com PDA padrão."
                                  ],
                                  "verification": "Escreva uma tupla completa válida e simule uma computação.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "JFLAP ou simulador de PDA",
                                    "Folhas de exercícios"
                                  ],
                                  "tips": [
                                    "Verifique tipos: δ deve retornar subconjuntos de Q × Γ*."
                                  ],
                                  "learningObjective": "Construir e validar formalmente um NPDA completo.",
                                  "commonMistakes": [
                                    "Ordem errada da tupla.",
                                    "δ com domínio ou codomínio incorreto.",
                                    "Exemplos que são determinísticos disfarçados."
                                  ]
                                }
                              ],
                              "practicalExample": "Defina um NPDA para L = {a^n b^n | n ≥ 0}: Q = {q0, q1, q2}, Σ = {a, b}, Γ = {Z, A}, q0 = q0, F = {q2}, δ(q0, ε, Z) = {(q1, Z)}, δ(q1, a, Z) = {(q1, A Z)}, δ(q1, a, A) = {(q1, A A)}, δ(q1, b, A) = {(q1, ε)}, δ(q1, ε, Z) = {(q2, Z)}.",
                              "finalVerifications": [
                                "Recitar a tupla quíntupla completa sem erros.",
                                "Explicar δ com exemplo de múltiplas transições.",
                                "Diferenciar NPDA de DPDA via não-determinismo.",
                                "Validar um NPDA dado com string de teste.",
                                "Montar tupla para linguagem simples fornecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal de δ (80% peso).",
                                "Correta ênfase no não-determinismo (múltiplos outputs).",
                                "Consistência de símbolos entre Σ, Γ e δ.",
                                "Exemplo prático funcional e relevante.",
                                "Explicação clara de cada componente.",
                                "Ausência de confusões com PDA determinístico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e funções parciais.",
                                "Lógica: Não-determinismo similar a backtracking em programação.",
                                "Engenharia de Software: Parsers LL/LR em compiladores.",
                                "Filosofia da Computação: Limites da computação determinística."
                              ],
                              "realWorldApplication": "NPDAs modelam parsers não-determinísticos em compiladores para linguagens livres de contexto, como expressões balanceadas em linguagens de programação (ex: Python parser usa conceitos semelhantes para análise sintática eficiente)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Construir um NPDA para linguagem livre de contexto",
                            "description": "Criar um NPDA para linguagens como {ww^R | w ∈ {a,b}*}, utilizando não-determinismo para adivinhar o ponto médio da palavra.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a linguagem {ww^R | w ∈ {a,b}*} e conceitos básicos de NPDA",
                                  "subSteps": [
                                    "Defina formalmente a linguagem {ww^R | w ∈ {a,b}*}, onde w^R é o reverso de w.",
                                    "Gere exemplos concretos: para w = 'ab', ww^R = 'abba'; para w = 'baab', ww^R = 'baabbaab'.",
                                    "Explique por que essa linguagem é livre de contexto (CFL) mas não regular, usando a pilha para memória de w.",
                                    "Revise a definição formal de NPDA: (Q, Σ, Γ, δ, q0, Z0, F), destacando transições não-determinísticas.",
                                    "Compare NPDAs com DPDA, enfatizando o não-determinismo para 'adivinhar' o ponto médio."
                                  ],
                                  "verification": "Liste 5 exemplos válidos e 3 inválidos da linguagem; descreva em palavras como um NPDA reconheceria 'abba'.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Referência: Livro 'Introduction to Automata Theory' de Hopcroft & Ullman (cap. PDA)",
                                    "Ferramenta online como JFLAP para visualização"
                                  ],
                                  "tips": [
                                    "Use tabelas para listar exemplos; desenhe pilha manualmente para um exemplo simples."
                                  ],
                                  "learningObjective": "Entender a estrutura da linguagem e o papel do não-determinismo em NPDAs para CFLs.",
                                  "commonMistakes": [
                                    "Confundir ww^R com palíndromos ímpares",
                                    "Ignorar que w pode ser vazio",
                                    "Esquecer símbolos de pilha além de a/b"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a fase de empilhamento para a primeira metade (w)",
                                  "subSteps": [
                                    "Defina estados iniciais: q0 (inicial), q_push (empilhando w).",
                                    "Crie transições: de q0, em a ou b, empilhe o símbolo correspondente e vá para q_push (não-determinístico para continuar empilhando).",
                                    "Introduza não-determinismo: de q_push, opção ε-transição para q_match (adivinhar fim de w).",
                                    "Garanta que a pilha comece com Z0 (símbolo bottom) e empilhe símbolos de Γ = {Z0, a, b}.",
                                    "Desenhe diagrama parcial do NPDA focando nessa fase."
                                  ],
                                  "verification": "Simule empilhamento para w='ab': pilha deve ser [Z0, a, b] no topo antes de matching.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "JFLAP ou draw.io para diagramas",
                                    "Papel para simulações de pilha",
                                    "Exemplos impressos de palavras"
                                  ],
                                  "tips": [
                                    "Sempre inclua Z0 para evitar underflow; teste com w vazio (aceita via ε para q_accept)."
                                  ],
                                  "learningObjective": "Dominar o uso da pilha para armazenar w durante a leitura inicial.",
                                  "commonMistakes": [
                                    "Empilhar reverso de w (deve ser w mesmo)",
                                    "Não usar não-determinismo para transição ε",
                                    "Pop prematuro na fase push"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar a fase de matching para a segunda metade (w^R)",
                                  "subSteps": [
                                    "Defina estado q_match: leia próximo símbolo e pop da pilha se combinar.",
                                    "Transições: em a, pop a (topo deve ser a); em b, pop b; se mismatch, rejeitar.",
                                    "Após matching completo, transição ε para q_accept se pilha tem só Z0.",
                                    "Integre com fase anterior: de q_push via ε para q_match.",
                                    "Adicione loops em q_match para múltiplos símbolos."
                                  ],
                                  "verification": "Simule para 'abba': push a,b; match b (pop b), a (pop a); pilha Z0 -> aceitar.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "JFLAP para simulação passo-a-passo",
                                    "Tabela de transições em Excel ou papel"
                                  ],
                                  "tips": [
                                    "Pense na pilha como LIFO: último empilhado (fim de w) match primeiro de w^R.",
                                    "Use múltiplas transições ε para flexibilidade."
                                  ],
                                  "learningObjective": "Implementar matching bidirecional usando não-determinismo para alinhar metades.",
                                  "commonMistakes": [
                                    "Ler segunda metade sem pop",
                                    "Não verificar Z0 no final",
                                    "Determinismo forçado (perde poder expressivo)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a definição do NPDA e testar com casos variados",
                                  "subSteps": [
                                    "Escreva δ formalmente: liste todas transições (push, pop, ε-move).",
                                    "Defina Q = {q0, q_push, q_match, q_accept, q_reject}, F = {q_accept}.",
                                    "Teste casos: válidos ('', 'aa', 'abba', 'baab'); inválidos ('ab', 'aba', 'abc').",
                                    "Simule pelo menos 3 caminhos não-determinísticos, mostrando aceitação/rejeição.",
                                    "Otimize: remova estados redundantes ou transições desnecessárias."
                                  ],
                                  "verification": "Forneça definição completa δ e simulações corretas para 5 strings.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de texto para δ formal",
                                    "JFLAP para execução automatizada",
                                    "Lista de strings de teste"
                                  ],
                                  "tips": [
                                    "Use notação δ(q, a, X) = {(p, α)} para múltiplas opções.",
                                    "Registre todos branches não-determinísticos."
                                  ],
                                  "learningObjective": "Formalizar e validar o NPDA contra a linguagem exata.",
                                  "commonMistakes": [
                                    "Transições incompletas (crash em inputs)",
                                    "Aceitar strings fora da linguagem",
                                    "Esquecer reject sink"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar propriedades e generalizar para outras CFLs",
                                  "subSteps": [
                                    "Prove que reconhece {ww^R}: argumente cobertura de todos w e rejeição de outros.",
                                    "Discuta equivalência com gramática CFG para ww^R.",
                                    "Compare com PDA para palíndromos: similaridades/diferenças.",
                                    "Estenda ideia: adapte para {w w | w ∈ {a,b}*} (sem reverso).",
                                    "Documente lições: poder do não-determinismo em adivinhação."
                                  ],
                                  "verification": "Escreva prova curta de corretude e adaptação para variação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas anteriores",
                                    "Referência CFG para ww^R"
                                  ],
                                  "tips": [
                                    "Use indução em |w| para prova.",
                                    "Conecte a parsing bottom-up."
                                  ],
                                  "learningObjective": "Entender generalizações e limitações de NPDAs.",
                                  "commonMistakes": [
                                    "Confundir ww^R com ww",
                                    "Ignorar não-CFLs que NPDAs não reconhecem"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa NPDA para w='abab': push a,b,a,b; não-det. ε para match; leia b(pop b), a(pop a), b(pop b), a(pop a); Z0 resta -> aceita 'abababab'. Para 'ababa' (ímpar): nenhum branch matcha completamente -> rejeita.",
                              "finalVerifications": [
                                "Simule corretamente 5 strings: 3 aceitas, 2 rejeitadas.",
                                "Pilha termina com apenas Z0 em aceitação.",
                                "Todas transições δ cobrem alfabeto e pilha.",
                                "Não-determinismo usado essencialmente para adivinhar meio.",
                                "Definição formal sem ambiguidades.",
                                "Prova de corretude para pelo menos um caso."
                              ],
                              "assessmentCriteria": [
                                "Precisão da definição δ: completa e correta (40%)",
                                "Simulações demonstram reconhecimento/rejeição (30%)",
                                "Uso efetivo de não-determinismo e pilha (20%)",
                                "Clareza do diagrama e explicações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e indução para provas de corretude.",
                                "Programação: Parsing em compiladores (ex: Yacc usa ideias semelhantes).",
                                "Lógica: Não-determinismo análogo a backtracking em algoritmos.",
                                "Engenharia de Software: Modelagem de sistemas com memória finita (pilha)."
                              ],
                              "realWorldApplication": "NPDAs modelam parsers para linguagens de programação (ex: expressões balanceadas em C++), validação de XML/JSON aninhados, e algoritmos de reconhecimento em NLP para estruturas recursivas como sentenças palindrômicas em processamento de texto."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Explicar o papel do não-determinismo em NPDA",
                            "description": "Discutir como o não-determinismo permite reconhecimento de todas as linguagens livres de contexto (CFLs), com simulação via árvore de computação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Autômatos de Pilha Determinísticos e Não-Determinísticos",
                                  "subSteps": [
                                    "Defina as componentes de um PDA: estados, alfabeto de entrada, alfabeto da pilha, função de transição, estado inicial, símbolo inicial da pilha e estados de aceitação.",
                                    "Explique a transição determinística (DPDA): exatamente uma transição possível para cada configuração.",
                                    "Descreva a transição não-determinística (NPDA): múltiplas transições possíveis, incluindo ε-transições.",
                                    "Compare linguagens reconhecíveis: DPDA reconhecem DCFLs, NPDA reconhecem todas as CFLs.",
                                    "Discuta aceitação por estado final vs. pilha vazia."
                                  ],
                                  "verification": "Escreva definições precisas e liste pelo menos 3 diferenças entre DPDA e NPDA em um diagrama comparativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre autômatos",
                                    "Livro 'Introduction to Automata Theory' de Hopcroft",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Desenhe diagramas de transição para visualizar múltiplas escolhas no NPDA.",
                                  "learningObjective": "Compreender as diferenças fundamentais entre determinismo e não-determinismo em PDAs.",
                                  "commonMistakes": [
                                    "Confundir aceitação por estado final com pilha vazia",
                                    "Achar que DPDA pode reconhecer todas CFLs",
                                    "Ignorar ε-movimentos no não-determinismo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o Poder do Não-Determinismo para Reconhecer Todas as CFLs",
                                  "subSteps": [
                                    "Lembre o teorema: Toda linguagem livre de contexto é reconhecida por um NPDA.",
                                    "Discuta por que DPDA são limitados a DCFLs (ex: {a^n b^n | n≥0} é DCFL, mas {ww^R} não é).",
                                    "Explique que não-determinismo permite 'adivinhação' correta em uma das ramificações.",
                                    "Conecte com gramáticas livres de contexto via construção de NPDA a partir de GLC.",
                                    "Aborde closure properties: CFLs não são fechadas sob complemento, justificando limitação de DPDA."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que todo CFL tem NPDA, citando um teorema chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de gramáticas GLC",
                                    "Ferramenta online como JFLAP para simular PDAs",
                                    "Referências teóricas sobre CFLs"
                                  ],
                                  "tips": "Use contraexemplos como palíndromos para mostrar falha de DPDA.",
                                  "learningObjective": "Identificar como não-determinismo expande o poder expressivo para todas CFLs.",
                                  "commonMistakes": [
                                    "Pensar que não-determinismo torna computação mais lenta (é sobre poder, não eficiência)",
                                    "Confundir NPDA com NTM",
                                    "Esquecer que NPDA não decide todas linguagens recursivas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Simulação de NPDA via Árvore de Computação",
                                  "subSteps": [
                                    "Defina configuração de NPDA: (estado, resto da entrada, conteúdo da pilha).",
                                    "Construa a árvore de computação: nós são configurações, arestas são transições não-determinísticas.",
                                    "Explique aceitação: existe um caminho da raiz à folha aceitadora (entrada consumida, estado final).",
                                    "Simule um exemplo simples: NPDA para {a^n b^n c^n} (não DCFL, requer adivinhação).",
                                    "Discuta simulação determinística: backtracking ou BFS na árvore para decidir aceitação."
                                  ],
                                  "verification": "Desenhe a árvore de computação para uma entrada curta em um NPDA exemplo e identifique caminhos aceitadores.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "JFLAP ou simulador de NPDA online",
                                    "Papel para desenhar árvores",
                                    "Exemplos de entradas como 'aabbcc'"
                                  ],
                                  "tips": "Comece com entradas pequenas (n=1 ou 2) para evitar árvores muito grandes.",
                                  "learningObjective": "Dominar o mecanismo conceitual de simulação não-determinística via exploração de árvore.",
                                  "commonMistakes": [
                                    "Confundir árvore de computação com grafo de estados",
                                    "Ignorar loops infinitos via ε-loops",
                                    "Achar que todas ramificações devem aceitar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Aplicar o Conceito com Exemplos Práticos",
                                  "subSteps": [
                                    "Construa NPDA para ww^R usando não-determinismo para 'adivinhar' o centro.",
                                    "Compare com DPDA: mostre por que falha em ww^R devido à necessidade de lookahead ilimitado.",
                                    "Discuta equivalência NPDA ~ CFLs e implicações para parsing.",
                                    "Resolva exercícios: prove que um CFL dado requer não-determinismo.",
                                    "Reflita sobre conversão NPDA para DPDA quando possível (potência de dois)."
                                  ],
                                  "verification": "Construa e simule um NPDA completo para um CFL não-DCFL, explicando o papel do não-determinismo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JFLAP para construção",
                                    "Lista de exercícios de teoria da computação",
                                    "Exemplos de CFLs como palíndromos"
                                  ],
                                  "tips": "Teste o NPDA com entradas aceitadoras e rejeitadoras para validar.",
                                  "learningObjective": "Aplicar o conhecimento para explicar e construir NPDA dependentes de não-determinismo.",
                                  "commonMistakes": [
                                    "Construir PDA determinístico acidentalmente",
                                    "Esquecer verificação de pilha vazia",
                                    "Não testar múltiplas ramificações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a linguagem de palíndromos pares {ww^R | w ∈ {a,b}*}, um NPDA usa não-determinismo para adivinhar o momento exato do centro da string: em algum ponto, transita para modo de 'pop' comparando símbolos invertidos na pilha, aceitando se uma ramificação da árvore de computação consome toda a entrada corretamente.",
                              "finalVerifications": [
                                "Explicar com precisão por que NPDA reconhecem todas CFLs mas DPDA não.",
                                "Desenhar corretamente uma árvore de computação para uma entrada em NPDA.",
                                "Identificar exemplos de CFLs que requerem não-determinismo.",
                                "Discutir simulação determinística de NPDA via backtracking.",
                                "Construir um NPDA simples para um CFL dado.",
                                "Comparar poder de NPDA com FSA e TM."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta de não-determinismo e seu papel único em CFLs (30%)",
                                "Uso de exemplos: inclusão de pelo menos um CFL não-DCFL com diagrama (25%)",
                                "Explicação da árvore de computação: clareza na descrição de ramificações e aceitação (20%)",
                                "Profundidade teórica: citação de teoremas como equivalência NPDA-CFL (15%)",
                                "Aplicação prática: habilidade em simular ou construir NPDA (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de árvores e grafos na simulação de não-determinismo.",
                                "Engenharia de Computação: Parsing em compiladores (parsers não-determinísticos resolvidos por tabelas LR).",
                                "Filosofia da Computação: Debate sobre não-determinismo quântico vs. clássico.",
                                "Inteligência Artificial: Busca não-determinística em algoritmos como A* com heurísticas."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens de programação, NPDA subjacentes em parsers (ex: Yacc/Bison) usam não-determinismo resolvido por tabelas de parsing para analisar sintaxe ambígua, permitindo reconhecimento eficiente de linguagens como C++ ou Python."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Diferenças entre DPDA e NPDA",
                        "description": "Principais distinções em termos de determinismo, poder expressivo e condições de equivalência.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Identificar diferenças estruturais",
                            "description": "Comparar a função de transição: única em DPDA vs. múltipla em NPDA; ausência de ε-transições em alguns modelos de DPDA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de DPDA e NPDA",
                                  "subSteps": [
                                    "Leia a definição formal de um Autômato de Pilha Determinístico (DPDA): conjunto finito de estados Q, alfabeto de entrada Σ, alfabeto da pilha Γ, função de transição δ: Q × (Σ ∪ {ε}) × Γ → Q × Γ* única para cada entrada.",
                                    "Leia a definição formal de um Autômato de Pilha Não-Determinístico (NPDA): função de transição δ: Q × (Σ ∪ {ε}) × Γ → 2^(Q × Γ*) que pode retornar múltiplos valores.",
                                    "Anote as componentes comuns: estados, alfabeto de entrada, pilha.",
                                    "Identifique as diferenças iniciais na assinatura da função δ.",
                                    "Desenhe diagramas esquemáticos simples de um DPDA e NPDA genérico."
                                  ],
                                  "verification": "Confirme se você pode recitar as definições e apontar diferenças na função δ sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Teoria da Computação (capítulo de Autômatos de Pilha)",
                                    "Papel e caneta para diagramas",
                                    "Notas de aula sobre linguagens formais"
                                  ],
                                  "tips": "Use tabelas para comparar definições lado a lado para visualização clara.",
                                  "learningObjective": "Entender as bases formais de DPDA e NPDA para estabelecer o contexto das diferenças estruturais.",
                                  "commonMistakes": [
                                    "Confundir ε-transições como obrigatórias em ambos",
                                    "Ignorar o poder não-determinístico da pilha em NPDA"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Função de Transição: Unicidade em DPDA vs. Múltiplas em NPDA",
                                  "subSteps": [
                                    "Estude exemplos de funções δ para DPDA: para cada (q, a, Z), existe exatamente uma transição (p, α).",
                                    "Estude exemplos de funções δ para NPDA: para cada (q, a, Z), δ pode retornar conjunto vazio, um ou múltiplos pares (p_i, α_i).",
                                    "Simule uma transição em um DPDA para uma entrada específica, mostrando determinismo.",
                                    "Simule a mesma transição em um NPDA equivalente, ramificando em múltiplas possibilidades.",
                                    "Registre como o determinismo afeta a simulação sequencial."
                                  ],
                                  "verification": "Execute uma simulação manual de transição em ambos os modelos e explique por que uma é única e a outra não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de autômatos de pilha de tutoriais online (ex: linguagem {a^n b^n})",
                                    "Simulador de PDA online ou software como JFLAP"
                                  ],
                                  "tips": "Comece com linguagens regulares empilhadas para simplicidade antes de context-free reais.",
                                  "learningObjective": "Diferenciar a unicidade da transição em DPDA da não-determinística em NPDA.",
                                  "commonMistakes": [
                                    "Assumir que NPDA sempre tem múltiplas transições",
                                    "Esquecer que DPDA pode ter ε-transições em alguns modelos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar o Papel das ε-Transições em Modelos de DPDA",
                                  "subSteps": [
                                    "Pesquise variações de DPDA: alguns modelos proíbem ε-transições na entrada (DPDA sem ε-move), outros permitem.",
                                    "Compare com NPDA, que sempre permite ε-transições livremente.",
                                    "Construa um exemplo de DPDA sem ε-transições reconhecendo {a^n b^n}.",
                                    "Tente converter para um modelo com ε-transições e note impactos na determinismo.",
                                    "Liste restrições impostas pela ausência de ε em certos DPDA."
                                  ],
                                  "verification": "Crie um diagrama de DPDA sem ε-transições e valide se mantém determinismo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JFLAP ou simulador PDA",
                                    "Referências acadêmicas sobre modelos equivalentes de PDA (Sipser ou Hopcroft/Ullman)"
                                  ],
                                  "tips": "Lembre-se: ausência de ε simplifica prova de equivalência, mas não é universal.",
                                  "learningObjective": "Identificar como a ausência de ε-transições em alguns DPDA afeta a estrutura comparada ao NPDA.",
                                  "commonMistakes": [
                                    "Generalizar todos DPDA como sem ε",
                                    "Confundir ε na entrada vs. ε na pilha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Identificar Diferenças Estruturais Completas",
                                  "subSteps": [
                                    "Compile uma tabela comparativa: função δ (única vs. múltipla), ε-transições (restritas vs. livres), impacto no poder expressivo.",
                                    "Discuta como essas diferenças afetam reconhecimento de linguagens DCFL vs. CFL.",
                                    "Aplique a uma linguagem exemplo: mostre DPDA para palíndromos pares vs. NPDA necessário para ímpares.",
                                    "Teste identificação em novos exemplos.",
                                    "Resuma em bullet points as diferenças estruturais chave."
                                  ],
                                  "verification": "Produza uma tabela ou lista de 5 diferenças estruturais precisas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em branco",
                                    "Exemplos de linguagens DCFL e não-DCFL"
                                  ],
                                  "tips": "Foque em estrutura formal, não em poder computacional ainda.",
                                  "learningObjective": "Capacitar identificação precisa de diferenças estruturais entre DPDA e NPDA.",
                                  "commonMistakes": [
                                    "Misturar diferenças estruturais com diferenças de poder",
                                    "Omitir variações em modelos DPDA"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a linguagem L = {a^n b^n | n ≥ 0}. Construa um DPDA determinístico sem ε-transições na entrada: empilhe 'A' para cada 'a', pop para cada 'b'. Agora, para L' = {ww^R | w em {a,b}* } (palíndromos), um NPDA usa não-determinismo para adivinhar o centro, com múltiplas transições de ε para copiar/validar, impossível em DPDA sem ε.",
                              "finalVerifications": [
                                "Pode definir δ para DPDA e NPDA corretamente?",
                                "Identifica unicidade em transições DPDA vs. ramificação em NPDA?",
                                "Explica ausência de ε em alguns DPDA?",
                                "Lista pelo menos 3 diferenças estruturais?",
                                "Simula diferenças em um exemplo concreto?",
                                "Distingue estrutura de poder expressivo?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da função de transição (única vs. múltipla): 25%",
                                "Compreensão de ε-transições e variações de modelo: 25%",
                                "Capacidade de exemplos comparativos corretos: 20%",
                                "Tabela ou síntese clara de diferenças: 15%",
                                "Simulações manuais sem erros: 15%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e funções (δ como função total vs. relação)",
                                "Lógica: Determinismo vs. Não-determinismo em sistemas formais",
                                "Engenharia de Software: Parsing determinístico em compiladores (LL vs. LR)",
                                "Filosofia da Computação: Limites do determinismo computacional"
                              ],
                              "realWorldApplication": "Em compiladores, DPDA são usados em parsers LR(1) determinísticos para análise sintática eficiente sem ambiguidades, contrastando com parsers não-determinísticos em ferramentas como ANTLR para linguagens complexas, otimizando performance em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Analisar exemplos de linguagens não reconhecíveis por DPDA",
                            "description": "Mostrar que o palíndromo {ww^R} requer NPDA, mas não DPDA, devido à necessidade de adivinhação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e exemplos da linguagem {ww^R}",
                                  "subSteps": [
                                    "Defina formalmente {ww^R} como { w w^R | w ∈ {a,b}^* }, onde w^R é o reverso de w.",
                                    "Gere exemplos concretos: aa (w=a), abba (w=ab), abaaba (w=aba).",
                                    "Identifique strings não pertencentes: ab (não palíndromo simétrico), aabbaa (w= aab? não reverso).",
                                    "Discuta propriedades: comprimento par, simetria em torno do centro.",
                                    "Compare com palíndromos pares clássicos para destacar semelhança."
                                  ],
                                  "verification": "Liste 5 strings na linguagem e 3 fora dela, justificando cada uma.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, tabela de símbolos do alfabeto {a,b}, referência de livro de teoria da computação (Sipser ou similar).",
                                  "tips": "Sempre verifique simetria manualmente dobrando a string no meio.",
                                  "learningObjective": "Dominar a definição precisa e reconhecimento intuitivo de {ww^R}.",
                                  "commonMistakes": "Confundir com palíndromos ímpares (como {w c w^R}); ignorar strings vazias ou unitárias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir um NPDA que reconhece {ww^R}",
                                  "subSteps": [
                                    "Desenhe estados: q0 (inicial), q1 (lendo w), q2 (não-determinístico: adivinha fim de w), q3 (lendo w^R).",
                                    "Defina transições: em q0/q1, empilhe símbolos de w; em q2, ε-transição para q3 sem empilhar; em q3, desempilhe comparando com w^R.",
                                    "Inclua estado de aceitação q_accept após pilha vazia e fim da string.",
                                    "Trace o exemplo 'abba': empilha 'a','b'; adivinha, desempilha 'b','a'.",
                                    "Teste com múltiplos ramos não-determinísticos para falhas."
                                  ],
                                  "verification": "Simule o NPDA em 3 strings (2 aceitas, 1 rejeitada) mostrando todos os ramos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramenta de desenho de autômatos (JFLAP ou papel), exemplos de strings impressos.",
                                  "tips": "Use não-determinismo apenas na transição chave para adivinhar o meio.",
                                  "learningObjective": "Projetar NPDA aproveitando não-determinismo para adivinhação.",
                                  "commonMistakes": "Fazer todas transições determinísticas; esquecer ε-transições ou estado de pilha vazia."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar que {ww^R} não é reconhecida por DPDA",
                                  "subSteps": [
                                    "Lembre que DCFL (linguagens de DPDA) são fechadas sob complementação, mas CFL não.",
                                    "Use argumento de adivinhação: DPDA deve decidir deterministicamente quando parar de empilhar.",
                                    "Considere strings ambíguas como a^n b a^n b: possível fim de w em vários pontos.",
                                    "Aplique lemma de bombeamento para DCFL ou reduza a linguagem ww^R para provar não-DCFL.",
                                    "Compare com {ww} que é DCFL, destacando o reverso como problema."
                                  ],
                                  "verification": "Escreva um argumento formal de 200 palavras provando impossibilidade para DPDA.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Referências teóricas (Hopcroft/Ullman), quadro branco para diagramas.",
                                  "tips": "Foque no 'pumping' ou 'adivinhação' como prova chave; evite provas complexas inicialmente.",
                                  "learningObjective": "Entender limites teóricos de DPDA via contra-exemplos.",
                                  "commonMistakes": "Confundir com prova para PDA determinístico com ε-moves; ignorar closure properties."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a necessidade de não-determinismo e sintetizar",
                                  "subSteps": [
                                    "Explique 'adivinhação': NPDA ramifica em possíveis centros; DPDA não pode.",
                                    "Discuta conversão NPDA para DPDA: resulta em estado explosão (2^{|q|*|Γ|}).",
                                    "Compare poder expressivo: DCFL ⊂ CFL determinístico ≠ todo CFL.",
                                    "Crie variação: {w w^R w} e discuta similaridades.",
                                    "Resuma diferenças DPDA vs NPDA com tabela."
                                  ],
                                  "verification": "Crie tabela comparativa e explique verbalmente para um par.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela comparativa em Excel ou papel, vídeo tutorial de NPDA.",
                                  "tips": "Use analogia: adivinhação como 'fork' em programação paralela.",
                                  "learningObjective": "Sintetizar por que {ww^R} exemplifica poder extra de NPDA.",
                                  "commonMistakes": "Subestimar impacto do reverso; confundir com linguagens regulares."
                                }
                              ],
                              "practicalExample": "Para string 'abcbca' (w=abc, w^R= cba? Espera, correto: abcbca? w=abc, w^R=cba, sim abccba. Trace NPDA: empilha a,b,c; adivinha, desempilha b,c,a? Não: para abccba: empilha a,b,c; match c,b,a. DPDA falha sem saber quando parar empilhar após 'abc'.",
                              "finalVerifications": [
                                "Construir e simular NPDA corretamente para 3 exemplos.",
                                "Explicar argumento de adivinhação sem erros.",
                                "Provar rejeição de string fora da linguagem.",
                                "Identificar pelo menos 2 propriedades de DCFL violadas.",
                                "Desenhar diagrama completo do NPDA.",
                                "Discutir closure properties relevantes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição da linguagem (20%)",
                                "Correção e completude do NPDA (25%)",
                                "Força do argumento de impossibilidade para DPDA (30%)",
                                "Clareza na análise de não-determinismo (15%)",
                                "Uso de exemplos e verificações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos (estados como nós, transições como arestas)",
                                "Programação: Pilhas em recursão e parsers (ex: Python stack)",
                                "Lógica: Provas por contradição e impossibilidade",
                                "Engenharia de Software: Análise de complexidade em autômatos finitos"
                              ],
                              "realWorldApplication": "Em compiladores, parsers determinísticos (LR) vs não-determinísticos (LL); design de linguagens de programação onde simetria requer lookahead ou backtracking, como em editores de texto para matching de expressões regulares avançadas ou validação de XML balanceado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Discutir conversão de NPDA para DPDA",
                            "description": "Explicar que nem todo NPDA tem equivalente DPDA, citando teoremas de Hopcroft & Ullman sobre subconjunto próprio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de NPDA e DPDA",
                                  "subSteps": [
                                    "Defina formalmente um NPDA: conjunto de estados, alfabeto, pilha, função de transição não-determinística.",
                                    "Defina formalmente um DPDA: similar, mas função de transição determinística (no máximo uma transição por configuração).",
                                    "Compare modelos de computação: NPDA aceita CFLs, DPDA aceita DCFLs.",
                                    "Discuta aceitação por estado final vs. pilha vazia.",
                                    "Identifique restrições do determinismo na pilha."
                                  ],
                                  "verification": "Resuma as diferenças em um diagrama comparativo e explique verbalmente para um par.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to Automata Theory, Languages, and Computation' de Hopcroft & Ullman (Cap. 8)",
                                    "Notas de aula sobre autômatos de pilha",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Use diagramas de transição para visualizar não-determinismo vs. determinismo.",
                                  "learningObjective": "Compreender as definições formais e diferenças chave entre NPDA e DPDA.",
                                  "commonMistakes": [
                                    "Confundir aceitação por pilha vazia com estado final",
                                    "Ignorar ε-transições no NPDA",
                                    "Achar que todo PDA é determinístico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Teoremas Relevantes de Hopcroft & Ullman",
                                  "subSteps": [
                                    "Leia Teorema 8.3: Conjunto de linguagens de DPDA é subconjunto próprio das CFLs.",
                                    "Analise prova de que toda DCFL é CFL (construção de NPDA a partir de DPDA).",
                                    "Estude existência de CFLs não-determinísticas (ex: ww^R requer não-determinismo).",
                                    "Discuta closure properties: DCFLs não fechadas sob união ou concatenação.",
                                    "Cite referências exatas do livro (páginas 200-210 approx.)."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras dos teoremas e prove um lema auxiliar.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Hopcroft & Ullman (edição 2ª, Cap. 8)",
                                    "Artigos acadêmicos sobre DCFLs",
                                    "PDF do teorema online via Google Scholar"
                                  ],
                                  "tips": "Anote provas em pseudocódigo para facilitar compreensão.",
                                  "learningObjective": "Memorizar e explicar teoremas que mostram DCFL ⊂ CFL propriamente.",
                                  "commonMistakes": [
                                    "Confundir subconjunto próprio com igualdade",
                                    "Ignorar contra-exemplos na prova",
                                    "Não citar fontes corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Limitações da Conversão NPDA para DPDA",
                                  "subSteps": [
                                    "Explique por que conversão power-set (como em NFA para DFA) falha devido à pilha infinita.",
                                    "Discuta ambiguidade em NPDAs e necessidade de determinismo.",
                                    "Explore condições para convertibilidade (ex: PDA sem ε-moves ou prefix-free).",
                                    "Analise por que alguns NPDAs requerem adivinhação (não-determinismo essencial).",
                                    "Construa argumento geral: se toda CFL fosse DCFL, contradiz teoremas."
                                  ],
                                  "verification": "Desenhe um NPDA não-convertível e justifique por que não há DPDA equivalente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Simulador de PDA online (ex: JFLAP)",
                                    "Papel e lápis para diagramas",
                                    "Notas de aula sobre power-set construction"
                                  ],
                                  "tips": "Teste simulações em JFLAP para ver branches não-determinísticos.",
                                  "learningObjective": "Identificar razões técnicas pelas quais conversão nem sempre existe.",
                                  "commonMistakes": [
                                    "Aplicar power-set construction sem considerar pilha",
                                    "Achar que ε-eliminação resolve tudo",
                                    "Confundir com conversões de autômatos finitos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar Exemplos e Contra-Exemplos Práticos",
                                  "subSteps": [
                                    "Construa NPDA para {a^n b^n | n≥0} e mostre conversão trivial para DPDA.",
                                    "Analise NPDA para {ww^R | w∈{a,b}*} e prove ausência de DPDA equivalente.",
                                    "Discuta linguagem {a^n b^m | n≤m≤2n} como CFL não-DCFL.",
                                    "Simule execuções e compare comportamentos.",
                                    "Debata implicações para parsing em compiladores."
                                  ],
                                  "verification": "Apresente um exemplo convertível e um não-convertível com provas curtas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "JFLAP ou PDA simulator",
                                    "Exemplos de linguagens de Hopcroft (Cap. 8)",
                                    "Whiteboard para discussões"
                                  ],
                                  "tips": "Comece com linguagens simples para construir intuição antes de complexas.",
                                  "learningObjective": "Aplicar conceitos a exemplos concretos para ilustrar teoremas.",
                                  "commonMistakes": [
                                    "Escolher exemplos errados (ex: palíndromos ímpares são DCFL)",
                                    "Não provar não-existência de DPDA",
                                    "Ignorar ambiguidade na simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o NPDA para a linguagem de palíndromos pares {ww^R | w∈{a,b}*}, que usa não-determinismo para adivinhar o centro. Tentativas de determinizar falham porque o DPDA precisaria prever o comprimento de w sem informação prévia, levando a rejeição prematura ou loops infinitos na pilha. Simule em JFLAP: o NPDA aceita 'ab ba', mas nenhum DPDA equivalente existe, conforme Teorema 8.3 de Hopcroft & Ullman.",
                              "finalVerifications": [
                                "Explicar verbalmente por que DCFLs formam subconjunto próprio de CFLs.",
                                "Construir NPDA para CFL não-DCFL e argumentar contra DPDA.",
                                "Citar teorema exato de Hopcroft & Ullman com lema chave.",
                                "Identificar 3 linguagens DCFL vs. não-DCFL.",
                                "Discutir falha da power-set construction para PDAs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação de teoremas e provas (70%).",
                                "Uso correto de exemplos/contras-exemplos (20%).",
                                "Clareza na explicação de limitações de conversão (10%).",
                                "Profundidade na análise de não-determinismo essencial.",
                                "Capacidade de simular e debugar PDAs."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Teoria da Computabilidade: Paralelos com reduções Turing.",
                                "Programação: Parsing LL(1) vs. LR(1) em compiladores.",
                                "Matemática Discreta: Conjuntos e subconjuntos próprios em linguagens formais.",
                                "Engenharia de Software: Determinismo em automação de testes."
                              ],
                              "realWorldApplication": "Em compiladores, DPDA são usados para parsing determinístico eficiente (ex: Yacc/Bison para LR parsers), enquanto NPDAs modelam parsers mais poderosos mas ambíguos como Earley; entender limitações guia escolhas em design de linguagens de programação para evitar não-determinismo desnecessário."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.4",
                        "name": "Classes de linguagens reconhecidas",
                        "description": "Linguagens Livres de Contexto Determinísticas (DCFLs) vs. Livres de Contexto (CFLs).",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.4.1",
                            "name": "Definir DCFLs e CFLs",
                            "description": "Estabelecer que DCFLs = L(DPDA) e CFLs = L(NPDA), com DCFLs sendo subconjunto próprio de CFLs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Autômatos de Pilha (PDA, NPDA e DPDA)",
                                  "subSteps": [
                                    "Relembre a definição formal de um Autômato de Pilha Não-Determinístico (NPDA): um 7-tupla (Q, Σ, Γ, δ, q0, Z0, F).",
                                    "Explique as transições não-determinísticas em NPDA, onde δ(q, a, Z) pode produzir múltiplas configurações.",
                                    "Defina DPDA como variante determinística: δ(q, a, Z) produz no máximo uma configuração.",
                                    "Liste as diferenças chave: NPDA pode ter ε-transições e não-determinismo, DPDA é determinístico sem ε em estados finais.",
                                    "Desenhe diagramas simples de um NPDA e DPDA para uma linguagem básica como {a^n b^n}."
                                  ],
                                  "verification": "Crie um diagrama de um NPDA e DPDA para {a^n b^n} e confirme que ambos aceitam a linguagem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to Automata Theory' de Hopcroft & Ullman",
                                    "Papel e caneta para diagramas",
                                    "Ferramenta online como JFLAP"
                                  ],
                                  "tips": "Use JFLAP para simular PDAs e visualizar diferenças entre determinístico e não-determinístico.",
                                  "learningObjective": "Compreender as diferenças estruturais entre NPDA e DPDA como base para suas linguagens.",
                                  "commonMistakes": [
                                    "Confundir ε-transições permitidas em NPDAs com proibições em DPDAs",
                                    "Ignorar que DPDA não aceita por estado vazio em alguns modelos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Context-Free Languages (CFLs) como L(NPDA)",
                                  "subSteps": [
                                    "Estabeleça formalmente: Uma linguagem L é CFL se existe um NPDA M tal que L(M) = L.",
                                    "Explique que CFLs são fechadas sob união, concatenação e Kleene star, mas não necessariamente determinísticas.",
                                    "Prove que toda CFL é aceita por algum NPDA usando gramáticas livres de contexto (GFL → NPDA via CYK ou parsing).",
                                    "Dê exemplos: {a^n b^n | n ≥ 0} é CFL (NPDA push/pop).",
                                    "Discuta pumping lemma para CFLs para caracterização."
                                  ],
                                  "verification": "Construa um NPDA para {a^n b^n c^m | n,m ≥ 0} e simule aceitação de strings específicas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre gramáticas livres de contexto",
                                    "Simulador JFLAP",
                                    "Exemplos de linguagens padrão"
                                  ],
                                  "tips": "Sempre comece com uma gramática GFL e converta para NPDA para validar a definição.",
                                  "learningObjective": "Definir precisamente CFLs e associá-las a NPDAs com exemplos concretos.",
                                  "commonMistakes": [
                                    "Achar que todo CFL tem um DPDA equivalente",
                                    "Confundir CFL com regular languages"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Deterministic Context-Free Languages (DCFLs) como L(DPDA)",
                                  "subSteps": [
                                    "Defina formalmente: L é DCFL se existe um DPDA M com L(M) = L.",
                                    "Especifique restrições: DPDA aceita por estado final, sem ε-transições de estados finais, determinístico.",
                                    "Mostre que DCFLs são fechadas sob complemento (propriedade chave).",
                                    "Exemplo: {a^n b^n | n ≥ 0} é DCFL (DPDA simples push/pop).",
                                    "Compare com CFLs: nem todo CFL é DCFL."
                                  ],
                                  "verification": "Construa um DPDA para {a^n b^n} e verifique determinismo em simulações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JFLAP ou Draw.io para diagramas",
                                    "Referência: Sipser 'Introduction to the Theory of Computation' Capítulo 2"
                                  ],
                                  "tips": "Teste o DPDA com strings inválidas para garantir rejeição determinística.",
                                  "learningObjective": "Definir DCFLs precisamente e destacar suas propriedades determinísticas.",
                                  "commonMistakes": [
                                    "Permitir ε-transições em DPDAs",
                                    "Confundir aceitação por estado vazio com por estado final"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer DCFLs ⊂ CFLs (Subconjunto Próprio)",
                                  "subSteps": [
                                    "Prove DCFLs ⊆ CFLs: Todo DPDA é um NPDA especial (não-determinismo trivial).",
                                    "Mostre que é próprio: Exemplo {ww^R | w ∈ {a,b}*} é CFL (NPDA usa pilha para comparar) mas não DCFL (pumping ou prova de impossibilidade).",
                                    "Use teorema: Existem CFLs inerentemente ambíguas ou requerendo não-determinismo.",
                                    "Discuta implicações: Parsing determinístico (DCFL) vs. backtracking (CFL geral).",
                                    "Resuma hierarquia: Regular ⊂ DCFL ⊂ CFL ⊂ CSL."
                                  ],
                                  "verification": "Escreva uma prova curta de que {ww^R} não é DCFL citando referências ou argumento de pilha.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo ou capítulo sobre ww^R",
                                    "Papel para prova",
                                    "JFLAP para tentativa falha de DPDA"
                                  ],
                                  "tips": "Memorize ww^R como exemplo canônico de CFL não-DCFL para provas rápidas.",
                                  "learningObjective": "Compreender e provar a relação estrita DCFLs ⊂ CFLs.",
                                  "commonMistakes": [
                                    "Achar que DCFLs = CFLs",
                                    "Usar exemplo errado como a^n b^n c^n (que não é CFL)"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um NPDA para a linguagem de palíndromos pares {ww^R | w ∈ {a,b}^*}, simulando push de w e pop comparando w^R. Tente converter para DPDA e veja o conflito no meio da string, provando que é CFL mas não DCFL. Use JFLAP para testar strings como 'ababba' (aceita) e 'ababb' (rejeitada).",
                              "finalVerifications": [
                                "Defina verbalmente DCFLs = L(DPDA) e CFLs = L(NPDA).",
                                "Explique por que DCFLs ⊆ CFLs com justificativa formal.",
                                "Forneça um exemplo de CFL que não é DCFL (ex: ww^R).",
                                "Descreva uma propriedade única de DCFLs (fechado sob complemento).",
                                "Desenhe um DPDA simples para {a^n b^n}.",
                                "Prove que {a^n b^n} é DCFL."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de DCFLs e CFLs (sem omissões).",
                                "Correta identificação da relação subset próprio com prova ou exemplo.",
                                "Uso de exemplos apropriados e simulações corretas.",
                                "Compreensão de propriedades (ex: fechamento sob complemento para DCFLs).",
                                "Capacidade de distinguir NPDA vs DPDA em diagramas.",
                                "Aplicação do conceito em linguagens concretas sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (subconjuntos próprios, hierarquias).",
                                "Lógica: Provas de impossibilidade e lemmas de bombeamento.",
                                "Engenharia de Software: Parsing determinístico em compiladores (ex: LR parsers para DCFLs).",
                                "Linguística Computacional: Modelagem de estruturas aninhadas em linguagem natural.",
                                "Algoritmos: Simulações de PDAs relacionam-se a algoritmos de stack."
                              ],
                              "realWorldApplication": "Em compiladores, parsers determinísticos (DPDA) para linguagens de programação como C (LR(1) grammars geram DCFLs) permitem parsing eficiente sem backtracking, enquanto parsers não-determinísticos (NPDA) são usados em linguagens ambíguas ou context-sensitive, otimizando tempo real em IDEs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.4.2",
                            "name": "Provar propriedades de DCFLs",
                            "description": "Demonstrar que DCFLs são fechadas sob complemento, inversão e união prefixada, diferentemente de CFLs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições e construções básicas de DCFLs e DPDAs",
                                  "subSteps": [
                                    "Defina formalmente DCFL como a classe de linguagens reconhecidas por DPDAs (Deterministic Pushdown Automata).",
                                    "Recapitule propriedades conhecidas de CFLs e DCFLs, destacando que DCFLs são um subconjunto próprio de CFLs.",
                                    "Estude a construção padrão de um DPDA para linguagens clássicas como {a^n b^n | n ≥ 0}.",
                                    "Analise o comportamento determinístico: em cada configuração, no máximo uma transição possível.",
                                    "Compare com NPDAs não-determinísticos para entender diferenças."
                                  ],
                                  "verification": "Construa um DPDA simples para uma DCFL conhecida e simule sua execução em 3 strings de teste.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to Automata Theory' de Hopcroft/Ullman (cap. DPDA), notas de aula sobre linguagens formais"
                                  ],
                                  "tips": "Use diagramas para visualizar o DPDA; foque na pilha como memória determinística.",
                                  "learningObjective": "Compreender as bases formais de DCFLs para preparar provas de fechamento.",
                                  "commonMistakes": [
                                    "Confundir DPDA com NPDA",
                                    "Ignorar o comportamento determinístico na pilha",
                                    "Esquecer que DCFLs ⊆ CFLs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar fechamento de DCFLs sob complemento",
                                  "subSteps": [
                                    "Dado um DPDA M reconhecendo L (DCFL), construa M' que reconhece complemento de L.",
                                    "Modifique M para simular M invertendo aceitação/rejeição, ajustando estados finais.",
                                    "Prove que M' é determinístico: preserve unicidade de transições.",
                                    "Verifique que M' reconhece Σ* - L usando simulações em strings aceitas e rejeitadas por M.",
                                    "Formalize o lema: se L é DCFL, então complemento(L) é DCFL."
                                  ],
                                  "verification": "Escreva a construção formal de M' e prove corretude para L = {a^n b^n | n ≥ 0}.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para diagramas de autômatos",
                                    "Ferramenta JFLAP para simulação de DPDA"
                                  ],
                                  "tips": "Lembre-se: o complemento usa o mesmo autômato, mas inverte o critério de aceitação.",
                                  "learningObjective": "Dominar a prova de fechamento sob complemento via construção de DPDA complementar.",
                                  "commonMistakes": [
                                    "Não preservar determinismo na construção",
                                    "Confundir aceitação por estado final vs. pilha vazia",
                                    "Esquecer strings fora de Σ*"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar fechamento de DCFLs sob inversão (reverse)",
                                  "subSteps": [
                                    "Dado DPDA M para L, construa M^r que reconhece L^r (reverse de L).",
                                    "Inverta as transições de M: leia de trás para frente, invertendo símbolos de entrada e pilha.",
                                    "Ajuste a pilha: empilhe símbolos de entrada iniciais e desempilhe no final.",
                                    "Prove determinismo de M^r e corretude via mapeamento de configurações.",
                                    "Teste com exemplo: se L = {a^n b^n}, L^r = {b^n a^n}, que é DCFL."
                                  ],
                                  "verification": "Construa M^r para um DPDA dado e valide com strings reversas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "JFLAP ou Draw.io para diagramas invertidos",
                                    "Exemplos de DPDAs de aulas anteriores"
                                  ],
                                  "tips": "Pense na pilha como LIFO: reverse exige 'desempilhar' a entrada de forma determinística.",
                                  "learningObjective": "Entender e provar fechamento sob reverse via inversão de autômato.",
                                  "commonMistakes": [
                                    "Não inverter corretamente símbolos da pilha",
                                    "Perder determinismo em transições ambíguas",
                                    "Ignorar estado inicial/final invertidos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar fechamento de DCFLs sob união prefixada e contrastar com CFLs",
                                  "subSteps": [
                                    "Defina união prefixada: L1 ∪_prefix L2 = {w | ∃u ∈ L1, w = u v e v ∈ L2}.",
                                    "Construa DPDA para união prefixada de duas DCFLs L1 e L2.",
                                    "Nondeterminize levemente para adivinhar prefixo de L1, mas preserve determinismo via testes prefixados.",
                                    "Prove via construção: simule M1 até aceitação prefixada, então M2.",
                                    "Contrastar com CFLs: mostre que CFLs não são fechadas (ex: {a^n b^n c^m} ∪_prefix {a^m c^n b^m})."
                                  ],
                                  "verification": "Forneça prova formal e contraexemplo para CFLs não fechadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigos ou notas sobre propriedades de DCFLs",
                                    "Python para simular uniões prefixadas"
                                  ],
                                  "tips": "Use 'testes de aceitação prefixada' em DPDAs para manter determinismo.",
                                  "learningObjective": "Provar fechamento sob união prefixada e destacar diferenças com CFLs.",
                                  "commonMistakes": [
                                    "Confundir união prefixada com união regular",
                                    "Não fornecer contraexemplo claro para CFLs",
                                    "Falhar em provar determinismo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar diferenças e praticar provas completas",
                                  "subSteps": [
                                    "Resuma as três propriedades: complemento, reverse, união prefixada.",
                                    "Resolva exercícios: prove para linguagens específicas e refute para CFLs.",
                                    "Discuta implicações: DCFLs ideais para parsing determinístico.",
                                    "Crie contraexemplos para CFLs em cada operação.",
                                    "Autoavalie com provas escritas."
                                  ],
                                  "verification": "Escreva três provas curtas cobrindo cada propriedade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de exercícios personalizada",
                                    "Respostas modelo de professor"
                                  ],
                                  "tips": "Pratique verbalizando as provas para fixar.",
                                  "learningObjective": "Integrar conhecimentos e diferenciar DCFLs de CFLs.",
                                  "commonMistakes": [
                                    "Generalizar incorretamente para CFLs",
                                    "Omitir formalidades nas provas",
                                    "Ignorar exemplos concretos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere L = {a^n b^n | n ≥ 0}, uma DCFL reconhecida por DPDA M. Prove: complemento(L) é DCFL (M' rejeita o que M aceita); L^r = {b^n a^n} é DCFL (inverta M); L ∪_prefix {c^m d^m} é DCFL via construção prefixada. Para CFLs, mostre que {a^n b^n} ∪_prefix {a^n c^n} não é CFL.",
                              "finalVerifications": [
                                "Consegue construir DPDA complementar para qualquer DCFL dada.",
                                "Prova fechamento sob reverse com diagrama invertido.",
                                "Explica união prefixada e constrói DPDA correspondente.",
                                "Fornece contraexemplo válido para CFLs em pelo menos duas operações.",
                                "Simula execuções de DPDAs em strings de teste.",
                                "Discute verbalmente as diferenças DCFL vs CFL."
                              ],
                              "assessmentCriteria": [
                                "Precisão formal nas construções de DPDAs (determinismo preservado).",
                                "Corretude das provas: lemas, induções e simulações.",
                                "Uso de exemplos concretos e contraexemplos.",
                                "Clareza na escrita e diagramas.",
                                "Compreensão de diferenças com CFLs.",
                                "Criatividade em aplicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e fechamentos (álgebra universal).",
                                "Lógica: Propriedades de closure em sistemas formais.",
                                "Programação: Parsing determinístico em compiladores (ex: LL(1) grammars).",
                                "Engenharia de Software: Análise sintática eficiente.",
                                "Filosofia da Computação: Limites da computação determinística."
                              ],
                              "realWorldApplication": "Em compiladores, DPDAs modelam parsers determinísticos LR(0)/SLR(1), permitindo análise sintática eficiente e sem ambiguidades, essencial para linguagens como C ou Java, onde o reverse e complemento ajudam em otimizações de gramáticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Máquinas de Turing",
                "description": "Modelos de máquinas de Turing, incluindo versões restritas e a tese de Church.",
                "totalSkills": 45,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Definição Formal de Máquina de Turing",
                    "description": "Modelo básico de Máquina de Turing com fita infinita, cabeçote, estados e função de transição.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Conjunto de Estados",
                        "description": "O conjunto finito Q de estados da Máquina de Turing, incluindo o estado inicial q₀ e o conjunto de estados de aceitação F.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Definir o conjunto Q de estados",
                            "description": "Explicar que Q é um conjunto finito não vazio de estados que representam a memória de controle da Máquina de Turing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o papel dos estados em autômatos",
                                  "subSteps": [
                                    "Revise o conceito de autômatos finitos (AF) e o uso de estados como memória de controle.",
                                    "Identifique como estados representam configurações internas da máquina.",
                                    "Compare com máquinas de estados finitos para preparar o terreno para MT."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o papel dos estados em um AF simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (capítulo sobre autômatos)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use diagramas de transição para visualizar estados.",
                                  "learningObjective": "Entender estados como memória discreta em autômatos.",
                                  "commonMistakes": "Confundir estados com símbolos da fita; estados são internos à máquina."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir formalmente o conjunto Q",
                                  "subSteps": [
                                    "Leia a definição formal de Máquina de Turing (MT): M = (Q, Σ, Γ, δ, q0, B, F).",
                                    "Identifique Q como conjunto finito e não vazio de estados.",
                                    "Escreva Q = {q1, q2, ..., qn} com n ≥ 1, incluindo q0 (inicial) e F ⊆ Q (aceitação)."
                                  ],
                                  "verification": "Escreva a definição completa de Q em uma fórmula matemática.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Referência formal de MT (Sipser ou similar)",
                                    "Editor de texto para fórmulas"
                                  ],
                                  "tips": "Sempre especifique que Q é finito para distinguir de modelos infinitos.",
                                  "learningObjective": "Formalizar Q como componente essencial da tupla de MT.",
                                  "commonMistakes": "Esquecer que Q deve ser não vazio ou incluir q0 explicitamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar propriedades e restrições de Q",
                                  "subSteps": [
                                    "Liste propriedades: finito (|Q| < ∞), não vazio (|Q| ≥ 1), contém q0 ∈ Q, F ⊆ Q.",
                                    "Discuta como Q armazena 'memória de controle' durante computação.",
                                    "Analise impacto de |Q| pequeno vs. grande na complexidade."
                                  ],
                                  "verification": "Crie uma tabela resumindo propriedades de Q com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel quadriculado",
                                    "Exemplos de MT simples"
                                  ],
                                  "tips": "Pense em Q como 'program counter' em computadores reais.",
                                  "learningObjective": "Dominar restrições matemáticas e funcionais de Q.",
                                  "commonMistakes": "Achar que Q pode ser infinito; MT padrão exige finitude."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Q em um exemplo simples de MT",
                                  "subSteps": [
                                    "Construa uma MT que reconhece {a^n b^n} com Q = {q0, q1, q2, qaceito, qrejeita}.",
                                    "Desenhe o diagrama de estados e transições usando Q.",
                                    "Simule uma entrada curta para verificar uso de estados."
                                  ],
                                  "verification": "Simule a MT em uma string de teste e liste estados visitados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de simulação de MT online ou papel",
                                    "Exemplos de linguagens regulares"
                                  ],
                                  "tips": "Comece com |Q| mínimo para clareza.",
                                  "learningObjective": "Usar Q na construção prática de uma MT.",
                                  "commonMistakes": "Incluir estados inacessíveis ou não declarar q0 e F."
                                }
                              ],
                              "practicalExample": "Em uma MT que soma dois números binários na fita, Q = {q0 (inicial), q1 (carry=0), q2 (carry=1), qaceito}, onde estados rastreiam o carry durante a soma.",
                              "finalVerifications": [
                                "Pode definir Q corretamente na tupla de MT?",
                                "Identifica q0 e F em Q?",
                                "Explica por que Q deve ser finito e não vazio?",
                                "Constrói um exemplo válido de Q para uma MT simples?",
                                "Lista propriedades chave de Q?",
                                "Diferencia Q de Σ ou Γ?"
                              ],
                              "assessmentCriteria": [
                                "Definição precisa e formal de Q (peso 30%)",
                                "Correta inclusão de q0 e F (peso 20%)",
                                "Exemplo prático com diagrama (peso 20%)",
                                "Explicação de propriedades e restrições (peso 15%)",
                                "Simulação correta em entrada teste (peso 15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (finito, subconjuntos).",
                                "Lógica: Máquinas de Estados em Circuitos Lógicos.",
                                "Programação: Estados em Finite State Machines (FSM) em código.",
                                "Física: Modelos de Memória em Sistemas Dinâmicos Discretos."
                              ],
                              "realWorldApplication": "Em compiladores, estados de Q modelam parsers; em jogos, controlam NPCs via FSM; em protocolos de rede, gerenciam handshakes de conexão."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Identificar o estado inicial q₀",
                            "description": "Descrever q₀ como o estado único em que a Máquina de Turing inicia sua computação ao processar uma entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Estados em Máquinas de Turing",
                                  "subSteps": [
                                    "Revise a definição formal de uma Máquina de Turing (MT): Q (conjunto finito de estados), Σ (alfabeto), Γ (fita), δ (função de transição), q₀ (estado inicial), q_accept, q_reject.",
                                    "Identifique que Q é o conjunto de todos os estados possíveis da MT.",
                                    "Explique verbalmente o que um 'estado' representa: a configuração interna da MT em um momento dado.",
                                    "Diferencie estados de outros componentes como a cabeça de leitura/escrita.",
                                    "Anote exemplos de estados em MTs simples, como q0, q1, q_accept."
                                  ],
                                  "verification": "Liste os componentes da definição formal de MT e destaque Q e q₀ corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Teoria da Computação ou slides sobre MTs; quadro branco.",
                                  "tips": "Use diagramas de transição para visualizar estados como 'nós' no grafo.",
                                  "learningObjective": "Entender estados como configurações internas da MT.",
                                  "commonMistakes": "Confundir estados com símbolos da fita ou posições da cabeça."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Papel Específico do Estado Inicial q₀",
                                  "subSteps": [
                                    "Leia definições que descrevem q₀ como o estado único de partida ao processar uma entrada.",
                                    "Simule mentalmente o início de uma computação: MT começa em q₀ com cabeça na primeira célula da fita.",
                                    "Compare q₀ com estados finais (aceitação/rejeição): q₀ é o 'ponto de partida único'.",
                                    "Escreva uma frase definindo q₀: 'q₀ ∈ Q é o estado inicial único'.",
                                    "Discuta por que deve ser único: garante determinismo na inicialização."
                                  ],
                                  "verification": "Explique em 2-3 frases o papel de q₀ e por que ele é único.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplos de MTs de um tutorial online (ex: Sipser's book excerpts).",
                                  "tips": "Pense em q₀ como o 'botão de power on' da MT.",
                                  "learningObjective": "Graspar o significado e unicidade de q₀ na computação.",
                                  "commonMistakes": "Achar que q₀ pode ser múltiplo ou confundi-lo com estado atual durante execução."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar q₀ em Definições e Diagramas Formais",
                                  "subSteps": [
                                    "Analise 3 definições formais de MTs e circule q₀ explicitamente.",
                                    "Em um diagrama de transição, marque q₀ com uma seta de entrada ou estrela.",
                                    "Verifique se q₀ pertence a Q e não é q_accept ou q_reject.",
                                    "Crie sua própria definição simples de MT e especifique q₀.",
                                    "Compare com MTs não-determinísticas (onde inicial pode ser conjunto, mas foque em determinísticas)."
                                  ],
                                  "verification": "Apresente uma definição de MT com q₀ corretamente identificado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagramas de MTs impressos ou software como JFLAP.",
                                  "tips": "Sempre procure 'q0' ou 'q_initial' nas notações padrão.",
                                  "learningObjective": "Localizar e destacar q₀ em representações formais.",
                                  "commonMistakes": "Ignorar q₀ em definições ou confundi-lo com q1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Exemplos Reais de MTs",
                                  "subSteps": [
                                    "Pegue uma MT para reconhecer {0^n 1^n} e identifique q₀.",
                                    "Simule os primeiros passos a partir de q₀ em uma fita exemplo.",
                                    "Teste em 2-3 MTs diferentes (ex: palíndromos, linguagens regulares simuladas).",
                                    "Crie um quiz autoavaliativo: 'Qual é q₀ aqui?'.",
                                    "Explique por que errar q₀ invalida a simulação."
                                  ],
                                  "verification": "Simule corretamente o início de 3 MTs a partir de q₀.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulador de MT online ou papel/fita simulada.",
                                  "tips": "Inicie sempre da entrada em branco à esquerda, cabeça em posição 0, estado q₀.",
                                  "learningObjective": "Aplicar identificação de q₀ em cenários práticos.",
                                  "commonMistakes": "Começar simulação de estado errado ou ignorar fita inicial."
                                }
                              ],
                              "practicalExample": "Em uma MT que reconhece strings com número par de 0s: Q = {q₀, q1, q_accept, q_reject}, onde q₀ é o estado inicial. Para entrada '00', inicia em q₀ lendo primeiro '0', move para q1.",
                              "finalVerifications": [
                                "Identifica corretamente q₀ em 5 definições formais de MTs.",
                                "Explica o papel de q₀ sem erros em uma simulação passo-a-passo.",
                                "Diferencia q₀ de outros estados em diagramas.",
                                "Verifica unicidade de q₀ em exemplos variados.",
                                "Simula início de computação a partir de q₀ sem falhas.",
                                "Responde quiz sobre q₀ com 100% acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de q₀ (obrigatório).",
                                "Compreensão clara do papel inicial único.",
                                "Uso correto em simulações e diagramas.",
                                "Explicações verbais concisas e precisas.",
                                "Aplicação consistente em múltiplos exemplos.",
                                "Identificação de erros comuns em si mesmo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Conjuntos e elementos únicos em Q.",
                                "Lógica: Estados como proposições em autômatos.",
                                "Programação: Estados iniciais em finite state machines (FSMs) de parsers.",
                                "Física: Estados iniciais em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em compiladores, parsers usam FSMs com estado inicial para tokenização; em protocolos de rede, máquinas de estado iniciam em q₀ para handshakes como TCP SYN."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Explicar os estados de aceitação F",
                            "description": "Definir F ⊆ Q como o conjunto de estados em que a máquina para e aceita a entrada processada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal do conjunto de estados Q em Máquinas de Turing",
                                  "subSteps": [
                                    "Relembre a estrutura de uma Máquina de Turing (MT): Q (estados), Σ (alfabeto), Γ (fita), δ (função de transição), q0 (estado inicial), B (símbolo em branco), F (estados de aceitação).",
                                    "Identifique Q como o conjunto finito de todos os estados possíveis da MT, incluindo estado inicial q0.",
                                    "Liste exemplos de estados em Q: q0 (inicial), estados de computação intermediários (q1, q2), e halting states.",
                                    "Desenhe um diagrama simples de estados para visualizar Q.",
                                    "Explique que Q é finito e não inclui necessariamente estados de aceitação ou rejeição ainda."
                                  ],
                                  "verification": "Construa um diagrama de Q com pelo menos 4 estados e rotule q0 corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou software de diagramas como Draw.io; notas de aula sobre MT.",
                                  "tips": "Use setas para mostrar transições possíveis entre estados em Q.",
                                  "learningObjective": "Compreender Q como base para todos os estados, incluindo F.",
                                  "commonMistakes": "Confundir Q com F; assumir que todos os estados em Q são de aceitação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir formalmente o conjunto de estados de aceitação F",
                                  "subSteps": [
                                    "Defina F ⊆ Q como o subconjunto de estados de halting onde a MT aceita a entrada.",
                                    "Escreva a notação matemática: F é finito, F ≠ ∅ tipicamente, e q ∈ F implica halting sem rejeição.",
                                    "Diferencie F de outros halting states: se para em F, aceita (linguagem aceita); caso contrário, rejeita ou loop.",
                                    "Especifique que ao entrar em q ∈ F, a MT para e a entrada w é aceita (w ∈ L(M)).",
                                    "Crie uma tabela comparando Q, F e estados de rejeição (se aplicável)."
                                  ],
                                  "verification": "Escreva a definição formal de F e prove com notação que F ⊆ Q.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de papel para tabelas; referência de livro como 'Sipser - Introdução à Teoria da Computação'.",
                                  "tips": "Sempre use ⊆ para mostrar subconjunto, não =.",
                                  "learningObjective": "Dominar a definição precisa de F como subconjunto halting de aceitação.",
                                  "commonMistakes": "Achar que F inclui estados não-halting; ignorar que F pode ser vazio (MT nunca aceita)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o mecanismo de aceitação via F",
                                  "subSteps": [
                                    "Descreva o processo: MT inicia em q0 com entrada w; segue δ até halting em q_halt.",
                                    "Se q_halt ∈ F, aceita w (L(M) inclui w); senão, rejeita ou indefinido.",
                                    "Trace uma computação exemplo: entrada '11', transições levam a q_accept ∈ F.",
                                    "Discuta impacto: F determina a linguagem reconhecida L(M) = {w | MT para em F após processar w}.",
                                    "Compare com AFDs/NFAs onde F é similar, mas MT tem fita infinita."
                                  ],
                                  "verification": "Simule uma computação manual de MT simples terminando em F.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulador online de MT (ex: Turing Machine Simulator); fita simulada em papel.",
                                  "tips": "Anote configuração (estado, fita, cabeça) a cada passo para rastrear.",
                                  "learningObjective": "Entender como F decide aceitação em computações de MT.",
                                  "commonMistakes": "Confundir aceitação com halting; esquecer loops infinitos (não halting)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar F de outros conceitos e verificar compreensão",
                                  "subSteps": [
                                    "Compare F com estados de rejeição R ⊆ Q (halting mas rejeita).",
                                    "Discuta casos: MT pode ter F e R, só F, ou nem (parcial).",
                                    "Analise propriedades: se F = ∅, L(M) = ∅; decidibilidade depende de halting sempre.",
                                    "Crie contraexemplos: MT que loopa nunca usa F.",
                                    "Resuma: F define aceitação decisiva quando halting ocorre."
                                  ],
                                  "verification": "Crie dois diagramas MT: um aceita via F, outro rejeita apesar de halting.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de desenho; exemplos de MT de tutoriais online.",
                                  "tips": "Teste diagramas com entradas específicas para validar F.",
                                  "learningObjective": "Distinguir F em contextos de aceitação vs. rejeição e não-halting.",
                                  "commonMistakes": "Assumir toda MT para sempre; confundir F com q0."
                                }
                              ],
                              "practicalExample": "Considere MT M que reconhece {0^n 1^n | n ≥ 0}: Q = {q0, q1, q_loop, q_accept, q_reject}, F = {q_accept}. Para w=0011, inicia q0, move cabeça apagando 0s e 1s; ao zerar, entra q_accept ∈ F, aceitando w ∈ L(M). Para 001, entra q_reject ∉ F, rejeita.",
                              "finalVerifications": [
                                "Defina corretamente F ⊆ Q com notação matemática.",
                                "Trace uma computação terminando em F e explique aceitação.",
                                "Diferencie F de estados de rejeição ou looping.",
                                "Construa diagrama MT simples com F marcado.",
                                "Explique L(M) em termos de F.",
                                "Identifique erros comuns em definições de F."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de F (subconjunto halting de Q).",
                                "Correta descrição do processo de aceitação via F.",
                                "Uso apropriado de exemplos e contraexemplos.",
                                "Clareza em diagramas e simulações de computação.",
                                "Distinção clara entre F, R e non-halting.",
                                "Compreensão de implicações para L(M)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (subconjuntos, inclusão).",
                                "Lógica: Estados como proposições verdadeiras/falsas em verificadores.",
                                "Engenharia de Software: Estados de aceitação em autômatos finitos para parsers.",
                                "Filosofia da Computação: Decidibilidade e halting problem."
                              ],
                              "realWorldApplication": "Em compiladores, estados de aceitação F em autômatos modelam parsing de linguagens de programação; em verificadores de hardware, F confirma configurações válidas de circuitos, evitando erros em chips como CPUs."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Alfabetos e Símbolo em Branco",
                        "description": "Os alfabetos de entrada Σ, da fita Γ e o símbolo em branco B utilizados na definição formal da Máquina de Turing.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Definir o alfabeto de entrada Σ",
                            "description": "Explicar Σ como o conjunto finito de símbolos válidos na string de entrada, sem incluir o símbolo em branco.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de alfabeto em linguagens formais",
                                  "subSteps": [
                                    "Revise a definição de alfabeto como um conjunto finito de símbolos distintos.",
                                    "Identifique exemplos cotidianos de alfabetos, como {a, b, c, ..., z} para texto ou {0,1} para binário.",
                                    "Explique o papel do alfabeto na representação de strings em teoria da computação.",
                                    "Diferencie alfabeto de string: alfabeto gera strings.",
                                    "Anote símbolos comuns usados em contextos computacionais."
                                  ],
                                  "verification": "Escreva uma definição em suas próprias palavras e liste 3 exemplos de alfabetos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Notas de aula sobre linguagens formais, quadro branco ou papel para anotações.",
                                  "tips": "Use analogias como 'ingredientes' para formar 'receitas' (strings).",
                                  "learningObjective": "Entender alfabeto como base para strings em modelos computacionais.",
                                  "commonMistakes": "Confundir alfabeto com o conjunto infinito de strings possíveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar o alfabeto de entrada Σ do alfabeto da fita Γ",
                                  "subSteps": [
                                    "Defina Σ como o conjunto finito de símbolos válidos especificamente na string de entrada inicial.",
                                    "Explique que Γ = Σ ∪ {⊥} (ou B), onde ⊥ é o símbolo em branco não incluído em Σ.",
                                    "Ilustre com diagrama: entrada usa apenas Σ, fita usa Γ.",
                                    "Discuta por que Σ exclui o blank: blank preenche o resto da fita.",
                                    "Compare com exemplos: Σ={0,1} para multiplicação binária, Γ={0,1,⊥}."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando entrada em Σ e fita em Γ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplos de definições formais de MT, software de desenho como Draw.io.",
                                  "tips": "Lembre-se: Σ é 'o que vem na entrada', Γ é 'tudo na fita'.",
                                  "learningObjective": "Distinguir Σ como subconjunto de Γ, excluindo blank.",
                                  "commonMistakes": "Incluir o blank em Σ por engano."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender a notação formal para definir Σ",
                                  "subSteps": [
                                    "Estude a notação: Σ = {s1, s2, ..., sn} onde si são símbolos distintos.",
                                    "Pratique escrevendo Σ para problemas simples, como reconhecimento de palíndromos.",
                                    "Verifique finitude: Σ deve ter tamanho finito e pequeno (tipicamente 2-10 símbolos).",
                                    "Inclua convenções: use aspas ou notação matemática para símbolos.",
                                    "Teste com validação: Σ não pode ter duplicatas ou símbolos irrelevantes."
                                  ],
                                  "verification": "Escreva Σ corretamente para 2 problemas de MT dados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de exercícios com problemas de MT, calculadora simbólica opcional.",
                                  "tips": "Sempre liste símbolos em ordem alfabética para clareza.",
                                  "learningObjective": "Dominar a sintaxe e regras para especificar Σ formalmente.",
                                  "commonMistakes": "Usar símbolos infinitos ou não enumerar explicitamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar definição de Σ em contextos de Máquinas de Turing",
                                  "subSteps": [
                                    "Escolha um problema MT, como soma binária, e defina seu Σ.",
                                    "Valide: todos símbolos da entrada estão em Σ? Blank excluído?",
                                    "Crie variações: Σ unário {1}, Σ decimal {0,1,2,...,9}.",
                                    "Compare definições com soluções padrão de livros.",
                                    "Autoavalie com pares ou auto-teste."
                                  ],
                                  "verification": "Defina Σ para 3 problemas MT diferentes e justifique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Livro de teoria da computação (Sipser), exemplos online de MT.",
                                  "tips": "Comece com problemas binários para simplicidade.",
                                  "learningObjective": "Aplicar definição de Σ em cenários reais de MT.",
                                  "commonMistakes": "Definir Σ muito amplo, incluindo símbolos desnecessários."
                                }
                              ],
                              "practicalExample": "Para uma MT que reconhece strings binárias com número par de 1s: Σ = {0, 1}. A entrada é w ∈ {0,1}*, como '1010', sem ⊥ na entrada inicial.",
                              "finalVerifications": [
                                "Pode listar corretamente os símbolos em Σ para um problema dado?",
                                "Explica verbalmente por que ⊥ não está em Σ?",
                                "Identifica erros em definições de Σ fornecidas?",
                                "Desenha fita inicial usando apenas Σ?",
                                "Aplica Σ em uma definição completa de MT?",
                                "Diferencia Σ de Γ em exemplos?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na exclusão do símbolo em branco de Σ (100% correto).",
                                "Finitude e distinção dos símbolos em Σ (sem duplicatas).",
                                "Uso correto de notação formal {s1, s2, ...}.",
                                "Justificativa contextual para escolha de símbolos.",
                                "Aplicação consistente em exemplos práticos.",
                                "Clareza na explicação escrita ou verbal."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (Σ como conjunto finito).",
                                "Lógica: Símbolos como proposições básicas em linguagens formais.",
                                "Linguística: Alfabetos como base para gramáticas e parsers.",
                                "Engenharia de Software: Definição de tokens em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores e parsers, Σ define tokens válidos de código-fonte (ex: {if, while, +, =}), excluindo espaços/brancos, permitindo análise lexical eficiente em linguagens de programação."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Definir o alfabeto da fita Γ",
                            "description": "Descrever Γ como o conjunto finito de símbolos que podem aparecer na fita, onde Σ ⊆ Γ e Γ contém B.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de alfabeto em teoria da computação",
                                  "subSteps": [
                                    "Revise a definição de alfabeto como um conjunto finito de símbolos distintos.",
                                    "Identifique exemplos comuns de alfabetos, como Σ = {0,1} para linguagens binárias.",
                                    "Diferencie alfabeto de entrada (Σ) de outros conjuntos de símbolos usados em autômatos.",
                                    "Anote que em Máquinas de Turing (MT), a fita requer símbolos adicionais além de Σ.",
                                    "Discuta por que um conjunto finito é essencial para computabilidade."
                                  ],
                                  "verification": "Escreva uma definição curta de alfabeto e dê um exemplo; compare com Σ.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notas de aula sobre autômatos"
                                  ],
                                  "tips": "Use analogia com teclado de computador: teclas limitadas formam o alfabeto.",
                                  "learningObjective": "Entender alfabeto como base para símbolos manipuláveis em MT.",
                                  "commonMistakes": "Confundir alfabeto com linguagem (sequências vs. símbolos individuais)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a relação entre Σ, Γ e o símbolo em branco B",
                                  "subSteps": [
                                    "Defina Σ como o alfabeto de entrada, contendo símbolos da string de entrada.",
                                    "Explique que Γ é o alfabeto da fita, onde Σ ⊆ Γ (todos símbolos de entrada estão em Γ).",
                                    "Introduza B como o símbolo em branco (blank), obrigatório em Γ, representando células vazias.",
                                    "Desenhe um diagrama de Venn mostrando Σ dentro de Γ, com B em Γ mas não necessariamente em Σ.",
                                    "Liste símbolos extras que podem estar em Γ, como marcadores auxiliares."
                                  ],
                                  "verification": "Crie um diagrama de Venn e rotule Σ, Γ e B corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para diagrama",
                                    "Livro ou PDF sobre Máquinas de Turing"
                                  ],
                                  "tips": "Lembre-se: B é como 'espaço vazio' na fita infinita.",
                                  "learningObjective": "Dominar a inclusão Σ ⊆ Γ e a presença obrigatória de B.",
                                  "commonMistakes": "Esquecer que B deve estar em Γ mesmo se não usado na entrada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a definição de Γ para uma Máquina de Turing",
                                  "subSteps": [
                                    "Escreva a definição formal: Γ é um conjunto finito de símbolos tal que Σ ⊆ Γ e B ∈ Γ.",
                                    "Especifique que Γ deve ser finito para garantir decidibilidade em simulações.",
                                    "Inclua símbolos auxiliares opcionais em Γ, como # para separadores.",
                                    "Verifique se a definição atende aos requisitos: finito, contém Σ e B.",
                                    "Compare com definições de outros componentes da MT (Q, δ, etc.)."
                                  ],
                                  "verification": "Redija a definição formal em notação matemática e valide com um exemplo.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Editor de texto ou LaTeX para fórmulas",
                                    "Referência formal de MT"
                                  ],
                                  "tips": "Use notação ∪ para mostrar Γ = Σ ∪ {B} ∪ símbolos extras.",
                                  "learningObjective": "Capacitar-se a escrever definições precisas de Γ.",
                                  "commonMistakes": "Definir Γ como infinito ou omitir a inclusão de Σ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a definição em um exemplo prático de MT",
                                  "subSteps": [
                                    "Escolha uma MT simples, ex: reconhecedora de strings pares de 0s.",
                                    "Defina Σ = {0}, então Γ = {0, B}.",
                                    "Expanda para um caso complexo: Σ = {0,1}, Γ = {0,1,B,#}.",
                                    "Simule a fita inicial e movimentos, destacando uso de símbolos de Γ.",
                                    "Ajuste Γ se necessário para suportar computação."
                                  ],
                                  "verification": "Descreva Γ para o exemplo e justifique cada símbolo.",
                                  "estimatedTime": "18 minutos",
                                  "materials": [
                                    "Simulador online de MT (opcional)",
                                    "Papel para simulação manual"
                                  ],
                                  "tips": "Comece simples para evitar sobrecarga cognitiva.",
                                  "learningObjective": "Praticar definição contextual de Γ em MT reais.",
                                  "commonMistakes": "Incluir símbolos de Σ não usados ou excluir B."
                                }
                              ],
                              "practicalExample": "Para uma MT que decide se uma string binária é par (Σ = {0,1}), defina Γ = {0,1,B,X}, onde X é um marcador auxiliar para contar pares, e B preenche o resto da fita infinita.",
                              "finalVerifications": [
                                "Pode listar corretamente os elementos de Γ para um Σ dado?",
                                "Confirma Σ ⊆ Γ e B ∈ Γ na definição?",
                                "Identifica símbolos auxiliares válidos em Γ?",
                                "Explica o papel de B na fita infinita?",
                                "Valida se Γ é finito?",
                                "Aplica Γ em uma simulação simples de MT?"
                              ],
                              "assessmentCriteria": [
                                "Definição inclui explicitamente Σ ⊆ Γ e B ∈ Γ (obrigatório).",
                                "Γ é descrito como conjunto finito.",
                                "Exemplo prático demonstra uso correto de símbolos de Γ.",
                                "Explicação diferencia Σ de Γ claramente.",
                                "Ausência de erros como omitir B ou tornar Γ infinito.",
                                "Integração coerente com outros componentes da MT."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (subconjuntos, finitude).",
                                "Lógica: Símbolos como predicados em linguagens formais.",
                                "Programação: Conjuntos de caracteres em linguagens como Python (string.ascii_letters).",
                                "Física: Estados discretos em sistemas quânticos simulados por MT.",
                                "Linguística: Alfabetos fonéticos finitos."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, Γ define o conjunto de tokens e marcadores na 'fita' de análise sintática; simuladores de MT em educação usam Γ para depuração de algoritmos universais, como em software como JFLAP."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Descrever o símbolo em branco B",
                            "description": "Explicar B ∈ Γ \\ Σ como o símbolo padrão que preenche as células infinitas da fita não utilizadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os alfabetos de entrada e fita",
                                  "subSteps": [
                                    "Defina o alfabeto de entrada Σ como o conjunto de símbolos válidos na linguagem de entrada.",
                                    "Defina o alfabeto da fita Γ como o conjunto de todos os símbolos que podem aparecer na fita, incluindo Σ.",
                                    "Identifique que Γ é sempre um superconjunto de Σ (Γ ⊇ Σ).",
                                    "Liste exemplos: Σ = {0,1}, Γ = {0,1,B}.",
                                    "Explique a notação Γ \\ Σ como os símbolos extras na fita além da entrada."
                                  ],
                                  "verification": "Escreva definições corretas de Σ e Γ com exemplos e explique Γ \\ Σ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de teoria da computação",
                                    "Folha de papel para anotações",
                                    "Diagrama de conjuntos"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar Σ dentro de Γ.",
                                  "learningObjective": "Compreender a relação hierárquica entre Σ e Γ.",
                                  "commonMistakes": [
                                    "Confundir Σ com Γ",
                                    "Esquecer que Γ inclui Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o símbolo em branco B",
                                  "subSteps": [
                                    "Defina B como o símbolo em branco, pertencente a Γ \\ Σ.",
                                    "Explique que B é o símbolo padrão usado para preencher células vazias.",
                                    "Escreva formalmente: B ∈ Γ \\ Σ.",
                                    "Discuta que B é único e convencional, mas pode ser representado como 'blank' ou '_'.",
                                    "Compare B com 'espaço' em linguagens de programação."
                                  ],
                                  "verification": "Forneça a definição formal de B e prove que B ∉ Σ.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas de aula sobre MT",
                                    "Editor de texto para fórmulas"
                                  ],
                                  "tips": "Sempre use notação matemática precisa para evitar ambiguidades.",
                                  "learningObjective": "Identificar B como o símbolo distintivo em Γ \\ Σ.",
                                  "commonMistakes": [
                                    "Incluir B em Σ",
                                    "Pensar que B é opcional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o papel de B na fita infinita",
                                  "subSteps": [
                                    "Descreva a fita de Turing como bi-infinitamente estendida, preenchida inicialmente com B fora da entrada.",
                                    "Ilustre: ... B B [entrada em Σ] B B ...",
                                    "Explique que durante a computação, a cabeça move e pode escrever B em células.",
                                    "Discuta como B representa 'não utilizado' ou 'vazio'.",
                                    "Simule um movimento: cabeça em B move direita, escreve símbolo de Σ."
                                  ],
                                  "verification": "Desenhe uma fita de Turing mostrando B preenchendo células infinitas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhar fita",
                                    "Simulador online de MT"
                                  ],
                                  "tips": "Visualize a fita como uma linha infinita com B em ambos os lados.",
                                  "learningObjective": "Entender como B modela o espaço infinito não utilizado.",
                                  "commonMistakes": [
                                    "Limitar a fita a tamanho finito",
                                    "Ignorar B nas extremidades"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e praticar a descrição completa",
                                  "subSteps": [
                                    "Escreva uma descrição completa: 'B ∈ Γ \\ Σ é o símbolo padrão preenchendo células infinitas da fita não utilizadas.'",
                                    "Crie um exemplo com Σ = {a}, Γ = {a,B}, fita inicial: ...BBB a BBB...",
                                    "Explique impacto na transição: δ(q, B, dir) permite expansão.",
                                    "Compare com halting: máquina para em B ou símbolo específico.",
                                    "Resuma em 1 parágrafo coeso."
                                  ],
                                  "verification": "Redija uma explicação de 100 palavras descrevendo B corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Simulador de Turing",
                                    "Modelo de fita impresso"
                                  ],
                                  "tips": "Pratique verbalizando a explicação para fixar.",
                                  "learningObjective": "Descrever integralmente o papel de B em MT.",
                                  "commonMistakes": [
                                    "Omitir notação formal",
                                    "Confundir com símbolos de entrada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma MT que reconhece {a^n b^n}, Σ = {a,b}, Γ = {a,b,B,#}. A fita inicial é ... B B B a a b b B B B ..., onde B preenche as células infinitas à esquerda e direita da entrada 'aabb', permitindo que a cabeça se mova livremente sem limites.",
                              "finalVerifications": [
                                "Explica corretamente B ∈ Γ \\ Σ.",
                                "Descreve B como preenchendo células infinitas não utilizadas.",
                                "Desenha fita com B nas extremidades.",
                                "Distingue B de símbolos em Σ.",
                                "Fornece exemplo concreto de uso em fita."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (Γ \\ Σ).",
                                "Clareza na descrição do papel de B na fita infinita.",
                                "Uso de exemplos visuais ou diagramas.",
                                "Ausência de confusão entre Σ e Γ.",
                                "Capacidade de sintetizar em parágrafo coeso.",
                                "Compreensão de implicações na computação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos (diferença Γ \\ Σ).",
                                "Lógica: Símbolos como marcadores em provas formais.",
                                "Programação: Conceitos de null/undefined em buffers infinitos.",
                                "Física: Modelagem de espaço vazio em simulações infinitas."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores modernos (ex: JavaScript engines), o símbolo B modela memória não inicializada ou heap infinito, permitindo expansão dinâmica sem erros de limite, similar a arrays dinâmicos em linguagens como Python."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Fita e Cabeçote",
                        "description": "A fita infinita bidirecional e o cabeçote de leitura/escrita que se move sobre ela.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Descrever a fita infinita",
                            "description": "Explicar a fita como uma sequência infinita de células em ambas as direções, inicialmente preenchida com B exceto pela entrada em Σ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de fita em Máquinas de Turing",
                                  "subSteps": [
                                    "Leia a definição formal de Máquina de Turing, focando na fita como componente de armazenamento.",
                                    "Identifique a fita como uma estrutura linear de células que o cabeçote pode ler/escrever.",
                                    "Compare com fitas de fita magnética real para analogia intuitiva.",
                                    "Anote os símbolos básicos: alfabeto Σ e blank B.",
                                    "Desenhe um diagrama simples de 5 células finitas para visualizar."
                                  ],
                                  "verification": "Você consegue explicar verbalmente o que é uma fita em MT e listar seus componentes principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de MT de referência online"
                                  ],
                                  "tips": "Use analogias cotidianas como uma régua infinita para fixar a ideia.",
                                  "learningObjective": "Entender a fita como estrutura de memória linear em MT.",
                                  "commonMistakes": [
                                    "Confundir fita com pilha ou fila",
                                    "Ignorar o papel do blank B"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever a infinitude da fita em ambas as direções",
                                  "subSteps": [
                                    "Explique que a fita se estende infinitamente para esquerda (←∞) e direita (→∞).",
                                    "Discuta por que finita não serve: limita computações universais.",
                                    "Represente simbolicamente: ... célula_{-2} célula_{-1} célula_0 célula_1 célula_2 ...",
                                    "Simule movimento do cabeçote para além dos limites iniciais.",
                                    "Compare com números inteiros ℤ vs. naturais ℕ."
                                  ],
                                  "verification": "Desenhe e label uma fita infinita com setas indicando direções ilimitadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel sulfite grande",
                                    "Marcadores coloridos"
                                  ],
                                  "tips": "Use elipses (...) para representar a infinitude sem desenhar tudo.",
                                  "learningObjective": "Dominar a propriedade de bidirecionalidade infinita da fita.",
                                  "commonMistakes": [
                                    "Pensar só em uma direção (direita)",
                                    "Limitar a fita a tamanho fixo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o estado inicial da fita",
                                  "subSteps": [
                                    "Defina que inicialmente todas células são B (blank), exceto as da entrada w ∈ Σ*.",
                                    "Posicione o cabeçote na primeira célula da entrada (célula 0).",
                                    "Escreva formalmente: fita(i) = B para i < 0 ou i > |w|, fita(i) = w_i para 0 ≤ i < |w|.",
                                    "Exemplo: para w = 'ab', fita = ...B B [a] [b] B B... com cabeçote em 'a'.",
                                    "Verifique com pseudocódigo de inicialização."
                                  ],
                                  "verification": "Escreva a configuração inicial para uma entrada dada, como 'aba'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha quadriculada",
                                    "Referência de definição formal de MT"
                                  ],
                                  "tips": "Sempre inclua o blank B explicitamente nos diagramas.",
                                  "learningObjective": "Descrever precisamente a inicialização da fita com entrada.",
                                  "commonMistakes": [
                                    "Preencher toda fita com entrada",
                                    "Esquecer blanks infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e representar a fita infinita completa",
                                  "subSteps": [
                                    "Crie um diagrama completo: infinitude, entrada, blanks, posição cabeçote.",
                                    "Simule um passo de computação: mover cabeçote, escrever símbolo.",
                                    "Discuta implicações: permite simular qualquer algoritmo.",
                                    "Compare com memória de computadores reais (expansível).",
                                    "Escreva um parágrafo descritivo unificando tudo."
                                  ],
                                  "verification": "Produza um diagrama e descrição escrita que cubra todos os aspectos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de desenho como Draw.io",
                                    "Papel para rascunho"
                                  ],
                                  "tips": "Use convenções padrão: ↑ para cabeçote, B para blank.",
                                  "learningObjective": "Integrar todos elementos em uma descrição coesa da fita.",
                                  "commonMistakes": [
                                    "Ignorar posição inicial do cabeçote",
                                    "Representar fita como circular"
                                  ]
                                }
                              ],
                              "practicalExample": "Para entrada w = 'aba' sobre Σ = {a, b}, a fita inicial é: … B B B [a] [b] [a] B B B … com cabeçote ↑ sobre o primeiro 'a'. Ao mover direita, lê 'b', etc., expandindo blanks conforme necessário.",
                              "finalVerifications": [
                                "Descreve corretamente a bidirecionalidade infinita.",
                                "Especifica preenchimento inicial com B exceto entrada.",
                                "Indica posição inicial do cabeçote.",
                                "Representa visualmente com diagramas precisos.",
                                "Explica implicações para computabilidade.",
                                "Distingue de modelos finitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição formal (infinitude, símbolos).",
                                "Clareza na representação visual/diagramática.",
                                "Correção no estado inicial (B e entrada).",
                                "Uso de notação padrão (elipses, setas).",
                                "Compreensão de implicações teóricas.",
                                "Capacidade de exemplificar com entrada arbitrária."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conjuntos infinitos e números inteiros ℤ.",
                                "Física: Modelos de espaço-tempo infinito em relatividade.",
                                "Engenharia: Memória virtual em sistemas operacionais.",
                                "Lógica: Representação de sequências em provas formais."
                              ],
                              "realWorldApplication": "Modela armazenamento ilimitado em computação, como memória virtual em SOs (páginas 'lazy-loaded' simulam blanks infinitos) ou big data processing onde dados se expandem dinamicamente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Explicar o funcionamento do cabeçote",
                            "description": "Definir o cabeçote como o mecanismo que lê o símbolo atual na fita, escreve um novo símbolo de Γ e move-se para Esquerda (L), Direita (R) ou Fica (N).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o cabeçote e sua posição inicial na fita",
                                  "subSteps": [
                                    "Identifique o cabeçote como o componente da Máquina de Turing (MT) que interage diretamente com a fita.",
                                    "Descreva a fita como uma sequência infinita de células, cada uma contendo um símbolo do alfabeto Γ.",
                                    "Explique que o cabeçote começa posicionado na célula inicial da fita, geralmente marcada como a posição 0.",
                                    "Esboce um diagrama simples da fita com o cabeçote apontando para a primeira célula.",
                                    "Note que o cabeçote sempre aponta para exatamente uma célula por vez."
                                  ],
                                  "verification": "Desenhe um diagrama da fita com o cabeçote na posição inicial e rotule as partes corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de fita de MT impresso ou digital"
                                  ],
                                  "tips": "Use setas para indicar a posição exata do cabeçote para visualização clara.",
                                  "learningObjective": "Compreender o papel fundamental do cabeçote como interface entre a MT e a fita.",
                                  "commonMistakes": "Confundir o cabeçote com a fita inteira ou assumir que ele pode apontar para múltiplas células."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar a função de leitura do símbolo atual",
                                  "subSteps": [
                                    "Descreva que, em cada passo de computação, o cabeçote lê o símbolo presente na célula em que está posicionado.",
                                    "Defina o alfabeto de símbolos Γ, incluindo o símbolo em branco (blank) como padrão para células vazias.",
                                    "Ilustre com um exemplo: se a célula tem '1', o cabeçote lê '1' e o passa para a função de transição δ.",
                                    "Explique que a leitura é o primeiro evento no ciclo de operação da MT.",
                                    "Simule a leitura em um exemplo simples de fita com símbolos '0', '1' e blank."
                                  ],
                                  "verification": "Simule a leitura em uma fita de exemplo e identifique corretamente o símbolo lido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Fita simulada em papel com símbolos",
                                    "Tabela de transição básica de MT"
                                  ],
                                  "tips": "Sempre verbalize o símbolo lido em voz alta para reforçar o conceito.",
                                  "learningObjective": "Dominar como o cabeçote captura o input atual da fita para processamento.",
                                  "commonMistakes": "Ignorar o símbolo em branco ou assumir leitura de múltiplos símbolos de uma vez."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a função de escrita de novo símbolo",
                                  "subSteps": [
                                    "Explique que após ler, a função de transição δ determina um novo símbolo de Γ para ser escrito na mesma célula.",
                                    "Detalhe que o cabeçote substitui o símbolo atual pelo novo, alterando o estado da fita.",
                                    "Exemplo: Lê '1', δ decide escrever '0' na mesma célula.",
                                    "Enfatize que a escrita ocorre na célula atual, sem mover o cabeçote ainda.",
                                    "Pratique escrevendo em uma fita simulada, mostrando antes/depois."
                                  ],
                                  "verification": "Modifique uma fita simulada escrevendo o novo símbolo corretamente após simular leitura.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Fita reutilizável ou quadro branco",
                                    "Exemplos de funções δ"
                                  ],
                                  "tips": "Apague e reescreva visivelmente para demonstrar a substituição exata.",
                                  "learningObjective": "Entender como o cabeçote modifica o estado da fita via escrita.",
                                  "commonMistakes": "Escrever em célula errada ou confundir escrita com movimento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detalhar os movimentos possíveis do cabeçote",
                                  "subSteps": [
                                    "Liste as direções: Esquerda (L) - move uma célula à esquerda; Direita (R) - uma à direita; Fica (N) - permanece na célula atual.",
                                    "Explique que o movimento é determinado por δ e ocorre após a escrita.",
                                    "Simule movimentos: de posição 0 para 1 (R), ou volta para -1 (L).",
                                    "Discuta implicações: L/R permitem acesso infinito; N para processamento local.",
                                    "Integre em ciclo completo: ler → escrever → mover → novo estado."
                                  ],
                                  "verification": "Execute um ciclo completo em fita simulada, rastreando posições do cabeçote.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fita longa em papel",
                                    "Marcadores para posições"
                                  ],
                                  "tips": "Use um ponteiro físico (caneta) para simular o cabeçote movendo-se.",
                                  "learningObjective": "Compreender como movimentos direcionais habilitam computação universal.",
                                  "commonMistakes": "Assumir movimentos múltiplos por passo ou ignorar 'N' como opção válida."
                                }
                              ],
                              "practicalExample": "Simule uma MT que reconhece strings pares de '1's: Fita inicial '_1111_', cabeçote em '_'. Lê '_', escreve 'X', move R; lê '1', escreve 'Y', move R; continua alternando até fim, verificando paridade.",
                              "finalVerifications": [
                                "Desenhe e explique o ciclo completo: ler-escrever-mover.",
                                "Simule 5 passos de uma MT simples sem erros.",
                                "Defina precisamente Γ, L/R/N e posição do cabeçote.",
                                "Compare cabeçote de MT com cabeçote de fita magnética real.",
                                "Responda: 'O que acontece se o cabeçote mover L da posição 0?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de leitura, escrita e movimentos (100% correta).",
                                "Capacidade de simular ciclo completo sem confusões de posição.",
                                "Uso correto de notação: Γ, L/R/N, δ.",
                                "Clareza em diagramas e explicações verbais.",
                                "Identificação de erros comuns em simulações alheias.",
                                "Integração com outros componentes da MT (fita, estados)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Movimento direcional similar a cabeçotes em motores lineares.",
                                "Eletrônica: Leitura/escrita análoga a sensores e atuadores em microcontroladores.",
                                "Matemática: Posições como números inteiros em linha numérica infinita.",
                                "Engenharia de Software: Ponteiros em linguagens como C++."
                              ],
                              "realWorldApplication": "Em discos rígidos (HDDs), o cabeçote lê/escreve bits em trilhas magnéticas, movendo-se L/R; em processadores, cache lines simulam acessos locais como 'N'."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.4",
                        "name": "Função de Transição",
                        "description": "A função parcial de transição δ que determina o próximo estado, símbolo escrito e direção de movimento.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.4.1",
                            "name": "Definir a função de transição δ",
                            "description": "Especificar δ: Q × Γ → Q × Γ × {L, R, N} como a regra central que define o comportamento passo a passo da máquina.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a assinatura formal da função δ",
                                  "subSteps": [
                                    "Identifique os componentes de entrada: conjunto de estados Q e alfabeto Γ.",
                                    "Explique o domínio: pares (q, γ) onde q ∈ Q e γ ∈ Γ.",
                                    "Descreva a saída: tripla (q', γ', D) onde q' ∈ Q, γ' ∈ Γ ∪ {blank}, D ∈ {L, R, N}.",
                                    "Diferencie N (ficar) de L (esquerda) e R (direita).",
                                    "Anote exemplos simbólicos para cada parte."
                                  ],
                                  "verification": "Escreva a assinatura δ: Q × Γ → Q × Γ × {L, R, N} corretamente e explique cada símbolo em uma frase.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de Máquina de Turing padrão",
                                    "Referência formal de MT (livro ou PDF)"
                                  ],
                                  "tips": "Use notação matemática precisa; memorize que Γ inclui o blank symbol.",
                                  "learningObjective": "Entender a estrutura matemática exata da função de transição δ.",
                                  "commonMistakes": [
                                    "Confundir Γ com Σ (alfabeto de entrada)",
                                    "Esquecer blank no range de símbolos de escrita",
                                    "Ignorar {N} como direção possível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar transições individuais para pares (q, γ)",
                                  "subSteps": [
                                    "Liste todos os estados Q e símbolos Γ relevantes para sua MT.",
                                    "Para cada par (q, γ), defina manualmente q', γ' e D.",
                                    "Comece com transições do estado inicial q0.",
                                    "Inclua transições para símbolos de entrada e blank.",
                                    "Registre em formato tabular: linhas para q, colunas para γ."
                                  ],
                                  "verification": "Crie pelo menos 3 transições exemplo e verifique se cada uma tem q', γ', D válidos.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Exemplo de MT simples (ex: reconhecedor de palíndromos)",
                                    "Ferramenta online de simulador MT opcional"
                                  ],
                                  "tips": "Priorize completude: defina para TODO Q × Γ para evitar undefined behavior.",
                                  "learningObjective": "Mapear entradas para saídas específicas na função δ.",
                                  "commonMistakes": [
                                    "Deixar pares indefinidos",
                                    "Usar símbolos fora de Γ",
                                    "Confundir escrita γ' com leitura γ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a tabela de transição completa e estados halting",
                                  "subSteps": [
                                    "Preencha a tabela δ para todos os pares Q × Γ.",
                                    "Defina transições para estados halting: tipicamente δ(h, γ) = (h, γ, N).",
                                    "Garanta que estados halting sejam sink states (não saem).",
                                    "Valide consistência: sem loops infinitos prematuros.",
                                    "Converta tabela em notação funcional: δ(q1,a)=(q2,b,R)."
                                  ],
                                  "verification": "A tabela cobre 100% dos pares e halting states estão corretos; teste com 2 entradas simuladas.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Tabela em Excel ou LaTeX",
                                    "Pseudocódigo de simulador MT",
                                    "Exemplos de MT de livros-texto"
                                  ],
                                  "tips": "Use cores para halting transitions; teste δ em sequência manual.",
                                  "learningObjective": "Construir uma δ total e comportamentalmente correta.",
                                  "commonMistakes": [
                                    "Transições halting que movem a cabeça",
                                    "Tabela incompleta levando a rejeição",
                                    "Ciclos acidentais em halting"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e representar formalmente a função δ",
                                  "subSteps": [
                                    "Simule 2-3 configurações iniciais usando δ passo a passo.",
                                    "Verifique propriedades: determinística (única saída por entrada), total (definida everywhere).",
                                    "Escreva δ como conjunto de triplas: δ = {((q,γ),(q',γ',D)) | ...}.",
                                    "Compare com definição padrão de MT.",
                                    "Documente em pseudocódigo ou diagrama de estados."
                                  ],
                                  "verification": "Simulação manual converge ou halts corretamente em exemplos; notação formal sem erros.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Simulador MT online (ex: Turing Machine Simulator)",
                                    "Fita simulada em papel",
                                    "Livro de teoria da computação"
                                  ],
                                  "tips": "Simule devagar, anotando configurações; use {N} só quando necessário.",
                                  "learningObjective": "Garantir que δ defina uma MT válida e funcional.",
                                  "commonMistakes": [
                                    "Não testar com blank symbols",
                                    "Erros em simulação manual",
                                    "Representação não formal"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma MT que soma 1 em binário (ex: 101 -> 110): δ(q0,1)=(q0,1,R); δ(q0,0)=(q1,1,R); δ(q1,blank)=(q0,1,L); δ(qh,*)=(qh,*,N) para halting qh.",
                              "finalVerifications": [
                                "δ é definida para todo q ∈ Q, γ ∈ Γ?",
                                "Todas saídas são (q' ∈ Q, γ' ∈ Γ ∪ {□}, D ∈ {L,R,N})?",
                                "Estados halting têm δ(h,γ)=(h,γ,N)?",
                                "Simulação manual em 3 entradas halta corretamente?",
                                "Tabela/ conjunto é determinístico (uma saída por entrada)?",
                                "Inclui transições para blank symbol □?"
                              ],
                              "assessmentCriteria": [
                                "Completude: 100% dos pares Q × Γ definidos (30%)",
                                "Correção formal: assinatura e ranges exatos (25%)",
                                "Consistência comportamental: halting correto, sem loops (20%)",
                                "Clareza de representação: tabela ou notação legível (15%)",
                                "Validação prática: simulações bem-sucedidas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções parciais/totais e relações cartesianas",
                                "Lógica: Tabelas de verdade análogas a tabelas de transição",
                                "Programação: Switch-case ou map em simuladores de MT",
                                "Física: Estados quânticos e transições em autômatos celulares"
                              ],
                              "realWorldApplication": "Em compiladores (parsers como LL/LR usam transições semelhantes), simuladores de computação quântica, verificadores de software (model checking com δ para estados), e algoritmos de controle em robótica autônoma."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.4.2",
                            "name": "Reconhecer a parcialidade de δ",
                            "description": "Explicar que δ é parcial, ou seja, nem todas as combinações (q, a) têm definição, levando a halting se indefinida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal da função de transição δ em Máquinas de Turing",
                                  "subSteps": [
                                    "Leia a definição padrão de δ: δ: Q × Γ → Q × Γ × {L, R} ou indefinida para alguns pares (q, a).",
                                    "Identifique os componentes: Q (estados), Γ (alfabeto da fita).",
                                    "Anote exemplos de δ total vs. parcial de livros ou notas.",
                                    "Desenhe um diagrama simples de uma MT mostrando δ.",
                                    "Compare com autômatos finitos onde δ é total."
                                  ],
                                  "verification": "Você pode recitar a assinatura de δ e listar seus domínios sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser), caderno para anotações, quadro branco"
                                  ],
                                  "tips": "Use setas para visualizar transições indefinidas como 'buracos' no mapeamento.",
                                  "learningObjective": "Compreender a assinatura e domínio potencial de δ em MT.",
                                  "commonMistakes": [
                                    "Confundir δ de MT com δ de AFD (sempre total)",
                                    "Ignorar que δ pode mapear para movimento L/R"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar funções totais e parciais no contexto de δ",
                                  "subSteps": [
                                    "Defina função total: definida para todo domínio possível.",
                                    "Defina função parcial: indefinida para alguns elementos do domínio.",
                                    "Liste todas combinações possíveis (q, a) para uma MT pequena (ex: 2 estados, 2 símbolos).",
                                    "Marque quais pares têm definição em δ e quais não.",
                                    "Explique verbalmente: 'δ é parcial se nem todo (q,a) leva a uma transição'."
                                  ],
                                  "verification": "Crie uma tabela de domínio de δ e identifique pelo menos 2 pares indefinidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela de verdade-like, exemplos de MT online"
                                  ],
                                  "tips": "Pense em funções parciais como métodos em programação que retornam null/throw exception.",
                                  "learningObjective": "Distinguir parcialidade conceitualmente aplicada a δ.",
                                  "commonMistakes": [
                                    "Achar que parcial significa 'meio definido' em vez de 'não totalmente'",
                                    "Confundir com não-determinismo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar um exemplo concreto de δ parcial",
                                  "subSteps": [
                                    "Escolha uma MT simples que reconhece {a^n b^n} com estados q0, q1, qaccept, qreject.",
                                    "Escreva δ com pelo menos um par (q,a) indefinido.",
                                    "Simule execução: ao atingir indefinido, pare.",
                                    "Desenhe o grafo de transições destacando arestas ausentes.",
                                    "Teste com input que força indefinido."
                                  ],
                                  "verification": "Simule a MT em papel e mostre onde para por δ indefinida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de MT online (ex: Turing Machine Simulator), papel milimetrado"
                                  ],
                                  "tips": "Comece com MT mínima para evitar sobrecarga cognitiva.",
                                  "learningObjective": "Reconhecer parcialidade em prática através de simulação.",
                                  "commonMistakes": [
                                    "Assumir que indefinido = loop infinito",
                                    "Esquecer de considerar estado halting"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar consequências da parcialidade de δ",
                                  "subSteps": [
                                    "Descreva halting: MT para se δ(q,a) indefinida.",
                                    "Compare com halting states explícitos (qaccept, qreject).",
                                    "Discuta por que parcialidade é útil (economia, expressividade).",
                                    "Crie variação: torne δ total adicionando transições para qreject.",
                                    "Explique impacto em decidibilidade."
                                  ],
                                  "verification": "Escreva um parágrafo explicando 'δ parcial leva a halting natural'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas anteriores, fórum ou vídeo sobre halting problem"
                                  ],
                                  "tips": "Ligue a exceções em software para analogia intuitiva.",
                                  "learningObjective": "Entender implicações práticas da parcialidade.",
                                  "commonMistakes": [
                                    "Pensar que toda MT para só em halting states",
                                    "Ignorar que parcial permite computações parciais"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere MT M com Q={q0,qacc,qrej}, Γ={0,1,B}, δ(q0,0)=(q0,0,R) apenas; indefinido para (q0,1). Input '01': lê 0→avança, lê 1→δ indefinida→halts rejeitando.",
                              "finalVerifications": [
                                "Liste 3 pares (q,a) indefinidos em uma MT exemplo.",
                                "Simule MT que halts por δ parcial, não por qhalt.",
                                "Explique diferença entre δ parcial e não-determinista.",
                                "Crie δ parcial para MT que aceita apenas strings vazias.",
                                "Identifique parcialidade em pseudocódigo de δ."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de δ parcial (sem confusão com total).",
                                "Capacidade de simular halting devido a indefinido.",
                                "Uso correto de notação formal em exemplos.",
                                "Identificação de pelo menos 80% dos pares indefinidos em tabela.",
                                "Explicação clara de vantagens da parcialidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções parciais em teoria de conjuntos.",
                                "Programação: Funções que retornam Option/None ou throw.",
                                "Lógica: Predicados parciais em lógica computacional.",
                                "Filosofia da Computação: Limites da computabilidade (halting)."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, funções de transição parciais modelam erros de sintaxe (halting em parse error); simuladores de MT usam para testar decidibilidade de linguagens."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.4.3",
                            "name": "Montar a 7-tupla formal da MT",
                            "description": "Combinar todos os componentes em M = (Q, Σ, Γ, δ, q₀, B, F) como a definição formal completa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e listar os sete componentes da 7-tupla formal de uma Máquina de Turing",
                                  "subSteps": [
                                    "Leia a definição formal: M = (Q, Σ, Γ, δ, q₀, B, F)",
                                    "Liste cada componente com sua descrição: Q (estados), Σ (alfabeto de entrada), Γ (alfabeto da fita), δ (função de transição), q₀ (estado inicial), B (símbolo em branco), F (estados finais)",
                                    "Anote exemplos genéricos para cada um, como Q = {q0, q1, qhalt}",
                                    "Crie uma tabela com colunas para componente, descrição e exemplo",
                                    "Verifique se todos os sete estão presentes e corretamente nomeados"
                                  ],
                                  "verification": "Conferir se a tabela lista exatamente sete componentes com descrições precisas e sem duplicatas ou omissões",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência: Livro 'Introduction to the Theory of Computation' de Sipser (cap. 7)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use abreviações padrão como 'q₀' para estado inicial e 'B' para blank; mantenha consistência na notação",
                                  "learningObjective": "Entender o papel exato de cada componente na definição formal de MT",
                                  "commonMistakes": [
                                    "Confundir Σ com Γ (Σ não inclui B)",
                                    "Esquecer que δ é uma função parcial",
                                    "Omitir F como conjunto de estados aceitadores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os componentes finitos: Q, Σ, Γ, q₀, B e F para uma MT específica",
                                  "subSteps": [
                                    "Escolha uma linguagem simples, ex: L = {w w | w ∈ {0,1}* } (cópia da string)",
                                    "Defina Q = {q0, q1, ..., qaccept, qreject} com pelo menos 5 estados",
                                    "Defina Σ = {0,1}, Γ = {0,1,B,#}, onde # é marcador",
                                    "Especifique q₀ = q0, B = B, F = {qaccept}",
                                    "Escreva cada definição em notação formal, ex: Q = {q0, q1, q2, qaccept, qreject}"
                                  ],
                                  "verification": "Validar se os conjuntos são finitos, disjuntos onde necessário (ex: q₀ ∈ Q, B ∈ Γ \\ Σ), e relevantes para a linguagem escolhida",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado para diagramas",
                                    "Editor de texto para notação LaTeX opcional",
                                    "Exemplos online de MTs simples"
                                  ],
                                  "tips": "Comece com poucos estados para simplicidade; garanta que Γ ⊇ Σ ∪ {B}",
                                  "learningObjective": "Selecionar componentes consistentes e finitos que suportem a computação desejada",
                                  "commonMistakes": [
                                    "Incluir símbolos de Σ em F",
                                    "Definir Q infinito",
                                    "Esquecer B na definição de Γ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a função de transição δ como um conjunto de transições parciais",
                                  "subSteps": [
                                    "Defina o domínio: δ: Q × Γ → Q × Γ × {L,R} (parcial)",
                                    "Liste pelo menos 5-10 transições específicas, ex: δ(q0, 0) = (q1, #, R)",
                                    "Use uma tabela: colunas Estado atual, Símbolo lido, Novo estado, Escrever, Direção",
                                    "Garanta totalidade parcial: nem todas combinações precisam estar definidas",
                                    "Teste δ em um input fictício para checar ciclos ou halts"
                                  ],
                                  "verification": "Simular uma transição manual: aplicar δ em (q0, símbolo) e confirmar saída válida",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela δ",
                                    "Simulador de MT online (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": "Agrupe transições por estado; use 'H' para halt se necessário, mas prefira qaccept/qreject",
                                  "learningObjective": "Modelar o comportamento dinâmico da MT via função δ precisa",
                                  "commonMistakes": [
                                    "Definir δ total quando deve ser parcial",
                                    "Direções inválidas além de L/R",
                                    "Estados de saída fora de Q"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e validar a 7-tupla formal completa M = (Q, Σ, Γ, δ, q₀, B, F)",
                                  "subSteps": [
                                    "Escreva a tupla unificada: M = ( {q0,...}, {0,1}, {0,1,B,#}, δ onde δ(...), q0, B, {qaccept} )",
                                    "Substitua δ pela lista ou tabela de transições dentro da tupla",
                                    "Verifique consistência: q₀ ∈ Q, F ⊆ Q, B ∈ Γ, dom(δ) ⊆ Q × Γ",
                                    "Simule a MT em um exemplo curto de input para confirmar aceitação/rejeição",
                                    "Formate em notação matemática limpa"
                                  ],
                                  "verification": "Ler em voz alta e checar se todos elementos estão presentes e corretamente ordenados na tupla",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "LaTeX editor ou papel para notação formal",
                                    "Simulador de MT para teste final"
                                  ],
                                  "tips": "Use parênteses e vírgulas estritamente; liste δ como conjunto de 5-tuplas {(q,a),(p,b,D)}",
                                  "learningObjective": "Sintetizar todos componentes em uma definição formal coesa e verificável",
                                  "commonMistakes": [
                                    "Ordem errada dos componentes",
                                    "δ não formalizada como função",
                                    "Inconsistências entre componentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Para MT que aceita {0^n 1^n | n ≥ 0}: Q={q0,q1,q2,qacc,qrej}, Σ={0,1}, Γ={0,1,B}, δ inclui δ(q0,0)=(q1,0,R), δ(q1,1)=(q2,1,L), etc., q0=q0, B=B, F={qacc}. Tupla completa: M=(Q,Σ,Γ,δ,q0,B,F). Simule em '01': move direito em 0, emparelha com 1, aceita.",
                              "finalVerifications": [
                                "Todos sete componentes estão presentes e na ordem correta: Q, Σ, Γ, δ, q₀, B, F",
                                "δ é definida como função parcial com saídas em Q × Γ × {L,R}",
                                "Conjuntos satisfazem: q₀ ∈ Q, F ⊆ Q, B ∈ Γ \\ Σ, Γ ⊇ Σ ∪ {B}",
                                "Simulação em input de teste resulta em estado de F ou rejeição apropriada",
                                "Notação é precisa, sem erros tipográficos em símbolos ou subscritos",
                                "Componentes são finitos e relevantes para uma linguagem decidível"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de cada componente (100% match com teoria padrão)",
                                "Completude da função δ com pelo menos 80% das transições necessárias cobertas",
                                "Consistência interna entre componentes (ex: símbolos em δ ∈ Γ)",
                                "Capacidade de simular corretamente um input exemplo",
                                "Clareza e formalidade na notação da tupla (legível e matemática)",
                                "Criatividade na escolha de MT simples mas não trivial"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos (Q, Σ como conjuntos finitos) e Funções Parciais",
                                "Lógica: Estados como proposições booleanas em autômatos finitos",
                                "Filosofia da Computação: Limites da Computabilidade (relacionado a Halting Problem)",
                                "Engenharia de Software: Verificação Formal de Sistemas (model checking com MT)",
                                "Algoritmos: Base para complexidade computacional (P vs NP)"
                              ],
                              "realWorldApplication": "Modelagem formal de protocolos em compiladores (parsers como MTs), verificação de software (usar MTs para provar propriedades), design de autômatos em IA para processamento de linguagens naturais, e análise de decidibilidade em sistemas embarcados ou blockchain (smart contracts)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1",
                              "10.1.6.1.2.1",
                              "10.1.6.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Máquinas de Turing com Múltiplas Fitas",
                    "description": "Extensão do modelo padrão com várias fitas para simular computações equivalentes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Definição Formal de Máquinas de Turing com Múltiplas Fitas",
                        "description": "Apresenta a extensão do modelo padrão de Máquina de Turing (MT) para múltiplas fitas, incluindo os componentes formais e sua notação tupla, destacando as fitas independentes e cabeçotes associados.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Identificar componentes de uma MTMF",
                            "description": "Listar e descrever os elementos constitutivos de uma Máquina de Turing com k fitas: conjunto de estados Q, alfabeto de entrada Σ, alfabeto das fitas Γ, função de transição δ, estado inicial q0, símbolo em branco B, estados finais F e número de fitas k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar componentes de uma Máquina de Turing de fita única",
                                  "subSteps": [
                                    "Estude a definição formal de uma MT de fita única: Q, Σ, Γ, δ, q0, B, F.",
                                    "Anote cada componente e sua função básica (ex: Q é conjunto finito de estados).",
                                    "Compare com diagramas visuais de MTs para fixar conceitos.",
                                    "Crie um mapa mental ligando cada símbolo à sua descrição.",
                                    "Resuma em uma tabela: Componente | Descrição | Exemplo simples."
                                  ],
                                  "verification": "Construa uma tabela completa com os 7 componentes de MT de fita única sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre MTs",
                                    "Vídeo introdutório sobre Máquinas de Turing (ex: YouTube - Automata Theory)",
                                    "Papel e caneta para mapa mental"
                                  ],
                                  "tips": "Use mnemônicos como 'Q-Sigma-Gamma-Delta-Q0-Blank-F' para memorizar a ordem.",
                                  "learningObjective": "Compreender a base de MTs de fita única como pré-requisito para MTMF.",
                                  "commonMistakes": [
                                    "Confundir Σ (entrada) com Γ (fita completa)",
                                    "Esquecer que Q é finito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender adaptações para Máquinas de Turing com Múltiplas Fitas (MTMF)",
                                  "subSteps": [
                                    "Leia a definição de MTMF, destacando a adição do número de fitas k.",
                                    "Explique como cada fita tem sua própria cabeça de leitura/escrita.",
                                    "Analise como δ muda para múltiplas fitas: δ: Q × Γ^k → Q × (Γ × {L,R,N})^k.",
                                    "Desenhe um diagrama de uma MTMF com k=2 fitas para visualizar.",
                                    "Compare δ de MT única vs. MTMF em uma tabela de diferenças."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama de MTMF com k=2, incluindo cabeças de fita.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Ferramenta de desenho online (ex: Draw.io)",
                                    "Exemplos de definições formais de MTMF"
                                  ],
                                  "tips": "Pense nas fitas como 'trabalhadores paralelos' para intuitivamente entender k.",
                                  "learningObjective": "Identificar como o parâmetro k e a transição δ se adaptam para múltiplas fitas.",
                                  "commonMistakes": [
                                    "Ignorar o expoente k em Γ^k na função δ",
                                    "Confundir movimento de cabeças entre fitas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Listar e descrever detalhadamente cada componente da MTMF",
                                  "subSteps": [
                                    "Liste os 8 componentes: Q, Σ, Γ, δ, q0, B, F, k.",
                                    "Descreva cada um: ex: k é inteiro positivo ≥1; δ considera tuplas de símbolos de k fitas.",
                                    "Escreva formalmente δ para MTMF e dê um exemplo com k=2.",
                                    "Crie flashcards com componente no frente e descrição no verso.",
                                    "Revise flashcards até acertar 100% em uma rodada."
                                  ],
                                  "verification": "Recite os 8 componentes com descrições precisas em voz alta ou por escrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Flashcards físicos ou app (ex: Anki)",
                                    "Folha de papel para lista formal",
                                    "Referência formal de MTMF"
                                  ],
                                  "tips": "Agrupe componentes: 'Estados e símbolos (Q,Σ,Γ,B)', 'Controle (δ,q0,F)', 'Hardware (k)' para memorização.",
                                  "learningObjective": "Dominar definições precisas e formais de todos os componentes da MTMF.",
                                  "commonMistakes": [
                                    "Omitir k como componente explícito",
                                    "Descrever δ como se fosse para fita única"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em exemplos e sintetizar conhecimento",
                                  "subSteps": [
                                    "Analise uma definição formal de MTMF exemplo e identifique cada componente.",
                                    "Crie sua própria MTMF simples (ex: copiadora com 2 fitas) e especifique todos os componentes.",
                                    "Resolva exercícios: 'Dado δ, qual é k?' ou 'Liste componentes ausentes'.",
                                    "Explique para um 'parceiro de estudo' (ou grave áudio) os componentes.",
                                    "Revise erros e reforce com repetição espaçada."
                                  ],
                                  "verification": "Construa uma MTMF completa fictícia listando todos os 8 componentes corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exercícios de teoria da computação",
                                    "Gravador de áudio ou parceiro",
                                    "Editor de texto para especificação formal"
                                  ],
                                  "tips": "Sempre especifique k primeiro para contextualizar os outros componentes.",
                                  "learningObjective": "Aplicar identificação de componentes em contextos práticos e formais.",
                                  "commonMistakes": [
                                    "Não especificar domínio exato de δ para k fitas",
                                    "Confundir B como parte de Σ"
                                  ]
                                }
                              ],
                              "practicalExample": "Defina uma MTMF com k=2 que copia o input da fita 1 para a fita 2: Q={q0,q1,qcopy,qaccept}, Σ={0,1}, Γ={0,1,B}, δ(q0,(B,B))=(q1,(B,B),(R,R)) [exemplo parcial; δ completa considera tuplas de 2 símbolos, move cabeças independentemente], q0, B, F={qaccept}, k=2. Identifique: Q é estados de controle compartilhado, etc.",
                              "finalVerifications": [
                                "Liste os 8 componentes exatos de uma MTMF sem consultar notas.",
                                "Escreva a assinatura formal da função δ para k fitas.",
                                "Dado um exemplo de MTMF, aponte qual é Σ, Γ e k.",
                                "Explique a diferença de δ entre MT de 1 fita e MTMF.",
                                "Crie uma tabela resumindo funções de q0, B e F em MTMF.",
                                "Desenhe configuração inicial de MTMF com k=3."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos os 8 componentes listados corretamente.",
                                "Precisão formal: Assinaturas matemáticas de δ e domínios exatos.",
                                "Clareza descritiva: Explicações concisas e sem ambiguidades.",
                                "Diferenciação: Distinção clara entre MT única e MTMF.",
                                "Aplicação: Capacidade de identificar em exemplos dados.",
                                "Profundidade: Menção a independência de cabeças de fita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos finitos (Q, Σ, Γ) e funções parciais.",
                                "Lógica: Transições como regras de inferência em autômatos.",
                                "Programação: Simulação de MTMF em Python com listas para fitas.",
                                "Física: Analogia com sistemas multi-fita como processadores paralelos.",
                                "Engenharia de Software: Modelagem formal de estados em verificadores."
                              ],
                              "realWorldApplication": "Em compiladores e simuladores, MTMFs modelam computação paralela; usadas em provas de equivalência P=NP e em ferramentas como JFLAP para visualizar algoritmos em fitas múltiplas, auxiliando no design de hardware multi-threaded."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Escrever a notação formal de uma MTMF",
                            "description": "Formalizar uma MTMF como a tupla (Q, Σ, Γ, δ: Q × Γ^k → Q × Γ^k × {L,R,S}^k, q0, B, F), explicando o papel de cada parâmetro e como a transição atua simultaneamente em múltiplas fitas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal de Máquina de Turing de fita única",
                                  "subSteps": [
                                    "Lembre-se da tupla padrão de uma MT: (Q, Σ, Γ, δ: Q × Γ → Q × Γ × {L, R}, q0, B, F).",
                                    "Identifique o papel de cada componente: Q (estados), Σ (alfabeto de entrada), Γ (alfabeto de fita), δ (função de transição), q0 (estado inicial), B (símbolo em branco), F (estados finais).",
                                    "Explique como a transição δ funciona em uma única fita.",
                                    "Anote exemplos simples de transições para uma MT básica.",
                                    "Compare com MTMF para destacar diferenças."
                                  ],
                                  "verification": "Escreva a tupla de uma MT de fita única corretamente e explique cada parâmetro em voz alta ou por escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas de aula sobre MT, livro de Teoria da Computação (ex: Sipser), quadro ou papel para anotações.",
                                  "tips": "Use diagramas para visualizar a fita única e as transições.",
                                  "learningObjective": "Compreender a base da MT de fita única para contrastar com múltiplas fitas.",
                                  "commonMistakes": "Confundir Σ com Γ ou esquecer que δ move apenas L ou R em uma fita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o conceito de Máquinas de Turing com Múltiplas Fitas (MTMF)",
                                  "subSteps": [
                                    "Defina MTMF como uma MT com k fitas independentes, onde k ≥ 1.",
                                    "Explique que cada fita tem sua própria cabeça de leitura/escrita.",
                                    "Descreva o comportamento simultâneo: em cada passo, todas as cabeças leem, escrevem e movem-se ao mesmo tempo.",
                                    "Discuta equivalência computacional: MTMF com k fitas simula MT de fita única.",
                                    "Visualize com um desenho de k fitas paralelas."
                                  ],
                                  "verification": "Desenhe um diagrama de uma MTMF com 2 fitas mostrando uma transição simultânea.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta para diagramas, vídeo tutorial sobre MTMF (YouTube ou Khan Academy).",
                                  "tips": "Pense nas fitas como threads paralelas em programação.",
                                  "learningObjective": "Graspar a extensão conceitual de uma para múltiplas fitas.",
                                  "commonMistakes": "Achar que as fitas compartilham símbolos ou que cabeças se movem independentemente em tempo diferente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e descrever os componentes da tupla de MTMF",
                                  "subSteps": [
                                    "Liste os componentes: Q, Σ, Γ, δ, q0, B, F (iguais à MT única).",
                                    "Note que Σ e Γ são compartilhados por todas as fitas, mas δ é adaptada para k fitas.",
                                    "Descreva Q: conjunto finito de estados (único para todas cabeças).",
                                    "Explique q0 (inicial), B (branco em todas fitas), F (aceitação).",
                                    "Escreva a tupla parcial sem δ: (Q, Σ, Γ, ..., q0, B, F)."
                                  ],
                                  "verification": "Escreva os 7 componentes com descrições breves em uma tabela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela em Excel ou papel, referência formal (ex: Wikipedia MT Multi-tape).",
                                  "tips": "Crie uma tabela comparativa MT vs MTMF.",
                                  "learningObjective": "Memorizar e diferenciar componentes específicos de MTMF.",
                                  "commonMistakes": "Esquecer que Q é compartilhado ou confundir Γ^k com Γ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a função de transição δ para MTMF",
                                  "subSteps": [
                                    "Defina δ: Q × Γ^k → Q × Γ^k × {L, R, S}^k.",
                                    "Explique entrada: estado atual + símbolo lido em cada uma das k fitas.",
                                    "Saída: novo estado + símbolo a escrever em cada fita + direção para cada cabeça (L, R ou S=stay).",
                                    "Forneça exemplo: δ(q, a, b) = (p, X, Y, L, R) para k=2.",
                                    "Compare com MT única: δ(q, γ) → (p, γ', D)."
                                  ],
                                  "verification": "Escreva 3 exemplos de δ para k=2 e simule uma transição passo a passo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulador online de MT (ex: Turing Machine Simulator), papel para simulações.",
                                  "tips": "Use tuplas para representar leituras/escrições: (γ1, γ2, ..., γk).",
                                  "learningObjective": "Dominar a notação e mecânica da transição simultânea.",
                                  "commonMistakes": "Usar {L,R} ao invés de {L,R,S}^k ou errar a aridade de δ."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar e explicar a notação formal completa de uma MTMF",
                                  "subSteps": [
                                    "Escreva a tupla completa: (Q, Σ, Γ, δ: Q × Γ^k → Q × Γ^k × {L,R,S}^k, q0, B, F).",
                                    "Explique o papel de k: número fixo de fitas.",
                                    "Descreva o funcionamento global: configuração inicial com entrada na fita 1, outras em branco.",
                                    "Simule uma configuração completa de MTMF.",
                                    "Verifique consistência com definições padrão."
                                  ],
                                  "verification": "Escreva a notação formal exata e explique em um parágrafo coeso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Modelo de currículo ou template de MTMF, gravador para autoexplicação.",
                                  "tips": "Leia em voz alta para fixar a pronúncia da tupla.",
                                  "learningObjective": "Escrever e verbalizar a definição formal com precisão.",
                                  "commonMistakes": "Omitir o expoente k ou errar a assinatura de δ."
                                }
                              ],
                              "practicalExample": "Para uma MTMF com k=2 fitas que copia a entrada da fita 1 para a fita 2: M = (Q = {q0, q1, qf}, Σ = {0,1}, Γ = {0,1,B}, δ: Q × Γ^2 → Q × Γ^2 × {L,R,S}^2 onde δ(q0, 0, B) = (q1, 0, 0, R, R), δ(q0, 1, B) = (q1, 1, 1, R, R), etc., q0, B, F={qf}). Explique: lê da fita 1, escreve na 2 simultaneamente.",
                              "finalVerifications": [
                                "Escreve corretamente a tupla (Q, Σ, Γ, δ: Q × Γ^k → Q × Γ^k × {L,R,S}^k, q0, B, F).",
                                "Explica o papel de cada um dos 7 componentes.",
                                "Descreve como δ atua simultaneamente em k fitas.",
                                "Distingue δ de MT única vs MTMF.",
                                "Simula uma transição para k=2 sem erros.",
                                "Identifica k como parâmetro fixo do número de fitas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação da tupla (100% dos símbolos corretos).",
                                "Explicação clara do papel de δ e simultaneidade.",
                                "Uso correto de Γ^k e {L,R,S}^k.",
                                "Exemplo prático viável e consistente.",
                                "Ausência de confusões com MT de fita única.",
                                "Profundidade nas explicações (cobertura de todos componentes)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Tuplas, funções parciais e produtos cartesianos (Q × Γ^k).",
                                "Lógica Formal: Estados e transições como autômatos finitos estendidos.",
                                "Programação Paralela: Modelagem de threads multi-fita como processos concorrentes.",
                                "Teoria dos Grafos: Transições como arestas em grafo de configuração."
                              ],
                              "realWorldApplication": "Modelagem de sistemas paralelos em compiladores (simulação de registradores múltiplos) e arquiteturas multi-core, onde fitas representam pipelines de processamento simultâneo em CPUs modernas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Comparar MTMF com MT de fita única",
                            "description": "Explicar as diferenças e semelhanças entre MT de fita única e MTMF, enfatizando que as fitas extras permitem computações mais eficientes, mas não aumentam o poder expressivo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Formal de Máquina de Turing de Fita Única (MT)",
                                  "subSteps": [
                                    "Lembre-se dos componentes principais: conjunto finito de estados Q, alfabeto de fita Γ, alfabeto de entrada Σ, fita infinita em uma direção ou bidirecional, cabeça de leitura/escrita, função de transição δ: Q × Γ → Q × Γ × {L, R, N}, estado inicial q0, espaço em branco B, estados de halt F.",
                                    "Entenda o modelo de computação: a fita atua como memória ilimitada, a cabeça move-se esquerda/direita ou fica parada.",
                                    "Reveja exemplos simples, como uma MT que reconhece palíndromos ou soma em binário.",
                                    "Identifique limitações: tempo e espaço lineares para muitas computações.",
                                    "Pratique desenhando o diagrama de estados para uma MT básica."
                                  ],
                                  "verification": "Desenhe e descreva corretamente os 7 componentes de uma MT de fita única em um papel ou ferramenta digital.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de Teoria da Computação (ex: Sipser)",
                                    "Papel e caneta ou software de desenho de autômatos (ex: JFLAP)"
                                  ],
                                  "tips": [
                                    "Use notação formal exata para evitar confusões; foque na fita única como gargalo de memória."
                                  ],
                                  "learningObjective": "Dominar os componentes e funcionamento básico de uma MT de fita única.",
                                  "commonMistakes": [
                                    "Confundir direção de movimento da cabeça (L/R/N)",
                                    "Esquecer o estado de halt ou espaço em branco",
                                    "Assumir fita finita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Definição Formal de Máquinas de Turing com Múltiplas Fitas (MTMF)",
                                  "subSteps": [
                                    "Aprenda a extensão: k fitas independentes, cada uma com sua própria cabeça de leitura/escrita.",
                                    "Componentes: Q, Γ (mesmo para todas fitas), δ: Q × Γ^k → Q × Γ^k × {L,R,N}^k, onde k é o número de fitas.",
                                    "Note que todas fitas começam vazias com B, entrada só na fita 1.",
                                    "Simule mentalmente: cabeças movem-se independentemente, permitindo 'acesso paralelo' à memória.",
                                    "Compare sintaxe: similar à MT, mas transição considera símbolos de todas cabeças."
                                  ],
                                  "verification": "Escreva a tupla formal de uma MTMF com k=2 e dê um exemplo de δ.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Notas de aula sobre MTMF",
                                    "Simulador online de MT (ex: adaptação do Turing Machine Simulator)"
                                  ],
                                  "tips": [
                                    "Pense nas fitas extras como 'pilha' ou 'fila' simuladas, mas todas lineares."
                                  ],
                                  "learningObjective": "Compreender precisamente como MTMF estende MT sem alterar poder computacional.",
                                  "commonMistakes": [
                                    "Assumir que fitas têm alfabetos diferentes",
                                    "Confundir entrada em múltiplas fitas",
                                    "Ignorar independência das cabeças"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Semelhanças entre MT e MTMF",
                                  "subSteps": [
                                    "Liste semelhanças estruturais: ambos têm estados finitos, fitas com Γ, δ determinística, halt.",
                                    "Poder expressivo: toda MTMF com k fitas é simulada por MT de fita única (usando fita com tracks).",
                                    "Recursivamente enumeráveis: mesmas linguagens reconhecidas.",
                                    "Universalidade: MT universal simula qualquer MT ou MTMF.",
                                    "Ambos decidem problemas indecidíveis da mesma forma."
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 4 semelhanças comprovadas por teorema ou construção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo ou capítulo sobre equivalência de modelos de MT",
                                    "Planilha ou tabela em Markdown"
                                  ],
                                  "tips": [
                                    "Use teorema de simulação: MTMF(k) ≤ MT(1) em tempo/espaço quadrático."
                                  ],
                                  "learningObjective": "Reconhecer que MTMF não aumenta poder computacional além de MT.",
                                  "commonMistakes": [
                                    "Achar que MTMF resolve halting problem",
                                    "Ignorar simulação via tracks na fita única"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Diferenças, Enfatizando Eficiência",
                                  "subSteps": [
                                    "Diferenças chave: MTMF usa O(log n) espaço/tempo para computações que MT precisa O(n) ou O(n^2).",
                                    "Exemplo: cópia de string - MT: O(n^2), MTMF(2): O(n).",
                                    "Eficiência: fitas extras simulam estruturas de dados (vetores, matrizes) mais rápido.",
                                    "Poder: equivalente (teorema: para todo k, MTMF(k) ≡ MT(1)).",
                                    "Implicações: MTMF modela melhor computações paralelas reais."
                                  ],
                                  "verification": "Explique com prova esboçada por que fitas extras não aumentam poder expressivo, mas melhoram eficiência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de provas de Sipser ou Hopcroft",
                                    "Ferramenta de simulação para testar cópia"
                                  ],
                                  "tips": [
                                    "Foque em simulação: divida fita única em k tracks para provar equivalência."
                                  ],
                                  "learningObjective": "Explicar diferenças em eficiência vs. poder, com exemplos concretos.",
                                  "commonMistakes": [
                                    "Confundir eficiência com poder (ex: achar MTMF mais poderosa)",
                                    "Esquecer prova de simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o reconhecimento da linguagem {a^n b^n | n ≥ 0}. Na MT de fita única: marque a's e b's ida/volta (O(n^2) tempo). Na MTMF(2): fita 1 para entrada, fita 2 para contador (O(n) tempo). Compare passos e conclua equivalência de poder, mas ganho de eficiência.",
                              "finalVerifications": [
                                "Liste corretamente 4 semelhanças e 3 diferenças principais.",
                                "Prove esboço: MT simula MTMF via tracks.",
                                "Dê exemplo onde MTMF é quadraticamente mais rápida.",
                                "Explique por que poder expressivo é idêntico.",
                                "Desenhe δ para MTMF simples vs MT."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de ambos modelos (20%)",
                                "Correta identificação de semelhanças e prova de equivalência (30%)",
                                "Análise clara de diferenças em eficiência com exemplos (30%)",
                                "Uso de terminologia técnica sem erros (10%)",
                                "Capacidade de simular exemplo prático (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções parciais para δ.",
                                "Programação: Implementar simuladores de MT/MTMF em Python.",
                                "Lógica: Raciocínio sobre equivalência de modelos formais.",
                                "Física: Analogia com memória distribuída em computação quântica."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, entender MTMF ajuda a otimizar parsers (simulando fitas para lookahead); em algoritmos paralelos, modela threads com memória compartilhada, guiando designs eficientes sem iludir sobre limites computacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Configurações e Transições em MTMF",
                        "description": "Descreve como as MTMF evoluem durante a computação, incluindo representações de configurações e regras de transição para múltiplas fitas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Representar uma configuração de MTMF",
                            "description": "Desenhar e interpretar uma configuração instantânea de MTMF, indicando posições dos cabeçotes em cada fita, estado atual e conteúdo das fitas (ex.: u q v1 # v2 # ... # vk, onde # separa fitas).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar configuração de Máquina de Turing de fita única",
                                  "subSteps": [
                                    "Estude a notação padrão para configuração instantânea de MT simples: partes à esquerda da cabeça (u), estado (q) e partes à direita (v), como 'u q v'.",
                                    "Identifique os elementos chave: conteúdo das fitas, posição da cabeça de leitura/escrita e estado atual da máquina.",
                                    "Pratique com exemplos simples, desenhando fitas com símbolos (ex: 0, 1, blank) e marcando a cabeça com '↓'.",
                                    "Analise como a configuração muda em uma transição δ(q, símbolo) = (q', símbolo', direção).",
                                    "Compare configurações antes e depois de uma transição para entender o fluxo."
                                  ],
                                  "verification": "Desenhe corretamente 3 configurações de MT simples e explique a transição entre elas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, exemplos de MT simples impressos ou digitais.",
                                  "tips": "Sempre marque a posição exata da cabeça com uma seta para evitar ambiguidades.",
                                  "learningObjective": "Compreender a representação gráfica e simbólica de configurações em MT de fita única como base para MTMF.",
                                  "commonMistakes": "Confundir a direção da cabeça (L/R) com o movimento; esquecer blanks infinitos nas extremidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender notação específica para configurações de MTMF",
                                  "subSteps": [
                                    "Memorize a notação compacta: 'u q v1 # v2 # ... # vk', onde u é o prefixo comum ou estado inicial, q é o estado, vi é o sufixo da i-ésima fita a partir da cabeça, e # separa fitas.",
                                    "Entenda que cada fita tem sua própria cabeça independente, alinhadas verticalmente na configuração gráfica.",
                                    "Desenhe fitas paralelas, marcando posições das cabeçotes com setas ↓ em cada fita.",
                                    "Pratique escrevendo a notação linear para uma configuração gráfica dada.",
                                    "Converta uma configuração linear de volta para gráfica, verificando alinhamento das cabeças."
                                  ],
                                  "verification": "Converta 2 configurações gráficas para notação linear e vice-versa sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha quadriculada, exemplos de MTMF (livro ou PDF de teoria da computação).",
                                  "tips": "Use # consistentemente para separar fitas e alinhe as setas das cabeças verticalmente.",
                                  "learningObjective": "Dominar a notação simbólica e gráfica única para MT com múltiplas fitas.",
                                  "commonMistakes": "Esquecer o separador # entre fitas; desalinhar posições das cabeças entre fitas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar desenho de uma configuração de MTMF",
                                  "subSteps": [
                                    "Escolha uma MTMF simples (ex: 2 fitas, copiando de uma para outra).",
                                    "Desenhe as fitas horizontalmente paralelas, escrevendo símbolos e marcando cabeçotes.",
                                    "Inclua o estado q acima ou ao lado das cabeçotes alinhadas.",
                                    "Escreva a notação linear correspondente abaixo do desenho.",
                                    "Simule uma transição e desenhe a configuração resultante."
                                  ],
                                  "verification": "Crie e rotule corretamente o desenho e notação para uma transição completa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel milimetrado, simulador online de MTMF (opcional, como JFLAP).",
                                  "tips": "Mantenha fitas do mesmo comprimento visual para clareza, usando blanks (_).",
                                  "learningObjective": "Habilitar a criação precisa de representações visuais e simbólicas de configurações MTMF.",
                                  "commonMistakes": "Não indicar blanks nas extremidades; confundir ordem das fitas (v1 é fita 1, etc.)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e analisar configurações de MTMF",
                                  "subSteps": [
                                    "Dada uma configuração como 'ε q0 101 # 00_', identifique estado, posições de cabeçotes e conteúdos.",
                                    "Preveja possível próxima configuração com base na função de transição.",
                                    "Explique o que a máquina está fazendo (ex: comparando strings nas fitas).",
                                    "Compare com configuração de MT simples para destacar vantagens das múltiplas fitas.",
                                    "Resolva um exercício: de uma sequência de configurações, identifique o erro."
                                  ],
                                  "verification": "Interprete 3 configurações dadas, prevendo transições corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exercícios impressos de configurações MTMF, calculadora para contagens.",
                                  "tips": "Leia a notação da esquerda para direita, focando no alinhamento de q com cabeçotes.",
                                  "learningObjective": "Desenvolver habilidade de leitura e análise crítica de configurações MTMF.",
                                  "commonMistakes": "Ignorar o estado q ao prever transições; confundir símbolos entre fitas."
                                }
                              ],
                              "practicalExample": "Considere uma MTMF de 2 fitas que copia o conteúdo da fita 1 para a fita 2. Configuração inicial: 'ε q0 101 # ___'. Desenho: Fita1: ... _ 1 0 ↓1 _... | Fita2: ... _ _ ↓_ _... com q0 acima das ↓. Após transição, possivelmente 'ε q1 10 ↓1 # _0__' (cabeçote moveu).",
                              "finalVerifications": [
                                "Desenha configurações gráficas com fitas paralelas, cabeçotes alinhados e estado claro.",
                                "Converte precisamente entre notação linear 'u q v1 # v2' e representação visual.",
                                "Prevé transições corretas em pelo menos 80% dos casos testados.",
                                "Identifica erros comuns em configurações fornecidas por outros.",
                                "Explica o propósito computacional da configuração (ex: cópia, comparação)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na marcação de posições de cabeçotes (alinhamento vertical).",
                                "Correção na notação linear com separadores # e símbolos exatos.",
                                "Clareza visual no desenho (legibilidade, uso de blanks).",
                                "Capacidade de análise: previsão de transições e interpretação.",
                                "Consistência em múltiplos exemplos (sem erros repetidos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de estados em autômatos como grafos direcionados.",
                                "Lógica: Análise de sequências simbólicas semelhantes a provas formais.",
                                "Física: Modelagem de sistemas paralelos como fitas múltiplas em experimentos.",
                                "Artes: Desenho técnico preciso de diagramas e estruturas lineares."
                              ],
                              "realWorldApplication": "Em compiladores e simuladores, representações de MTMF modelam processadores multi-core ou pipelines paralelos em hardware, facilitando debug de algoritmos distribuídos em sistemas como Hadoop ou GPUs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Aplicar função de transição em MTMF",
                            "description": "Executar um passo de computação em uma MTMF, lendo símbolos de todas as fitas, aplicando δ e movendo cabeçotes simultaneamente para L (esquerda), R (direita) ou S (ficar).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a configuração atual da MTMF",
                                  "subSteps": [
                                    "Localize as posições atuais dos cabeçotes em cada fita.",
                                    "Leia o símbolo presente sob cada cabeçote em todas as fitas simultaneamente.",
                                    "Registre o estado atual da máquina (q).",
                                    "Forme a tupla de entrada: (q, σ₁, σ₂, ..., σₖ), onde σᵢ é o símbolo da fita i.",
                                    "Desenhe ou anote a configuração inicial para visualização."
                                  ],
                                  "verification": "Confirme que todos os símbolos das fitas foram lidos corretamente e a tupla de entrada está formada sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Diagrama da MTMF",
                                    "Papel e caneta",
                                    "Tabela de símbolos do alfabeto"
                                  ],
                                  "tips": "Sempre leia todas as fitas ao mesmo tempo para evitar confusão com configurações assíncronas.",
                                  "learningObjective": "Compreender e representar precisamente a configuração de entrada de uma MTMF.",
                                  "commonMistakes": [
                                    "Ler apenas uma fita ignorando as outras.",
                                    "Confundir a ordem das fitas na tupla.",
                                    "Esquecer o estado atual q."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Consultar a função de transição δ",
                                  "subSteps": [
                                    "Acesse a tabela ou definição formal da função de transição δ da MTMF.",
                                    "Localize a entrada correspondente: (q, σ₁, σ₂, ..., σₖ).",
                                    "Identifique a saída: δ(q, σ₁, ..., σₖ) = (p, τ₁, τ₂, ..., τₖ, d₁, d₂, ..., dₖ), onde p é o novo estado, τᵢ os símbolos a escrever e dᵢ as direções (L, R ou S).",
                                    "Verifique se a transição está definida; caso contrário, note se é um estado de halting.",
                                    "Anote a saída completa para referência."
                                  ],
                                  "verification": "A saída de δ coincide exatamente com a definição da máquina, sem ambiguidades.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de transições δ da MTMF",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Use índices para fitas (ex: fita 1, fita 2) para evitar trocar os componentes da tupla.",
                                  "learningObjective": "Aplicar corretamente a consulta à função de transição multidimensional.",
                                  "commonMistakes": [
                                    "Consultar δ com tupla incompleta.",
                                    "Confundir símbolos de entrada com saída.",
                                    "Ignorar se δ não está definida."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar as escritas e movimentos dos cabeçotes",
                                  "subSteps": [
                                    "Escreva o símbolo τᵢ sob o cabeçote de cada fita i.",
                                    "Mova simultaneamente cada cabeçote i de acordo com dᵢ: L (esquerda), R (direita) ou S (ficar).",
                                    "Atualize o estado da máquina para p.",
                                    "Ajuste as fitas visualmente para refletir as mudanças.",
                                    "Confirme que todas as ações foram simultâneas (não sequenciais)."
                                  ],
                                  "verification": "Nova configuração reflete exatamente os τᵢ escritos, posições dos cabeçotes movidos e estado p atualizado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama atualizado da MTMF",
                                    "Marcadores ou lápis coloridos para fitas"
                                  ],
                                  "tips": "Simule o movimento com setas para visualizar a simultaneidade.",
                                  "learningObjective": "Executar ações de transição de forma precisa e simultânea em múltiplas fitas.",
                                  "commonMistakes": [
                                    "Mover cabeçotes sequencialmente em vez de simultaneamente.",
                                    "Escrever símbolo errado em fita errada.",
                                    "Esquecer de atualizar o estado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e registrar a nova configuração",
                                  "subSteps": [
                                    "Leia os novos símbolos sob os cabeçotes nas posições atualizadas.",
                                    "Confirme o novo estado p e as posições finais dos cabeçotes.",
                                    "Compare com a configuração esperada da transição.",
                                    "Registre a configuração resultante para o próximo passo de computação.",
                                    "Identifique se a máquina parou (halting state)."
                                  ],
                                  "verification": "A configuração final é consistente com a aplicação de δ, sem discrepâncias.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Folha de configurações sequenciais",
                                    "Tabela δ para dupla-checagem"
                                  ],
                                  "tips": "Crie uma tabela antes/depois para comparações rápidas.",
                                  "learningObjective": "Validar a integridade da transição e preparar para iterações subsequentes.",
                                  "commonMistakes": [
                                    "Não verificar simultaneidade pós-movimento.",
                                    "Perder o rastro das posições dos cabeçotes.",
                                    "Ignorar estados de halting."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma MTMF com 2 fitas processando adição. Configuração inicial: estado q₀, fita1 cabeçote em '1' (σ₁='1'), fita2 cabeçote em '0' (σ₂='0'). δ(q₀, 1, 0) = (q₁, '0', '1', R, R). Aplicação: Escreva '0' em fita1 e mova R; escreva '1' em fita2 e mova R; novo estado q₁. Nova configuração: cabeçotes avançaram, símbolos alterados corretamente.",
                              "finalVerifications": [
                                "Todos os símbolos σᵢ foram lidos corretamente na entrada?",
                                "A função δ foi consultada com a tupla exata?",
                                "Símbolos τᵢ foram escritos em fitas corretas?",
                                "Movimentos dᵢ (L/R/S) aplicados simultaneamente?",
                                "Estado atualizado para p sem erros?",
                                "Nova configuração registrada para próximo passo?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na formação da tupla de entrada (100% dos símbolos corretos).",
                                "Consulta correta de δ sem ambiguidades.",
                                "Execução simultânea de escritas e movimentos (sem sequencialidade).",
                                "Verificação pós-transição completa e precisa.",
                                "Registro claro da configuração final.",
                                "Identificação de halting se aplicável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aplicação de funções parciais e tuplas multidimensionais.",
                                "Lógica e Filosofia: Conceitos de estados determinísticos e transições.",
                                "Programação: Similaridade com atualizações de estado em autômatos finitos ou threads paralelas.",
                                "Física: Analogia com movimentos simultâneos em sistemas multi-partícula."
                              ],
                              "realWorldApplication": "Em computação paralela, como em processadores multi-core ou bancos de dados distribuídos, onde operações em múltiplas 'fitas' (memórias ou threads) devem ocorrer simultaneamente, modelando transições atômicas para evitar race conditions."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Determinar aceitação e halting em MTMF",
                            "description": "Identificar condições de parada (halting): estado final, loop infinito ou rejeição, e definir a linguagem reconhecida L(M) como entradas que levam a configuração de aceitação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Estados de Halting e Configurações em MTMF",
                                  "subSteps": [
                                    "Revise a definição de configuração em MTMF: tupla (estado, posições das cabeças, conteúdos das fitas).",
                                    "Identifique estados especiais: q_accept (aceitação), q_reject (rejeição) e estados halting.",
                                    "Estude transições que levam a halting: sem movimento ou mudança de estado.",
                                    "Diferencie halting de loop infinito: ausência de ciclo detectável na configuração.",
                                    "Anote exemplos de configurações halting vs. não-halting."
                                  ],
                                  "verification": "Liste 3 configurações halting e explique por quê.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Diagrama da MTMF",
                                    "Notas de aula sobre configurações",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Sempre represente configurações graficamente para visualização clara.",
                                  "learningObjective": "Entender as condições fundamentais de parada em MTMF.",
                                  "commonMistakes": [
                                    "Confundir halting com rejeição.",
                                    "Ignorar posições das cabeças nas configurações.",
                                    "Não considerar todas as fitas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular Execução Passo a Passo até Halting",
                                  "subSteps": [
                                    "Inicie com entrada w na fita de entrada; configure cabeças iniciais.",
                                    "Aplique transições δ sequencialmente, atualizando estado e fitas.",
                                    "Registre cada configuração em uma tabela: passo, estado, fitas, posições.",
                                    "Pare se alcançar q_accept ou q_reject; anote o tipo de halting.",
                                    "Continue até 50 passos ou detecte repetição de configuração."
                                  ],
                                  "verification": "Simule 10 passos e identifique se halting ocorreu.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Ferramenta de simulação MT (ex: JFLAP)",
                                    "Exemplo de MTMF impresso",
                                    "Planilha para tabelas"
                                  ],
                                  "tips": "Use cores para fitas diferentes para evitar confusão visual.",
                                  "learningObjective": "Executar simulações precisas de MTMF.",
                                  "commonMistakes": [
                                    "Erros em atualização de posições das cabeças.",
                                    "Pular transições condicionais.",
                                    "Não registrar configurações completas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Loop Infinito e Rejeição",
                                  "subSteps": [
                                    "Monitore configurações vistas; detecte ciclo se repetir.",
                                    "Classifique não-halting: loop infinito se ciclo sem halting.",
                                    "Diferencie rejeição (q_reject alcançado) de loop (sem q_reject).",
                                    "Simule entradas que causam loops vs. halting.",
                                    "Discuta impacto: não-halting significa não decide a entrada."
                                  ],
                                  "verification": "Identifique loop em uma simulação de 20 passos.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Lista de configurações anteriores",
                                    "Exemplos de MTMF com loops",
                                    "Software de detecção de ciclos"
                                  ],
                                  "tips": "Mantenha um conjunto de configurações hash para detecção rápida de ciclos.",
                                  "learningObjective": "Reconhecer comportamentos não-terminantes em MTMF.",
                                  "commonMistakes": [
                                    "Confundir loop com halting distante.",
                                    "Ignorar fitas em branco como parte da configuração.",
                                    "Assumir halting sem simulação completa."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir a Linguagem Reconhecida L(M)",
                                  "subSteps": [
                                    "Defina L(M) = {w | simulação em w termina em q_accept}.",
                                    "Exclua entradas que vão para q_reject ou loop infinito.",
                                    "Teste múltiplas entradas: aceite, rejeite, não-decida.",
                                    "Escreva formalmente L(M) baseado em padrões observados.",
                                    "Verifique com teorema: L(M) é a linguagem decidida por M."
                                  ],
                                  "verification": "Escreva L(M) para uma MTMF exemplo e justifique.",
                                  "estimatedTime": "20-35 minutos",
                                  "materials": [
                                    "Definição formal de L(M)",
                                    "Conjunto de entradas teste",
                                    "Notas de simulações anteriores"
                                  ],
                                  "tips": "Agrupe entradas por comportamento para generalizar L(M).",
                                  "learningObjective": "Formalizar a linguagem aceita por MTMF.",
                                  "commonMistakes": [
                                    "Incluir entradas com loop em L(M).",
                                    "Confundir aceitação com decisão.",
                                    "Não especificar condições exatas."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere MTMF M com 2 fitas que verifica se w é par: Fita 1 lê w, Fita 2 conta símbolos. Transição: move direita em Fita 1, escreve 1 em Fita 2 por símbolo. Aceita se Fita 1 vazia e Fita 2 tem par de 1s (estado q_accept). Para w=ab (par), halting em aceitação; para w=a (ímpar), rejeita; para loop crafted, detecta ciclo.",
                              "finalVerifications": [
                                "Corretamente simula execução até halting ou detecta ciclo.",
                                "Classifica halting como aceitação ou rejeição.",
                                "Identifica configurações de loop infinito.",
                                "Define L(M) excluindo não-decidíveis.",
                                "Explica diferenças entre MT simples e MTMF em halting.",
                                "Aplica a múltiplas entradas teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão na simulação de transições (90%+ correto).",
                                "Detecção correta de halting vs. loop (sem falsos positivos).",
                                "Definição formal e precisa de L(M).",
                                "Uso adequado de configurações completas.",
                                "Explicações claras de verificações.",
                                "Eficiência na simulação (dentro de limites de passos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de grafos para detecção de ciclos.",
                                "Lógica: Estados e transições como autômatos finitos.",
                                "Programação: Simulação como algoritmo recursivo/debugging.",
                                "Algoritmos: Complexidade e decidibilidade.",
                                "Filosofia da Computação: Problema da Parada."
                              ],
                              "realWorldApplication": "Em verificadores de software e compiladores, simulações de MTMF ajudam a analisar terminância de programas; em IA, modela limites computacionais para tarefas de reconhecimento de padrões indecidíveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Equivalência Computacional de MTMF",
                        "description": "Demonstra que MT com múltiplas fitas têm o mesmo poder computacional que MT de fita única, via simulações mútuas, alinhando-se à Tese de Church-Turing.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Simular MT de fita única por MTMF",
                            "description": "Construir uma MTMF de 2 fitas que simula uma MT de fita única, usando uma fita para entrada/trabalho e outra auxiliar para cópias ou controle.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e analisar uma Máquina de Turing de fita única (MT1) exemplo",
                                  "subSteps": [
                                    "Escolha uma MT1 simples, como a que reconhece strings com número par de '0's em {0,1}* (estados: q0 inicial/par, q1 ímpar, qaccept, qreject; transição: em q0/q1 lê 0 inverte estado, lê 1 fica; fim em blank vai accept se par).",
                                    "Liste todos os componentes: conjunto de estados Q, alfabeto de fita Γ = {0,1,B}, alfabeto entrada Σ = {0,1}, função δ1, estado inicial q0, blanks B, estados finais.",
                                    "Desenhe a tabela de transições da MT1.",
                                    "Simule manualmente 2-3 entradas curtas (ex: 0 aceita? 00 aceita? 000 rejeita?).",
                                    "Identifique como a fita é usada para contagem."
                                  ],
                                  "verification": "Escreva um relatório curto descrevendo a MT1 e simulando uma entrada, confirmando se aceita/rejeita corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Referência: Sipser 'Introduction to the Theory of Computation' capítulo 3",
                                    "Simulador de MT online opcional"
                                  ],
                                  "tips": "Comece com uma MT1 muito simples para focar na simulação, não na complexidade da linguagem.",
                                  "learningObjective": "Dominar a estrutura formal de uma MT1 e simular sua execução manualmente.",
                                  "commonMistakes": [
                                    "Confundir alfabeto de entrada com alfabeto de fita.",
                                    "Esquecer de cercar a entrada com blanks.",
                                    "Não tratar o caso de fim de fita (blank)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os componentes formais da MTMF de 2 fitas",
                                  "subSteps": [
                                    "Defina Q_MTMF = Q da MT1 (mesmos estados), Γ_MTMF = Γ, Σ_MTMF = Σ, estado inicial q0, blanks B, estados finais iguais.",
                                    "Especifique 2 fitas: Fita 1 (entrada/trabalho), Fita 2 (auxiliar para controle/cópias, inicialmente blanks).",
                                    "Planeje que Fita 2 será mantida em blanks durante simulação, usada opcionalmente para verificação de integridade.",
                                    "Defina que transições atuam principalmente na Fita 1, com verificação em Fita 2.",
                                    "Adicione estados auxiliares se necessário para mover cabeçote 2 (ex: q_check2)."
                                  ],
                                  "verification": "Escreva a definição formal da MTMF em notação quadruplet ou quintuplet, listando Q, Γ, δ vazia por enquanto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para tabelas",
                                    "Notas da Step 1"
                                  ],
                                  "tips": "Mantenha Q idêntico à MT1 para simplicidade; expanda só se necessário para controle de cabeçote.",
                                  "learningObjective": "Mapear componentes de MT1 para MTMF, entendendo extensões para múltiplas fitas.",
                                  "commonMistakes": [
                                    "Alterar estados desnecessariamente.",
                                    "Ignorar que alfabeto é o mesmo para todas fitas.",
                                    "Esquecer cabeçotes independentes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar a inicialização e condições de segurança para Fita auxiliar",
                                  "subSteps": [
                                    "Coloque entrada w na Fita 1 como B w B... (cabeçote 1 na primeira célula).",
                                    "Inicialize Fita 2 toda B... (cabeçote 2 na primeira célula).",
                                    "Adicione transições iniciais para copiar entrada para Fita 2 (opcional para controle): mova cabeçotes sincronizados copiando símbolos até B.",
                                    "Implemente verificação: em todo passo, se símbolo em Fita 2 != B, vá para qreject.",
                                    "Garanta que cabeçote 2 fique em B escrevendo B sempre."
                                  ],
                                  "verification": "Desenhe diagramas das fitas iniciais para entrada exemplo '00' e após cópia opcional.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel milimetrado para desenhar fitas",
                                    "Marcadores coloridos para cabeçotes"
                                  ],
                                  "tips": "Use cores diferentes para Fita 1 e 2; desenhe fitas como linhas infinitas truncadas.",
                                  "learningObjective": "Configurar corretamente fitas múltiplas para simular ambiente de fita única.",
                                  "commonMistakes": [
                                    "Cabeçotes não alinhados inicialmente.",
                                    "Não tratar overflow ou símbolos inválidos em Fita 2.",
                                    "Esquecer de voltar cabeçote 2 após cópia."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a função de transição de simulação",
                                  "subSteps": [
                                    "Para cada δ1(q, σ1) = (p, τ1, D1): crie δ2(q, σ1, σ2) = (p, τ1, B, D1, S) se σ2 = B, senão reject.",
                                    "Se cópia usada, adicione estados de cópia inicial: de q0, copie símbolo por símbolo movendo ambos cabeçotes R, marque fim com $, volte cabeçotes para início.",
                                    "Expanda para casos onde controle usa Fita 2 (ex: escrever estado temporário em Fita 2 para pausar).",
                                    "Trate halting: se MT1 para, MTMF para nos mesmos estados.",
                                    "Preencha tabela completa de transições."
                                  ],
                                  "verification": "Simule 3 passos de uma execução na MTMF e confirme que imita exatamente a MT1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela em Excel ou papel para δ2 (estados x σ1 x σ2)",
                                    "Exemplos da Step 1"
                                  ],
                                  "tips": "Comece mapeando transições diretas; adicione verificação σ2=B como guarda.",
                                  "learningObjective": "Criar δ_MTMF que replica δ1 passo a passo, usando auxiliar para segurança.",
                                  "commonMistakes": [
                                    "Não verificar σ2 sempre.",
                                    "Direções erradas para cabeçote 2 (use S/stay).",
                                    "Perder sincronia entre simulação e original."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e testar a simulação completa",
                                  "subSteps": [
                                    "Execute simulação completa para 3 entradas: uma aceita, uma rejeitada, uma inválida.",
                                    "Compare traços de execução: confirme que Fita 1 final é idêntica à da MT1, Fita 2 permanece controlada (blanks ou cópia intacta).",
                                    "Analise uso da Fita 2: confirme controle (ex: detecção de erro se poluída).",
                                    "Generalize: explique como estender para qualquer MT1.",
                                    "Otimize: note quando Fita 2 é usada para cópias reais em simulações complexas."
                                  ],
                                  "verification": "Registre traços lado a lado (MT1 vs MTMF) para entradas testadas, sem discrepâncias.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulador ou desenhos manuais",
                                    "Tabelas anteriores"
                                  ],
                                  "tips": "Use setas para movimentos de cabeçotes; pause em cada configuração.",
                                  "learningObjective": "Validar que MTMF computa exatamente o mesmo que MT1, provando simulação.",
                                  "commonMistakes": [
                                    "Ignorar conteúdo final da Fita 2.",
                                    "Não testar casos de borda como entrada vazia.",
                                    "Confundir halting conditions."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a MT1 que aceita {0^{2n} | n >=0} (pares de 0s). Estados: q_even, q_odd, q_acc, q_rej. δ1(q_even,0)=(q_odd,B,R); δ1(q_odd,0)=(q_even,B,R); etc. Na MTMF: inicial Fita1=B00B..., Fita2=BB... Primeiro copie para Fita2 (usando estados copy1,copy2: leia Fita1, escreva em Fita2, R ambos até B, volte L). Então simule: em q_even leia σ1=0 σ2=B -> q_odd, escreva B em Fita1, B em Fita2, R cabeçote1, S cabeçote2. Para '00' aceita em q_even após scan, Fita2 tem cópia '00' para verificação opcional.",
                              "finalVerifications": [
                                "MTMF aceita exatamente as mesmas entradas que a MT1.",
                                "Durante toda execução, símbolos lidos em Fita 2 são sempre B (ou cópia verificada).",
                                "Configuração final das fitas: Fita 1 idêntica à simulação MT1, Fita 2 intacta ou com cópia.",
                                "Cabeçotes terminam em posições consistentes com halting da MT1.",
                                "Traços de execução coincidem passo a passo na Fita 1.",
                                "Nenhuma transição indefinida ou loop infinito em testes."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de transições (100% cobertura de δ1).",
                                "Correta inicialização e manutenção da Fita auxiliar.",
                                "Validação com pelo menos 3 exemplos concretos.",
                                "Explicação clara do papel da Fita 2 (controle/cópia).",
                                "Generalização para MT1 arbitrárias.",
                                "Ausência de erros comuns como movimentos incoerentes de cabeçotes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções parciais e relações de equivalência computacional.",
                                "Lógica e Provas: Construções de redução e simulação em teoria da computação.",
                                "Engenharia de Computação: Modelagem de memória distribuída (múltiplos buffers).",
                                "Algoritmos: Otimização via abstrações de máquina virtual."
                              ],
                              "realWorldApplication": "Essa simulação demonstra como computadores modernos usam múltiplos 'buffers' de memória (cache L1/L2, RAM) para simular computação sequencial eficiente, essencial em compiladores, VMs (como JVM) e sistemas distribuídos onde recursos são particionados sem perda de poder computacional."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Simular MTMF por MT de fita única",
                            "description": "Descrever a construção de uma MT de fita única que simula k fitas de uma MTMF, codificando todas as fitas em uma única fita com track encoding (ex.: símbolos compostos para cada posição).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Esquema de Encoding de Múltiplas Fitas em Uma Única Fita",
                                  "subSteps": [
                                    "Estude o conceito de track encoding: cada posição da fita única representa uma tupla de símbolos, um para cada fita da MTMF.",
                                    "Defina o alfabeto da fita única como o produto cartesiano dos alfabetos das fitas individuais (ex.: Γ^k para k fitas).",
                                    "Aprenda a representar símbolos especiais como '_ ' para espaços em branco em todas as tracks.",
                                    "Pratique codificando uma configuração inicial de uma MTMF com 2 fitas em uma fita única.",
                                    "Identifique como delimitadores ou marcadores podem separar tracks logicamente."
                                  ],
                                  "verification": "Codifique corretamente uma configuração exemplo de MTMF com 3 fitas em uma fita única e compare com a solução modelo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Papel e lápis para desenhos",
                                    "Editor de texto para diagramas ASCII"
                                  ],
                                  "tips": "Use símbolos compostos como (a,b,c) para visualizar tracks claramente antes de formalizar.",
                                  "learningObjective": "Compreender como mapear k fitas em uma única fita usando encoding de tracks.",
                                  "commonMistakes": [
                                    "Confundir ordem das tracks",
                                    "Esquecer de codificar cabeças de forma consistente",
                                    "Não tratar símbolos em branco uniformemente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar Posições e Movimentos das Cabeças de Leitura/Escrita",
                                  "subSteps": [
                                    "Codifique a posição atual das k cabeças usando marcadores especiais na fita única (ex.: setas ↑ em cada track).",
                                    "Defina como mover uma cabeça específica: simule movimentos L/R alterando a posição do marcador apenas naquela track.",
                                    "Gerencie movimentos independentes: a MT única move sua cabeça para acessar a posição relevante nas tracks.",
                                    "Implemente um 'modo de simulação' onde a MT única itera sobre as tracks para simular ações sequenciais.",
                                    "Desenhe diagramas de antes/depois para movimentos em uma MTMF de 2 fitas."
                                  ],
                                  "verification": "Desenhe e explique a fita única antes e depois de um movimento L na cabeça 1 e R na cabeça 2.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Diagramas de fitas impressos",
                                    "Software de desenho como Draw.io",
                                    "Exemplos de Sipser Capítulo 7"
                                  ],
                                  "tips": "Pense na fita única como uma 'zip' das fitas; movimentos requerem 'deszipar' logicamente.",
                                  "learningObjective": "Modelar posições e movimentos independentes de cabeças em uma estrutura linear única.",
                                  "commonMistakes": [
                                    "Mover todas as tracks simultaneamente",
                                    "Perder sincronia entre marcadores de cabeças",
                                    "Ignorar limites da fita"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Transições de Estado e Escrita nas Fitas Múltiplas",
                                  "subSteps": [
                                    "Leia o estado atual e símbolos sob todas as cabeças da fita única para formar a configuração de entrada da transição.",
                                    "Aplique a função de transição da MTMF: compute novos símbolos para cada fita e novo estado.",
                                    "Escreva os novos símbolos nas tracks correspondentes e mova os marcadores de cabeças conforme especificado.",
                                    "Gerencie estados da MT simuladora: use estados compostos (estado da MTMF + flags para simular cada fita).",
                                    "Teste com uma transição que escreve em uma fita e lê na outra."
                                  ],
                                  "verification": "Simule uma transição completa passo a passo para uma MTMF que copia de fita 1 para fita 2.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Pseudocódigo de MT",
                                    "Simulador de MT online (ex.: Turing Machine Simulator)",
                                    "Folhas de configuração de fita"
                                  ],
                                  "tips": "Divida transições em sub-rotinas: ler todas, computar, escrever todas.",
                                  "learningObjective": "Implementar lógica de transição que preserva o poder computacional da MTMF.",
                                  "commonMistakes": [
                                    "Aplicar transição sem ler todas as cabeças",
                                    "Sobrescrever tracks erradas",
                                    "Entrar em loop infinito por má gestão de estados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar Condição de Parada e Verificar Equivalência",
                                  "subSteps": [
                                    "Defina halting da MTMF: quando ela entra em estado halt, a MT única para após finalizar ações pendentes.",
                                    "Limpe marcadores de cabeças e retorne à configuração inicial decodificada se necessário.",
                                    "Prove informalmente que toda computação de MTMF pode ser simulada (universalidade).",
                                    "Discuta overhead: tempo quadrático O(n^2) devido a movimentos na fita única.",
                                    "Simule um exemplo completo de halting, como reconhecer {a^n b^n} com MTMF."
                                  ],
                                  "verification": "Execute simulação completa de uma MTMF que halta e decodifique a fita final corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Teorema de equivalência de Sipser",
                                    "Exemplos resolvidos de MTMF",
                                    "Ferramenta de simulação"
                                  ],
                                  "tips": "Sempre verifique se a simulação preserva aceitação/rejeição da MTMF.",
                                  "learningObjective": "Completar a simulação garantindo halting correto e equivalência computacional.",
                                  "commonMistakes": [
                                    "Não detectar halt da MTMF",
                                    "Deixar marcadores na fita final",
                                    "Ignorar complexidade temporal"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma MTMF com 2 fitas que soma dois números binários na fita 1 e armazena o resultado na fita 2. Codifique: fita única com tracks para binários e marcadores. Execute 5 passos de soma de '101 + 11 = 1000'.",
                              "finalVerifications": [
                                "Codificar/decodificar corretamente uma configuração de MTMF com 3 fitas.",
                                "Simular 10 transições sem erros de sincronia de cabeças.",
                                "Explicar por que a simulação preserva halting e aceitação.",
                                "Calcular overhead temporal para input de tamanho n.",
                                "Desenhar fita única para um exemplo de cópia entre fitas.",
                                "Provar que qualquer MTMF pode ser convertida em MT única."
                              ],
                              "assessmentCriteria": [
                                "Precisão no encoding de tracks e símbolos compostos (30%)",
                                "Correta simulação de movimentos independentes de cabeças (25%)",
                                "Implementação fiel de transições e halting (20%)",
                                "Análise de equivalência e complexidade (15%)",
                                "Clareza em diagramas e explicações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Similar a emulação de registradores em assembly.",
                                "Matemática: Produtos cartesianos e funções injetivas para encoding.",
                                "Engenharia de Software: Otimização de memória em simuladores.",
                                "Criptografia: Encoding de mensagens multi-canal em um fluxo."
                              ],
                              "realWorldApplication": "Em compiladores e interpretadores, simulações de MT múltiplas otimizam uso de memória em uma heap única; aplicações em hardware como GPUs com memória compartilhada simulando threads independentes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Provar equivalência de linguagens reconhecidas",
                            "description": "Argumentar formalmente que para toda MTMF M existe MT única M' tal que L(M) = L(M'), e vice-versa, preservando linguagens recursivamente enumeráveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições formais de MT e MTMF",
                                  "subSteps": [
                                    "Defina formalmente uma Máquina de Turing padrão (MT) com componentes: estados Q, alfabeto Γ, fita única, função de transição δ, estado inicial q0, branco B, estados de aceitação F e rejeição.",
                                    "Defina uma Máquina de Turing com Múltiplas Fitas (MTMF) com k fitas, cada uma com cabeçote independente, e função de transição δ: Q × Γ^k → Q × Γ^k × {L,R,S}^k.",
                                    "Compare as linguagens reconhecidas: L(M) para MT e L(M') para MTMF, focando em linguagens recursivamente enumeráveis (RE).",
                                    "Estabeleça que MT é caso especial de MTMF com k=1.",
                                    "Liste propriedades conhecidas: MT reconhece exatamente as linguagens RE."
                                  ],
                                  "verification": "Escreva as definições em notação formal e verifique se elas coincidem com referências padrão (ex: Sipser).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 7), anotações de aula, quadro branco"
                                  ],
                                  "tips": "Use diagramas para visualizar cabeçotes múltiplos vs. único.",
                                  "learningObjective": "Compreender precisamente as diferenças e semelhanças entre MT e MTMF.",
                                  "commonMistakes": "Confundir movimento de cabeçote (S para stay) ou ignorar estados de rejeição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar que toda MT é reconhecida por uma MTMF",
                                  "subSteps": [
                                    "Dada uma MT M, construa MTMF M' com k=1 fita, copiando exatamente a configuração de M.",
                                    "Mostre que δ' de M' replica δ de M, com movimentos idênticos.",
                                    "Argumente por indução sobre configurações que L(M) = L(M').",
                                    "Estenda para qualquer k>1 adicionando fitas ociosas.",
                                    "Verifique que M' preserva linguagens RE."
                                  ],
                                  "verification": "Simule uma entrada simples (ex: {a^n b^n}) em ambas e confirme aceitação/rejeição iguais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel para simulações manuais, software de simulação de TM como JFLAP"
                                  ],
                                  "tips": "Comece com k=1 para simplicidade antes de generalizar.",
                                  "learningObjective": "Demonstrar a inclusão trivial L(MT) ⊆ L(MTMF).",
                                  "commonMistakes": "Esquecer de mapear estados ou símbolos entre as máquinas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir simulação de MTMF em uma MT única",
                                  "subSteps": [
                                    "Dada MTMF M com k fitas, descreva a construção da MT M' com fita única dividida em pistas: pista de controle + k pistas de fita simuladas.",
                                    "Defina codificação: use símbolos Γ^k para representar tuplos de símbolos nas k fitas; posições dos cabeçotes em campo separado.",
                                    "Defina movimentos: simule transições δ lendo/escrevendo tuplos, atualizando posições de cabeçotes via varreduras lineares.",
                                    "Implemente rotina de varredura: mover cabeçote da MT para ler/escrever em posições remotas simuladas.",
                                    "Prove por indução que qualquer configuração de M corresponde a uma de M', preservando L(M) = L(M')."
                                  ],
                                  "verification": "Desenhe a transição para um exemplo com k=2 e uma entrada curta; execute 5 passos manualmente.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Quadro ou software de desenho (ex: Draw.io), exemplos de provas de Sipser"
                                  ],
                                  "tips": "Visualize a fita como 'bloco de pistas': controle | fita1 | fita2 | ...",
                                  "learningObjective": "Dominar a construção padrão de simulação multi-fita em mono-fita.",
                                  "commonMistakes": "Erro no gerenciamento de posições de cabeçotes durante varreduras; não tratar sobras de fita."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar prova bidirecional e discutir preservação de RE",
                                  "subSteps": [
                                    "Combine passos 2 e 3 para provar ∀ MTMF M ∃ MT M' tal que L(M)=L(M'), e vice-versa.",
                                    "Argumente unicidade no sentido de existência efetiva (construção determinística).",
                                    "Mostre que linguagens RE são preservadas: se L(M) RE, então L(M') RE.",
                                    "Discuta implicações: MTMF não aumenta classe de linguagens reconhecíveis.",
                                    "Formalize teorema: L(MT) = L(MTMF) = RE."
                                  ],
                                  "verification": "Escreva o teorema completo e esboce prova em 1 página; peer-review com colega.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Modelo de prova formal, LaTeX ou Word para redação"
                                  ],
                                  "tips": "Use seta dupla ↔ para equivalência e cite lemas intermediários.",
                                  "learningObjective": "Sintetizar prova completa de equivalência computacional.",
                                  "commonMistakes": "Afirmar unicidade literal (existem muitas M' equivalentes); ignorar direção reversa."
                                }
                              ],
                              "practicalExample": "Considere MTMF M com 2 fitas reconhecendo {a^n b^n | n≥0}: fita1 lê a's, fita2 conta b's. Construa MT M' com fita única: codifique como pistas (controle | a's/b's | contador). Simule: varra para ler a na pos1, escreva em pos2, marque contador; repita até mismatch.",
                              "finalVerifications": [
                                "A construção simula corretamente todas transições de MTMF em MT.",
                                "Indução prova preservação de configurações e linguagens.",
                                "Exemplo prático executa sem erros em simulação manual.",
                                "Prova cobre ambos sentidos (MT → MTMF e MTMF → MT).",
                                "Linguagens RE são preservadas em ambos os casos.",
                                "Teorema formal está claro e correto."
                              ],
                              "assessmentCriteria": [
                                "Correção formal da construção de simulação (sem falhas lógicas).",
                                "Clareza na descrição de pistas e varreduras na fita única.",
                                "Uso adequado de indução para prova de equivalência.",
                                "Tratamento completo da bidirecionalidade e unicidade existencial.",
                                "Profundidade nos subpassos e exemplos concretos.",
                                "Ausência de erros comuns como má gestão de cabeçotes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução e teoria dos conjuntos para linguagens RE.",
                                "Lógica: Argumentação formal e provas por construção.",
                                "Programação: Implementar simulador de TM em Python para validar.",
                                "Algoritmos: Otimizações multi-fita sem ganho computacional."
                              ],
                              "realWorldApplication": "Em compiladores e verificadores formais (ex: Coq, Isabelle), prova que extensões multi-fita não escapam limites RE; otimiza design de autômatos sem perda de poder, útil em análise de complexidade e teoremas de Rice."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Máquinas de Turing Não-Determinísticas",
                    "description": "Versão não-determinística da MT, com poder computacional equivalente à determinística.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Definição Formal da Máquina de Turing Não-Determinística (MTND)",
                        "description": "Compreensão da estrutura formal de uma MTND, incluindo seus componentes como estados, fita, cabeçote e função de transição não-determinística que permite múltiplas transições simultâneas para o mesmo símbolo lido.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Identificar os componentes de uma MTND",
                            "description": "Diferenciar e listar os elementos constitutivos de uma MTND: conjunto de estados Q, alfabeto de entrada Σ, alfabeto da fita Γ, função de transição δ: Q × Γ → P(Q × Γ × {L,R,N}), estados iniciais q0, espaço em branco B e estados de aceitação F.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal geral de Máquinas de Turing",
                                  "subSteps": [
                                    "Leia a definição padrão de uma MT determinística, identificando componentes comuns: Q, Σ, Γ, δ, q0, B, F.",
                                    "Anote as semelhanças entre MT e MTND para construir uma base sólida.",
                                    "Compare diagramaticamente os componentes em uma tabela simples.",
                                    "Estude exemplos básicos de MT para contextualizar.",
                                    "Resuma em suas palavras os papéis gerais de cada componente."
                                  ],
                                  "verification": "Crie uma tabela com os 7 componentes e suas descrições breves; revise se todos estão corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Teoria da Computação, notas de aula, quadro branco ou papel.",
                                  "tips": "Use mnemônicos como 'Q-Sigma-Gamma-Delta-q0-B-F' para memorizar a ordem.",
                                  "learningObjective": "Compreender os componentes fundamentais compartilhados entre MT e MTND.",
                                  "commonMistakes": "Confundir Σ (entrada) com Γ (fita, que inclui B); ignorar que Γ ⊇ Σ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar os componentes específicos da MTND",
                                  "subSteps": [
                                    "Foque na função de transição δ: explique como ela mapeia para P(Q × Γ × {L,R,N}), permitindo múltiplas transições.",
                                    "Liste e descreva Q (estados), Σ (alfabeto de entrada), Γ (alfabeto da fita), q0 (inicial), B (branco), F (aceitação).",
                                    "Desenhe um diagrama da δ não-determinística mostrando ramificações.",
                                    "Compare δ de MT (singular) vs MTND (potência).",
                                    "Escreva a assinatura formal exata de δ."
                                  ],
                                  "verification": "Escreva a definição completa de MTND e circule diferenças chave; confira com referência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Referência formal (ex: Sipser 'Introduction to the Theory of Computation'), editor de texto.",
                                  "tips": "Pense em δ como um 'menu de opções' em vez de uma escolha única.",
                                  "learningObjective": "Identificar precisamente o que torna a MTND não-determinística.",
                                  "commonMistakes": "Escrever δ como Q × Γ → Q × Γ × {L,R} (forma determinística); esquecer {N} para 'não mover'."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos de componentes em MTNDs definidas",
                                  "subSteps": [
                                    "Pegue um exemplo simples de MTND (ex: reconhecedor de {a^n b^n}).",
                                    "Extraia e rotule cada componente: Q, Σ, Γ, δ, q0, B, F.",
                                    "Trace uma transição não-determinística usando δ.",
                                    "Identifique como a não-determinística afeta aceitação.",
                                    "Crie sua própria lista anotada dos componentes."
                                  ],
                                  "verification": "Preencha um template de MTND com componentes corretamente identificados de um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos de MTND de tutoriais online ou livro, papel para diagramas.",
                                  "tips": "Use cores diferentes para cada componente ao rotular.",
                                  "learningObjective": "Aplicar identificação de componentes em contextos concretos.",
                                  "commonMistakes": "Omitir estados iniciais múltiplos (permitidos em algumas definições); confundir q0 com F."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e verificar identificação independente",
                                  "subSteps": [
                                    "Receba uma definição formal de MTND e liste os 7 componentes.",
                                    "Crie flashcards com cada componente e sua descrição.",
                                    "Explique verbalmente ou por escrito a função de cada um.",
                                    "Simule uma 'caça ao tesouro' em textos acadêmicos para componentes.",
                                    "Autoavalie com perguntas de quiz."
                                  ],
                                  "verification": "Responda a 5 perguntas de identificação sem consultar notas; acerte 100%.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Flashcards digitais (Anki), quiz online ou auto-gerado.",
                                  "tips": "Pratique com definições variadas para generalizar.",
                                  "learningObjective": "Dominar a listagem e diferenciação fluida dos componentes.",
                                  "commonMistakes": "Listar componentes errados como 'direção de movimento' isolada (está em δ)."
                                }
                              ],
                              "practicalExample": "Considere uma MTND que aceita linguagens par-impar de a's: Q = {q0, q1, qf}, Σ = {a}, Γ = {a, B}, B = B, q0 inicial, F = {qf}, δ(q0, a) = {(q1, a, R), (q0, B, R)} permitindo ramificações para contar paridade não-determinísticamente.",
                              "finalVerifications": [
                                "Liste corretamente os 7 componentes sem hesitação.",
                                "Explique a assinatura exata de δ para MTND.",
                                "Diferencie Γ de Σ com exemplos.",
                                "Identifique q0, B e F em uma definição dada.",
                                "Descreva o papel da não-determinística em δ.",
                                "Trace uma transição múltipla corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem de todos os componentes (100% correto).",
                                "Descrição clara e formal de δ, incluindo P(...) e {L,R,N}.",
                                "Diferenciação correta entre componentes semelhantes (ex: Σ vs Γ).",
                                "Uso correto de notação matemática.",
                                "Compreensão demonstrada via exemplo prático.",
                                "Ausência de confusões com MT determinística."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (P(Q × Γ × {L,R,N})).",
                                "Lógica: Não-determinismo similar a busca em árvores de decisão.",
                                "Filosofia da Computação: Limites da computabilidade.",
                                "Programação: Simulação de não-determinismo em backtracking."
                              ],
                              "realWorldApplication": "Em algoritmos de otimização e IA, MTNDs modelam buscas paralelas não-determinísticas, simuladas em computadores determinísticos para resolver problemas NP como planejamento de rotas ou verificação de software."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Escrever a notação formal de uma MTND",
                            "description": "Formalizar uma MTND usando a tupla (Q, Σ, Γ, δ, q0, B, F), destacando como δ produz subconjuntos de possíveis movimentos, permitindo ramificações na computação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes fundamentais da tupla de uma MTND",
                                  "subSteps": [
                                    "Relembrar a tupla de uma MTD: (Q, Σ, Γ, δ, q0, B, F) e identificar que o não-determinismo afeta apenas δ.",
                                    "Listar e descrever cada componente: Q (estados), Σ (alfabeto de entrada), Γ (alfabeto da fita), δ (transição), q0 (estado inicial), B (símbolo em branco), F (estados finais).",
                                    "Explicar o papel do não-determinismo: múltiplas transições possíveis por configuração.",
                                    "Estudar diagramas de MTND para visualizar ramificações.",
                                    "Comparar com autômatos finitos não-determinísticos (AFND) para analogia."
                                  ],
                                  "verification": "Escreva uma tabela resumindo os 7 componentes com suas descrições e tipos matemáticos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 7)",
                                    "Notas de aula sobre Máquinas de Turing",
                                    "Vídeo Khan Academy ou YouTube sobre MTND"
                                  ],
                                  "tips": "Use a mnemônica 'QΣΓδqBF' para memorizar a ordem exata da tupla.",
                                  "learningObjective": "Identificar e descrever precisamente os sete componentes da tupla formal de uma MTND.",
                                  "commonMistakes": [
                                    "Confundir Σ (entrada) com Γ (fita completa)",
                                    "Esquecer que B ∈ Γ mas não necessariamente em Σ",
                                    "Achar que F inclui q0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os conjuntos e elementos fixos da tupla",
                                  "subSteps": [
                                    "Definir Q como conjunto finito de estados, ex: Q = {q0, q1, qaccept, qreject}.",
                                    "Especificar Σ como alfabeto de entrada finito, ex: Σ = {0,1}.",
                                    "Estender para Γ = Σ ∪ {B}, onde B é o símbolo em branco.",
                                    "Escolher q0 ∈ Q como estado inicial único.",
                                    "Selecionar F ⊆ Q como subconjunto de estados de aceitação.",
                                    "Verificar consistência: q0 ∉ F tipicamente, B ∉ Σ."
                                  ],
                                  "verification": "Escreva definições formais para Q, Σ, Γ, q0, B, F com exemplos concretos para uma linguagem simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para esboços",
                                    "Editor de texto para anotações LaTeX",
                                    "Exemplos de currículo sobre linguagens regulares"
                                  ],
                                  "tips": "Sempre inclua B explicitamente em Γ para evitar ambiguidades.",
                                  "learningObjective": "Formalizar os componentes não-transicionais da tupla com notação matemática precisa.",
                                  "commonMistakes": [
                                    "Incluir B em Σ",
                                    "Definir Q como infinito",
                                    "Permitir múltiplos q0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a função de transição δ para não-determinismo",
                                  "subSteps": [
                                    "Definir o domínio: δ: Q × Γ → P(Q × Γ × {L, R}), onde P é o conjunto potências (power set).",
                                    "Explicar que δ produz subconjuntos finitos de movimentos possíveis, permitindo ramificações.",
                                    "Escrever exemplos: δ(q, a) = {(p1, b, R), (p2, c, L)} para duas transições.",
                                    "Discutir computação por branches: uma configuração gera múltiplas sucessoras.",
                                    "Comparar com MTD: δ: Q × Γ → Q × Γ × {L, R} (singleton).",
                                    "Verificar que δ(q, B) é definida para todos q ∈ Q, símbolos em Γ."
                                  ],
                                  "verification": "Escreva δ formal para um exemplo simples com pelo menos duas ramificações não-determinísticas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta JFLAP para simular MTND",
                                    "Folha de papel quadriculado para tabelas de transição",
                                    "Referência: Hopcroft & Ullman Teoria da Computação"
                                  ],
                                  "tips": "Represente δ como uma tabela ou conjunto de pares para clareza visual.",
                                  "learningObjective": "Dominar a notação de δ que captura o não-determinismo via power set.",
                                  "commonMistakes": [
                                    "Usar função determinística em vez de power set",
                                    "Esquecer direções L/R",
                                    "Definir δ para símbolos fora de Γ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e escrever a notação formal completa da tupla MTND",
                                  "subSteps": [
                                    "Reunir todos componentes em ordem: (Q, Σ, Γ, δ, q0, B, F).",
                                    "Escrever a tupla completa usando notação matemática precisa.",
                                    "Validar: δ mapeia corretamente para subconjuntos não-vazios onde aplicável.",
                                    "Testar com uma configuração inicial: (q0, símbolo inicial).",
                                    "Documentar em LaTeX ou texto formatado para precisão.",
                                    "Simular uma computação curta para verificar aceitação."
                                  ],
                                  "verification": "Produza a tupla formal completa e simule 2-3 passos de uma computação ramificada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor LaTeX (Overleaf)",
                                    "Simulador online de Máquinas de Turing",
                                    "Exemplo resolvido de MTND para {a^n b^n}"
                                  ],
                                  "tips": "Use parênteses e vírgulas estritamente para evitar ambiguidades na tupla.",
                                  "learningObjective": "Construir e notate uma tupla MTND completa e válida.",
                                  "commonMistakes": [
                                    "Ordem errada dos componentes",
                                    "δ vazia para algum input",
                                    "Inconsistência entre Γ e símbolos em δ"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a MTND que aceita {0^n 1^n | n ≥ 0}: Q = {q0, q1, qacc, qrej}, Σ = {0,1}, Γ = {0,1,B}, q0 (inicial), B (blank), F = {qacc}, δ(q0,0) = {(q1,B,R)}, δ(q1,0) = {(q1,0,R)}, δ(q1,1) = {(q0,B,L)}, etc., com ramificações para rejeição.",
                              "finalVerifications": [
                                "Tupla possui exatamente 7 componentes na ordem (Q, Σ, Γ, δ, q0, B, F).",
                                "δ: Q × Γ → P(Q × Γ × {L,R}) com subconjuntos não-vazios onde definido.",
                                "q0 ∈ Q, F ⊆ Q, B ∈ Γ \\ Σ.",
                                "Todos símbolos em δ pertencem a Γ.",
                                "Exemplo de computação ramificada leva a aceitação ou rejeição corretas.",
                                "Notação matemática é precisa e legível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de δ (captura não-determinismo via power set): 30%",
                                "Correção e consistência de todos componentes da tupla: 25%",
                                "Clareza na escrita formal e uso de notação matemática: 20%",
                                "Explicação de ramificações e exemplo prático: 15%",
                                "Ausência de erros comuns (ex: ordem errada, símbolos inconsistentes): 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (power sets e funções para potências)",
                                "Lógica: Não-determinismo e ramificação em provas e deduções",
                                "Algoritmos: Modelagem de busca paralela em problemas NP-completos",
                                "Filosofia da Computação: Limites da computação determinística vs. não-determinística"
                              ],
                              "realWorldApplication": "Modelar algoritmos de otimização não-determinísticos em IA, como em solvers para problemas NP (ex: SAT solvers que exploram branches paralelas em hardware multi-core ou computação quântica simulada)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Construir um exemplo simples de MTND",
                            "description": "Criar uma MTND que reconheça uma linguagem simples, como {a^n b^n | n ≥ 0}, ilustrando múltiplas transições possíveis a partir de um estado e símbolo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal de MTND e definir componentes básicos",
                                  "subSteps": [
                                    "Estude a definição formal de MTND: (Q, Σ, Γ, δ, q0, B, F).",
                                    "Defina Σ = {a, b}, Γ = {a, b, B}, B = branco.",
                                    "Escolha estados iniciais: q0 (inicial), q1 (contando a's), q_reject, q_accept.",
                                    "Especifique q0 como estado inicial e F = {q_accept}.",
                                    "Liste todos os componentes em uma tabela ou estrutura organizada."
                                  ],
                                  "verification": "Confirme que todos os 7 componentes estão definidos corretamente sem erros tipográficos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referência à definição formal de MTND"
                                  ],
                                  "tips": [
                                    "Use notação padrão para evitar confusões futuras.",
                                    "Comece com o mínimo de estados possível."
                                  ],
                                  "learningObjective": "Compreender e aplicar a estrutura formal de uma MTND.",
                                  "commonMistakes": [
                                    "Confundir Σ com Γ.",
                                    "Esquecer o blank symbol B.",
                                    "Definir F vazio."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar transições determinísticas iniciais para ler os símbolos 'a'",
                                  "subSteps": [
                                    "Em q0 lendo 'a', transite para q1 escrevendo 'a' e movendo direita (R).",
                                    "Em q1 lendo 'a', transite para q1 escrevendo 'a' e movendo R (loop para múltiplos a's).",
                                    "Em q0 lendo 'b', vá para q_reject (linguagem começa com a's).",
                                    "Em q1 lendo 'B', prepare para não-determinismo: transite para um estado intermediário.",
                                    "Registre todas as transições em formato δ(q, símbolo) = conjunto de (novo_q, escrever, direção)."
                                  ],
                                  "verification": "Simule manualmente a leitura de 'aaabbb' até o fim dos a's e confirme posicionamento correto na fita.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fita simulada em papel ou ferramenta online como JFLAP",
                                    "Tabela de transições vazia"
                                  ],
                                  "tips": [
                                    "Sempre especifique direção (L/R/N) explicitamente.",
                                    "Teste com n=0 (fita vazia)."
                                  ],
                                  "learningObjective": "Construir transições básicas para sequências prefixadas.",
                                  "commonMistakes": [
                                    "Não mover a cabeça corretamente após escrever.",
                                    "Loop infinito em q1 sem condição de saída.",
                                    "Ignorar casos n=0 ou n=1."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir não-determinismo para matching de 'b's com os 'a's contados",
                                  "subSteps": [
                                    "De q1 lendo 'b', defina duas transições não-determinísticas: uma para q2 (match b, mover L para apagar 'a'), outra para q_reject.",
                                    "Em q2 lendo 'a', apague 'a' (escreva B), mova L para próximo 'a', transite para q1_match.",
                                    "Em q1_match lendo 'b', continue matching: apague 'b', mova R para próximo.",
                                    "Em q1_match lendo 'B' após último 'a', transite para q_accept se alinhado.",
                                    "Adicione rejeição se mismatch (ex: mais b's que a's)."
                                  ],
                                  "verification": "Execute ramificações não-determinísticas em um exemplo como 'aabbb' e veja se uma leva à aceitação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de MTND ou desenho de árvore de computação",
                                    "Exemplos de fita: aabb, aaab, ab"
                                  ],
                                  "tips": [
                                    "Visualize como 'adivinhação' do número de b's.",
                                    "Garanta simetria no apagamento para evitar loops."
                                  ],
                                  "learningObjective": "Implementar branches não-determinísticos para reconhecimento de linguagem.",
                                  "commonMistakes": [
                                    "Transições só determinísticas (perde não-det).",
                                    "Não apagar símbolos para evitar reutilização.",
                                    "Falta de rejeição em branches erradas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar a MTND, testar e representar formalmente",
                                  "subSteps": [
                                    "Defina transições de q_accept e q_reject como halt.",
                                    "Teste com casos: n=0 (aceita), n=1 (ab aceita), n=2 (aabb aceita), mismatch (aab aceita? não).",
                                    "Escreva a função δ completa como conjunto de 5-tuplas.",
                                    "Desenhe o diagrama de estados com setas múltiplas para não-det.",
                                    "Documente todas as computações aceitantes/rejeitantes."
                                  ],
                                  "verification": "Todos os testes passam: aceita exatamente {a^n b^n | n≥0}, rejeita outros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io ou papel",
                                    "Lista de strings de teste"
                                  ],
                                  "tips": [
                                    "Use cores para branches aceitantes vs rejeitantes.",
                                    "Verifique halting em todos os caminhos."
                                  ],
                                  "learningObjective": "Validar e representar uma MTND completa.",
                                  "commonMistakes": [
                                    "Não haltar em reject.",
                                    "Aceitar strings inválidas como 'aaa'.",
                                    "Diagrama sem múltiplas setas."
                                  ]
                                }
                              ],
                              "practicalExample": "MTND para {a^n b^n | n≥0}: Q={q0,q1,q2,q_reject,q_accept}, Σ={a,b}, Γ={a,b,B}, δ(q1,b)={(q2,B,R),(q_reject,B,N)} para não-det; matching apaga a's e b's alternadamente até B em ambos lados, aceitando se sincronizado.",
                              "finalVerifications": [
                                "A MTND aceita 'ε', 'ab', 'aabb' mas rejeita 'aab', 'abbb', 'ba'.",
                                "δ tem pelo menos uma transição múltipla de um (q,símbolo).",
                                "Estados Finais só acessíveis após matching exato.",
                                "Todas transições haltam (aceita ou rejeita).",
                                "Representação formal inclui todos 7 componentes.",
                                "Simulação manual de 3 strings diferentes funciona."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (todos componentes corretos): 25%",
                                "Correta implementação de não-determinismo (múltiplas transições): 25%",
                                "Validação com testes (aceita/rejeita corretamente): 20%",
                                "Clareza na representação (diagrama/tabela legível): 15%",
                                "Explicação de como o não-det resolve o matching: 10%",
                                "Ausência de erros comuns (loops infinitos, halting): 5%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e relações em linguagens formais.",
                                "Lógica: Não-determinismo similar a provas não-construtivas.",
                                "Programação: Paralelismo e backtracking em algoritmos de busca.",
                                "Física: Modelagem de sistemas quânticos com superposição (análoga a não-det)."
                              ],
                              "realWorldApplication": "Modelagem de algoritmos de otimização não-determinísticos, como em inteligência artificial para exploração de espaços de busca paralelos (ex: planejamento de rotas com incertezas ou simulações quânticas aproximadas)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Comportamento e Aceitação em MTND",
                        "description": "Análise do funcionamento não-determinístico, incluindo configurações, ramificações de computação e critérios de aceitação por existência de pelo menos um caminho aceitador.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Descrever uma configuração de MTND",
                            "description": "Definir configuração como (q, u, v), onde q é o estado atual, u a porção esquerda da fita e v a porção direita incluindo o símbolo sob o cabeçote, e explicar sucessão de configurações via δ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes de uma configuração de MTND",
                                  "subSteps": [
                                    "Estude a definição formal de configuração: (q, u, v), onde q é o estado atual.",
                                    "Identifique u como a porção da fita à esquerda do cabeçote (sem o símbolo atual).",
                                    "Explique v como a porção à direita, incluindo o símbolo sob o cabeçote.",
                                    "Revise a fita infinita em branco fora dos símbolos relevantes.",
                                    "Diferencie configuração de MT determinística e não-determinística."
                                  ],
                                  "verification": "Liste e defina corretamente q, u e v com um exemplo simples de fita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Definição formal de MTND",
                                    "Diagrama de fita de Turing",
                                    "Exemplo básico de configuração"
                                  ],
                                  "tips": "Visualize a fita como uma linha infinita com o cabeçote apontando para um símbolo em v.",
                                  "learningObjective": "Identificar e explicar cada componente de uma configuração de MTND.",
                                  "commonMistakes": [
                                    "Incluir o símbolo sob o cabeçote em u",
                                    "Confundir ordem de u e v",
                                    "Ignorar que v inclui o símbolo atual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar uma configuração inicial de MTND",
                                  "subSteps": [
                                    "Escolha uma palavra de entrada w e estado inicial q0.",
                                    "Forme a configuração inicial: (q0, ε, w), onde ε é a fita vazia à esquerda.",
                                    "Desenhe a fita mostrando u=ε e v=w.",
                                    "Anote símbolos de fita Γ e alfabeto de entrada Σ.",
                                    "Pratique com uma palavra curta, como 'ab'."
                                  ],
                                  "verification": "Escreva a configuração inicial para w = 'aab' em (q0, ε, aab).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhar fita",
                                    "Exemplos de palavras de entrada"
                                  ],
                                  "tips": "Sempre comece com u vazio na configuração inicial.",
                                  "learningObjective": "Construir a notação (q, u, v) para configurações iniciais.",
                                  "commonMistakes": [
                                    "Colocar símbolos à esquerda em configurações iniciais",
                                    "Esquecer o estado q0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a função de transição δ para sucessão",
                                  "subSteps": [
                                    "Revise δ: δ(q, σ) = conjunto de (p, γ, D) para MTND.",
                                    "Extraia o símbolo atual de v (primeiro símbolo).",
                                    "Escolha uma transição não-determinística de δ(q, σ).",
                                    "Atualize: novo q = p, substitua símbolo por γ, mova cabeçote por D (L/R/N).",
                                    "Forme nova configuração: ajuste u e v conforme movimento."
                                  ],
                                  "verification": "Dada (q, u, σw'), aplique δ e escreva a próxima configuração.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de transição δ de uma MTND simples",
                                    "Simulador de Turing online"
                                  ],
                                  "tips": "Liste todas as branches não-determinísticas se houver múltiplas.",
                                  "learningObjective": "Executar uma transição δ e gerar a configuração sucessora.",
                                  "commonMistakes": [
                                    "Não atualizar u/v corretamente no movimento L/R",
                                    "Ignorar múltiplas escolhas em δ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever uma sucessão completa de configurações",
                                  "subSteps": [
                                    "Inicie com configuração inicial (q0, ε, w).",
                                    "Aplique δ sequencialmente para 3-5 passos, ramificando se não-determinístico.",
                                    "Descreva a sucessão como C1 → C2 → C3, destacando mudanças.",
                                    "Identifique configuração de aceitação (q_acc, *, *) ou rejeição.",
                                    "Explique por que a sucessão leva à aceitação/rejeição."
                                  ],
                                  "verification": "Descreva sucessão de 4 configurações para uma MTND simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo completo de MTND para {a^n b^n}",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Use setas → para mostrar sucessão e numere cada configuração.",
                                  "learningObjective": "Narrar o comportamento de uma MTND via sucessão de configurações.",
                                  "commonMistakes": [
                                    "Perder ramificações não-determinísticas",
                                    "Erro na concatenação u + v"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere MTND M que aceita {ww | w em {a,b}*}: Configuração inicial C1 = (q0, ε, abab). δ(q0, a) inclui (q1, X, R), então C2 = (q1, a, Xbab) [substitui a por X, move R]. Próxima: δ(q1, b) → (q2, Y, L), C3 = (q2, aX, bYab), e assim por diante, até verificar se segunda metade espelha a primeira.",
                              "finalVerifications": [
                                "Descreva corretamente (q, u, v) para uma configuração dada.",
                                "Aplique δ e gere a configuração sucessora sem erros.",
                                "Liste uma sucessão de 3 configurações para entrada 'aa'.",
                                "Explique diferenças entre configuração inicial e final.",
                                "Identifique configuração de aceitação.",
                                "Diferencie MTND de MTD em termos de sucessão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação (q, u, v) com u à esquerda e v à direita incluindo símbolo atual.",
                                "Correta aplicação de δ, incluindo não-determinismo.",
                                "Clareza na descrição de sucessão com setas e numeração.",
                                "Explicação completa de componentes e mudanças na fita/estado.",
                                "Identificação correta de aceitação/rejeição.",
                                "Uso apropriado de símbolos Γ e movimentos L/R/N."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de estados como tuplas e funções parciais (δ).",
                                "Lógica Formal: Transições como regras de inferência em sistemas dedutivos.",
                                "Algoritmos: Modelagem de não-determinismo em buscas paralelas.",
                                "Física Computacional: Simulação de processos quânticos não-determinísticos."
                              ],
                              "realWorldApplication": "Em verificação de software e modelagem de sistemas concorrentes, descrições de configurações de MTND ajudam a simular explorações paralelas de caminhos computacionais, como em ferramentas de model checking (ex: SPIN) ou otimização em IA com múltiplas hipóteses."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Explicar aceitação por não-determinismo",
                            "description": "Definir que uma entrada w é aceita se existe pelo menos uma sequência de transições que leva a um estado de aceitação, com todas as fitas vazias ou em estado de rejeição para outros ramos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Máquinas de Turing Não-Determinísticas (MTND)",
                                  "subSteps": [
                                    "Relembre a estrutura de uma MTND: fita infinita, cabeçote, estados, função de transição não-determinística (pode ter múltiplas transições para o mesmo input).",
                                    "Desenhe um diagrama simples de uma MTND com pelo menos uma transição não-determinística.",
                                    "Compare brevemente com MT determinística: uma vs múltiplas escolhas.",
                                    "Identifique componentes chave: estados de aceitação (q_accept), rejeição (q_reject) e halting.",
                                    "Liste as condições de halting: estado de aceitação/rejeição ou fitas vazias."
                                  ],
                                  "verification": "Crie um diagrama anotado de uma MTND simples e explique verbalmente ou por escrito as diferenças com MTD.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou software de diagramação (ex: Draw.io), notas de aula sobre MTND.",
                                  "tips": "Use setas ramificadas no diagrama para visualizar não-determinismo claramente.",
                                  "learningObjective": "Compreender a estrutura e o comportamento básico de uma MTND.",
                                  "commonMistakes": "Confundir não-determinismo com aleatoriedade; não-determinismo é 'existe caminho', não probabilístico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Aceitação em Máquinas de Turing",
                                  "subSteps": [
                                    "Defina aceitação em MTD: única computação termina em estado de aceitação com fita vazia.",
                                    "Estenda para MTND: uma entrada w é aceita se HÁ PELO MENOS UMA sequência de transições que leva a q_accept com todas as fitas vazias.",
                                    "Explique rejeição: rejeitada só se TODAS as ramificações possíveis terminam em q_reject ou loop infinito.",
                                    "Discuta halting: computação para quando atinge q_accept/q_reject ou fita vazia.",
                                    "Escreva formalmente: M aceita w se ∃ computação válida terminando em aceitação."
                                  ],
                                  "verification": "Escreva definições formais para aceitação e rejeição em MTND e compare com MTD em uma tabela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de papel para tabela comparativa, pseudocódigo ou notação formal.",
                                  "tips": "Use quantificadores lógicos: ∃ para aceitação (existe), ∀ para rejeição (todas).",
                                  "learningObjective": "Diferenciar formalmente aceitação entre MTD e MTND.",
                                  "commonMistakes": "Pensar que MTND aceita se 'qualquer' ramo aceita sem considerar halting completo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Papel do Não-Determinismo na Aceitação",
                                  "subSteps": [
                                    "Simule uma transição não-determinística: de um estado, liste múltiplas próximas configurações.",
                                    "Trace um 'árvore de computação' para uma entrada w simples, mostrando ramificações.",
                                    "Identifique: se um ramo atinge q_accept com fitas vazias, w é aceita, ignorando outros ramos.",
                                    "Discuta poder computacional: MTND = MTD, mas não-determinismo simplifica design.",
                                    "Aborde loops: se um ramo loopa infinitamente, não conta como aceitação."
                                  ],
                                  "verification": "Construa e trace uma árvore de computação para uma MTND simples, marcando ramos aceitadores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulador de MT online (ex: Turing Machine Simulator) ou papel para árvore.",
                                  "tips": "Comece com entrada curta como '11' para linguagem {ww | w em {0,1}*}.",
                                  "learningObjective": "Visualizar como não-determinismo permite 'escolha existencial' para aceitação.",
                                  "commonMistakes": "Ignorar condição de fitas vazias; aceitação requer halting limpo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Formalizar Condições de Aceitação Completa",
                                  "subSteps": [
                                    "Liste condições exatas: q_accept + todas fitas vazias (sem símbolos residuais).",
                                    "Explique rejeição por exaustão: todos ramos terminam em q_reject ou não halting.",
                                    "Formalize em pseudocódigo: função accept(w) retorna true se ∃ path to accept.",
                                    "Discuta implicações: simulador determinístico pode decidir aceitação via busca em largura.",
                                    "Resuma diferenças chave em bullet points."
                                  ],
                                  "verification": "Redija uma definição completa de aceitação por não-determinismo em 1 parágrafo e valide com exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto, exemplo de MTND salvo do step anterior.",
                                  "tips": "Memorize: 'Aceita se existe um caminho vencedor; rejeita só se todos perdem'.",
                                  "learningObjective": "Articular precisamente as regras de aceitação e rejeição em MTND.",
                                  "commonMistakes": "Confundir 'fitas vazias' com 'cabeçote parado'; ambas condições importam."
                                }
                              ],
                              "practicalExample": "Considere MTND M que aceita {0^n 1^n | n ≥ 0}. Em w = '0011', uma ramificação não-determinística adivinha o meio: move cabeçote direito para combinar 0s e 1s, alcançando q_accept com fitas vazias. Outros ramos rejeitam, mas como ∃ um aceitador, w é aceita.",
                              "finalVerifications": [
                                "Pode definir aceitação: ∃ sequência para q_accept com fitas vazias.",
                                "Explica rejeição: todos ramos rejeitam ou não halta.",
                                "Trace corretamente uma árvore de computação simples.",
                                "Diferencia MTD (único caminho) vs MTND (existe caminho).",
                                "Identifica erros comuns como ignorar fitas vazias.",
                                "Formaliza em notação lógica (∃, ∀)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de aceitação (obrigatório halting em q_accept).",
                                "Correta representação de não-determinismo como 'escolha existencial'.",
                                "Uso apropriado de exemplos com ramificações múltiplas.",
                                "Distinção clara entre aceitação, rejeição e não-halting.",
                                "Capacidade de simular e verificar computações manualmente.",
                                "Conexão com equivalência computacional MTND = MTD."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Teoria dos Conjuntos: quantificadores ∃ e ∀ em provas de aceitação.",
                                "Algoritmos e Estruturas de Dados: busca em grafos não-determinística (BFS para simulação).",
                                "Probabilidade: analogia com caminhos probabilísticos (PP vs NP).",
                                "Filosofia da Computação: limites da 'adivinhação' não-determinística."
                              ],
                              "realWorldApplication": "Em verificadores de software e compiladores, não-determinismo modela backtracking em parsers (ex: YACC); em IA, simula busca heurística onde 'existe solução' é priorizado, como em algoritmos genéticos ou planejamento de caminhos paralelos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Simular uma execução não-determinística",
                            "description": "Traçar manualmente todas as ramificações possíveis de uma MTND em uma entrada curta, identificando caminhos aceitadores e rejeitadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a definição da Máquina de Turing Não-Determinística (MTND)",
                                  "subSteps": [
                                    "Identificar os componentes: estados Q, alfabeto de fita Γ, alfabeto de entrada Σ, função de transição δ, estado inicial q0, espaços em branco B, estados finais F e rejeição R.",
                                    "Desenhar o diagrama de estados e transições, destacando transições não-determinísticas (mais de uma transição possível para o mesmo estado, símbolo e direção).",
                                    "Listar todas as transições não-determinísticas explicitamente.",
                                    "Verificar se a MTND está completa e bem-formada.",
                                    "Anotar o comprimento da entrada para estimar o número de ramificações."
                                  ],
                                  "verification": "Diagrama desenhado com todas as transições listadas e não-determinismos destacados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis, borracha, definição da MTND impressa ou digital.",
                                  "tips": "Use cores diferentes para transições determinísticas e não-determinísticas para facilitar a visualização.",
                                  "learningObjective": "Compreender a estrutura formal de uma MTND e identificar pontos de não-determinismo.",
                                  "commonMistakes": "Ignorar transições para espaços em branco ou assumir determinismo onde não há."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a configuração inicial da fita e cabeçote",
                                  "subSteps": [
                                    "Escrever a entrada na fita, com espaços em branco nas extremidades.",
                                    "Posicionar o cabeçote na primeira célula da entrada (estado q0).",
                                    "Representar a configuração inicial como: estado + posição do cabeçote + conteúdo da fita.",
                                    "Preparar um 'árvore de configurações' com o nó raiz como configuração inicial.",
                                    "Validar que a configuração inicial está correta conforme a definição."
                                  ],
                                  "verification": "Configuração inicial anotada corretamente e árvore iniciada com nó raiz.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, lápis, exemplo de fita impresso.",
                                  "tips": "Use notação compacta para a fita, como _aabb_ com seta no cabeçote.",
                                  "learningObjective": "Representar configurações de MTND de forma padronizada.",
                                  "commonMistakes": "Posicionar o cabeçote errado ou esquecer espaços em branco infinitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar ramificações não-determinísticas passo a passo",
                                  "subSteps": [
                                    "Para cada configuração atual, aplicar δ e gerar todas as configurações sucessoras possíveis.",
                                    "Desenhar branches na árvore para cada transição não-determinística.",
                                    "Avançar simultaneamente em todas as branches, registrando mudanças na fita, estado e posição.",
                                    "Detectar loops ou halts parciais (aceitação/rejeição) em branches individuais.",
                                    "Manter um contador de passos para cada branch para evitar loops infinitos em simulações manuais."
                                  ],
                                  "verification": "Árvore de configurações expandida até o primeiro nível de halt em todas as branches ativas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel grande para árvore, marcadores coloridos.",
                                  "tips": "Priorize branches curtas primeiro para eficiência; use abreviações para fitas longas.",
                                  "learningObjective": "Simular branching não-determinístico manualmente.",
                                  "commonMistakes": "Perder uma branch ou aplicar transição errada em ramificações múltiplas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Traçar todos os caminhos completos e classificar",
                                  "subSteps": [
                                    "Continuar expandindo a árvore até que todas as folhas sejam configurações de halt (aceitação, rejeição ou loop detectado).",
                                    "Para cada caminho da raiz às folhas, anotar o resultado final.",
                                    "Classificar caminhos como aceitadores (atinge F), rejeitadores (atinge R) ou não-halting (loops).",
                                    "Verificar se a MTND aceita a entrada (existe pelo menos um caminho aceitador).",
                                    "Resumir: número de caminhos aceitadores, rejeitadores e não-halting."
                                  ],
                                  "verification": "Árvore completa com todos os caminhos classificados e resumo anotado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Árvore anterior, papel para resumo.",
                                  "tips": "Marque loops com um símbolo especial para não expandir infinitamente.",
                                  "learningObjective": "Identificar e classificar todos os caminhos de execução em MTND.",
                                  "commonMistakes": "Classificar incorretamente halts ou ignorar caminhos não-halting."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e documentar a simulação completa",
                                  "subSteps": [
                                    "Revisar cada branch para erros de transição ou configuração.",
                                    "Confirmar que todos os não-determinismos foram explorados.",
                                    "Escrever uma narrativa textual dos principais caminhos.",
                                    "Destacar o menor caminho aceitador, se existir.",
                                    "Arquivar a simulação com legenda clara."
                                  ],
                                  "verification": "Documento final revisado sem erros, com narrativa e resumo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Simulação anterior, editor de texto ou caderno.",
                                  "tips": "Peça a um colega para verificar uma branch aleatória.",
                                  "learningObjective": "Documentar simulações de forma reprodutível e precisa.",
                                  "commonMistakes": "Pular revisão, levando a inconsistências não detectadas."
                                }
                              ],
                              "practicalExample": "Considere uma MTND M que aceita {w | w tem número par de 'a's}: Estados {q0, q1, qf, qr}, δ(q0,a)=(q1,L); δ(q0,a)=(q0,R); etc. Entrada: 'aa'. Simule: Config inicial q0 _aa_. Branches: (1) q1 aaa_ (L), continua até aceitação; (2) q0 _aa_ (R), etc. Caminhos: 1 aceitador, 1 rejeitador.",
                              "finalVerifications": [
                                "Todas as transições não-determinísticas foram ramificadas corretamente.",
                                "Configurações de fita, estado e cabeçote estão precisas em cada nó.",
                                "Todos os caminhos terminam em halt ou loop detectado.",
                                "Classificação de aceitadores/rejeitadores está correta.",
                                "Não há branches perdidas ou duplicadas.",
                                "Simulação reproduz o comportamento esperado da MTND."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação de configurações (100% correto).",
                                "Completude da árvore de ramificações (todas exploradas).",
                                "Correta identificação de estados finais e rejeição.",
                                "Detecção adequada de loops ou não-halting.",
                                "Clareza na documentação e diagramas.",
                                "Eficiência na simulação (sem redundâncias)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Árvore de computação como grafo de derivações.",
                                "Probabilidade: Não-determinismo como distribuição de caminhos probabilísticos.",
                                "Lógica: Ramificações como busca em árvore de provas.",
                                "Algoritmos: Similar a backtracking em buscas exaustivas."
                              ],
                              "realWorldApplication": "Em verificação de software e model checking, simulações não-determinísticas modelam comportamentos concorrentes em sistemas distribuídos, como protocolos de rede ou IA com escolhas múltiplas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Equivalência com Máquinas de Turing Determinísticas",
                        "description": "Demonstração da equivalência de poder computacional entre MTND e MTD, via construção de simulações e teoremas de Sipser ou Hopcroft-Ullman.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Entender a simulação de MTND por MTD",
                            "description": "Descrever o algoritmo que usa um 'buscador' de caminhos aceitadores, simulando todas as ramificações não-determinísticas de forma determinística via busca em largura ou profundidade na árvore de computação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Básicas de MTND e MTD",
                                  "subSteps": [
                                    "Defina formalmente uma Máquina de Turing Não-Determinística (MTND), destacando transições múltiplas para o mesmo estado e símbolo.",
                                    "Defina uma Máquina de Turing Determinística (MTD), enfatizando uma única transição por configuração.",
                                    "Compare as diferenças chave: não-determinismo permite 'escolhas' paralelas, enquanto determinismo segue um caminho único.",
                                    "Identifique configurações instantâneas (estado, posição da cabeça, fita) como base para simulação.",
                                    "Desenhe diagramas simples de uma MTND básica com ramificação."
                                  ],
                                  "verification": "Escreva definições precisas e desenhe um diagrama comparativo sem erros conceituais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, quadro branco ou software de desenho como Draw.io.",
                                  "tips": "Use notação padrão (Q, Σ, Γ, δ, q0, B, F) para precisão.",
                                  "learningObjective": "Compreender as diferenças fundamentais entre MTND e MTD para fundamentar a simulação.",
                                  "commonMistakes": "Confundir não-determinismo com aleatoriedade; lembre-se que é escolha não-determinística finita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Árvore de Computação da MTND",
                                  "subSteps": [
                                    "Explique como uma computação MTND gera uma árvore: nós são configurações instantâneas, arestas são transições não-determinísticas.",
                                    "Descreva ramificações: de uma configuração, múltiplas filhos via δ(q, símbolo).",
                                    "Discuta caminhos aceitadores: caminhos da raiz a um estado final sem loops infinitos.",
                                    "Diferencie busca em largura (BFS, simula paralelismo) vs. profundidade (DFS, simula sequencial).",
                                    "Desenhe uma árvore de exemplo para uma MTND simples."
                                  ],
                                  "verification": "Construa e rotule corretamente uma árvore de computação para uma MTND de 3 estados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel milimetrado, exemplos de MTND impressos ou digitais.",
                                  "tips": "Comece com árvores pequenas para evitar complexidade; use abreviações para fitas longas.",
                                  "learningObjective": "Visualizar a explosão de ramificações não-determinísticas como uma árvore explorável.",
                                  "commonMistakes": "Ignorar loops infinitos; sempre considere halting ou detecção de ciclos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o Algoritmo de Simulação Determinística",
                                  "subSteps": [
                                    "Defina a MTD simuladora: fita codifica múltiplas configurações da MTND separadas por marcadores (ex: #config1#config2#).",
                                    "Explique o 'buscador': seleciona uma configuração não-explorada (frente para BFS, pilha para DFS).",
                                    "Detalhe o ciclo: simule um passo da configuração selecionada, gere filhos, atualize fita.",
                                    "Descreva detecção de aceitação: se qualquer configuração atinge estado final, aceite.",
                                    "Aborde rejeição: todas ramificações rejeitam ou loops detectados."
                                  ],
                                  "verification": "Escreva pseudocódigo do algoritmo principal da simuladora.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de texto para pseudocódigo, referências como Sipser 'Introduction to the Theory of Computation'.",
                                  "tips": "Pense na fita da MTD como uma fila ou pilha de configurações para BFS/DFS.",
                                  "learningObjective": "Dominar o mecanismo determinístico que explora exaustivamente a árvore não-determinística.",
                                  "commonMistakes": "Esquecer de copiar configurações inalteradas; todas devem persistir na fita."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Testar a Simulação com Exemplo",
                                  "subSteps": [
                                    "Escolha uma MTND exemplo (ex: reconhece {ww | w em {0,1}*}).",
                                    "Construa manualmente os primeiros níveis da árvore de computação.",
                                    "Simule passos da MTD: inicialize fita com configuração inicial, execute 5-10 passos.",
                                    "Verifique se detecta aceitação/rejeição corretamente.",
                                    "Analise complexidade: tempo O(n^{|Q|}) ou similar."
                                  ],
                                  "verification": "Simule entrada válida/inválida e confirme resultado correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Fitas simuladas em papel ou simulador online como JFLAP.",
                                  "tips": "Use entrada curta (ex: 00) para teste manual viável.",
                                  "learningObjective": "Aplicar o algoritmo em prática para solidificar compreensão.",
                                  "commonMistakes": "Perder sincronia entre cabeça da MTD e configurações simuladas."
                                }
                              ],
                              "practicalExample": "Considere MTND M que aceita {a^n b^n | n >= 0}. Para entrada 'aabb': a árvore ramifica em caminhos que contam a's e b's. A MTD simuladora inicia fita com #q0 aabb#, seleciona q0, gera filhos para X ou Y (marcadores), expande BFS até encontrar caminho aceitador onde contador a's = b's.",
                              "finalVerifications": [
                                "Descreva verbalmente o algoritmo de simulação em 2 minutos.",
                                "Desenhe árvore de computação para MTND simples sem erros.",
                                "Explique diferença BFS vs DFS na simulação.",
                                "Identifique aceitação para entrada exemplo.",
                                "Liste componentes da fita simuladora.",
                                "Discuta por que simulação é determinística apesar de ND."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da árvore de computação (80% ramificações corretas).",
                                "Correta codificação de configurações na fita MTD.",
                                "Implementação lógica do buscador (BFS/DFS).",
                                "Detecção adequada de aceitação/rejeição.",
                                "Análise de complexidade básica.",
                                "Clareza em diagramas e pseudocódigo."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Árvore de computação como grafo de busca.",
                                "Algoritmos: BFS/DFS para exploração exaustiva.",
                                "Matemática Discreta: Conjuntos finitos de configurações.",
                                "Programação: Simulação em Python com filas/pilhas.",
                                "Lógica: Prova de equivalência via simulação."
                              ],
                              "realWorldApplication": "Simulações determinísticas de sistemas não-determinísticos em verificação de software (model checking), busca em IA (A* como variante), compiladores para parsing não-determinístico, e paralelismo implícito em computação quântica ou distribuída."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Provar que toda MTND é simulada por uma MTD",
                            "description": "Construir formalmente uma MTD que simule qualquer MTND, codificando configurações na fita e gerenciando o não-determinismo através de enumerador de caminhos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formalizar a Configuração Instantânea de uma MTND",
                                  "subSteps": [
                                    "Defina configuração instantânea como tupla (q, h, fita, posição da cabeça).",
                                    "Explique estados q ∈ Q, posição h da cabeça, conteúdo da fita como string infinita com símbolos em Γ.",
                                    "Discuta transições δ: Q × Γ → finito(Q × Γ × {L,R}) para não-determinismo.",
                                    "Identifique configuração inicial e de aceitação.",
                                    "Diferencie de MTD: múltiplas transições possíveis por configuração."
                                  ],
                                  "verification": "Escreva definição formal de configuração e dê exemplo com MTND simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Papel e lápis para diagramas"
                                  ],
                                  "tips": "Use notação precisa; desenhe exemplos visuais para clareza.",
                                  "learningObjective": "Compreender a representação exata de um snapshot computacional em MTND.",
                                  "commonMistakes": [
                                    "Confundir posição da cabeça com conteúdo da fita",
                                    "Ignorar infinitude da fita (usar blanks)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Codificação de Configurações na Fita da MTD",
                                  "subSteps": [
                                    "Codifique cada configuração como string: #estado# símbolo cabeça símbolo1...símboloN #.",
                                    "Separe múltiplas configs na fita da MTD com delimitadores especiais como ¢ entre configs.",
                                    "Reserve áreas: cabeçalho para ID da MTND, lista de configs pendentes, config atual, configs geradas.",
                                    "Defina alfabeto estendido da MTD incluindo símbolos da MTND mais delimitadores.",
                                    "Garanta que MTD possa navegar e modificar essas codificações."
                                  ],
                                  "verification": "Desenhe fita da MTD com 2-3 configs codificadas e rotule partes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta de desenho (Draw.io ou papel)",
                                    "Pseudocódigo para codificação"
                                  ],
                                  "tips": "Escolha delimitadores não usados em Γ para evitar ambiguidade.",
                                  "learningObjective": "Dominar representação compacta de estado não-determinístico em estrutura determinística.",
                                  "commonMistakes": [
                                    "Codificação ambígua sem delimitadores únicos",
                                    "Esquecer símbolos de estado ou cabeça"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Simulação de Passo Único na MTD",
                                  "subSteps": [
                                    "MTD seleciona primeira config pendente, move para área de trabalho.",
                                    "Simule uma transição: leia cabeça, busque δ(q, símbolo), gere todas sucessoras determinísticamente.",
                                    "Codifique sucessoras e adicione à lista pendente se não-halting.",
                                    "Marque config processada como rejeitada se sem transições.",
                                    "Repita: avance para próxima pendente."
                                  ],
                                  "verification": "Simule manualmente um passo para MTND com 2 branches não-determinísticos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplo de MTND escrita (e.g., palíndromos)",
                                    "Tabela de transições δ"
                                  ],
                                  "tips": "Pense em MTD como loop while: while configs pendentes, simule uma.",
                                  "learningObjective": "Construir mecanismo para expandir não-determinismo em passos sequenciais.",
                                  "commonMistakes": [
                                    "Gerar sucessoras fora de ordem",
                                    "Perder configs ao mover na fita"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar Busca e Detecção de Aceitação",
                                  "subSteps": [
                                    "Use fila (breadth-first) ou pilha (depth-first) implícita na lista de pendentes para enumerar caminhos.",
                                    "Se config alcança estado de aceitação, MTD aceita imediatamente.",
                                    "Se lista pendentes esvazia sem aceitação, rejeite.",
                                    "Prove simulação em tempo finito: cada caminho é enumerado eventualmente.",
                                    "Discuta overhead exponencial mas preservação de decidibilidade."
                                  ],
                                  "verification": "Trace simulação completa de MTND pequena até aceitação/rejeição.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplo MTND para {a^n b^n}",
                                    "Gráfico de configs como árvore"
                                  ],
                                  "tips": "Breadth-first garante menor caminho primeiro, mas depth-first economiza espaço.",
                                  "learningObjective": "Entender enumeração exaustiva resolve não-determinismo.",
                                  "commonMistakes": [
                                    "Loop infinito sem marcar processadas",
                                    "Não detectar halting states"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Provar Correção da Simulação",
                                  "subSteps": [
                                    "Mostre: se MTND aceita entrada w, existe caminho para accept → MTD encontra.",
                                    "Mostre: se MTD aceita, então config accept válida → MTND aceita w.",
                                    "Argumente preservação de rejeição: todos caminhos explorados.",
                                    "Discuta linguagens reconhecidas iguais: L(MTND) = L(MTD).",
                                    "Aborde halting: MTD halts iff todos caminhos de MTND halts."
                                  ],
                                  "verification": "Escreva prova formal em 2 direções (⇒ e ⇐).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Template de prova por contradição/construção",
                                    "Livro texto para referências"
                                  ],
                                  "tips": "Use indução sobre número de passos no caminho não-determinístico.",
                                  "learningObjective": "Formalizar equivalência via simulação universal.",
                                  "commonMistakes": [
                                    "Ignorar caminhos infinitos (mas MTNDs padrão halts)",
                                    "Confundir simulação com equivalência de poder"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere MTND M que aceita {ww | w ∈ {0,1}*}: não-determinismo adivinha meio da fita. MTD S codifica configs como #q0#000111#¢#q1#00111#...; S enumera: simula adivinhação esquerda/direita, verifica matching, aceita se match encontrado.",
                              "finalVerifications": [
                                "Descreva fita da MTD com múltiplas configs codificadas.",
                                "Simule 3 passos de uma MTND na MTD.",
                                "Explique como não-determinismo é resolvido por enumeração.",
                                "Prove que se MTND aceita, MTD aceita.",
                                "Identifique halting condition na simulação.",
                                "Dê exemplo onde MTD rejeita após esgotar paths."
                              ],
                              "assessmentCriteria": [
                                "Codificação de configs é inequívoca e manipulável.",
                                "Simulação de passo gera todas sucessoras corretamente.",
                                "Mecanismo de enumeração cobre todos paths sem loops.",
                                "Prova de correção bidirecional completa e rigorosa.",
                                "Overhead exponencial reconhecido mas irrelevante para RE.",
                                "Notação formal consistente com definições padrão."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: configs como nós, transições como arestas, busca BFS/DFS.",
                                "Programação: simulação similar a backtracking em algoritmos (e.g., sudoku solver).",
                                "Lógica Matemática: prova por exaustão de casos não-determinísticos.",
                                "Algoritmos: universal Turing machine como simulador.",
                                "Filosofia da Computação: limites do determinismo vs. não-determinismo."
                              ],
                              "realWorldApplication": "Simuladores de hardware não-determinístico em software determinístico, como verificadores de protocolos (model checking em SPIN), compiladores lidando com backtracking parsers, e em IA para busca exaustiva em espaços de estados (e.g., jogos com minimax)."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Reconhecer a equivalência de linguagens",
                            "description": "Afirmar e justificar que L(MTND) = L(MTD) para qualquer MTND e MTD equivalente, implicando na tese de Church-Turing para ambos os modelos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de MTD e MTND",
                                  "subSteps": [
                                    "Defina formalmente uma Máquina de Turing Determinística (MTD), incluindo estados, alfabeto, fita, função de transição única.",
                                    "Defina formalmente uma Máquina de Turing Não-Determinística (MTND), destacando múltiplas transições possíveis do mesmo estado.",
                                    "Compare as linguagens aceitas: L(M) = {w | M aceita w}.",
                                    "Estude exemplos simples: MTD que reconhece {a^n b^n} e uma MTND equivalente com ramificações.",
                                    "Identifique diferenças no comportamento de execução: caminho único vs. árvore de computação."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças entre MTD e MTND, confirmando que entendeu as definições formais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Cap. 7)",
                                    "Notas de aula sobre Autômatos",
                                    "Simulador online de Máquinas de Turing (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": "Use diagramas de transição para visualizar; foque na não-determinização como 'escolha' em vez de aleatoriedade.",
                                  "learningObjective": "Compreender as definições precisas e diferenças chave entre MTD e MTND.",
                                  "commonMistakes": [
                                    "Confundir não-determinismo com paralelismo real; ignorar o papel da fita infinita."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Simulação de MTND por MTD",
                                  "subSteps": [
                                    "Aprenda a codificação: represente configuração de MTND (estado, posição fita, conteúdo fita) como string em MTD.",
                                    "Descreva a MTD simuladora: ela gera sistematicamente todas as configurações possíveis da MTND via BFS ou DFS na árvore de computação.",
                                    "Implemente a função de transição da simuladora: simule um passo não-determinístico escolhendo uma transição válida.",
                                    "Gerencie a fita da simuladora para armazenar múltiplas configurações separadas por marcadores especiais.",
                                    "Trate halting: simuladora aceita se qualquer configuração simulada aceitar."
                                  ],
                                  "verification": "Desenhe o diagrama de alto nível da MTD simuladora para uma MTND simples e trace 2 passos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigo 'Nondeterministic Turing Machines' de Hopcroft/Ullman",
                                    "Pseudocódigo da simulação em LaTeX ou papel",
                                    "Ferramenta JFLAP para diagramas de MT"
                                  ],
                                  "tips": "Pense na simuladora como um 'gerenciador de processos' que explora todas as ramificações sequencialmente.",
                                  "learningObjective": "Dominar a construção explícita da MTD que simula qualquer MTND.",
                                  "commonMistakes": [
                                    "Esquecer de codificar a posição da cabeça; não lidar com fitas infinitas na simulação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a Equivalência de Linguagens",
                                  "subSteps": [
                                    "Prove L(MTND) ⊆ L(MTD): se MTND aceita w, mostre que a simuladora MTD aceita w (preservação de aceitação).",
                                    "Prove L(MTD) ⊆ L(MTND): construa MTND trivial que simula MTD (uma transição por estado).",
                                    "Analise complexidade: tempo da simuladora é exponencial, mas poder de linguagem é o mesmo (REC).",
                                    "Verifique corretude: simulação exaustiva garante que se existe caminho aceitador na MTND, MTD o encontra.",
                                    "Teste com exemplo: converta MTND para {ww | w em {0,1}*} em MTD equivalente."
                                  ],
                                  "verification": "Escreva uma prova formal curta (1 página) da inclusão L(MTND) ⊆ L(MTD).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Provas de Sipser (Teorema 7.2)",
                                    "Papel e lápis para indução em configurações",
                                    "Exemplos resolvidos online (StackExchange Theory of Computation)"
                                  ],
                                  "tips": "Use indução na profundidade da árvore de computação para provar simulação correta.",
                                  "learningObjective": "Afirmar e justificar matematicamente que L(MTND) = L(MTD).",
                                  "commonMistakes": [
                                    "Confundir equivalência de linguagem com tempo de execução; inverter as inclusões."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Implicações para a Tese de Church-Turing",
                                  "subSteps": [
                                    "Recapitule a tese: todo algoritmo efetivo é simulado por MT (determinística).",
                                    "Discuta como equivalência reforça: MTND não aumenta poder computacional além de REC.",
                                    "Compare com outros modelos: λ-cálculo, registradoras, todos equivalentes via Church-Turing.",
                                    "Analise limitações: problemas indecidíveis permanecem (Halting Problem).",
                                    "Debata extensões: MT com oráculos ou probabilísticas."
                                  ],
                                  "verification": "Escreva um parágrafo justificando como isso implica na tese de Church-Turing para MTND e MTD.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Seção sobre Church-Turing em 'Computability and Logic' de Boolos",
                                    "Vídeo MIT OCW 18.404 (Lecture on Turing Machines)",
                                    "Resumo pessoal em blog ou nota"
                                  ],
                                  "tips": "Ligue à história: Church e Turing provaram independentes, mas equivalentes.",
                                  "learningObjective": "Conectar a equivalência à universalidade computacional.",
                                  "commonMistakes": [
                                    "Achar que MTND resolve Halting Problem; ignorar que tese é sobre efetividade, não eficiência."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere MTND M que aceita {a^n b^n c^n | n ≥ 0} com não-determinismo para adivinhar contagens. Construa MTD S que simula M: S codifica configurações como #q1#...#q2#..., explora BFS, e aceita se qualquer qi aceitar. Trace entrada aabbcc: S simula caminhos e aceita após exaustão.",
                              "finalVerifications": [
                                "Afirma corretamente que L(MTND) = L(MTD) para qualquer par equivalente.",
                                "Descreve a construção da simuladora sem erros chave.",
                                "Justifica a prova de inclusão com argumentos de preservação de aceitação.",
                                "Identifica implicações para classes de linguagens REC.",
                                "Aplica a equivalência em um exemplo concreto.",
                                "Discute corretamente o impacto na tese de Church-Turing."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de MTD vs. MTND (20%)",
                                "Corretude da construção da simuladora (30%)",
                                "Rigor matemático na prova de equivalência (25%)",
                                "Profundidade na discussão de implicações Church-Turing (15%)",
                                "Clareza em exemplos e diagramas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Indução em árvores de computação.",
                                "Lógica: Provas de corretude e simulação de processos lógicos.",
                                "Programação: Paralelismo simulado em algoritmos sequenciais (ex: backtracking).",
                                "Filosofia da Ciência: Universalidade computacional e limites da mente humana."
                              ],
                              "realWorldApplication": "Em compiladores e verificadores formais (ex: model checking com SPIN), onde simulações não-determinísticas são reduzidas a determinísticas para análise de software; otimiza algoritmos paralelos entendendo que poder é equivalente a sequencial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Versões Restritas de Máquinas de Turing",
                    "description": "Modelos limitados, como autômatos de fita linear (LBA), com restrições na fita ou cabeçotes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Autômatos de Fita Linear Acotada (LBA)",
                        "description": "Modelos de Máquinas de Turing onde o comprimento da fita é limitado a uma constante vezes o tamanho da entrada, reconhecendo linguagens sensíveis ao contexto.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Definir formalmente um LBA",
                            "description": "Descrever a estrutura de um Autômato de Fita Linear Acotada, incluindo estados, alfabeto de fita, função de transição, com restrição de que a cabeça não pode ultrapassar os marcadores de fim de entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Componentes Fundamentais de uma Máquina de Turing",
                                  "subSteps": [
                                    "Identifique os 7 componentes padrão de uma MT: conjunto de estados Q, alfabeto de entrada Σ, alfabeto da fita Γ, função de transição δ, estado inicial q0, símbolo em branco B e conjunto de estados finais F.",
                                    "Explique o papel de cada componente: Q representa configurações internas, Σ símbolos de entrada, Γ símbolos da fita incluindo blanks.",
                                    "Descreva δ como δ: Q × Γ → 2^(Q × Γ × {L, R, S}) para MTs não-determinísticas padrão.",
                                    "Discuta configuração inicial: fita com símbolo em branco além da entrada, cabeça no primeiro símbolo.",
                                    "Liste exemplos simples: Q = {q0, q1, qf}, Σ = {a,b}, Γ = {a,b,B}."
                                  ],
                                  "verification": "Escreva e recite os 7 componentes de uma MT com um exemplo breve.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Notas de aula sobre Máquinas de Turing",
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (capítulo relevante)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Use mnemônicos como 'Q-Sigma-Gamma-Delta-q0-B-F' para memorizar.",
                                    "Desenhe um diagrama da fita para visualizar."
                                  ],
                                  "learningObjective": "Compreender os blocos de construção de uma MT padrão como base para LBA.",
                                  "commonMistakes": [
                                    "Confundir Σ (entrada) com Γ (fita completa).",
                                    "Esquecer que δ pode ser não-determinística (potência de conjuntos).",
                                    "Ignorar o símbolo em branco B como parte de Γ."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Endmarkers e Restrição de Fita Linear Acotada",
                                  "subSteps": [
                                    "Defina endmarkers: símbolos especiais ¢ (esquerda) e $ (direita) que delimitam a entrada w, formando fita inicial ¢ w $.",
                                    "Especifique que Γ inclui ¢, $, Σ e B, mas ¢ e $ não são sobrescritos.",
                                    "Descreva restrição: cabeça de leitura/escrita não move além de ¢ para esquerda ou $ para direita; movimentos inválidos são rejeitados.",
                                    "Explique impacto: comprimento da fita limitado a |w| + 2, sem expansão ilimitada.",
                                    "Compare com MT padrão: LBA é MT com fita acotada linearmente pela entrada."
                                  ],
                                  "verification": "Desenhe a fita inicial de um LBA para entrada 'ab' e marque posições inválidas de movimento.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Papel para diagramas de fita",
                                    "Simulador online de MT (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": [
                                    "Pense nos endmarkers como 'cercas' que prendem a computação.",
                                    "Teste movimentos em um exemplo curto para internalizar."
                                  ],
                                  "learningObjective": "Dominar a restrição espacial que diferencia LBA de MTs ilimitadas.",
                                  "commonMistakes": [
                                    "Permitir sobrescrita de ¢ ou $.",
                                    "Confundir acotamento linear com fita fixa (que seria FA).",
                                    "Esquecer inclusão de endmarkers em Γ."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Função de Transição e Estados para LBA",
                                  "subSteps": [
                                    "Adapte δ para LBA: δ: Q × Γ → 2^(Q × Γ × {L, R}), mas rejeita transições que moveriam além de ¢/$ ou sobre eles.",
                                    "Defina Q incluindo q0 (inicial, cabeça em primeiro símbolo após ¢) e F (finais).",
                                    "Especifique que B é usado apenas dentro dos limites, se necessário.",
                                    "Discuta não-determinismo: múltiplas transições possíveis, aceita se algum caminho leva a F.",
                                    "Exemplo parcial: δ(q0, a) = {(q1, X, R)} onde X em Γ, respeitando limites."
                                  ],
                                  "verification": "Escreva uma regra de transição δ para um LBA que rejeite movimento além de $.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Folha de exercícios com diagramas de transição",
                                    "Ferramenta JFLAP para simular LBAs"
                                  ],
                                  "tips": [
                                    "Sempre verifique limites em cada transição: se próximo movimento sair, rejeitar.",
                                    "Use tabelas para listar δ em vez de funções matemáticas."
                                  ],
                                  "learningObjective": "Construir a lógica de transição respeitando restrições de LBA.",
                                  "commonMistakes": [
                                    "Definir δ sem checagem de limites.",
                                    "Incluir S (stay) sem justificativa para LBA padrão.",
                                    "Esquecer não-determinismo (2^)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar a Definição Formal Completa de um LBA",
                                  "subSteps": [
                                    "Reúna todos: LBA = (Q, Σ, Γ, δ, q0, B, F) onde Γ ⊇ Σ ∪ {¢, $, B}, δ respeita limites ¢/$ e não os sobrescreve.",
                                    "Especifique configuração inicial: (q0, ¢ w $, 1) com cabeça na posição 1 (após ¢).",
                                    "Defina aceitação: atinge q em F com fita inalterada nos endmarkers.",
                                    "Formalize rejeição: loop infinito bloqueado por limites ou sem transições.",
                                    "Valide com exemplo: escreva tupla completa para LBA trivial que aceita tudo."
                                  ],
                                  "verification": "Escreva a definição formal completa de um LBA simples e simule uma computação curta.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Modelo de tupla em LaTeX ou texto",
                                    "Exemplos resolvidos de LBA"
                                  ],
                                  "tips": [
                                    "Copie a tupla padrão e anote restrições em itálico.",
                                    "Teste a definição com entrada vazia."
                                  ],
                                  "learningObjective": "Articular a definição 7-tupla precisa de LBA com todas restrições.",
                                  "commonMistakes": [
                                    "Omitir endmarkers da tupla.",
                                    "Não especificar posições iniciais da cabeça.",
                                    "Confundir aceitação com halting em qualquer estado."
                                  ]
                                }
                              ],
                              "practicalExample": "Defina formalmente um LBA M que reconhece {a^n b^n | n ≥ 0}: Q = {q0, q1, qf}, Σ = {a,b}, Γ = {a,b,¢,$,X,Y,B}, δ inclui: δ(q0, a) = {(q1, X, R)}, δ(q1, b) = {(q1, Y, R)}, δ(q1, $) = {(qf, Y, L)} com checagens para combinar Xs e Ys cruzando, rejeitando mismatches, sem ultrapassar ¢/$. Simule em 'aabb': aceita.",
                              "finalVerifications": [
                                "Recite a 7-tupla exata de um LBA.",
                                "Desenhe fita inicial com endmarkers para w = 'abc'.",
                                "Explique por que uma transição para L em ¢ é inválida.",
                                "Diferencie LBA de MT e PDA em restrições de fita.",
                                "Escreva δ parcial respeitando limites.",
                                "Identifique linguagens decidíveis por LBA (context-sensitive)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na 7-tupla (todos componentes corretos).",
                                "Correta inclusão e não-sobrescrita de endmarkers.",
                                "Descrição clara da restrição de movimento da cabeça.",
                                "Uso apropriado de notação matemática para δ.",
                                "Exemplo prático funcional sem erros.",
                                "Diferenciação clara de MT padrão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções parciais para definir tuplas e δ.",
                                "Lógica: Autômatos como modelos formais de computação decidível.",
                                "Engenharia de Software: Verificação formal de sistemas com recursos limitados.",
                                "Física Computacional: Modelagem de sistemas com memória finita como qubits limitados."
                              ],
                              "realWorldApplication": "LBAs decidem linguagens context-sensitive, fundamentais para parsers de compiladores (ex: análise sintática com contexto linear) e verificação de protocolos em sistemas embarcados com memória restrita, como IoT devices."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Construir configurações de LBA",
                            "description": "Representar configurações iniciais, intermediárias e finais de um LBA, ilustrando como a fita limitada afeta o movimento da cabeça.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes fundamentais de um LBA",
                                  "subSteps": [
                                    "Identificar os elementos principais: estados, alfabeto de fita, alfabeto de entrada, funções de transição, fita linear limitada e posição da cabeça.",
                                    "Diferenciar LBA de Máquina de Turing padrão, enfatizando o limite na fita (k células fixas).",
                                    "Estudar a notação padrão para configurações: (estado, conteúdo da fita, posição da cabeça).",
                                    "Revisar exemplos simples de transições em LBAs."
                                  ],
                                  "verification": "Liste corretamente todos os 5 componentes principais e explique a limitação da fita em uma frase.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Material didático sobre LBAs (PDF ou slides)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar a fita limitada como um array fixo.",
                                  "learningObjective": "Dominar a terminologia e estrutura de um LBA para representar configurações com precisão.",
                                  "commonMistakes": "Confundir fita limitada com infinita ou ignorar a posição exata da cabeça."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a configuração inicial",
                                  "subSteps": [
                                    "Definir o estado inicial q0.",
                                    "Especificar o conteúdo inicial da fita com símbolo branco nas células não usadas.",
                                    "Posicionar a cabeça na primeira célula da entrada.",
                                    "Representar graficamente: desenhar a fita com | para células e seta para cabeça."
                                  ],
                                  "verification": "Desenhe a configuração inicial para uma entrada exemplo e confirme que corresponde à notação formal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de desenho (ex: Draw.io)",
                                    "Exemplo de entrada: w = aabb"
                                  ],
                                  "tips": "Sempre marque os limites da fita (k células) desde o início.",
                                  "learningObjective": "Representar com exatidão o ponto de partida de uma computação LBA.",
                                  "commonMistakes": "Colocar símbolos incorretos nas células vazias ou posicionar cabeça errada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar configurações intermediárias",
                                  "subSteps": [
                                    "Aplicar funções de transição passo a passo a partir da inicial.",
                                    "Atualizar estado, símbolo escrito, direção de movimento (L/R, mas respeitando limites).",
                                    "Ilustrar cada mudança na fita e posição da cabeça.",
                                    "Simular 3-5 passos, parando se atingir limite da fita."
                                  ],
                                  "verification": "Mostre pelo menos 3 configurações intermediárias consistentes com as transições.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador online de LBA ou tabela de transições impressa",
                                    "Cronômetro para simulação sequencial"
                                  ],
                                  "tips": "Anote o número do passo em cada configuração para rastreabilidade.",
                                  "learningObjective": "Simular dinamicamente o comportamento da cabeça em fita limitada.",
                                  "commonMistakes": "Ignorar rejeição por extrapolação da fita ou erros em direções de movimento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir a configuração final e ilustrar impacto da fita",
                                  "subSteps": [
                                    "Identificar estados de aceitação/rejeição ou halt.",
                                    "Representar a fita final e posição da cabeça.",
                                    "Explicar cenários onde fita limitada causa rejeição (ex: overflow).",
                                    "Comparar com MT ilimitada via diagrama side-by-side."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito como a limitação afeta o resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de LBAs decidores (linguagens CSL)",
                                    "Ferramenta de comparação gráfica"
                                  ],
                                  "tips": "Use cores para destacar áreas 'fora do limite' na fita.",
                                  "learningObjective": "Analisar o efeito restritivo da fita no movimento e aceitação.",
                                  "commonMistakes": "Não distinguir aceitação por estado vs. por fita cheia ou overflow."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar as configurações",
                                  "subSteps": [
                                    "Verificar consistência entre todas as configurações (inicial a final).",
                                    "Testar com outra entrada para generalização.",
                                    "Corrigir erros identificados nas simulações.",
                                    "Documentar ilustrações em um relatório curto."
                                  ],
                                  "verification": "Um par revise as configurações e confirme validade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Checklist de verificação",
                                    "Outra entrada teste: w' = aaabbb"
                                  ],
                                  "tips": "Simule reversamente da final para inicial para checar lógica.",
                                  "learningObjective": "Garantir precisão e robustez nas representações de LBA.",
                                  "commonMistakes": "Pular validação cruzada, levando a inconsistências ocultas."
                                }
                              ],
                              "practicalExample": "Para um LBA que aceita {a^n b^n | n≥0} com fita de 2n+1 células: Inicial: q0, fita= aabb | _ _, cabeça em 'a'. Intermediária1: q1, fita= _Xb b | _ _, cabeça em 'X'. Final: q_acc, fita= _ _ _ | _ _, cabeça em branco, ilustrando rejeição se n grande por overflow.",
                              "finalVerifications": [
                                "Configuração inicial tem estado q0 e cabeça no início?",
                                "Transições intermediárias respeitam limites da fita?",
                                "Configuração final indica aceitação/rejeição corretamente?",
                                "Impacto da fita limitada é explicitamente ilustrado?",
                                "Todas as posições da cabeça são válidas dentro de k células?",
                                "Notação é consistente em todas as configs?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação da fita e cabeça (100% match com transições).",
                                "Número adequado de steps intermediários (mín. 3).",
                                "Clareza visual nas ilustrações (setas, limites marcados).",
                                "Explicação correta do impacto da limitação da fita.",
                                "Generalização para múltiplas entradas testadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem com grafos de estados e autômatos finitos.",
                                "Física: Análoga a movimento browniano confinado em espaço limitado.",
                                "Programação: Implementação de simuladores em Python com arrays fixos.",
                                "Lógica: Teoria da computabilidade e hierarquia de Chomsky."
                              ],
                              "realWorldApplication": "Modela parsers com memória fixa (compiladores LL), caches de CPU com tamanho limitado e sistemas embarcados onde RAM é restrita, prevendo falhas por overflow de memória."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Identificar linguagens reconhecidas por LBA",
                            "description": "Explicar que LBAs decidem exatamente as linguagens sensíveis ao contexto (CSL) e fornecer exemplos como {a^n b^n c^n | n ≥ 1}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição de Autômatos de Fita Linear Acotada (LBA)",
                                  "subSteps": [
                                    "Estude a definição formal de LBA: um TM com fita de tamanho linear na entrada (|input| * k).",
                                    "Compare LBA com TM padrão e PDA, destacando restrições de espaço.",
                                    "Revise transições e configuração de fita em LBAs.",
                                    "Entenda que LBAs são não-determinísticos e decidem em tempo exponencial.",
                                    "Anote diferenças chave: fita ilimitada vs. linear."
                                  ],
                                  "verification": "Escreva uma definição precisa de LBA e dê um exemplo de configuração de fita.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Notas de aula sobre Automata",
                                    "Vídeos online sobre LBAs"
                                  ],
                                  "tips": "Desenhe diagramas de fita para visualizar o espaço linear.",
                                  "learningObjective": "Definir formalmente LBA e distinguir de outros autômatos.",
                                  "commonMistakes": "Confundir fita linear com fita ilimitada; achar que LBAs são determinísticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar a Hierarquia de Chomsky e o Papel das CSL",
                                  "subSteps": [
                                    "Recapitule a hierarquia: Regular < CFL < CSL < RE < r.e.",
                                    "Aprenda que CSL são exatamente as linguagens reconhecidas por LBAs não-determinísticos.",
                                    "Estude teoremas: Toda CSL tem uma gramática sensível ao contexto; LBAs simulam gramáticas CSL.",
                                    "Discuta decidibilidade: LBAs decidem CSL (problema de aceitação é decidível).",
                                    "Compare com CFL: CSL requerem mais poder (ex: cópias múltiplas)."
                                  ],
                                  "verification": "Desenhe a hierarquia de Chomsky e posicione CSL/LBA corretamente com justificativa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela da Hierarquia de Chomsky impressa",
                                    "Exercícios de teoria da computação"
                                  ],
                                  "tips": "Use mnemônicos para lembrar: 'Context-Sensitive precisa de contexto linear'.",
                                  "learningObjective": "Posicionar CSL na hierarquia e ligar a LBAs.",
                                  "commonMistakes": "Confundir CSL com CFL; ignorar não-determinismo em LBAs."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos Clássicos de Linguagens Reconhecidas por LBA",
                                  "subSteps": [
                                    "Estude L1 = {a^n b^n c^n | n ≥ 1}: não CFL, mas CSL via LBA contando com marcadores.",
                                    "Examine L2 = {a^n b^n c^n d^n | n ≥ 1}: CSL, LBA usa fita linear para rastrear contagens.",
                                    "Revise {ww | w em {a,b}*}: palíndromos pares, reconhecido por LBA.",
                                    "Pratique esboçando LBAs de alto nível para esses exemplos.",
                                    "Identifique por que não são CFL (bomba de bombeamento falha)."
                                  ],
                                  "verification": "Esboce um LBA não-determinístico para {a^n b^n c^n} e simule em entrada pequena.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para diagramas",
                                    "Simulador de TM online adaptado para LBA"
                                  ],
                                  "tips": "Comece com contadores na fita: marque a's, então b's, etc.",
                                  "learningObjective": "Reconhecer padrões CSL e delinear LBAs para eles.",
                                  "commonMistakes": "Achar que {a^n b^n} é CSL (é CFL); subestimar espaço linear."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação de Linguagens Reconhecidas por LBA",
                                  "subSteps": [
                                    "Dada uma linguagem, teste se é regular/CFL primeiro (pumping lemma).",
                                    "Se não, verifique se cabe em CSL: precisa de contexto linear? Pode LBA simular?",
                                    "Exercícios: Classifique {a^n b^m | n ≤ m ≤ 2n}, {w w^R}, linguagens RE mas não CSL.",
                                    "Construa contra-exemplos para linguagens além de CSL (ex: RE não-recursivas).",
                                    "Resolva problemas: 'É L reconhecida por LBA?' com justificativa."
                                  ],
                                  "verification": "Resolva 5 exercícios de classificação e autoavalie acertos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Lista de exercícios de linguagens formais",
                                    "Soluções comentadas"
                                  ],
                                  "tips": "Pergunte: 'Requer memória linear não-stack?' -> Provavelmente CSL/LBA.",
                                  "learningObjective": "Identificar rapidamente se uma linguagem é reconhecida por LBA.",
                                  "commonMistakes": "Classificar CSL como RE sem verificar decidibilidade; ignorar exemplos canônicos."
                                }
                              ],
                              "practicalExample": "Para L = {a^n b^n c^n | n ≥ 1}, prove que não é CFL (pumping lemma) e esboce LBA: varra fita marcando um a, b, c por vez, usando espaço linear para contadores temporários.",
                              "finalVerifications": [
                                "Define LBA e CSL corretamente sem erros.",
                                "Classifica exemplos como {a^n b^n c^n} como CSL/LBA com justificativa.",
                                "Explica por que CSL ≠ RE usando decidibilidade de LBAs.",
                                "Distingue LBA de PDA e TM em poder e restrições.",
                                "Esboça LBA simples para linguagem CSL padrão.",
                                "Identifica corretamente 4/5 linguagens dadas como LBA ou não."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e hierarquia (90% correto).",
                                "Uso correto de lemmas (pumping) para exclusão de classes inferiores.",
                                "Criatividade em esboços de LBA viáveis em espaço linear.",
                                "Justificativas lógicas sem falácias.",
                                "Profundidade em exemplos: cobre não-determinismo e decidibilidade.",
                                "Velocidade: identifica em <5 min por linguagem."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução e contagem para provas de reconhecimento.",
                                "Lógica: Raciocínio formal em hierarquias e decidibilidade.",
                                "Programação: Simulação de autômatos em Python para validação.",
                                "Linguística Computacional: Análise sintática sensível ao contexto."
                              ],
                              "realWorldApplication": "Em compiladores de linguagens de programação, LBAs modelam análises sintáticas complexas como balanceamento de tipos genéricos ou verificação de escopos lineares, otimizando parsers para gramáticas context-sensitive limitadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Máquinas de Turing com Restrições em Cabeçotes ou Fitas",
                        "description": "Versões com múltiplos cabeçotes ou fitas com bounds específicos, como fitas de uma via infinita ou multi-cabeçote com fita compartilhada.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Descrever MT com múltiplos cabeçotes",
                            "description": "Definir Máquinas de Turing multi-cabeçote, mostrando equivalência com MT padrão e como restrições em movimento sincronizado limitam o poder.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os Conceitos Básicos de Máquinas de Turing Multi-Cabeçote",
                                  "subSteps": [
                                    "Revise a definição de uma MT padrão (single-head, single-tape).",
                                    "Introduza MT multi-cabeçote: múltiplos cabeçotes em uma fita única, cada um lendo/gravando independentemente.",
                                    "Estude a função de transição δ: Q × Γ^k → Q × Γ^k × {L,R,S}^k, onde k é o número de cabeçotes.",
                                    "Identifique estados, alfabeto, fita infinita e configurações iniciais.",
                                    "Diferencie de MT multi-fita (equivalentes, mas foco em cabeçotes)."
                                  ],
                                  "verification": "Desenhe e rotule o diagrama de uma MT com 2 cabeçotes, incluindo função δ para um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Papel e lápis para diagramas",
                                    "Notas de aula sobre MT padrão"
                                  ],
                                  "tips": "Visualize os cabeçotes como 'dedos' independentes na mesma fita para facilitar a compreensão.",
                                  "learningObjective": "Compreender a estrutura formal e componentes de uma MT multi-cabeçote.",
                                  "commonMistakes": "Confundir movimentos independentes dos cabeçotes com sincronizados; assumir que mais cabeçotes aumentam poder computacional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar Equivalência com MT Padrão",
                                  "subSteps": [
                                    "Analise por que k cabeçotes não aumentam o poder: simulação por MT single-tape.",
                                    "Descreva a construção de simulação: MT padrão simula movimentos multiplexando cabeçotes em blocos na fita.",
                                    "Estude o overhead: tempo de simulação é O(n^k) no pior caso, mas reconhece mesmas linguagens recursivamente enumeráveis.",
                                    "Prove formalmente: qualquer MT multi-cabeçote pode ser convertida em MT equivalente single-head.",
                                    "Verifique exemplos de linguagens reconhecidas (ex: {a^n b^n})."
                                  ],
                                  "verification": "Escreva um esboço da prova de simulação e compute o tempo para uma entrada de tamanho n.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador de MT online (ex: Turing Machine Simulator)",
                                    "Folha de provas matemáticas"
                                  ],
                                  "tips": "Use track jumping na fita simulada para representar posições de múltiplos cabeçotes.",
                                  "learningObjective": "Provar que MT multi-cabeçote ≡ MT padrão em poder computacional.",
                                  "commonMistakes": "Ignorar o overhead polinomial e achar que multi-cabeçote resolve problemas intratáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Exemplos Práticos e Simulações",
                                  "subSteps": [
                                    "Construa uma MT com 2 cabeçotes para reconhecer palíndromos.",
                                    "Simule passo a passo: um cabeçote na esquerda, outro na direita, comparando símbolos.",
                                    "Implemente em simulador e trace configurações.",
                                    "Compare eficiência com MT single-head para a mesma tarefa.",
                                    "Gere traços de execução para entradas variadas."
                                  ],
                                  "verification": "Execute simulação em simulador e capture screenshot de configuração final aceitando/rejeitando.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta online como JFLAP ou Turing Machine Web Simulator",
                                    "Entradas de teste: 'aba', 'abc']"
                                  ],
                                  "tips": "Comece com k=2 para simplicidade; aumente gradualmente para entender escalabilidade.",
                                  "learningObjective": "Aplicar MT multi-cabeçote em problemas concretos via simulação.",
                                  "commonMistakes": "Esquecer de mover todos os cabeçotes na transição; crash por loops infinitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Restrições de Movimento Sincronizado",
                                  "subSteps": [
                                    "Defina MT multi-cabeçote sincronizada: todos cabeçotes movem L/R juntos.",
                                    "Prove que perde poder: equivalente a MT single-head (não pode 'separar' para escanear partes independentes).",
                                    "Construa contra-exemplo: linguagem requerendo separação não reconhecível.",
                                    "Compare com versão não-sincronizada via teorema de simulação.",
                                    "Discuta implicações para modelos de computação paralela."
                                  ],
                                  "verification": "Escreva prova curta mostrando que MT sincronizada com k cabeçotes ≤ MT single-head.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigos ou capítulos sobre variantes de MT",
                                    "Quadro branco para diagramas de prova"
                                  ],
                                  "tips": "Pense em sincronizado como 'cadeia' de cabeçotes; movimentos limitados reduzem a independência.",
                                  "learningObjective": "Entender como restrições alteram o poder computacional das MT.",
                                  "commonMistakes": "Achar que sincronização ainda permite equivalência total; confundir com multi-fita."
                                }
                              ],
                              "practicalExample": "Construa uma MT com dois cabeçotes para copiar uma string w na fita: cabeçote 1 lê w, cabeçote 2 escreve cópia em outra seção. Simule em entrada '101': final resulta em '101101'.",
                              "finalVerifications": [
                                "Pode definir formalmente δ para MT com k cabeçotes?",
                                "Explica e esboça prova de equivalência com MT single-tape?",
                                "Simula corretamente um exemplo com 2 cabeçotes?",
                                "Identifica limitação exata de movimentos sincronizados?",
                                "Distingue multi-cabeçote de multi-fita?",
                                "Calcula overhead de simulação para k=3?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal e componentes (30%)",
                                "Correta demonstração de equivalência e prova de simulação (25%)",
                                "Qualidade da simulação prática e traços de execução (20%)",
                                "Análise clara de restrições sincronizadas com contra-exemplo (15%)",
                                "Clareza em diagramas e explicações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Paralelismo em Programação Concorrente (Ciência da Computação)",
                                "Teoria de Autômatos em Inteligência Artificial",
                                "Modelos Matemáticos de Sistemas Dinâmicos",
                                "Hardware: Arquitetura de Múltiplos Núcleos de CPU"
                              ],
                              "realWorldApplication": "Modela processamento paralelo em multi-threaded systems e GPUs, onde 'cabeçotes' representam threads acessando memória compartilhada, otimizando tarefas como busca em grafos ou análise de dados massivos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Analisar MT de fita linear ilimitada em uma direção",
                            "description": "Explicar MT com fita infinita apenas em uma direção (half-tape), comparando seu poder com autômatos de pilha e identificando linguagens reconhecíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a definição formal de Máquina de Turing com fita linear ilimitada em uma direção (Half-Tape Turing Machine - HTTM)",
                                  "subSteps": [
                                    "Estude a estrutura padrão de uma MT: estados, alfabeto de fita, alfabeto de entrada, função de transição, estado inicial, estados de aceitação e rejeição.",
                                    "Modifique o modelo para fita half-tape: fita começa na posição 0 e se estende infinitamente apenas à direita (direção positiva), sem movimento à esquerda.",
                                    "Defina formalmente a HTTM como um 7-tupla: (Q, Σ, Γ, δ, q0, B, F), destacando restrições na função δ para não mover a cabeça para posições negativas.",
                                    "Desenhe diagramas da fita half-tape versus fita bidirecional ilimitada.",
                                    "Implemente uma simulação simples em pseudocódigo para uma HTTM básica que copia a entrada."
                                  ],
                                  "verification": "Construa e execute uma simulação manual de uma HTTM simples em papel, confirmando que a cabeça nunca vai à esquerda.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Papel e lápis para diagramas",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Visualize a fita como um array indexado de 0 a ∞; use 'parede' na posição -1 para reforçar a restrição.",
                                  "learningObjective": "Formalizar e visualizar o modelo HTTM, diferenciando-o da MT padrão.",
                                  "commonMistakes": [
                                    "Confundir com fita finita",
                                    "Permitir movimentos à esquerda na transição",
                                    "Ignorar o blank symbol na extremidade esquerda"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar simulações e equivalências entre HTTM e MT padrão",
                                  "subSteps": [
                                    "Prove que toda HTTM pode ser simulada por uma MT padrão, mapeando posições da half-tape para posições pares na fita bidirecional.",
                                    "Demonstre que toda MT padrão pode simular uma HTTM usando apenas a metade direita da fita, 'dobrando' movimentos necessários.",
                                    "Implemente uma construção explícita de simulação em pseudocódigo ou diagrama.",
                                    "Execute simulações passo a passo para linguagens regulares e context-free simples.",
                                    "Discuta limitações: HTTM reconhece exatamente as linguagens recursivas (RE), igual à MT."
                                  ],
                                  "verification": "Escreva uma prova curta (1 página) mostrando equivalência de poder computacional entre HTTM e MT.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Pseudocódigo ou Python para simulação",
                                    "Exemplos de linguagens RE de livros-texto",
                                    "Folhas para provas manuais"
                                  ],
                                  "tips": "Use numeração de Gödel-like para codificar posições; foque em preservar o conteúdo da fita durante simulações.",
                                  "learningObjective": "Compreender que restrições unidirecionais não reduzem o poder computacional.",
                                  "commonMistakes": [
                                    "Achar que HTTM é menos poderosa",
                                    "Erros em construções de simulação que violam a half-tape",
                                    "Confundir decidibilidade com reconhecibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar HTTM com Autômatos de Pilha (PDA)",
                                  "subSteps": [
                                    "Revise o modelo PDA: 7-tupla com pilha infinita bidirecional.",
                                    "Mostre que PDA ⊂ HTTM, pois toda linguagem context-free é RE, mas nem toda RE é context-free (ex: {a^n b^n c^n}).",
                                    "Construa uma HTTM que simula um PDA usando a fita como pilha (push/pop via movimentos).",
                                    "Discuta por que HTTM é mais poderosa: acesso randômico à fita vs. LIFO da pilha.",
                                    "Analise exemplos: ww^R é CF (PDA), mas halting problem não é reconhecível por PDA."
                                  ],
                                  "verification": "Desenhe uma HTTM que reconhece {a^n b^n | n≥0} e explique por que um PDA também pode, contrastando com linguagens não-CF.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Diagramas de PDA e HTTM",
                                    "Ferramenta JFLAP para simulações",
                                    "Lista de linguagens CF e RE"
                                  ],
                                  "tips": "Pense na fita half-tape como uma pilha melhorada com marcações para simular acesso randômico.",
                                  "learningObjective": "Diferenciar hierarquia de poder: PDA < HTTM = MT.",
                                  "commonMistakes": [
                                    "Achar PDA tão poderoso quanto MT",
                                    "Ignorar que PDA não decide halting",
                                    "Exemplos errados de linguagens"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar linguagens reconhecíveis por HTTM e aplicações",
                                  "subSteps": [
                                    "Liste linguagens RE reconhecíveis por HTTM: todas RE, incluindo decidíveis e indecidíveis.",
                                    "Construa HTTM para exemplos concretos: palíndromos longos, {a^n! | n≥1}, problemas de parada simulados.",
                                    "Discuta linguagens não reconhecíveis: complemento de halting problem.",
                                    "Analise impacto de restrições: tempo/espaço em half-tape vs. full-tape.",
                                    "Crie um exemplo original de linguagem RE e sua HTTM."
                                  ],
                                  "verification": "Projetar e simular uma HTTM para uma linguagem RE dada, como {w w | w em {0,1}*}.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "JFLAP ou simulador online de MT",
                                    "Papel para construções",
                                    "Referências de linguagens RE"
                                  ],
                                  "tips": "Comece com linguagens simples e escale para complexas; teste com entradas variadas.",
                                  "learningObjective": "Classificar linguagens pelo poder de HTTM e construir máquinas específicas.",
                                  "commonMistakes": [
                                    "Confundir RE com decidíveis",
                                    "Falhar em loops infinitos para não-RE",
                                    "Construções ineficientes"
                                  ]
                                }
                              ],
                              "practicalExample": "Projetar uma HTTM que reconhece a linguagem {a^n b^n c^n | n ≥ 0}: Use marcadores na fita para contar a's, b's e c's em passes múltiplos à direita, verificando igualdade no final sem voltar à esquerda.",
                              "finalVerifications": [
                                "Define corretamente a 7-tupla da HTTM com restrições unidirecionais.",
                                "Explica equivalência de poder com MT padrão via simulação mútua.",
                                "Compara precisamente com PDA, dando exemplos de linguagens CF e RE não-CF.",
                                "Constrói uma HTTM funcional para uma linguagem RE específica.",
                                "Identifica corretamente linguagens reconhecíveis (todas RE) e não reconhecíveis.",
                                "Simula manualmente uma execução sem violar regras da half-tape."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formalização e restrições do modelo HTTM (30%)",
                                "Correção nas provas de equivalência e comparações (25%)",
                                "Qualidade das construções e simulações de máquinas (20%)",
                                "Profundidade na identificação de linguagens e exemplos (15%)",
                                "Clareza em diagramas, pseudocódigo e explicações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções parciais para formalismos.",
                                "Lógica: Equivalências e hierarquias de Chomsky.",
                                "Física: Modelos de computação quântica com restrições unidirecionais.",
                                "Engenharia de Software: Streams de dados unidirecionais em programação funcional."
                              ],
                              "realWorldApplication": "Modela computação em dispositivos com memória unidirecional, como processadores de streaming de dados em IoT ou análise de logs em tempo real, onde dados chegam sequencialmente sem rewind."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Comparar poder computacional de versões restritas",
                            "description": "Discutir hierarquia: PDA ⊂ LBA ⊂ TM, relacionando com a tese de Church-Turing sobre modelos equivalentes à computação recursiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de PDA, LBA e TM",
                                  "subSteps": [
                                    "Estude a definição formal de Pushdown Automaton (PDA), incluindo estados, alfabeto, pilha e transições.",
                                    "Analise Linear Bounded Automaton (LBA), destacando a restrição de fita limitada ao tamanho da entrada.",
                                    "Revise a Máquina de Turing (TM) padrão, com fita infinita em ambas as direções e cabeçote móvel.",
                                    "Compare componentes comuns e diferenças chave entre os três modelos.",
                                    "Identifique as classes de linguagens associadas: CFL para PDA, CSL para LBA e RE para TM."
                                  ],
                                  "verification": "Resuma em um diagrama ou tabela as definições e diferenças principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Teoria da Computação (ex: Sipser), notas de aula, diagramas online de autômatos.",
                                  "tips": "Use diagramas visuais para representar as fitas e pilhas para melhor compreensão.",
                                  "learningObjective": "Compreender precisamente os modelos e suas restrições estruturais.",
                                  "commonMistakes": "Confundir PDA com fita infinita (PDA usa pilha, não fita); ignorar que LBA tem fita limitada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Hierarquia PDA ⊂ LBA ⊂ TM",
                                  "subSteps": [
                                    "Demonstre que todo PDA pode ser simulado por um LBA (inclusão PDA ⊂ LBA).",
                                    "Mostre que LBA pode ser simulado por TM (inclusão LBA ⊂ TM).",
                                    "Discuta provas de inclusão estrita: existe CFL não CSL? Não, mas CSL ⊂ RE estritamente.",
                                    "Estude exemplos: ww é CSL (LBA), não CFL (PDA); linguagem de parada é RE, não CSL.",
                                    "Construa um diagrama de Venn ou hierarquia de Chomsky ilustrando as inclusões."
                                  ],
                                  "verification": "Crie um fluxograma mostrando simulações e exemplos separadores.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e caneta para diagramas, simuladores online de autômatos (ex: JFLAP), referências teóricas.",
                                  "tips": "Comece pelas simulações mais simples (PDA em LBA) para construir confiança.",
                                  "learningObjective": "Dominar as relações de inclusão e estritudez entre as classes de poder computacional.",
                                  "commonMistakes": "Afirmar PDA ⊂ LBA ⊂ TM sem exemplos de separação; confundir CSL com RE."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos e Provas de Poder Computacional",
                                  "subSteps": [
                                    "Pumping lemma para CFL: prove que {ww | w ∈ {a,b}*} não é CFL.",
                                    "Construa um LBA para {ww} usando fita limitada.",
                                    "Discuta problema da parada: RE mas não recursivo, requer TM completa.",
                                    "Compare tempos/espaços: PDA O(n), LBA O(n), TM ilimitado.",
                                    "Resolva exercícios: classifique linguagens em PDA/LBA/TM."
                                  ],
                                  "verification": "Resolva 3 problemas de classificação de linguagens e justifique.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Exercícios de livros (Sipser/Hopcroft), software JFLAP para simulações.",
                                  "tips": "Pratique com linguagens conhecidas como anbn para PDA e wwR para LBA.",
                                  "learningObjective": "Aplicar teoremas para demonstrar diferenças de poder computacional.",
                                  "commonMistakes": "Usar pumping lemma incorretamente; esquecer que LBA é decidível para CSL."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com a Tese de Church-Turing",
                                  "subSteps": [
                                    "Explique a tese de Church-Turing: TM captura computação efetiva intuitiva.",
                                    "Discuta equivalência: λ-cálculo, registradoras, TM computam funções recursivas parciais.",
                                    "Analise como restrições (PDA/LBA) limitam para subclasses (CFL/CSL).",
                                    "Debata implicações: TM universal simula qualquer algoritmo, restrições simulam casos especiais.",
                                    "Conclua com limitações modernas: computação quântica vs. TM clássica."
                                  ],
                                  "verification": "Escreva um parágrafo conectando hierarquia à tese CT.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos sobre Church-Turing (Wikipedia acadêmica), vídeo-aulas (ex: YouTube MIT OCW).",
                                  "tips": "Pense em TM como 'hardware universal' e restrições como 'hardware especializado'.",
                                  "learningObjective": "Integrar hierarquia restrita à noção fundamental de computabilidade.",
                                  "commonMistakes": "Confundir tese CT (universalidade) com hierarquia restrita; ignorar não-computável."
                                }
                              ],
                              "practicalExample": "Dado a linguagem {a^n b^n c^n | n ≥ 0}, prove que não é CFL (PDA falha pelo pumping lemma), requer LBA para CSL, e TM a reconhece facilmente. Simule em JFLAP um PDA falhando e LBA sucedendo.",
                              "finalVerifications": [
                                "Explicar verbalmente a hierarquia PDA ⊂ LBA ⊂ TM com exemplos.",
                                "Classificar corretamente 5 linguagens em suas classes máximas.",
                                "Desenhar diagramas de simulação PDA→LBA→TM.",
                                "Relacionar corretamente à tese de Church-Turing em um ensaio curto.",
                                "Identificar por que restrições limitam poder computacional.",
                                "Resolver um problema de prova de não-reconhecimento por PDA."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e inclusões corretas (30%).",
                                "Uso de exemplos e provas: lemmas e simulações aplicadas (25%).",
                                "Profundidade na hierarquia: demonstrações de estritudez (20%).",
                                "Conexão com Church-Turing: clareza e relevância (15%).",
                                "Clareza e organização: diagramas e resumos lógicos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Hierarquias (Chomsky).",
                                "Lógica: Decidibilidade e Teoremas de Incompletude (Gödel).",
                                "Filosofia: Limites da Computação e Mente Mecânica.",
                                "Engenharia de Software: Análise de Complexidade em Compiladores."
                              ],
                              "realWorldApplication": "No design de compiladores, PDAs parseiam linguagens livres de contexto (ex: expressões aritméticas); LBAs modelam verificadores de memória limitada em sistemas embarcados; TMs guiam algoritmos gerais em IA, destacando trade-offs entre restrições de hardware (memória/energia) e poder computacional em dispositivos IoT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.3",
                              "10.1.6.4.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Tese de Church-Turing",
                    "description": "Afirmação de que as Máquinas de Turing capturam a noção intuitiva de computação efetiva.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Noção Intuitiva de Computação Efetiva",
                        "description": "Compreender a definição informal e intuitiva do que constitui um procedimento ou algoritmo efetivamente computável, incluindo suas propriedades fundamentais como finitude, determinação e mecanicidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Definir computação efetiva",
                            "description": "Explicar com precisão a noção intuitiva de computação efetiva, destacando critérios como passos finitos, regras determinísticas, ausência de oráculos e aplicabilidade a entradas arbitrárias de forma mecânica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Noção Intuitiva Básica de Computação Efetiva",
                                  "subSteps": [
                                    "Leia a definição clássica de computação efetiva de Turing e Church.",
                                    "Identifique que computação efetiva significa resolver problemas por meio de um processo mecânico e finito.",
                                    "Anote exemplos cotidianos de tarefas efetivas, como somar números.",
                                    "Diferencie de processos infinitos ou não-mecânicos.",
                                    "Resuma em suas próprias palavras o que significa 'efetivo' intuitivamente."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a noção intuitiva e compartilhe com um par para feedback.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Texto introdutório sobre Tese de Church-Turing",
                                    "Caderno de anotações"
                                  ],
                                  "tips": "Use analogias como uma receita de bolo para visualizar o processo mecânico.",
                                  "learningObjective": "Compreender o conceito intuitivo de computação como um procedimento mecânico finito.",
                                  "commonMistakes": [
                                    "Confundir com eficiência computacional",
                                    "Ignorar o aspecto 'intuitivo' vs formal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Explicar os Critérios Principais",
                                  "subSteps": [
                                    "Liste os critérios: passos finitos, regras determinísticas.",
                                    "Explique 'passos finitos': o algoritmo deve terminar em tempo finito para qualquer entrada válida.",
                                    "Descreva 'regras determinísticas': cada passo segue regras fixas sem ambiguidades.",
                                    "Crie um fluxograma simples ilustrando um processo determinístico.",
                                    "Compare com processos não-determinísticos para reforçar."
                                  ],
                                  "verification": "Crie uma tabela comparando critérios efetivos vs não-efetivos e autoavalie.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma online (ex: Draw.io)",
                                    "Referências sobre algoritmos determinísticos"
                                  ],
                                  "tips": "Pense em um jogo de tabuleiro com regras fixas como exemplo determinístico.",
                                  "learningObjective": "Dominar os critérios de passos finitos e determinismo na computação efetiva.",
                                  "commonMistakes": [
                                    "Confundir determinístico com probabilístico",
                                    "Esquecer que passos devem ser finitos para todas entradas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Ausência de Oráculos e Aplicabilidade Mecânica",
                                  "subSteps": [
                                    "Defina 'oráculo' como uma 'caixa preta' que resolve problemas indecidíveis instantaneamente.",
                                    "Explique por que computação efetiva proíbe oráculos: deve ser puramente mecânica.",
                                    "Discuta aplicabilidade a entradas arbitrárias: algoritmo funciona para qualquer entrada válida sem intervenção externa.",
                                    "Estude exemplos como o Problema da Parada e por que requer oráculo.",
                                    "Escreva uma definição precisa incorporando esses elementos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que um oráculo viola a efetividade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo sobre Problema da Parada",
                                    "Vídeo explicativo sobre oráculos em teoria da computação"
                                  ],
                                  "tips": "Imagine um computador sem 'mágica': tudo deve ser calculado passo a passo.",
                                  "learningObjective": "Entender a proibição de oráculos e a mecânica universal para entradas arbitrárias.",
                                  "commonMistakes": [
                                    "Achar que oráculos são apenas 'rápidos'",
                                    "Não ligar à universalidade das entradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Verificar a Definição Completa",
                                  "subSteps": [
                                    "Combine todos os critérios em uma definição unificada.",
                                    "Crie um exemplo de algoritmo efetivo (ex: multiplicação de inteiros).",
                                    "Teste a definição contra contraexemplos não-efetivos.",
                                    "Refine a definição com base em autoavaliação.",
                                    "Ensine a definição a alguém e ajuste com feedback."
                                  ],
                                  "verification": "Grave um vídeo de 1 minuto explicando a definição completa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gravador de vídeo ou app de notas de voz",
                                    "Exemplos de algoritmos simples"
                                  ],
                                  "tips": "Use a estrutura: 'Computação efetiva é um processo [critérios] aplicado a [entradas].'",
                                  "learningObjective": "Formular uma definição precisa e holística de computação efetiva.",
                                  "commonMistakes": [
                                    "Omitir um critério chave",
                                    "Tornar a definição vaga ou não precisa"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um algoritmo simples para verificar se um número é primo: use loop finito (passos finitos), regras if/else determinísticas, sem oráculos, aplicável a qualquer inteiro positivo arbitrário. Teste com entradas como 17 (primo) e 15 (não primo).",
                              "finalVerifications": [
                                "Pode listar e explicar os quatro critérios principais sem hesitação.",
                                "Diferencia corretamente um processo efetivo de um que usa oráculo.",
                                "Aplica a definição a um exemplo novo com precisão.",
                                "Explica a relevância para a Tese de Church-Turing.",
                                "Identifica falhas em definições incompletas fornecidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inclusão de todos os critérios (passos finitos, determinismo, sem oráculos, mecânica universal).",
                                "Clareza e concisão na explicação intuitiva.",
                                "Uso correto de exemplos e contraexemplos.",
                                "Compreensão da aplicabilidade a entradas arbitrárias.",
                                "Capacidade de sintetizar em uma definição coesa.",
                                "Ausência de confusões com conceitos relacionados (ex: eficiência vs efetividade)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Ligação com funções recursivas e teoria da recursão.",
                                "Filosofia: Discussões sobre decidibilidade e limites do conhecimento humano.",
                                "Lógica: Relação com sistemas formais axiomáticos e provas.",
                                "Engenharia de Software: Fundamento para design de algoritmos corretos e terminantes."
                              ],
                              "realWorldApplication": "Essa definição fundamenta o desenvolvimento de software confiável, como compiladores e verificadores de bugs, garantindo que programas terminem e sejam previsíveis em sistemas críticos como aviões autônomos ou bancos digitais, evitando loops infinitos ou comportamentos indeterminísticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Identificar exemplos de funções efetivas e não efetivas",
                            "description": "Classificar funções matemáticas como efetivamente computáveis (ex.: soma, fatorial) ou não (ex.: função de parada), justificando com base nos critérios intuitivos de efetividade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Critérios Intuitivos de Computação Efetiva",
                                  "subSteps": [
                                    "Revise a definição intuitiva: uma função é efetivamente computável se puder ser calculada por um algoritmo finito que termine em passos finitos para qualquer entrada válida.",
                                    "Identifique os três critérios principais: precisão (passos exatos), finitude (termina em tempo finito) e determinismo (mesmo resultado para mesma entrada).",
                                    "Compare com funções matemáticas gerais que podem ser definidas mas não computadas mecanicamente.",
                                    "Anote exemplos iniciais de ações cotidianas que são 'efetivas' vs. impossíveis mecanicamente.",
                                    "Discuta com um parceiro ou anote por que intuição humana não conta como 'efetiva' no sentido formal."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando os critérios intuitivos e dê um exemplo simples de cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Texto sobre Tese de Church-Turing, caderno para anotações, vídeo introdutório (ex.: Khan Academy ou YouTube sobre computabilidade).",
                                  "tips": "Use analogias como 'receita de bolo' para efetiva vs. 'adivinhar o futuro' para não efetiva.",
                                  "learningObjective": "Dominar os critérios intuitivos para distinguir computação efetiva de funções puramente matemáticas.",
                                  "commonMistakes": "Confundir 'fácil de calcular manualmente' com 'efetivamente computável'; ignorar a necessidade de terminação finita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Exemplos de Funções Efetivamente Computáveis",
                                  "subSteps": [
                                    "Liste funções clássicas: soma de números naturais, fatorial, exponenciação, ordenação de listas.",
                                    "Para cada uma, descreva um algoritmo simples (ex.: loop para soma, recursão para fatorial).",
                                    "Simule execução manual para entradas pequenas (ex.: fatorial(5) = 120 em 5 passos).",
                                    "Implemente uma em pseudocódigo ou Python para visualizar terminação.",
                                    "Classifique por que atendem aos critérios: passos finitos, precisos e determinísticos."
                                  ],
                                  "verification": "Crie uma tabela com 4 funções efetivas, algoritmo breve e prova de terminação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código online (Replit), exemplos de algoritmos de livros como Sipser 'Introduction to the Theory of Computation'.",
                                  "tips": "Comece com funções aritméticas básicas antes de avançar para mais complexas como busca binária.",
                                  "learningObjective": "Reconhecer e justificar funções efetivas com algoritmos explícitos.",
                                  "commonMistakes": "Achar que funções polinomiais são sempre efetivas sem verificar terminação; confundir com eficiência (tempo polinomial)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos de Funções Não Efetivamente Computáveis",
                                  "subSteps": [
                                    "Estude a Função de Parada (Halting Problem): dada uma máquina de Turing e entrada, ela para?",
                                    "Explore outros exemplos: problema da parada generalizado, resolver axiomas indecidíveis (Teorema de Gödel).",
                                    "Tente 'codificar' a função de parada e veja por que leva a paradoxos (diagonalização).",
                                    "Compare com funções efetivas: por que não há algoritmo universal que decida para todas as entradas.",
                                    "Anote justificativas intuitivas: requer 'olhar infinito' ou adivinhação."
                                  ],
                                  "verification": "Escreva uma justificativa de 150 palavras para por que a Função de Parada não é efetiva, citando argumento de Turing.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigo de Turing 'On Computable Numbers', simulador de Máquina de Turing online (ex.: Turing Machine Simulator).",
                                  "tips": "Visualize com diagramas: loops infinitos vs. caminhos finitos.",
                                  "learningObjective": "Identificar funções não computáveis e explicar falhas nos critérios intuitivos.",
                                  "commonMistakes": "Pensar que 'às vezes para' torna efetiva; ignorar casos onde algoritmo falha em decidir."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Classificação e Justificativa de Funções",
                                  "subSteps": [
                                    "Selecione 6 funções mistas (3 efetivas, 3 não) de uma lista ou crie próprias.",
                                    "Para cada, classifique e justifique com critérios intuitivos e exemplo de algoritmo (se aplicável).",
                                    "Debata casos ambíguos com um colega ou autoavaliação.",
                                    "Crie um fluxograma de decisão: 'Tem algoritmo finito? Para sempre? Determinístico?'",
                                    "Teste com função híbrida, como 'paridade de número de 1s em binário' (efetiva)."
                                  ],
                                  "verification": "Submeta relatório com classificações corretas de 6 funções, 100% precisão nas justificativas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Lista de funções de teste (ex.: f(x)=x+1 efetiva; resolver Collatz sempre para? Não efetiva), planilha Google Sheets para tabela.",
                                  "tips": "Use contraexemplos: para não efetiva, mostre entrada onde algoritmo loopa ou erra.",
                                  "learningObjective": "Aplicar critérios para classificar novas funções com justificativas robustas.",
                                  "commonMistakes": "Classificar funções NP-completas como não efetivas (elas são computáveis, só difíceis); justificativas vagas sem referência a terminação."
                                }
                              ],
                              "practicalExample": "Classifique a função 'soma(x,y)' como efetiva: algoritmo 'resultado = 0; enquanto y>0 {resultado +=x; y--;} retorna resultado' termina em y passos finitos. Agora, Função de Parada H(M,e): não efetiva, pois prova de Turing mostra nenhum algoritmo decide para todas M,e sem loop infinito em alguns casos.",
                              "finalVerifications": [
                                "Classifica corretamente 5 funções efetivas e 3 não efetivas de uma lista aleatória.",
                                "Fornece justificativa baseada em critérios intuitivos para cada classificação.",
                                "Simula ou codifica algoritmo para funções efetivas, mostrando terminação.",
                                "Explica paradoxo da diagonalização para Função de Parada.",
                                "Cria fluxograma de decisão para novas funções.",
                                "Identifica erros em classificações incorretas de pares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação (100% correto para exemplos padrão).",
                                "Profundidade da justificativa (cita critérios específicos e contraexemplos).",
                                "Clareza na descrição de algoritmos (pseudocódigo legível e finito).",
                                "Compreensão de limites (explica por que não efetiva sem apelar a 'complexidade').",
                                "Criatividade em exemplos originais (além de padrões como fatorial/parada).",
                                "Uso correto de terminologia (efetivamente computável, terminação, determinismo)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números e indecidibilidade (Gödel).",
                                "Filosofia: Limites do mecanicismo e mente humana (Turing vs. Penrose).",
                                "Lógica: Paradoxos e provas por contradição.",
                                "Programação: Análise de loops infinitos e depuração."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, prever se um programa termina (ex.: verificadores estáticos como em Rust ou análise de dependências em compiladores); em IA, entender limites de modelos de linguagem para tarefas indecidíveis como detecção universal de bugs."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Discutir limitações da intuição humana",
                            "description": "Analisar por que a noção intuitiva de computabilidade precisa de formalização, citando paradoxos históricos como o de Hilbert e o Entscheidungsproblem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Noção Intuitiva de Computabilidade Efetiva",
                                  "subSteps": [
                                    "Defina computação efetiva como procedimentos mecânicos e finitos que humanos podem seguir passo a passo.",
                                    "Explore exemplos intuitivos, como algoritmos manuais para adição ou busca em listas.",
                                    "Discuta suposições intuitivas: todo problema matemático resolvível tem um algoritmo.",
                                    "Identifique ambiguidades na intuição humana, como o que conta como 'passo efetivo'.",
                                    "Compare com processos não efetivos, como adivinhação ou infinitos passos."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a noção intuitiva e liste 3 exemplos efetivos vs. 2 não efetivos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 0); notas pessoais; internet para definições básicas.",
                                  "tips": "Use analogias cotidianas, como receitas de cozinha, para tornar a intuição tangível.",
                                  "learningObjective": "Distinguir computação efetiva intuitiva de processos informais.",
                                  "commonMistakes": "Confundir intuição com formalismo; ignorar finitude dos passos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Programa de Hilbert e o Entscheidungsproblem",
                                  "subSteps": [
                                    "Pesquise o Programa de Hilbert de 1900: 23 problemas, foco em consistência e completude axiomática.",
                                    "Explique o Entscheidungsproblem: existe algoritmo para decidir validade de fórmulas em lógica de primeira ordem?",
                                    "Analise otimismo de Hilbert: matemática finitista e decidível.",
                                    "Colete citações chave de Hilbert sobre 'máquinas matemáticas'.",
                                    "Registre contexto histórico: pós-Russell paradoxo."
                                  ],
                                  "verification": "Crie um timeline visual com eventos chave de Hilbert até 1930 e resuma o Entscheidungsproblem em 100 palavras.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Artigos originais de Hilbert (PDFs online); vídeo Khan Academy sobre história da lógica; papel e caneta para timeline.",
                                  "tips": "Leia fontes primárias resumidas para capturar o tom otimista de Hilbert.",
                                  "learningObjective": "Entender o otimismo formal da era pré-Gödel/Turing.",
                                  "commonMistakes": "Confundir Entscheidungsproblem com halting problem; subestimar escopo do programa de Hilbert."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Paradoxos Históricos que Revelam Limitações Intuitivas",
                                  "subSteps": [
                                    "Estude teoremas de incompletude de Gödel (1931): sistemas consistentes são incompletos.",
                                    "Explique o problema da parada de Turing (1936): indecidibilidade da halting problem.",
                                    "Conecte ao Entscheidungsproblem: Church/Turing provam indecidibilidade.",
                                    "Discuta como intuição falha: assume decidibilidade onde não há.",
                                    "Liste 3 paradoxos adicionais (ex: Berry paradoxo, Richard paradoxo)."
                                  ],
                                  "verification": "Escreva um ensaio curto (300 palavras) ligando Gödel/Turing ao fracasso intuitivo.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Papel 'On Computable Numbers' de Turing (resumo); Gödel's proof vídeo (YouTube); simulador de Máquina de Turing online.",
                                  "tips": "Simule halting problem com exemplos simples para internalizar indecidibilidade.",
                                  "learningObjective": "Identificar paradoxos que minam confiança na intuição humana.",
                                  "commonMistakes": "Simplificar demais Gödel como 'só auto-referência'; ignorar ligação com computabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a Necessidade de Formalização",
                                  "subSteps": [
                                    "Compare intuição pré-1930 vs. formalismos (λ-cálculo, Máquinas de Turing).",
                                    "Argumente por que formalização resolve ambiguidades intuitivas.",
                                    "Discuta Tese de Church-Turing como formalização da intuição.",
                                    "Preveja implicações: limites inerentes à computação.",
                                    "Debata em voz alta ou forum: 'Intuição basta?'"
                                  ],
                                  "verification": "Produza um slide de apresentação ou post de blog concluindo a necessidade de formalismo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de slides (Google Slides); resumos dos steps anteriores.",
                                  "tips": "Use contra-argumentos intuitivos para fortalecer sua posição.",
                                  "learningObjective": "Justificar formalização como resposta às limitações intuitivas.",
                                  "commonMistakes": "Superestimar intuição moderna; ignorar avanços pós-Turing."
                                }
                              ],
                              "practicalExample": "Em um debate de clube de computação, argumente contra um colega que defende 'todo problema prático é computável intuitivamente', usando Hilbert's Entscheidungsproblem e halting problem para mostrar falhas, levando a uma discussão sobre por que usamos Máquinas de Turing em proofs de software.",
                              "finalVerifications": [
                                "Pode explicar Entscheidungsproblem sem erros factuais.",
                                "Lista corretamente 3 paradoxos que desafiam intuição computacional.",
                                "Distingue intuição de formalismo em exemplos dados.",
                                "Cita fontes históricas com precisão (Hilbert 1928, Gödel 1931, Turing 1936).",
                                "Resume Tese de Church-Turing como ponte entre intuição e formalismo.",
                                "Identifica aplicações modernas de limites intuitivos (ex: undecidability em IA)."
                              ],
                              "assessmentCriteria": [
                                "Precisão histórica e citações corretas (30%)",
                                "Profundidade na análise de paradoxos (25%)",
                                "Clareza na distinção intuição vs. formalismo (20%)",
                                "Uso de exemplos concretos e conexões lógicas (15%)",
                                "Estrutura argumentativa coerente (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Filosofia: Paradoxos lógicos e epistemologia (Gödel e limites do saber).",
                                "Matemática: Teoria da prova e lógica formal.",
                                "História da Ciência: Evolução da matemática no séc. XX.",
                                "Inteligência Artificial: Limites de algoritmos em problemas indecidíveis."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, entender limitações intuitivas previne erros em verificação de código (ex: usar model checkers para aproximar halting problem), e em IA ética, alerta para undecidibilidade em tarefas como 'detectar mentiras perfeitamente'."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Modelos Equivalentes de Computação",
                        "description": "Reconhecer os principais modelos formais propostos independentemente para capturar a computação efetiva e suas equivalências comprovadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Descrever a Máquina de Turing padrão",
                            "description": "Explicar o modelo de Máquina de Turing de Alan Turing como um dispositivo formal com fita infinita, cabeça de leitura/escrita e tabela de transições, capaz de simular qualquer procedimento efetivo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes principais da Máquina de Turing",
                                  "subSteps": [
                                    "Pesquise a definição original de Alan Turing para Máquina de Turing (1936).",
                                    "Liste os componentes fundamentais: fita infinita dividida em células, cabeça de leitura/escrita, conjunto finito de estados, alfabeto de símbolos, tabela de transições, estados inicial, de aceitação e rejeição.",
                                    "Desenhe um diagrama esquemático mostrando a fita, cabeça e estados.",
                                    "Explique o papel de cada componente em uma frase curta."
                                  ],
                                  "verification": "Crie um diagrama rotulado com todos os componentes e explique oralmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de desenho (ex: Draw.io)",
                                    "Artigo 'On Computable Numbers' de Turing ou resumo confiável (Wikipedia/Khan Academy)"
                                  ],
                                  "tips": "Use analogia com um gravador de fita antigo para visualizar a fita e cabeça.",
                                  "learningObjective": "Identificar e descrever os componentes essenciais de uma Máquina de Turing padrão.",
                                  "commonMistakes": [
                                    "Confundir fita com memória finita de computadores reais",
                                    "Ignorar estados de aceitação/rejeição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o funcionamento da fita infinita e cabeça de leitura/escrita",
                                  "subSteps": [
                                    "Descreva a fita como bi-infinita ou uni-infinita com células contendo símbolos de Γ (incluindo blank).",
                                    "Explique movimentos da cabeça: Left (L), Right (R) ou Stay (S).",
                                    "Simule um passo: leia símbolo atual, escreva novo, mova cabeça, mude estado.",
                                    "Discuta inicialização: cabeça na posição 0, estado inicial q0, fita com input e blanks."
                                  ],
                                  "verification": "Simule manualmente 3 passos de uma execução simples em papel.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado para simular fita",
                                    "Marcadores coloridos"
                                  ],
                                  "tips": "Comece com input simples como '11' em unário para soma.",
                                  "learningObjective": "Compreender como a fita e cabeça gerenciam dados e controle.",
                                  "commonMistakes": [
                                    "Assumir fita finita",
                                    "Esquecer que símbolos podem ser sobrescritos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a tabela de transições e controle de estados",
                                  "subSteps": [
                                    "Defina a função de transição δ: Q × Γ → Q × Γ × {L,R,S}.",
                                    "Construa uma tabela simples com estados q0, q1, símbolos 0/1/blank.",
                                    "Explique halting: transições indefinidas levam a reject ou loops.",
                                    "Exemplo: δ(q0,1) = (q1,1,R)."
                                  ],
                                  "verification": "Crie e preencha uma tabela de transições para uma MT que reconhece strings pares de 1s.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Exemplos de MTs simples online"
                                  ],
                                  "tips": "Pense na tabela como 'if-then' para o robô da MT.",
                                  "learningObjective": "Modelar o controle sequencial via estados e transições.",
                                  "commonMistakes": [
                                    "Confundir δ parcial com total",
                                    "Ignorar direção de movimento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar a MT com simulação de procedimentos efetivos",
                                  "subSteps": [
                                    "Explique a Tese de Church-Turing: toda função computável por algoritmo é por MT.",
                                    "Discuta universal MT: simula qualquer outra MT.",
                                    "Descreva como MT simula computadores reais (via código como input).",
                                    "Compare com lambda-calculo ou registradoras."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que MT é equivalente a qualquer modelo efetivo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Textos sobre Tese de Church-Turing",
                                    "Vídeos explicativos (ex: YouTube CS channels)"
                                  ],
                                  "tips": "Foquem em 'procedimento efetivo' como passos finitos determinísticos.",
                                  "learningObjective": "Entender o poder universal da MT na teoria da computação.",
                                  "commonMistakes": [
                                    "Confundir simulação com eficiência prática",
                                    "Subestimar halting problem"
                                  ]
                                }
                              ],
                              "practicalExample": "Descreva uma MT padrão que soma dois números unários separados por 0 (ex: input 11 0 1 = output 111). Componentes: fita com 1101..., cabeça inicia em 1º 1, estados para ler primeiro, mover, ler segundo, somar movendo cabeça.",
                              "finalVerifications": [
                                "Lista corretamente os 7 elementos formais da MT (Q, Σ, Γ, δ, q0, q_acc, q_rej).",
                                "Explica δ(q,a)=(q',b,D) com exemplo.",
                                "Simula 5 passos de execução sem erros.",
                                "Descreve halting conditions.",
                                "Relaciona à Tese de Church-Turing."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de componentes (100% cobertura).",
                                "Clareza na explicação de transições e execução.",
                                "Uso correto de terminologia formal.",
                                "Capacidade de diagramação visual.",
                                "Conexão com universalidade computacional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções parciais recursivas e teoria dos conjuntos.",
                                "História: Contribuições de Turing na WWII e IA.",
                                "Filosofia: Limites da computação (problema da parada).",
                                "Lógica: Teoremas de incompletude de Gödel.",
                                "Física: Modelos quânticos de computação (QTM)."
                              ],
                              "realWorldApplication": "A MT padrão fundamenta a teoria da computação, definindo o que é 'computável', influenciando design de algoritmos, análise de complexidade em software (ex: P vs NP), compiladores e limites de IA/hardware moderno."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Apresentar o λ-cálculo de Church",
                            "description": "Definir o λ-cálculo tipado e não tipado de Alonzo Church, mostrando como ele define funções computáveis via abstração e aplicação, equivalente ao poder das MT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introdução Histórica e Conceitual ao λ-Cálculo",
                                  "subSteps": [
                                    "Pesquise a biografia de Alonzo Church e o contexto da década de 1930 na lógica matemática.",
                                    "Estude a Tese de Church-Turing e como o λ-cálculo foi proposto como modelo de computação.",
                                    "Compare brevemente com Máquinas de Turing (MT) como modelos equivalentes.",
                                    "Identifique funções computáveis via abstração e aplicação no λ-cálculo.",
                                    "Anote diferenças iniciais entre λ-cálculo tipado e não tipado."
                                  ],
                                  "verification": "Resuma em um parágrafo a motivação histórica e a tese de equivalência com MT.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigo original de Church (opcional PDF)",
                                    "Livro 'Lambda-Calculus and Combinators' de Hindley",
                                    "Vídeo introdutório no YouTube sobre Tese Church-Turing"
                                  ],
                                  "tips": [
                                    "Comece com analogias simples: λ como 'função anônima' em JavaScript.",
                                    "Use diagramas para mostrar equivalência MT ↔ λ."
                                  ],
                                  "learningObjective": "Compreender o contexto histórico e a equivalência teórica do λ-cálculo com MT.",
                                  "commonMistakes": [
                                    "Confundir λ-cálculo com cálculo λ de Church sem contexto histórico.",
                                    "Ignorar a Tese de Church-Turing ao introduzir o modelo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Sintaxe do λ-Cálculo Não Tipado",
                                  "subSteps": [
                                    "Aprenda os elementos básicos: variáveis (x, y), abstrações (λx.M), aplicações (M N).",
                                    "Estude regras de escopo livre e ligado (free/bound variables).",
                                    "Pratique notação: escreva exemplos como λx.x (identidade) e (λx.x y).",
                                    "Defina termos válidos e bem-formados.",
                                    "Exercite α-conversão para renomeação de variáveis ligadas."
                                  ],
                                  "verification": "Escreva 5 termos λ válidos e identifique variáveis livres em cada um.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de referência sintática do λ-cálculo",
                                    "Editor de texto ou Jupyter Notebook para testes",
                                    "Ferramenta online como lambda calculus reducer"
                                  ],
                                  "tips": [
                                    "Sempre parentese aplicações para clareza: ((λx.x) y).",
                                    "Pratique com combinadores fixos como I = λx.x."
                                  ],
                                  "learningObjective": "Dominar a sintaxe precisa do λ-cálculo não tipado.",
                                  "commonMistakes": [
                                    "Esquecer parênteses em aplicações aninhadas.",
                                    "Confundir variáveis livres com ligadas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Semântica: Abstração, Aplicação e Redução β",
                                  "subSteps": [
                                    "Defina abstração: λx.M cria funções que aplicam M a x.",
                                    "Explique aplicação: (λx.M) N substitui x por N em M.",
                                    "Aprenda redução β: ((λx.M) N) → [N/x]M, com substituição cautelosa.",
                                    "Estude normalização e Church-Rosser theorem brevemente.",
                                    "Implemente reduções passo a passo em exemplos como sucessor de números de Church."
                                  ],
                                  "verification": "Reduza ((λx.λy.x) z w) para forma normal e explique cada passo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora λ online (ex: lambdacalculator.com)",
                                    "Exemplos de números de Church",
                                    "Papel e caneta para reduções manuais"
                                  ],
                                  "tips": [
                                    "Substitua evitando captura de variáveis livres.",
                                    "Use convenções de De Bruijn para índices se avançado."
                                  ],
                                  "learningObjective": "Executar e entender reduções que simulam computação.",
                                  "commonMistakes": [
                                    "Substituição incorreta levando a captura variável.",
                                    "Parar redução prematuramente sem normal form."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "λ-Cálculo Tipado e Equivalência com Máquinas de Turing",
                                  "subSteps": [
                                    "Introduza λ-cálculo tipado simply typed: tipos base, → para funções.",
                                    "Aprenda inferência de tipos e sistema hindley-milner básico.",
                                    "Discuta como λ-cálculo codifica MT: encoding de estados, fita, etc.",
                                    "Compare poder expressivo: não tipado Turing-completo, tipado com strong normalization.",
                                    "Exemplo: encode identidade tipada λx:X.x : X → X."
                                  ],
                                  "verification": "Escreva um termo tipado para NOT booleano e prove equivalência conceitual com MT.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Types and Programming Languages' de Pierce (capítulos iniciais)",
                                    "Simulador MT para comparação",
                                    "Notas sobre encoding Church numerals"
                                  ],
                                  "tips": [
                                    "Tipos evitam paradoxos como Ω = (λx.x x)(λx.x x).",
                                    "Pense em MT como interpretador de λ-termo."
                                  ],
                                  "learningObjective": "Diferenciar tipado/não tipado e estabelecer equivalência formal com MT.",
                                  "commonMistakes": [
                                    "Achar tipado Turing-completo (não é).",
                                    "Ignorar encoding explícito de MT em λ."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente números de Church no λ-cálculo: 0 = λf.λx.x, 1 = λf.λx.f x, SUC = λn.λf.λx.f (n f x). Reduza SUC 1 para obter 2, simulando aritmética em funções puras, equivalente a uma MT contando.",
                              "finalVerifications": [
                                "Escrever e reduzir corretamente um termo λ complexo com abstração e aplicação.",
                                "Identificar variáveis livres e realizar α/β-reduções sem erros.",
                                "Diferenciar sintaxe/semântica de λ não tipado vs tipado.",
                                "Explicar como λ-cálculo define funções computáveis via Tese Church-Turing.",
                                "Codificar uma função simples (ex: AND booleano) em λ e tipá-la.",
                                "Comparar encoding de MT em λ com exemplo concreto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe e regras de redução (sem erros de substituição).",
                                "Compreensão conceitual da equivalência com MT (explicação clara).",
                                "Capacidade de diferenciar λ tipado (normalização forte) vs não tipado (Turing-completo).",
                                "Uso correto de exemplos práticos como combinadores e números de Church.",
                                "Profundidade em verificações: identificando erros comuns em reduções.",
                                "Criatividade em aplicações reais, ligando a programação funcional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de predicados e teoria de tipos.",
                                "Programação: Paradigma funcional em Haskell/ML/Lisp.",
                                "Filosofia: Fundamentos da computação e decidibilidade.",
                                "Lógica: Teorema de Church-Rosser e normalização."
                              ],
                              "realWorldApplication": "O λ-cálculo fundamenta linguagens funcionais como Haskell e Scala, usadas em big data (Spark), IA (TensorFlow graphs) e verificação formal (Coq/Agda), permitindo provas matemáticas de correção de software e otimização de compiladores."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Comparar modelos de computação",
                            "description": "Demonstrar a equivalência entre Máquinas de Turing, funções recursivas parciais de Gödel-Herbrand-Kleene e λ-cálculo, citando teoremas de normalização e simulação mútua.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais dos Modelos de Computação",
                                  "subSteps": [
                                    "Ler e resumir a definição formal de Máquina de Turing (MT), incluindo fita, cabeçote e tabela de transições.",
                                    "Estudar funções recursivas parciais (PRF) de Gödel-Herbrand-Kleene: composição, recursão primitiva e minimização μ-operador.",
                                    "Analisar λ-cálculo: termos λ-abstraídos, aplicação, β-redução e η-conversão.",
                                    "Criar um glossário comparativo com notação e exemplos simples para cada modelo.",
                                    "Identificar funções computáveis básicas (ex: sucessor, projeção) em cada modelo."
                                  ],
                                  "verification": "Produzir um documento de 1-2 páginas com definições resumidas e glossário comparativo sem erros conceituais.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Livro 'Introduction to the Theory of Computation' de Sipser; notas de aula sobre λ-cálculo; Wikipedia para referências rápidas.",
                                  "tips": "Use diagramas para visualizar MT e árvores de derivação para λ-cálculo para melhor retenção.",
                                  "learningObjective": "Compreender precisamente as mecânicas operacionais de MT, PRF e λ-cálculo.",
                                  "commonMistakes": "Confundir recursão primitiva com recursão total; ignorar o aspecto parcial das PRF."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Simulações Mútuas entre os Modelos",
                                  "subSteps": [
                                    "Investigar como uma MT universal simula qualquer MT, e como codificar MT em λ-cálculo (usando Church numerals).",
                                    "Aprender a simular PRF em MT via codificação de números de Gödel.",
                                    "Explorar simulação de λ-cálculo em PRF usando teorema de Curry-Howard (básico).",
                                    "Implementar um exemplo simples: codificar a função sucessor em cada modelo e mostrar tradução mútua.",
                                    "Verificar simulações bidirecionais: MT → PRF → λ e vice-versa."
                                  ],
                                  "verification": "Escrever pseudocódigo ou expressões λ para simular uma MT simples em λ-cálculo, com testes manuais.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Artigo 'Lambda Calculus and Turing Machines' online; simulador de MT como JFLAP; editor de texto para λ-termos.",
                                  "tips": "Comece com funções aritméticas simples como adição para testar simulações antes de universais.",
                                  "learningObjective": "Dominar as construções de simulação que provam poder computacional equivalente.",
                                  "commonMistakes": "Esquecer de lidar com não-terminação em simulações parciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Teoremas de Normalização e Equivalência",
                                  "subSteps": [
                                    "Estudar o Teorema de Church-Rosser para λ-cálculo: normalização forte e confluence.",
                                    "Revisar provas de equivalência: Kleene para PRF ≡ MT; Church para λ ≡ MT.",
                                    "Citar teoremas de simulação mútua: toda PRF é computável por MT, e toda MT computa uma PRF.",
                                    "Comparar classes de funções: mostrar que todas capturam exatamente as funções recursivas parciais.",
                                    "Discutir implicações da Tese de Church-Turing como hipótese unificadora."
                                  ],
                                  "verification": "Redigir um ensaio curto (500 palavras) citando teoremas com referências e explicando normalização.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Papel 'On Computable Functions' de Kleene; capítulos de 'Computability and Logic' de Boolos.",
                                  "tips": "Use provas por contradição para teoremas de equivalência para clareza lógica.",
                                  "learningObjective": "Aplicar teoremas formais para justificar a equivalência teórica.",
                                  "commonMistakes": "Confundir normalização com terminação; ignorar variantes tipadas de λ-cálculo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Comparação Prática e Sintetizar Equivalência",
                                  "subSteps": [
                                    "Escolher uma função não-trivial (ex: máquina de Ackermann parcial) e implementá-la em cada modelo.",
                                    "Comparar eficiência, expressividade e limitações (ex: legibilidade em λ vs MT).",
                                    "Criar uma tabela comparativa: poder, determinismo, paralelismo implícito em λ.",
                                    "Argumentar equivalência citando simulações e teoremas estudados.",
                                    "Testar com exemplos de funções indecidíveis para mostrar limites comuns."
                                  ],
                                  "verification": "Produzir uma tabela comparativa e demonstração de Ackermann em pelo menos dois modelos.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Simulador λ-calculus online (lambda.js); papel e lápis para tabelas.",
                                  "tips": "Foque em funções que crescem rápido para destacar poder equivalente apesar de sintaxes diferentes.",
                                  "learningObjective": "Sintetizar conhecimentos em uma comparação coesa demonstrando equivalência.",
                                  "commonMistakes": "Superestimar diferenças superficiais como prova de desigualdade computacional."
                                }
                              ],
                              "practicalExample": "Implemente a função de fatorial parcial em MT (via contador em fita), PRF (usando recursão μ) e λ-cálculo (Church numerals com recursão Y-combinator). Mostre reduções passo a passo e simulações mútuas para provar que computam o mesmo.",
                              "finalVerifications": [
                                "Explicar verbalmente a simulação de uma MT em λ-cálculo sem hesitação.",
                                "Codificar corretamente uma PRF simples em termos λ.",
                                "Citar pelo menos três teoremas de equivalência com autores.",
                                "Identificar uma função indecidível comum a todos os modelos.",
                                "Comparar prós/contras de cada modelo em uma aplicação real.",
                                "Resolver um exercício de normalização λ em menos de 10 minutos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e teoremas citados (sem erros factuais).",
                                "Profundidade das simulações mútuas demonstradas.",
                                "Clareza na tabela comparativa e exemplos práticos.",
                                "Compreensão da Tese de Church-Turing e suas implicações.",
                                "Criatividade em conexões entre modelos e aplicações.",
                                "Capacidade de debater limitações e equivalências."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica matemática e teoria dos números de Gödel.",
                                "Filosofia: Fundamentos da computabilidade e mente-computador.",
                                "Programação: Paradigmas funcionais (Haskell/Lisp) vs imperativos.",
                                "Lógica: Teoremas de confluence e provas por indução.",
                                "História da Ciência: Evolução dos modelos na década de 1930."
                              ],
                              "realWorldApplication": "Essa equivalência fundamenta compiladores modernos (ex: traduzir código funcional para assembly via simulações), validação de linguagens de programação e debates sobre IA, garantindo que qualquer algoritmo expressível em uma forma seja implementável em hardware (MT-like)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Enunciado e Natureza da Tese de Church-Turing",
                        "description": "Formular a tese de Church-Turing, entender sua natureza como hipótese não provável e explorar evidências e implicações.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Enunciar a Tese de Church-Turing",
                            "description": "Estabelecer formalmente a tese: 'Toda função efetivamente computável é computável por uma Máquina de Turing', diferenciando-a de teoremas por sua base intuitiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender funções efetivamente computáveis",
                                  "subSteps": [
                                    "Ler definições clássicas de computabilidade efetiva de autores como Turing e Church.",
                                    "Identificar características de funções efetivas: algoritmos finitos, determinísticos e mecânicos.",
                                    "Analisar exemplos de funções computáveis (soma, multiplicação) versus não-computáveis (problema da parada).",
                                    "Discutir informalmente o que significa 'efetivamente computável' em termos intuitivos.",
                                    "Resumir em suas palavras o conceito de efetividade computacional."
                                  ],
                                  "verification": "Escrever um parágrafo definindo 'função efetivamente computável' e listar 3 exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro 'Computability and Logic' de Boolos ou equivalentes online",
                                    "Artigos sobre história da computabilidade",
                                    "Notas pessoais"
                                  ],
                                  "tips": "Foquem na intuição humana de 'algoritmo manual' para evitar abstrações excessivas.",
                                  "learningObjective": "Dominar a noção intuitiva de computabilidade efetiva como base para a tese.",
                                  "commonMistakes": [
                                    "Confundir com computabilidade total",
                                    "Ignorar o aspecto mecânico e finito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar o modelo da Máquina de Turing",
                                  "subSteps": [
                                    "Desenhar o diagrama básico de uma Máquina de Turing (fita, cabeça, estados, tabela de transições).",
                                    "Simular manualmente uma MT simples que computa soma de dois números.",
                                    "Explicar como MTs podem simular qualquer algoritmo efetivo.",
                                    "Listar propriedades universais das MTs (universalidade, simulação mútua).",
                                    "Comparar MT com outros modelos (λ-cálculo, registradoras)."
                                  ],
                                  "verification": "Construir e simular uma MT para uma função simples, como incremento de um número.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador online de Máquinas de Turing (ex: Turing Machine Simulator)",
                                    "Papel e lápis para desenhos",
                                    "Vídeos tutoriais sobre MT"
                                  ],
                                  "tips": "Use simuladores interativos para visualizar transições em tempo real.",
                                  "learningObjective": "Entender MT como modelo padrão de computação geral.",
                                  "commonMistakes": [
                                    "Esquecer a fita infinita",
                                    "Confundir MT determinística com não-determinística"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o enunciado formal da Tese de Church-Turing",
                                  "subSteps": [
                                    "Memorizar o enunciado exato: 'Toda função efetivamente computável é computável por uma Máquina de Turing'.",
                                    "Escrever variações equivalentes (ex: computável por λ-cálculo, registradoras).",
                                    "Praticar recitação oral do enunciado em voz alta.",
                                    "Explicar cada termo: 'efetivamente computável', 'Máquina de Turing'.",
                                    "Criar um fluxograma visualizando a tese."
                                  ],
                                  "verification": "Recitar e escrever o enunciado sem consultar materiais, com definição precisa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referências originais: 'On Computable Numbers' de Turing",
                                    "Flashcards para memorização",
                                    "Gravador de áudio"
                                  ],
                                  "tips": "Associe o enunciado a uma imagem mental de uma MT resolvendo problemas humanos.",
                                  "learningObjective": "Enunciar com precisão e fluência a tese formal.",
                                  "commonMistakes": [
                                    "Omitir 'efetivamente'",
                                    "Inverter a direção da equivalência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar a tese de um teorema matemático",
                                  "subSteps": [
                                    "Comparar teses (intuitivas, não prováveis formalmente) com teoremas (provados axiomaticamente).",
                                    "Analisar evidências empíricas: simulações de algoritmos em MTs.",
                                    "Discutir contra-argumentos históricos (ex: máquinas oráculos).",
                                    "Explicar por que a tese é aceita universalmente apesar de não ser provada.",
                                    "Debater em um fórum ou autoquestionamento: 'Por que não é um teorema?'"
                                  ],
                                  "verification": "Escrever um texto curto (200 palavras) diferenciando tese de teorema, com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo 'The Church-Turing Thesis' na Wikipedia ou Stanford Encyclopedia",
                                    "Fórum de discussão online",
                                    "Modelo de redação comparativa"
                                  ],
                                  "tips": "Use analogias: tese como 'água molha' vs. teorema como '2+2=4'.",
                                  "learningObjective": "Compreender a natureza não-formal e intuitiva da tese.",
                                  "commonMistakes": [
                                    "Tratar como teorema provado",
                                    "Ignorar evidências empíricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma apresentação acadêmica sobre limites da computação, você enuncia claramente a Tese de Church-Turing, explica sua intuição e diferencia de teoremas, convencendo colegas de que problemas indecidíveis existem independentemente do hardware.",
                              "finalVerifications": [
                                "Recitar o enunciado exato sem erros.",
                                "Explicar 'efetivamente computável' com exemplos.",
                                "Desenhar uma MT simples e relacioná-la à tese.",
                                "Diferenciar corretamente tese de teorema.",
                                "Identificar 2 evidências de suporte à tese.",
                                "Discutir implicações para problemas indecidíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão no enunciado (100% correto).",
                                "Clareza na diferenciação intuitiva vs. formal.",
                                "Uso de exemplos concretos e relevantes.",
                                "Profundidade na compreensão de computabilidade.",
                                "Capacidade de aplicação em contextos reais.",
                                "Fluência oral e escrita no tema."
                              ],
                              "crossCurricularConnections": [
                                "Filosofia da Mente: Intuição humana vs. mecânica.",
                                "Matemática: Lógica formal e indecidibilidade (Gödel).",
                                "História da Ciência: Desenvolvimento da computação teórica.",
                                "Física: Modelos computacionais quânticos e teses estendidas."
                              ],
                              "realWorldApplication": "Na programação de IA e software, a tese guia o design de algoritmos, alertando para limites inerentes (ex: detecção automática de halting), influenciando criptografia, verificação de software e debates sobre superinteligência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Explicar por que a tese não é provável",
                            "description": "Argumentar que a tese é uma afirmação sobre a intuição humana, não passível de prova formal, mas suportada por convergência de modelos independentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Enunciado e Natureza da Tese de Church-Turing",
                                  "subSteps": [
                                    "Leia e resuma o enunciado clássico da tese: 'Toda função computável efetivamente é computável por uma Máquina de Turing.'",
                                    "Identifique termos chave como 'computável efetivamente' e explique por que eles são intuitivos, não formais.",
                                    "Compare com teoremas provados, como o Teorema de Normalização do λ-cálculo.",
                                    "Anote exemplos de modelos equivalentes: Máquinas de Turing, λ-cálculo, registradores.",
                                    "Discuta brevemente por que a equivalência entre modelos é provada, mas a tese geral não."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras do enunciado e sua natureza não-formal; verifique se menciona intuição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Teoria da Computação (ex: Sipser), notas de aula sobre Church-Turing.",
                                  "tips": "Use analogias cotidianas para 'efetivamente computável', como seguir uma receita manualmente.",
                                  "learningObjective": "Compreender a distinção entre tese intuitiva e teorema formal.",
                                  "commonMistakes": "Confundir a tese com um teorema provado; ignorar o termo 'efetivamente'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Por Que a Tese Não Pode Ser Provada Formalmente",
                                  "subSteps": [
                                    "Defina 'prova formal' em matemática: axiomas + lógica dedutiva.",
                                    "Argumente que 'computável efetivamente' não é definido formalmente; é pré-formal.",
                                    "Explore o problema: provar requer definir o universo de funções intuitivas, levando a circularidade.",
                                    "Discuta Gödel: incompletude impede capturar toda intuição humana em axiomas finitos.",
                                    "Escreva uma contra-argumentação hipotética e refute-a."
                                  ],
                                  "verification": "Crie um diagrama mostrando por que prova formal falha; inclua seta para circularidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos sobre filosofia da mente computacional, quadro branco ou software de diagramação (ex: Draw.io).",
                                  "tips": "Pense em 'prova' como jogo com regras fixas; intuição humana quebra as regras.",
                                  "learningObjective": "Explicar limitações lógicas de formalização da intuição.",
                                  "commonMistakes": "Achar que falta de contra-exemplo prova a tese; confundir com falsificabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Papel da Intuição Humana na Tese",
                                  "subSteps": [
                                    "Defina intuição como julgamento humano não-algorítmico sobre efetividade.",
                                    "Argumente que a tese é uma generalização sobre capacidades humanas de computação.",
                                    "Compare com outras teses científicas (ex: continuidade do espaço-tempo).",
                                    "Discuta evidências psicológicas: humanos usam MT-like processos para computar.",
                                    "Reflita: se intuição muda (ex: com IA), a tese pode evoluir."
                                  ],
                                  "verification": "Registre um áudio de 2 minutos explicando 'tese como intuição'; transcreva e autoavalie clareza.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Gravador de voz, resumo de filosofia da computação (ex: Turing's original paper).",
                                  "tips": "Use 'intuição' como 'olho humano para padrões'; não como mágica.",
                                  "learningObjective": "Vincular a tese à psicologia cognitiva humana.",
                                  "commonMistakes": "Reduzir intuição a algoritmo; ignorar subjetividade humana."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Suporte via Convergência de Modelos Independentes",
                                  "subSteps": [
                                    "Liste modelos independentes: MT, λ-cálculo, máquinas de registradores, recursão primitiva.",
                                    "Explique 'convergência': todos capturam as mesmas funções apesar de origens diferentes.",
                                    "Argumente que isso suporta intuição compartilhada, não prova formal.",
                                    "Discuta contra-exemplos potenciais (ex: oráculos) e por que não refutam.",
                                    "Sintetize: convergência é evidência empírica forte para a tese."
                                  ],
                                  "verification": "Monte uma tabela comparando 4 modelos e suas equivalências; verifique completude.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Planilha (Google Sheets), referências sobre equivalências computacionais.",
                                  "tips": "Visualize convergência como rios independentes chegando ao mesmo oceano.",
                                  "learningObjective": "Usar evidência empírica para apoiar teses não-prováveis.",
                                  "commonMistakes": "Confundir convergência com prova; omitir independência histórica dos modelos."
                                }
                              ],
                              "practicalExample": "Em um debate acadêmico sobre limites da IA, argumente: 'A Tese de Church-Turing não é provável porque \"computável efetivamente\" reflete intuição humana não-axiomatizável, como provado pela incompletude de Gödel; porém, a convergência de MT, λ-cálculo e registradores fornece suporte empírico robusto, similar a teses físicas não-provadas.'",
                              "finalVerifications": [
                                "Explica corretamente que a tese é sobre intuição, não definição formal.",
                                "Identifica pelo menos 3 modelos convergentes como suporte.",
                                "Refuta argumento de 'provada por falta de contra-exemplos'.",
                                "Menciona limitações formais (ex: Gödel) sem erros.",
                                "Sintetiza argumento em parágrafo coeso de 150 palavras.",
                                "Distingue tese de teoremas equivalentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: ausência de confusões entre tese e teorema (30%)",
                                "Profundidade argumentativa: cobertura de intuição e convergência (25%)",
                                "Clareza e estrutura: lógica sequencial no raciocínio (20%)",
                                "Uso de evidências: citação correta de modelos e teoremas (15%)",
                                "Originalidade: analogias ou exemplos pessoais relevantes (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Filosofia da Ciência: teses vs. teorias falsificáveis (Popper)",
                                "Epistemologia: limites do conhecimento formal (Gödel)",
                                "Psicologia Cognitiva: modelagem da intuição computacional humana",
                                "História da Computação: contribuições de Church, Turing e Kleene"
                              ],
                              "realWorldApplication": "Em discussões sobre computação quântica ou hipercomputação, usar este argumento para explicar por que novas máquinas não refutam necessariamente a tese, guiando investimentos em pesquisa de IA e limites algorítmicos em software crítico (ex: verificação de segurança em sistemas autônomos)."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Discutir evidências e implicações",
                            "description": "Apresentar evidências históricas (trabalhos de Church e Turing em 1936) e implicações como a universalidade da MT e limites da computação (indecidibilidade).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar e resumir os trabalhos originais de Church e Turing em 1936",
                                  "subSteps": [
                                    "Ler o artigo de Alonzo Church sobre cálculo lambda e sua solução para o Entscheidungsproblem.",
                                    "Estudar a descrição de Alan Turing da Máquina de Turing (MT) como modelo de computação.",
                                    "Identificar como ambos os trabalhos convergem para mostrar que funções computáveis são equivalentes.",
                                    "Compilar um resumo cronológico das publicações de 1936.",
                                    "Comparar os formalismos: lambda calculus vs. MT."
                                  ],
                                  "verification": "Escrever um resumo de 300 palavras citando fontes primárias ou secundárias precisas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos originais (disponíveis em archive.org), livro 'Introduction to the Theory of Computation' de Sipser (cap. 7), resumos online da Stanford Encyclopedia of Philosophy.",
                                  "tips": "Use timelines visuais para conectar eventos históricos.",
                                  "learningObjective": "Compreender as contribuições históricas específicas que formam a base empírica da Tese de Church-Turing.",
                                  "commonMistakes": "Confundir datas (Church publicou em maio, Turing em julho) ou ignorar o contexto do Entscheidungsproblem de Hilbert."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o conceito de universalidade da Máquina de Turing",
                                  "subSteps": [
                                    "Definir Máquina de Turing Universal (UTM) como uma MT que simula qualquer outra MT.",
                                    "Descrever o encoding de estados, transições e fita em uma fita única da UTM.",
                                    "Demonstrar com um exemplo simples: simular uma MT que soma dois números.",
                                    "Discutir evidências: provas de Turing mostrando que funções recursivas primitivas são computáveis por MT.",
                                    "Relacionar à tese: UTM suporta a ideia de um modelo único de computação."
                                  ],
                                  "verification": "Construir um diagrama da UTM simulando uma MT simples e explicar em voz alta.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador online de MT (turingmachinesimulator.com), pseudocódigo de UTM de Sipser.",
                                  "tips": "Comece com MTs mínimas para visualizar a simulação antes de generalizar.",
                                  "learningObjective": "Dominar a evidência chave da universalidade como suporte à tese de Church-Turing.",
                                  "commonMistakes": "Confundir universalidade com onipotência; UTM simula, mas não resolve problemas indecidíveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar implicações para limites da computação, focando em indecidibilidade",
                                  "subSteps": [
                                    "Explicar o Problema da Parada (Halting Problem) e sua prova por Turing via diagonalização.",
                                    "Discutir teoremas derivados: undecidibilidade de linguagens regulares avançadas (Rice's Theorem).",
                                    "Relacionar à tese: mostra limites inerentes a qualquer modelo equivalente à MT.",
                                    "Explorar implicações filosóficas: o que não é computável (ex: consciência?).",
                                    "Citar evidências modernas: verificação de software limitada por indecidibilidade."
                                  ],
                                  "verification": "Escrever uma prova esboçada do Halting Problem em 200 palavras.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Vídeo de Khan Academy sobre Halting Problem, capítulo 4 de Sipser.",
                                  "tips": "Use analogias como 'prever se um programa para' para intuitivar.",
                                  "learningObjective": "Articular como a tese implica limites fundamentais na computação.",
                                  "commonMistakes": "Acreditar que indecidibilidade significa 'impossível resolver'; é sobre algoritmos gerais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar evidências e implicações em uma discussão coerente",
                                  "subSteps": [
                                    "Estruturar um argumento: introdução histórica → evidências → universalidade → implicações.",
                                    "Praticar verbalmente: gravar uma apresentação de 5 minutos.",
                                    "Incorporar contra-argumentos: hipercomputação quântica vs. tese clássica.",
                                    "Revisar para precisão e fluxo lógico.",
                                    "Receber feedback de pares ou autoavaliação."
                                  ],
                                  "verification": "Gravar e transcrever uma discussão de 5 minutos cobrindo todos os pontos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Gravador de áudio/app (Voice Recorder), rubrica de autoavaliação.",
                                  "tips": "Use transições como 'Isso leva à implicação de...' para coesão.",
                                  "learningObjective": "Sintetizar conhecimentos em uma discussão persuasiva e estruturada.",
                                  "commonMistakes": "Sobrecarregar com jargão sem explicar; manter acessível."
                                }
                              ],
                              "practicalExample": "Em um seminário de IA, discuta como a tese explica por que nenhum algoritmo geral pode prever se uma rede neural divergir, citando Turing 1936 e halting problem, evitando promessas irrealistas de 'IA onisciente'.",
                              "finalVerifications": [
                                "Citar corretamente trabalhos de Church (maio 1936) e Turing (julho 1936).",
                                "Explicar UTM com exemplo de simulação.",
                                "Provar informalmente o halting problem.",
                                "Discutir pelo menos duas implicações (universalidade e indecidibilidade).",
                                "Integrar em narrativa coerente sem erros factuais.",
                                "Responder perguntas sobre contra-argumentos."
                              ],
                              "assessmentCriteria": [
                                "Precisão histórica e técnica (30%)",
                                "Clareza e estrutura lógica da discussão (25%)",
                                "Profundidade de evidências e implicações (20%)",
                                "Uso de exemplos concretos (15%)",
                                "Capacidade de responder objeções (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica e teoria da computabilidade (Gödel's incompleteness).",
                                "Filosofia: Natureza da mente e computabilidade (Searle vs. Turing).",
                                "História da Ciência: Desenvolvimento da teoria da computação pré-WWII.",
                                "Ética em Computação: Limites em IA e privacidade algorítmica."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, entender indecidibilidade guia o design de ferramentas como linters e verificadores estáticos, evitando buscas por soluções impossíveis e focando em heurísticas práticas, como no GitHub Copilot que não garante ausência de loops infinitos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.4",
                            "name": "Relacionar com indecidibilidade",
                            "description": "Conectar a tese aos resultados de indecidibilidade de Turing, mostrando que problemas não efetivos estão fora do escopo das MT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos da Tese de Church-Turing",
                                  "subSteps": [
                                    "Leia a definição formal da Tese de Church-Turing: toda função efetivamente computável é computável por uma Máquina de Turing (MT).",
                                    "Identifique os modelos equivalentes (λ-cálculo, recursão primitiva) e por que eles capturam a noção intuitiva de computação.",
                                    "Discuta a natureza conjectural da tese versus os teoremas de equivalência entre modelos.",
                                    "Anote exemplos de funções computáveis que MTs podem resolver.",
                                    "Compare com funções intuitivamente 'computáveis' mas não formalizadas."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando a tese e liste 3 exemplos de computabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Teoria da Computação (ex: Sipser), notas de aula sobre MTs, quadro branco.",
                                  "tips": "Use analogias como 'MT como o padrão ouro da computação' para fixar a ideia central.",
                                  "learningObjective": "Compreender a tese como delimitação do que é efetivamente computável via MT.",
                                  "commonMistakes": "Confundir a tese (conjectura) com teoremas de simulação entre modelos formais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Resultados de Indecidibilidade de Turing",
                                  "subSteps": [
                                    "Estude o Problema da Parada (Halting Problem): dada uma MT M e entrada w, M para em w?",
                                    "Revise a prova de indecidibilidade por contradição de Turing: assumir H decidível leva a paradoxo.",
                                    "Liste outros problemas indecidíveis (ex: equivalência de MTs, Post Correspondence Problem).",
                                    "Classifique problemas como decidíveis, semi-decidíveis ou indecidíveis.",
                                    "Pratique reduzindo problemas conhecidos ao Halting Problem."
                                  ],
                                  "verification": "Prove informalmente por que o Halting Problem é indecidível em um diagrama de contradição.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Artigo original de Turing (1936) ou resumo em Sipser Cap. 4, simulador de MT online.",
                                  "tips": "Desenhe o loop diagonal de Turing para visualizar o paradoxo.",
                                  "learningObjective": "Dominar provas de indecidibilidade e reconhecer problemas além do poder das MTs.",
                                  "commonMistakes": "Achar que indecidível significa 'lento demais'; é sobre impossibilidade absoluta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conectar a Tese de Church-Turing à Indecidibilidade",
                                  "subSteps": [
                                    "Argumente que indecidíveis não são efetivamente computáveis, alinhando com a tese.",
                                    "Mostre que problemas indecidíveis estão fora do escopo das MTs, reforçando a tese como limite da computação.",
                                    "Discuta implicações: tese define o 'computável'; indecidibilidade mostra seus limites.",
                                    "Formule: se um problema é indecidível, não há MT para ele, confirmando a tese.",
                                    "Crie um fluxograma: Tese → Computável por MT → Decidível vs. Indecidível."
                                  ],
                                  "verification": "Escreva um parágrafo conectando explicitamente tese e Halting Problem.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Notas dos steps 1-2, papel para fluxogramas, vídeo explicativo (ex: YouTube sobre Church-Turing).",
                                  "tips": "Pense na tese como 'regra do jogo'; indecidibilidade como jogadas inválidas.",
                                  "learningObjective": "Estabelecer a relação lógica: indecidibilidade valida os limites da tese.",
                                  "commonMistakes": "Invertir causalidade: tese não causa indecidibilidade, mas a explica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Conexão em Exemplos e Análise Crítica",
                                  "subSteps": [
                                    "Escolha um problema real (ex: vírus detector perfeito) e mostre sua indecidibilidade via redução.",
                                    "Analise como isso afeta a tese: reforça que só efetivamente computáveis estão no escopo das MTs.",
                                    "Debata objeções: hipercomputação possível? (resposta: viola tese).",
                                    "Sintetize em uma tese pessoal: 'Indecidibilidade prova a completude da tese'.",
                                    "Crie perguntas de autoavaliação sobre a conexão."
                                  ],
                                  "verification": "Resolva um exercício: relacione indecidibilidade de PCP à tese.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exercícios de livro (Sipser problemas), fórum online para discussões.",
                                  "tips": "Use exemplos cotidianos como 'prever bugs perfeitamente' para tornar concreto.",
                                  "learningObjective": "Aplicar a conexão para analisar problemas computacionais reais.",
                                  "commonMistakes": "Ignorar semi-decidibilidade; focar só em decidível/indecidível."
                                }
                              ],
                              "practicalExample": "Analise o problema de detecção de vírus: nenhum antivírus perfeito existe porque seria indecidível (reduz ao Halting Problem). Isso mostra que, pela Tese de Church-Turing, tal detector não é efetivamente computável por MTs, limitando o escopo da computação.",
                              "finalVerifications": [
                                "Explicar verbalmente a prova diagonal de Turing e sua relação com a tese.",
                                "Identificar 3 problemas indecidíveis e argumentar por que estão fora do escopo das MTs.",
                                "Desenhar um mapa conceitual conectando tese, MTs e indecidibilidade.",
                                "Responder: 'Por que a tese não é falsificada pela indecidibilidade?'",
                                "Aplicar a conexão a um novo problema proposto.",
                                "Escrever um ensaio curto (300 palavras) sintetizando a relação."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre tese (conjectura) e indecidibilidade (teorema).",
                                "Profundidade da conexão: demonstra causalidade lógica entre os conceitos.",
                                "Uso de exemplos: inclui provas/reduções corretas.",
                                "Clareza de expressão: linguagem acessível sem jargão excessivo.",
                                "Originalidade: aplica a novos cenários além dos exemplos padrão.",
                                "Completude: cobre todos os aspectos (fundamentos, provas, implicações)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Computabilidade e Lógica Matemática (Gödel).",
                                "Filosofia: Natureza da mente e computação (Searle, Penrose).",
                                "Engenharia de Software: Limites de verificação automática de programas.",
                                "Inteligência Artificial: Impossibilidade de IA geral onisciente."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, entender que tarefas como 'detecção 100% de bugs' são indecidíveis reforça a necessidade de testes manuais e validação humana, guiando investimentos em IA assistiva em vez de autônoma perfeita, alinhando expectativas com limites da Tese de Church-Turing."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Indecidabilidade e Problemas Intratáveis",
                "description": "Teoria da indecidibilidade e caracterização de problemas intratáveis.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Problema da Parada",
                    "description": "Definição e prova de indecidibilidade: não existe máquina de Turing que decida se outra MT para em uma dada entrada.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1",
                        "name": "Definição do Problema da Parada",
                        "description": "Definição formal do Problema da Parada (Halting Problem), que consiste em determinar, para uma máquina de Turing M e uma entrada w, se M entra em estado de parada (halting state) ao processar w em um número finito de passos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1",
                            "name": "Enunciar a definição formal",
                            "description": "Formular precisamente o Problema da Parada como a linguagem H = {<M, w> | M é uma máquina de Turing que para em entrada w}, onde <M, w> é a codificação conjunta da MT M e da string w.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Máquinas de Turing",
                                  "subSteps": [
                                    "Leia a definição formal de uma Máquina de Turing (MT): um septeto (Q, Σ, Γ, δ, q0, qaccept, qreject).",
                                    "Entenda os componentes: estados Q, alfabeto de entrada Σ, fita Γ, função de transição δ, estado inicial q0, estados de aceitação e rejeição.",
                                    "Revise como uma MT processa uma entrada w ∈ Σ* através de configurações sucessivas.",
                                    "Identifique o que significa 'parar' (halting): a MT entra em qaccept ou qreject após um número finito de passos.",
                                    "Diferencie halting de looping infinito."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os 7 componentes de uma MT e dê um exemplo simples de execução.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Teoria da Computação (ex: Sipser), notas de aula sobre MTs, simulador online de MT.",
                                  "tips": "Use diagramas para visualizar transições de estado; foque em exemplos canônicos como reconhecedor de {a^n b^n}.",
                                  "learningObjective": "Dominar a estrutura formal de MTs como base para o Problema da Parada.",
                                  "commonMistakes": "Confundir alfabeto de entrada Σ com símbolos da fita Γ; ignorar estados de aceitação/rejeição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Conceito de Parada (Halting)",
                                  "subSteps": [
                                    "Defina 'parada' como alcançar qaccept ou qreject em passos finitos.",
                                    "Discuta configurações de MT: sequência de estado, cabeça de fita e conteúdo da fita.",
                                    "Explique por que algumas MTs podem entrar em loop infinito em certas entradas.",
                                    "Diferencie decidibilidade de reconhecimento: halting é sobre parada, não aceitação.",
                                    "Analise um exemplo simples: MT que para em ε mas loops em 'a'."
                                  ],
                                  "verification": "Descreva uma configuração de MT que halta e outra que não, justificando.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Vídeos tutoriais sobre halting (ex: YouTube - Sipser lectures), papel e lápis para diagramas.",
                                  "tips": "Pense em halting como 'terminação de programa'; relacione com loops while infinitos em programação.",
                                  "learningObjective": "Internalizar o que significa uma MT 'parar' em uma entrada específica.",
                                  "commonMistakes": "Confundir halting com aceitação; assumir que toda MT para em toda entrada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Codificação Conjunta <M, w>",
                                  "subSteps": [
                                    "Aprenda a codificar uma MT M usando notação padrão (ex: Gödel numbering ou binário).",
                                    "Entenda codificação de strings w sobre Σ* (ex: unary ou binário).",
                                    "Defina <M, w> como codificação concatenada ou pareada de ambas.",
                                    "Veja exemplos: codifique uma MT simples M1 que para em w='ab' como <M1, ab>.",
                                    "Verifique unicidade: toda string em {0,1}* representa unicamente uma MT e entrada."
                                  ],
                                  "verification": "Codifique manualmente uma MT trivial e uma string w, formando <M, w>.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Apêndice de livro sobre codificações (Sipser Cap. 4), calculadora para numeração de Gödel.",
                                  "tips": "Comece com codificações simples; memorize que <M, w> é injetiva.",
                                  "learningObjective": "Mestre a representação formal de pares (MT, entrada) como strings.",
                                  "commonMistakes": "Esquecer separadores em codificações concatenadas; confundir com tuplas matemáticas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular a Definição Formal da Linguagem H",
                                  "subSteps": [
                                    "Defina H = {<M, w> | M é MT que halta em w} ⊆ {0,1}*.",
                                    "Escreva explicitamente: H = {<M, w> ∈ {0,1}* | M halts on w}.",
                                    "Explique que H é uma linguagem sobre alfabeto binário.",
                                    "Relacione com problemas decidíveis: H é indecidível ( teaser para prova futura).",
                                    "Pratique escrevendo a definição 5 vezes de cor."
                                  ],
                                  "verification": "Escreva a definição exata sem consultar materiais e a recite em voz alta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha em branco, timer para prática de recitação.",
                                  "tips": "Use mnemônicos: 'H para Halting, <M,w> para Machine-input'.",
                                  "learningObjective": "Enunciar precisamente a definição formal do Problema da Parada.",
                                  "commonMistakes": "Omitir 'codificação conjunta'; usar 'aceita' em vez de 'para'; errar o alfabeto."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Reforçar a Definição",
                                  "subSteps": [
                                    "Resolva exercícios: identifique se dada <M,w> pertence a H (com justificativa).",
                                    "Compare com variações erradas e corrija-as.",
                                    "Ensine a definição a um colega ou grave-se explicando.",
                                    "Crie flashcards com definição e componentes.",
                                    "Teste-se em quiz auto-gerado."
                                  ],
                                  "verification": "Acertar 100% em 10 perguntas sobre a definição e componentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Flashcards (Anki app), exercícios de livro (Sipser problemas 4.x).",
                                  "tips": "Espaçamento de repetição: revise em 1h, 1dia, 1semana.",
                                  "learningObjective": "Fixar a definição para recall imediato e aplicação.",
                                  "commonMistakes": "Memorizar sem entender; ignorar contexto de indecidibilidade."
                                }
                              ],
                              "practicalExample": "Considere M uma MT que reconhece palíndromos pares (halta em 'abaaba' aceitando, em 'ab' rejeitando) e w='abaaba'. Então <M, abaaba> ∈ H pois M halta em w. Para uma MT que loops em qualquer entrada não-vazia, <M_loop, a> ∉ H.",
                              "finalVerifications": [
                                "Recitar a definição exata de H sem erros.",
                                "Explicar <M,w> com exemplo codificado.",
                                "Diferenciar halting de aceitação.",
                                "Identificar se uma <M,w> dada pertence a H.",
                                "Relacionar H com indecidibilidade geral.",
                                "Corrigir definições erradas comuns."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação: uso correto de <M,w> e H.",
                                "Compreensão conceitual: distinção entre parada e looping.",
                                "Correção na codificação: explicação válida de representações.",
                                "Clareza na formulação: linguagem formal e concisa.",
                                "Exemplos adequados: relevância e acurácia.",
                                "Profundidade: menção ao alfabeto e contexto teórico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (linguagens como subconjuntos), Numeração de Gödel.",
                                "Filosofia: Limites do conhecimento computacional (Epicuro diagonal).",
                                "Lógica: Argumentos por contradição na prova de indecidibilidade.",
                                "Programação: Análise de terminção em linguagens como Python (ex: rice theorem)."
                              ],
                              "realWorldApplication": "A definição formal do Halting Problem fundamenta provas de impossibilidade em verificação de software (ex: detectar deadlocks infinitos), análise de complexidade em compiladores e limites de IA (não pode prever todos os comportamentos de programas)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2",
                            "name": "Identificar parâmetros de entrada",
                            "description": "Explicar os componentes de entrada: a descrição codificada de uma máquina de Turing M (como uma string sobre o alfabeto de entrada) e a string w sobre o alfabeto de fita de M.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema da Parada e seus Parâmetros de Entrada",
                                  "subSteps": [
                                    "Leia a definição formal do Problema da Parada: dada uma MT M e string w, determinar se M para em w.",
                                    "Identifique os dois parâmetros principais: a descrição codificada <M> e a string w.",
                                    "Diferencie <M> (encoding da MT sobre seu alfabeto de entrada) de w (string no alfabeto de fita de M).",
                                    "Anote exemplos de entradas típicas em problemas de indecidibilidade."
                                  ],
                                  "verification": "Escreva uma frase resumindo os dois parâmetros e seu papel no problema.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Definição de Máquina de Turing (livro ou PDF)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar M como uma 'caixa preta' com entrada w.",
                                  "learningObjective": "Entender conceitualmente os parâmetros de entrada do Problema da Parada.",
                                  "commonMistakes": "Confundir alfabeto de entrada de M com alfabeto de fita; assumir que w é parte de <M>."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Descrição Codificada da Máquina de Turing <M>",
                                  "subSteps": [
                                    "Estude o formato padrão de encoding de MT: estados, símbolos de fita, transições como quadruplas.",
                                    "Identifique componentes em <M>: alfabeto de entrada Γ, alfabeto de fita Σ, estado inicial, etc.",
                                    "Pratique decodificando uma string <M> simples, extraindo Γ e Σ.",
                                    "Compare encodings diferentes (ex: binário vs. unário) para ver padrões comuns."
                                  ],
                                  "verification": "Dado um <M> exemplo, liste seus componentes principais (Γ, Σ, estados).",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Exemplos de encodings de MT (online ou livro de teoria da computação)",
                                    "Editor de texto para simular strings"
                                  ],
                                  "tips": "Comece com MTs simples (1 estado) para construir confiança.",
                                  "learningObjective": "Extrair e identificar elementos da descrição codificada <M>.",
                                  "commonMistakes": "Ignorar separadores no encoding; confundir símbolos de entrada com de fita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Validar a String de Entrada w",
                                  "subSteps": [
                                    "Defina w como string finita sobre o alfabeto de fita Σ de M.",
                                    "Verifique se todos símbolos em w pertencem a Σ de <M>.",
                                    "Pratique identificando w em instâncias do problema: 'Entrada: <M>, 101'.",
                                    "Teste casos onde w é inválida (símbolos fora de Σ)."
                                  ],
                                  "verification": "Para um par (<M>, w), confirme se w é válida para M e explique por quê.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Lista de exemplos de problemas de parada",
                                    "Simulador de MT online (opcional)"
                                  ],
                                  "tips": "Sempre cheque o alfabeto primeiro: Σ inclui blank symbol?",
                                  "learningObjective": "Reconhecer w e validar sua compatibilidade com M.",
                                  "commonMistakes": "Assumir que w usa alfabeto de entrada Γ sem verificar Σ; tratar w como código de M."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Parâmetros e Verificar Instância Completa",
                                  "subSteps": [
                                    "Combine <M> e w em uma instância formal do Problema da Parada.",
                                    "Descreva o que significa 'M em w': simular M com fita inicial w.",
                                    "Identifique parâmetros em enunciados verbais ou codificados.",
                                    "Crie sua própria instância simples e valide."
                                  ],
                                  "verification": "Escreva uma instância completa e explique cada parâmetro.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Papel para diagramas de fita inicial",
                                    "Exemplos resolvidos de halting problem"
                                  ],
                                  "tips": "Visualize a fita com w no início e cabeçote em posição inicial.",
                                  "learningObjective": "Montar e validar pares (<M>, w) para o problema.",
                                  "commonMistakes": "Esquecer estado inicial ou blank symbol na validação."
                                }
                              ],
                              "practicalExample": "Considere <M> = 'Q={q0,q1,qhalt}; Σ={0,1,B}; Γ={0,1}; δ(q0,0)=(q1,1,R); ...' (MT que copia input) e w='01'. Aqui, <M> codifica a MT sobre Γ={0,1}, e w='01' está em Σ={0,1,B}. Pergunta: M para em '01'?",
                              "finalVerifications": [
                                "Pode listar os dois parâmetros de uma instância dada?",
                                "Identifica corretamente Γ e Σ de <M>?",
                                "Valida se w pertence a Σ?",
                                "Explica o papel de cada parâmetro no halting problem?",
                                "Cria uma instância válida própria?",
                                "Diferencia encoding <M> de w?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de <M> e w (100% componentes corretos).",
                                "Correta validação de alfabetos (sem erros de símbolos).",
                                "Explicação clara do contexto do Problema da Parada.",
                                "Uso de terminologia formal (ex: alfabeto de fita Σ).",
                                "Capacidade de gerar exemplos válidos independentes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos para alfabetos e linguagens formais.",
                                "Lógica: Análise de predicados indecidíveis como HALT.",
                                "Programação: Verificação de terminção em loops e recursão.",
                                "Filosofia: Limites do conhecimento computacional (Gödel, Turing)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, identificar inputs críticos para testar loops infinitos; em análise de segurança, verificar se malware para ou roda forever; otimização de algoritmos para detectar não-terminação aproximada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3",
                            "name": "Diferenciar decidibilidade e reconhecimento",
                            "description": "Distinguir entre uma MT decididora (que sempre para e responde sim/não corretamente) e uma MT reconhecedora (semi-decidível, que para apenas em aceitação).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de Máquina de Turing Decididora",
                                  "subSteps": [
                                    "Ler a definição formal: uma MT decididora sempre halting em todas as entradas e responde corretamente 'sim' ou 'não'.",
                                    "Analisar o comportamento em aceitação (estado de aceitação) e rejeição (estado de rejeição).",
                                    "Estudar diagramas de MT que param em ambos os casos.",
                                    "Anotar as propriedades: total, computável, decidível.",
                                    "Resolver exercício simples: identificar se uma MT dada é decididora."
                                  ],
                                  "verification": "Explicar em suas palavras o que significa 'sempre halting' e dar um exemplo de resposta para uma entrada específica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 3)",
                                    "Vídeo sobre MT decididoras no YouTube (canal teoria da computação)"
                                  ],
                                  "tips": "Visualize o tape da MT: ela deve limpar e parar sempre, sem loops infinitos.",
                                  "learningObjective": "Dominar a definição precisa de decidibilidade em MT.",
                                  "commonMistakes": [
                                    "Confundir halting apenas em aceitação com decidibilidade total.",
                                    "Ignorar que rejeição também requer halting."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a definição de Máquina de Turing Reconhecedora",
                                  "subSteps": [
                                    "Ler a definição: uma MT reconhecedora halting apenas em aceitação ('sim'), podendo loopar infinitamente em rejeição.",
                                    "Analisar o semi-algoritmo: aceita linguagens RE (recursively enumerable).",
                                    "Estudar exemplos de linguagens RE mas não decidíveis.",
                                    "Comparar informalmente com simuladores de MT online.",
                                    "Anotar diferenças iniciais com decididoras."
                                  ],
                                  "verification": "Descrever um cenário onde a MT loopa em 'não' e para em 'sim'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de Máquinas de Turing online (ex: Turing Machine Simulator)",
                                    "Notas de aula sobre indecidibilidade"
                                  ],
                                  "tips": "Pense em 'reconhecedora' como 'detecta sim, mas pode falhar em não'.",
                                  "learningObjective": "Entender o conceito de semi-decidibilidade e linguagens RE.",
                                  "commonMistakes": [
                                    "Achar que reconhecedora é 'incompleta' em aceitação também.",
                                    "Confundir com MTs que sempre rejeitam."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e comparar diferenças chave",
                                  "subSteps": [
                                    "Listar tabela comparativa: halting (sempre vs parcial), resposta (sim/não vs só sim), classes de linguagens (REC vs RE).",
                                    "Analisar implicações: decididoras ⊂ reconhecedoras.",
                                    "Estudar prova informal de que nem toda RE é REC.",
                                    "Discutir relação com Problema da Parada.",
                                    "Criar fluxograma das diferenças."
                                  ],
                                  "verification": "Preencher uma tabela comparativa corretamente sem consultar materiais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para tabela",
                                    "Artigo sobre hierarquia de Chomsky"
                                  ],
                                  "tips": "Use mnemônico: Decididora = DECide tudo; Reconhecedora = REConhece alguns.",
                                  "learningObjective": "Distinguir precisamente decidibilidade de reconhecimento.",
                                  "commonMistakes": [
                                    "Invertir: achar que reconhecedora halting em tudo.",
                                    "Ignorar que decididora é um caso especial de reconhecedora."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar conceitos no contexto do Problema da Parada",
                                  "subSteps": [
                                    "Explicar por que o Problema da Parada é RE mas não REC: simulador reconhece halting, mas loopa se não.",
                                    "Simular MT para halting problem.",
                                    "Discutir reduções de Church-Turing.",
                                    "Resolver exercício: classificar problemas como decidíveis ou só reconhecíveis.",
                                    "Refletir sobre limites da computação."
                                  ],
                                  "verification": "Classificar corretamente o halting problem e justificar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exercícios de Sipser cap. 4",
                                    "Ferramenta JFLAP para simulação"
                                  ],
                                  "tips": "Lembre: simulador universal é reconhecedor para halting.",
                                  "learningObjective": "Conectar diferenciação ao teorema fundamental da indecidibilidade.",
                                  "commonMistakes": [
                                    "Achar halting decidível por 'testar por tempo finito'.",
                                    "Confundir simulador com decisor."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere verificar se um programa Python para em uma entrada: uma MT reconhecedora simula até detectar halting ('sim'), mas loopa se o programa loopa infinitamente ('não' não é garantido). Uma decididora hipotética pararia sempre, mas não existe por indecidibilidade.",
                              "finalVerifications": [
                                "Definir corretamente MT decididora e reconhecedora.",
                                "Explicar por que halting é reconhecível mas não decidível.",
                                "Identificar em um diagrama de MT se é decididora ou reconhecedora.",
                                "Dar exemplo de linguagem RE não REC.",
                                "Desenhar tabela comparativa precisa.",
                                "Justificar que decididoras são subconjunto de reconhecedoras."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (sem omissões ou erros).",
                                "Correta distinção de comportamentos de halting.",
                                "Uso apropriado de terminologia (REC, RE, halting).",
                                "Conexão clara com Problema da Parada.",
                                "Exemplos relevantes e corretos.",
                                "Tabela ou fluxograma comparativo lógico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e cardinalidade (contáveis vs incontáveis).",
                                "Filosofia: Limites do conhecimento humano e Gödel incompleto.",
                                "Lógica: Proposições decidíveis vs semi-decidíveis.",
                                "Programação: Análise estática de código e verificadores de bugs."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, ferramentas como linters ou provers usam abordagens semi-decidíveis para detectar loops infinitos, parando só ao encontrar problemas, mas podendo falhar em casos benignos, refletindo limites teóricos na verificação automática de programas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.2",
                        "name": "Prova de Indecidibilidade",
                        "description": "Prova por contradição da indecidibilidade do Problema da Parada, utilizando argumento diagonal e redução, mostrando que nenhuma máquina de Turing pode decidir a linguagem H.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.2.1",
                            "name": "Assumir existência de máquina decididora H",
                            "description": "Supor, por contradição, que existe uma MT H que decide H_LP, de modo que H(<M>, w) para e aceita se M para em w, e rejeita caso contrário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal do Problema da Parada (H_LP)",
                                  "subSteps": [
                                    "Lembre-se que H_LP é a linguagem { <M>, w | M é uma MT que para em w }.",
                                    "Confirme que H_LP é uma linguagem recursivamente enumerável, mas supostamente decidível por assunção.",
                                    "Identifique por que decidir H_LP é central para a teoria da indecidibilidade.",
                                    "Escreva a definição em notação formal: H_LP = { <M,w> | M halts on w }.",
                                    "Diferencie 'parar' (halt) de 'loop infinito'."
                                  ],
                                  "verification": "Escreva e compare sua definição de H_LP com a definição padrão de um livro-texto como Sipser.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 4)",
                                    "Notas de aula sobre Máquinas de Turing"
                                  ],
                                  "tips": "Use diagramas de MT para visualizar halting vs. looping.",
                                  "learningObjective": "Compreender precisamente o que H_LP representa e por que sua decidibilidade é questionada.",
                                  "commonMistakes": [
                                    "Confundir H_LP com aceitação em linguagens regulares",
                                    "Ignorar que w é uma string específica, não qualquer entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a assunção por contradição da existência de H",
                                  "subSteps": [
                                    "Suponha, para contradição, que H_LP é decidível.",
                                    "Isso implica a existência de uma MT H que decide H_LP perfeitamente.",
                                    "Afirme formalmente: 'Existe uma MT H tal que para toda <M>, w, H(<M>, w) para.'",
                                    "Explique que essa assunção leva a uma contradição posterior na prova.",
                                    "Discuta por que usamos prova por contradição aqui (não há prova direta conhecida)."
                                  ],
                                  "verification": "Escreva a assunção em uma frase formal e justifique por que ela é hipotética.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel para anotações",
                                    "Vídeo tutorial sobre prova da indecidibilidade do halting problem"
                                  ],
                                  "tips": "Pense em H como um 'oráculo perfeito' para halting, que vamos mostrar impossível.",
                                  "learningObjective": "Dominar a estrutura lógica da prova por contradição ao assumir decidibilidade.",
                                  "commonMistakes": [
                                    "Confundir assunção com prova de existência",
                                    "Esquecer que H deve ser uma MT padrão, não um oráculo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o formato de entrada para H",
                                  "subSteps": [
                                    "Especifique que a entrada de H é uma codificação única <M>, w, onde <M> é a codificação de Turing da MT M.",
                                    "Revise como codificar uma MT M em uma string binária.",
                                    "Garanta que w seja qualquer string sobre o alfabeto da MT.",
                                    "Exemplo: <M> pode ser 1^{q1}0 1^{transições} etc., seguido de w.",
                                    "Confirme que H lê <M>, w como uma única fita."
                                  ],
                                  "verification": "Construa um exemplo simples de <M>, w e descreva como H o processaria.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online de simulador de MT (ex: Turing Machine Simulator)",
                                    "Tabela de codificação de MT de Sipser"
                                  ],
                                  "tips": "Pratique codificando uma MT simples que soma dois números para fixar <M>.",
                                  "learningObjective": "Entender a representação padrão de pares MT-string como entrada para H.",
                                  "commonMistakes": [
                                    "Usar notação informal para <M>",
                                    "Confundir codificação de M com sua descrição em linguagem natural"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Especificar o comportamento exato de H",
                                  "subSteps": [
                                    "H(<M>, w) aceita (halts em estado aceitador) se e somente se M halts em w.",
                                    "H(<M>, w) rejeita (halts em estado rejeitador) caso contrário (M loops em w).",
                                    "Importante: H sempre halts, nunca loops, pois é decididora.",
                                    "Formalize: Se M halts on w então H accepts; senão H rejects; e H halts sempre.",
                                    "Diferencie H de um reconhecedor semi-decisor (que pode loop)."
                                  ],
                                  "verification": "Crie uma tabela verdade conceitual para H com casos: halts/aceita, halts/rejeita, loops.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para tabela",
                                    "Exemplos de provas de Sipser página 170-175"
                                  ],
                                  "tips": "Lembre: H é total (computa função total), não parcial.",
                                  "learningObjective": "Precificar o output binário de H e sua totalidade como decisor.",
                                  "commonMistakes": [
                                    "Permitir que H loop em alguns casos",
                                    "Confundir 'aceitar' com 'halts' sem especificar rejeição"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma MT M que verifica se uma string w tem número par de 1s e halts aceitando se sim. Codifique <M>, w='1111' (par, deve halt). Por assunção, H(<M>,'1111') aceita. Para w='111' (ímpar, loops forever), H rejeita.",
                              "finalVerifications": [
                                "Explique verbalmente a assunção de H sem erros.",
                                "Escreva a definição formal de H corretamente.",
                                "Identifique diferenças entre H e um reconhecedor de H_LP.",
                                "Construa um exemplo válido de entrada <M>, w.",
                                "Justifique por que H deve sempre parar.",
                                "Descreva o próximo passo lógico na prova (construir máquina diagonal)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de H e H_LP (100% correto).",
                                "Compreensão clara da assunção por contradição.",
                                "Habilidade em codificar entradas corretamente.",
                                "Identificação correta de comportamentos de accept/reject/halt.",
                                "Ausência de confusões comuns como looping de H.",
                                "Capacidade de ligar à prova completa."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Prova por contradição (Reductio ad absurdum).",
                                "Filosofia da Ciência: Limites do conhecimento computacional (Gödel, Turing).",
                                "Matemática Discreta: Codificações e funções totais vs. parciais.",
                                "Engenharia de Software: Implicações em análise estática de código."
                              ],
                              "realWorldApplication": "Essa assunção é o alicerce para provar que detectores automáticos de loops infinitos em programas (ex: antivirus, compiladores) são impossíveis em geral, guiando o desenvolvimento de heurísticas aproximadas em ferramentas como linters no VS Code ou análise de segurança em sistemas operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.2.2",
                            "name": "Construir máquina diagonal D",
                            "description": "Construir uma MT D que, em entrada <M>, simula H(<M>, <M>) e inverte o resultado: se H aceitar, D entra em loop infinito; se rejeitar, D para.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e definir a máquina hipotética H",
                                  "subSteps": [
                                    "Estude a definição de H: uma MT que decide o halting problem, aceitando se M halts em w, rejeitando caso contrário.",
                                    "Anote formalmente: H(<M>, w) ⊢ se M em w para, aceita; senão rejeita.",
                                    "Identifique que H é assumida decidível para prova por contradição.",
                                    "Desenhe diagrama de estados simplificado de H para visualização.",
                                    "Explique verbalmente como H difere de simuladores universais."
                                  ],
                                  "verification": "Escreva uma definição precisa de H e confirme com auto-perguntas sobre seu comportamento em casos de halt e loop.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel, lápis, notas de aula sobre halting problem, simulador de MT online (ex: JFLAP).",
                                  "tips": "Use pseudocódigo para descrever H antes de pensar em estados.",
                                  "learningObjective": "Entender o papel hipotético de H na prova de indecidibilidade.",
                                  "commonMistakes": "Confundir H com simulador universal U; assumir H existe realmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a entrada e preparar simulação em D",
                                  "subSteps": [
                                    "Descreva como D lê <M> da fita de entrada.",
                                    "Copie <M> duas vezes na fita: prepare configuração <H> # <M> # <M> para simulação.",
                                    "Implemente cópia de strings na fita usando estados de MT para duplicar <M>.",
                                    "Posicione a cabeça na posição inicial para simular H em (<M>, <M>).",
                                    "Defina o simulador universal U embutido em D para rodar H nessa configuração."
                                  ],
                                  "verification": "Desenhe a fita inicial e final da preparação, confirmando <H> # <M> # <M>.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Simulador de MT (JFLAP ou Turing Machine Simulator), quadro branco.",
                                  "tips": "Teste cópia de strings com <M> simples como 'q0 -> q1'.",
                                  "learningObjective": "Dominar manipulação de fita para preparar argumentos de simulação.",
                                  "commonMistakes": "Erro na codificação: esquecer separadores # ou ordem errada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulação de H(<M>, <M>) e detectar resultado",
                                  "subSteps": [
                                    "Inicie o simulador U em D para executar H sobre a configuração preparada.",
                                    "Monitore estados: detecte se H aceita (entra em q_accept) ou rejeita (q_reject).",
                                    "Implemente estados em D para pausar simulação ao detectar aceitação/rejeição.",
                                    "Descreva transições para 'observar' halting states de H sem interferir.",
                                    "Teste com M que halts e loops para validar detecção."
                                  ],
                                  "verification": "Simule manualmente para M halting: confirme detecção de aceitação.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de simulação MT avançado, exemplos de MT halting/non-halting.",
                                  "tips": "Use 'non-deterministic' simulação se disponível para ramificações.",
                                  "learningObjective": "Implementar detecção de resultados em simulações aninhadas.",
                                  "commonMistakes": "Simulação infinita sem detecção: esquecer estados de monitoramento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar inversão diagonal no comportamento de D",
                                  "subSteps": [
                                    "Da detecção: se H aceita (<M> halts em <M>), transite para loop infinito em D.",
                                    "Se H rejeita (<M> loops em <M>), transite para estado halting/aceitação em D.",
                                    "Defina loop infinito: estado q_loop com auto-transição sem halt.",
                                    "Halting: vá para q_halt.",
                                    "Formalize tabela de transições completa de D."
                                  ],
                                  "verification": "Construa diagrama de D e trace execução para <D>: confirme contradição.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Ferramentas de desenho de autômatos, pseudocódigo editor.",
                                  "tips": "Nomeie estados claramente: q_simulate_accept, q_invert_loop.",
                                  "learningObjective": "Aplicar diagonalização para criar auto-referência paradoxal.",
                                  "commonMistakes": "Inverter errado: loop quando deve halt."
                                }
                              ],
                              "practicalExample": "Suponha M é uma MT que imediatamente halts em qualquer input. Então H(<M>,<M>) aceita. D, simulando isso, detecta aceitação e entra em loop infinito em <M>. Agora para <D>: se D halt em <D>, H aceitaria, mas D loopa — contradição.",
                              "finalVerifications": [
                                "D em <M> loops se H(<M>,<M>) aceita.",
                                "D em <M> halts se H(<M>,<M>) rejeita.",
                                "Aplicando a <D>: leva a contradição (não halta se halta, e vice-versa).",
                                "Descrição de D é válida MT (estados finitos, transições totais).",
                                "Simulação preserva comportamento de H."
                              ],
                              "assessmentCriteria": [
                                "Correção da lógica de inversão diagonal.",
                                "Precisão na preparação da fita para simulação.",
                                "Detecção correta de estados halting de H.",
                                "Explicação clara da contradição em <D>.",
                                "Formalização completa da MT D com transições."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Diagonalização de Cantor em conjuntos incontáveis.",
                                "Lógica: Provas por contradição e teorema da incompletude de Gödel.",
                                "Filosofia: Limites do conhecimento e computabilidade humana."
                              ],
                              "realWorldApplication": "Demonstra limites fundamentais da computação, impactando análise de programas (ex: antivírus não detectam todos loops), teorema de Rice e impossibilidade de verificadores estáticos perfeitos em software."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.2.3",
                            "name": "Derivar contradição",
                            "description": "Analisar o comportamento de D em sua própria codificação <D>: isso leva a uma contradição, pois D não pode tanto parar quanto não parar em <D>.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição da máquina decididora D",
                                  "subSteps": [
                                    "Recordar que D é uma Máquina de Turing (TM) hipotética que recebe como entrada codificações <M> e w, e retorna 'para' se M(w) para, ou 'não para' caso contrário.",
                                    "Entender que D sempre para (é decididora) por suposição na prova por contradição.",
                                    "Notar que D, sendo uma TM, possui sua própria codificação <D>.",
                                    "Escrever pseudocódigo ou diagrama formal de D: D(<M>, w) = 'para' se M(w) halts, senão 'loopa'.",
                                    "Verificar que o comportamento de D depende do input fornecido."
                                  ],
                                  "verification": "Escrever a definição formal de D e confirmar que ela decide o Problema da Parada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas da aula sobre Prova de Indecidibilidade",
                                    "Papel e caneta para diagrama",
                                    "Livro de Teoria da Computação (ex: Sipser)"
                                  ],
                                  "tips": "Use notação padrão de TMs para precisão; foque no fato de D ser total (sempre para).",
                                  "learningObjective": "Compreender precisamente o papel e as propriedades assumidas para D.",
                                  "commonMistakes": "Confundir D com uma simuladora de TMs ou assumir que D resolve problemas sem contradizer."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o input especial: D(<D>)",
                                  "subSteps": [
                                    "Construir o input específico: aplicar D à sua própria codificação, ou seja, D(<D>).",
                                    "Explicar que <D> é o input w = <D> para a máquina M = D.",
                                    "Descrever o que D faz nesse caso: simula D(<D>) e decide se para ou não.",
                                    "Destacar que o resultado de D(<D>) determina o comportamento de D rodando em <D>.",
                                    "Desenhar um diagrama mostrando D recebendo <D> como input."
                                  ],
                                  "verification": "Desenhar e rotular corretamente o diagrama de D(<D>).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de codificação de TM das notas"
                                  ],
                                  "tips": "Pense em D como uma 'caixa preta' que se auto-inspeciona.",
                                  "learningObjective": "Identificar o input auto-referencial que gera a contradição.",
                                  "commonMistakes": "Usar input errado, como D(<M>, w) genérico em vez de <D> específico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Caso 1: Suponha que D(<D>) retorne 'para'",
                                  "subSteps": [
                                    "Assumir que D(<D>) = 'para', significando que D afirma que D(<D>) para.",
                                    "Pela definição de D, se retorna 'para', então D(<D>) executa normalmente e para.",
                                    "Mas D(<D>) é exatamente a execução de D em <D>, que por definição, se 'para', faz a máquina loopar infinitamente (comportamento oposto).",
                                    "Identificar a contradição: D(<D>) para (por output) mas loopa (por ação).",
                                    "Registrar: isso viola a definição de D."
                                  ],
                                  "verification": "Escrever a contradição em uma frase clara: 'D diz que para, mas age como loop'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do Step 2",
                                    "Pseudocódigo de D"
                                  ],
                                  "tips": "Use setas no diagrama para mostrar 'output → ação contraditória'.",
                                  "learningObjective": "Derivar a contradição no primeiro caso hipotético.",
                                  "commonMistakes": "Ignorar que o output de D afeta seu próprio comportamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Caso 2: Suponha que D(<D>) retorne 'não para'",
                                  "subSteps": [
                                    "Assumir que D(<D>) = 'não para', significando que D afirma que D(<D>) loopa.",
                                    "Pela definição de D, se retorna 'não para', então D(<D>) para imediatamente após o output.",
                                    "Mas D(<D>) é a execução de D em <D>, que para (por ação), contradizendo o output 'loopa'.",
                                    "Identificar a contradição: D(<D>) loopa (por output) mas para (por ação).",
                                    "Registrar: novamente, viola a definição de D."
                                  ],
                                  "verification": "Escrever a contradição: 'D diz que loopa, mas age como para'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do Step 2 atualizado",
                                    "Pseudocódigo de D"
                                  ],
                                  "tips": "Compare os dois casos lado a lado em uma tabela para clareza.",
                                  "learningObjective": "Derivar a contradição no segundo caso hipotético.",
                                  "commonMistakes": "Confundir o output 'não para' com loop real da simulação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir a contradição e a indecidibilidade",
                                  "subSteps": [
                                    "Observar que ambos os casos levam a contradição: D não pode retornar nem 'para' nem 'não para' corretamente.",
                                    "Concluir que a suposição inicial (D existe e decide o Problema da Parada) é falsa.",
                                    "Afirmar: Problema da Parada é indecidível.",
                                    "Discutir implicações: nenhum algoritmo geral para detectar halt.",
                                    "Testar compreensão reescrevendo a prova completa em parágrafos."
                                  ],
                                  "verification": "Explicar a prova inteira em 1 minuto sem notas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resumo dos Steps 1-4",
                                    "Folha de conclusão"
                                  ],
                                  "tips": "Use prova por reductio ad absurdum explicitamente.",
                                  "learningObjective": "Sintetizar a prova por contradição completa.",
                                  "commonMistakes": "Parar no meio sem concluir que D não pode existir."
                                }
                              ],
                              "practicalExample": "Imagine D como um programa Python hipotético: def D(code, input): if simulates(code, input) halts: print('para'); return else: while True: pass. Agora, rode D(source_D, source_D). Se printa 'para', entra em loop (contradição). Se entra em loop sem printar, mas simulação haltou (contradição).",
                              "finalVerifications": [
                                "Explicar verbalmente os dois casos de contradição sem hesitação.",
                                "Desenhar diagrama completo da prova mostrando auto-referência.",
                                "Identificar corretamente onde a suposição falha.",
                                "Reescrever a prova em pseudocódigo lógico.",
                                "Responder: 'Por que D(<D>) é problemático?' com precisão.",
                                "Comparar com paradoxo do mentiroso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de D (exata ou não).",
                                "Clareza na identificação do input auto-referencial.",
                                "Correta derivação de contradições em ambos os casos.",
                                "Conclusão lógica da indecidibilidade.",
                                "Uso de diagramas ou tabelas para visualização.",
                                "Profundidade nas implicações da prova."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Proposicional: Prova por reductio ad absurdum e auto-referência.",
                                "Filosofia: Paradoxo do mentiroso (Eu minto).",
                                "Matemática: Teoremas de Gödel sobre incompletude.",
                                "Física Computacional: Limites da simulação em sistemas complexos."
                              ],
                              "realWorldApplication": "Compreender que não existe detector universal de loops infinitos impacta depuração de software, análise de malware, verificação de IA e design de compiladores, evitando buscas por soluções impossíveis e focando em heurísticas aproximadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.2.4",
                            "name": "Concluir indecidibilidade",
                            "description": "Concluir que nenhuma MT decide H_LP, relacionando com a Tese de Church-Turing e implicações para problemas computacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a construção da prova de indecidibilidade do Problema da Parada",
                                  "subSteps": [
                                    "Relembrar a definição formal do Problema da Parada H_LP: dada uma MT M e entrada w, M para em w?",
                                    "Estudar a suposição de que existe uma MT H que decide H_LP.",
                                    "Construir a MT D usando H: D em <M> simula H em <M>, <M>; se H diz que M para em <M>, D entra em loop; caso contrário, para.",
                                    "Analisar o comportamento de D em <D>: leva a contradição independentemente do resultado de H.",
                                    "Documentar a contradição em um diagrama de fluxo."
                                  ],
                                  "verification": "Construir e explicar o diagrama da prova sem erros lógicos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Teoria da Computação (Sipser ou similar), papel e caneta para diagramas, simulador de MT online.",
                                  "tips": "Use notação formal <M> para codificação da MT M para evitar confusão.",
                                  "learningObjective": "Compreender a estrutura reducionista da prova por contradição.",
                                  "commonMistakes": "Confundir simulação com execução direta; ignorar que D usa H como oráculo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a contradição e concluir a não-existência de decididor",
                                  "subSteps": [
                                    "Assumir que H existe e derivar que D(D) tanto para quanto não para.",
                                    "Explicar por que isso viola o princípio da não-contradição.",
                                    "Concluir que a suposição é falsa: nenhuma MT decide H_LP.",
                                    "Verificar se a prova é geral para qualquer MT universal.",
                                    "Escrever uma declaração formal da indecidibilidade."
                                  ],
                                  "verification": "Redigir um parágrafo lógico provando a contradição sem falácias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de exercícios com prova esboçada, quadro branco virtual (ex: Jamboard).",
                                  "tips": "Pense em termos de 'se... então...' para rastrear casos.",
                                  "learningObjective": "Dominar raciocínio por contradição em contextos computacionais.",
                                  "commonMistakes": "Assumir que D é total; esquecer que H deve ser total e halt em todas as entradas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar com a Tese de Church-Turing",
                                  "subSteps": [
                                    "Explicar a Tese de Church-Turing: toda função computável intuitivamente é computável por MT.",
                                    "Inferir que H_LP não é computável, pois indecidível por MT.",
                                    "Discutir que algoritmos em linguagens de programação reais são equivalentes a MT.",
                                    "Explorar extensões: undecidibilidade implica limites em qualquer modelo Turing-equivalente.",
                                    "Comparar com problemas decidíveis como ABNF para linguagens regulares."
                                  ],
                                  "verification": "Mapear a tese para um exemplo de algoritmo prático (ex: Python simulator).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigo original de Turing/Church (resumo), vídeo explicativo (ex: YouTube CS lecture).",
                                  "tips": "Use analogia: MT como 'cérebro universal' de computadores.",
                                  "learningObjective": "Conectar teoria formal com limites da computação prática.",
                                  "commonMistakes": "Confundir tese (não provada) com teorema; ignorar que vale para computabilidade efetiva."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar implicações para problemas computacionais",
                                  "subSteps": [
                                    "Listar teoremas derivados: Teorema de Rice (propriedades semânticas indecidíveis).",
                                    "Discutir aplicações: detecção de vírus, verificação de programas, otimização.",
                                    "Analisar por que aproximar H_LP (ex: timeouts) não resolve fundamentalmente.",
                                    "Relacionar com problemas intratáveis (NP-completos como aproximação).",
                                    "Debater ética: limites do conhecimento computacional."
                                  ],
                                  "verification": "Criar uma tabela de 5 problemas derivados e seu status de decidibilidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Lista de teoremas de indecidibilidade, exemplos de código com timeouts.",
                                  "tips": "Foque em 'por quês' para implicações, não só 'o quês'.",
                                  "learningObjective": "Aplicar indecidibilidade a cenários reais de computação.",
                                  "commonMistakes": "Superestimar decididores heurísticos como soluções completas."
                                }
                              ],
                              "practicalExample": "Imagine tentar construir um antivírus que detecta 100% dos vírus sem falsos positivos: assuma um decisor H para 'M é malicioso em w'. Construa D que se M malicioso em si, age benigno; senão, malicioso. Rodar D em si causa paradoxo, provando impossível – daí antivírus usam heurísticas.",
                              "finalVerifications": [
                                "Explicar verbalmente a prova sem consultar notas.",
                                "Identificar erro em uma prova falha modificada.",
                                "Relacionar corretamente com Tese de Church-Turing.",
                                "Listar 3 implicações práticas sem hesitação.",
                                "Desenhar diagrama da contradição em <5 minutos.",
                                "Diferenciar H_LP de problemas decidíveis como reconhecimento de linguagens regulares."
                              ],
                              "assessmentCriteria": [
                                "Precisão lógica na prova (sem falácias: 30%)",
                                "Profundidade na conexão com Church-Turing (25%)",
                                "Clareza em explicações e diagramas (20%)",
                                "Número e relevância de implicações discutidas (15%)",
                                "Capacidade de verificação independente (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da prova e contradição (Gödel).",
                                "Filosofia: Limites do conhecimento e determinismo computacional.",
                                "Lógica: Argumentos diagonais e autorreferência.",
                                "Engenharia de Software: Verificação formal e teorema de Rice."
                              ],
                              "realWorldApplication": "Na programação de sistemas críticos (ex: aviões, bancos), entender indecidibilidade guia o uso de verificações parciais e timeouts, evitando promessas impossíveis de 'verificação total', e inspira pesquisa em computação quântica para contornar limites Turing."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Teorema de Rice",
                    "description": "Propriedades semânticas não-triviais de linguagens recursivamente enumeráveis são indecidíveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Propriedades Semânticas",
                        "description": "Propriedades de linguagens que dependem unicamente do conjunto de strings reconhecidas (a linguagem em si), independentemente da máquina de Turing específica que a reconhece.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Definir propriedade semântica",
                            "description": "Explicar formalmente que uma propriedade P é semântica se, para quaisquer máquinas de Turing M1 e M2, M1 satisfaz P se e somente se L(M1) = L(M2) implica que M2 satisfaz P.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Máquinas de Turing e Linguagens Aceitas",
                                  "subSteps": [
                                    "Revise a definição formal de uma Máquina de Turing (MT) como um septeto (Q, Σ, Γ, δ, q0, qaccept, qreject).",
                                    "Explique o conceito de L(M), a linguagem aceita por uma MT M, como o conjunto de strings w ∈ Σ* para as quais M para em qaccept em w.",
                                    "Diferencie propriedades de MTs baseadas em sua estrutura (sintáticas) versus baseadas em L(M) (semânticas).",
                                    "Identifique exemplos iniciais: 'M tem 5 estados' é sintática; 'L(M) é infinita' é semântica.",
                                    "Pratique descrevendo L(M1) = L(M2) para MTs equivalentes."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando L(M) e dê 2 exemplos de propriedades sintáticas e semânticas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser ou similar), notas de aula sobre MTs, simulador de MT online.",
                                  "tips": "Use diagramas para visualizar transições de MTs; foque em equivalência de linguagens, não em código.",
                                  "learningObjective": "Dominar os conceitos básicos de MTs e linguagens aceitas como base para propriedades semânticas.",
                                  "commonMistakes": "Confundir estrutura interna da MT com sua linguagem aceita; ignorar que MTs equivalentes têm mesmo L(M)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Condição de Equivalência de Linguagens",
                                  "subSteps": [
                                    "Defina formalmente: Para MTs M1 e M2, L(M1) = L(M2) significa que ambas aceitam exatamente as mesmas strings.",
                                    "Explore implicações: Se L(M1) = L(M2), qualquer propriedade dependente apenas da linguagem deve ser compartilhada.",
                                    "Estude o contraexemplo: Se P depende da descrição da MT (ex: número de estados), M1 e M2 podem divergir em P mesmo com L(M1)=L(M2).",
                                    "Prove um lema simples: Toda MT pode ser convertida em uma MT de 2 símbolos sem mudar L(M).",
                                    "Liste 3 pares de MTs equivalentes com propriedades diferentes."
                                  ],
                                  "verification": "Construa ou descreva duas MTs equivalentes e verifique se compartilham propriedades semânticas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis para diagramas de MTs, ferramenta JFLAP para simulação.",
                                  "tips": "Sempre normalize MTs para minimizar estados/símbolos ao testar equivalência.",
                                  "learningObjective": "Entender que propriedades semânticas são invariantes sob equivalência de linguagens.",
                                  "commonMistakes": "Assumir que todas as propriedades de MTs são semânticas; esquecer que L(M) ignora 'como' a linguagem é aceita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Definição de Propriedade Semântica",
                                  "subSteps": [
                                    "Escreva a definição: P é semântica iff ∀ M1, M2 (máquinas de Turing), M1 satisfaz P ⇔ (L(M1)=L(M2) ⇒ M2 satisfaz P).",
                                    "Quebre a bicondicional: Direção → (se M1 tem P e L(M1)=L(M2), então M2 tem P); direção ← (análoga).",
                                    "Verifique com exemplo: P = 'L(M) contém ε' é semântica, pois depende só de L(M).",
                                    "Contrastar com sintática: P = 'M aceita em tempo polinomial' não é, pois MTs equivalentes podem ter tempos diferentes.",
                                    "Reescreva a definição em notação lógica: ∀M1∀M2 [P(M1) ∧ L(M1)=L(M2) → P(M2)]."
                                  ],
                                  "verification": "Forneça a definição formal exata e prove que ela é equivalente à versão com bicondicional.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Folha de fórmulas lógicas, exemplos do Teorema de Rice.",
                                  "tips": "Use tabelas verdadeiras para quantificadores; memorize 'invariante sob reescrita equivalente'.",
                                  "learningObjective": "Capacitar-se a expressar e validar a definição formal de propriedade semântica.",
                                  "commonMistakes": "Omitir a direção reversa na bicondicional; confundir com propriedades decidíveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar a Definição em Exemplos",
                                  "subSteps": [
                                    "Classifique 5 propriedades: 'L(M) é regular' (semântica), 'M para em todas entradas' (semântica), etc.",
                                    "Construa contraexemplo para propriedade sintática: Duas MTs com L(M1)=L(M2) mas uma com loop infinito.",
                                    "Explique ligação com Rice: Propriedades semânticas não-triviais são indecidíveis.",
                                    "Teste sua compreensão: É 'L(M) é vazia' semântica? Prove.",
                                    "Resuma diferenças entre semântica e sintática em um fluxograma."
                                  ],
                                  "verification": "Classifique corretamente 5 propriedades fornecidas e justifique cada uma.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Lista de propriedades de exemplo, quadro branco para fluxogramas.",
                                  "tips": "Pergunte sempre: 'Isso muda se eu reescrever a MT equivalentemente?'",
                                  "learningObjective": "Aplicar a definição para distinguir propriedades semânticas de outras.",
                                  "commonMistakes": "Classificar erroneamente propriedades triviais (ex: 'L(M) ⊆ Σ*') como não-semânticas."
                                }
                              ],
                              "practicalExample": "Considere P: 'L(M) é vazia'. Tome M1 que rejeita tudo imediatamente (L(M1)=∅). Construa M2 equivalentemente que loopa em entradas vazias mas rejeita outras (ainda L(M2)=∅). Ambas satisfazem P, provando semântica. Contrastar com Q: 'M tem ≤10 estados' – M1 tem 5, M2 tem 100, L iguais, mas Q falha em M2.",
                              "finalVerifications": [
                                "Reescreva a definição formal sem erros.",
                                "Classifique 3 propriedades como semânticas ou não, com justificativa.",
                                "Explique por que L(M1)=L(M2) é crucial.",
                                "Identifique uma propriedade sintática e construa contraexemplo.",
                                "Ligue à implicação no Teorema de Rice.",
                                "Descreva um par de MTs equivalentes compartilhando propriedade semântica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (bicondicional correta).",
                                "Correta distinção semântica vs. sintática com exemplos.",
                                "Profundidade na explicação de equivalência de linguagens.",
                                "Uso apropriado de notação lógica e provas simples.",
                                "Criatividade em contraexemplos e aplicações.",
                                "Clareza na comunicação escrita/oral da definição."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Quantificadores universais e implicações.",
                                "Filosofia da Ciência: Propriedades observáveis vs. intrínsecas (semântica como 'comportamento').",
                                "Engenharia de Software: Verificação de equivalência funcional de programas.",
                                "Matemática Discreta: Equivalência de estruturas formais."
                              ],
                              "realWorldApplication": "Na verificação de compiladores e analisadores, propriedades semânticas como 'o programa aceita apenas linguagens regulares válidas' guiam testes de equivalência comportamental, ignorando otimizações internas, essencial para ferramentas como LLVM ou verificadores de modelos em IA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Diferenciar propriedades semânticas e sintáticas",
                            "description": "Comparar propriedades semânticas (dependem da linguagem) com sintáticas (dependem da descrição da máquina, como 'a máquina para em 10 passos'), fornecendo exemplos como 'a linguagem é vazia' (semântica) vs. 'o código tem menos de 100 estados' (sintática).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Propriedades Semânticas",
                                  "subSteps": [
                                    "Leia a definição de propriedade semântica: uma propriedade que depende do comportamento da linguagem gerada ou reconhecida pela máquina, não da sua descrição formal.",
                                    "Estude exemplos clássicos: 'A linguagem é vazia (L(M)=∅)', 'A linguagem é tudo (L(M)=Σ*)', 'L(M) contém uma palavra específica'.",
                                    "Analise por que essas propriedades são independentes da representação da máquina: múltiplas descrições podem gerar a mesma linguagem.",
                                    "Discuta com exemplos de Máquinas de Turing (TM) ou autômatos como diferentes códigos podem reconhecer a mesma linguagem.",
                                    "Registre em um mapa mental as características chave: foca no 'o que é computado', não no 'como é descrito'."
                                  ],
                                  "verification": "Crie uma lista de 3 propriedades semânticas e justifique por que elas são semânticas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre Teorema de Rice",
                                    "Exemplos de TMs de um textbook como Sipser's Introduction to the Theory of Computation",
                                    "Papel e caneta para mapa mental"
                                  ],
                                  "tips": "Use analogia: semântica é o 'significado' da linguagem, como o que ela aceita, ignorando a 'forma' do código.",
                                  "learningObjective": "Identificar e exemplificar propriedades semânticas corretamente.",
                                  "commonMistakes": "Confundir com propriedades da máquina em si, como número de estados, achando que afetam a linguagem diretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Conceito de Propriedades Sintáticas",
                                  "subSteps": [
                                    "Leia a definição de propriedade sintática: uma propriedade que depende apenas da descrição formal da máquina, como tamanho do código ou estrutura do grafo de estados.",
                                    "Estude exemplos: 'O número de estados é par', 'O código tem menos de 100 símbolos', 'Há um estado com mais de 2 transições'.",
                                    "Analise por que são decidíveis: podem ser checadas sintaticamente sem simular a execução.",
                                    "Compare com autômatos finitos (AF): propriedades como 'é determinístico' são sintáticas.",
                                    "Registre diferenças iniciais em uma tabela comparativa com semânticas."
                                  ],
                                  "verification": "Liste 3 propriedades sintáticas e prove que são decidíveis via algoritmo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Mesmo textbook de Sipser",
                                    "Ferramenta online como JFLAP para visualizar autômatos",
                                    "Tabela em Excel ou papel"
                                  ],
                                  "tips": "Pense em sintáticas como 'checagem de código estático' em programação, sem rodar o programa.",
                                  "learningObjective": "Distinguir propriedades sintáticas e entender sua decidibilidade.",
                                  "commonMistakes": "Achar que propriedades como 'tem loop' são sintáticas se dependem de execução infinita (na verdade, pode ser semântica)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e Contrastar Propriedades Semânticas e Sintáticas",
                                  "subSteps": [
                                    "Preencha uma tabela comparativa: colunas para definição, exemplos, decidibilidade, dependência.",
                                    "Resolva exercícios: classifique 5 propriedades dadas como semântica ou sintática, ex: 'L(M) é regular' (semântica).",
                                    "Discuta o Teorema de Rice: propriedades semânticas não-triviais são indecidíveis.",
                                    "Crie contra-exemplos: duas TMs com mesma linguagem mas descrições diferentes (prova independência semântica).",
                                    "Pratique com quiz autoavaliativo de 10 itens."
                                  ],
                                  "verification": "Classifique corretamente 8/10 propriedades em um quiz.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Exercícios do textbook ou site como theory.csail.mit.edu",
                                    "Quiz online criado por você no Google Forms"
                                  ],
                                  "tips": "Lembre: se mudar a descrição sem mudar a linguagem, propriedade semântica permanece igual; sintática muda.",
                                  "learningObjective": "Comparar diferenças chave e aplicar no contexto de indecidibilidade.",
                                  "commonMistakes": "Classificar 'a TM para em todas entradas' como sintática (é semântica, halting problem)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Diferenciação em Cenários Reais",
                                  "subSteps": [
                                    "Analise propriedades de programas reais: ex, 'o programa imprime 'hello'' (semântica) vs. 'tem menos de 50 linhas' (sintática).",
                                    "Resolva problema: dada uma TM, liste 2 semânticas e 2 sintáticas associadas.",
                                    "Debata: por que Rice usa essa distinção para provar indecidibilidade.",
                                    "Crie seu próprio exemplo de propriedade indecidível via Rice.",
                                    "Avalie um peer review de classificações."
                                  ],
                                  "verification": "Produza um relatório com 4 exemplos classificados e justificadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de código TM em Python simulator",
                                    "Fórum ou parceiro de estudo para peer review"
                                  ],
                                  "tips": "Conecte com programação: linters checam sintáticas, testes unitários aproximam semânticas.",
                                  "learningObjective": "Aplicar diferenciação para analisar problemas de teoria da computação.",
                                  "commonMistakes": "Ignorar trivialidade em Rice: propriedades triviais semânticas podem ser decidíveis."
                                }
                              ],
                              "practicalExample": "Dada uma TM M que reconhece { ww | w ∈ {0,1}* }: Propriedade semântica: 'L(M) contém palíndromos' (verdadeiro, depende da linguagem). Propriedade sintática: 'M tem exatamente 5 estados' (falso, conta estados no diagrama). Classifique e justifique.",
                              "finalVerifications": [
                                "Pode listar 3 exemplos semânticos e 3 sintáticos corretos.",
                                "Classifica corretamente propriedades em 90% dos casos.",
                                "Explica ligação com Rice: semânticas não-triviais indecidíveis.",
                                "Dá contra-exemplo para independência semântica.",
                                "Aplica em uma TM simples fornecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação (80% peso): 90% acertos.",
                                "Profundidade de justificativas: cita linguagem vs. descrição.",
                                "Criatividade em exemplos: originais e relevantes.",
                                "Compreensão de Rice: explica trivialidade.",
                                "Clareza na comunicação: tabela ou mapa mental bem estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: propriedades decidíveis vs. indecidíveis em teoremas de Gödel.",
                                "Programação: análise estática (sintática) vs. testes (semântica).",
                                "Filosofia da Computação: limites da computação.",
                                "Linguística: semântica vs. sintaxe em linguagens naturais.",
                                "Engenharia de Software: verificação formal de propriedades."
                              ],
                              "realWorldApplication": "Em verificadores de software como ESLint (sintáticas: estilo de código) vs. ferramentas de prova como Coq (semânticas: corretude da lógica), ajudando a decidir o que automatizar vs. o que requer provas manuais em sistemas críticos como aviônicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Identificar exemplos de propriedades semânticas",
                            "description": "Classificar propriedades como 'L é finita', 'L é vazia', 'L contém todas as strings' ou 'L é recursiva' como semânticas, justificando com base na dependência exclusiva da linguagem reconhecida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de propriedades semânticas no Teorema de Rice",
                                  "subSteps": [
                                    "Leia a definição do Teorema de Rice: uma propriedade semântica de linguagens recursivamente enumeráveis é não-trivial e depende apenas da linguagem reconhecida, não da máquina de Turing específica.",
                                    "Identifique que propriedades semânticas são decidíveis apenas se triviais (todas ou nenhuma linguagem satisfaz).",
                                    "Estude exemplos iniciais: propriedades como 'L é vazia' ou 'L é finita' são semânticas porque se referem à linguagem L, não à descrição da TM.",
                                    "Anote a diferença chave: independência da codificação da TM.",
                                    "Revise o teorema formal: para todo conjunto não-trivial C de linguagens RE, o problema { <M> | L(M) ∈ C } é indecidível."
                                  ],
                                  "verification": "Escreva uma definição em suas próprias palavras e liste 2 exemplos de propriedades semânticas com justificativa breve.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de teoria da computação (ex: Sipser), notas de aula sobre Teorema de Rice, quadro branco ou papel para anotações.",
                                  "tips": "Use analogias: pense na linguagem como o 'conjunto de soluções' de um problema, independente de como o programa é escrito.",
                                  "learningObjective": "Compreender que propriedades semânticas dependem exclusivamente da linguagem reconhecida pela TM.",
                                  "commonMistakes": "Confundir com propriedades da máquina (ex: 'TM para em 10 passos'), que são sintáticas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Distinguir propriedades semânticas de sintáticas",
                                  "subSteps": [
                                    "Liste propriedades sintáticas: dependem da descrição da TM, como 'TM tem no máximo 100 estados' ou 'TM usa apenas 3 símbolos'.",
                                    "Compare com semânticas: 'L(M) é finita' – varia se mudarmos a TM mas mantendo a mesma L.",
                                    "Crie uma tabela: coluna 1 sintáticas (ex: comprimento de <M>), coluna 2 semânticas (ex: L contém ε).",
                                    "Teste: para uma propriedade P, pergunte 'duas TMs com mesma L têm mesmo P?'. Sim → semântica.",
                                    "Pratique com 3 pares de TMs equivalentes e verifique se P é preservada."
                                  ],
                                  "verification": "Classifique 5 propriedades dadas (3 semânticas, 2 sintáticas) corretamente em uma tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de exercícios com propriedades mistas, simulador de TM online (ex: JFLAP).",
                                  "tips": "Lembre: semântica = sobre o que a TM aceita, não como ela é construída.",
                                  "learningObjective": "Diferenciar propriedades baseadas na linguagem vs. na máquina.",
                                  "commonMistakes": "Classificar 'L é recursiva' como sintática por confundir com halting."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos específicos de propriedades semânticas",
                                  "subSteps": [
                                    "Examine 'L é vazia': semântica porque depende se L( M ) = ∅, não da TM.",
                                    "Analise 'L é finita': conta strings em L, independente de <M>.",
                                    "Estude 'L contém todas as strings': L = Σ*, trivial semântica.",
                                    "Verifique 'L é recursiva': depende da linguagem ser decidível.",
                                    "Para cada uma, prove reduzindo a um problema conhecido indecidível via Rice."
                                  ],
                                  "verification": "Para cada exemplo, escreva uma justificativa de 2-3 frases confirmando que é semântica.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplos impressos ou digitais do teorema, calculadora para redução de Rice.",
                                  "tips": "Use o critério de Rice: se C = {L | propriedade} é não-trivial, então semântica e indecidível.",
                                  "learningObjective": "Classificar propriedades listadas como semânticas com base na dependência da linguagem.",
                                  "commonMistakes": "Ignorar trivialidade: 'TM aceita todas entradas' pode ser trivial se sempre verdadeiro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar justificação e aplicação do conceito",
                                  "subSteps": [
                                    "Pegue novas propriedades e classifique: ex: 'L contém w0' para w0 fixa (semântica).",
                                    "Justifique: mostre que duas TMs com mesma L têm mesmo valor da propriedade.",
                                    "Crie contraexemplos para sintáticas: mude <M> sem mudar L e veja P mudar.",
                                    "Resolva um exercício: prove indecidibilidade de 'L é finita' reduzindo de halting.",
                                    "Autoavalie com quiz de 5 perguntas mistas."
                                  ],
                                  "verification": "Resolva um conjunto de 5 exercícios de classificação com 100% acerto e justificativas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Quiz impresso ou online sobre Rice, timer para prática.",
                                  "tips": "Pratique redução: reduza 'L(M) vazia?' a 'L(N) finita?' para prova.",
                                  "learningObjective": "Justificar classificações com argumentos formais baseados em Rice.",
                                  "commonMistakes": "Confundir 'recursiva' com 'recursivamente enumerável'."
                                }
                              ],
                              "practicalExample": "Dada a propriedade 'L(M) é finita'. Classifique como semântica: duas TMs M1 e M2 com L(M1)=L(M2)={ε} (finita) satisfazem; se L={0^n | n≥0} (infinita), não. Não depende de estados/símbolos de M, mas só de L. Indecidível por Rice, pois C={L RE finita} não-trivial.",
                              "finalVerifications": [
                                "Classifica corretamente 'L é vazia', 'L é finita', 'L contém todas strings', 'L é recursiva' como semânticas.",
                                "Justifica cada uma mostrando independência da codificação da TM.",
                                "Distingue de sintáticas como 'TM tem paridade de estados'.",
                                "Aplica critério de Rice: não-trivialidade para indecidibilidade.",
                                "Resolve 80% de exercícios mistos sem erros.",
                                "Explica redução de exemplo conhecido (ex: halting) para uma propriedade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação: 100% para exemplos canônicos.",
                                "Qualidade da justificativa: usa dependência exclusiva de L.",
                                "Distinção clara sintática/semântica com exemplos.",
                                "Compreensão de Rice: identifica trivial/não-trivial corretamente.",
                                "Criatividade em contraexemplos e reduções.",
                                "Clareza na comunicação: justificativas concisas e lógicas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos (propriedades de linguagens como subconjuntos de Σ*).",
                                "Lógica: Propriedades não-triviais semelhantes a teoremas de Gödel.",
                                "Filosofia da Computação: Limites da computação e indecidibilidade.",
                                "Engenharia de Software: Verificação de propriedades de programas."
                              ],
                              "realWorldApplication": "Em análise de malware: verificar se conjunto de strings maliciosas reconhecidas por um detector é finito/vazio, guiando otimizações sem decidir propriedades indecidíveis diretamente, mas usando aproximações ou oráculos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Propriedades Triviais e Não-Triviais",
                        "description": "Classificação de propriedades semânticas: triviais (todas ou nenhuma linguagem r.e. satisfaz) versus não-triviais (algumas sim, outras não).",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Definir propriedade trivial",
                            "description": "Descrever que uma propriedade semântica P é trivial se ou todas as linguagens recursivamente enumeráveis satisfazem P, ou nenhuma satisfaz P, com exemplos como 'L é recursivamente enumerável' (todas) ou 'L é cofinita' (nem todas, mas ilustrar trivialidade).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Linguagens Recursivamente Enumeráveis (RE)",
                                  "subSteps": [
                                    "Lembre-se que uma linguagem L é RE se existe uma TM que aceita todas as strings em L e pode loopar em strings fora de L.",
                                    "Entenda o conjunto de todas as linguagens RE, denotado como RE.",
                                    "Discuta que propriedades semânticas são predicados sobre linguagens inteiras, não sobre strings individuais.",
                                    "Identifique exemplos iniciais de propriedades semânticas, como 'L é vazia' ou 'L contém a string ε'.",
                                    "Diferencie propriedades semânticas de sintáticas (que dependem da codificação da TM)."
                                  ],
                                  "verification": "Escreva uma definição precisa de RE e liste 3 propriedades semânticas com exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas de aula sobre Teoria da Computação, livro como 'Sipser Introduction to the Theory of Computation'.",
                                  "tips": "Use diagramas de TMs para visualizar aceitação em RE languages.",
                                  "learningObjective": "Compreender o universo de linguagens RE como base para propriedades triviais.",
                                  "commonMistakes": "Confundir RE com recursivas (decidíveis); RE permite loop infinito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formalizar o Conceito de Propriedade Semântica",
                                  "subSteps": [
                                    "Defina uma propriedade semântica P como uma propriedade que depende apenas da linguagem reconhecida por uma TM, não de sua codificação.",
                                    "Estabeleça que P é um subconjunto de RE: P ⊆ RE.",
                                    "Discuta por que propriedades semânticas são relevantes no Teorema de Rice.",
                                    "Classifique propriedades como index-independentes.",
                                    "Exemplo: P(L) = 'L é finita' é semântica porque independe da TM que gera L."
                                  ],
                                  "verification": "Classifique 3 propriedades dadas (ex: 'L contém 0', 'TM para L halts on ε') como semânticas ou não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Quadro branco ou papel para diagramas, exemplos de TMs.",
                                  "tips": "Pense em renomear variáveis na TM sem mudar a linguagem; se P permanece igual, é semântica.",
                                  "learningObjective": "Distinguir propriedades semânticas das sintáticas com precisão.",
                                  "commonMistakes": "Achar que propriedades sobre TMs específicas são semânticas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Compreender Propriedade Trivial",
                                  "subSteps": [
                                    "Defina P trivial se P(RE) = RE (todas RE languages satisfazem P) OU P(RE) = ∅ (nenhuma satisfaz P).",
                                    "Prove que se P é trivial, então { <M> | P(L(M)) } é decidível.",
                                    "Entenda que trivialidade significa ou sempre verdadeiro ou sempre falso para RE.",
                                    "Discuta implicações no Teorema de Rice: só propriedades não-triviais levam a indecidibilidade.",
                                    "Formalize com notação: P trivial ⇔ ∀L ∈ RE, P(L) ou ∀L ∈ RE, ¬P(L)."
                                  ],
                                  "verification": "Escreva a definição formal e prove trivialidade para um caso simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de exercícios sobre Rice, calculadora simbólica opcional.",
                                  "tips": "Use contrapartidas: se existe L1 em P e L2 não em P, ambas RE, então não-trivial.",
                                  "learningObjective": "Dominar a definição exata de propriedade trivial.",
                                  "commonMistakes": "Confundir com propriedades verdadeiras para todas as linguagens possíveis, não só RE."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Exemplos e Contraexemplos de Propriedades Triviais",
                                  "subSteps": [
                                    "Exemplo trivial (todas): P(L) = 'L é RE' – pois todo L em consideração é RE.",
                                    "Exemplo trivial (nenhuma): P(L) = 'L é cofinita' – existe RE languages cofinitas? Não, pois complementos de RE não são RE em geral; na verdade, cofinita RE implica decidível, mas ilustre com RE infinitas não-cofinitas.",
                                    "Contraexemplo não-trivial: P(L) = 'L é vazia' – ∅ é RE, mas Σ* também é RE e não vazia.",
                                    "Verifique mais 2 exemplos: 'L contém ε' (não-trivial), 'L é regular' (não-trivial).",
                                    "Conecte à prova de Rice: trivialidade permite algoritmo simples."
                                  ],
                                  "verification": "Classifique 5 propriedades como trivial/não-trivial com justificativa.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Lista de propriedades pré-preparada, exemplos de linguagens RE.",
                                  "tips": "Para provar 'todas', note que domínio é RE; para 'nenhuma', encontre contraexemplo RE.",
                                  "learningObjective": "Aplicar definição para classificar propriedades corretamente.",
                                  "commonMistakes": "Achar 'L é RE' não-trivial; é trivial por definição do contexto."
                                }
                              ],
                              "practicalExample": "Considere P(L) = 'L é recursivamente enumerável'. Para provar trivial: todo L no teorema é RE por hipótese, então P(L) vale para todas RE languages. Algoritmo decidível: sempre aceite <M>, pois L(M) é RE se M é TM.",
                              "finalVerifications": [
                                "Defina precisamente propriedade trivial usando notação formal.",
                                "Classifique corretamente 'L é RE' como trivial (todas).",
                                "Forneça exemplo de trivial 'nenhuma' como 'L é o complemento de uma RE não-recursiva'.",
                                "Explique por que trivial implica decidível no Rice.",
                                "Distinga de não-trivial com contraexemplo.",
                                "Liste 2 conexões com teorema de Rice."
                              ],
                              "assessmentCriteria": [
                                "Definição exata sem erros (P(RE)=RE ou ∅).",
                                "Exemplos corretos com provas breves.",
                                "Compreensão de semântica vs sintática.",
                                "Aplicação correta a novos casos.",
                                "Clareza na distinção trivial/não-trivial.",
                                "Conexão lógica com indecidibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (subconjuntos de RE).",
                                "Lógica: Predicados e quantificadores universais/existenciais.",
                                "Filosofia da Computação: Limites da computação e decidibilidade.",
                                "Programação: Verificação de propriedades de programas."
                              ],
                              "realWorldApplication": "Em verificação de software e análise de malware, entender propriedades triviais de linguagens de padrões ajuda a focar em questões indecidíveis, como 'este programa halta?', evitando esforços fúteis em teoremas como Rice para otimizar ferramentas de análise estática."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Identificar propriedades não-triviais",
                            "description": "Reconhecer propriedades como 'L é vazia', 'L é infinita' ou 'L contém a string 0' como não-triviais, pois existem linguagens r.e. que as satisfazem e outras que não, citando contraexemplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Propriedades Semânticas no Teorema de Rice",
                                  "subSteps": [
                                    "Revise a definição de uma propriedade semântica: um subconjunto C ⊆ {L | L é r.e.}.",
                                    "Estude o Teorema de Rice: para propriedades semânticas não-triviais, os problemas de decisão são indecidíveis.",
                                    "Diferencie propriedades sintáticas (dependem da forma do programa) de semânticas (dependem do comportamento).",
                                    "Analise exemplos iniciais: 'L é o conjunto vazio' é semântica.",
                                    "Registre notas sobre por que propriedades como 'o programa contém a palavra \"halt\"' são sintáticas e triviais."
                                  ],
                                  "verification": "Escreva uma definição precisa de propriedade semântica e classifique 3 exemplos como semântica ou sintática.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre Teorema de Rice, livro 'Sipser - Introdução à Teoria da Computação' (Capítulo 9).",
                                  "tips": "Sempre pergunte: 'Isso depende do que a máquina faz, não de como está escrita?'",
                                  "learningObjective": "Compreender a distinção fundamental entre propriedades semânticas e sintáticas.",
                                  "commonMistakes": "Confundir propriedades que dependem da codificação do programa com semânticas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Diferenciar Propriedades Triviais e Não-Triviais",
                                  "subSteps": [
                                    "Memorize: Propriedade trivial se C = ∅ ou C = todas as r.e.; caso contrário, não-trivial.",
                                    "Entenda que trivial significa indecidível só se vazia ou tudo, mas sempre decidível.",
                                    "Construa exemplos: C = {L r.e. | L vazia} é não-trivial (existe Σ* que não satisfaz).",
                                    "Liste critérios: Para não-trivial, deve existir pelo menos uma L r.e. em C e uma fora de C.",
                                    "Pratique formalizando: Dado C, prove se é trivial fornecendo contraexemplos."
                                  ],
                                  "verification": "Classifique 2 propriedades como trivial ou não-trivial, justificando com exemplos de L r.e.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Folha de exercícios sobre Rice, simulador de máquinas de Turing online.",
                                  "tips": "Use linguagens canônicas: φ_e (r.e. padrão) e Σ* (r.e. total).",
                                  "learningObjective": "Dominar a definição exata de trivialidade para propriedades semânticas.",
                                  "commonMistakes": "Achar que 'L contém 0' é trivial; lembre que há r.e. com e sem 0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Exemplos Clássicos de Propriedades Não-Triviais",
                                  "subSteps": [
                                    "'L é vazia': Contraexemplo positivo: L=∅; negativo: L=Σ*.",
                                    "'L é infinita': Positivo: L=Σ*; negativo: L={ε}.",
                                    "'L contém a string 0': Positivo: L={0}; negativo: L=Σ* sem 0 (ex: {1}* ).",
                                    "Verifique mais: 'L é cofinita' ou 'L é regular' (esta última é semântica?).",
                                    "Crie tabela: Propriedade | Exemplo em C | Exemplo fora de C."
                                  ],
                                  "verification": "Para 4 propriedades dadas, identifique se não-trivial e cite contraexemplos.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "Lista de propriedades comuns (fornecida no contexto do curso), quadro branco para tabelas.",
                                  "tips": "Sempre teste com L=∅, L=Σ*, L singleton para rapidez.",
                                  "learningObjective": "Reconhecer padrões em propriedades não-triviais comuns.",
                                  "commonMistakes": "Esquecer que todas as r.e. não-vazias podem ser infinitas ou finitas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Exercícios e Contraexemplos",
                                  "subSteps": [
                                    "Resolva 5 exercícios: Classifique propriedades como trivial/não-trivial.",
                                    "Para cada não-trivial, prove existência de L r.e. satisfazendo e não satisfazendo.",
                                    "Discuta em grupo ou autoavalie: 'Por que L=φ_e (padrão) ajuda?'",
                                    "Crie sua própria propriedade e classifique-a.",
                                    "Revise erros: Ajuste classificações incorretas."
                                  ],
                                  "verification": "Submeta relatório com 5 classificações corretas, incluindo contraexemplos.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": "Banco de exercícios do curso, ferramenta de anotações como Notion ou papel.",
                                  "tips": "Se duvidar, reduza a alfabeto Σ={0,1} para simplicidade.",
                                  "learningObjective": "Aplicar o conceito de forma autônoma em novos casos.",
                                  "commonMistakes": "Ignorar que propriedades devem ser sobre todas r.e., não só regulares."
                                }
                              ],
                              "practicalExample": "Propriedade P: 'L contém a string '0''. Não-trivial porque existe L1 = {'0'} (r.e., contém '0') e L2 = {'1'}* (r.e., não contém '0'). Para decidir se uma máquina M aceita L com '0' é indecidível por Rice.",
                              "finalVerifications": [
                                "Classifica corretamente 'L é vazia' como não-trivial com exemplos.",
                                "Identifica 'todas as r.e.' como trivial.",
                                "Fornece contraexemplos válidos r.e. para propriedades dadas.",
                                "Explica por que uma propriedade é não-trivial em termos de Rice.",
                                "Distingue semântica de sintática em 90% dos casos.",
                                "Cria uma propriedade não-trivial própria com prova."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de trivial/não-trivial (100% correto).",
                                "Qualidade dos contraexemplos: devem ser explicitamente r.e.",
                                "Completude: todos os campos de justificativa preenchidos.",
                                "Criatividade em exemplos originais.",
                                "Velocidade e confiança na classificação (sem hesitação em básicos).",
                                "Integração com Teorema de Rice (menciona indecidibilidade)."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Semelhança com propriedades em teoria dos modelos.",
                                "Teoria dos Conjuntos: Noções de subconjuntos não-vazios e próprios.",
                                "Programação: Verificação de propriedades de linguagens em compiladores.",
                                "Filosofia da Computação: Discussões sobre limites da computação."
                              ],
                              "realWorldApplication": "Em verificação de software e análise estática de código, identificar propriedades não-triviais de programas ajuda a entender por que certas checagens automáticas (ex: 'este programa sempre termina?') são impossíveis, guiando o design de ferramentas como linters ou provers que lidam apenas com decidíveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.1",
                              "10.1.7.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Provar trivialidade de uma propriedade",
                            "description": "Demonstrar formalmente se uma dada propriedade semântica é trivial, verificando se o conjunto indexado por P é vazio ou o conjunto total de máquinas de Turing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições fundamentais de propriedades semânticas e trivialidade",
                                  "subSteps": [
                                    "Ler e anotar a definição de propriedade semântica: um predicado P sobre linguagens que depende apenas de L(M), não da máquina M.",
                                    "Estudar o Teorema de Rice: para P semântica não-trivial, o conjunto {e | P(L(M_e))} é indecidível.",
                                    "Memorizar que P é trivial se K_P = ∅ ou K_P = ℕ, onde ℕ é o conjunto de índices de MTs.",
                                    "Listar exemplos: trivial (\"L é RE\"), não-trivial (\"L é vazia\").",
                                    "Confirmar que a propriedade dada é semântica verificando independência de M."
                                  ],
                                  "verification": "Escrever definições em palavras próprias e citar 2 exemplos triviais e 2 não-triviais corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou Hopcroft/Ullman)",
                                    "Notas de aula sobre Rice's Theorem"
                                  ],
                                  "tips": "Use Venn diagrams para visualizar K_P como subconjunto possível de ℕ.",
                                  "learningObjective": "Compreender precisamente os conceitos chave para análise de trivialidade.",
                                  "commonMistakes": [
                                    "Confundir semântica (depende de L) com sintática (depende de M)",
                                    "Acreditar que trivial implica decidível facilmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formalizar a propriedade P e o conjunto K_P",
                                  "subSteps": [
                                    "Escrever P formalmente como P: 2^{Σ*} → {true, false}.",
                                    "Definir K_P = {e ∈ ℕ | P(L(M_e)) = true}, assumindo enumeração padrão de MTs.",
                                    "Verificar se P é semântica: provar que se L(M_1) = L(M_2), então P(L(M_1)) = P(L(M_2)).",
                                    "Especificar o alfabeto Σ e qualquer assunção sobre MTs (ex: multi-tape).",
                                    "Documentar em notação matemática clara."
                                  ],
                                  "verification": "Produzir definição escrita de K_P para uma P exemplo, revisada por par ou auto-check.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência à enumeração de Gödel para MTs"
                                  ],
                                  "tips": "Sempre quantifique sobre todas MTs equivalentes reconhecendo a mesma L.",
                                  "learningObjective": "Capacitar formalização precisa para aplicação do teorema.",
                                  "commonMistakes": [
                                    "Omitir verificação de semântica",
                                    "Confundir L(M_e) com domínio de M_e"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que K_P = ∅ (nenhuma MT satisfaz P)",
                                  "subSteps": [
                                    "Assumir ∃e tal que P(L(M_e)) = true.",
                                    "Derivar contradição usando propriedades universais de linguagens RE (ex: closure, diagonalização).",
                                    "Mostrar diretamente que ∀M, P(L(M)) = false (ex: P requer co-RE strict).",
                                    "Usar exemplo concreto como P(L) = 'L não é RE'.",
                                    "Generalizar para qualquer P impossível em RE."
                                  ],
                                  "verification": "Escrever prova completa por contradição aceita por revisão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplos de linguagens RE e suas propriedades",
                                    "Ferramenta de prova como LaTeX"
                                  ],
                                  "tips": "Lembre que RE languages satisfazem certas propriedades por definição.",
                                  "learningObjective": "Mestrar provas de impossibilidade para conjuntos vazios.",
                                  "commonMistakes": [
                                    "Ignorar MTs que loopam infinitamente",
                                    "Usar argumentos não-rigorosos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar que K_P = ℕ (todas as MTs satisfazem P)",
                                  "subSteps": [
                                    "Provar ∀e ∈ ℕ, P(L(M_e)) = true.",
                                    "Usar construção universal: L(M_e) sempre satisfaz propriedade definicional de RE.",
                                    "Tratar casos: M_e halting ou não, via simulação.",
                                    "Exemplo: P(L) = 'L é RE' – true por construção de M_e.",
                                    "Verificar para MTs patológicas (ex: nunca aceita)."
                                  ],
                                  "verification": "Prova formal ∀e com contraexemplo se falhar.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Descrição da máquina universal de Turing",
                                    "Lista de propriedades sempre verdadeiras para RE"
                                  ],
                                  "tips": "Comece com 'Por definição da enumeração...'",
                                  "learningObjective": "Dominar provas universais sobre todas MTs.",
                                  "commonMistakes": [
                                    "Esquecer MTs que reconhecem linguagens específicas",
                                    "Confundir RE com decidível"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir trivialidade e redigir prova formal completa",
                                  "subSteps": [
                                    "Analisar resultados: se K_P = ∅ ou ℕ, P trivial; senão, não-trivial.",
                                    "Compilar prova: introdução, formalizações, casos, conclusão.",
                                    "Aplicar a uma P dada e testar com exemplos conhecidos.",
                                    "Discutir implicações: trivial → decidível, mas irrelevante.",
                                    "Revisar por gaps lógicos."
                                  ],
                                  "verification": "Documento final de prova submetido e aprovado sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Template LaTeX para provas",
                                    "Checklist de Rice's Theorem"
                                  ],
                                  "tips": "Estruture como: Definições → Análise → Conclusão.",
                                  "learningObjective": "Sintetizar análise em prova coesa.",
                                  "commonMistakes": [
                                    "Concluir trivial sem provar ambos os casos possíveis",
                                    "Omitir rigor formal"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere P(L) = 'L é recursivamente enumerável'. Formalize K_P = {e | L(M_e) é RE}. Por construção da enumeração padrão, toda L(M_e) é RE (M_e enumera/simula), logo ∀e, P(L(M_e)) = true, K_P = ℕ, trivial. Exemplo vazio: P(L) = 'L não é RE'. Então ∀e, L(M_e) é RE, P = false, K_P = ∅, trivial.",
                              "finalVerifications": [
                                "Define corretamente propriedade semântica e K_P.",
                                "Prova K_P = ∅ ou ℕ para pelo menos um exemplo trivial.",
                                "Escreve prova formal sem falácias lógicas.",
                                "Identifica trivialidade corretamente para P dada.",
                                "Explica por que trivial implica decidível.",
                                "Lista 3 propriedades triviais com justificativa."
                              ],
                              "assessmentCriteria": [
                                "Formalização precisa de P e K_P (20%)",
                                "Corretude lógica nas provas de vazio/total (40%)",
                                "Rigor matemático e clareza (20%)",
                                "Verificação de semântica (10%)",
                                "Conclusão e implicações corretas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos, quantificadores universais/existenciais.",
                                "Lógica: Provas por contradição, teoremas de incompletude.",
                                "Filosofia: Limites da computação (Church-Turing thesis).",
                                "Engenharia: Verificação de propriedades em compiladores."
                              ],
                              "realWorldApplication": "Em verificação de software e IA, distinguir propriedades triviais (ex: 'modelo é computável') de não-triviais (ex: 'lógica é segura') permite priorizar esforços em análises undecidíveis, como checagem de vulnerabilidades semânticas em sistemas autônomos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Teorema de Rice",
                        "description": "Teorema que estabelece a indecidibilidade de qualquer propriedade semântica não-trivial das linguagens recursivamente enumeráveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Enunciar o Teorema de Rice",
                            "description": "Estabelecer precisamente: Para qualquer propriedade semântica não-trivial P das linguagens r.e., o problema 'Dada uma MT M, L(M) satisfaz P?' é indecidível.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Pré-Requisitos",
                                  "subSteps": [
                                    "Defina linguagens recursivamente enumeráveis (r.e.): linguagens reconhecidas por alguma Máquina de Turing (MT).",
                                    "Explique o que é uma MT e sua linguagem L(M).",
                                    "Diferencie propriedades sintáticas (sobre a forma da descrição da MT) de propriedades semânticas (sobre a linguagem gerada)."
                                  ],
                                  "verification": "Escreva definições precisas dos três conceitos em suas próprias palavras e compare com fontes padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 5)",
                                    "Notas de aula sobre Teoria da Computação"
                                  ],
                                  "tips": "Use diagramas para visualizar MTs e suas linguagens.",
                                  "learningObjective": "Dominar os termos fundamentais para contextualizar o teorema.",
                                  "commonMistakes": "Confundir linguagens r.e. com linguagens recursivas ou decidíveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Propriedades Semânticas e Trivialidade",
                                  "subSteps": [
                                    "Defina propriedade semântica P: um subconjunto das linguagens r.e.",
                                    "Classifique P como trivial se P = ∅ ou P = todas as linguagens r.e.",
                                    "Forneça exemplos: P trivial (L(M)=∅), P não-trivial (L(M) contém '0')."
                                  ],
                                  "verification": "Identifique se três propriedades dadas são semânticas, e classifique como trivial ou não-trivial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de propriedades de linguagens r.e. de anotações",
                                    "Artigo ou vídeo sobre Teorema de Rice"
                                  ],
                                  "tips": "Lembre-se: trivialidade é sobre o conjunto de linguagens r.e. que satisfazem P.",
                                  "learningObjective": "Distinguir propriedades semânticas não-triviais.",
                                  "commonMistakes": "Confundir trivial com 'fácil de decidir'; trivial é puramente de cobertura."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Problema de Decisão Associado",
                                  "subSteps": [
                                    "Formule o problema: 'Dada MT M e propriedade P, L(M) ∈ P?'",
                                    "Relacione com o Problema da Parada (Halting Problem), que é um caso especial.",
                                    "Discuta por que propriedades sintáticas podem ser decidíveis, mas semânticas não."
                                  ],
                                  "verification": "Escreva o problema formalmente para uma P específica (ex: L(M) infinita?).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo para redução do Halting Problem",
                                    "Ferramenta online de simulador de MT (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": "Sempre especifique 'qualquer MT M' para enfatizar universalidade.",
                                  "learningObjective": "Compreender a forma indecidível do problema central.",
                                  "commonMistakes": "Esquecer que P deve ser não-trivial para indecidibilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Memorizar e Praticar o Enunciado Preciso",
                                  "subSteps": [
                                    "Leia o enunciado oficial múltiplas vezes: 'Para qualquer P semântica não-trivial sobre linguagens r.e., o problema {⟨M⟩ | L(M) satisfaz P} é indecidível.'",
                                    "Divida em partes: 'qualquer P', 'semântica não-trivial', 'linguagens r.e.', 'problema indecidível'.",
                                    "Pratique escrevendo e recitando o enunciado 5 vezes, variando as palavras sinônimas."
                                  ],
                                  "verification": "Enuncie o teorema por escrito sem consultar fontes e autoavalie precisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Flashcards com enunciado (Anki ou papel)",
                                    "Gravação de si mesmo recitando"
                                  ],
                                  "tips": "Associe a uma história: Rice 'arrozou' as esperanças de decidibilidade semântica.",
                                  "learningObjective": "Enunciar o teorema com precisão verbatim.",
                                  "commonMistakes": "Omitir 'não-trivial' ou confundir com sintáticas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar Compreensão via Exemplos",
                                  "subSteps": [
                                    "Aplique a uma P não-trivial: 'L(M) é cofinita?' – argumente indecidibilidade.",
                                    "Encontre contraexemplos para P trivial: mostre decidibilidade.",
                                    "Discuta implicações: todo problema semântico reduz ao Halting."
                                  ],
                                  "verification": "Resolva 3 exercícios: classifique P e justifique decidibilidade/indecidibilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de exercícios de indecidibilidade (Hopcroft/Ullman)"
                                  ],
                                  "tips": "Use reduções para conectar a problemas conhecidos.",
                                  "learningObjective": "Aplicar o teorema para validar enunciado.",
                                  "commonMistakes": "Aplicar teorema a propriedades não-semânticas."
                                }
                              ],
                              "practicalExample": "Considere P = {L r.e. | L contém a palavra 'abc'}. É semântica não-trivial (existe MT com L=∅ não satisfaz, MT aceitando 'abc' satisfaz). Pelo Teorema de Rice, 'Dada M, 'abc' ∈ L(M)?' é indecidível.",
                              "finalVerifications": [
                                "Enuncie o teorema verbatim sem erros.",
                                "Classifique corretamente 3 propriedades como trivial/não-trivial.",
                                "Formule o problema de decisão para uma P dada.",
                                "Explique diferença entre semântica e sintática com exemplo.",
                                "Reduza Halting Problem a uma instância do teorema."
                              ],
                              "assessmentCriteria": [
                                "Precisão verbatim do enunciado (100% match).",
                                "Correta identificação de não-trivialidade (exemplos válidos).",
                                "Clareza na formulação do problema de decisão.",
                                "Uso correto de termos r.e./MT.",
                                "Capacidade de aplicar a exemplos concretos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reduções em Teoria da Complexidade (NP-completude).",
                                "Lógica: Teorema de Incompletude de Gödel (limites formais).",
                                "Filosofia: Limites do mecanicismo computacional (Turing/Church).",
                                "Engenharia de Software: Verificação estática de código (impossibilidades)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, explica por que ferramentas como linters não podem verificar universalmente propriedades semânticas como 'este programa nunca crasha em inputs reais', guiando foco em análises aproximadas e testes empíricos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Compreender a prova do Teorema de Rice",
                            "description": "Explicar a redução ao problema da parada: construir máquinas que simulam uma MT fixa e modificam a linguagem para entrar ou não em P, usando reduções de decidibilidade para mostrar indecidibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o enunciado do Teorema de Rice",
                                  "subSteps": [
                                    "Leia e memorize o enunciado exato do Teorema de Rice: para qualquer propriedade semântica não-trivial P das linguagens reconhecidas por MTs, o problema { <M> | L(M) satisfaz P } é indecidível.",
                                    "Identifique propriedades triviais (ex: L(M)=Σ*) e não-triviais (ex: L(M) vazia?).",
                                    "Classifique exemplos de propriedades semânticas vs. sintáticas.",
                                    "Explique por que propriedades triviais são decidíveis.",
                                    "Discuta o que significa 'não-trivial' em termos de conjuntos S_P = {M | L(M) ∈ P} sendo Σ* ou vazio."
                                  ],
                                  "verification": "Reescreva o teorema corretamente e dê 2 exemplos de propriedades triviais e 3 não-triviais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Notas de aula sobre indecidibilidade",
                                    "Vídeo introdutório sobre Rice (YouTube)"
                                  ],
                                  "tips": "Foquem em propriedades que dependem da semântica da linguagem, não da sintaxe da MT.",
                                  "learningObjective": "Dominar o statement preciso e as condições do teorema.",
                                  "commonMistakes": [
                                    "Confundir propriedades semânticas com sintáticas (ex: MT aceita ε).",
                                    "Achar que todas as propriedades são indecidíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar o Problema da Parada (Halting Problem)",
                                  "subSteps": [
                                    "Lembre a prova de indecidibilidade do Halting Problem via diagonalização.",
                                    "Defina formalmente H = { <M,w> | M halta em w }.",
                                    "Entenda por que H é RE mas não decidível.",
                                    "Discuta reduções de problemas indecidíveis como base para provas.",
                                    "Pratique reduzindo problemas simples a H."
                                  ],
                                  "verification": "Prove informalmente a indecidibilidade de H e explique uma redução básica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Capítulo sobre Halting Problem no livro texto",
                                    "Exercícios resolvidos de reduções",
                                    "Simulador de MT online"
                                  ],
                                  "tips": "Use diagramas para visualizar a diagonalização de Turing.",
                                  "learningObjective": "Reforçar a base para reduções no Teorema de Rice.",
                                  "commonMistakes": [
                                    "Esquecer que H é semi-decidível.",
                                    "Confundir halting com aceitação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Máquina Universal Simuladora",
                                  "subSteps": [
                                    "Defina uma MT universal U que, em <M,w>, simula M em w.",
                                    "Construa, para uma propriedade P, uma MT modificada M_P que simula M em w e, se halta, decide se L(M) satisfaz P alterando a linguagem.",
                                    "Especifique: M_P em x: se x = <M',w> e M'≠M ou M(w) não halta, rejeita; senão, aceita/rejeita baseado em P.",
                                    "Ajuste para entrar em P ou não: se halta e L(M)∈P, aceita Σ*; senão, aceita vazio.",
                                    "Verifique que L(M_P) satisfaz P iff M halta em w."
                                  ],
                                  "verification": "Descreva pseudocódigo da construção de M_P e simule em um exemplo simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para diagramas de MT",
                                    "Ferramenta JFLAP para simular MTs",
                                    "Exemplos de provas de Rice online"
                                  ],
                                  "tips": "Comece com P = 'linguagem vazia' para testar a construção.",
                                  "learningObjective": "Construir a redução chave via simulador.",
                                  "commonMistakes": [
                                    "Erros na codificação de <M,w>.",
                                    "Não tratar casos onde simulação não halta."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Completar a Redução e Concluir a Prova",
                                  "subSteps": [
                                    "Reduza H para Rice_P: dado <M,w>, construa M_P como acima; então <M> ∈ Rice_P iff <M,w> ∈ H.",
                                    "Mostre que se Rice_P decidível, então H decidível, contradição.",
                                    "Generalize para qualquer P não-trivial (use redução para S_P não-trivial).",
                                    "Discuta por que funciona para propriedades indexadas.",
                                    "Resolva exercícios: prove indecidibilidade de 'L(M) finita?' via Rice."
                                  ],
                                  "verification": "Escreva a prova completa em 1 página e identifique onde a não-trivialidade é usada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de exercícios de Rice",
                                    "Artigo original de Rice (opcional)",
                                    "Fórum StackExchange para dúvidas"
                                  ],
                                  "tips": "Desenhe setas de redução: H → Rice_P.",
                                  "learningObjective": "Entender a generalidade da prova por redução.",
                                  "commonMistakes": [
                                    "Ignorar que P deve ser semântica e não-trivial.",
                                    "Confundir aceitação com halting na simulação."
                                  ]
                                }
                              ],
                              "practicalExample": "Para P = { L(M) | L(M) é vazia }: Construa M_P que em <M,w> simula M em w; se não halta, loop; se halta, rejeita tudo (L(M_P)=vazio, satisfaz P); se L(M) não vazia, ajuste para que se M(w) halta, M_P aceita algo (não satisfaz P). Assim, Rice_P decide H.",
                              "finalVerifications": [
                                "Explicar verbalmente a construção de M_P para uma P dada.",
                                "Provar que a redução preserva a indecidibilidade.",
                                "Identificar por que propriedades triviais falham na redução.",
                                "Aplicar a prova a um novo exemplo como 'L(M) regular?'.",
                                "Diferenciar Rice de resultados como Post Correspondence.",
                                "Simular um caso onde simulação loopa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da máquina simuladora (80% correto).",
                                "Correta identificação de não-trivialidade.",
                                "Clareza na explicação da contradição via redução.",
                                "Uso correto de notação formal (ex: <M,w>).",
                                "Capacidade de generalizar para outras propriedades.",
                                "Ausência de confusões com halting vs. aceitação."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Reduções e diagonalização.",
                                "Algoritmos e Estruturas: Simuladores e interpretadores.",
                                "Filosofia da Computação: Limites da formalização (Gödel).",
                                "Verificação de Software: Análise estática impossível.",
                                "Matemática Discreta: Conjuntos indexados."
                              ],
                              "realWorldApplication": "Demonstra por que ferramentas de análise estática de código (ex: verificadores de propriedades de programas) não podem ser completas em geral, impactando desenvolvimento de software seguro e compiladores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.3.1",
                              "10.1.7.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Aplicar o teorema a exemplos",
                            "description": "Usar o teorema para provar indecidibilidade de problemas como 'L(M) é vazia?', 'L(M) é infinita?' ou 'L(M1) ⊆ L(M2)?', confirmando que são propriedades semânticas não-triviais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e declarar formalmente o Teorema de Rice",
                                  "subSteps": [
                                    "Relembre a definição de propriedades semânticas: uma propriedade P de linguagens reconhecíveis por MT.",
                                    "Estude a declaração do teorema: Para qualquer propriedade semântica não-trivial P, o problema {⟨M⟩ | L(M) satisfaz P} é indecidível.",
                                    "Identifique as condições chave: P deve ser semântica (depende de L(M), não da estrutura de M) e não-trivial (existem MTs com e sem P).",
                                    "Anote exemplos de propriedades triviais (ex: toda linguagem) vs. não-triviais.",
                                    "Pratique reescrevendo o teorema em suas próprias palavras."
                                  ],
                                  "verification": "Escreva uma declaração precisa do teorema e identifique corretamente se uma propriedade dada é semântica e não-trivial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre Teorema de Rice",
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 5)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar MTs com e sem a propriedade para entender não-trivialidade.",
                                  "learningObjective": "Compreender os pré-requisitos exatos do Teorema de Rice para aplicação correta.",
                                  "commonMistakes": [
                                    "Confundir propriedades sintáticas (ex: MT com 3 estados) com semânticas.",
                                    "Ignorar a não-trivialidade, aplicando a propriedades triviais como 'L(M) é finita?' incorretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e classificar a propriedade semântica no exemplo",
                                  "subSteps": [
                                    "Escolha um problema exemplo, como 'L(M) é vazia?' ou 'L(M) é infinita?'.",
                                    "Prove que é semântica: depende apenas da linguagem aceita, não da codificação da MT.",
                                    "Verifique não-trivialidade: Construa MT M_vazia tal que L(M_vazia)=∅ (ex: MT que nunca aceita).",
                                    "Construa MT M_nao_vazia tal que L(M_nao_vazia)={ε} ou Σ*.",
                                    "Repita para 'L(M1) ⊆ L(M2)?' mostrando independência da estrutura."
                                  ],
                                  "verification": "Forneça construções explícitas de MTs que satisfazem e não satisfazem a propriedade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de texto para pseudocódigo de MTs",
                                    "Simulador de Máquinas de Turing online",
                                    "Exemplos de Sipser ou notas de aula"
                                  ],
                                  "tips": "Sempre use MTs canônicas: uma que loopa para sempre (vazia) e uma que aceita algo específico.",
                                  "learningObjective": "Classificar propriedades como semânticas e não-triviais com evidências concretas.",
                                  "commonMistakes": [
                                    "Falhar em provar não-trivialidade com MTs explícitas.",
                                    "Confundir 'vazia' com 'não-halting', que é sintática."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a redução do problema de parada",
                                  "subSteps": [
                                    "Lembre o problema de parada HALT = {⟨M,w⟩ | M halta em w}.",
                                    "Defina a redução f: para ⟨M⟩, construa ⟨M'⟩ tal que L(M') satisfaz P iff M não satisfaz algo relacionado a HALT.",
                                    "Para 'L(M) vazia?': Crie M'_M,w que em w simula M em w; se halta, aceita Σ*; senão, aceita ∅.",
                                    "Mostre que L(M') vazia iff M halta em w, invertendo para indecidibilidade.",
                                    "Generalize para 'infinita' ou 'subconjunto' ajustando a construção."
                                  ],
                                  "verification": "Escreva a função de redução f e prove que é computável e preserva a propriedade corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel para desenhar diagramas de redução",
                                    "Ferramentas como LaTeX para formalizar provas",
                                    "Vídeos tutoriais sobre reduções de Rice"
                                  ],
                                  "tips": "Desenhe o diagrama da MT M' com setas para 'simular M em w' → 'aceitar tudo' ou 'nada'.",
                                  "learningObjective": "Dominar a técnica de redução padrão do Teorema de Rice a partir de HALT.",
                                  "commonMistakes": [
                                    "Erro na polaridade: confundir 'halta → não vazia' com o inverso.",
                                    "Não provar que f é computável (codificação de MTs)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a prova e verificar robustez",
                                  "subSteps": [
                                    "Combine: Como HALT indecidível → problema P indecidível por redução.",
                                    "Verifique condições: P semântica? Não-trivial? Redução correta?",
                                    "Teste com variação: Aplique a 'L(M1) ⊆ L(M2)?' reduzindo de inclusão de linguagens.",
                                    "Escreva a prova completa em parágrafos lógicos.",
                                    "Discuta extensões: Por que falha para propriedades sintáticas?"
                                  ],
                                  "verification": "Produza uma prova escrita completa e sem falhas lógicas para um exemplo dado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Modelo de prova em LaTeX ou Word",
                                    "Checklist de condições de Rice"
                                  ],
                                  "tips": "Use a estrutura: 1. Declaração, 2. Não-trivial, 3. Redução, 4. Conclusão.",
                                  "learningObjective": "Sintetizar a aplicação completa do teorema em uma prova formal.",
                                  "commonMistakes": [
                                    "Pular verificação de computabilidade da redução.",
                                    "Aplicar a propriedades triviais como 'MT existe?'.",
                                    "Ignorar que Rice é para RE, não recursivas."
                                  ]
                                }
                              ],
                              "practicalExample": "Para provar que 'L(M) é vazia?' é indecidível: Construa M_{M,w} que, em entrada x, simula M em w; se M halta em w, então L(M_{M,w}) = Σ* (não vazia); senão L=∅. Logo, L(M_{M,w}) vazia iff M não halta em w. Como HALT indecidível, este também é.",
                              "finalVerifications": [
                                "Construir MTs explícitas para não-trivialidade.",
                                "Escrever redução computável de HALT para o problema P.",
                                "Identificar corretamente propriedades semânticas vs. sintáticas.",
                                "Concluir corretamente a indecidibilidade para 3 exemplos dados.",
                                "Explicar falhas comuns em aplicações erradas do teorema.",
                                "Aplicar a uma variação como 'L(M) infinita?' com prova completa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na declaração do teorema e verificação de condições (30%).",
                                "Construções de MTs corretas e não-triviais (25%).",
                                "Redução válida e prova de preservação (25%).",
                                "Clareza e lógica na prova escrita (10%).",
                                "Tratamento de erros comuns e generalizações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Analogia com teoremas de Gödel sobre incompletude.",
                                "Filosofia da Computação: Limites da computação e decidibilidade.",
                                "Engenharia de Software: Verificação de propriedades em compiladores e analisadores.",
                                "Inteligência Artificial: Indecidibilidade em aprendizado de máquina e validação de modelos."
                              ],
                              "realWorldApplication": "Em verificação de software, prova que certas propriedades de programas (ex: 'este programa imprime 'hello'?') são indecidíveis, guiando o uso de aproximações heurísticas em ferramentas como linters ou provers automáticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.3.1",
                              "10.1.7.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.4",
                            "name": "Discutir exceções e limitações",
                            "description": "Analisar propriedades decidíveis (triviais ou sintáticas), como 'L(M) é r.e.?', e referenciar livros como Sipser para extensões a classes como PSPACE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Enunciado do Teorema de Rice e Conceitos Básicos",
                                  "subSteps": [
                                    "Leia o enunciado preciso do Teorema de Rice: toda propriedade semântica não-trivial de linguagens RE é indecidível.",
                                    "Defina 'propriedade semântica' como dependendo apenas do conteúdo de L(M), não da descrição de M.",
                                    "Classifique propriedades como triviais (sempre verdadeira ou falsa para todas TM) ou não-triviais.",
                                    "Estude exemplos de propriedades triviais, como 'L(M) é RE?', que é sempre sim para TM.",
                                    "Anote definições chave de livros como Sipser (Capítulo 9)."
                                  ],
                                  "verification": "Resuma o teorema e dê 2 exemplos de propriedades triviais em um parágrafo escrito.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro Sipser (2ª ed., Cap. 9)",
                                    "Notas de aula sobre TM e RE",
                                    "Artigo sobre Rice's Theorem"
                                  ],
                                  "tips": "Foquem em distinções semântica vs sintática desde o início para evitar confusão posterior.",
                                  "learningObjective": "Compreender o escopo exato do Teorema de Rice e identificar propriedades triviais.",
                                  "commonMistakes": [
                                    "Confundir trivial com trivialmente decidível; ignorar que trivial implica decidível."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Propriedades Decidíveis: Exceções Triviais e Sintáticas",
                                  "subSteps": [
                                    "Liste propriedades decidíveis: ex., 'M tem pelo menos 10 estados?' (sintática).",
                                    "Analise por que 'L(M) é vazia?' é indecidível para RE, mas decidível para linguagens regulares.",
                                    "Discuta 'L(M) é finita?' como indecidível para RE, mas trivial em alguns contextos.",
                                    "Prove decidibilidade de propriedades sintáticas via exame direto do encoding de M.",
                                    "Compare com propriedades semânticas não-triviais como 'L(M) contém w?'."
                                  ],
                                  "verification": "Classifique 5 propriedades dadas (3 semânticas, 2 sintáticas) como decidíveis/indecidíveis e justifique.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Sipser Cap. 9 exercícios",
                                    "Papel e caneta para provas",
                                    "Ferramenta JFLAP para simulações"
                                  ],
                                  "tips": "Use tabelas para categorizar: coluna semântica/sintática, trivial/não-trivial, decidível/indecidível.",
                                  "learningObjective": "Distinguir exceções ao teorema: propriedades triviais e puramente sintáticas.",
                                  "commonMistakes": [
                                    "Achar que toda propriedade sobre L(M) é coberta por Rice; esquecer sintáticas são decidíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Limitações e Contraexemplos Específicos",
                                  "subSteps": [
                                    "Estude contraexemplo: 'L(M) é RE?' é trivial (sempre sim), logo decidível.",
                                    "Analise limitações para classes além RE: ex., PSPACE-complete properties em Sipser.",
                                    "Discuta extensões de Rice para classes como CFL ou regulares, onde algumas semânticas tornam-se decidíveis.",
                                    "Resolva exercício: É decidível 'L(M) ⊆ Σ*?' para TM? Por quê?",
                                    "Crie diagrama de Venn: decidíveis dentro/fora do teorema."
                                  ],
                                  "verification": "Crie um fluxograma para determinar se uma propriedade viola Rice ou é exceção.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Sipser exercícios 9.1-9.5",
                                    "Software de diagramação como Draw.io",
                                    "Notas de aula sobre classes de complexidade"
                                  ],
                                  "tips": "Sempre pergunte: 'Depende só de L(M)?' para semântica; caso contrário, sintática.",
                                  "learningObjective": "Aplicar teorema a casos específicos e reconhecer limitações contextuais.",
                                  "commonMistakes": [
                                    "Aplicar Rice a classes onde não vale, como regulares; ignorar trivialidade."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Referenciar Extensões e Sintetizar Discussão",
                                  "subSteps": [
                                    "Leia Sipser sobre generalizações de Rice para PSPACE e NP.",
                                    "Discuta limitações práticas: undecidability implica não computável, mas aproximações existem.",
                                    "Escreva ensaio curto: 'Exceções e limites do Teorema de Rice'.",
                                    "Conecte a teoremas relacionados como halting problem.",
                                    "Revise com quiz: 10 perguntas sobre decidibilidade."
                                  ],
                                  "verification": "Escreva um parágrafo discutindo uma extensão para PSPACE com referência a Sipser.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Sipser Cap. 9 avançado",
                                    "Quiz online sobre undecidability",
                                    "Fórum StackExchange para dúvidas"
                                  ],
                                  "tips": "Use Sipser como âncora; cite página seções específicas para credibilidade.",
                                  "learningObjective": "Sintetizar exceções, limitações e extensões para discussão fluida.",
                                  "commonMistakes": [
                                    "Superestimar generalidade de Rice; não referenciar fontes primárias."
                                  ]
                                }
                              ],
                              "practicalExample": "Dada a propriedade Q(M) = 'L(M) contém a string 0?', aplique Rice: é semântica não-trivial (algumas TM sim, outras não), logo indecidível. Exceção: Q(M) = 'M tem loop em estado q0?' é sintática e decidível por parsing do diagrama de M.",
                              "finalVerifications": [
                                "Classifique corretamente 5 propriedades como exceção ou coberta por Rice.",
                                "Explique por que 'L(M) é RE?' é decidível apesar de semântica.",
                                "Cite pelo menos 2 limitações de Rice de Sipser.",
                                "Discuta uma extensão para PSPACE.",
                                "Identifique distinção sintática/semântica em um exemplo dado.",
                                "Prove trivialidade de uma propriedade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de propriedades triviais/sintáticas (30%)",
                                "Correta aplicação do teorema com justificativas (25%)",
                                "Uso de exemplos e referências a Sipser (20%)",
                                "Clareza na discussão de limitações/extensões (15%)",
                                "Profundidade de substeps e verificações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e cardinalidade de linguagens.",
                                "Filosofia: Limites do computacional (Gödel, Turing).",
                                "Lógica: Proposições indecidíveis em lógica formal.",
                                "Engenharia de Software: Verificação de propriedades em compiladores."
                              ],
                              "realWorldApplication": "Em verificação de software, propriedades como 'este programa sempre termina?' são indecidíveis por Rice/halting, mas usamos análises estáticas sintáticas (ex.: linting) ou aproximações para detectar loops infinitos em prática."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Reduções de Turing",
                    "description": "Técnica de redução de um problema de decidibilidade a outro para provar indecidibilidade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Definição de Redução de Turing",
                        "description": "Compreensão formal das noções básicas de redução entre problemas de decidibilidade, incluindo reduções many-one e de Turing, e seu papel na transferência de propriedades de decidibilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Definir redução many-one",
                            "description": "Explicar que uma redução many-one de um problema A para B é uma função computável f tal que x ∈ A se e somente se f(x) ∈ B, e demonstrar como isso preserva decidibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Problemas de Decisão e Decidibilidade",
                                  "subSteps": [
                                    "Defina um problema de decisão como uma linguagem formal L ⊆ Σ*.",
                                    "Explique decidibilidade: uma linguagem é decidível se existe uma TM que para e aceita/rejeita corretamente toda entrada.",
                                    "Discuta exemplos: linguagens regulares são decidíveis; problema da parada (Halting Problem) é indecidível.",
                                    "Diferencie decidível de semi-decidível (recursivamente enumerável).",
                                    "Liste propriedades preservadas por reduções, como indecidibilidade."
                                  ],
                                  "verification": "Escreva definições precisas e cite um exemplo de linguagem indecidível sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de teoria da computação (ex: Sipser), papel e caneta.",
                                  "tips": "Use diagramas de TM para visualizar aceitação/rejeição.",
                                  "learningObjective": "Compreender os fundamentos de decidibilidade para contextualizar reduções.",
                                  "commonMistakes": "Confundir decidibilidade com parabilidade ou ignorar a obrigatoriedade de parada em TMs decisoras."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito Intuitivo de Redução Many-One",
                                  "subSteps": [
                                    "Explique intuitivamente: reduzir A para B significa transformar instâncias de A em instâncias de B preservando a resposta.",
                                    "Defina many-one como uma redução via função única f: Σ* → Σ*.",
                                    "Compare com reduções de Turing (mais poderosas).",
                                    "Discuta por que many-one é útil para preservar decidibilidade.",
                                    "Esboce a ideia de 'mapeamento único' vs. 'simulação oracular'."
                                  ],
                                  "verification": "Descreva verbalmente a diferença entre many-one e Turing reduction com um desenho simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Quadro branco ou software de desenho (ex: Draw.io), notas de aula.",
                                  "tips": "Pense em 'tradutor' que converte problemas sem perda de informação.",
                                  "learningObjective": "Graspar a intuição por trás da redução many-one como transformação direta.",
                                  "commonMistakes": "Confundir many-one com reduções polinomiais ou ignorar computabilidade de f."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Definição de Redução Many-One",
                                  "subSteps": [
                                    "Escreva: A ≤_m B se existe f computável tal que ∀x, x ∈ A ⇔ f(x) ∈ B.",
                                    "Prove que f deve ser total e computável por TM.",
                                    "Analise a bicondicional: implica preservação exata de membership.",
                                    "Verifique que f é many-one (muitos x mapeiam para um y, mas condição é por x).",
                                    "Escreva a definição em notação matemática precisa."
                                  ],
                                  "verification": "Escreva a definição formal e prove um caso trivial (A ≤_m A via f(x)=x).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto ou LaTeX para fórmulas, referência teórica.",
                                  "tips": "Use setas duplas ⇔ para enfatizar equivalência exata.",
                                  "learningObjective": "Dominar a definição precisa e seus componentes.",
                                  "commonMistakes": "Esquecer que f é computável ou inverter a direção da redução."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Preservação de Decidibilidade",
                                  "subSteps": [
                                    "Prove: Se B é decidível e A ≤_m B, então A é decidível.",
                                    "Construa TM para A: compute f(x), decida f(x) em B, retorne o resultado.",
                                    "Prove o converso parcial: se A é indecidível, então B é indecidível.",
                                    "Discuta implicações para hierarquias de complexidade.",
                                    "Aplique logicamente a um exemplo conhecido."
                                  ],
                                  "verification": "Escreva a prova formal da preservação e teste com um contraexemplo hipotético.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel para provas, simulador de TM online (ex: JFLAP).",
                                  "tips": "Estruture a prova como 'se-decidível-então-decidível' com composição de TMs.",
                                  "learningObjective": "Compreender e provar como reduções preservam decidibilidade.",
                                  "commonMistakes": "Ignorar que f computável garante composição efetiva ou confundir com NP-completude."
                                }
                              ],
                              "practicalExample": "Reduza o problema POST (pós-correspondência) many-one para si mesmo trivialmente, ou mais interessante: reduza Halting Problem para Empty Language via f((M,w)) = código de M que ignora w e roda em input vazio, preservando indecidibilidade.",
                              "finalVerifications": [
                                "Definição formal escrita corretamente com f computável e ⇔.",
                                "Prova de preservação de decidibilidade sem falhas lógicas.",
                                "Exemplo concreto de redução many-one com verificação de membership.",
                                "Explicação clara da diferença para reduções de Turing.",
                                "Identificação correta de quando usar many-one vs. outras reduções.",
                                "Aplicação em um problema clássico de indecidibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (f computável, bicondicional exata): 30%.",
                                "Correção da prova de preservação: 25%.",
                                "Qualidade do exemplo prático e verificação: 20%.",
                                "Compreensão intuitiva e distinções conceituais: 15%.",
                                "Clareza na explicação escrita/oral: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções injetoras/sobretivas.",
                                "Lógica: Provas por contrapositiva e bicondicionais.",
                                "Filosofia: Limites do conhecimento computacional (Gödel).",
                                "Engenharia de Software: Provas de impossibilidade em algoritmos."
                              ],
                              "realWorldApplication": "Usado para provar indecidibilidade de problemas como verificação de software (ex: 'este programa sempre termina?'), otimizações em compiladores e análise de segurança cibernética, mostrando limites algorítmicos fundamentais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Definir redução de Turing",
                            "description": "Descrever uma redução de Turing de A para B como uma máquina de Turing que, com oráculo para B, decide A, diferenciando-a da redução many-one e exemplificando com diagramas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Máquinas de Turing e Oráculos",
                                  "subSteps": [
                                    "Estude a definição formal de uma Máquina de Turing (MT) padrão, incluindo configuração, transição e aceitação.",
                                    "Aprenda o conceito de oráculo: uma MT com acesso a uma 'caixa preta' que resolve instantaneamente uma linguagem B.",
                                    "Entenda a notação M^B para uma MT M com oráculo para B.",
                                    "Pratique descrevendo como uma MT com oráculo consulta o oráculo e usa o resultado.",
                                    "Desenhe um diagrama simples de uma transição com consulta ao oráculo."
                                  ],
                                  "verification": "Desenhe e explique um diagrama de MT com oráculo que decide uma linguagem trivial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Sipser Introduction to Theory of Computation' (Cap. 9), papel e caneta para diagramas, vídeo online sobre oráculos em MT.",
                                  "tips": "Use setas curvas para representar consultas ao oráculo nos diagramas para clareza visual.",
                                  "learningObjective": "Compreender o papel de oráculos em estender o poder computacional de MTs.",
                                  "commonMistakes": "Confundir oráculo com fita extra; oráculo é consulta instantânea, não computação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente Redução de Turing",
                                  "subSteps": [
                                    "Defina redução de Turing de A ≤_T B como: existe MT M tal que M com oráculo B decide A.",
                                    "Escreva a definição em notação formal: A ≤_T B iff ∃ M^B que L(M^B) = A.",
                                    "Explique que M pode usar o oráculo múltiplas vezes e processar respostas.",
                                    "Discuta transitividade e reflexividade das reduções de Turing.",
                                    "Crie um pseudocódigo para uma MT genérica que usa oráculo para decidir A."
                                  ],
                                  "verification": "Escreva a definição formal e prove que é reflexiva para uma linguagem simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de anotações, software de diagrama como Draw.io, referências online sobre reduções (Wikipedia: Turing reduction).",
                                  "tips": "Sempre inclua 'decide A' na definição para enfatizar completude e corretude.",
                                  "learningObjective": "Formular precisamente a definição de redução de Turing.",
                                  "commonMistakes": "Omitir que a MT decide A corretamente em todos os casos, não só aceita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar de Redução Many-One",
                                  "subSteps": [
                                    "Revise redução many-one: f: Σ* → Σ* computável tal que x ∈ A iff f(x) ∈ B.",
                                    "Compare: many-one é 'uma consulta', Turing permite 'múltiplas consultas adaptativas'.",
                                    "Note que A ≤_m B implica A ≤_T B, mas não vice-versa (ex: HALTING ≤_T HALTING, mas many-one é mais restrita).",
                                    "Crie uma tabela comparativa: determinística, número de consultas, adaptatividade.",
                                    "Desenhe diagramas lado a lado mostrando fluxos de consulta."
                                  ],
                                  "verification": "Explique por que uma redução many-one é um caso especial de Turing reduction.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabela em Excel ou papel, exemplos de Sipser Cap. 9.",
                                  "tips": "Use 'many-one: transforma input uma vez' vs 'Turing: transforma dinamicamente múltiplas vezes'.",
                                  "learningObjective": "Distinguir as duas reduções e suas implicações em indecidibilidade.",
                                  "commonMistakes": "Achar que são equivalentes; many-one é mais forte (permite menos poder na redução)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar com Diagramas",
                                  "subSteps": [
                                    "Escolha exemplo: Redução de Turing de HALT_TM (halting) para A_TM (aceitação).",
                                    "Descreva MT M^{A_TM}: simule M em w; se aceitar, pergunte oráculo A_TM sobre instâncias construídas.",
                                    "Desenhe diagrama completo: estados, transições, consultas ao oráculo.",
                                    "Teste o exemplo com input específico e trace a execução.",
                                    "Gere um diagrama para many-one no mesmo contexto para contraste."
                                  ],
                                  "verification": "Desenhe e anote um diagrama completo que um colega possa entender e verificar.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta de diagrama (Lucidchart ou papel), exemplos de livros/textos.",
                                  "tips": "Rotule consultas como 'Query: <instância> ?' e respostas como Y/N branches.",
                                  "learningObjective": "Aplicar a definição em um exemplo visual e concreto.",
                                  "commonMistakes": "Diagramas sem legendas ou fluxos incompletos para casos de rejeição."
                                }
                              ],
                              "practicalExample": "Redução de Turing do problema HALTING para EQ_TM: Construa MT M^{EQ_TM} que simula pares de máquinas e usa oráculo EQ_TM para verificar se M1 e M2 são equivalentes após simulações parciais, decidindo se M halta em w comparando comportamentos.",
                              "finalVerifications": [
                                "Definição formal escrita corretamente sem omissões.",
                                "Diferença chave entre Turing e many-one explicada com exemplo.",
                                "Diagrama de MT com oráculo desenhado e anotado.",
                                "Exemplo prático traceado para input sim/não.",
                                "Prova de que many-one implica Turing demonstrada.",
                                "Conceitos de oráculo aplicados corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% match com padrão).",
                                "Clareza na distinção many-one vs Turing (explicação adaptativa).",
                                "Qualidade visual e legibilidade dos diagramas.",
                                "Correção lógica no exemplo prático.",
                                "Profundidade nos substeps (cobertura completa).",
                                "Uso correto de terminologia teórica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reduções semelhantes a mapeamentos em teoria dos conjuntos e funções compostas.",
                                "Lógica: Oráculos como axiomas adicionais em sistemas formais.",
                                "Filosofia da Computação: Implicações para limites do conhecimento computável.",
                                "Programação: Analogia com chamadas de API externas em software."
                              ],
                              "realWorldApplication": "Em pesquisa de IA e verificação de software, reduções de Turing ajudam a provar que certos problemas de otimização (ex: satisfatibilidade ótima) são indecidíveis, guiando desenvolvedores a heurísticas práticas em compiladores e análise de vulnerabilidades."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Explicar propósito na indecidibilidade",
                            "description": "Argumentar que se A reduz para B e A é indecidível, então B é indecidível, usando contrapositiva para provar indecidibilidade por redução do Problema da Parada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Problema da Parada e sua Indecidibilidade",
                                  "subSteps": [
                                    "Revise a definição formal do Problema da Parada (Halting Problem): dada uma máquina de Turing M e entrada w, determinar se M para em w.",
                                    "Lembre-se da prova clássica de indecidibilidade de Alan Turing por diagonalização.",
                                    "Explique por que o Problema da Parada é o 'problema canônico' de indecidibilidade.",
                                    "Discuta implicações: não existe algoritmo geral para prever parada.",
                                    "Pratique reformulando o problema em termos de linguagens RE e co-RE."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a prova de Turing e identifique o passo diagonalizador.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 4); notas de aula sobre Automata.",
                                  "tips": "Use analogias como 'prever se um programa infinito roda para sempre' para fixar o conceito.",
                                  "learningObjective": "Compreender o papel fundamental do Halting Problem como base para reduções de indecidibilidade.",
                                  "commonMistakes": "Confundir indecidibilidade com intratabilidade (NP-completo); achar que é só 'difícil computar'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Redução de Turing e seu Propósito",
                                  "subSteps": [
                                    "Defina redução de Turing: função computável f tal que x ∈ A iff f(x) ∈ B.",
                                    "Diferencie reduções many-one de Turing reductions (oracle).",
                                    "Explique o lema: se A reduz para B e A é indecidível, então B é indecidível.",
                                    "Ilustre com diagrama: seta de A para B via f computável.",
                                    "Pratique convertendo problemas em instâncias via redução."
                                  ],
                                  "verification": "Desenhe um diagrama de redução e explique verbalmente como f preserva decidibilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta para diagramas; vídeo Khan Academy sobre reduções em teoria da computação.",
                                  "tips": "Pense em reduções como 'tradutores': se resolver B resolve A, e A é impossível, B também é.",
                                  "learningObjective": "Dominar a definição formal de redução e sua direção (de problema conhecido para desconhecido).",
                                  "commonMistakes": "Invertir a direção da redução (reduzir B para A em vez de A para B)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Contrapositiva do Teorema de Redução",
                                  "subSteps": [
                                    "Enuncie o teorema direto: A ≤_T B e A indecidível ⇒ B indecidível.",
                                    "Derive a contrapositiva: B decidível ⇒ A decidível.",
                                    "Prove por contradição: assumir B decidível, construir decisor para A via f^{-1}.",
                                    "Aplique ao Halting Problem: reduzir H para problema alvo P.",
                                    "Escreva prova formal com símbolos: ∀x, H(x) iff P(f(x))."
                                  ],
                                  "verification": "Escreva a prova da contrapositiva em 5-7 linhas, sem erros lógicos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto para pseudocódigo; exemplos de Sipser (p. 152-155).",
                                  "tips": "Sempre prove contrapositiva para evitar confusão na direção da implicação.",
                                  "learningObjective": "Aplicar lógica proposicional para reformular teoremas em contrapositivas equivalentes.",
                                  "commonMistakes": "Esquecer que f deve ser computável; confundir decidível com semi-decidível."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Redução para Provar Indecidibilidade",
                                  "subSteps": [
                                    "Escolha um problema alvo, ex: 'Existe TM que aceita Σ*?' (problema do complemento total).",
                                    "Construa redução explícita de Halting para o alvo.",
                                    "Verifique que f é computável e preserva membership.",
                                    "Conclua usando contrapositiva: se alvo decidível, Halting seria decidível (absurdo).",
                                    "Generalize para outros problemas como PCP ou EQ_TM."
                                  ],
                                  "verification": "Produza uma prova completa de indecidibilidade para um problema específico usando essa técnica.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Exercícios de livro-texto; simulador de TM online como Turing Machine Simulator.",
                                  "tips": "Teste a redução com instâncias pequenas para validar.",
                                  "learningObjective": "Executar prova por redução do zero, identificando todos os componentes necessários.",
                                  "commonMistakes": "Não provar que f é total e computável; pular verificação de preservação."
                                }
                              ],
                              "practicalExample": "Para provar que o problema 'TM aceita Σ*?' é indecidível: reduza Halting Problem. Dada <M,w>, construa M' que em w roda M e aceita tudo depois; em outros inputs aceita tudo. Se M' aceita Σ*, então M para em w.",
                              "finalVerifications": [
                                "Explicar verbalmente o teorema e contrapositiva sem hesitação.",
                                "Construir redução correta para um problema padrão como EQ_TM.",
                                "Identificar falhas em uma prova de redução malfeita.",
                                "Reescrever prova usando símbolos formais.",
                                "Aplicar a um novo problema em <5 minutos.",
                                "Discutir limitações de reduções em contextos semi-decidíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de redução e contrapositiva (100% correto).",
                                "Clareza na construção da função f computável.",
                                "Correta aplicação da contradição lógica.",
                                "Uso de notação formal consistente.",
                                "Generalização para problemas semelhantes.",
                                "Ausência de erros comuns como inversão de direção."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Provas por contrapositiva e contradição.",
                                "Filosofia da Ciência: Limites do conhecimento computacional (Gödel, Turing).",
                                "Matemática Discreta: Funções redutoras e preservação de propriedades.",
                                "Inteligência Artificial: Implicações para limites de aprendizado de máquina."
                              ],
                              "realWorldApplication": "Em verificação de software, prova limites de ferramentas de análise estática (não detectam todos loops infinitos); em criptografia, mostra impossibilidade de decifrar chaves universais; orienta pesquisa em IA para evitar buscas por algoritmos impossíveis."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Construção de Reduções",
                        "description": "Técnicas passo a passo para construir máquinas de Turing ou funções computáveis que realizam reduções entre linguagens RE e não-RE.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Construir redução do Problema da Parada",
                            "description": "Dado o Problema da Parada HALT_TM, construir uma redução many-one para o problema de aceitação A_TM, especificando a codificação da instância e simulando a execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições e Conceitos Fundamentais",
                                  "subSteps": [
                                    "Defina formalmente HALT_TM como a linguagem {⟨M, w⟩ | M é uma TM que halta em entrada w}.",
                                    "Defina formalmente A_TM como a linguagem {⟨M, w⟩ | M é uma TM que aceita w}.",
                                    "Explique o que é uma redução many-one: função computável f tal que x ∈ L1 iff f(x) ∈ L2.",
                                    "Identifique por que reduzir HALT_TM para A_TM mostra que A_TM é pelo menos tão difícil quanto HALT_TM.",
                                    "Liste propriedades chave das TMs: simulação universal, codificação de TMs como strings."
                                  ],
                                  "verification": "Escreva definições precisas e um diagrama comparando HALT_TM e A_TM; confirme com fórmulas formais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Notas de aula sobre indecidabilidade",
                                    "Editor de texto para diagramas"
                                  ],
                                  "tips": "Use notação padrão ⟨M, w⟩ para codificações; memorize que aceitação implica parada, mas não vice-versa.",
                                  "learningObjective": "Compreender os problemas exatos e o papel das reduções many-one na hierarquia de dificuldade.",
                                  "commonMistakes": [
                                    "Confundir aceitação com parada",
                                    "Ignorar que many-one requer função computável total",
                                    "Esquecer codificação binária de TMs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a Máquina Turing Redutora M'",
                                  "subSteps": [
                                    "Crie M' que ignora sua própria entrada x e inicia simulação de M em w hardcoded.",
                                    "Implemente um simulador universal dentro de M': use codificação de configuração (estado, fita, cabeça).",
                                    "Defina que, se a simulação de M em w halta (aceita ou rejeita), M' entra em estado de aceitação.",
                                    "Se a simulação nunca halta, M' loopa indefinidamente sem aceitar.",
                                    "Especifique estados especiais: q_init (inicia simulação), q_sim (simula passo), q_halt_accept (aceita após halt)."
                                  ],
                                  "verification": "Desenhe o diagrama de estados de M' e trace 5 passos de simulação manual para uma TM simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta de desenho de TMs (JFLAP ou papel)",
                                    "Exemplos de simuladores universais",
                                    "Código fonte de TM em Python para protótipo"
                                  ],
                                  "tips": "Hardcode w na transição inicial de M'; use contador de passos para evitar loops reais em simulações manuais.",
                                  "learningObjective": "Construir uma TM que simule outra independentemente da entrada, capturando parada como aceitação.",
                                  "commonMistakes": [
                                    "Fazer M' depender de x",
                                    "Não tratar rejeição de M como halt",
                                    "Esquecer estados de transição para aceitação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar a Codificação da Redução",
                                  "subSteps": [
                                    "Defina f(⟨M, w⟩) = ⟨M', ε⟩, onde M' é construída como acima com w embutido.",
                                    "Descreva codificação de M': inclua tabela de transições com w como string inicial na fita simulada.",
                                    "Forneça exemplo de codificação binária: converta M e w em símbolos únicos, concatene.",
                                    "Implemente f como uma TM que gera ⟨M', ε⟩ a partir de ⟨M, w⟩ (construtora).",
                                    "Verifique que f é computável: simulação de construção é finita."
                                  ],
                                  "verification": "Codifique um ⟨M, w⟩ específico e gere ⟨M', ε⟩; valide parsing manual.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Especificação de codificação padrão (Sipser 7.1)",
                                    "Calculadora binária",
                                    "Simulador de TM online"
                                  ],
                                  "tips": "Use padding com símbolos especiais para separar partes da codificação; teste com TM trivial.",
                                  "learningObjective": "Mapear instâncias de HALT_TM para A_TM via codificação precisa e computável.",
                                  "commonMistakes": [
                                    "Codificação ambígua",
                                    "f não total (não define para todos inputs)",
                                    "Esquecer ε como entrada vazia"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Correção da Redução",
                                  "subSteps": [
                                    "Prove ⇒: Se ⟨M, w⟩ ∈ HALT_TM (M halta em w), então simulação termina, M' aceita ε.",
                                    "Prove ⇐: Se ⟨M', ε⟩ ∈ A_TM (M' aceita ε), então simulação terminou, M haltou em w.",
                                    "Discuta tempo: simulação é fiel, halt em k passos leva O(k) em M'.",
                                    "Aborde casos: M aceita w → M' aceita; M rejeita w → M' aceita; M loops → M' loops.",
                                    "Generalize para qualquer TM: universalidade garante simulação."
                                  ],
                                  "verification": "Escreva prova formal em duas direções; teste com contraexemplos falhos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Modelo de prova de redução (notas de aula)",
                                    "Lápis e papel para casos",
                                    "Ferramenta LaTeX para formalização"
                                  ],
                                  "tips": "Use 'suponha por contradição' para ⇐; lembre que loop em M' só ocorre se loop em M.",
                                  "learningObjective": "Demonstrar equivalência via prova bidirecional, solidificando indecidabilidade.",
                                  "commonMistakes": [
                                    "Ignorar caso de rejeição",
                                    "Assumir tempo polinomial (não necessário)",
                                    "Prova unidirecional apenas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere M que em '0' escreve '11' e aceita (halta). w='0'. Construa M': ignora input, põe '0' na fita simulada, simula M (halta aceitando), então M' aceita ε. Se M' loopa em '1'* (não halta), prova falha corretamente.",
                              "finalVerifications": [
                                "Construa M' para uma TM que rejeita e verifica se M' aceita.",
                                "Codifique ⟨M_loop, ε⟩ onde M_loop loops; confirme f gera M' que loops.",
                                "Trace simulação completa para TM com 3 estados.",
                                "Escreva prova de correção sem olhar notas.",
                                "Explique verbalmente a redução para um par.",
                                "Identifique erro em uma redução incorreta proposta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de M': simula corretamente halt como accept.",
                                "Codificação válida e computável de f.",
                                "Prova bidirecional completa e sem falhas lógicas.",
                                "Tratamento de todos casos (accept, reject, loop).",
                                "Clareza na descrição de estados e transições.",
                                "Uso correto de notação formal e exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Analogia com reduções de incompletude de Gödel.",
                                "Algoritmos: Simulação universal como interpretadores de VMs.",
                                "Filosofia: Limites do computacional (Church-Turing).",
                                "Engenharia de Software: Verificação de programas intratáveis."
                              ],
                              "realWorldApplication": "Em compiladores e verificadores de software, entender reduções ajuda a provar impossibilidade de detecção automática de loops infinitos, guiando ferramentas para análise parcial ou heurísticas em debugging."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1",
                              "10.1.7.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Simular execução em reduções",
                            "description": "Desenvolver um construtor de máquinas de Turing que, dada uma MT M e entrada w, cria uma instância equivalente para outro problema, incluindo gerenciamento de fita e estados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Codificar Configurações de Máquinas de Turing",
                                  "subSteps": [
                                    "Estude a configuração instantânea de uma MT: tupla (estado atual, posição da cabeça, conteúdo da fita).",
                                    "Defina uma codificação para representar a configuração inteira em um único símbolo da fita da simuladora (ex: use alfabeto expandido com símbolos compostos como #q0#0#1...#).",
                                    "Crie exemplos de codificação para configurações iniciais e após uma transição.",
                                    "Teste a codificação manualmente para uma MT simples com 2-3 estados.",
                                    "Documente o alfabeto estendido necessário para a simuladora."
                                  ],
                                  "verification": "Codificações manuais de 3 configurações diferentes coincidem com simulações passo a passo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Papel quadriculado, lápis, tabela de transições de uma MT exemplo, simulador online de MT (ex: Turing Machine Simulator).",
                                  "tips": "Use marcadores como # para delimitar partes da configuração, facilitando parsing.",
                                  "learningObjective": "Representar estados, cabeça e fita de M como um símbolo único na fita de S.",
                                  "commonMistakes": "Esquecer de incluir a posição da cabeça na codificação ou usar símbolos ambíguos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar Estados da Simuladora para Aplicar Transições",
                                  "subSteps": [
                                    "Liste os estados de S: estados para ler configuração, parsear estado/head/symbol de M, consultar δ de M, escrever nova configuração.",
                                    "Defina sub-estados para cada fase: 'lendo configuração', 'identificando estado q', 'lendo símbolo sob cabeça', 'aplicando transição'.",
                                    "Especifique transições de S que simulam uma única transição de M, atualizando o símbolo da configuração.",
                                    "Inclua estados para mover a 'cabeça simulada' dentro da configuração codificada.",
                                    "Desenhe um diagrama de estados de S destacando o ciclo de simulação."
                                  ],
                                  "verification": "Diagrama de estados permite simular pelo menos 2 transições de M manualmente.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramenta de desenho de diagramas (ex: Draw.io), tabela δ de M.",
                                  "tips": "Agrupe estados em 'fases' nomeadas para evitar explosão de estados.",
                                  "learningObjective": "Criar estados em S que imitem fielmente o comportamento de uma transição em M.",
                                  "commonMistakes": "Não sincronizar corretamente o movimento da cabeça simulada com a real."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Gerenciamento de Fita e Expansão Dinâmica",
                                  "subSteps": [
                                    "Defina como S gerencia fita infinita de M: use blocos delimitados e estados para estender fita quando necessário.",
                                    "Crie transições para inserir/espaçar símbolos quando a cabeça se move além dos limites atuais.",
                                    "Implemente limpeza de símbolos irrelevantes (ex: brancos à esquerda/direita).",
                                    "Simule cenários de fita crescendo em ambas direções.",
                                    "Integre com codificação: garanta que configuração reflita fita expandida."
                                  ],
                                  "verification": "Simulação manual mostra fita expandindo corretamente sem perda de dados em 5 passos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Simulador de MT avançado, fita longa em papel para tracking manual.",
                                  "tips": "Use símbolos especiais como □ para blanks e estados dedicados para extensão.",
                                  "learningObjective": "Simular fita infinita de M na fita finita/local da simuladora S.",
                                  "commonMistakes": "Sobrescrever partes da fita sem backup ou falhar em detectar limites."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Inicialização, Halting e Integração em Redução",
                                  "subSteps": [
                                    "Defina configuração inicial de S: codificar estado inicial de M, cabeça em posição 1, fita com w e blanks.",
                                    "Crie estados de aceitação/rejeição em S que detectem q_acc/q_rej em M e mapeiem para o problema alvo.",
                                    "Adicione loop de simulação: repetir aplicação de transições até halting.",
                                    "Para redução: ajuste saída de S para instância equivalente no problema B (ex: codificar resposta como 'sim/não').",
                                    "Teste end-to-end com MT M simples e w curto."
                                  ],
                                  "verification": "Simulação completa de M em w termina corretamente e produz saída para redução.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Simulador completo, exemplos de reduções (ex: de AHP para PCP).",
                                  "tips": "Comece com M que halta rapidamente para depuração.",
                                  "learningObjective": "Completar ciclo de simulação e ligar a uma redução de Turing.",
                                  "commonMistakes": "Loop infinito sem detecção de halting ou inicialização errada de w."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Otimizar a Simuladora Completa",
                                  "subSteps": [
                                    "Execute simulação passo a passo para múltiplas entradas w em M.",
                                    "Identifique e corrija bugs em estados/fita via tracing.",
                                    "Otimize número de estados/transições sem alterar poder computacional.",
                                    "Gere formalmente a descrição de S para qualquer M (high-level constructor).",
                                    "Documente como usar S em uma redução específica."
                                  ],
                                  "verification": "S simula M corretamente em 3 entradas diferentes, incluindo non-halting.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Ferramentas de validação de MT, logs de simulação.",
                                  "tips": "Use debugging com pausas em estados chave.",
                                  "learningObjective": "Garantir corretude e universalidade da simulação em reduções.",
                                  "commonMistakes": "Ignorar casos de halting por rejeição ou loops."
                                }
                              ],
                              "practicalExample": "Construa MT S que simula M (que aceita {a^n b^n | n≥0}) em w = 'aabb'. S inicia com configuração codificada #q0 #aabb#□, aplica transições de M (ex: δ(q0,a)=(q1,A,R)), gerencia fita expandindo para AA BB □, detecta q_acc e aceita, reduzindo para 'instância válida de paridade strings'.",
                              "finalVerifications": [
                                "Simulação manual de 10 passos coincide com execução direta de M.",
                                "S aceita/rejeita corretamente para 5 entradas w variadas.",
                                "Fita gerenciada corretamente sem overflow ou perda em simulações longas.",
                                "Estados de halting mapeiam precisamente para decisão do problema B.",
                                "Constructor gera S equivalente para MT M' diferente.",
                                "Nenhuma transição indefinida ou ambígua em S."
                              ],
                              "assessmentCriteria": [
                                "Corretude da codificação de configurações (20%)",
                                "Precisão das transições simuladas (25%)",
                                "Gerenciamento robusto de fita (20%)",
                                "Detecção correta de halting e mapeamento para redução (20%)",
                                "Eficiência e minimalismo de estados (10%)",
                                "Documentação clara e testes abrangentes (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Similar a interpretadores/VMs em linguagens como Python (simular stack machine).",
                                "Matemática: Modelagem de funções parciais e indução em provas de corretude.",
                                "Lógica: Relação com teorema de Rice e provas por contradição em indecidibilidade.",
                                "Engenharia de Software: Design de simuladores e emuladores (ex: QEMU)."
                              ],
                              "realWorldApplication": "Em compiladores e VMs (ex: JVM simulando bytecode), provadores de teoremas automatizados, análise de complexidade em algoritmos, e criptografia para simular máquinas em provas de segurança."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Verificar correção de redução",
                            "description": "Provar formalmente que uma redução construída é correta, mostrando as implicações nos dois sentidos (x em A implica f(x) em B e vice-versa) com casos de aceitação e rejeição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formalizar a Redução e os Problemas Envolvidos",
                                  "subSteps": [
                                    "Identifique os problemas de decisão A e B, incluindo suas definições formais (linguagens reconhecidas por TM).",
                                    "Descreva a função de redução f: Σ* → Σ*, especificando como ela mapeia instâncias de A para instâncias de B.",
                                    "Verifique se f é computável por uma TM (geralmente em tempo polinomial para reduções many-one).",
                                    "Escreva as afirmações a provar: (x ∈ A ⇔ f(x) ∈ B), separando em → e ←.",
                                    "Liste os casos possíveis: aceitação em A, rejeição em A, e correspondentes em B."
                                  ],
                                  "verification": "Confirme que definições de A, B e f estão claras e sem ambiguidades, com exemplos de entradas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser",
                                    "Notas de aula sobre reduções de Turing",
                                    "Editor de texto ou papel para diagramas"
                                  ],
                                  "tips": "Sempre comece pelas definições exatas para evitar confusões; desenhe um diagrama de fluxo da redução.",
                                  "learningObjective": "Compreender precisamente os componentes da redução para basear a prova formal.",
                                  "commonMistakes": [
                                    "Assumir conhecimento implícito sem explicitar definições",
                                    "Ignorar se f é computável",
                                    "Confundir reduções many-one com Turing reductions"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar a Direção Forward: x ∈ A implica f(x) ∈ B",
                                  "subSteps": [
                                    "Assuma x ∈ A (M_A aceita x).",
                                    "Descreva como f constrói a instância y = f(x) para B.",
                                    "Mostre construção passo a passo de uma TM M_B que simula M_A em y, provando que M_B aceita y.",
                                    "Considere o caso de aceitação: trace a execução mostrando que a simulação halta em aceitação.",
                                    "Argumente por contradição se necessário, confirmando que a simulação preserva o comportamento."
                                  ],
                                  "verification": "A prova mostra explicitamente que toda execução aceitadora em A leva a aceitação em B.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de reduções de Sipser (Capítulo 7)",
                                    "Simulador de TM online",
                                    "Papel para traces de execução"
                                  ],
                                  "tips": "Use indução em passos de computação ou casos base para simulações; escreva pseudocódigo da TM simuladora.",
                                  "learningObjective": "Dominar a prova de preservação de aceitação na redução.",
                                  "commonMistakes": [
                                    "Esquecer de lidar com loops infinitos na simulação",
                                    "Não especificar como y codifica x",
                                    "Ignorar tempo de halting"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a Direção Backward: f(x) ∈ B implica x ∈ A",
                                  "subSteps": [
                                    "Assuma y = f(x) ∈ B (M_B aceita y).",
                                    "Extraia x da estrutura de y usando a inversa parcial de f.",
                                    "Mostre que a aceitação de M_B em y implica que a simulação interna aceita x em A.",
                                    "Considere o caso de rejeição: se M_B rejeita y, então M_A rejeita x (ou loopa).",
                                    "Prove que não há 'falsos positivos': aceitação em B só ocorre se A aceita."
                                  ],
                                  "verification": "Demonstre que toda aceitação em B corresponde unicamente a aceitação em A, sem casos espúrios.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigos sobre provas de reduções undecidability",
                                    "Exemplos de reduções HP para PCP",
                                    "Ferramentas de prova como LaTeX para formalização"
                                  ],
                                  "tips": "Pense em f como injetiva onde necessário; use 'dado que y = f(x), decodificar x de y'.",
                                  "learningObjective": "Garantir que a redução não introduza aceitações extras em B.",
                                  "commonMistakes": [
                                    "Assumir bidirecionalidade sem prova reversa",
                                    "Confundir rejeição com não-halting",
                                    "Não tratar encodings não-únicos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Completude, Casos Especiais e Propriedades Globais",
                                  "subSteps": [
                                    "Verifique casos de rejeição: x ∉ A implica f(x) ∉ B (loop ou rejeita).",
                                    "Confirme que f é total e computável em tempo razoável.",
                                    "Teste com exemplos concretos: execute traces para aceitação/rejeição.",
                                    "Argumente indecidabilidade: se B decidível, então A seria via f^{-1}.",
                                    "Revise por lacunas: consistência lógica e cobertura de todos casos."
                                  ],
                                  "verification": "Todos os quatro casos (A aceita/rejeita, B aceita/rejeita) estão cobertos e consistentes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Test cases de reduções padrão",
                                    "Verificador lógico online",
                                    "Peer review ou auto-checklist"
                                  ],
                                  "tips": "Crie uma tabela verdade para os casos; prove por exaustão finita.",
                                  "learningObjective": "Assegurar robustez da prova contra edge cases e generalidade.",
                                  "commonMistakes": [
                                    "Omitir loops infinitos",
                                    "Não provar computabilidade de f",
                                    "Generalizar sem casos concretos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a redução do Halting Problem (HP = {<M,w> | M halts on w}) para o Empty Language Problem (ELP = {<M> | L(M) = ∅}). f(<M,w>) = <M_{M,w}> onde M_{M,w} em ε roda M em w e aceita se halta. Forward: Se M halts on w, M_{M,w} halts on ε. Backward: Se M_{M,w} halts on ε, então M halted on w. Casos: aceitação preserva halt, rejeição/loop preserva vazio.",
                              "finalVerifications": [
                                "Duas direções provadas formalmente com simulações explícitas.",
                                "Todos casos (aceita, rejeita, loop) cobertos.",
                                "f é computável e total.",
                                "Exemplo concreto validado com trace.",
                                "Implicação para indecidabilidade clara.",
                                "Sem contradições lógicas ou ambiguidades."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão das definições iniciais (20%)",
                                "Rigor matemático nas provas forward/backward (40%)",
                                "Cobertura completa de casos e edge cases (20%)",
                                "Uso correto de notação formal e simulações (10%)",
                                "Conclusão sobre implicações para decidibilidade (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Provas por contradição e equivalências.",
                                "Teoria da Computação: Simulações de TM e encodings.",
                                "Matemática Discreta: Funções injetoras e bijetoras.",
                                "Filosofia da Ciência: Argumentos de redução para impossibilidade."
                              ],
                              "realWorldApplication": "Em verificação de software, prova correção de transformações em ferramentas de análise estática (ex: reduzir bug-finding para SAT-solving); em criptografia, validar reduções de segurança para provar que quebrar um esquema implica quebra de problema hard."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Aplicações em Provas de Indecidibilidade",
                        "description": "Uso de reduções para provar indecidibilidade de problemas clássicos como validade de fórmulas, equivalência de programas e outros.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Reduzir para problemas de linguagens",
                            "description": "Aplicar redução de HALT_TM para provar que E_TM (linguagens vazias) é indecidível, detalhando a construção da MT que aceita tudo se a simulação para.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os problemas HALT_TM e E_TM",
                                  "subSteps": [
                                    "Defina HALT_TM como o conjunto de pares <M, w> onde a máquina de Turing M para (halts) em entrada w.",
                                    "Defina E_TM como o conjunto de descrições <M> onde L(M) = ∅ (linguagem vazia, M nunca aceita nenhuma string).",
                                    "Explique por que HALT_TM é indecidível usando o argumento diagonal de Turing.",
                                    "Discuta por que provar indecidibilidade de E_TM requer redução de um problema conhecido indecidível.",
                                    "Identifique que usaremos uma redução de \\bar{HALT_TM} (não-halts) para E_TM."
                                  ],
                                  "verification": "Escreva definições precisas e resuma a prova de indecidibilidade de HALT_TM em 3 frases.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser, Capítulo 7)",
                                    "Notas sobre máquinas de Turing universais",
                                    "Papel para diagramas"
                                  ],
                                  "tips": "Use notação padrão <M> para codificação de máquinas de Turing.",
                                  "learningObjective": "Dominar as definições e a motivação para reduções em indecidibilidade.",
                                  "commonMistakes": "Confundir halting com aceitação; lembrar que halting inclui aceitar ou rejeitar, mas loop é não-halt."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar a estratégia de redução",
                                  "subSteps": [
                                    "Estabeleça a direção: <M, w> ∈ \\bar{HALT_TM} (M não halts em w) iff <M'> ∈ E_TM (L(M') = ∅).",
                                    "Descreva intuitivamente: M' simulará M em w; se simulação para, M' aceita todo input x; senão, loopa em todos x.",
                                    "Explique o resultado: Se M halts em w, L(M') = Σ* (não vazia); se não halts, L(M') = ∅.",
                                    "Discuta o papel da máquina universal U(<M>, w, x) para simular.",
                                    "Esboce pseudocódigo da transição de M'."
                                  ],
                                  "verification": "Desenhe um fluxograma mostrando o mapeamento <M,w> → <M'> e as condições iff.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Simulador de máquinas de Turing online (ex: Turing Machine Simulator)",
                                    "Ferramenta de fluxogramas (ex: Draw.io)"
                                  ],
                                  "tips": "Pense em termos de comportamento assintótico: simulação infinita implica loop em todos inputs.",
                                  "learningObjective": "Entender como reduções preservam indecidibilidade via equivalência computacional.",
                                  "commonMistakes": "Esquecer que se halts, deve aceitar *todo* x, não só alguns."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a máquina de Turing M' detalhadamente",
                                  "subSteps": [
                                    "Defina M' como uma máquina que usa fita com input x, mas ignora x inicialmente.",
                                    "Inicie simulação universal de M em w usando parte da fita.",
                                    "Se simulação halts (detectado por estado final de U), transite para estado 'aceitar x' independentemente de x.",
                                    "Se simulação não halts, permanece loopando na simulação para todo x.",
                                    "Codifique <M'> formalmente, descrevendo estados principais: q_init, q_sim, q_halted_accept_all."
                                  ],
                                  "verification": "Desenhe o diagrama de estados de M' com pelo menos 5 estados chave e transições principais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel quadriculado para diagramas de MT",
                                    "Referência de codificação de TMs (Sipser Apêndice)"
                                  ],
                                  "tips": "Use uma fita separada para simulação para evitar interferência com input x.",
                                  "learningObjective": "Construir explicitamente uma TM redutora envolvendo simulação universal.",
                                  "commonMistakes": "Não tratar o caso onde simulação halts: sempre mover para aceitação após halt."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar corretude e concluir a indecidibilidade",
                                  "subSteps": [
                                    "Prove →: Se M não halts em w, simulação loopa para todo x, logo M' nunca aceita, L(M')=∅.",
                                    "Prove ←: Se M halts em w, simulação termina finitamente para todo x, M' aceita x, L(M')=Σ* ≠∅.",
                                    "Mostre que a construção é computável (TM que gera <M'> de <M,w>).",
                                    "Conclua: Decisor hipotético para E_TM decidiria \\bar{HALT_TM}, contradição.",
                                    "Discuta generalizações para outros problemas de linguagens."
                                  ],
                                  "verification": "Escreva prova formal em 200 palavras, verificando ambos sentidos da iff.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Template de prova por contradição",
                                    "Exemplos de reduções do livro-texto"
                                  ],
                                  "tips": "Use quantificadores: para todo x, comportamento uniforme.",
                                  "learningObjective": "Masterizar provas de corretude em reduções de indecidibilidade.",
                                  "commonMistakes": "Ignorar que aceitação requer halt em estado aceitando; loop não é aceitação."
                                }
                              ],
                              "practicalExample": "Considere M que em qualquer input loopa (move direita para sempre sem aceitar). Para w=0, M não halts em w. Então M' em qualquer x loopa na simulação, nunca aceita, L(M')=∅, <M'> ∈ E_TM. Agora, M' que aceita imediatamente (halts sempre). Para w=0, halts, então M' simula e halt rápido, aceita todo x, L(M')=Σ* ≠∅, <M'> ∉ E_TM.",
                              "finalVerifications": [
                                "Pode codificar <M'> corretamente a partir de <M,w>?",
                                "Explica por que L(M')=∅ exatamente quando M não halts em w?",
                                "Desenha o diagrama de M' sem erros?",
                                "Prova ambos sentidos da redução?",
                                "Identifica como isso prova indecidibilidade de E_TM?",
                                "Aplica a um exemplo concreto?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da simulação universal em M'.",
                                "Completude da prova de corretude (ambos iff).",
                                "Clareza no diagrama de estados de M'.",
                                "Correta identificação da direção da redução (\\bar{HALT_TM} para E_TM).",
                                "Detecção e explicação de erros comuns em simulações.",
                                "Generalização para problemas similares."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Argumentos por contradição e diagonalização de Cantor.",
                                "Lógica: Reduções em teoria da complexidade computacional.",
                                "Filosofia: Limites da computabilidade e decidibilidade (Gödel, Turing).",
                                "Engenharia: Implicações em verificação formal de software."
                              ],
                              "realWorldApplication": "Essa redução prova que não existe algoritmo para determinar se um programa nunca produz saída válida (linguagem vazia), essencial em análise estática de código, detecção de deadlocks e limites de ferramentas de linting/verificadores automáticos em programação e IA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.1",
                              "10.1.7.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Reduzir para propriedades de gramáticas",
                            "description": "Construir redução para mostrar que ALL_CFG (todas as strings aceitas por uma CFG) é indecidível, usando diagonalização e simulação em MT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Problemas Fundamentais: ALL_CFG e A_TM",
                                  "subSteps": [
                                    "Defina formalmente ALL_CFG = {<G> | G é uma gramática livre de contexto e L(G) = Σ* }.",
                                    "Recapitule A_TM = {<M, w> | M é uma máquina de Turing que aceita a string w }, provado indecidível por diagonalização.",
                                    "Explique por que ALL_CFG é candidato a indecidível: propriedades não-triviais de linguagens RE.",
                                    "Discuta o complemento: se ALL_CFG decidível, implica decidibilidade de outros problemas.",
                                    "Estude o teorema de Rice para contextos semânticos."
                                  ],
                                  "verification": "Escreva definições precisas e resuma a prova de indecidibilidade de A_TM em suas próprias palavras.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Cap. 5 e 9)",
                                    "Notas de aula sobre Automata e Linguagens Formais",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use exemplos simples de Σ* como {0,1}* para visualizar.",
                                  "learningObjective": "Entender a definição exata de ALL_CFG e sua relação com problemas RE completos.",
                                  "commonMistakes": [
                                    "Confundir ALL_CFG com EQ_CFG",
                                    "Esquecer que Σ* é recursivo mas reconhecimento por CFG é sutil"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Simulação de Máquinas de Turing em Gramáticas Livres de Contexto",
                                  "subSteps": [
                                    "Aprenda a codificar configurações de MT como strings em uma gramática: estados, fita, cabeça.",
                                    "Construa regras de produção para simular um passo de MT: δ(q, σ) → (q', σ', D).",
                                    "Implemente simulação não-determinista em CFG para branches de execução.",
                                    "Codifique aceitação/rejeição: string especial se MT para em estado aceitador.",
                                    "Teste com MT trivial que aceita ε."
                                  ],
                                  "verification": "Construa uma CFG que simule uma MT simples com 2 estados e verifique se gera a linguagem correta.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Ferramenta online de simulação CFG (ex: JFLAP)",
                                    "Exemplos de Sipser p. 170-180",
                                    "Editor de texto para prototipar regras"
                                  ],
                                  "tips": "Comece com MT determinística simples antes de generalizar para não-determinística.",
                                  "learningObjective": "Capacitar a construção de CFGs que simulam execuções de MT de forma precisa.",
                                  "commonMistakes": [
                                    "Ignorar loops infinitos na simulação",
                                    "Erros na codificação de direções da cabeça (L/R)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Redução Explícita de A_TM para ALL_CFG",
                                  "subSteps": [
                                    "Dado <M, w>, defina G_{M,w}: gera todas as strings em Σ* via regras padrão, MAS simula M em w em paralelo.",
                                    "Se M aceita w, adicione regra para NÃO gerar uma string diagonal especial, como codificação única de aceitação.",
                                    "Se M rejeita ou loopa, garanta que todas strings sejam geradas (simulação falha silenciosamente).",
                                    "Formalize: L(G_{M,w}) = Σ* se M não aceita w; L(G_{M,w}) = Σ* - {c} se aceita, onde c é constante.",
                                    "Implemente regras de produção concretas para o simulador."
                                  ],
                                  "verification": "Escreva as regras de produção de G_{M,w} para uma MT de exemplo e prove membership para strings arbitrárias.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Pseudocódigo de redução de Sipser ou Hopcroft/Ullman",
                                    "JFLAP para testar CFG gerada",
                                    "Planilha para mapear estados MT → não-terminais CFG"
                                  ],
                                  "tips": "Use alfabeto expandido com símbolos de simulação (#, _, q_i) para evitar conflitos.",
                                  "learningObjective": "Construir a instância reduzida G_{M,w} corretamente.",
                                  "commonMistakes": [
                                    "Falhar em garantir geração de Σ* no caso de rejeição",
                                    "Confundir simulação com decisão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar a Correção da Redução e Aplicar Diagonalização",
                                  "subSteps": [
                                    "Prove: se M aceita w, então <G_{M,w}> ∉ ALL_CFG (falta string c).",
                                    "Prove: se M não aceita w, então L(G_{M,w}) = Σ* (simulação não bloqueia).",
                                    "Integre diagonalização: assuma decididor D para ALL_CFG, construa M' diagonal que contradiz.",
                                    "Conclua: redução polinomial implica indecidibilidade de ALL_CFG.",
                                    "Discuta generalizações para outras propriedades de gramáticas."
                                  ],
                                  "verification": "Escreva prova formal biforward (⇒ e ⇐) e verifique com exemplo onde M aceita/rejeita.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Artigo original de Chomsky ou notas de teoria da computação",
                                    "LaTeX para prova formal",
                                    "Exemplos resolvidos online"
                                  ],
                                  "tips": "Use contrapositiva para simplificar prova de correção.",
                                  "learningObjective": "Validar a redução e ligar à diagonalização clássica de Turing.",
                                  "commonMistakes": [
                                    "Ignorar halting em loops infinitos",
                                    "Erro na direção da redução (A_TM ≤ ALL_CFG)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere M que aceita {ww | w em {0,1}* } e w=00. Construa G_{M,00}: simula M em 00 (aceita), então L(G) ≠ {0,1}* pois falta string #aceita#0000. Se w=01 (rejeita), gera tudo.",
                              "finalVerifications": [
                                "Definição precisa de ALL_CFG e redução escrita corretamente.",
                                "Construção de G_{M,w} com regras de produção explícitas para exemplo.",
                                "Prova biforward da redução sem gaps lógicos.",
                                "Explicação de como diagonalização reforça a indecidibilidade.",
                                "Identificação de 3 propriedades semelhantes de gramáticas indecidíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (30%): Definições e teoremas corretos.",
                                "Construção da redução (30%): Regras CFG válidas e simulador funcional.",
                                "Prova de correção (20%): Lógica impecável em ambos sentidos.",
                                "Integração de diagonalização (10%): Ligação clara com prova de A_TM.",
                                "Clareza e exemplos (10%): Explicações acionáveis e sem ambiguidades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções redutíveis.",
                                "Lógica: Argumentos por contradição e diagonalização (Gödel).",
                                "Programação: Simulação de máquinas em código (Python interpreters).",
                                "Filosofia: Limites do conhecimento computacional."
                              ],
                              "realWorldApplication": "Em compiladores e verificadores de parsers (Yacc/Bison), prova limites de checagem automática de completude de linguagens de programação; em IA, mostra por que alguns problemas de aprendizado de gramáticas são intratáveis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.3"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.3",
                            "name": "Analisar cadeia de reduções",
                            "description": "Compor múltiplas reduções (ex: HALT_TM → A_TM → E_TM) para provar indecidibilidade em cascata, verificando transitividade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Reduções em Máquinas de Turing",
                                  "subSteps": [
                                    "Estudar a definição formal de redução many-one entre problemas de indecidibilidade.",
                                    "Analisar um exemplo simples de redução única, como HALT_TM reduz para A_TM.",
                                    "Identificar os componentes chave: função de redução f e preservação de sim/não.",
                                    "Exercitar com diagrama: desenhar setas de redução e explicar direção.",
                                    "Comparar reduções many-one com Turing-reduções."
                                  ],
                                  "verification": "Explicar em voz alta ou por escrito um exemplo de redução básica, justificando por que preserva indecidibilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introdução à Teoria da Computação' de Sipser (Cap. 7)",
                                    "Slides de aula sobre indecidibilidade",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Sempre lembre: a redução vai do problema conhecido indecidível para o alvo, não o contrário.",
                                  "learningObjective": "Dominar os fundamentos de uma redução única para basear composições.",
                                  "commonMistakes": [
                                    "Confundir direção da redução (de alvo para conhecido)",
                                    "Ignorar que f deve ser computável em tempo polinomial",
                                    "Misturar many-one com Cook-Levin"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Compor Duas Reduções Consecutivas",
                                  "subSteps": [
                                    "Estudar a composição f = g ∘ h, onde HALT_TM --h--> A_TM --g--> E_TM.",
                                    "Verificar computabilidade: se h e g são computáveis, f também é.",
                                    "Construir explicitamente a função composta para um exemplo dado.",
                                    "Desenhar diagrama em cascata com setas encadeadas.",
                                    "Testar com instância: dada uma TM M, aplicar h depois g."
                                  ],
                                  "verification": "Construir e escrever a função composta f para um par de reduções exemplo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de reduções compostas",
                                    "Exemplos de provas de Sipser ou Arora/Barak",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Pense na composição como 'pipe': saída de uma entra na outra.",
                                  "learningObjective": "Capacitar-se a compor reduções duplas manualmente.",
                                  "commonMistakes": [
                                    "Esquecer de compor as funções corretamente (f(x) = g(h(x))",
                                    "Não verificar se f é polinomial",
                                    "Perder a instância original na cadeia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Transitividade e Propriedades da Cadeia",
                                  "subSteps": [
                                    "Provar formalmente que indecidibilidade é transitiva via composição.",
                                    "Analisar preservação de sim/não através da cadeia inteira.",
                                    "Identificar condições: todas reduções many-one e computáveis.",
                                    "Aplicar a uma cadeia de 3 reduções: HALT → A → E.",
                                    "Discutir limitações: quando composição falha (ex: não-polinomial)."
                                  ],
                                  "verification": "Escrever uma prova curta de transitividade para uma cadeia específica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigo ou capítulo sobre reduções em cascata",
                                    "Lápis para anotações formais",
                                    "Exemplos resolvidos online (ex: StackExchange Teoria CS)"
                                  ],
                                  "tips": "Use indução para cadeias longas: base (1 redução), passo (adicionar uma).",
                                  "learningObjective": "Garantir compreensão das propriedades algébricas das reduções.",
                                  "commonMistakes": [
                                    "Assumir transitividade sem prova",
                                    "Confundir com equivalência (redução bidirecional)",
                                    "Ignorar overhead de tempo na composição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar uma Cadeia Completa em Prova de Indecidibilidade",
                                  "subSteps": [
                                    "Escolher uma prova real: HALT_TM → A_TM → E_TM → PCP.",
                                    "Mapear cada redução na cadeia com funções explícitas.",
                                    "Verificar passo a passo: se HALT indecidível implica PCP indecidível.",
                                    "Identificar pontos frágeis na cadeia (ex: complexidade da redução).",
                                    "Criticar a prova: discutir se há atalhos ou falhas conhecidas."
                                  ],
                                  "verification": "Produzir um relatório resumido da análise da cadeia, com diagrama e conclusão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Prova completa de undecidability de PCP (Sipser)",
                                    "Paper original de Cook ou Minsky",
                                    "Editor de texto para relatório"
                                  ],
                                  "tips": "Anote 'sim → sim' e 'não → não' para cada seta para rastrear.",
                                  "learningObjective": "Aplicar análise de cadeia em contexto de prova real.",
                                  "commonMistakes": [
                                    "Pular verificação de uma redução intermediária",
                                    "Não notar que algumas cadeias usam reduções diferentes (many-one vs Turing)",
                                    "Concluir indecidibilidade sem cadeia completa"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise a cadeia HALT_TM → A_TM → E_TM → PCP: Construa f = pcp ∘ etm ∘ atm ∘ halt, mostrando que se PCP fosse decidível, HALT seria decidível, contradizendo Rice's Theorem.",
                              "finalVerifications": [
                                "Construir corretamente uma composição de 3+ reduções.",
                                "Provar transitividade com linguagem formal.",
                                "Identificar erros em uma cadeia dada com falha.",
                                "Desenhar diagrama preciso de cascata.",
                                "Explicar implicações para um problema novo.",
                                "Verificar computabilidade polinomial da composição final."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e composição de funções de redução (90% correto).",
                                "Correta aplicação de transitividade com prova concisa.",
                                "Identificação de pelo menos 2 erros comuns em cadeias exemplo.",
                                "Diagrama claro e rotulado de pelo menos 4 reduções.",
                                "Análise crítica de limitações reais da cadeia.",
                                "Tempo de execução da análise dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra de funções compostas e transitividade em relações.",
                                "Lógica: Inferência em cadeias de implicações e teorema de Rice.",
                                "Filosofia: Limites epistemológicos do computacional (Gödel, Turing).",
                                "Engenharia de Software: Modelagem de dependências em proofs de complexidade.",
                                "Física Computacional: Reduções em simulações quânticas."
                              ],
                              "realWorldApplication": "Em verificação formal de software (ex: provar indecidibilidade de checagem de vulnerabilidades em protocolos), guiando engenheiros a evitar problemas intratáveis e optar por aproximações heurísticas em cibersegurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.4",
                            "name": "Resolver exercícios de redução",
                            "description": "Dado um problema alvo, esboçar e provar uma redução a partir de um problema conhecido indecidível, como o Problema da Parada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema Alvo e o Problema de Referência",
                                  "subSteps": [
                                    "Ler cuidadosamente a descrição do problema alvo, identificando entradas (ex: TM M e string w) e a pergunta de decisão (sim/não).",
                                    "Revisar o problema conhecido indecidível, como o Problema da Parada (HP): 'Dada TM M e input w, M para em w?'.",
                                    "Comparar os dois problemas, notando similaridades em estrutura (máquinas de Turing e inputs).",
                                    "Listar as propriedades chave: decidibilidade, linguagem associada e exemplos de instâncias."
                                  ],
                                  "verification": "Escrever um resumo de 1 parágrafo para cada problema, confirmando compreensão mútua.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Descrição do exercício",
                                    "Notas de aula sobre Problema da Parada",
                                    "Livro de Teoria da Computação (ex: Sipser)"
                                  ],
                                  "tips": "Use diagramas para visualizar entradas/saídas de cada problema.",
                                  "learningObjective": "Identificar precisamente as instâncias e questões de decisão de problemas undecidíveis.",
                                  "commonMistakes": "Confundir 'parada' com 'aceitação'; assumir decidibilidade sem prova."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Esboçar a Construção da Redução",
                                  "subSteps": [
                                    "Decidir a direção: reduzir HP para o problema alvo (assumir HP sim => alvo sim).",
                                    "Definir intuitivamente como transformar (M,w) de HP em instância equivalente do alvo.",
                                    "Esboçar componentes: nova TM M' que simula M em w e adapta para o formato do alvo.",
                                    "Desenhar um fluxograma da redução, mostrando mapeamento de sim/não."
                                  ],
                                  "verification": "Desenhar um diagrama informal mostrando HP -> Alvo com setas para casos sim/não.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Pense em 'simulador': M' deve embutir M e w, então decidir baseado no alvo.",
                                  "learningObjective": "Desenvolver intuição para reduções many-one entre problemas de decisão.",
                                  "commonMistakes": "Esquecer de codificar w na TM M'; ignorar tempo de computação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Função de Redução",
                                  "subSteps": [
                                    "Definir formalmente f((M,w)) = instância do alvo (ex: M' onde M' simula M em w).",
                                    "Especificar como construir M': incluir cópia de M, w hardcoded, lógica de simulação.",
                                    "Provar que f é computável (TM que constrói M' em tempo finito).",
                                    "Escrever pseudocódigo ou descrição em linguagem formal para f."
                                  ],
                                  "verification": "Implementar uma TM fictícia ou pseudocódigo que computa f em uma instância exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Formalismo de TM (notas)",
                                    "Ferramenta de desenho para TMs"
                                  ],
                                  "tips": "Use padrão '4-way branching' para simular HP em reduções padrão.",
                                  "learningObjective": "Construir funções de redução computáveis explicitamente.",
                                  "commonMistakes": "f não total (não definida para todos inputs); f não eficiente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar a Corretude da Redução",
                                  "subSteps": [
                                    "Provar implicação =>: Se HP sim (M para w), então alvo sim para f((M,w)).",
                                    "Provar implicação <=: Se HP não (M loop w), então alvo não para f((M,w)).",
                                    "Analisar simulação: mostrar que M' comporta como esperado em ambos casos.",
                                    "Verificar preservação de sim/não via contradição se supor decididor para alvo."
                                  ],
                                  "verification": "Escrever prova bidirecional com casos exaustivos, sem lacunas lógicas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel para provas formais",
                                    "Exemplos resolvidos de reduções"
                                  ],
                                  "tips": "Use 'por contradição': suponha decididor D para alvo, construa para HP.",
                                  "learningObjective": "Dominar provas de corretude em reduções de Turing.",
                                  "commonMistakes": "Prova só unidirecional; ignorar loops infinitos na simulação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir a Indecidibilidade e Verificar",
                                  "subSteps": [
                                    "Concluir: se alvo decidível, então HP decidível (contradição).",
                                    "Testar redução em exemplo pequeno (TM trivial).",
                                    "Identificar possíveis falhas e refinar.",
                                    "Documentar prova completa em formato estruturado."
                                  ],
                                  "verification": "Simular manualmente 2 instâncias (uma sim, uma não) através da redução.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de TMs simples"
                                  ],
                                  "tips": "Sempre cheque 'equisatisfatibilidade' via simulação passo-a-passo.",
                                  "learningObjective": "Aplicar reduções para provar undecidibilidade formalmente.",
                                  "commonMistakes": "Concluir sem prova contrafactual; pular verificação de exemplos."
                                }
                              ],
                              "practicalExample": "Reduza o Problema da Parada (HP: 'TM M para em w?') para 'L(M) é vazia?' (Empty Language). Construa M' que, em input ε, simula M em w; se para, rejeita; senão loop. Prova: HP sim => M' rejeita ε => L(M') não vazia? Não: wait, padrão é M' aceita ε iff M loops em w.",
                              "finalVerifications": [
                                "A função de redução f é computável e total.",
                                "Preservação correta: HP sim iff alvo sim.",
                                "Simulação de M em w é fiel na TM reduzida.",
                                "Prova cobre casos de parada e loop infinito.",
                                "Redução funciona para todas instâncias de HP.",
                                "Nenhuma instância mapeia incorretamente sim/não."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na definição de f((M,w)).",
                                "Prova bidirecional completa sem suposições.",
                                "Formalismo correto de TMs e simulações.",
                                "Tratamento explícito de loops infinitos.",
                                "Exemplo prático validado manualmente.",
                                "Lógica impecável por contradição.",
                                "Eficiência da redução demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por contradição e indução em teoria dos conjuntos.",
                                "Lógica: Raciocínio dedutivo e teoremas de Rice.",
                                "Programação: Simulação de máquinas virtuais e interpretadores.",
                                "Filosofia: Limites do conhecimento computacional (Gödel).",
                                "Engenharia de Software: Análise de complexidade em verificadores."
                              ],
                              "realWorldApplication": "Em verificação de software, prova limites de ferramentas automáticas (ex: não existe checker universal para bugs de loop infinito), guiando design de analisadores estáticos parciais em compiladores como GCC ou ferramentas como PVS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Linguagens Recursivas e Recursivamente Enumeráveis",
                    "description": "Diferenças entre linguagens decidíveis (REC) e semi-decidíveis (RE), com exemplos de indecidibilidade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Linguagens Recursivas (REC)",
                        "description": "Conjuntos de palavras decidíveis por uma Máquina de Turing que sempre para (halta) com a resposta correta, independentemente de a palavra pertencer ou não à linguagem.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Definir linguagens recursivas",
                            "description": "Explicar formalmente que uma linguagem é recursiva se existe uma TM decididora que para em todos os inputs, aceitando se pertence e rejeitando caso contrário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Máquinas de Turing e Linguagens Formais",
                                  "subSteps": [
                                    "Relembre a definição formal de uma Máquina de Turing (TM): conjunto de estados, alfabeto, fita, cabeçote, função de transição e estados inicial, aceitação e rejeição.",
                                    "Entenda o conceito de reconhecimento: uma TM reconhece uma linguagem se para e aceita em strings da linguagem, podendo loopar em strings fora dela.",
                                    "Diferencie TM reconhecendoras (aceitadoras) de TM decididoras: decididoras param em todos os inputs.",
                                    "Liste exemplos de linguagens reconhecidas por TM, como {a^n b^n | n ≥ 0}.",
                                    "Pratique diagramando uma TM simples para uma linguagem regular."
                                  ],
                                  "verification": "Resuma em um parágrafo os componentes de uma TM e a diferença entre reconhecimento e decisão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Papel e caneta para diagramas",
                                    "Vídeo tutorial sobre TM no YouTube"
                                  ],
                                  "tips": "Use diagramas visuais para representar transições de TM; foque em exemplos concretos para fixar conceitos.",
                                  "learningObjective": "Compreender os pré-requisitos de TM e distinção entre reconhecimento e decisão.",
                                  "commonMistakes": [
                                    "Confundir halting com looping infinito",
                                    "Ignorar o estado de rejeição em decididores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender TM Decididoras (Deciders)",
                                  "subSteps": [
                                    "Defina formalmente uma TM decididora: para (halts) em todos os inputs, aceitando se w ∈ L e rejeitando caso contrário.",
                                    "Compare com TM reconhecendoras: deciders são um subconjunto que sempre halta.",
                                    "Estude a notação: M decide L se para em todos w ∈ Σ*, com M(w) = ACCEPT se w ∈ L, REJECT otherwise.",
                                    "Construa um decider trivial para a linguagem vazia ou Σ*.",
                                    "Analise por que nem toda TM reconhecidora é decididora (ex: halting problem)."
                                  ],
                                  "verification": "Escreva a definição formal de TM decididora e dê um exemplo de TM que decide Σ*.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre TM",
                                    "Simulador online de TM (como Turing Machine Simulator)"
                                  ],
                                  "tips": "Sempre pergunte: 'Essa TM para em TODOS os inputs?' para validar um decider.",
                                  "learningObjective": "Dominar a definição e propriedades de TM decididoras.",
                                  "commonMistakes": [
                                    "Achar que toda TM que reconhece uma linguagem decide ela",
                                    "Esquecer que deciders rejeitam explicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente Linguagens Recursivas (REC)",
                                  "subSteps": [
                                    "Defina L é recursiva (REC) se existe TM M decididora para L: ∀w ∈ Σ*, M halta e aceita iff w ∈ L.",
                                    "Escreva a definição matemática: L ∈ REC ⇔ ∃ TM M que decide L.",
                                    "Discuta equivalências: REC = linguagens decidíveis por TM.",
                                    "Prove que linguagens regulares e context-free decidíveis estão em REC.",
                                    "Diferencie de RE: REC ⊂ RE, pois RE permite loop em não-membros."
                                  ],
                                  "verification": "Escreva a definição exata de linguagem recursiva e prove que {ε} é REC.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigo ou capítulo sobre hierarquia de Chomsky e indecidabilidade",
                                    "Editor de texto para formalizações"
                                  ],
                                  "tips": "Memorize a frase chave: 'Sempre para, sempre correto: aceita ou rejeita'.",
                                  "learningObjective": "Explicar formalmente o que torna uma linguagem recursiva.",
                                  "commonMistakes": [
                                    "Confundir REC com RE",
                                    "Omitir 'para em todos os inputs' na definição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Exemplos e Propriedades de REC",
                                  "subSteps": [
                                    "Exemplo: L = {w | w é palindrome} é REC? Construa um decider simples.",
                                    "Propriedade: REC é fechada sob união, interseção, complemento.",
                                    "Relacione com problemas indecidíveis: halting problem ∉ REC.",
                                    "Pratique provando que uma linguagem dada é REC via construção de TM decididora.",
                                    "Compare tamanhos: |REC| < |RE| < |todas linguagens possíveis|."
                                  ],
                                  "verification": "Construa TM decididora para {a^n b^n | n ≥ 0} e liste 3 propriedades de REC.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Simulador de TM",
                                    "Lista de exercícios de linguagens formais"
                                  ],
                                  "tips": "Para provar REC, sempre esboce a TM decididora explicitamente.",
                                  "learningObjective": "Aplicar a definição em exemplos e entender closure properties.",
                                  "commonMistakes": [
                                    "Assumir que CF decidíveis cobrem todos REC",
                                    "Confundir closure de REC vs RE"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa uma TM decididora para L = {w ∈ {0,1}* | w tem número par de 1s}. A TM conta os 1s na fita, alternando estados 'par' e 'ímpar', rejeitando se encontrar erro de formato ou terminando em 'ímpar'; aceita em 'par'. Isso prova L ∈ REC pois halta sempre.",
                              "finalVerifications": [
                                "Explique a definição de REC sem consultar notas.",
                                "Dê 2 exemplos de linguagens em REC e 1 não-REC.",
                                "Prove closure sob complemento para REC.",
                                "Diferencie REC e RE com diagrama de inclusão.",
                                "Construa decider para linguagem trivial como Σ*."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (inclui halting em todos inputs).",
                                "Correta distinção entre REC, RE e decididores.",
                                "Capacidade de construir TM decididora para exemplos simples.",
                                "Compreensão de propriedades como closure.",
                                "Identificação de erros comuns em definições.",
                                "Uso correto de notação matemática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções totais (halting).",
                                "Lógica: Conceitos de decidibilidade e teorema de Church-Turing.",
                                "Filosofia: Limites do computacional (Gödel e indecidibilidade).",
                                "Engenharia de Software: Algoritmos que sempre terminam (vs heurísticas)."
                              ],
                              "realWorldApplication": "Em compiladores, verificar se um programa é sintaticamente correto requer um decider (REC), garantindo que o parser sempre termine com aceitação ou rejeição explícita, essencial para ferramentas de IDEs e verificadores estáticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Identificar exemplos de linguagens REC",
                            "description": "Reconhecer exemplos como linguagens regulares, livres de contexto e decidíveis, como {w | w é palíndromo em {0,1}*}, provando decidibilidade via TM.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal de linguagens REC",
                                  "subSteps": [
                                    "Leia a definição: Uma linguagem L é REC se existe uma TM M que, para toda entrada w, para e aceita se w ∈ L, e para e rejeita se w ∉ L.",
                                    "Compare com RE: RE para e aceita se ∈ L, mas pode loopar se ∉ L.",
                                    "Estude propriedades: REC ⊆ RE, e REC são fechadas sob complemento.",
                                    "Anote exemplos iniciais: linguagens regulares e livres de contexto são REC.",
                                    "Resuma em suas palavras a diferença chave: halting para todas as entradas."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras definindo REC e diferenciando de RE; verifique se menciona decidibilidade total.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Notas de aula sobre TMs",
                                    "Folha de papel ou editor de texto"
                                  ],
                                  "tips": [
                                    "Use diagramas de TMs para visualizar aceitação/rejeição.",
                                    "Foquem em 'para sempre' vs 'pode loopar'.",
                                    "Crie uma tabela comparativa REC vs RE."
                                  ],
                                  "learningObjective": "Compreender precisamente o que torna uma linguagem recursiva (decidível).",
                                  "commonMistakes": [
                                    "Confundir REC com RE, ignorando o loop em RE.",
                                    "Achar que todas as RE são REC.",
                                    "Esquecer que REC requer decisão para todas as entradas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar exemplos clássicos de linguagens REC",
                                  "subSteps": [
                                    "Liste linguagens regulares: ex. {w | w tem número par de 0s} – decidível por AFD.",
                                    "Liste linguagens livres de contexto decidíveis: ex. {a^n b^n | n ≥ 0} – via PDA determinístico.",
                                    "Inclua linguagens decidíveis gerais: ex. {w | |w| é par} – trivial por TM.",
                                    "Classifique 5 linguagens comuns como REC ou não.",
                                    "Discuta por que todas as linguagens de Chomsky hierarchy (0-3) são REC."
                                  ],
                                  "verification": "Crie uma lista de 5 exemplos de REC com justificativa breve; um colega deve concordar.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela da Hierarquia de Chomsky",
                                    "Exemplos de linguagens de notas de aula",
                                    "Caneta e papel"
                                  ],
                                  "tips": [
                                    "Lembre: decidível = REC.",
                                    "Use famílias menores (reg, CF) como porta de entrada.",
                                    "Evite exemplos ambíguos como halting problem (não REC)."
                                  ],
                                  "learningObjective": "Reconhecer padrões de linguagens conhecidamente decidíveis.",
                                  "commonMistakes": [
                                    "Incluir RE não REC como {w | TM_w aceita w}.",
                                    "Achar que todo CFL é REC (sim, mas prove).",
                                    "Confundir enumerável com recursivo."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o exemplo específico: palíndromos sobre {0,1}*",
                                  "subSteps": [
                                    "Defina L = {w ∈ {0,1}* | w é palíndromo}.",
                                    "Descreva algoritmo: compare w[i] com w[n-1-i] para i=0 a n/2.",
                                    "Construa TM de alto nível: leia fita, marque centro, compare pares simetricamente.",
                                    "Prove decidibilidade: TM sempre para (tempo O(n)).",
                                    "Teste com exemplos: 010 (sim), 011 (não)."
                                  ],
                                  "verification": "Esboce pseudocódigo ou diagrama de TM que decide L; simule em 3 strings.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de TM online (ex. Turing Machine Simulator)",
                                    "Fita simulada no papel",
                                    "Exemplos de palíndromos binários"
                                  ],
                                  "tips": [
                                    "Comece com versão não-eficiente; otimize depois.",
                                    "Marque posições na fita para evitar erros.",
                                    "Teste casos edge: ε, strings ímpares."
                                  ],
                                  "learningObjective": "Aplicar prova de decidibilidade a um exemplo concreto.",
                                  "commonMistakes": [
                                    "Achar palíndromos não-decidíveis (são!)",
                                    "Esquecer strings vazias ou unitárias.",
                                    "Construir TM que loopa em rejeição."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e diferenciação de linguagens REC",
                                  "subSteps": [
                                    "Receba 5 linguagens aleatórias; classifique como REC ou RE-não-REC.",
                                    "Para REC, esboce TM decisor; para não, explique por quê.",
                                    "Diferencie: ex. ALL = Σ* é REC; EQ_TM não é.",
                                    "Crie seu próprio exemplo de REC e prove.",
                                    "Revise lista: confirme linguagens reg/CF/TM-decidíveis como REC."
                                  ],
                                  "verification": "Resolva um quiz de 5 itens com 100% acerto; explique um prova.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de exercícios de indecidibilidade",
                                    "Quiz online ou impresso",
                                    "Timer"
                                  ],
                                  "tips": [
                                    "Pergunte: 'Existe TM que sempre para?'",
                                    "Use rice's theorem para não-REC.",
                                    "Pratique com variações de palíndromos."
                                  ],
                                  "learningObjective": "Identificar autonomamente exemplos de REC com justificativa.",
                                  "commonMistakes": [
                                    "Classificar halting como REC.",
                                    "Ignorar prova de decidibilidade.",
                                    "Confundir decidível com reconhecível."
                                  ]
                                }
                              ],
                              "practicalExample": "Dado L = {w ∈ {0,1}* | w é palíndromo}, prove que é REC construindo TM M: 1. Leia comprimento n. 2. Para i=1 a floor(n/2): compare símbolo i com n-i+1. 3. Aceite se todos iguais, rejeite senão. Simule em w=0110 (rejeita pois 0≠1).",
                              "finalVerifications": [
                                "Liste corretamente 5 exemplos de REC (reg, CF, palíndromos, etc.).",
                                "Explique por que L_pal é REC com esboço de TM.",
                                "Diferencie REC de RE com exemplo de RE-não-REC.",
                                "Prove decidibilidade de uma linguagem dada como REC.",
                                "Identifique erros em classificações comuns de linguagens.",
                                "Simule TM decisor em 3 entradas variadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos de REC (80% peso).",
                                "Qualidade das provas de decidibilidade via TM.",
                                "Correção na diferenciação REC vs RE.",
                                "Profundidade nos sub-steps e verificações.",
                                "Criatividade em exemplos práticos e conexões.",
                                "Completude: todos campos preenchidos sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções totais (decidibilidade).",
                                "Lógica: Provas de existência de algoritmos haltantes.",
                                "Programação: Implementação de verificadores em Python (ex. is_palindrome).",
                                "Filosofia: Limites da computação (Gödel, halting).",
                                "Engenharia de Software: Verificação de propriedades decidíveis."
                              ],
                              "realWorldApplication": "Em compiladores, verificar sintaxe (CFL decidível=REC); em verificação de software, checar propriedades como 'todo loop termina' se modelado decidivelmente; em IA, validar inputs palindrômicos em padrões de dados ou criptografia simétrica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Provar propriedades de REC",
                            "description": "Demonstrar que REC é fechada sob união, concatenação, estrela de Kleene e complemento, construindo TMs compostas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição de Linguagens REC e Máquinas de Turing Decisoras",
                                  "subSteps": [
                                    "Defina formalmente uma linguagem REC como o conjunto de strings aceitas por uma TM que halta em todas as entradas.",
                                    "Explique a diferença entre REC e RE (recursivamente enumeráveis).",
                                    "Descreva o modelo de TM decisora: sempre halta com aceita/rejeita.",
                                    "Estude exemplos canônicos de linguagens REC, como {a^n b^n | n ≥ 0}."
                                  ],
                                  "verification": "Escreva uma definição precisa e identifique corretamente 3 exemplos de REC vs RE.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Cap. 4)",
                                    "Notas de aula sobre Automata",
                                    "Simulador de TM online"
                                  ],
                                  "tips": [
                                    "Use diagramas para visualizar o comportamento de TMs decisoras.",
                                    "Compare com TMs que podem loopar indefinidamente."
                                  ],
                                  "learningObjective": "Compreender os fundamentos teóricos de REC para basear as provas de fechamento.",
                                  "commonMistakes": [
                                    "Confundir REC com RE.",
                                    "Ignorar que TMs REC devem halta em todas as entradas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar Fechamento sob União",
                                  "subSteps": [
                                    "Dadas TMs M1 e M2 decisoras para L1 e L2, construa M_union que, em entrada w, simula M1(w); se aceita, aceita; senão simula M2(w).",
                                    "Argumente que M_union halta sempre, pois M1 e M2 halta.",
                                    "Verifique que L(M_union) = L1 ∪ L2.",
                                    "Teste com exemplo: L1 = {a^n b^n}, L2 = {a^n c^n}."
                                  ],
                                  "verification": "Construa e descreva a TM M_union em pseudocódigo ou diagrama, provando corretude e totalidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para diagramas de TM",
                                    "Sipser Cap. 4.2",
                                    "Ferramenta JFLAP para simulação"
                                  ],
                                  "tips": [
                                    "Pense em 'execução sequencial' para evitar paralelismo desnecessário.",
                                    "Sempre prove tanto aceitação quanto rejeição."
                                  ],
                                  "learningObjective": "Dominar a construção composicional para união em TMs decisoras.",
                                  "commonMistakes": [
                                    "Esquecer de lidar com rejeição de M1 antes de rodar M2.",
                                    "Assumir nondeterminismo sem justificativa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar Fechamento sob Concatenação",
                                  "subSteps": [
                                    "Construa M_concat para L1 · L2: para w de tamanho n, para cada i=0 a n, verifique se prefixo w[1..i] ∈ L1 e sufixo w[i+1..n] ∈ L2 usando M1 e M2.",
                                    "Argumente halting: número finito de splits, cada simulação halta.",
                                    "Prove L(M_concat) = L1 · L2.",
                                    "Exemplo: {a^n b^n} · {c^m d^m}."
                                  ],
                                  "verification": "Escreva pseudocódigo da TM e calcule complexidade temporal (O(n * tempo(M1+M2))).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "JFLAP ou simulador TM",
                                    "Notas sobre loops em TMs",
                                    "Exemplos de linguagens regulares como base"
                                  ],
                                  "tips": [
                                    "Use contador para iterar sobre splits possíveis.",
                                    "Otimize verificando comprimentos mínimos se conhecidos."
                                  ],
                                  "learningObjective": "Aprender brute-force enumeration para operações booleanas em decidíveis.",
                                  "commonMistakes": [
                                    "Não iterar todos os splits possíveis.",
                                    "Confundir com concatenação em regex (nondet)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Fechamento sob Estrela de Kleene",
                                  "subSteps": [
                                    "Construa M_star para L*: simule loop - enquanto possível, encontre splits sucessivos de w em k partes, cada em L, para k=0,1,... até |w|.",
                                    "Use recursão ou iteração com backtracking determinístico, verificando halting por bounds finitos.",
                                    "Prove aceitação se existe decomposição, rejeição otherwise.",
                                    "Exemplo: ({ab} ∪ {ba})*."
                                  ],
                                  "verification": "Descreva algoritmo detalhado e prove que termina em tempo finito.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Sipser Cap. 4.3",
                                    "Pseudocódigo em Python simulando TM",
                                    "Diagramas de estados"
                                  ],
                                  "tips": [
                                    "Pense em dynamic programming: dp[i] = true se prefixo i pode ser decomposição.",
                                    "Comece com k=0 (epsilon)."
                                  ],
                                  "learningObjective": "Entender construções iterativas para fechamento sob estrela em classes decidíveis.",
                                  "commonMistakes": [
                                    "Usar nondet sem converter para det.",
                                    "Loop infinito sem bound em k."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Provar Fechamento sob Complemento",
                                  "subSteps": [
                                    "Dada M decisora para L, construa M_comp que simula M(w) e inverte: aceita se M rejeita, rejeita se M aceita.",
                                    "Argumente M_comp halta sempre e L(M_comp) = complemento de L.",
                                    "Discuta implicações: REC fechada sob complemento implica decidível.",
                                    "Exemplo: complemento de {a^n b^n}."
                                  ],
                                  "verification": "Escreva TM simples e prove por casos (aceita/rejeita de M).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas básicas de TM",
                                    "Exemplos de linguagens co-RE vs REC"
                                  ],
                                  "tips": [
                                    "Mais simples que as outras: só inverter output.",
                                    "Lembre: RE não é fechada sob complemento."
                                  ],
                                  "learningObjective": "Reconhecer simplicidade do complemento em classes totais.",
                                  "commonMistakes": [
                                    "Tentar simular em paralelo.",
                                    "Esquecer que M halta garante halting de M_comp."
                                  ]
                                }
                              ],
                              "practicalExample": "Prove que a linguagem L = {a^n b^n | n≥0} ∪ {a^n b^{2n} | n≥0} é REC, construindo TM para união de duas TMs decisoras conhecidas.",
                              "finalVerifications": [
                                "TM para união halta e aceita exatamente L1 ∪ L2.",
                                "TM para concatenação testa todos splits corretamente.",
                                "TM para estrela encontra decomposições ou rejeita finitamente.",
                                "TM para complemento inverte precisamente.",
                                "Todas construções preservam decidibilidade.",
                                "Exemplos testados com strings específicas aceitam/rejeitam corretamente."
                              ],
                              "assessmentCriteria": [
                                "Corretude formal das provas de halting e aceitação.",
                                "Detalhe nas descrições de TMs (pseudocódigo ou diagramas).",
                                "Tratamento de casos edge (strings vazias, comprimentos zero).",
                                "Clareza na distinção entre operações.",
                                "Uso apropriado de argumentos de finitude.",
                                "Integração coerente de todas propriedades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e indução para estrela.",
                                "Lógica: Provas por casos e contradição em halting.",
                                "Programação: Simulação de loops e recursão em algoritmos decidíveis.",
                                "Filosofia da Computação: Limites da decidibilidade."
                              ],
                              "realWorldApplication": "Em verificadores de software e compiladores, propriedades de REC garantem que problemas como 'esta string é válida?' sejam decidíveis, permitindo ferramentas como parsers LL(k) ou validadores XML que sempre terminam."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Linguagens Recursivamente Enumeráveis (RE)",
                        "description": "Conjuntos de palavras aceitos por uma Máquina de Turing que para e aceita se a palavra pertence, mas pode entrar em loop infinito caso contrário.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Definir linguagens RE",
                            "description": "Descrever que L é RE se existe TM M tal que para x em L, M(x) aceita, e para x não em L, M(x) para ou loopa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os fundamentos de Máquinas de Turing (TM)",
                                  "subSteps": [
                                    "Estude a definição formal de uma Máquina de Turing: conjunto de estados, alfabeto, fita, cabeçote, função de transição e estados inicial, aceitação e rejeição.",
                                    "Revise como uma TM processa uma entrada: lê símbolos da fita, move o cabeçote e altera estados conforme a transição.",
                                    "Identifique os componentes principais: fita infinita, determinística ou não-determinística.",
                                    "Pratique simulando uma TM simples que reconhece {a^n b^n}.",
                                    "Entenda que TMs equivalem à computabilidade geral."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os 7-tuple de uma TM e simule um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser ou similar), simulador online de TM (ex: Turing Machine Simulator).",
                                  "tips": "Desenhe diagramas de transição para visualizar melhor.",
                                  "learningObjective": "Compreender a estrutura e operação básica de uma TM.",
                                  "commonMistakes": "Confundir TM com autômatos finitos; ignorar a fita infinita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os comportamentos possíveis de uma TM em uma entrada",
                                  "subSteps": [
                                    "Liste os três comportamentos: aceita (entra em q_accept), rejeita (entra em q_reject) ou loopa infinitamente.",
                                    "Defina formalmente: M aceita x se há um caminho para q_accept; rejeita se para q_reject; loopa caso contrário.",
                                    "Discuta o halting problem: nem sempre sabemos se para ou loopa.",
                                    "Exemplo: TM que aceita strings pares de 'a' e loopa em ímpares.",
                                    "Compare com modelos mais simples como AFND, que sempre param."
                                  ],
                                  "verification": "Classifique o comportamento de 3 TMs exemplo em uma tabela: aceita/rejeita/loopa para entradas específicas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta para diagramas, exemplos de TMs de aulas anteriores.",
                                  "tips": "Use notação: M(x) ⊢* q_accept para aceitação.",
                                  "learningObjective": "Distinguir aceitação, rejeição e loop infinito em TMs.",
                                  "commonMistakes": "Achar que toda TM sempre para; confundir loop com rejeição."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a linguagem aceita por uma TM (L(M))",
                                  "subSteps": [
                                    "Defina L(M) = {x ∈ Σ* | M(x) aceita}.",
                                    "Note que para x ∉ L(M), M(x) pode rejeitar (para em q_reject) ou loopar.",
                                    "Prove que L(M) é uma linguagem formal válida.",
                                    "Exemplo: TM para {0^n 1^n | n ≥ 0}, L(M) contém exatamente essas strings.",
                                    "Discuta closure properties: união, concatenação de L(M1) e L(M2)."
                                  ],
                                  "verification": "Escreva a definição formal de L(M) e dê 2 exemplos de L(M).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de definições formais, simulador de TM.",
                                  "tips": "Sempre especifique o alfabeto Σ*.",
                                  "learningObjective": "Formalizar a linguagem gerada pela aceitação de uma TM.",
                                  "commonMistakes": "Incluir strings onde loopa como aceitas; confundir com L(M) recursiva."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar linguagens Recursivamente Enumeráveis (RE)",
                                  "subSteps": [
                                    "Defina: L é RE se ∃ TM M tal que L = L(M), i.e., ∀x ∈ L, M(x) aceita; ∀x ∉ L, M(x) para ou loopa.",
                                    "Contrastar com recursivas (REC): ∀x, M(x) para (aceita ou rejeita).",
                                    "Exemplo: halting problem é RE mas não REC.",
                                    "RE = ∪ todas L(M); toda REC é RE, mas não vice-versa.",
                                    "Discuta semi-decidibilidade: RE são semi-decidíveis."
                                  ],
                                  "verification": "Redija a definição completa de linguagem RE e prove que {ww | w ∈ {0,1}*} é RE.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Livro texto, notas de aula sobre indecidabilidade.",
                                  "tips": "Lembre: 'para ou loopa' significa pode não halting em negativos.",
                                  "learningObjective": "Definir precisamente linguagens RE e diferenciá-las de REC.",
                                  "commonMistakes": "Exigir halting em todos os casos (confundir com REC); inverter aceitação."
                                }
                              ],
                              "practicalExample": "Considere a linguagem H = {<M,w> | TM M aceita w}. Construa TM M_H que simula M em w: se aceita, aceita; senão loopa se M loopa ou rejeita. Assim H é RE, mas não REC pelo halting problem.",
                              "finalVerifications": [
                                "Defina corretamente L(M) para uma TM dada.",
                                "Explique por que para x ∉ L, M(x) pode loopar.",
                                "Classifique uma linguagem como RE ou não com justificativa.",
                                "Dê exemplo de RE não REC.",
                                "Prove que toda REC é RE.",
                                "Descreva semi-decidibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de RE (aceita em L, para/loopa fora).",
                                "Correta distinção entre RE e REC.",
                                "Uso apropriado de notação (L(M), TM).",
                                "Exemplos relevantes e corretos.",
                                "Entendimento de halting implications.",
                                "Clareza na explicação de comportamentos de TM."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos (família de linguagens), funções parciais.",
                                "Lógica: Semi-decidibilidade e teoremas de Gödel.",
                                "Programação: Verificação de programas (halting-like problems).",
                                "Filosofia: Limites da computação e saber.",
                                "Engenharia de Software: Análise de complexidade e undecidability."
                              ],
                              "realWorldApplication": "Em compiladores e verificadores de software, problemas como 'este programa para?' são RE, guiando ferramentas que detectam alguns loops mas não todos, impactando análise estática e depuração."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Relacionar RE com TMs aceitadoras",
                            "description": "Explicar a correspondência entre RE e linguagens reconhecidas por TMs, incluindo o conceito de enumeradores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Máquinas de Turing (TMs) e Conceito de Aceitação",
                                  "subSteps": [
                                    "Relembre a definição formal de uma Máquina de Turing: estados, alfabeto, fita, cabeçote, função de transição e estados de aceitação/rejeição.",
                                    "Explique a diferença entre TMs decididoras (que sempre halitam) e TMs aceitadoras (que halitam apenas em aceitação).",
                                    "Descreva o que significa uma TM aceitar uma string: entra em estado de aceitação após processá-la.",
                                    "Estude exemplos simples de TMs aceitadoras para linguagens regulares e context-free.",
                                    "Pratique simulando manualmente uma TM aceitadora em uma string específica."
                                  ],
                                  "verification": "Simule corretamente uma TM aceitadora em pelo menos 3 strings diferentes, mostrando configurações de transição.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Simulador online de TM (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": "Comece com TMs de um fita única para simplicidade; foque em aceitação sem necessidade de rejeição explícita.",
                                  "learningObjective": "Compreender o mecanismo de aceitação de TMs como base para linguagens RE.",
                                  "commonMistakes": [
                                    "Confundir aceitação com decisão (haltação em todos os casos)",
                                    "Ignorar loops infinitos em rejeição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Linguagens Recursivamente Enumeráveis (RE)",
                                  "subSteps": [
                                    "Defina formalmente L(RE) como o conjunto de linguagens aceitas por alguma TM (TM_M aceita w se M halta em estado de aceitação em w).",
                                    "Compare com linguagens recursivas (R): TMs que halitam em todos os inputs, aceitando ou rejeitando.",
                                    "Prove que toda linguagem recursiva é RE (construa TM aceitadora a partir de decididora).",
                                    "Discuta não-RE: linguagens que requerem TMs que divergem em alguns casos.",
                                    "Liste propriedades chave: RE é fechada sob união, concatenação e estrela de Kleene."
                                  ],
                                  "verification": "Escreva definições formais e prove que REC ⊆ RE com uma construção de TM.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Notas de aula sobre hierarquia de Chomsky",
                                    "Papel e lápis para provas formais"
                                  ],
                                  "tips": "Use notação padrão: L(M) = {w | M aceita w}; memorize inclusão estrita REC ⊂ RE.",
                                  "learningObjective": "Estabelecer RE como linguagens de TMs aceitadoras.",
                                  "commonMistakes": [
                                    "Confundir RE com decidíveis",
                                    "Esquecer que RE permite não-haltação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Enumeradores e Equivalência com TMs",
                                  "subSteps": [
                                    "Defina um enumerador E como uma TM que imprime strings de uma linguagem em ordem lexicográfica ou sequencial, sem duplicatas.",
                                    "Prove que toda RE tem um enumerador: simule TM aceitadora em todas strings possíveis em diagonalização.",
                                    "Prove o inverso: dada TM enumeradora, construa TM aceitadora via simulação e busca na saída.",
                                    "Discuta teorema de Rice: propriedades semânticas de RE são indecidíveis.",
                                    "Implemente um enumerador simples para {a^n b^n | n ≥ 0}."
                                  ],
                                  "verification": "Construa e descreva TM enumeradora para uma RE simples e sua TM aceitadora equivalente.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Pseudocódigo para enumeradores",
                                    "Ferramenta de simulação como JFLAP"
                                  ],
                                  "tips": "Para diagonalização, use codificação de strings e dovetailing para simular múltiplas TMs.",
                                  "learningObjective": "Compreender enumeradores como alternativa para caracterizar RE.",
                                  "commonMistakes": [
                                    "Gerar duplicatas na enumeração",
                                    "Não lidar com loops infinitos na prova"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar RE, TMs Aceitadoras e Exemplos Práticos",
                                  "subSteps": [
                                    "Resuma teorema central: L é RE iff existe TM aceitadora para L iff existe enumerador para L.",
                                    "Analise exemplo: halting problem é RE mas não REC; construa TM aceitadora.",
                                    "Compare com linguagens regulares e CFLs: todas são RE.",
                                    "Discuta implicações: undecidibilidade de 'L é RE?' para TMs arbitrárias.",
                                    "Crie diagrama de Venn mostrando RE ⊃ REC ⊃ CFL ⊃ REG."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a equivalência tripla com um exemplo não-trivial.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Diagrama hierarquia de linguagens",
                                    "Exemplos de provas de Sipser Cap. 9"
                                  ],
                                  "tips": "Use halting problem como âncora: TM aceita se simula e halta em aceitação.",
                                  "learningObjective": "Integrar conceitos em uma visão coesa de RE via TMs e enumeradores.",
                                  "commonMistakes": [
                                    "Achar que toda RE é decidível",
                                    "Confundir aceitador com recognizer universal"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a linguagem do halting problem H = {<M,w> | M halta em w}, construa TM_M que, em input <M',w'>, simula M' em w'; se halta em aceitação, aceite. Isso mostra H é RE. Um enumerador lista todos pares <M,w> onde simulação halta, imprimindo-os sequencialmente.",
                              "finalVerifications": [
                                "Defina corretamente RE como linguagens de TMs aceitadoras.",
                                "Construa TM aceitadora a partir de enumerador e vice-versa.",
                                "Prove REC ⊆ RE.",
                                "Identifique halting problem como RE não-recursiva.",
                                "Explique papel dos enumeradores na caracterização de RE.",
                                "Descreva diferenças entre aceitação, decisão e enumeração."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições formais (ex: L(M) para aceitação).",
                                "Corretude das construções de TMs e enumeradores.",
                                "Compreensão de não-haltação e undecidibilidade.",
                                "Uso correto de teoremas (equivalência RE-TM-enum).",
                                "Capacidade de exemplos concretos e contra-exemplos.",
                                "Clareza em provas e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções computáveis.",
                                "Lógica: Provas de indecidibilidade e teorema de Rice.",
                                "Programação: Simulação de TMs em Python ou Java.",
                                "Filosofia: Limites da computação e mente mecânica."
                              ],
                              "realWorldApplication": "Em compiladores e verificadores de software, entender RE ajuda a modelar problemas semi-decidíveis como 'este programa halta?', usado em ferramentas de análise estática e provas de correção parcial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.3",
                            "name": "Exemplificar linguagens RE",
                            "description": "Citar exemplos como o problema da aceitação de TM (A_TM = {<M,w> | M aceita w}), que é RE mas não recursiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Linguagens Recursivas e RE",
                                  "subSteps": [
                                    "Defina linguagem recursiva: aceita/decide por TM que sempre para.",
                                    "Defina linguagem RE: aceita por TM que para se aceita, pode loopar se rejeita.",
                                    "Diferencie: toda recursiva é RE, mas nem toda RE é recursiva.",
                                    "Estude hierarquia: REG ⊂ CSL ⊂ RE ⊂ REC (não exato, mas ideia).",
                                    "Memorize teoremas chave: halting problem não RE-complemento."
                                  ],
                                  "verification": "Escreva definições em papel e compare com fonte confiável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre linguagens formais",
                                    "Livro 'Sipser Introduction to Theory of Computation' capítulo 9"
                                  ],
                                  "tips": "Use mnemônicos: RE = 'pode enumerar', recursiva = 'sempre decide'.",
                                  "learningObjective": "Distinguir precisamente RE de recursivas.",
                                  "commonMistakes": "Confundir RE com decidível; lembrar que RE não requer rejeição explícita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Problema de Aceitação A_TM",
                                  "subSteps": [
                                    "Defina A_TM = {<M,w> | M é TM que aceita string w}",
                                    "Codifique TMs como strings binárias (padrão Universal TM).",
                                    "Exemplo: <M_empty> aceita ε? Sim, se M para aceitando.",
                                    "Discuta encoding: alfabeto Γ={0,1}, estados numerados.",
                                    "Visualize tape com <M,w> como input."
                                  ],
                                  "verification": "Escreva definição formal de A_TM e um exemplo concreto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador de TM online (ex: Turing Machine Simulator)",
                                    "Exemplos de encodings de Sipser"
                                  ],
                                  "tips": "Pense em <M,w> como 'programa + input'.",
                                  "learningObjective": "Representar A_TM formalmente.",
                                  "commonMistakes": "Esquecer que M pode loopar em w não aceito."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que A_TM é RE",
                                  "subSteps": [
                                    "Construa TM U (Universal): simula M em w.",
                                    "U(<M,w>): rode M em w; se M aceita, U aceita.",
                                    "U para se M aceita, loops caso contrário.",
                                    "Mostre L(U) = A_TM, logo RE.",
                                    "Discuta enumeração: dovetailing para listar simulações."
                                  ],
                                  "verification": "Descreva algoritmo de U em pseudocódigo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo de Universal TM de Sipser p. 169",
                                    "Vídeo Khan Academy ou YouTube sobre Universal TM"
                                  ],
                                  "tips": "Universal TM é como interpretador Python.",
                                  "learningObjective": "Construir prova de RE para A_TM.",
                                  "commonMistakes": "Confundir aceitação com halting; U só aceita se para aceitando."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mostrar que A_TM Não é Recursiva",
                                  "subSteps": [
                                    "Assuma H = {<M,w> | M halts em w} recursiva.",
                                    "Reduza H para A_TM: se A_TM decidível, decida H.",
                                    "Construa M_w: em x, simule M em w; se para, loop; senão aceita x.",
                                    "M_w aceita x=0 se M loops em w, senão não.",
                                    "Diagonal: contradiz assumida decidibilidade."
                                  ],
                                  "verification": "Esboce prova por contradição em bullet points.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Prova de Rice's Theorem ou halting problem",
                                    "Notas sobre redução diagonal"
                                  ],
                                  "tips": "Lembre: halting é RE, mas complemento não.",
                                  "learningObjective": "Provar A_TM RE mas não recursiva.",
                                  "commonMistakes": "Confundir A_TM com HALT_TM; HALT é RE, A_TM também mas não DEC."
                                }
                              ],
                              "practicalExample": "Para mostrar RE: TM U(<M,w>) simula M em cópia de w; se M entra em q_accept, U aceita. Exemplo: M que aceita {a^n b^n}, w=aabb; U simula passos até aceita.",
                              "finalVerifications": [
                                "Citar corretamente definição de A_TM.",
                                "Explicar por que U prova RE.",
                                "Descrever redução diagonal para não-recursiva.",
                                "Dar outro exemplo RE (ex: halting).",
                                "Distinguir RE de co-RE."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (100% correto).",
                                "Clareza na prova de RE (passos lógicos).",
                                "Correção na não-recursividade (redução válida).",
                                "Uso de notação formal (<M,w>).",
                                "Originalidade em exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e diagonalização de Cantor.",
                                "Lógica: Proposições indecidíveis de Gödel.",
                                "Filosofia: Limites do conhecimento computacional.",
                                "Programação: Simuladores de VMs como JVM."
                              ],
                              "realWorldApplication": "Verificação de software: testar se programa P aceita input I é RE, usado em tools de análise estática que enumeram caminhos mas não decidem sempre (ex: bounded model checking)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.3",
                        "name": "Diferenças entre REC e RE com exemplos de indecidibilidade",
                        "description": "Hierarquia REC ⊂ RE estrita, com exemplos clássicos de linguagens RE - REC e provas de indecidibilidade via redução.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.3.1",
                            "name": "Comparar REC e RE",
                            "description": "Explicar que toda REC é RE, mas não o inverso, pois REC requer halting total e RE permite loop em rejeições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de REC e RE",
                                  "subSteps": [
                                    "Defina Linguagem Recursiva (REC): conjunto de strings reconhecido por uma Máquina de Turing (MT) que sempre para (halta) em aceitação ou rejeição para qualquer entrada.",
                                    "Defina Linguagem Recursivamente Enumerável (RE): conjunto de strings aceito por uma MT que halta apenas em aceitações, podendo entrar em loop infinito em rejeições.",
                                    "Compare os requisitos de halting: REC exige halting total, RE permite não-halting em não-membros.",
                                    "Estude diagramas de comportamento das MTs para entradas na linguagem e fora dela.",
                                    "Anote as diferenças em uma tabela comparativa."
                                  ],
                                  "verification": "Escreva definições precisas e tabela comparativa sem erros conceituais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre Máquinas de Turing",
                                    "Capítulo relevante de 'Introduction to the Theory of Computation' de Sipser",
                                    "Papel e caneta para tabela"
                                  ],
                                  "tips": [
                                    "Use setas para ilustrar caminhos de halting vs. loop nas MTs.",
                                    "Lembre-se: halting total é a chave para REC."
                                  ],
                                  "learningObjective": "Dominar as definições exatas de REC e RE e suas diferenças em halting.",
                                  "commonMistakes": [
                                    "Confundir RE com decidível (REC).",
                                    "Achar que RE requer halting em rejeições.",
                                    "Ignorar que ambas usam MTs determinísticas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Comportamento de Halting nas MTs",
                                  "subSteps": [
                                    "Para REC: demonstre que para qualquer entrada w, a MT halta em 'aceitar' se w ∈ L, ou 'rejeitar' se w ∉ L.",
                                    "Para RE: mostre que para w ∈ L, halta em 'aceitar'; para w ∉ L, pode loopar indefinidamente.",
                                    "Construa prova informal de que toda REC é RE: dada MT_REC, crie MT_RE que simula e aceita/rejeita igual.",
                                    "Discuta por que o inverso falha: RE pode não fornecer sinal de rejeição.",
                                    "Desenhe fluxogramas para ambos os casos."
                                  ],
                                  "verification": "Crie fluxogramas corretos e explique verbalmente a inclusão REC ⊆ RE.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io ou papel",
                                    "Exemplos de MTs de notas anteriores"
                                  ],
                                  "tips": [
                                    "Pense em RE como 'enumeradores' que listam membros sem verificar não-membros.",
                                    "Simule mentalmente entradas específicas."
                                  ],
                                  "learningObjective": "Compreender mecanicamente por que REC é subconjunto próprio de RE.",
                                  "commonMistakes": [
                                    "Achar que toda RE é REC.",
                                    "Esquecer prova de inclusão via simulação.",
                                    "Confundir MTs não-determinísticas (não aplicável aqui)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Exemplos e Contraexemplos",
                                  "subSteps": [
                                    "Exemplo REC: L = {w | |w| par} – MT conta comprimento e halta sempre.",
                                    "Exemplo RE não REC: Problema da Parada H = {<M,w> | M halta em w} – simulador TM aceita halts, loopa em non-halts.",
                                    "Prove que H é RE: construa MT que simula M em w.",
                                    "Prove que H não é REC: use argumento diagonal de undecidibilidade.",
                                    "Identifique mais um exemplo: Linguagens regulares ou context-free são REC."
                                  ],
                                  "verification": "Liste exemplos corretos e esboce provas breves para cada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de linguagens padrão",
                                    "Simulador de MT online (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": [
                                    "Sempre relacione exemplos à halting behavior.",
                                    "Use diagonal para undecidíveis."
                                  ],
                                  "learningObjective": "Aplicar conceitos com exemplos concretos de hierarquia.",
                                  "commonMistakes": [
                                    "Classificar H como REC.",
                                    "Dar exemplos vagos sem prova.",
                                    "Confundir RE com co-RE."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Comparação e Implicações",
                                  "subSteps": [
                                    "Resuma: REC ⊆ RE, mas RE - REC contém problemas undecidíveis como Halting.",
                                    "Discuta teoremas: REC fechada sob complemento; RE não.",
                                    "Conecte a indecidibilidade: propriedades separando REC de RE.",
                                    "Crie mnemônico: 'REC halta tudo, RE só aceitações'.",
                                    "Resolva 2 exercícios: classifique linguagens dadas como REC ou RE."
                                  ],
                                  "verification": "Responda quiz com 90% acerto sobre diferenças e exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exercícios impressos ou online",
                                    "Resumo pessoal anterior"
                                  ],
                                  "tips": [
                                    "Foquem em closure properties para reforçar.",
                                    "Pratique verbalizando inverso falso."
                                  ],
                                  "learningObjective": "Integrar comparação com implicações teóricas.",
                                  "commonMistakes": [
                                    "Ignorar closure sob complemento.",
                                    "Subestimar tamanho de RE - REC.",
                                    "Confundir com classes P/NP."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere HALT = {<M,w> | MT M halta em entrada w}. É RE: MT simuladora roda M em w; se halta, aceita; senão loopa. Não é REC: se fosse, resolveria Halting Problem decididamente, contradizendo undecidibilidade por diagonal. Em contraste, EVEN = {w | |w| par} é REC: MT conta bits e halta sempre (aceita ou rejeita).",
                              "finalVerifications": [
                                "Explicar corretamente por que toda REC é RE, mas não vice-versa.",
                                "Dar exemplo válido de linguagem RE que não é REC com justificativa.",
                                "Desenhar tabela comparativa de halting behaviors precisa.",
                                "Provar informalmente inclusão REC ⊆ RE via construção de MT.",
                                "Identificar erro em declaração falsa sobre REC/RE.",
                                "Discutir implicação para undecidibilidade do Halting Problem."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual nas definições e halting requirements (30%).",
                                "Qualidade e correção de exemplos/contraexemplos (25%).",
                                "Profundidade na prova de inclusão e diagonal argument (20%).",
                                "Clareza em diagramas/tabelas comparativas (15%).",
                                "Aplicação a novos problemas/exercícios (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos (inclusão estrita REC ⊂ RE).",
                                "Lógica: Proposições undecidíveis e teorema de Rice.",
                                "Programação: Simulação de TMs em Python para RE languages.",
                                "Filosofia: Limites da computação e Gödel incompleteness."
                              ],
                              "realWorldApplication": "Em verificação de software e análise estática, entender REC vs RE delimita problemas decidíveis (ex: type checking, REC) de undecidíveis (ex: 'este programa halta?', RE não REC), guiando ferramentas como linters vs. aproximadores heurísticos em compiladores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.2",
                            "name": "Provar REC ⊂ RE estrita",
                            "description": "Usar o problema da parada (HALT_TM) para mostrar existência de RE não REC via diagonalização ou redução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de REC e RE",
                                  "subSteps": [
                                    "Defina REC como o conjunto de linguagens decidíveis por uma TM que sempre para (aceita ou rejeita).",
                                    "Defina RE como o conjunto de linguagens reconhecidas por uma TM que para e aceita em strings da linguagem, podendo loopar em outras.",
                                    "Explique a relação intuitiva: toda linguagem decidível é semi-decidível, mas nem toda semi-decidível é decidível.",
                                    "Discuta exemplos simples: linguagens regulares estão em REC, mas problemas como HALT_TM estão em RE."
                                  ],
                                  "verification": "Escreva definições formais e dê 2 exemplos para cada classe.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Sipser 'Introduction to the Theory of Computation' (Cap. 4)",
                                    "Notas de aula sobre TMs"
                                  ],
                                  "tips": "Use diagramas de TMs para visualizar aceitação vs. decisão.",
                                  "learningObjective": "Entender precisamente as diferenças entre decidibilidade e reconhecimento.",
                                  "commonMistakes": [
                                    "Confundir 'para sempre' com 'loop infinito' em definições",
                                    "Achar que RE inclui linguagens não-TM"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar que REC ⊆ RE",
                                  "subSteps": [
                                    "Mostre que se L ∈ REC, existe TM M que decide L: para w ∈ L aceita, senão rejeita.",
                                    "Construa TM N para L: simule M em w; se M aceita, N aceita; se rejeita, N loopa (mas como M sempre para, N sempre para se aceita).",
                                    "Argumente formalmente: ∀L ∈ REC, ∃TM N s.t. w ∈ L ⇔ N aceita w (pois M decide).",
                                    "Verifique que N pode loopar? Não, porque M para sempre."
                                  ],
                                  "verification": "Escreva a prova formal com construção de TM N.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para diagramas de TM",
                                    "Ferramenta online como JFLAP para simular TMs"
                                  ],
                                  "tips": "Lembre: inclusão é fácil porque decisão implica reconhecimento.",
                                  "learningObjective": "Dominar prova de inclusão REC em RE.",
                                  "commonMistakes": [
                                    "Esquecer que TM para reconhecimento pode loopar em não-membros",
                                    "Invertir a direção da inclusão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mostrar que HALT_TM ∈ RE",
                                  "subSteps": [
                                    "Defina HALT_TM = { <M> | M é TM que para em ε (input vazio) }.",
                                    "Construa TM H: em input <M>, simule M em ε; se M para (aceita ou rejeita), H aceita.",
                                    "Argumente: se <M> ∈ HALT_TM, simulação para, H aceita; se não, simulação loopa, H loopa (correto para RE).",
                                    "Formalize: H reconhece HALT_TM perfeitamente."
                                  ],
                                  "verification": "Descreva construção de H e prove que reconhece HALT_TM.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplos de encodings de TMs de Sipser"
                                  ],
                                  "tips": "Foco na simulação universal de TM.",
                                  "learningObjective": "Entender como simulação prova reconhecimento.",
                                  "commonMistakes": [
                                    "Confundir HALT_TM com A_TM (aceitação)",
                                    "Achar que H decide, não só reconhece"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar que HALT_TM ∉ REC via Diagonalização",
                                  "subSteps": [
                                    "Suponha por contradição que HALT_TM ∈ REC, decidida por TM D.",
                                    "Construa TM M_D: em ε, compute D(<M_D>); se D aceita, M_D loopa forever; se rejeita, M_D aceita (para).",
                                    "Pergunte: M_D para em ε? Se sim, D(<M_D>) rejeita → M_D aceita (para); se não, D(<M_D>) aceita → M_D loopa (não para). Contradição.",
                                    "Conclua: nenhuma D decide HALT_TM."
                                  ],
                                  "verification": "Escreva prova completa por contradição com M_D.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplos de diagonalização de Sipser Cap. 5"
                                  ],
                                  "tips": "M_D é como máquina diagonal anti-D.",
                                  "learningObjective": "Mestre técnica de diagonalização para indecidibilidade.",
                                  "commonMistakes": [
                                    "Erro no comportamento de M_D: inverter aceita/loopa",
                                    "Esquecer input ε em simulação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir REC ⊂ RE Estrita",
                                  "subSteps": [
                                    "Reúna: REC ⊆ RE de step 2, HALT_TM ∈ RE de step 3, HALT_TM ∉ REC de step 4.",
                                    "Mostre HALT_TM ∈ RE \\ REC, logo REC é subconjunto próprio de RE.",
                                    "Discuta implicações: existem problemas semi-decidíveis mas indecidíveis.",
                                    "Generalize para outras reduções."
                                  ],
                                  "verification": "Escreva teorema final e corolário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Resumo da prova anterior"
                                  ],
                                  "tips": "Use diagrama de Venn para visualizar REC ⊂ RE.",
                                  "learningObjective": "Sintetizar prova completa da inclusão estrita.",
                                  "commonMistakes": [
                                    "Achar prova bidirecional sem contraexemplo",
                                    "Ignorar 'estrita' sem elemento separador"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere TMs simples: M1 para em ε (aceita), <M1> ∈ HALT_TM. Simule: H roda M1, vê para, aceita. Para M2 que loopa em ε, H loopa. Suponha D decide; construa M_D que em ε roda D(<M_D>): se D diz sim (para), M_D loopa; contradiz.",
                              "finalVerifications": [
                                "Pode definir REC e RE corretamente?",
                                "Constrói TM para mostrar REC ⊆ RE?",
                                "Descreve H para HALT_TM ∈ RE?",
                                "Explica diagonalização sem erros?",
                                "Conclui inclusão estrita com HALT_TM como separador?"
                              ],
                              "assessmentCriteria": [
                                "Prova de REC ⊆ RE é formal e correta (30%)",
                                "Construção de H para RE correta (20%)",
                                "Diagonalização sem falhas lógicas (30%)",
                                "Conclusão clara e generalização (10%)",
                                "Clareza e formalidade na escrita (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos (subconjuntos próprios), diagonalização de Cantor.",
                                "Lógica: Argumentos por contradição, reduções.",
                                "Programação: Implicações do halting problem em compiladores e verificadores."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, entender halting problem explica por que detectores de loops infinitos são limitados (ex: analyzers em IDEs como VS Code só aproximam); guia design de algoritmos semi-decidíveis como provers em theorem provers (Coq, Isabelle)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.3",
                            "name": "Analisar exemplos de indecidibilidade",
                            "description": "Discutir HALT_TM e A_TM como RE indecidíveis, e seu complemento não RE, referenciando teoremas de Rice.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Linguagens REC e RE",
                                  "subSteps": [
                                    "Defina linguagens recursivas (REC): decidíveis por TM que sempre para.",
                                    "Defina linguagens recursivamente enumeráveis (RE): aceitas por TM, mas pode loopar em não-aceitação.",
                                    "Compare REC ⊂ RE: todo REC é RE, mas nem todo RE é REC.",
                                    "Discuta simuladores de TM universais para entender aceitação.",
                                    "Exemplifique com linguagens simples como {a^n b^n} (REC) vs. halting problems (RE)."
                                  ],
                                  "verification": "Resuma diferenças entre REC e RE em um diagrama de Venn e liste 2 exemplos de cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Sipser 'Introduction to the Theory of Computation', notas de aula, simulador de TM online (ex: Turing Machine Simulator).",
                                  "tips": "Use diagramas para visualizar hierarquia de linguagens formais.",
                                  "learningObjective": "Compreender a hierarquia REC ⊂ RE e suas implicações para decidibilidade.",
                                  "commonMistakes": "Confundir RE com decidível; lembrar que RE permite loop infinito em rejeição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Problema HALT_TM",
                                  "subSteps": [
                                    "Defina HALT_TM = {<M,w> | TM M parata em input w}.",
                                    "Prove que HALT_TM é RE: constrói TM que simula M em w e aceita se parar.",
                                    "Prove indecidibilidade: assuma decididor H, construa diagonalização para contradizer.",
                                    "Discuta redução de A_TM para HALT_TM via modificação de TM.",
                                    "Simule exemplos simples de TMs que param ou loopam."
                                  ],
                                  "verification": "Escreva prova de que HALT_TM é RE e esboce prova de indecidibilidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e caneta para provas, simulador de TM, capítulos relevantes de Sipser.",
                                  "tips": "Sempre comece provas de RE com 'constrói TM que simula...' para aceitação.",
                                  "learningObjective": "Demonstrar que HALT_TM é RE mas não REC usando provas formais.",
                                  "commonMistakes": "Esquecer que simulador para apenas se M para; ignorar diagonalização na indecidibilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Problema A_TM e Seu Complemento",
                                  "subSteps": [
                                    "Defina A_TM = {<M,w> | TM M aceita w}.",
                                    "Prove A_TM é RE: simula M em w e aceita se aceitar.",
                                    "Prove complemento de A_TM não é RE: redução via HALT_TM.",
                                    "Compare HALT_TM e A_TM: ambos RE, complementos não RE.",
                                    "Construa exemplos concretos de TMs para ilustrar."
                                  ],
                                  "verification": "Forneça prova de que complemento de A_TM não é RE e liste diferenças com HALT_TM.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Simulador de TM, quadro branco para reduções.",
                                  "tips": "Para complementos, pense em casos onde TM loopa vs. rejeita explicitamente.",
                                  "learningObjective": "Entender por que A_TM e HALT_TM têm complementos não RE.",
                                  "commonMistakes": "Confundir aceitação (RE) com parada (HALT); não especificar reduções corretas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Teorema de Rice para Generalização",
                                  "subSteps": [
                                    "Enuncie Teorema de Rice: toda propriedade semântica não-trivial de TMs é indecidível.",
                                    "Classifique HALT_TM e A_TM como propriedades semânticas.",
                                    "Prove Rice para A_TM: reduza de halting problem.",
                                    "Discuta implicações: quase todas propriedades interessantes são indecidíveis.",
                                    "Conecte com exemplos como 'TM parata em input vazio'."
                                  ],
                                  "verification": "Aplique Rice a uma nova propriedade e prove indecidibilidade.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Artigos ou capítulos sobre Rice's Theorem, exemplos de propriedades.",
                                  "tips": "Verifique se propriedade é semântica (depende de L(M)) e não-trivial.",
                                  "learningObjective": "Usar Rice para explicar indecidibilidade ampla de problemas RE.",
                                  "commonMistakes": "Confundir sintáticas (ex: TM tem 5 estados) com semânticas; esquecer não-trivialidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Discutir Implicações",
                                  "subSteps": [
                                    "Resuma: HALT_TM, A_TM RE indecidíveis; complementos não RE.",
                                    "Conecte com hierarquia: REC = RE ∩ co-RE.",
                                    "Discuta limites da computação: sem algoritmo geral para halting.",
                                    "Crie tabela comparativa de propriedades RE/REC.",
                                    "Reflita sobre extensões como oráculos."
                                  ],
                                  "verification": "Crie mapa mental conectando todos conceitos e exemplos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramenta de mind mapping (ex: XMind), resumo anterior.",
                                  "tips": "Use tabelas para comparações claras de decidibilidade.",
                                  "learningObjective": "Integrar conhecimentos para análise completa de indecidibilidade.",
                                  "commonMistakes": "Ignorar co-RE; superestimar decidibilidade de subproblemas."
                                }
                              ],
                              "practicalExample": "Considere TM M1 que loopa em '0' (while true) e M2 que para em '0' (print e halt). Analise se HALT_TM decide <M1,0> (não para) vs. <M2,0> (para), simulando em um TM universal para ver RE mas não REC. Aplique Rice para propriedade 'L(M) contém 0*'.",
                              "finalVerifications": [
                                "Explicar por que HALT_TM é RE mas não REC com prova.",
                                "Provar que complemento de A_TM não é RE via redução.",
                                "Aplicar Rice a pelo menos duas propriedades semânticas.",
                                "Listar diferenças chave entre REC, RE e co-RE com exemplos.",
                                "Simular um caso de halting em ferramenta online.",
                                "Discutir implicações para verificadores de programas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas provas formais (reduções e simulações corretas).",
                                "Compreensão conceitual de RE vs. REC (sem confusões).",
                                "Aplicação correta do Teorema de Rice (semântica e não-trivial).",
                                "Profundidade nos exemplos e simulações práticas.",
                                "Clareza na síntese e conexões entre conceitos.",
                                "Identificação de erros comuns e dicas preventivas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e cardinalidade em hierarquias de linguagens.",
                                "Filosofia: Limites do conhecimento computacional (Gödel, Turing).",
                                "Lógica: Provas por contradição e diagonalização.",
                                "Engenharia de Software: Implicações em análise estática e detecção de bugs."
                              ],
                              "realWorldApplication": "Em verificação de software, halting problem impede analisadores estáticos perfeitos para loops infinitos; antivírus usam aproximações RE para detectar malware que 'para' em certas entradas, mas falham em casos indecidíveis; otimização de compiladores respeita Rice ao evitar análises semânticas gerais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.5",
                    "name": "Classe NP e Problemas NP-Completos",
                    "description": "Definição da classe NP, problemas completos e caracterização de problemas intratáveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.5.1",
                        "name": "Classe NP",
                        "description": "Definição formal da classe NP como o conjunto de problemas de decisão cujas instâncias podem ser verificadas por um verificador determinístico em tempo polinomial, incluindo relação com a classe P e exemplos clássicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.1.1",
                            "name": "Definir a classe NP",
                            "description": "Explicar que a classe NP consiste em linguagens reconhecíveis por uma máquina de Turing não-determinística em tempo polinomial, ou equivalentemente, problemas de decisão com certificados verificáveis em tempo polinomial por uma máquina determinística.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Máquinas de Turing e Complexidade Polinomial",
                                  "subSteps": [
                                    "Relembre a definição formal de uma Máquina de Turing (MT) determinística: conjunto de estados, alfabeto, função de transição, etc.",
                                    "Entenda o conceito de tempo de execução de uma MT: número de passos até halting.",
                                    "Defina tempo polinomial: função O(n^k) para k constante, onde n é o tamanho da entrada.",
                                    "Diferencie classes P (MT determinística em tempo polinomial) e prepare para extensão a não-determinismo.",
                                    "Estude exemplos simples de linguagens em P, como paridade de bits."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre tempo polinomial e exponencial, com um exemplo de linguagem em P.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de teoria da computação (Sipser ou similar), notas de aula sobre MT, simulador online de MT.",
                                  "tips": "Use diagramas para visualizar transições de MT; foque em exemplos concretos para fixar.",
                                  "learningObjective": "Compreender os pré-requisitos para definir NP, incluindo MT e polinomialidade.",
                                  "commonMistakes": "Confundir tempo polinomial com linear; ignorar que n é tamanho da entrada, não comprimento da fita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Máquinas de Turing Não-Determinísticas (MTND)",
                                  "subSteps": [
                                    "Defina MTND: similar à MT, mas função de transição pode mapear para múltiplos estados (ramificações).",
                                    "Explique aceitação: existe pelo menos um caminho de computação que aceita a entrada.",
                                    "Defina tempo de execução de MTND: comprimento máximo de qualquer caminho de computação.",
                                    "Compare com MT determinística: MTND pode 'adivinhar' soluções.",
                                    "Simule uma MTND simples para linguagem de strings com número par de 1s."
                                  ],
                                  "verification": "Construa e simule manualmente uma MTND para um problema simples, mostrando ramificações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulador de MTND online (ex: Turing Machine Simulator), papel e lápis para desenhos.",
                                  "tips": "Pense na MTND como um 'árvore de possibilidades'; desenhe árvores de computação.",
                                  "learningObjective": "Dominar o modelo não-determinístico como base para NP.",
                                  "commonMistakes": "Confundir aceitação (existe caminho) com todos os caminhos; ignorar tempo máximo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente a Classe NP via MTND",
                                  "subSteps": [
                                    "Defina NP: conjunto de linguagens L onde existe MTND M tal que para x em L, M aceita x em tempo polinomial, e rejeita x não em L.",
                                    "Escreva a definição matemática: L ∈ NP iff ∃ MTND M, ∀x ∈ L, |x| ≥ n ⇒ M aceita x em O(n^k) passos.",
                                    "Discuta closure sob união, concatenação e estrela (propriedades de NP).",
                                    "Compare NP com P: P ⊆ NP.",
                                    "Exemplo: SUBSET-SUM como linguagem em NP."
                                  ],
                                  "verification": "Escreva a definição formal de NP e prove que uma linguagem específica (ex: PARITY) está em NP.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Referência formal (Sipser Capítulo 7), quadro branco ou software de desenho.",
                                  "tips": "Memorize a definição exata; use 'existe MTND' como mantra.",
                                  "learningObjective": "Aplicar definição via MTND para classificar linguagens em NP.",
                                  "commonMistakes": "Omitir 'tempo polinomial' ou confundir com tempo determinístico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Equivalência via Verificador Determinístico e Certificados",
                                  "subSteps": [
                                    "Defina verificador: MT determinística V que, dado (x, c) onde c é certificado de tamanho polinomial, aceita se c é válido para x.",
                                    "Mostre NP = linguagens com verificadores polinomiais.",
                                    "Prove sketch da equivalência: MTND simula adivinhação via certificado.",
                                    "Exemplo: Certificado para 3-COLORING é coloração válida.",
                                    "Discuta tamanho do certificado: |c| ≤ poly(|x|)."
                                  ],
                                  "verification": "Para um problema NP, descreva um verificador determinístico e um certificado exemplo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Exemplos de problemas NP (SAT, Clique), calculadora para tamanhos polinomiais.",
                                  "tips": "Sempre pergunte: 'Como verificar sem resolver?' para intuitar certificados.",
                                  "learningObjective": "Entender e provar a dupla definição de NP.",
                                  "commonMistakes": "Achar que verificador resolve o problema (não, só verifica); ignorar polinomialidade do certificado."
                                }
                              ],
                              "practicalExample": "Para o problema CLIQUE: Dada uma grafo G e k, certificado c é o conjunto de k vértices. Verificador determinístico checa em tempo O(k^2) se todos estão conectados, polinomial em n.",
                              "finalVerifications": [
                                "Explique as duas definições equivalentes de NP sem hesitação.",
                                "Classifique corretamente 3 linguagens como em NP ou não.",
                                "Descreva um certificado e verificador para um problema clássico como SAT.",
                                "Prove intuitivamente P ⊆ NP.",
                                "Diferencie NP de co-NP com exemplo.",
                                "Simule uma MTND simples aceitando/rejeitando entradas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (MTND e verificador).",
                                "Compreensão da equivalência entre modelos.",
                                "Capacidade de gerar exemplos e contraexemplos.",
                                "Uso correto de notação assintótica (O(n^k)).",
                                "Identificação de erros comuns em definições.",
                                "Aplicação a problemas reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e lógica proposicional (fórmulas SAT).",
                                "Física: Modelos probabilísticos e simulações quânticas (BQP vs NP).",
                                "Economia: Otimização combinatória em teoria dos jogos.",
                                "Filosofia: Limites da computabilidade e decidibilidade."
                              ],
                              "realWorldApplication": "Em criptografia, problemas NP como fatoração subjacentes ao RSA (difícil sem certificado, fácil verificar); em logística, scheduling de jobs com certificados para soluções ótimas aproximadas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.2",
                            "name": "Identificar exemplos de problemas em NP",
                            "description": "Listar e descrever problemas clássicos em NP, como o Problema da Satisfatibilidade Booleana (SAT), o Problema do Caixeiro Viajante (TSP) em sua versão de decisão e o Problema do Clique Máximo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal da classe NP",
                                  "subSteps": [
                                    "Leia a definição de NP: problemas cujas soluções podem ser verificadas em tempo polinomial por uma máquina de Turing não-determinística.",
                                    "Entenda a diferença entre P e NP: P é decidível em tempo polinomial determinístico.",
                                    "Estude exemplos iniciais de problemas em P para contrastar (ex: ordenação).",
                                    "Identifique as duas versões de problemas: otimização vs. decisão.",
                                    "Anote as propriedades chave: verificação polinomial."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando NP e liste 2 diferenças de P.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Notas de aula sobre complexidade",
                                    "Vídeo introdutório sobre P vs NP (Khan Academy)"
                                  ],
                                  "tips": "Use diagramas de máquina de Turing para visualizar não-determinismo.",
                                  "learningObjective": "Compreender os critérios fundamentais para classificar um problema como NP.",
                                  "commonMistakes": [
                                    "Confundir NP com NP-completo",
                                    "Ignorar a distinção entre busca e decisão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Problema da Satisfatibilidade Booleana (SAT)",
                                  "subSteps": [
                                    "Defina SAT: dada uma fórmula em forma normal conjuntiva (CNF), existe uma atribuição de variáveis que a torna verdadeira?",
                                    "Aprenda a representação em CNF e exemplos simples (ex: (x1 ∨ ¬x2) ∧ (¬x1 ∨ x2)).",
                                    "Explique por que SAT está em NP: dado uma atribuição, verifique em tempo linear.",
                                    "Resolva um exemplo pequeno manualmente.",
                                    "Pesquise histórico: primeiro problema provado NP-completo por Cook."
                                  ],
                                  "verification": "Resolva um SAT com 3 variáveis e verifique a solução.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online SAT solver (ex: SAT4J demo)",
                                    "Exercícios de lógica booleana",
                                    "Artigo de Cook-Levin theorem (resumo)"
                                  ],
                                  "tips": "Comece com fórmulas de 2 variáveis para praticar.",
                                  "learningObjective": "Reconhecer SAT como exemplo clássico em NP e sua verificação polinomial.",
                                  "commonMistakes": [
                                    "Confundir SAT com tautologia",
                                    "Esquecer conversão para CNF"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Problema do Caixeiro Viajante (TSP) na versão de decisão",
                                  "subSteps": [
                                    "Defina TSP-decisão: dado grafo completo com pesos e k, existe ciclo hamiltoniano de custo ≤ k?",
                                    "Diferencie de TSP-otimização: foco em 'sim/não' para NP.",
                                    "Desenhe um grafo pequeno (4 nós) e verifique um tour candidato.",
                                    "Explique verificador polinomial: some pesos do tour proposto.",
                                    "Compare com Hamiltoniano Path."
                                  ],
                                  "verification": "Crie um grafo de 5 nós e liste um tour válido ou prove inexistência para k dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de grafos (Graphviz ou yEd)",
                                    "Exemplos de TSP em Wikipedia",
                                    "Papel e lápis para desenhar"
                                  ],
                                  "tips": "Use matriz de adjacência para representar pesos.",
                                  "learningObjective": "Identificar TSP-decisão como problema em NP via redução de grafos.",
                                  "commonMistakes": [
                                    "Usar versão otimização em vez de decisão",
                                    "Ignorar completude do grafo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o Problema do Clique Máximo",
                                  "subSteps": [
                                    "Defina Clique: subgrafo completo onde todos os vértices são adjacentes.",
                                    "Clique Máximo decisão: existe clique de tamanho ≥ k em grafo G?",
                                    "Verifique por que em NP: dado subconjunto de vértices, cheque todas as arestas em O(n^2).",
                                    "Resolva exemplo: grafo com 6 vértices.",
                                    "Conecte com outros: relação com coloração de grafos."
                                  ],
                                  "verification": "Encontre o clique máximo em um grafo pequeno e justifique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de grafos online (ex: Gephi demo)",
                                    "Lista de problemas NP em teoria da computação"
                                  ],
                                  "tips": "Procure cliques triangulares primeiro.",
                                  "learningObjective": "Classificar Clique Máximo como NP e entender sua verificação.",
                                  "commonMistakes": [
                                    "Confundir com cobertura de vértices",
                                    "Esquecer verificação de todas as arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Identificar padrões comuns e sintetizar exemplos",
                                  "subSteps": [
                                    "Liste SAT, TSP-decisão, Clique Máximo e compare estruturas.",
                                    "Identifique traços NP: decisão, verificação polinomial.",
                                    "Pesquise 2 outros exemplos (ex: Subset Sum, Vertex Cover).",
                                    "Crie tabela comparativa: problema, entrada, verificador.",
                                    "Discuta por que esses são 'clássicos'."
                                  ],
                                  "verification": "Produza uma tabela com 4 problemas em NP e suas verificações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha (Google Sheets)",
                                    "Referência: 'Computers and Intractability' de Garey & Johnson (capítulos iniciais)"
                                  ],
                                  "tips": "Use colunas: Nome, Descrição, Verificador Tempo.",
                                  "learningObjective": "Sintetizar conhecimento para reconhecer novos problemas em NP.",
                                  "commonMistakes": [
                                    "Listar problemas em P como exemplos",
                                    "Omitir justificativa de NP"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado um grafo de cidades com distâncias, determine se existe um tour visitando todas com custo total ≤ 1000 (TSP-decisão). Verifique propondo um tour e somando distâncias em tempo polinomial.",
                              "finalVerifications": [
                                "Liste corretamente 3 problemas clássicos em NP com descrições breves.",
                                "Explique o verificador polinomial para cada um.",
                                "Diferencie versões de decisão de otimização.",
                                "Identifique por que não estão em P (assumindo P≠NP).",
                                "Crie um exemplo original de problema em NP similar.",
                                "Resolva um SAT pequeno manualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos (90% correto).",
                                "Compreensão de verificação polinomial demonstrada.",
                                "Uso correto de terminologia (NP, decisão, CNF, etc.).",
                                "Capacidade de sintetizar padrões comuns.",
                                "Criatividade em exemplos práticos.",
                                "Ausência de confusões com NP-completo ou P."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (TSP, Clique).",
                                "Lógica: Proposicional e CNF (SAT).",
                                "Filosofia: Limites do conhecimento computacional.",
                                "Engenharia de Software: Análise de complexidade em algoritmos.",
                                "Inteligência Artificial: Otimização em busca heurística."
                              ],
                              "realWorldApplication": "Em logística, TSP-decisão ajuda a verificar rotas viáveis eficientes; SAT em verificação de hardware e software (testes lógicos); Clique em redes sociais para detectar grupos densos ou bioinformática para clusters genéticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.5.1.3",
                            "name": "Comparar NP com a classe P",
                            "description": "Discutir a inclusão P ⊆ NP, a hipótese P ≠ NP e implicações para a resolvibilidade eficiente de problemas em NP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições das Classes P e NP",
                                  "subSteps": [
                                    "Defina a classe P como o conjunto de problemas de decisão resolvíveis em tempo polinomial por uma máquina de Turing determinística.",
                                    "Defina a classe NP como o conjunto de problemas de decisão cujas soluções podem ser verificadas em tempo polinomial por uma máquina de Turing determinística.",
                                    "Compare as máquinas de Turing: determinística para P vs. não-determinística para NP.",
                                    "Liste exemplos clássicos: P (ordenação rápida), NP (Satisfatibilidade Booleana - SAT).",
                                    "Discuta a noção de 'certificado' em NP."
                                  ],
                                  "verification": "Escreva definições precisas e exemplos sem erros conceituais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser), notas de aula, whiteboard.",
                                  "tips": "Use diagramas de Venn para visualizar P e NP.",
                                  "learningObjective": "Compreender as definições fundamentais de P e NP.",
                                  "commonMistakes": "Confundir verificação com resolução; achar que NP é só 'difícil'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar a Inclusão P ⊆ NP",
                                  "subSteps": [
                                    "Explique por que todo problema em P é também em NP: uma solução trivial serve como certificado.",
                                    "Formalize: Se M decide L em tempo polinomial determinístico, então M não-determinístico aceita L com certificado vazio.",
                                    "Prove com um exemplo: Problema de ordenação (P) pode ser 'verificado' instantaneamente.",
                                    "Discuta reduções e por que isso é trivial.",
                                    "Desenhe o diagrama P ⊆ NP."
                                  ],
                                  "verification": "Construa uma prova curta e correta da inclusão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta para provas, simulador de MT online.",
                                  "tips": "Pense em 'NP é pelo menos tão fácil quanto P para verificação'.",
                                  "learningObjective": "Provar matematicamente que P está contido em NP.",
                                  "commonMistakes": "Invertir a inclusão ou ignorar o aspecto não-determinístico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Hipótese P ≠ NP",
                                  "subSteps": [
                                    "Defina a hipótese P ≠ NP como a crença de que P é estritamente menor que NP.",
                                    "Revise evidências: Milhões de dólares em prêmios, falhas em provas de igualdade.",
                                    "Discuta problemas NP-completos (ex: SAT) e o teorema de Cook-Levin.",
                                    "Aborde tentativas de prova e por que é um dos Problemas do Milênio.",
                                    "Debata implicações se P=NP fosse provado."
                                  ],
                                  "verification": "Resuma evidências e status atual da hipótese.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Clay Mathematics Institute site, artigos de Scott Aaronson.",
                                  "tips": "Leia resumos acessíveis antes de mergulhar em papers.",
                                  "learningObjective": "Entender o status aberto e motivações da hipótese.",
                                  "commonMistakes": "Achar que P=NP é provado ou trivial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implicações para Problemas em NP",
                                  "subSteps": [
                                    "Explique que se P=NP, todos NP são eficientemente resolvíveis.",
                                    "Discuta impactos: Otimização (Caixeiro Viajante), criptografia quebra.",
                                    "Se P≠NP, problemas NP-completos são 'intratáveis' eficientemente.",
                                    "Compare com problemas em P: sempre eficientes.",
                                    "Crie tabela comparativa: Tempo, Exemplos, Implicações."
                                  ],
                                  "verification": "Elabore um ensaio curto sobre implicações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela em Excel ou papel, exemplos reais de problemas.",
                                  "tips": "Ligue a problemas cotidianos para fixar.",
                                  "learningObjective": "Discutir consequências práticas da relação P-NP.",
                                  "commonMistakes": "Superestimar soluções heurísticas como prova de P≠NP."
                                }
                              ],
                              "practicalExample": "Compare o problema de 'Verificar se um grafo tem ciclo Hamiltoniano' (NP) com 'Verificar conectividade de grafo' (P): No P, resolve diretamente em O(V+E); no NP, verifica um caminho proposto em polinomial, mas resolução é dura.",
                              "finalVerifications": [
                                "Explicar corretamente P ⊆ NP com prova.",
                                "Descrever hipótese P ≠ NP e seu status.",
                                "Listar 3 implicações se P=NP.",
                                "Diferenciar 2 problemas P de 2 NP.",
                                "Desenhar diagrama de Venn preciso.",
                                "Debater uma implicação em otimização."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (90% correto).",
                                "Profundidade na prova de inclusão.",
                                "Compreensão de evidências para P≠NP.",
                                "Clareza nas implicações práticas.",
                                "Uso correto de terminologia técnica.",
                                "Criatividade em exemplos e conexões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Complexidade e Reduções.",
                                "Criptografia: Segurança baseada em NP-difíceis.",
                                "Otimização: Algoritmos em Logística e IA.",
                                "Filosofia: Limites do Conhecimento Computacional."
                              ],
                              "realWorldApplication": "Em criptografia, RSA assume P≠NP (fatoração é NP-intermediário); se P=NP, toda cripto assimétrica quebra, impactando bancos e segurança online."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.2",
                        "name": "Problemas NP-Completos",
                        "description": "Conceito de completude em NP via reduções polinomiais, incluindo problemas NP-difíceis e o teorema de Cook-Levin.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.2.1",
                            "name": "Definir problemas NP-completos",
                            "description": "Explicar que um problema é NP-completo se pertence a NP e todo problema em NP pode ser reduzido a ele em tempo polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição da classe NP",
                                  "subSteps": [
                                    "Estude a definição formal: um problema de decisão está em NP se existe uma máquina de Turing não-determinística que decide em tempo polinomial ou, equivalentemente, se uma solução pode ser verificada em tempo polinomial por uma máquina determinística.",
                                    "Diferencie NP de P: P é decidível em tempo polinomial determinístico, NP permite não-determinismo na decisão mas verificação determinística polinomial.",
                                    "Liste exemplos clássicos de problemas em NP, como SAT (Satisfatibilidade Booleana) e TSP (Problema do Caixeiro Viajante) na versão de decisão.",
                                    "Pratique identificando por que um problema está em NP focando na verificação polinomial de uma solução proposta.",
                                    "Resuma em suas palavras: 'NP = problemas onde soluções ruins são fáceis de checar'."
                                  ],
                                  "verification": "Escreva um parágrafo explicando NP e dê um exemplo com verificação polinomial explícita.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 7)",
                                    "Wikipedia: NP (complexity)",
                                    "Vídeo Khan Academy sobre Classes de Complexidade"
                                  ],
                                  "tips": "Use diagramas de máquina de Turing para visualizar não-determinismo.",
                                  "learningObjective": "Compreender precisamente o que significa um problema pertencer à classe NP.",
                                  "commonMistakes": "Confundir decisão com otimização; lembrar que NP é para problemas de decisão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender reduções polinomiais",
                                  "subSteps": [
                                    "Defina redução polinomial: dado problemas A e B, A reduz a B (A ≤_p B) se existe uma função computável em tempo polinomial f tal que x ∈ A iff f(x) ∈ B.",
                                    "Aprenda a construir uma redução: transforme instância de A em instância de B preservando a resposta.",
                                    "Estude exemplos: 3-SAT ≤_p Clique, onde cláusulas são mapeadas para grafos.",
                                    "Pratique com exercícios simples: reduza 'Paridade de bits' para si mesmo trivialmente.",
                                    "Verifique propriedades: reduções preservam complexidade (se B em P, A em P)."
                                  ],
                                  "verification": "Construa uma redução polinomial de um problema conhecido para outro e prove correção.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Sipser Capítulo 7.5",
                                    "GeeksforGeeks: Polynomial Time Reductions",
                                    "Exercícios de Arora & Barak 'Computational Complexity'"
                                  ],
                                  "tips": "Sempre prove duas direções: sim para sim, não para não.",
                                  "learningObjective": "Dominar o conceito e construção de reduções polinomiais entre problemas.",
                                  "commonMistakes": "Esquecer de provar que a função f é polinomial ou bidirecional na preservação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e entender NP-hard",
                                  "subSteps": [
                                    "Defina NP-hard: um problema H é NP-hard se todo problema em NP reduz a H em tempo polinomial.",
                                    "Note que NP-hard não requer H estar em NP; pode ser fora de NP.",
                                    "Entenda implicações: se um NP-hard estiver em P, então P=NP.",
                                    "Exemplo: Halting Problem é NP-hard mas não em NP.",
                                    "Construa entendimento: NP-hard captura 'pelo menos tão difícil quanto NP'."
                                  ],
                                  "verification": "Explique por que SAT é NP-hard citando a redução de todo NP para SAT via Cook-Levin.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Sipser Seção 7.6",
                                    "CLRS 'Introduction to Algorithms' Capítulo 34",
                                    "Notas de aula MIT 6.045"
                                  ],
                                  "tips": "Lembre: NP-hard é 'universalmente difícil' para NP.",
                                  "learningObjective": "Diferenciar NP-hard de NP e listar suas propriedades chave.",
                                  "commonMistakes": "Achar que todo NP-hard está em NP; não necessariamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir problemas NP-completos",
                                  "subSteps": [
                                    "Combine definições: problema C é NP-completo se C ∈ NP e C é NP-hard.",
                                    "Consequência: todo NP-completo é equivalentemente difícil; reduções transitivas.",
                                    "Liste teorema de Cook-Levin: SAT é o primeiro NP-completo.",
                                    "Pratique: prove que Clique é NP-completo reduzindo 3-SAT para Clique.",
                                    "Resuma definição completa: 'NP-completo = em NP + todo NP ≤_p ele'."
                                  ],
                                  "verification": "Escreva a definição formal e prove Clique NP-completo em esboço.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Sipser Capítulo 9",
                                    "Papel 'The Boolean Satisfiability Problem' de Cook",
                                    "NP-Completeness Playground online"
                                  ],
                                  "tips": "Use reduções em cadeia: NP → SAT → outros.",
                                  "learningObjective": "Formular a definição exata de NP-completo e suas implicações.",
                                  "commonMistakes": "Omitir 'em NP'; isso diferencia de NP-hard."
                                }
                              ],
                              "practicalExample": "Para provar que o problema Clique é NP-completo: 1) Verificação polinomial: dado grafo G e k, cheque se subgrafo de k vértices é completo em O(k^2). 2) Reduza 3-SAT: para fórmula φ com v variáveis e c cláusulas, crie grafo com  v*c vértices (um por literal por cláusula), arestas se compatíveis e satisfazem cláusula. Clique de tamanho v*c iff φ satisfatível.",
                              "finalVerifications": [
                                "Explique verbalmente a definição de NP-completo para um par.",
                                "Identifique se um problema dado é NP-completo justificando os dois critérios.",
                                "Construa uma redução simples entre dois problemas NP.",
                                "Diferencie NP-completo, NP-hard e NP com exemplos.",
                                "Resolva um quiz com 5 afirmações verdadeiras/falsas sobre NP-completude.",
                                "Prove sucintamente por que SAT é NP-completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: inclui ambos critérios (em NP e NP-hard)?",
                                "Compreensão de reduções: pode explicar e construir uma corretamente?",
                                "Uso de exemplos: aplica a problemas reais como SAT ou Clique?",
                                "Diferenciação conceitual: distingue NP, NP-hard, NP-completo?",
                                "Implicações: entende P=NP colapso?",
                                "Profundidade: menciona teoremas como Cook-Levin?"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (problemas como Clique, Vertex Cover)",
                                "Lógica: Teoria da Prova e Satisfatibilidade (Cook-Levin)",
                                "Filosofia: Decidibilidade e Limites da Computação (Gödel, Turing)",
                                "Economia: Otimização Combinatória em Alocação de Recursos"
                              ],
                              "realWorldApplication": "Em otimização logística (ex: roteirização de veículos como TSP NP-completo), criptografia (fatores primos relacionados a classes de complexidade), e IA (busca em espaços de planejamento onde reduções mostram intratabilidade aproximada)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.5.2.2",
                            "name": "Entender reduções polinomiais",
                            "description": "Descrever reduções de Karp (muitas-uma) e Cook (Turing) entre problemas em NP, com exemplos de como reduzir SAT a 3-SAT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Reduções Polinomiais",
                                  "subSteps": [
                                    "Defina redução polinomial como uma transformação de uma instância de problema A para B em tempo polinomial, preservando a resposta (sim/não).",
                                    "Explique por que reduções são usadas para mostrar dureza computacional em NP.",
                                    "Diferencie reduções em problemas de decisão versus otimização.",
                                    "Revise pré-requisitos: classes P, NP e problemas NP-completos.",
                                    "Estude a importância das reduções para provar NP-completude via SAT."
                                  ],
                                  "verification": "Escreva uma definição precisa de redução polinomial e dê um exemplo simples de redução trivial (ex: de um problema para si mesmo).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 7)",
                                    "Vídeo Khan Academy sobre NP-completude",
                                    "Notas de aula sobre classes de complexidade"
                                  ],
                                  "tips": "Comece com analogias cotidianas, como 'reduzir' cozinhar arroz para cozinhar feijão compartilhando passos semelhantes.",
                                  "learningObjective": "Dominar a definição formal e o propósito das reduções polinomiais em teoria da computação.",
                                  "commonMistakes": [
                                    "Confundir redução polinomial com transformação exponencial.",
                                    "Ignorar a preservação da resposta (sim para sim, não para não).",
                                    "Esquecer que o tempo deve ser polinomial no tamanho da entrada."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Reduções de Karp (Many-One)",
                                  "subSteps": [
                                    "Defina redução de Karp como uma função computável em tempo polinomial f: Σ* → Σ* tal que x ∈ A iff f(x) ∈ B.",
                                    "Analise propriedades: total, preservação de sim/não, e composição de reduções.",
                                    "Compare com reduções não-polinomiais.",
                                    "Resolva exercícios simples de many-one reductions entre problemas em P.",
                                    "Discuta por que Karp é preferida para NP-completude."
                                  ],
                                  "verification": "Construa uma redução de Karp de 'Paridade de bits' para 'Soma par' e prove correção.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Arora & Barak 'Computational Complexity' (Seção 2.3)",
                                    "Lecture notes de Arora sobre Reductions",
                                    "Python para simular reduções simples"
                                  ],
                                  "tips": "Pense em Karp como 'tradução direta': uma entrada vira exatamente uma saída sem branches.",
                                  "learningObjective": "Entender e aplicar reduções many-one para relacionar problemas NP.",
                                  "commonMistakes": [
                                    "Confundir com oráculos (isso é Cook).",
                                    "Não provar que f é polinomial.",
                                    "Esquecer de mostrar ambas as direções: x sim → f(x) sim e x não → f(x) não."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Reduções de Cook (Turing Reductions)",
                                  "subSteps": [
                                    "Defina redução de Cook como uma máquina de Turing M que decide A usando um oráculo para B em tempo polinomial.",
                                    "Entenda a notação A ≤_T B (Turing-reduzível).",
                                    "Compare com Karp: Cook permite múltiplas queries ao oráculo.",
                                    "Estude teorema de Cook-Levin (SAT é NP-completo via Turing reductions).",
                                    "Pratique convertendo uma Karp em Turing e vice-versa."
                                  ],
                                  "verification": "Descreva como uma máquina Turing usa oráculo para 3-SAT para decidir SAT.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Sipser Livro (Capítulo 7.4)",
                                    "Vídeos MIT OCW 18.404 sobre Reductions",
                                    "Simulador de Turing online"
                                  ],
                                  "tips": "Visualize Cook como 'perguntar várias vezes' ao problema B, como consultar um expert repetidamente.",
                                  "learningObjective": "Diferenciar e usar reduções Turing para complexidade mais geral.",
                                  "commonMistakes": [
                                    "Achar que Cook é mais fraca que Karp (na verdade, Karp ≤ Cook).",
                                    "Não limitar queries a tempo polinomial.",
                                    "Confundir com reduções de busca."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Exemplo: Redução de SAT para 3-SAT",
                                  "subSteps": [
                                    "Lembre fórmula SAT: conjunção de cláusulas com literais arbitrários.",
                                    "Descreva construção polinomial: para cláusula (l1 ∨ l2 ∨ ... ∨ lk), k>3, introduza variáveis auxiliares.",
                                    "Exemplo: (a∨b∨c∨d) → (a∨b∨x) ∧ (¬x∨c∨d), onde x novo.",
                                    "Prove preservação: SAT satisfazível iff 3-SAT satisfazível.",
                                    "Implemente em pseudocódigo e teste com instância pequena."
                                  ],
                                  "verification": "Reduza uma fórmula SAT com cláusula de 4 literais para 3-SAT e verifique satisfatibilidade manualmente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para fórmulas",
                                    "Solver SAT online como minisat",
                                    "Exercícios de Garey & Johnson 'Computers and Intractability'"
                                  ],
                                  "tips": "Use tabela verdade para variáveis auxiliares para entender por que funciona.",
                                  "learningObjective": "Construir e verificar uma redução clássica NP-completa.",
                                  "commonMistakes": [
                                    "Introduzir variáveis que alteram independência.",
                                    "Não generalizar para qualquer k>3.",
                                    "Erros na negação de literais auxiliares."
                                  ]
                                }
                              ],
                              "practicalExample": "Dada fórmula SAT φ = (x1 ∨ ¬x2 ∨ x3 ∨ x4) ∧ (¬x1 ∨ x2), reduza para 3-SAT: Para primeira cláusula, introduza y: (x1 ∨ ¬x2 ∨ y) ∧ (¬y ∨ x3 ∨ x4). φ satisfazível iff nova fórmula é.",
                              "finalVerifications": [
                                "Explique diferença entre Karp e Cook com diagrama.",
                                "Prove que SAT ≤_p 3-SAT via construção explícita.",
                                "Dê exemplo onde Karp não existe mas Cook sim.",
                                "Liste 3 problemas NP-completos reduzidos via Karp.",
                                "Simule redução em código para instância pequena.",
                                "Discuta se P=NP implicaria fim das reduções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de reduções (formalismo correto).",
                                "Correção na prova de preservação sim/não.",
                                "Tempo polinomial na construção demonstrado.",
                                "Exemplo concreto com verificação manual.",
                                "Diferenciação clara Karp vs Cook.",
                                "Aplicação criativa a novo problema."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e tautologias.",
                                "Algoritmos: Heurísticas para SAT-solvers (ex: DPLL).",
                                "Criptografia: Reduções em provas de segurança.",
                                "Inteligência Artificial: Planejamento como redução de SAT."
                              ],
                              "realWorldApplication": "Em otimização combinatória, como roteamento de circuitos VLSI ou escalonamento de tarefas, onde provar NP-completude guia o uso de solvers SAT aproximados ou exatos em ferramentas como Z3 ou Google OR-Tools."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.5.2.3",
                            "name": "Aplicar o Teorema de Cook-Levin",
                            "description": "Demonstrar que SAT é NP-completo via redução de qualquer linguagem em NP para SAT, usando máquinas de Turing como certificados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Definições Fundamentais de NP e Verificadores",
                                  "subSteps": [
                                    "Defina formalmente a classe NP usando máquinas de Turing determinísticas como verificadores.",
                                    "Explique o conceito de certificado e como um verificador V(x, c) aceita se c é um certificado válido para x em L.",
                                    "Discuta as restrições: tempo polinomial em |x| + |c|, e |c| polinomial em |x|.",
                                    "Revise notação: <V, 1^n> onde n = |x|, representando o verificador com entrada de tamanho n.",
                                    "Identifique por que SAT é candidato a NP-completo."
                                  ],
                                  "verification": "Escreva definições precisas e dê um exemplo de L em NP com seu verificador.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Sipser Introduction to Theory of Computation' Capítulo 7",
                                    "Notas de aula sobre complexidade",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Use diagramas de TM para visualizar o verificador.",
                                    "Lembre-se: NP é sobre verificação rápida, não decisão rápida."
                                  ],
                                  "learningObjective": "Dominar as bases conceituais para a redução.",
                                  "commonMistakes": [
                                    "Confundir NP com P.",
                                    "Ignorar o tamanho polinomial do certificado.",
                                    "Esquecer que o verificador é determinístico."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Estrutura Geral da Redução Cook-Levin",
                                  "subSteps": [
                                    "Entenda que para qualquer L em NP com verificador V, construímos φ_{V,x} tal que φ é satisfatível iff x em L.",
                                    "Revise os componentes da fórmula SAT: encoding da configuração da fita da TM em tempo polinomial.",
                                    "Aprenda sobre cláusulas para transição de configurações: posição do cabeçote, estado, símbolo na fita.",
                                    "Discuta cláusulas de inicialização, aceitação e rejeição.",
                                    "Esboce o esqueleto da fórmula: ∧ de cláusulas para cada timestep t = 1 a p(n)."
                                  ],
                                  "verification": "Desenhe um fluxograma da redução mostrando entrada (V,x) -> φ.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigo original de Cook 1971 (resumo)",
                                    "Vídeo MIT OCW sobre NP-completude",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": [
                                    "Pense na TM como um autômato finito no tempo: cada timestep é um 'estado global'.",
                                    "Comece com uma TM simples para intuitar."
                                  ],
                                  "learningObjective": "Visualizar a simulação passo-a-passo da TM via SAT.",
                                  "commonMistakes": [
                                    "Subestimar o número de variáveis (uma por posição, símbolo, estado, timestep).",
                                    "Esquecer cláusulas de 'exclusividade' (um símbolo por posição)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Detalhadamente a Instância SAT",
                                  "subSteps": [
                                    "Defina variáveis booleanas: H_{t, i, q, s} = true se na timestep t, posição i, estado q, símbolo s.",
                                    "Escreva cláusulas para configuração inicial: cabeçote em 1, estado inicial, símbolos de x na fita.",
                                    "Crie cláusulas de transição: para cada t, i, garanta que próxima configuração segue δ (função de transição da TM).",
                                    "Adicione cláusulas para aceitação: em algum t <= p(n), estado de aceitação.",
                                    "Implemente cláusulas de consistência: exatamente um estado/símbolo por posição/timestep."
                                  ],
                                  "verification": "Escreva cláusulas explícitas para uma TM toy com 2 estados e alfabeto {0,1,#}.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Excel para listar variáveis e cláusulas",
                                    "Python para gerar fórmulas pequenas (opcional)",
                                    "Referência: Arora-Barak 'Computational Complexity'"
                                  ],
                                  "tips": [
                                    "Use notação compacta: liste todas as cláusulas em categorias (init, trans, accept).",
                                    "Teste com SAT solver online para fórmulas pequenas."
                                  ],
                                  "learningObjective": "Construir a fórmula SAT manualmente para casos simples.",
                                  "commonMistakes": [
                                    "Cláusulas incompletas para transições não-determinísticas (mas V é determinístico).",
                                    "Permitir sobreposições na fita sem cláusulas de exclusão mútua."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar a Correção da Redução",
                                  "subSteps": [
                                    "Prove 'se x em L, então φ satisfatível': dado certificado c, construa atribuição H simulando V(x,c).",
                                    "Prove 'se φ satisfatável, então x em L': extraia certificado da atribuição válida da fita auxiliar.",
                                    "Verifique polinomialidade: número de variáveis e cláusulas O(p(n)^3) ou similar.",
                                    "Discuta generalidade: funciona para qualquer verificador TM em tempo polinomial.",
                                    "Aborde extensões: para Circuit-SAT ou 3SAT via padding."
                                  ],
                                  "verification": "Escreva prova formal em 1-2 páginas, com lemas para cada direção.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel para provas",
                                    "Exemplos de provas de redução em CLRS",
                                    "LaTeX para formatação (opcional)"
                                  ],
                                  "tips": [
                                    "Use contrapositiva para direção inversa.",
                                    "Conte bits na fita para extrair c."
                                  ],
                                  "learningObjective": "Estabelecer NP-completude rigorosamente.",
                                  "commonMistakes": [
                                    "Não provar extração explícita do certificado.",
                                    "Ignorar tempo polinomial na construção de φ."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Testar com um Exemplo Concreto",
                                  "subSteps": [
                                    "Escolha um L simples em NP, e.g., 'palíndromos pares' com verificador que compara metades.",
                                    "Construa TM V para esse L.",
                                    "Gere φ para uma instância x específica.",
                                    "Use um SAT solver (como MiniSat) para verificar satisfatibilidade.",
                                    "Analise o assignment retornado para validar o certificado."
                                  ],
                                  "verification": "Execute redução completa e solver, documente resultados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SAT solver online (satcompetition.org/tools)",
                                    "Python com pysat library",
                                    "Exemplo pronto de palíndromo"
                                  ],
                                  "tips": [
                                    "Comece com x curto (|x|=4) para fórmula gerenciável.",
                                    "Debug cláusulas comparando com simulação manual da TM."
                                  ],
                                  "learningObjective": "Aplicar teorema hands-on.",
                                  "commonMistakes": [
                                    "Erros de indexação em variáveis H.",
                                    "Solver timeout por fórmula mal codificada."
                                  ]
                                }
                              ],
                              "practicalExample": "Para L = {w | w é palíndromo par}, verificador V lê w na fita, certificado c indica posição de mismatch se existir. Construa φ com 10 timesteps para |w|=4, resultando em ~500 cláusulas; solver encontra assignment simulando aceitação.",
                              "finalVerifications": [
                                "Construir φ correta para TM dada com ≤10 estados.",
                                "Provar ambas direções da redução formalmente.",
                                "Executar solver em exemplo e interpretar assignment.",
                                "Explicar por que SAT captura computação polinomial.",
                                "Identificar falhas em uma redução incompleta.",
                                "Generalizar para outros problemas NP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de variáveis e cláusulas (90% correto).",
                                "Completude da prova de redução (todas direções cobertas).",
                                "Polinomialidade verificada em tamanho de φ.",
                                "Exemplo prático executável com solver.",
                                "Clareza em documentação e diagramas.",
                                "Compreensão conceitual via explicação oral."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Proposicional (construção de fórmulas CNF).",
                                "Teoria dos Autômatos (simulação de TM via lógica).",
                                "Matemática Discreta (contagem de cláusulas, indução em provas).",
                                "Inteligência Artificial (SAT solvers em planejamento e verificação).",
                                "Criptografia (NP-completude em problemas como factoring)."
                              ],
                              "realWorldApplication": "Usado em compiladores e verificadores de hardware para encoding de problemas de otimização como 'encontrar bug em circuito' como SAT, resolvido por solvers industriais como Z3 em design de chips e segurança de software."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.5.2.4",
                            "name": "Listar problemas NP-completos conhecidos",
                            "description": "Enumerar e caracterizar problemas como Vertex Cover, Independent Set, Hamiltonian Cycle e sua importância na prática computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de NP-Completude",
                                  "subSteps": [
                                    "Leia a definição de problemas NP e NP-Completos, focando em redução polinomial.",
                                    "Estude o teorema de Cook-Levin e a importância das reduções.",
                                    "Revise exemplos iniciais como SAT e Clique para contextualizar."
                                  ],
                                  "verification": "Explique em suas palavras o que torna um problema NP-Completo e dê um exemplo de redução.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro 'Introduction to Algorithms' (CLRS), Wikipedia: NP-completeness",
                                  "tips": "Use diagramas para visualizar reduções entre problemas.",
                                  "learningObjective": "Compreender os critérios formais para classificar problemas como NP-Completos.",
                                  "commonMistakes": "Confundir NP-Completos com NP-Difíceis ou ignorar a necessidade de reduções polinomiais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Vertex Cover e Independent Set",
                                  "subSteps": [
                                    "Defina Vertex Cover: menor conjunto de vértices que cobre todas as arestas.",
                                    "Aprenda Independent Set: maior conjunto de vértices sem arestas entre si.",
                                    "Pratique reduções: mostre como Independent Set reduz para Vertex Cover.",
                                    "Liste instâncias pequenas e resolva manualmente."
                                  ],
                                  "verification": "Resolva um grafo simples com 5 vértices para ambos os problemas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Geogebra ou papel para grafos, Khan Academy: Graph Theory",
                                  "tips": "Desenhe grafos e teste conjuntos candidatos iterativamente.",
                                  "learningObjective": "Caracterizar formalmente Vertex Cover e Independent Set, incluindo suas reduções mútuas.",
                                  "commonMistakes": "Esquecer que Vertex Cover é o complemento de Independent Set em alguns contextos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Hamiltonian Cycle e outros problemas",
                                  "subSteps": [
                                    "Defina Hamiltonian Cycle: ciclo que visita cada vértice exatamente uma vez.",
                                    "Estude Traveling Salesman Problem (TSP) e 3-SAT como exemplos adicionais.",
                                    "Pratique identificando por que esses problemas são NP-Completos via reduções.",
                                    "Compare com problemas em P para contrastar."
                                  ],
                                  "verification": "Descreva uma redução de Hamiltonian Cycle para TSP.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Site Garey & Johnson 'Computers and Intractability', YouTube: NP-Completeness playlist",
                                  "tips": "Use animações para visualizar ciclos hamiltonianos em grafos.",
                                  "learningObjective": "Enumerar e caracterizar Hamiltonian Cycle, TSP e 3-SAT como NP-Completos.",
                                  "commonMistakes": "Confundir Hamiltonian Path com Cycle ou ignorar restrições de vértices distintos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar importância prática e aplicações",
                                  "subSteps": [
                                    "Discuta heurísticas e aproximações para problemas NP-Completos (ex: 2-approx para Vertex Cover).",
                                    "Explore impactos em scheduling, roteamento e criptografia.",
                                    "Crie uma tabela resumindo os problemas estudados com suas aplicações.",
                                    "Reflita sobre P vs NP e implicações."
                                  ],
                                  "verification": "Escreva um parágrafo sobre por que NP-Completos importam apesar de intratáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigo 'The Status of the P versus NP Problem' (Clay Math), Notion ou Excel para tabela",
                                  "tips": "Relacione com problemas reais como otimização de rotas de entrega.",
                                  "learningObjective": "Explicar a relevância prática de problemas NP-Completos na computação.",
                                  "commonMistakes": "Superestimar solucionabilidade exata em instâncias grandes."
                                }
                              ],
                              "practicalExample": "Em um grafo de rede social com 10 usuários (vértices) e amizades (arestas), use Vertex Cover para encontrar o menor conjunto de usuários que 'cobre' todas as amizades (influencers mínimos), Independent Set para grupos sem conexões diretas, e Hamiltonian Cycle para uma sequência de visitas que conecta todos sem repetir.",
                              "finalVerifications": [
                                "Liste pelo menos 5 problemas NP-Completos com definições breves.",
                                "Explique reduções entre Vertex Cover e Independent Set.",
                                "Descreva uma aplicação real de Hamiltonian Cycle.",
                                "Identifique por que esses problemas são intratáveis mas úteis.",
                                "Crie uma tabela comparativa de 3 problemas estudados."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e caracterizações (90% correto).",
                                "Completude na enumeração de exemplos e reduções.",
                                "Profundidade na discussão de importância prática.",
                                "Clareza em exemplos e verificações pessoais.",
                                "Correção em distinções entre problemas semelhantes.",
                                "Criatividade em conexões com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Combinatória.",
                                "Otimização: Algoritmos de Aproximação e Heurísticas.",
                                "Inteligência Artificial: Busca e Planejamento em espaços de estados.",
                                "Economia: Modelagem de problemas de alocação intratável."
                              ],
                              "realWorldApplication": "Em logística, Hamiltonian Cycle modela rotas de entrega ótimas (TSP); Vertex Cover otimiza cobertura de sensores em redes IoT; Independent Set agenda tarefas sem conflitos em manufatura, impactando eficiência em indústrias como transporte e telecomunicações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.3",
                        "name": "Caracterização de Problemas Intratáveis",
                        "description": "Uso de NP-completude para caracterizar problemas presumivelmente intratáveis, implicações da hipótese P ≠ NP e relação com indecidabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.3.1",
                            "name": "Caracterizar intratabilidade via NP-completude",
                            "description": "Explicar que problemas NP-completos são intratáveis se P ≠ NP, significando ausência de algoritmos polinomiais eficientes a menos que P=NP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as classes de complexidade P e NP",
                                  "subSteps": [
                                    "Defina formalmente a classe P como problemas decidíveis em tempo polinomial por uma máquina de Turing determinística.",
                                    "Defina a classe NP como problemas cujas soluções podem ser verificadas em tempo polinomial por uma máquina de Turing determinística.",
                                    "Discuta exemplos clássicos: ordenação em P (ex: QuickSort), e SAT em NP.",
                                    "Explique a relação P ⊆ NP e a hipótese aberta P =? NP.",
                                    "Compare com classes como EXP para contextualizar."
                                  ],
                                  "verification": "Resuma as diferenças entre P e NP em um diagrama de Venn e liste 3 exemplos para cada classe.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 7)",
                                    "Vídeos Khan Academy sobre complexidade",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogias: P é como resolver um cubo mágico rapidamente; NP é verificar se está resolvido.",
                                  "learningObjective": "Compreender as definições fundamentais de P e NP para basear a discussão de NP-completude.",
                                  "commonMistakes": [
                                    "Confundir verificação com solução (NP não implica solução polinomial)",
                                    "Achar que todos problemas em NP são 'difíceis' sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender NP-completude e reduções polinomiais",
                                  "subSteps": [
                                    "Defina problema NP-completo: problema em NP para o qual todo problema em NP é redutível em tempo polinomial.",
                                    "Explique reduções polinomiais: transformação f: instância de A para B em tempo polinomial, preservando sim/não.",
                                    "Estude o teorema de Cook-Levin: SAT é NP-completo.",
                                    "Liste outros NP-completos via redução: Clique, TSP, Vertex Cover.",
                                    "Pratique traçando uma redução simples de SAT para 3-SAT."
                                  ],
                                  "verification": "Descreva uma redução polinomial de um problema conhecido para outro e prove que preserva a resposta.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigo original de Cook (opcional)",
                                    "Site NP-Completeness de Garey & Johnson",
                                    "Ferramenta online como Reductions Visualizer"
                                  ],
                                  "tips": "Pense em reduções como 'tradução': se A é difícil, faça B parecer A.",
                                  "learningObjective": "Dominar o conceito de NP-completude como 'mais difícil' dentro de NP.",
                                  "commonMistakes": [
                                    "Confundir NP-duro com NP-completo (NP-duro não precisa estar em NP)",
                                    "Achar que redução implica algoritmo eficiente para o original"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a hipótese P ≠ NP e implicações para intratabilidade",
                                  "subSteps": [
                                    "Explique que se P = NP, todos NP-completos têm algoritmos polinomiais (colapso de classes).",
                                    "Discuta evidências heurísticas para P ≠ NP: oráculos, barreiras de relativização, algebrização.",
                                    "Defina 'intratável' como ausência de algoritmo polinomial eficiente (assumindo P ≠ NP).",
                                    "Argumente: NP-completos são intratáveis se P ≠ NP, pois resolver um resolve todos NP.",
                                    "Compare com problemas indecidíveis (ex: Halting Problem) para diferenciar."
                                  ],
                                  "verification": "Escreva um parágrafo provando que resolver um NP-completo em P implica P=NP.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Clay Mathematics Institute Millennium Prize para P vs NP",
                                    "Blog de Scott Aaronson sobre complexidade",
                                    "Notas de aula de Arora & Barak"
                                  ],
                                  "tips": "Lembre: P ≠ NP é conjectura; tratamos como verdadeira para prática.",
                                  "learningObjective": "Conectar NP-completude à intratabilidade prática sob P ≠ NP.",
                                  "commonMistakes": [
                                    "Equiparar NP-completo a 'impossível' (são aproximáveis/heuristicamente solucionáveis)",
                                    "Ignorar que P=NP colapsaria hierarquia polinomial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Caracterizar formalmente intratabilidade via NP-completude",
                                  "subSteps": [
                                    "Formalize: Problema é presumidamente intratável se NP-completo e P ≠ NP.",
                                    "Discuta consequências: sem polinomiais exatos, use aproximações, heurísticas, ramificação/podar.",
                                    "Aplique a exemplo: TSP é NP-completo → intratável para instâncias grandes.",
                                    "Debata impactos: criptografia (se P=NP, quebra RSA), otimização industrial.",
                                    "Crie uma tabela comparando P, NP, NPC, Intratáveis."
                                  ],
                                  "verification": "Classifique 5 problemas (ex: sorting, SAT, Halting) por classe e intratabilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exercícios de 'Computers and Intractability' de Garey",
                                    "Python para simular TSP pequeno",
                                    "Tabela em Excel/Google Sheets"
                                  ],
                                  "tips": "Foco em 'presumidamente': não provado, mas amplamente aceito.",
                                  "learningObjective": "Capacitar caracterização precisa de problemas intratáveis usando NP-completude.",
                                  "commonMistakes": [
                                    "Chamar todos NP de intratáveis (apenas NPC sob P≠NP)",
                                    "Confundir com NP-fácil (em P)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o problema do Caixeiro Viajante (TSP): dado cidades e distâncias, encontre tour mais curto. Prove NP-completo via redução de Hamiltonian Cycle. Sob P ≠ NP, não há algoritmo polinomial eficiente para instâncias reais (milhares de cidades), forçando heurísticas como Christofides (aproximação 1.5x ótima).",
                              "finalVerifications": [
                                "Explique corretamente por que NP-completos são intratáveis assumindo P ≠ NP.",
                                "Forneça um exemplo de redução polinomial para um NP-completo.",
                                "Diferencie intratabilidade de indecidibilidade com exemplos.",
                                "Liste 3 implicações práticas de P ≠ NP.",
                                "Crie um argumento lógico conectando NPC a ausência de algoritmos eficientes."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições de P, NP, NPC sem erros (30%)",
                                "Compreensão de reduções: explica e aplica corretamente (25%)",
                                "Raciocínio sobre P vs NP: discute implicações lógicas (20%)",
                                "Exemplos e caracterizações: usa casos reais e tabelas (15%)",
                                "Clareza e estrutura: comunicação organizada sem confusões (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Otimização Combinatória",
                                "Lógica e Filosofia: Problemas indecidíveis e limites do conhecimento",
                                "Engenharia de Software: Análise de algoritmos e design de heurísticas",
                                "Economia: Modelos de otimização em logística e alocação de recursos"
                              ],
                              "realWorldApplication": "Em logística (ex: rotas Amazon), problemas NP-completos como Vehicle Routing levam a solvers heurísticos; em bioinformática, alinhamento de sequências assume intratabilidade para genomas grandes, usando aproximações; criptografia depende de P ≠ NP para segurança de sistemas como blockchain."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.5.3.2",
                            "name": "Relacionar com problemas indecidíveis",
                            "description": "Comparar problemas NP-completos (recursivamente enumeráveis em tempo expoencial) com problemas indecidíveis como o Problema da Parada, destacando hierarquia de complexidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Indecidibilidade e o Problema da Parada",
                                  "subSteps": [
                                    "Estude a definição formal do Problema da Parada (Halting Problem): dado um programa P e entrada I, determinar se P para em I.",
                                    "Aprenda a prova de indecidibilidade de Turing: assumir um decisor H leva a contradição via diagonalização.",
                                    "Identifique classes de linguagens: recursivamente enumeráveis (RE) vs. decidíveis (recursive).",
                                    "Explore exemplos de problemas indecidíveis além do Halting, como equivalência de máquinas Turing.",
                                    "Anote as implicações: não existe algoritmo geral para resolver esses problemas."
                                  ],
                                  "verification": "Resuma em 3-5 frases a prova de indecidibilidade e liste 2 exemplos de problemas RE mas não decidíveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 4); vídeo Khan Academy sobre Halting Problem; papel e caneta para anotações.",
                                  "tips": "Use analogias como 'prever se um loop infinito termina' para fixar o conceito.",
                                  "learningObjective": "Compreender a natureza fundamentalmente indecidível do Problema da Parada e classes RE.",
                                  "commonMistakes": "Confundir indecidível com 'muito difícil'; lembrar que indecidível significa sem algoritmo finito garantido."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Problemas NP-Completos e sua Complexidade",
                                  "subSteps": [
                                    "Defina P, NP e NP-completo: problemas em NP verificáveis em tempo polinomial, NP-completos reduzíveis uns aos outros.",
                                    "Estude exemplos: SAT, Clique, Traveling Salesman; note que são decidíveis mas presumivelmente não em P.",
                                    "Discuta tempo exponencial: solvers enumeram 2^n possibilidades no pior caso.",
                                    "Aprenda reduções polinomiais: por que NP-completos são 'os mais difíceis' em NP.",
                                    "Compare com RE: NP-completos são decidíveis (recursive), mas intratáveis."
                                  ],
                                  "verification": "Classifique SAT como NP-completo e esboce uma redução de 3-SAT para Clique.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Capítulo 34 de CLRS ('Introduction to Algorithms'); ferramenta online como NP-completeness applet; quadro branco.",
                                  "tips": "Visualize árvores de busca exaustiva para entender o expoencial.",
                                  "learningObjective": "Dominar a hierarquia P ⊆ NP e a centralidade dos NP-completos.",
                                  "commonMistakes": "Achar que NP-completos são indecidíveis; eles são decidíveis, só caros computacionalmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar NP-Completos com Problemas Indecidíveis",
                                  "subSteps": [
                                    "Liste diferenças chave: NP-completos decidíveis em tempo finito (expoencial), indecidíveis sem algoritmo halting em todos casos.",
                                    "Semelhanças: ambos 'difíceis'; NP-completos no nível Δ_1^0 da hierarquia aritmética, Halting em Σ_1^0.",
                                    "Discuta hierarquia: decidíveis abaixo indecidíveis na torre de computabilidade.",
                                    "Analise: NP-completos RE e co-RE, Halting só RE.",
                                    "Crie tabela comparativa: decidibilidade, tempo, exemplos."
                                  ],
                                  "verification": "Preencha tabela comparativa com 5 critérios (ex: decidível?, tempo worst-case?, reduzível?).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigo Wikipedia 'Halting Problem' e 'NP-completeness'; Excel ou papel para tabela.",
                                  "tips": "Pense em 'escalas': NP é 'lenta mas termina', indecidível é 'pode nunca terminar'.",
                                  "learningObjective": "Destacar diferenças e hierarquia entre complexidade e indecidibilidade.",
                                  "commonMistakes": "Equiparar 'expoencial' a 'indecidível'; expoencial termina, indecidível não garante."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Hierarquia de Complexidade e Aplicações",
                                  "subSteps": [
                                    "Estude hierarquia aritmética: Σ_0^0 = decidíveis, inclui P/NP; Σ_1^0 = RE (Halting).",
                                    "Posicione NP-completos em decidíveis mas acima P.",
                                    "Discuta implicações: limites teóricos guiam heurísticas para NP.",
                                    "Crie diagrama: torre de computabilidade com posições.",
                                    "Reflita: por que entender isso importa para pesquisa em IA/algoritmos."
                                  ],
                                  "verification": "Desenhe diagrama hierárquico e explique posição de SAT vs. Halting.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Notas de aula sobre teoria da computabilidade; ferramenta Draw.io para diagrama.",
                                  "tips": "Use setas para mostrar 'mais difícil que' na hierarquia.",
                                  "learningObjective": "Visualizar e explicar a hierarquia de complexidade computacional.",
                                  "commonMistakes": "Ignorar que NP está dentro decidíveis; hierarquia vai além."
                                }
                              ],
                              "practicalExample": "Compare SAT (NP-completo): dado fórmula booleana, existe atribuição satisfazendo? Decidível via backtracking expoencial. Vs. Halting: dado código Python 'while True: pass' em input vazio, para? Indecidível, sem algoritmo geral. Hierarquia: SAT decidível politempo-verificável, Halting requer simulação infinita potencial.",
                              "finalVerifications": [
                                "Explique em 1 minuto a diferença entre decidível expoencial e indecidível.",
                                "Classifique corretamente 3 problemas: SAT (NP-C), Halting (indecidível), Bubble Sort (P).",
                                "Descreva prova diagonal de Turing sem olhar notas.",
                                "Preencha tabela comparativa sem erros.",
                                "Desenhe hierarquia básica: P/NP dentro decidíveis, RE acima.",
                                "Dê exemplo de redução NP-completa."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre decidibilidade e complexidade (30%)",
                                "Compreensão hierárquica: posicionamento correto em classes (25%)",
                                "Uso de exemplos: relevância e correção (20%)",
                                "Capacidade explicativa: clareza em resumo oral/escrito (15%)",
                                "Profundidade comparativa: semelhanças/diferenças bem articuladas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e cardinalidade (diagonalização).",
                                "Filosofia: Limites do conhecimento e epistemologia computacional.",
                                "Lógica: Provas por contradição e sistemas formais.",
                                "Engenharia de Software: Análise de complexidade em design de algoritmos."
                              ],
                              "realWorldApplication": "Em verificação de software, Halting indecidível impede análise estática total de loops; usa-se aproximadores NP-hard como model checking. Para otimização (ex: roteirização NP-completa em logística), aceita-se heurísticas sabendo limites teóricos, guiando investimentos em computação quântica ou aproximada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.3.1",
                              "10.1.7.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.7.5.3.3",
                            "name": "Discutir implicações práticas",
                            "description": "Analisar o impacto de problemas NP-completos em otimização, heurísticas e aproximações, com referências a livros como Sipser e Hopcroft-Ullman.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Problemas NP-Completos",
                                  "subSteps": [
                                    "Ler capítulos relevantes de Sipser (Capítulo 7) sobre classes P, NP e NP-completude.",
                                    "Estudar definições de redução polinomial e exemplos como SAT e Clique.",
                                    "Resumir em um mapa mental as propriedades chave de problemas NP-completos.",
                                    "Comparar com problemas em P usando tabelas de complexidade.",
                                    "Identificar por que provar P=NP é um problema em aberto."
                                  ],
                                  "verification": "Mapa mental completo com pelo menos 5 propriedades listadas e exemplos corretos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro Sipser (Introduction to the Theory of Computation)",
                                    "Papel e caneta ou ferramenta de mind mapping como MindMeister"
                                  ],
                                  "tips": "Comece com exemplos familiares como SAT para ancorar conceitos abstratos.",
                                  "learningObjective": "Compreender as bases teóricas de NP-completude para contextualizar implicações práticas.",
                                  "commonMistakes": "Confundir NP-completos com intratáveis; lembre que são polinomialmente verificáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Impacto em Problemas de Otimização",
                                  "subSteps": [
                                    "Selecionar 3 problemas NP-completos de otimização (ex: Caixeiro-Viajante, Knapsack, Partition).",
                                    "Calcular complexidade exponencial para instâncias reais (n=50).",
                                    "Discutir trade-offs entre exatidão e tempo de execução.",
                                    "Explorar ramificações e poda como estratégias iniciais.",
                                    "Documentar limitações em escala prática."
                                  ],
                                  "verification": "Relatório com cálculos de tempo para n=20-50 e trade-offs descritos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Livro Hopcroft-Ullman (Capítulo sobre complexidade)",
                                    "Planilha Excel para simulações de tempo"
                                  ],
                                  "tips": "Use logaritmos para estimar 2^n realisticamente (ex: 1 trilhão de operações).",
                                  "learningObjective": "Identificar por que otimização exata falha em problemas NP-completos grandes.",
                                  "commonMistakes": "Ignorar que soluções exatas existem mas são impraticáveis; foque em escalabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Heurísticas e Algoritmos de Aproximação",
                                  "subSteps": [
                                    "Estudar heurísticas como Nearest Neighbor para TSP.",
                                    "Implementar uma heurística simples em pseudocódigo.",
                                    "Analisar garantias de aproximação (ex: 2-aproximação para Vertex Cover).",
                                    "Comparar desempenho empírico vs. ótimo usando benchmarks.",
                                    "Referenciar Sipser para limites teóricos de aproximação (PCP theorem)."
                                  ],
                                  "verification": "Pseudocódigo funcional e tabela comparativa de desempenho.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python ou pseudocódigo editor",
                                    "Datasets de TSP do TSPLIB"
                                  ],
                                  "tips": "Teste com instâncias pequenas para validar antes de escalar.",
                                  "learningObjective": "Dominar alternativas práticas para contornar NP-dureza.",
                                  "commonMistakes": "Achar heurísticas sempre ruins; destaque casos onde superam exatas em tempo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Implicações Práticas e Referências",
                                  "subSteps": [
                                    "Ler seções de Hopcroft-Ullman sobre aplicações em grafos e linguagens.",
                                    "Escrever ensaio discutindo impactos em IA, logística e criptografia.",
                                    "Citar pelo menos 3 exemplos reais (ex: roteamento GPS, scheduling).",
                                    "Debater futuro com quantum computing.",
                                    "Preparar apresentação de 5 minutos resumindo."
                                  ],
                                  "verification": "Ensaio de 800 palavras com citações e apresentação gravada.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Livros Sipser e Hopcroft-Ullman",
                                    "Ferramenta de gravação como Loom"
                                  ],
                                  "tips": "Use bullet points para implicações para clareza no ensaio.",
                                  "learningObjective": "Articular implicações práticas de forma coesa com suporte bibliográfico.",
                                  "commonMistakes": "Focar só em teoria; sempre ligue a aplicações mensuráveis."
                                }
                              ],
                              "practicalExample": "Em logística, o problema do Caixeiro-Viajante (TSP, NP-completo) é aproximado por heurísticas em apps como Google Maps, economizando combustível mas sacrificando 10-20% de otimalidade em rotas urbanas.",
                              "finalVerifications": [
                                "Explicar corretamente 3 exemplos de problemas NP-completos e suas otimizações práticas.",
                                "Calcular tempo estimado para instância TSP n=30.",
                                "Descrever uma heurística com garantia de aproximação.",
                                "Citar páginas específicas de Sipser/Hopcroft-Ullman.",
                                "Discutir limitações em 2 domínios reais (ex: scheduling, cripto).",
                                "Apresentar síntese oral sem erros conceituais."
                              ],
                              "assessmentCriteria": [
                                "Profundidade na análise de impactos (30%)",
                                "Precisão em conceitos teóricos e referências (25%)",
                                "Criatividade em exemplos práticos e heurísticas (20%)",
                                "Clareza na comunicação escrita/oral (15%)",
                                "Integração de conexões interdisciplinares (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Otimização Linear",
                                "Economia: Modelos de Decisão e Custos Computacionais",
                                "Inteligência Artificial: Algoritmos Genéticos e Aprendizado de Máquina",
                                "Física: Simulações Quânticas para NP (Quantum Annealing)"
                              ],
                              "realWorldApplication": "Na indústria farmacêutica, otimização de síntese molecular (NP-completa) usa heurísticas para acelerar descoberta de drogas, reduzindo tempo de anos para meses em empresas como Pfizer."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.8",
                "name": "Classe de Problemas NP",
                "description": "Definição e propriedades da classe NP na teoria da computação.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.8.1",
                    "name": "Definição Formal da Classe NP",
                    "description": "Definição da classe NP como o conjunto de problemas decidíveis em tempo polinomial por uma máquina de Turing não-determinística.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.1.1",
                        "name": "Máquina de Turing Não-Determinística (MTN)",
                        "description": "Definição formal e componentes de uma Máquina de Turing Não-Determinística, incluindo transições múltiplas a partir de um estado e configuração.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.1.1",
                            "name": "Identificar componentes de uma MTN",
                            "description": "Listar e descrever os elementos formais de uma MTN: conjunto de estados Q, alfabeto de fita Γ, função de transição δ: Q × Γ → P(Q × Γ × {L,R}), estados inicial q0, aceitação F e rejeição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Listar os componentes principais de uma MTN",
                                  "subSteps": [
                                    "Relembre a definição formal de uma Máquina de Turing Não-Determinística (MTN).",
                                    "Identifique os seis componentes essenciais: Q, Γ, δ, q0, F e o estado de rejeição.",
                                    "Anote cada componente em uma tabela com nome e símbolo.",
                                    "Compare com a definição de MT determinística para destacar diferenças.",
                                    "Pesquise em uma referência confiável para confirmar a lista."
                                  ],
                                  "verification": "A tabela lista corretamente os 6 componentes com símbolos exatos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro ou PDF de Teoria da Computação (ex: Sipser)"
                                  ],
                                  "tips": "Use símbolos gregos corretos: Γ para alfabeto de fita, δ para transição.",
                                  "learningObjective": "Memorizar e listar precisamente os componentes formais de uma MTN.",
                                  "commonMistakes": [
                                    "Confundir Γ com Σ (alfabeto de entrada)",
                                    "Esquecer o poder set P em δ",
                                    "Omitir estado de rejeição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o conjunto de estados Q e alfabeto de fita Γ",
                                  "subSteps": [
                                    "Defina Q como o conjunto finito de estados da máquina.",
                                    "Explique Γ como o alfabeto da fita, incluindo o símbolo em branco ⊢.",
                                    "Dê exemplos: Q = {q0, q1, qrej, qacc}, Γ = {0,1,⊢}.",
                                    "Discuta o papel de cada um na execução da MTN.",
                                    "Desenhe uma fita simples com símbolos de Γ."
                                  ],
                                  "verification": "Descrições escritas explicam funções e incluem exemplos válidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou papel",
                                    "Referência teórica online"
                                  ],
                                  "tips": "Lembre-se: Γ é maior ou igual a Σ, inclui símbolos de controle.",
                                  "learningObjective": "Compreender o propósito e representação de Q e Γ em uma MTN.",
                                  "commonMistakes": [
                                    "Achar que Q é infinito",
                                    "Confundir Γ com o alfabeto de entrada Σ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a função de transição δ",
                                  "subSteps": [
                                    "Estude a assinatura: δ: Q × Γ → P(Q × Γ × {L,R}).",
                                    "Explique o poder set P, permitindo múltiplas transições (não-determinismo).",
                                    "Escreva um exemplo: δ(q0,0) = {(q1,1,R), (q2,0,L)}.",
                                    "Compare com δ determinística: Q × Γ → Q × Γ × {L,R}.",
                                    "Simule uma transição em papel."
                                  ],
                                  "verification": "Exemplo de δ escrito corretamente com múltiplas saídas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Simulador de MTN online (opcional)"
                                  ],
                                  "tips": "Pense em δ como um conjunto de possibilidades, não uma única escolha.",
                                  "learningObjective": "Dominar a notação e o conceito não-determinístico de δ.",
                                  "commonMistakes": [
                                    "Escrever δ sem P( )",
                                    "Usar {L,R,N} em vez de só {L,R}",
                                    "Ignorar que δ retorna subconjuntos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar estados inicial, aceitação F e rejeição",
                                  "subSteps": [
                                    "Defina q0 como o estado inicial único.",
                                    "Explique F ⊆ Q como estados de aceitação.",
                                    "Descreva o estado de rejeição (geralmente qrej ∉ F).",
                                    "Marque em um diagrama de estados: seta para q0, círculos duplos para F.",
                                    "Verifique aceitação: máquina aceita se entra em F."
                                  ],
                                  "verification": "Diagrama rotulado corretamente com q0, F e rejeição.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para diagrama",
                                    "Exemplos de MTN de livros"
                                  ],
                                  "tips": "Estado de rejeição é implícito, mas essencial para halt.",
                                  "learningObjective": "Reconhecer e diferenciar estados especiais em MTN.",
                                  "commonMistakes": [
                                    "Confundir q0 com estado de aceitação",
                                    "Achar F vazio sempre rejeita"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar identificação completa em um exemplo",
                                  "subSteps": [
                                    "Pegue uma MTN exemplo para {a^n b^n}.",
                                    "Extraia Q, Γ, δ, q0, F da descrição formal.",
                                    "Preencha um formulário com todos componentes.",
                                    "Simule 2-3 passos de execução não-determinística.",
                                    "Autoavalie erros na identificação."
                                  ],
                                  "verification": "Formulário preenchido 100% correto para o exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo impresso de MTN",
                                    "Ferramentas de simulação online"
                                  ],
                                  "tips": "Escolha branches não-determinísticos para entender ramificações.",
                                  "learningObjective": "Aplicar conhecimento para identificar componentes em MTN real.",
                                  "commonMistakes": [
                                    "Não capturar todas transições em δ",
                                    "Esquecer símbolo em branco em Γ"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma MTN que aceita {a^n b^n | n≥0}: Q={q0,q1,q2,qacc,qrej}, Γ={a,b,⊢}, δ(q0,a)={(q1,⊢,R),(qrej,a,R)}, δ(q1,b)={(q1,b,R),(q2,⊢,L)}, etc., q0 inicial, F={qacc}. Identifique todos listando formalmente.",
                              "finalVerifications": [
                                "Lista corretamente os 6 componentes: Q, Γ, δ, q0, F, rejeição.",
                                "Explica δ com notação P(Q × Γ × {L,R}).",
                                "Diferencia MTN de MTD pela não-determinística δ.",
                                "Identifica componentes em um exemplo dado.",
                                "Desenha diagrama com estados corretos.",
                                "Simula transição básica sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na lista de componentes (100%).",
                                "Correção da notação matemática de δ (90%).",
                                "Explicações claras e concisas (80%).",
                                "Exemplo prático incluído e válido (100%).",
                                "Identificação em diagrama visual (90%).",
                                "Compreensão de não-determinismo demonstrada (85%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Funções Parciais.",
                                "Lógica: Estados e Transições em Autômatos.",
                                "Algoritmos: Complexidade Computacional (NP).",
                                "Filosofia da Computação: Limites da Computação."
                              ],
                              "realWorldApplication": "Modelagem de problemas NP-completos em verificadores de software, otimização em IA (busca não-determinística) e análise de algoritmos paralelos em computação quântica simulada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.1.2",
                            "name": "Simular um passo de computação em MTN",
                            "description": "Dado uma configuração inicial e entrada, descrever todas as configurações sucessoras possíveis em um passo de transição não-determinístico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Representar a Configuração Inicial da MTN",
                                  "subSteps": [
                                    "Examinar a configuração dada: estado atual q, conteúdo da fita (incluindo blanks infinitos à esquerda e direita), e posição da cabeça de leitura/escrita.",
                                    "Escrever a fita usando notação padrão, como ...B B σ ... onde σ é o símbolo sob a cabeça.",
                                    "Confirmar o estado inicial q e a posição exata da cabeça (índice ou seta indicando).",
                                    "Verificar se a entrada está corretamente posicionada na fita inicial.",
                                    "Documentar a configuração completa no formato padrão: <q, w, p> onde w é a fita e p a posição."
                                  ],
                                  "verification": "Configuração inicial representada corretamente no formato <q, fita com blanks, posição da cabeça>.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Definição formal da MTN, papel e lápis ou editor de texto para diagramas de fita.",
                                  "tips": "Sempre inclua blanks (geralmente '_') para mostrar infinitude; use setas ↑ para cabeça.",
                                  "learningObjective": "Representar com precisão qualquer configuração inicial de uma MTN.",
                                  "commonMistakes": "Ignorar blanks infinitos ou posicionar incorretamente a cabeça de leitura."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o Símbolo Lido e Consultar Transições Não-Determinísticas",
                                  "subSteps": [
                                    "Identificar o símbolo σ sob a cabeça na configuração atual.",
                                    "Consultar a função de transição δ(q, σ), que retorna um conjunto finito de transições possíveis: {(q₁, γ₁, D₁), (q₂, γ₂, D₂), ...}.",
                                    "Listar todas as transições aplicáveis sem duplicatas.",
                                    "Anotar cada possível (novo_estado, símbolo_a_escrever, direção_de_movimento).",
                                    "Confirmar que δ é total ou gerenciar casos sem transição (rejeição implícita)."
                                  ],
                                  "verification": "Lista completa e correta de todas as transições δ(q, σ) extraídas da definição da MTN.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela de transições da MTN específica, calculadora para contagem se necessário.",
                                  "tips": "Ordene as transições por novo estado para facilitar rastreamento.",
                                  "learningObjective": "Extrair e listar todas as ramificações não-determinísticas de uma transição.",
                                  "commonMistakes": "Omitir alguma transição possível ou confundir símbolos de entrada/saída."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Configurações Sucessoras para Cada Transição",
                                  "subSteps": [
                                    "Para cada transição (q', γ, D) em δ(q, σ): substitua σ por γ na fita.",
                                    "Mova a cabeça: se D=R, incremente posição; se L, decremente; se S, mantenha.",
                                    "Ajuste a fita para incluir novos blanks se a cabeça mover para fora.",
                                    "Crie a nova configuração <q', fita_modificada, nova_posição>.",
                                    "Repita para todas as transições, gerando o conjunto completo de sucessoras."
                                  ],
                                  "verification": "Cada sucessora gerada corresponde exatamente a uma transição, com fita, estado e posição alterados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Cópias da fita inicial, tabela de transições, software de desenho como Draw.io para fitas.",
                                  "tips": "Copie a fita original para cada ramificação para evitar erros de propagação.",
                                  "learningObjective": "Aplicar transições para gerar configurações sucessoras precisas em um passo.",
                                  "commonMistakes": "Erro no movimento da cabeça (ex: confundir R com L) ou não estender blanks."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Listar Todas as Configurações Sucessoras",
                                  "subSteps": [
                                    "Comparar o conjunto gerado com todas as transições listadas no passo 2.",
                                    "Verificar unicidade: sucessoras distintas mesmo se transições levem a mesmas configs.",
                                    "Descrever o passo não-determinístico: 'De config inicial, possíveis sucessoras são {...}'.",
                                    "Testar com um caso trivial para validação.",
                                    "Documentar o conjunto final em notação formal."
                                  ],
                                  "verification": "Conjunto de sucessoras completo, sem duplicatas ou omissões, validado por inspeção.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Lista de transições e configs geradas, checklist de verificação.",
                                  "tips": "Use numeração ou bullets para listar sucessoras claramente.",
                                  "learningObjective": "Validar e apresentar o resultado de um passo de computação não-determinístico.",
                                  "commonMistakes": "Duplicar sucessoras idênticas ou esquecer de verificar movimento para blanks."
                                }
                              ],
                              "practicalExample": "Considere MTN M com δ(q0, a) = {(q1, X, R), (q2, Y, L)}. Configuração inicial: <q0, ... _ _ a _ _, 2> (cabeça em 'a'). Sucessoras: 1. <q1, ... _ _ X _ _, 3> (escreve X, move R); 2. <q2, ... _ Y a _ _, 1> (escreve Y em pos 2, move L para 1).",
                              "finalVerifications": [
                                "Configuração inicial corretamente analisada e representada.",
                                "Todas as transições δ(q, σ) listadas sem omissões.",
                                "Cada sucessora tem fita, estado e posição alterados precisamente.",
                                "Conjunto de sucessoras reflete não-determinismo (múltiplas se aplicável).",
                                "Notação consistente usada em todas as configs.",
                                "Blanks infinitos adequadamente gerenciados em movimentos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de σ e consulta a δ (100% das transições capturadas).",
                                "Correção na modificação da fita e movimento da cabeça (sem erros de posição).",
                                "Completude do conjunto de sucessoras (todas possíveis incluídas).",
                                "Clareza na representação gráfica/textual das configs.",
                                "Validação interna consistente (verificação passo-a-passo).",
                                "Tratamento correto de casos edge (sem transições ou movimento para blank)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Relações multifuncionais e conjuntos de pares (δ como relação).",
                                "Lógica: Não-determinismo similar a ramificações em provas não-construtivas.",
                                "Algoritmos e Grafos: Sucessoras como vizinhos em grafo de configurações.",
                                "Probabilidade: Interpretação não-det como distribuição uniforme sobre branches."
                              ],
                              "realWorldApplication": "Em algoritmos de busca não-determinística (ex: A* com heurísticas), modelagem de sistemas quânticos ou concorrentes onde múltiplos estados futuros emergem de um input, e verificação de software para explorar todos os caminhos de execução possíveis em um ciclo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.1.1.3",
                            "name": "Explicar o conceito de não-determinismo",
                            "description": "Diferenciar MT determinística de MTN, explicando como o não-determinismo permite ramificações paralelas na computação e aceitação se existe pelo menos um caminho aceitador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o funcionamento de uma Máquina de Turing Determinística (MT)",
                                  "subSteps": [
                                    "Estude a definição formal de uma MT: conjunto de estados, alfabeto, fita, cabeçote, função de transição única.",
                                    "Desenhe um diagrama simples de uma MT que reconhece uma linguagem regular, como strings pares de 'a'.",
                                    "Simule manualmente 3-5 transições em uma fita exemplo.",
                                    "Identifique que em cada configuração, há exatamente uma transição possível.",
                                    "Registre o caminho único de computação até a aceitação ou rejeição."
                                  ],
                                  "verification": "Construa e simule uma MT simples que aceite ou rejeite corretamente uma string de entrada fornecida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, lápis, diagrama de MT impresso ou software como JFLAP.",
                                  "tips": "Use setas claras no diagrama para representar transições únicas.",
                                  "learningObjective": "Compreender o comportamento determinístico de uma MT como base para contraste.",
                                  "commonMistakes": "Confundir estados com símbolos da fita ou ignorar o estado de halt."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a definição de Máquina de Turing Não-Determinística (MTN)",
                                  "subSteps": [
                                    "Defina MTN similar à MT, mas com função de transição que permite múltiplas transições para a mesma configuração (conjunto de possíveis próximas configurações).",
                                    "Desenhe um diagrama de MTN onde um estado tenha duas transições possíveis para o mesmo símbolo.",
                                    "Explique conceitualmente que uma MTN 'ramifica' em múltiplos caminhos simultaneamente.",
                                    "Compare sintaticamente a função de transição: δ(q, a) = {(p1, b1, D1), (p2, b2, D2)} vs. única tupla em MT.",
                                    "Liste componentes formais de uma MTN."
                                  ],
                                  "verification": "Escreva a definição formal de uma MTN e crie um exemplo com pelo menos duas transições não-determinísticas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de anotações, exemplos de diagramas de MTN.",
                                  "tips": "Pense na MTN como um 'supercomputador' que explora todos os caminhos de uma vez.",
                                  "learningObjective": "Dominar a definição formal e sintática da MTN.",
                                  "commonMistakes": "Achar que MTN usa aleatoriedade; é não-determinismo puro, não probabilístico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar ramificações paralelas no não-determinismo",
                                  "subSteps": [
                                    "Simule uma computação de MTN em uma fita exemplo, listando todas as configurações possíveis em cada passo (árvore de computação).",
                                    "Desenhe a árvore de ramificações mostrando como múltiplos caminhos evoluem paralelamente.",
                                    "Discuta o conceito de 'computação paralela conceitual' sem hardware real.",
                                    "Compare com MT: um caminho linear vs. exponencialmente muitos em MTN.",
                                    "Calcule o número de caminhos possíveis para uma entrada de tamanho n (2^k onde k é não-determinismo)."
                                  ],
                                  "verification": "Desenhe a árvore de computação completa para uma MTN simples com 2-3 ramificações.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel grande para árvore, simulador online de MTN.",
                                  "tips": "Use cores diferentes para ramificações para visualizar melhor.",
                                  "learningObjective": "Visualizar e explicar como o não-determinismo cria ramificações paralelas.",
                                  "commonMistakes": "Confundir com paralelismo real; enfatize que é conceitual para definição de linguagem."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir aceitação e rejeição em MTN",
                                  "subSteps": [
                                    "Defina aceitação: MTN aceita se EXISTE pelo menos UM caminho que alcança estado de aceitação.",
                                    "Defina rejeição: só se TODOS os caminhos rejeitam (alcançam rejeição ou loop infinito).",
                                    "Simule um exemplo onde um caminho aceita e outro rejeita, mostrando aceitação geral.",
                                    "Discuta halting: assumimos sem loops infinitos para fins teóricos.",
                                    "Compare com MT: aceitação é unívoca vs. existencial em MTN."
                                  ],
                                  "verification": "Para uma MTN exemplo, determine corretamente aceitação/rejeição justificando com caminhos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Exemplos de fitas, quadro para simulação.",
                                  "tips": "Lembre: 'existe um caminho bom' é a chave, não 'todos os caminhos'.",
                                  "learningObjective": "Compreender a semântica existencial da aceitação em MTN.",
                                  "commonMistakes": "Achar que aceitação requer maioria de caminhos; é 'qualquer um'."
                                }
                              ],
                              "practicalExample": "Considere uma MTN que verifica se uma string binária tem um '1' em posição par. Em um estado q lendo '0' em posição par, ramifica: uma vai para aceitação imediata (supondo '1' possível), outra continua lendo. Simule em '1010': múltiplos caminhos, mas um aceita se houver '1' par.",
                              "finalVerifications": [
                                "Diferencie corretamente MT (transição única) de MTN (múltiplas).",
                                "Desenhe árvore de ramificações para uma MTN simples.",
                                "Explique aceitação como 'existe caminho aceitador'.",
                                "Simule computação de MTN sem erros em exemplo dado.",
                                "Compare poder computacional: MTN simula MT, mas não vice-versa.",
                                "Identifique não-determinismo em pseudocódigo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de MTN vs. MT (90% correto).",
                                "Clareza na explicação de ramificações paralelas (com diagrama).",
                                "Correta semântica de aceitação existencial.",
                                "Uso de exemplos concretos e simulações sem falhas.",
                                "Diferenciação conceitual profunda, não superficial.",
                                "Ausência de confusão com modelos probabilísticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (árvore de computação como grafo de caminhos).",
                                "Filosofia: Lógica Modal (possibilidade: 'existe caminho').",
                                "Física: Computação Quântica (superposição similar a não-determinismo).",
                                "Engenharia de Software: Backtracking em algoritmos (exploração de ramificações)."
                              ],
                              "realWorldApplication": "O não-determinismo modela problemas NP, como Caixeiro Viajante, onde verificadores não-determinísticos simulam 'adivinhação' de soluções ótimas, essencial para entender heurísticas e aproximações em otimização prática."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.1.2",
                        "name": "Tempo de Execução em Máquinas Não-Determinísticas",
                        "description": "Medida de tempo para MTN: o tempo de uma computação é o número de passos em um caminho, e o tempo da máquina é o máximo sobre todas as computações possíveis em entradas de tamanho n.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.2.1",
                            "name": "Definir tempo polinomial para MTN",
                            "description": "Formalizar que uma MTN M roda em tempo polinomial se existe k tal que para toda entrada w de tamanho n, toda computação de M em w tem no máximo n^k passos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Máquinas de Turing Não-Determinísticas (MTN)",
                                  "subSteps": [
                                    "Relembre a definição formal de uma MTN: conjunto de estados Q, alfabeto de fita Γ, função de transição δ: Q × Γ → conjunto finito de (Q × Γ × {L,R,N}), etc.",
                                    "Entenda as ramificações não-determinísticas: em cada passo, a MTN pode escolher uma transição válida aleatoriamente.",
                                    "Diferencie aceitação em MTN: existe pelo menos um caminho de computação que aceita a entrada.",
                                    "Revise o conceito de comprimento de entrada n = |w| e o número de passos em uma computação.",
                                    "Estude diagramas de configuração de MTN para visualizar ramificações."
                                  ],
                                  "verification": "Escreva um resumo de 5 frases definindo MTN e dê um exemplo simples de transição não-determinística.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser ou similar), notas de aula sobre MTN, quadro branco para diagramas.",
                                  "tips": "Desenhe árvores de computação para visualizar não-determinismo; foque em como múltiplos caminhos coexistem.",
                                  "learningObjective": "Compreender os fundamentos de MTN para contextualizar tempo de execução.",
                                  "commonMistakes": "Confundir MTN com MTD (determinística); ignorar que aceitação requer apenas um caminho aceitador."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Tempo de Execução em MTN",
                                  "subSteps": [
                                    "Defina uma computação de MTN em w: sequência de configurações começando da inicial até rejeição ou aceitação.",
                                    "Meça o tempo de uma computação específica: número de passos até halting (aceitar ou rejeitar).",
                                    "Note que para MTN, o tempo é definido pelo comprimento máximo sobre todas as computações possíveis em w.",
                                    "Discuta por que usamos 'toda computação' em vez de 'alguma': garante bound uniforme para análise de complexidade.",
                                    "Calcule exemplos manuais: para |w|=3, liste todas as computações e seus comprimentos."
                                  ],
                                  "verification": "Para uma MTN simples, liste 3 computações em uma entrada de tamanho 2 e compute seus tempos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador de MTN online (ex: JFLAP), papel e lápis para simulações manuais.",
                                  "tips": "Sempre considere o pior caso entre ramificações para bound superior preciso.",
                                  "learningObjective": "Dominar como medir e comparar tempos de computação em contextos não-determinísticos.",
                                  "commonMistakes": "Medir apenas o caminho aceitador curto, ignorando caminhos longos que rejeitam."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir e Formalizar Tempo Polinomial para MTN",
                                  "subSteps": [
                                    "Defina informalmente: MTN roda em tempo polinomial se o tempo máximo é bounded por um polinômio em n.",
                                    "Especifique: existe constante k tal que para toda w com |w|=n, toda computação tem ≤ n^k passos.",
                                    "Escreva a definição formal: M é polinomial se ∃k ∈ ℕ ∀w (|w|=n → max{ passos em computações de M em w } ≤ n^k).",
                                    "Compare com tempo determinístico: similar, mas aplica a todas as ramificações.",
                                    "Prove trivial: toda MTN para em tempo polinomial se k grande o suficiente para estados e fita."
                                  ],
                                  "verification": "Escreva a definição formal exata e justifique por que 'toda computação' é crucial.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Folha de fórmulas de complexidade, LaTeX ou editor de texto para formalizações.",
                                  "tips": "Use notação ∀w, |w|=n para clareza; memorize o quantificador 'existe k tal que para toda w'.",
                                  "learningObjective": "Formalizar precisamente a definição de tempo polinomial em MTN.",
                                  "commonMistakes": "Escrever 'existe computação em n^k' em vez de 'toda computação ≤ n^k'; confundir com espaço polinomial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar a Definição",
                                  "subSteps": [
                                    "Construa uma MTN para um problema simples (ex: A(w) se w é palíndromo par) e analise seu tempo polinomial.",
                                    "Verifique se k=2 basta: simule para n=1 a 5 e confirme bound.",
                                    "Discuta implicações: MTNs polinomiais definem NP via simulação por MTD em tempo exponencial.",
                                    "Resolva exercício: dada MTN, prove se é ou não polinomial.",
                                    "Crie contraexemplo: MTN que força caminhos longos além de polinômio."
                                  ],
                                  "verification": "Analise uma MTN exemplo e determine o menor k para tempo polinomial.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Exemplos de MTN de livros/textos, simulador JFLAP.",
                                  "tips": "Conte passos explicitamente em simulações; aumente k gradualmente até cobrir todos os caminhos.",
                                  "learningObjective": "Aplicar a definição para classificar MTNs e entender sua relevância para NP.",
                                  "commonMistakes": "Assumir que não-determinismo permite tempos menores sem bound em todas as ramificações."
                                }
                              ],
                              "practicalExample": "Considere uma MTN M que aceita linguagens regulares via guess de estado inicial. Para w de tamanho n, todas as ramificações exploram no máximo n^3 passos (k=3), pois fita cresce linearmente e estados finitos limitam profundidade.",
                              "finalVerifications": [
                                "Escreva a definição formal de tempo polinomial para MTN sem erros.",
                                "Dado uma MTN e w, compute o tempo máximo sobre todas computações.",
                                "Identifique se uma MTN dada roda em tempo polinomial e justifique k.",
                                "Explique diferença entre tempo de uma computação e tempo da máquina.",
                                "Prove que toda MTN trivialmente para em tempo polinomial com k grande.",
                                "Relacione com NP: L ∈ NP se existe MTN polinomial para L."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formalização: quantificadores corretos (∃k ∀w ... ≤ n^k).",
                                "Compreensão conceitual: distinção clara entre 'toda computação' e caminhos individuais.",
                                "Aplicação prática: análise correta de exemplos com bounds polinomiais.",
                                "Raciocínio lógico: justificativa de por que bound uniforme é necessário.",
                                "Clareza na comunicação: definições escritas de forma legível e concisa.",
                                "Conexão com teoria: menção correta ao papel em definições de NP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica de polinômios (O(n^k)) e quantificadores lógicos.",
                                "Algoritmos: Comparação com análise de tempo em algoritmos não-determinísticos simulados.",
                                "Lógica: Uso de ∀ e ∃ em definições formais semelhantes a axiomas.",
                                "Física/Quântica: Paralelos com computação quântica e superposição (não-determinismo)."
                              ],
                              "realWorldApplication": "Essa definição é fundamental para provar que problemas NP-completos como SAT têm solucionadores não-determinísticos eficientes em teoria, guiando heurísticas em software de verificação (ex: SAT solvers em VLSI design e scheduling otimização)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.8.1.2.2",
                            "name": "Calcular tempo de execução em exemplo simples",
                            "description": "Dado uma MTN específica e entrada, determinar o tempo máximo de execução e verificar se é polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Formal de MTN e Tempo de Execução",
                                  "subSteps": [
                                    "Revise a estrutura de uma MTN: conjunto de estados Q, alfabeto de fita Γ, função de transição δ: Q × Γ → 2^{Q × Γ × {L,R,N}}, configuração inicial (q0, w, posição 0).",
                                    "Entenda que uma computação é uma árvore onde cada nó é uma configuração e arestas são transições não-determinísticas.",
                                    "Defina o tempo de execução T_M(w) como o comprimento máximo de qualquer caminho na árvore de computação (aceitador ou rejeitador) para entrada w.",
                                    "Aprenda que para L ∈ NP, existe MTN com T(n) polinomial."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito a árvore de computação para uma MTN trivial com 2 transições ND.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de MTN exemplo",
                                    "Papel e caneta para desenhar árvore"
                                  ],
                                  "tips": "Comece com uma MTN com apenas 2 ramificações para visualizar a árvore.",
                                  "learningObjective": "Dominar os conceitos teóricos de configuração, árvore de computação e medida de tempo máximo em MTNs.",
                                  "commonMistakes": "Ignorar caminhos rejeitadores no cálculo do tempo máximo; confundir tempo de aceitação com tempo máximo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a MTN Específica e Preparar a Entrada",
                                  "subSteps": [
                                    "Liste todos os estados Q, símbolos Γ, transições δ da MTN dada.",
                                    "Escreva a configuração inicial: cabeçote em posição 0, fita com entrada w#... (onde # é blank).",
                                    "Identifique o número de ramificações possíveis por configuração (branching factor).",
                                    "Calcule o tamanho n = |w| e anote possíveis bounds iniciais para T(n)."
                                  ],
                                  "verification": "Crie um diagrama da MTN com todas transições e configuração inicial anotada corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Descrição da MTN",
                                    "Ferramenta de desenho como Draw.io ou papel"
                                  ],
                                  "tips": "Numere as transições ND para rastreamento fácil (ex: δ1, δ2).",
                                  "learningObjective": "Preparar todos os elementos necessários para simulação precisa da execução.",
                                  "commonMistakes": "Esquecer blanks na fita infinita; não anotar posições exatas do cabeçote."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular a Execução Não-Determinística Passo a Passo",
                                  "subSteps": [
                                    "Use busca em largura (BFS) ou profundidade para explorar a árvore de computação, rastreando configurações únicas.",
                                    "Para cada configuração, aplique todas transições δ e gere filhos, registrando o passo atual.",
                                    "Continue até todos caminhos terminarem em qacc/qrej ou loop detectado (mas foque em halting).",
                                    "Registre o comprimento de cada caminho e identifique o máximo."
                                  ],
                                  "verification": "Desenhe ou liste a árvore completa de computação com comprimentos de caminhos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou software para simulação (ex: Python simples ou papel quadriculado)"
                                  ],
                                  "tips": "Use conjuntos para evitar revisitar configurações idênticas e prevenir explosão.",
                                  "learningObjective": "Executar simulação completa de MTN, gerenciando não-determinismo.",
                                  "commonMistakes": "Parar em caminhos aceitadores cedo; duplicar configurações sem hash/check."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar Tempo Máximo e Verificar Polinomialidade",
                                  "subSteps": [
                                    "Identifique o comprimento máximo de qualquer caminho na árvore simulada: T(w) = max passos.",
                                    "Expresse T(n) em termos de n=|w|, ex: contar operações O(n^k).",
                                    "Verifique se T(n) é polinomial: existe k tal que T(n) ≤ n^k para n grande? Compare com exemplos NP.",
                                    "Conclua se a MTN roda em tempo polinomial."
                                  ],
                                  "verification": "Escreva T(w) exato e assintótico, com justificativa se polinomial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resultados da simulação do step 3",
                                    "Tabela de complexidades polinomiais"
                                  ],
                                  "tips": "Para polinomial, cheque se max path é O(n^c) baseado em #estados e |Γ| fixos.",
                                  "learningObjective": "Analisar complexidade temporal de MTNs e classificar em polinomial.",
                                  "commonMistakes": "Confundir tempo médio com máximo; superestimar sem bound claro."
                                }
                              ],
                              "practicalExample": "Considere MTN M para L = {w ∈ {0,1}^* | w tem pelo menos um '1'}: Q={q0,qg,qc,qacc,qrej}, δ(q0,σ)=(qg,X,R) ou (q0,σ,R) para σ∈{0,1} (adivinha posição). Em qg move para posição atual, qcheck se 1→qacc senão qrej. Para w=00 (n=2), árvore: path1: sempre R até blank (4 passos); path2: adivinha pos1, check 0→rej (3 passos); path3: pos2, check 0→rej (5 passos max). T(00)=5 = O(n). Polinomial sim.",
                              "finalVerifications": [
                                "Árvore de computação completa sem erros.",
                                "Tempo máximo T(w) calculado corretamente para todas entradas testadas.",
                                "Classificação polinomial justificada com bound O(n^k).",
                                "Simulação halting em todos caminhos.",
                                "Explicação coerente da não-determinismo impacto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na simulação (100% caminhos cobertos): 30%.",
                                "Correção do T_max e análise assintótica: 25%.",
                                "Visualização clara da árvore: 20%.",
                                "Verificação polinomial rigorosa: 15%.",
                                "Eficiência na simulação (sem loops desnecessários): 10%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Exploração de árvores e grafos direcionados (teoria dos grafos).",
                                "Física: Analogia com superposição quântica em computação quântica.",
                                "Engenharia de Software: Verificação de modelos não-determinísticos em testes unitários.",
                                "Estatística: Análise de caminhos probabilísticos em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em verificadores NP para problemas como SAT ou TSP, onde simular MTN polinomial permite decidir membership em tempo polinomial, usado em solvers como MiniSat para otimização combinatorial em IA e logística."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.8.1.2.3",
                            "name": "Relacionar tempo NTM com classes de tempo",
                            "description": "Explicar TIME_NTM(f(n)) como o conjunto de linguagens reconhecidas por alguma MTN em tempo O(f(n)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Máquinas de Turing Não-Determinísticas (MTN)",
                                  "subSteps": [
                                    "Relembre a definição de uma MTN: uma MT que pode ter múltiplas transições possíveis para o mesmo estado e símbolo, criando ramos de computação não-determinísticos.",
                                    "Entenda o conceito de aceitação: uma entrada é aceita se existe pelo menos um caminho de computação que aceita.",
                                    "Defina tempo de execução em MTN: o tempo máximo sobre todos os caminhos possíveis até a aceitação ou rejeição.",
                                    "Compare com MT determinísticas (MTD): MTN podem ser mais 'poderosas' em termos de tempo devido à não-determinização.",
                                    "Estude a simulação de MTN por MTD: uma MTD pode simular uma MTN em tempo exponencial."
                                  ],
                                  "verification": "Resuma em suas palavras a diferença entre tempo de MTN e MTD, e liste 3 exemplos de linguagens reconhecidas por MTN.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Teoria da Computação (Sipser ou similar), notas de aula sobre autômatos, quadro branco para diagramas.",
                                  "tips": "Desenhe diagramas de MTN simples para visualizar ramos não-determinísticos.",
                                  "learningObjective": "Compreender os mecanismos básicos de MTN e sua medida de tempo de execução.",
                                  "commonMistakes": "Confundir aceitação (existe um caminho) com todos os caminhos aceitarem; ignorar o tempo máximo sobre caminhos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente TIME_NTM(f(n))",
                                  "subSteps": [
                                    "Defina TIME_NTM(f(n)) como o conjunto de linguagens L ⊆ {0,1}* tais que existe uma MTN M que reconhece L e para toda entrada x ∈ L, M aceita x em tempo O(f(|x|)).",
                                    "Esclareça que o tempo é medido pelo número máximo de passos em qualquer ramo de computação.",
                                    "Discuta a notação O(f(n)): tempo assintótico superior, onde n = |x|.",
                                    "Prove informalmente que TIME_NTM(f(n)) ⊆ TIME_DTM(c * f(n)) para alguma constante c, devido à simulação.",
                                    "Explore propriedades: TIME_NTM(f(n)) é fechado sob união e concatenação sob certas condições."
                                  ],
                                  "verification": "Escreva a definição formal de TIME_NTM(f(n)) e prove que uma linguagem simples como {a^n b^n} está em TIME_NTM(n^2).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Pseudocódigo de MTN, calculadora para análise assintótica, referências formais (Hopcroft/Ullman).",
                                  "tips": "Use notação matemática precisa: ∀x ∈ L, tempo(M,x) ≤ k*f(|x|) para alguma k.",
                                  "learningObjective": "Dominar a definição precisa e notação de classes de tempo não-determinísticas.",
                                  "commonMistakes": "Confundir O(f(n)) com tempo exato; esquecer que é o máximo sobre caminhos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar TIME_NTM com Classes de Tempo Determinísticas",
                                  "subSteps": [
                                    "Estabeleça que P = ∪_{k} TIME_DTM(n^k) e NP = ∪_{k} TIME_NTM(n^k).",
                                    "Explique por que NP captura problemas 'fáceis de verificar': não-determinismo modela adivinhação + verificação polinomial.",
                                    "Discuta TIME_NTM(n^k) ⊆ TIME_DTM(2^{O(n^k)}), via simulação por busca em árvore.",
                                    "Analise implicações: P ⊆ NP, e se P = NP é aberto.",
                                    "Compare com SPACE_NTM para hierarquias."
                                  ],
                                  "verification": "Construa uma tabela comparando TIME_NTM(f(n)) com TIME_DTM(f(n)) para f(n) = n, n^2, 2^n.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabela comparativa em planilha, artigos sobre P vs NP, simulador de MT online.",
                                  "tips": "Pense em NP como 'poder de adivinhação' limitada a tempo polinomial.",
                                  "learningObjective": "Conectar classes não-determinísticas com as determinísticas padrão como P e NP.",
                                  "commonMistakes": "Achar que TIME_NTM(n^k) = TIME_DTM(n^k); subestimar o custo exponencial da simulação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar com Exemplos",
                                  "subSteps": [
                                    "Exemplo: Mostre que SAT ∈ TIME_NTM(n^3) via adivinhação de atribuição + verificação.",
                                    "Crie uma MTN para 3-SAT em tempo polinomial não-determinístico.",
                                    "Analise por que SAT ∉ TIME_DTM(n^k) se P ≠ NP.",
                                    "Generalize para outras linguagens NP-completas como Clique ou Hamiltoniano.",
                                    "Teste com contraexemplos: linguagens regulares em TIME_NTM(O(1))."
                                  ],
                                  "verification": "Implemente pseudocódigo de MTN para um problema NP e calcule seu tempo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de texto para pseudocódigo, exemplos de problemas NP do CLRS.",
                                  "tips": "Sempre quantifique o tempo O(f(n)) com uma constante explícita.",
                                  "learningObjective": "Aplicar o conceito a problemas concretos e validar relações.",
                                  "commonMistakes": "Ignorar o overhead na verificação do certificado; confundir reconhecimento com decisão."
                                }
                              ],
                              "practicalExample": "Para provar que o problema SAT (Satisfiability) está em NP: construa uma MTN que, não-determinísticamente, gera uma atribuição de variáveis em O(n) passos, então verifica se satisfaz a fórmula 3-CNF em O(n^3) passos totais, colocando SAT em TIME_NTM(n^3).",
                              "finalVerifications": [
                                "Defina corretamente TIME_NTM(f(n)) sem erros na notação assintótica.",
                                "Explique a relação P ⊆ NP via TIME_DTM ⊆ TIME_NTM.",
                                "Forneça um exemplo de linguagem em TIME_NTM(n^2) não trivial.",
                                "Discuta o custo da simulação determinística.",
                                "Identifique se uma dada MTN opera em tempo O(f(n)).",
                                "Compare com classes espaciais como NSPACE."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal e notação O(f(n)).",
                                "Correta distinção entre tempo não-determinístico e determinístico.",
                                "Capacidade de construir exemplos com MTN e análise de tempo.",
                                "Compreensão das implicações para P vs NP.",
                                "Identificação de erros comuns em provas de inclusão.",
                                "Uso apropriado de hierarquias de tempo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções assintóticas (Big-O).",
                                "Lógica: Fórmulas proposicionais e tautologias em SAT.",
                                "Algoritmos: Verificação de certificados em otimização combinatória.",
                                "Filosofia da Computação: Limites da computação e decidibilidade."
                              ],
                              "realWorldApplication": "Essa relação é fundamental para entender problemas NP-completos como escalonamento de tarefas, roteamento de veículos e criptografia, permitindo algoritmos heurísticos e aproximações em IA e otimização industrial onde soluções exatas são intratáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.1.3",
                        "name": "Definição Formal da Classe NP",
                        "description": "Classe NP como a união sobre k de TIME_NTM(n^k), ou seja, linguagens decidíveis por MTN em tempo polinomial.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.3.1",
                            "name": "Enunciar a definição formal de NP",
                            "description": "Escrever NP = ∪_{k≥1} TIME_NTM(n^k), onde TIME_NTM(f(n)) é o conjunto de linguagens L ⊆ Σ* tais que existe MTN M que decide L com tempo de execução ≤ f(n) para |w|=n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de Máquinas de Turing Não-determinísticas (NTM)",
                                  "subSteps": [
                                    "Estude a definição formal de uma Máquina de Turing Não-determinística (MTN), incluindo configuração inicial, transições múltiplas e aceitação/rejeição.",
                                    "Compare MTN com MT determinística, destacando o paralelismo não-determinístico.",
                                    "Revise o conceito de tempo de execução para MTN: o tempo é medido pelo comprimento da menor cadeia de computação aceitadora.",
                                    "Examine exemplos simples de MTN reconhecendo linguagens regulares ou de contexto livre.",
                                    "Anote as diferenças chave em relação ao tempo determinístico."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre MT e MTN, com um exemplo de transição não-determinística.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Notas de aula sobre Autômatos",
                                    "Vídeo tutorial sobre MTN no YouTube"
                                  ],
                                  "tips": "Use diagramas para visualizar ramos não-determinísticos; foque no menor caminho aceitador.",
                                  "learningObjective": "Compreender o funcionamento fundamental das MTN e sua medida de tempo.",
                                  "commonMistakes": "Confundir tempo de MTN com o pior caso determinístico; ignorar que aceitação requer pelo menos um caminho aceitador."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a classe de tempo TIME_NTM(f(n))",
                                  "subSteps": [
                                    "Defina formalmente TIME_NTM(f(n)) como {L ⊆ Σ* | ∃ MTN M que decide L com tempo ≤ f(n) para toda entrada w com |w|=n}.",
                                    "Esclareça que 'decide' significa aceitar w ∈ L e rejeitar w ∉ L.",
                                    "Discuta o papel do alfabeto Σ* e da medida de tamanho n = |w|.",
                                    "Forneça um exemplo: TIME_NTM(n) inclui linguagens decidíveis em tempo linear por MTN.",
                                    "Prove informalmente que TIME_NTM(f(n)) ⊆ TIME_DTM(O(f(n)^2)) pela simulação."
                                  ],
                                  "verification": "Escreva a definição exata de TIME_NTM(f(n)) e dê um exemplo de linguagem nela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel para anotações",
                                    "Referência: Arora & Barak 'Computational Complexity'",
                                    "Simulador online de Turing Machines"
                                  ],
                                  "tips": "Memorize a notação exata: L ⊆ Σ*, MTN M, tempo ≤ f(n).",
                                  "learningObjective": "Dominar a definição precisa da classe de tempo para MTN.",
                                  "commonMistakes": "Esquecer '∃ MTN M' ou usar 'para todo caminho' em vez de 'pelo menos um caminho aceitador'."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a união para tempos polinomiais",
                                  "subSteps": [
                                    "Entenda a união ∪_{k≥1} como a coleção de todas as classes TIME_NTM(n^k) para k=1,2,...",
                                    "Explique por que k≥1 cobre todos os polinômios: qualquer polinômio p(n) ≤ n^k para algum k.",
                                    "Escreva NP = ∪_{k≥1} TIME_NTM(n^k) e justifique o foco em polinômios.",
                                    "Discuta propriedades: fechada sob união, complemento não necessariamente.",
                                    "Compare com P = ∪_{k≥1} TIME_DTM(n^k)."
                                  ],
                                  "verification": "Escreva a expressão da união e explique por que ela define 'tempo polinomial não-determinístico'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro branco ou papel",
                                    "Artigo sobre Complexidade Computacional (Wikipedia NP)",
                                    "Exercícios de livro-texto"
                                  ],
                                  "tips": "Pense em k como grau do polinômio; pratique escrevendo o símbolo ∪ corretamente.",
                                  "learningObjective": "Compreender como a união captura a classe polinomial NP.",
                                  "commonMistakes": "Usar k finito fixo em vez de ∪_{k≥1}; confundir com EXP ou outras classes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enunciar e praticar a definição completa de NP",
                                  "subSteps": [
                                    "Combine tudo: NP = ∪_{k≥1} TIME_NTM(n^k), onde TIME_NTM(f(n)) = {L ⊆ Σ* | ∃ MTN M decide L em ≤ f(n)}.",
                                    "Escreva a definição 5 vezes de memória, variando o formato (com ou sem 'onde').",
                                    "Teste com perguntas: 'O que é NP?', 'Dê a def. formal'.",
                                    "Relacione com verificadores: NP como linguagens com certificados polinomiais.",
                                    "Crie flashcards com a definição para revisão."
                                  ],
                                  "verification": "Enuncie a definição completa sem consultar materiais e corrija erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Flashcards Anki ou Quizlet",
                                    "Gravador de voz para autoavaliação",
                                    "Companheiro de estudo para quizz"
                                  ],
                                  "tips": "Fale em voz alta para fixar; associe a problemas como SAT.",
                                  "learningObjective": "Enunciar fluentemente a definição formal de NP.",
                                  "commonMistakes": "Omitir 'L ⊆ Σ*' ou inverter o quantificador ∃; usar DTM em vez de NTM."
                                }
                              ],
                              "practicalExample": "Para a linguagem SAT (satisfatibilidade booleana), existe uma MTN que adivinha uma atribuição (não-determinismo) e verifica em tempo polinomial O(n), colocando SAT em TIME_NTM(n^2) ⊆ NP. Enuncie: 'SAT ∈ NP pois ∃ MTN que decide em tempo O(n^2)'.",
                              "finalVerifications": [
                                "Enuncie a definição completa sem erros em menos de 30 segundos.",
                                "Explique TIME_NTM(f(n)) com um exemplo simples.",
                                "Justifique por que NP usa união sobre k≥1.",
                                "Distinga NP de P formalmente.",
                                "Responda corretamente a 5 perguntas quizz sobre a definição."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (∪, ⊆, ∃, ≤ f(n)).",
                                "Correta explicação de MTN e tempo de execução.",
                                "Uso apropriado de termos: decide, aceita/rejeita.",
                                "Capacidade de relacionar com exemplos como SAT ou GRAPH-COLORING.",
                                "Fluência na memorização e recitação.",
                                "Identificação de erros comuns em definições alternativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (união, subconjuntos) e funções polinomiais.",
                                "Lógica: Quantificadores existenciais (∃) e predicados.",
                                "Filosofia da Computação: Limites da computação e decidibilidade.",
                                "Algoritmos: Verificadores polinomiais como dual da definição."
                              ],
                              "realWorldApplication": "A definição de NP é fundamental para classificar problemas como o Caixeiro Viajante ou Fatoração (base da criptografia RSA), permitindo algoritmos de aproximação e heurísticas em otimização industrial, IA e segurança cibernética."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.2.3"
                            ]
                          },
                          {
                            "id": "10.1.8.1.3.2",
                            "name": "Provar que uma linguagem está em NP",
                            "description": "Construir uma MTN que decide uma linguagem específica (ex: SAT) em tempo polinomial e argumentar a complexidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de NP e MTN",
                                  "subSteps": [
                                    "Revise a definição formal da classe NP: uma linguagem L está em NP se existe uma MTN M que decide L em tempo polinomial.",
                                    "Estude o funcionamento de Máquinas de Turing Não-determinísticas (MTN): branches não-determinísticos e aceitação se pelo menos um caminho aceita.",
                                    "Analise o conceito de tempo polinomial em MTN: o comprimento da entrada n, tempo O(p(n)) para polinômio p.",
                                    "Identifique exemplos clássicos como SAT e entenda por que eles são candidatos a NP.",
                                    "Diferencie verificadores determinísticos de não-determinísticos."
                                  ],
                                  "verification": "Resuma em suas palavras a definição de NP e desenhe um diagrama simples de uma MTN básica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre Teoria da Computação",
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (capítulos relevantes)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use diagramas de transição para visualizar branches não-determinísticos.",
                                  "learningObjective": "Dominar os pré-requisitos teóricos para construir provas de membership em NP.",
                                  "commonMistakes": "Confundir tempo de MTN com tempo de TM determinística; ignorar o papel do não-determinismo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e analisar a linguagem específica (ex: SAT)",
                                  "subSteps": [
                                    "Defina formalmente a linguagem SAT: {φ | φ é uma fórmula booleana em 3-CNF que é satisfatível}.",
                                    "Descreva a estrutura de uma instância de entrada: fórmula em CNF com cláusulas e variáveis.",
                                    "Explique o problema de decisão: dada φ, SAT aceita se existe uma atribuição de valores verdadeiros/falsos que satisfaz todas as cláusulas.",
                                    "Identifique o certificado (witness): uma atribuição de variáveis que satisfaz φ.",
                                    "Estime o tamanho do certificado: O(n), onde n é o número de variáveis."
                                  ],
                                  "verification": "Escreva a definição formal de SAT e um exemplo de fórmula satisfatível e insatisfatível.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de fórmulas SAT online ou em livros",
                                    "Editor de texto para escrever fórmulas"
                                  ],
                                  "tips": "Comece com fórmulas pequenas para testar intuição.",
                                  "learningObjective": "Entender a estrutura do problema para guiar a construção da MTN.",
                                  "commonMistakes": "Confundir SAT com 3-SAT ou ignorar a forma CNF normalizada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a MTN que decide a linguagem em tempo polinomial",
                                  "subSteps": [
                                    "Desenhe a MTN M_SAT: na branch não-determinística, gere uma atribuição aleatória para todas as variáveis (usando não-determinismo).",
                                    "Implemente o verificador determinístico: para cada cláusula, cheque se pelo menos uma literal é satisfeita pela atribuição.",
                                    "Defina as transições da fita: entrada φ na fita, atribuição gerada em outra fita auxiliar.",
                                    "Garanta rejeição se alguma cláusula não for satisfeita; aceite só se todas forem.",
                                    "Especifique o alfabeto, estados e função de transição de alto nível."
                                  ],
                                  "verification": "Desenhe o diagrama de alto nível da MTN e simule manualmente em uma fórmula pequena.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io ou papel",
                                    "Simulador de MTN online (opcional)"
                                  ],
                                  "tips": "Pense na MTN como 'adivinhador + verificador': não-determinismo adivinha, determinismo verifica.",
                                  "learningObjective": "Criar uma máquina formal que captura a essência do não-determinismo polinomial.",
                                  "commonMistakes": "Fazer a MTN buscar todas as atribuições (isso seria exponencial); esquecer de copiar a entrada para verificação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Argumentar a complexidade temporal e formalizar a prova",
                                  "subSteps": [
                                    "Analise o tempo de cada branch: geração de atribuição O(n), verificação de m cláusulas O(m * k) onde k=3 para 3-CNF, total O(n + m).",
                                    "Prove que m e n são polinomiais no tamanho da entrada |φ|.",
                                    "Escreva a prova formal: 'SAT ∈ NP pois existe MTN M_SAT com tempo O(|φ|^c) para alguma constante c.'",
                                    "Discuta correção: aceita sim se satisfatível (pelo menos uma branch), rejeita insatisfatíveis (todas rejeitam).",
                                    "Inclua análise de espaço se relevante, mas foque em tempo."
                                  ],
                                  "verification": "Escreva um parágrafo formal provando SAT ∈ NP e calcule o polinômio exato.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Modelo de prova de livros texto",
                                    "Calculadora para estimar graus polinomiais"
                                  ],
                                  "tips": "Conte o número de passos em cada sub-rotina para bound preciso.",
                                  "learningObjective": "Formalizar argumentos de complexidade para membership em NP.",
                                  "commonMistakes": "Subestimar o tempo de verificação de cláusulas; confundir tempo de branch com tempo total."
                                }
                              ],
                              "practicalExample": "Para provar SAT ∈ NP: MTN lê fórmula φ em 3-CNF com n vars e m cláusulas. Não-determinísticamente gera atribuição binária de n bits. Verifica cada cláusula: para cada uma das 3 literais, checa se matches a atribuição. Aceita se todas cláusulas OK. Tempo: O(n + 3m) = O(|φ|).",
                              "finalVerifications": [
                                "A MTN aceita exatamente as fórmulas satisfatíveis.",
                                "O tempo polinomial é explicitamente calculado e bounded.",
                                "Correção de aceitação e rejeição argumentada.",
                                "Diagrama ou pseudocódigo da MTN completo.",
                                "Prova escrita em formato formal matemático.",
                                "Exemplo concreto simulado com entrada pequena."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na descrição da MTN (estados, transições).",
                                "Correção da análise temporal (polinômio demonstrado).",
                                "Profundidade dos substeps e verificações intermediárias.",
                                "Formalidade da prova final.",
                                "Uso correto de não-determinismo vs. determinismo.",
                                "Ausência de erros conceituais em definições."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Proposicional: satisfatibilidade e CNF.",
                                "Matemática Discreta: contagem polinomial e big-O.",
                                "Algoritmos: solvers SAT como DPLL.",
                                "Inteligência Artificial: problemas NP-completos em planejamento.",
                                "Criptografia: base para provas de redução."
                              ],
                              "realWorldApplication": "Provas de NP são fundamentais para mostrar que problemas como SAT (usado em verificadores de hardware, planejamento de rotas, configuração de software) têm solucionadores eficientes em casos práticos, apesar da dureza teórica, impulsionando IA e otimização industrial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.8.1.3.3",
                            "name": "Comparar NP com P via NTM",
                            "description": "Explicar que P ⊆ NP, pois toda MTD em tempo polinomial pode ser vista como MTN, e discutir implicações da hipótese P ≠ NP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de P e NP",
                                  "subSteps": [
                                    "Defina a classe P como o conjunto de linguagens decidíveis por uma Máquina de Turing Determinística (MTD) em tempo polinomial.",
                                    "Defina a classe NP como o conjunto de linguagens decidíveis por uma Máquina de Turing Não-Determinística (MTN) em tempo polinomial.",
                                    "Explique o papel das MTN: elas podem 'adivinhar' soluções e verificá-las em tempo polinomial.",
                                    "Compare formalmente: P é decidibilidade determinística polinomial; NP é verificabilidade não-determinística polinomial.",
                                    "Estude exemplos: Problemas em P (ex: ordenação), candidatos a NP (ex: SAT)."
                                  ],
                                  "verification": "Escreva definições formais de P e NP em suas próprias palavras e liste 2 exemplos para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introduction to the Theory of Computation' de Sipser (Cap. 7), notas de aula sobre classes de complexidade.",
                                  "tips": "Use diagramas de Venn para visualizar P e NP; lembre que P está dentro de NP.",
                                  "learningObjective": "Compreender as definições precisas de P e NP usando modelos de Máquinas de Turing.",
                                  "commonMistakes": "Confundir NP com 'não-polinomial'; NP é polinomial na não-determinística."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar que P ⊆ NP via Simulação de MTD por MTN",
                                  "subSteps": [
                                    "Mostre que toda MTD em tempo polinomial T(n) pode ser simulada por uma MTN que segue o caminho único da MTD.",
                                    "Construa a MTN: em cada passo, ela executa exatamente a transição determinística da MTD, sem ramificações.",
                                    "Analise o tempo: a simulação leva O(T(n)) passos na MTN, que é polinomial.",
                                    "Formalize: Para qualquer L ∈ P, existe MTN M' que decide L em tempo polinomial.",
                                    "Verifique com pseudocódigo: descreva a transição δ' da MTN igual à δ da MTD."
                                  ],
                                  "verification": "Esboce a construção da MTN simuladora e prove que o tempo é preservado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis para diagramas de MT, vídeo-aula sobre simulação de DTMs por NTMs (ex: YouTube - Theory of Computation playlist).",
                                  "tips": "Pense na MTN como uma 'MTD disfarçada': sem adivinhação desnecessária.",
                                  "learningObjective": "Dominar a prova de inclusão P ⊆ NP através da simulação direta.",
                                  "commonMistakes": "Ignorar que a MTN não ramifica na simulação; ela é determinística na prática."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Direção Oposta: NP ⊈ P?",
                                  "subSteps": [
                                    "Discuta por que provar NP ⊆ P seria equivalente a P = NP.",
                                    "Apresente evidências empíricas: problemas NP-completos difíceis na prática.",
                                    "Explore reduções: SAT é NP-completo; se SAT ∈ P, então P = NP.",
                                    "Revise teorema de Cook-Levin para contexto de NP-completude.",
                                    "Debata: Não há prova conhecida de NP ⊆ P, apesar de décadas de pesquisa."
                                  ],
                                  "verification": "Liste 3 problemas NP-completos e explique por que sua resolução em P colapsaria as classes.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigo 'The Status of the P versus NP Problem' (Clay Mathematics Institute), quadro branco para reduções.",
                                  "tips": "Use analogias: P = problemas 'fáceis'; NP = 'fáceis de verificar, difíceis de resolver'.",
                                  "learningObjective": "Entender a assimetria entre P ⊆ NP (provado) e NP ⊆ P (aberto).",
                                  "commonMistakes": "Achar que P = NP é provado; é uma hipótese amplamente aceita como falsa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Implicações da Hipótese P ≠ NP",
                                  "subSteps": [
                                    "Se P ≠ NP: Otimização combinatorial é inerentemente difícil; algoritmos aproximados necessários.",
                                    "Impactos: Criptografia (ex: fatoração é NP-intermediário?), IA, logística.",
                                    "Se P = NP: Revolução em otimização, quebra de cripto assimétrica.",
                                    "Consequências filosóficas: Limites da computação eficiente.",
                                    "Pesquise status atual: Problema do Milênio, prêmio de US$1M."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo 3 implicações práticas de P ≠ NP.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Site Clay Mathematics Institute (P vs NP), podcast 'P vs NP implications'.",
                                  "tips": "Conecte a problemas reais: 'Por que roteirização de veículos é cara?'",
                                  "learningObjective": "Avaliar o impacto da hipótese na ciência da computação e além.",
                                  "commonMistakes": "Subestimar implicações: P=NP quebraria RSA instantaneamente."
                                }
                              ],
                              "practicalExample": "Considere o problema de ordenação de array (em P): Uma MTD bubble-sort roda em O(n²). Simule com MTN: ela segue o mesmo caminho determinístico, aceitando em tempo polinomial se ordenado corretamente. Para contraste, TSP (NP): MTN adivinha tour ótimo e verifica em O(n²).",
                              "finalVerifications": [
                                "Explicar verbalmente por que P ⊆ NP em menos de 2 minutos.",
                                "Construir simulação MTD → MTN para um problema toy como paridade.",
                                "Listar 3 implicações de P = NP vs P ≠ NP.",
                                "Identificar erros em uma prova falha de NP ⊆ P.",
                                "Desenhar diagrama de classes com P ⊆ NP.",
                                "Discutir um NP-completo e sua relação com P."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e prova de P ⊆ NP (30%)",
                                "Clareza na explicação de simulação MTD por MTN (25%)",
                                "Profundidade na discussão de implicações (20%)",
                                "Uso correto de terminologia teórica (15%)",
                                "Exemplos relevantes e verificáveis (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (problemas NP-completos como Hamiltoniano)",
                                "Filosofia: Limites do conhecimento e indecidibilidade (Gödel, Turing)",
                                "Economia: Otimização em cadeias de suprimento",
                                "Engenharia: Algoritmos aproximados em software embarcado"
                              ],
                              "realWorldApplication": "Na indústria de software, entender P ≠ NP guia o design de heurísticas para scheduling de jobs em data centers (ex: Google Cloud), evitando buscas exaustivas impossíveis, e fundamenta a segurança criptográfica em blockchains como Bitcoin."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.8.1.3.4",
                            "name": "Relacionar NP com verificadores polinomiais",
                            "description": "Mostrar equivalência entre definição via NTM e via máquina determinística que verifica certificados em tempo polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição de NP via Máquinas de Turing Não-Determinísticas (NTM)",
                                  "subSteps": [
                                    "Lembre-se que uma linguagem L está em NP se existe uma NTM M que decide L em tempo polinomial p(n).",
                                    "Entenda que a NTM pode ter múltiplos caminhos de computação, e aceita se pelo menos um caminho aceita.",
                                    "Estude exemplos como o problema SAT: uma NTM pode adivinhar uma atribuição e verificar em tempo polinomial.",
                                    "Anote as propriedades chave: tempo polinomial no pior caso para caminhos aceitantes.",
                                    "Compare com P, onde todas as NTMs determinísticas decidem em tempo polinomial."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases explicando NP via NTM e dê um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use diagramas de transição para visualizar ramos não-determinísticos.",
                                  "learningObjective": "Compreender formalmente a definição de NP usando NTMs.",
                                  "commonMistakes": "Confundir tempo polinomial de NTM com tempo de todos os caminhos (apenas um basta)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Definição de NP via Verificadores Polinomiais Determinísticos",
                                  "subSteps": [
                                    "Defina um verificador V como uma TM determinística que, dado (x, c) onde |c| ≤ p(|x|), aceita se x ∈ L e c é um certificado válido.",
                                    "Especifique que V roda em tempo polinomial q(n) em |x| + |c|.",
                                    "Exemplo: Para SAT, c é uma atribuição de variáveis; V verifica se satisfaz a fórmula.",
                                    "Note que para x ∉ L, V rejeita todos os certificados possíveis.",
                                    "Discuta o tamanho polinomial do certificado como essencial."
                                  ],
                                  "verification": "Descreva o algoritmo de um verificador para o problema Hamiltoniano.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pseudocódigo editor (ex: Notepad++)",
                                    "Exemplos de problemas NP-completos"
                                  ],
                                  "tips": "Pense no certificado como 'prova' que a NTM 'adivinha'.",
                                  "learningObjective": "Dominar a definição formal de NP usando máquinas verificadoras.",
                                  "commonMistakes": "Ignorar que o verificador deve rejeitar todos os certificados para x ∉ L."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que NP via NTM está Contido em NP via Verificador (NP_NTM ⊆ NP_V)",
                                  "subSteps": [
                                    "Dada NTM M decidindo L em tempo p(n), construa V que simula todos os caminhos de M usando c como descrição do caminho aceitante.",
                                    "Codifique o caminho aceitante em c (tamanho O(p(n)) bits).",
                                    "V simula deterministicamente o caminho especificado por c e aceita se leva a aceitação.",
                                    "Verifique que tempo de V é polinomial: simulação leva O(p(n)^2) ou similar.",
                                    "Confirme que para x ∈ L, existe c (o caminho aceitante); para x ∉ L, nenhum c funciona."
                                  ],
                                  "verification": "Esboce o pseudocódigo de V para uma NTM genérica.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Papel para desenhar construções de TMs",
                                    "Referência formal (ex: Arora-Barak)"
                                  ],
                                  "tips": "Use 'computação válida' para validar o caminho em c.",
                                  "learningObjective": "Construir a redução de NTM para verificador.",
                                  "commonMistakes": "Subestimar o tamanho de c ou tempo de simulação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar que NP via Verificador está Contido em NP via NTM (NP_V ⊆ NP_NTM)",
                                  "subSteps": [
                                    "Dado verificador V para L em tempo q(n), construa NTM M que não-deterministicamente gera c de tamanho p(n) = q(n).",
                                    "M adivinha c bit a bit em tempo polinomial.",
                                    "Em seguida, M roda V em (x, c).",
                                    "Aceita se V aceita; tempo total polinomial pois adivinhação e verificação são polinomiais.",
                                    "Para x ∈ L, existe caminho (bom c); para x ∉ L, todos rejeitam."
                                  ],
                                  "verification": "Descreva a NTM M e calcule seu tempo de execução.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Diagrama de NTM",
                                    "Calculadora para análise de tempo"
                                  ],
                                  "tips": "A não-determinização é só para gerar c; o resto é determinístico.",
                                  "learningObjective": "Construir a redução de verificador para NTM.",
                                  "commonMistakes": "Esquecer que geração de c é não-determinística e paralela."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir e Verificar a Equivalência das Definições",
                                  "subSteps": [
                                    "Combine as duas inclusões para mostrar NP_NTM = NP_V.",
                                    "Discuta implicações: ambas definições capturam problemas 'verificáveis rapidamente'.",
                                    "Teste com exemplo: mostre para 3-SAT como ambas se aplicam.",
                                    "Resuma teorema: 'L ∈ NP iff existe verificador polinomial'.",
                                    "Reflita sobre por que isso é útil (ex: sem necessidade de simular não-determinismo)."
                                  ],
                                  "verification": "Escreva uma prova completa em 1 página.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Resumo anterior dos steps 1-4"
                                  ],
                                  "tips": "Use setas bidirecionais para visualizar ⊆ e ⊇.",
                                  "learningObjective": "Internalizar a equivalência e suas consequências.",
                                  "commonMistakes": "Confundir as direções das provas."
                                }
                              ],
                              "practicalExample": "Para o problema Hamiltoniano: NTM adivinha caminho Hamiltoniano e verifica; Verificador recebe o caminho como c e checa se visita todos vértices exatamente uma vez em tempo O(n^2). A construção liga os dois perfeitamente.",
                              "finalVerifications": [
                                "Explicar verbalmente as duas definições sem consultar notas.",
                                "Construir corretamente V a partir de uma NTM simples.",
                                "Construir corretamente NTM a partir de um verificador.",
                                "Identificar erros em uma prova incompleta fornecida.",
                                "Aplicar a equivalência a um novo problema NP como Subset Sum.",
                                "Calcular tempos polinomiais para as construções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de ambas as versões de NP (100% correta).",
                                "Correção das construções de redução (V de M e M de V).",
                                "Análise de tempo polinomial explícita e bounded.",
                                "Uso correto de certificados e caminhos aceitantes.",
                                "Capacidade de generalizar para exemplos concretos.",
                                "Clareza na explicação da equivalência bidirecional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por contrução e indução em complexidade.",
                                "Lógica: Verificadores como provas formais em lógica proposicional.",
                                "Criptografia: Conceitos de provas interativas e zero-knowledge proofs.",
                                "Algoritmos: Heurísticas para problemas NP como TSP."
                              ],
                              "realWorldApplication": "Em otimização industrial (ex: roteamento de veículos), verificadores polinomiais permitem checar soluções candidatas rapidamente, enquanto NTMs modelam a busca exaustiva paralelizável em computação quântica ou distribuída."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.2",
                    "name": "Máquinas de Turing Não-Determinísticas",
                    "description": "Modelo computacional de máquinas de Turing com escolhas não-determinísticas e sua relação com a classe NP.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.2.1",
                        "name": "Definição Formal de Máquinas de Turing Não-Determinísticas (NTM)",
                        "description": "Apresenta o modelo formal de uma NTM, incluindo sua estrutura como uma tupla de componentes e o conceito de transições não-determinísticas, onde múltiplas próximas configurações são possíveis a partir de um estado e símbolo atual.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.1.1",
                            "name": "Identificar os componentes de uma NTM",
                            "description": "Reconhecer e listar os elementos da tupla formal de uma NTM: estados Q, alfabeto de fita Γ, função de transição δ: Q × Γ → P(Q × Γ × {L,R}), estado inicial q0, espaço em branco B e estados de aceitação/rejeição F.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura da tupla formal de uma NTM",
                                  "subSteps": [
                                    "Leia a definição formal: Uma NTM é definida pela tupla (Q, Γ, δ, q0, B, F).",
                                    "Identifique que há 6 componentes principais na tupla.",
                                    "Anote a assinatura exata da função de transição: δ: Q × Γ → P(Q × Γ × {L, R}).",
                                    "Compare brevemente com a DTM para destacar a não-deterministicidade (P() indica poder).",
                                    "Desenhe um diagrama esquemático da tupla."
                                  ],
                                  "verification": "Conseguiu listar corretamente os 6 componentes e a assinatura de δ sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Slides ou vídeo sobre NTMs (ex: YouTube ou livro Sipser)"
                                  ],
                                  "tips": [
                                    "Use mnemônicos como 'QΓδq0BF' para memorizar a ordem.",
                                    "Visualize a tupla como uma 'caixa de ferramentas' da máquina."
                                  ],
                                  "learningObjective": "Compreender a composição exata da tupla formal de uma NTM.",
                                  "commonMistakes": [
                                    "Confundir com tupla de DTM (δ retorna tupla única, não conjunto).",
                                    "Esquecer o poder P em δ.",
                                    "Invertir ordem dos componentes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os componentes fixos: Q, q0, B e F",
                                  "subSteps": [
                                    "Defina Q como o conjunto finito de estados.",
                                    "Identifique q0 ∈ Q como o estado inicial único.",
                                    "Explique B ∈ Γ como o símbolo de espaço em branco.",
                                    "Descreva F ⊆ Q como o conjunto de estados de aceitação (rejeição implícita em Q - F).",
                                    "Crie exemplos simples: Q = {q0, q1, qacc}, F = {qacc}."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o papel de cada um e dê um exemplo para Q, q0, B, F.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para diagramas de estados",
                                    "Referência: Capítulo sobre Máquinas de Turing em livro de teoria da computação"
                                  ],
                                  "tips": [
                                    "Pense em Q como 'salas' da máquina, q0 como 'entrada', B como 'vazio', F como 'saída OK'.",
                                    "Sempre verifique se q0 ∈ Q e F ⊆ Q."
                                  ],
                                  "learningObjective": "Reconhecer e descrever precisamente os componentes estáticos de uma NTM.",
                                  "commonMistakes": [
                                    "Achar que F inclui rejeição (não, só aceitação).",
                                    "Confundir B com parte de Γ (B é específico).",
                                    "Pensar q0 não faz parte de Q."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o alfabeto Γ e a função de transição δ",
                                  "subSteps": [
                                    "Defina Γ como o alfabeto finito da fita, com B ∈ Γ.",
                                    "Entenda δ: para cada (q, γ) ∈ Q × Γ, δ retorna um conjunto finito de movimentos possíveis (p, γ', D) onde D ∈ {L, R}.",
                                    "Diferencie de DTM: δ retorna conjunto (não-determinismo permite ramificações).",
                                    "Escreva um exemplo: δ(q0, 0) = {(q1, 1, R), (q2, 0, L)}.",
                                    "Simule uma transição não-determinística em papel."
                                  ],
                                  "verification": "Escreva δ para um par (q, γ) com pelo menos 2 opções e explique o não-determinismo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador online de Turing (ex: Turing Machine Simulator web)",
                                    "Papel para tabelas de transição"
                                  ],
                                  "tips": [
                                    "Use tabelas para representar δ: linhas Q, colunas Γ.",
                                    "Lembre: P(Q × Γ × {L,R}) significa 'conjunto de possibilidades'."
                                  ],
                                  "learningObjective": "Dominar os componentes dinâmicos que definem o comportamento não-determinístico.",
                                  "commonMistakes": [
                                    "Esquecer {L,R} em δ.",
                                    "Confundir Γ com alfabeto de entrada (Γ inclui símbolos de fita).",
                                    "Achar δ total (pode ser parcial)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação completa dos componentes",
                                  "subSteps": [
                                    "Pegue uma definição de NTM exemplo e extraia Q, Γ, δ, q0, B, F.",
                                    "Monte uma tupla fictícia e verifique se atende à formalidade.",
                                    "Identifique erros em definições incompletas ou erradas.",
                                    "Compare com uma DTM para reforçar diferenças.",
                                    "Crie sua própria NTM mínima e liste componentes."
                                  ],
                                  "verification": "Liste corretamente todos os 6 componentes de um exemplo dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de NTMs de livros ou online (ex: reconhecimento de {a^n b^n})",
                                    "Planilha para organizar componentes"
                                  ],
                                  "tips": [
                                    "Sempre cheque: δ tem assinatura correta? B em Γ? q0 em Q? F subconjunto Q?",
                                    "Pratique com NTMs pequenas (3 estados)."
                                  ],
                                  "learningObjective": "Aplicar o conhecimento para identificar componentes em definições reais.",
                                  "commonMistakes": [
                                    "Omitir B na tupla.",
                                    "Definir δ como função determinística.",
                                    "Confundir aceitação com halting."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma NTM que aceita linguagens com número par de 0s: Q = {q0, q1, qacc, qrej}, Γ = {0,1,B}, q0 estado inicial, B espaço em branco, F = {qacc}, δ(q0,0) = {(q1,0,R), (q0,B,L)} (exemplo parcial mostrando não-determinismo em escolhas de ramificação). Identifique: Q lista estados, Γ símbolos, etc.",
                              "finalVerifications": [
                                "Lista corretamente os 6 componentes da tupla sem erros.",
                                "Explica a não-deterministicidade via P em δ.",
                                "Distingue NTM de DTM nos componentes.",
                                "Fornece exemplo válido de δ com múltiplas transições.",
                                "Verifica consistência: q0 ∈ Q, B ∈ Γ, F ⊆ Q.",
                                "Simula uma transição básica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na assinatura de δ (Q × Γ → P(Q × Γ × {L,R})).",
                                "Correta identificação e descrição de cada componente.",
                                "Demonstração de compreensão do não-determinismo.",
                                "Uso correto de notação matemática (subconjuntos, funções).",
                                "Capacidade de detectar erros em definições dadas.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos (Q, Γ, F como conjuntos) e Funções Parciais.",
                                "Lógica: Transições como regras lógicas não-determinísticas.",
                                "Filosofia da Computação: Limites da Computação e Não-Determinismo.",
                                "Inteligência Artificial: Busca não-determinística em algoritmos.",
                                "Matemática Discreta: Autômatos e Linguagens Formais."
                              ],
                              "realWorldApplication": "NTMs modelam problemas NP (ex: Satisfatibilidade Booleana), base para algoritmos de aproximação, verificadores em provas interativas e compreensão de paralelismo em computação quântica ou distribuída."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.1.2",
                            "name": "Construir funções de transição não-determinísticas",
                            "description": "Definir funções de transição que retornam conjuntos finitos de movimentos possíveis (esquerda, direita ou ficar), permitindo ramificações no cálculo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição formal de Máquinas de Turing Não-Determinísticas (NTM)",
                                  "subSteps": [
                                    "Identifique os componentes da tupla padrão de uma NTM: Q (estados), Σ (alfabeto de entrada), Γ (alfabeto de fita), δ (função de transição), q0 (estado inicial), B (símbolo em branco), F (estados finais).",
                                    "Explique o papel da função de transição δ em NTMs, destacando que ela mapeia para conjuntos de transições possíveis.",
                                    "Compare com MT determinísticas, onde δ retorna exatamente um elemento.",
                                    "Desenhe um diagrama simples de uma NTM com ramificações.",
                                    "Liste os movimentos possíveis: L (esquerda), R (direita), S (ficar)."
                                  ],
                                  "verification": "Crie um resumo escrito ou diagrama da tupla NTM com δ destacada; verifique se todos componentes estão corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência de livro ou notas sobre teoria da computação"
                                  ],
                                  "tips": "Use setas ramificadas em diagramas para visualizar não-determinismo.",
                                  "learningObjective": "Compreender a estrutura formal de NTMs e o papel único da função δ.",
                                  "commonMistakes": [
                                    "Confundir Γ com Σ",
                                    "Esquecer que δ retorna potências finitas",
                                    "Ignorar o símbolo em branco B"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar transições determinísticas e não-determinísticas",
                                  "subSteps": [
                                    "Defina δ para MT: Q × Γ → Q × Γ × {L, R}.",
                                    "Defina δ para NTM: Q × Γ → Pfin(Q × Γ × {L, R, S}), onde Pfin é o conjunto de subconjuntos finitos.",
                                    "Explique 'não-determinismo' como escolha simultânea de múltiplas transições.",
                                    "Calcule exemplos: Para δ(q, a) = {(p1, b, R), (p2, c, L)}.",
                                    "Discuta aceitação: NTM aceita se pelo menos um caminho aceita.",
                                    "Implemente um exemplo em pseudocódigo."
                                  ],
                                  "verification": "Escreva definições lado a lado e um exemplo com pelo menos duas transições; teste com um estado fictício.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto ou quadro branco",
                                    "Exemplos de MT e NTM impressos"
                                  ],
                                  "tips": "Pense em não-determinismo como 'adivinhação' que o computador faz em paralelo.",
                                  "learningObjective": "Distinguir formalmente δ em MT vs NTM e entender ramificações.",
                                  "commonMistakes": [
                                    "Omitir S (ficar) como movimento possível",
                                    "Confundir Pfin com todos os subconjuntos",
                                    "Achar que NTM é mais lenta que MT"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a assinatura formal da função de transição não-determinística",
                                  "subSteps": [
                                    "Escreva a assinatura: δ: Q × Γ → Pfin(Q × Γ × {L, R, S}).",
                                    "Especifique domínios: Q finito, Γ finito incluindo B.",
                                    "Garanta que δ(q, σ) seja finito e não vazio para estados não-finais.",
                                    "Defina casos especiais: δ em estados finais ou rejeição.",
                                    "Crie uma tabela para δ com linhas para estados e símbolos.",
                                    "Valide: Para cada entrada, liste 1-3 transições possíveis."
                                  ],
                                  "verification": "Construa uma tabela δ parcial para 2 estados e 2 símbolos; confirme que cada célula tem um conjunto finito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Ferramenta como LaTeX ou Markdown para tabelas"
                                  ],
                                  "tips": "Use notação de conjuntos { (q', γ', D) | ... } para clareza.",
                                  "learningObjective": "Formalizar δ corretamente, incluindo restrições de finitude.",
                                  "commonMistakes": [
                                    "Retornar conjuntos infinitos",
                                    "Esquecer parênteses triplos (q, γ, D)",
                                    "Definir δ para símbolos fora de Γ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e testar uma função de transição não-determinística completa",
                                  "subSteps": [
                                    "Escolha um exemplo: NTM que 'adivinha' se uma string binária tem comprimento par.",
                                    "Defina Q = {q0, qp, qrej, qace}, Γ = {0,1,B}.",
                                    "Construa δ: Em q0 lendo 0/1, ramifique para qp (par) ou qrej (ímpar).",
                                    "Simule 2-3 passos em uma fita exemplo: 010.",
                                    "Verifique ramificações e aceitação.",
                                    "Refatore δ para incluir movimento S em alguns casos."
                                  ],
                                  "verification": "Simule a NTM em uma fita de teste; mostre pelo menos um caminho de aceitação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Simulador de MT online ou papel para fita",
                                    "Pseudocódigo editor"
                                  ],
                                  "tips": "Comece com não-determinismo mínimo (2 escolhas) para simplicidade.",
                                  "learningObjective": "Aplicar δ em um exemplo prático e simular execução.",
                                  "commonMistakes": [
                                    "Ramificações vazias levando a loops",
                                    "Movimentos que saem da fita sem B",
                                    "Confundir aceitação com todos os caminhos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma NTM que reconhece strings binárias de comprimento par: δ(q0, 0) = {(qp, 0, R), (qrej, 0, S)}; δ(q0, 1) = {(qp, 1, R), (qrej, 1, S)}; δ(qp, B) = {(qace, B, S)}. A máquina 'adivinha' paridade no primeiro passo, ramificando para verificação ou rejeição.",
                              "finalVerifications": [
                                "δ retorna conjuntos finitos não-vazios para entradas válidas.",
                                "Todos elementos de δ estão no formato (q', γ', {L,R,S}).",
                                "Simulação em fita de teste mostra ramificações corretas.",
                                "NTM aceita/rejeita conforme esperado em pelo menos um caminho.",
                                "Tabela δ cobre todos estados e símbolos relevantes.",
                                "Movimentos respeitam limites da fita com B."
                              ],
                              "assessmentCriteria": [
                                "Correção formal da assinatura δ (20%)",
                                "Exemplos de transições com múltiplas escolhas (25%)",
                                "Simulação precisa sem erros de movimento (25%)",
                                "Uso apropriado de L, R, S (15%)",
                                "Explicação clara de não-determinismo (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos (Pfin) e funções parciais.",
                                "Lógica: Ramificações como disjunções em provas não-determinísticas.",
                                "Programação: Modelagem de threads paralelas ou backtracking em algoritmos.",
                                "Física: Modelos quânticos com superposição (análoga a não-determinismo)."
                              ],
                              "realWorldApplication": "Em algoritmos de otimização como busca em grafos (A*), onde não-determinismo modela exploração paralela de caminhos; em verificação de software para modelar comportamentos concorrentes incertos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.1.3",
                            "name": "Diferenciar NTM de TM determinística",
                            "description": "Comparar o comportamento de uma TM determinística (uma única transição por configuração) com uma NTM (múltiplas transições possíveis, modelando não-determinismo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição e Funcionamento de uma Máquina de Turing Determinística (TM)",
                                  "subSteps": [
                                    "Relembre os componentes de uma TM: estados Q, alfabeto de fita Γ, função de transição δ: Q × Γ → Q × Γ × {L, R}, estado inicial q0, estados finais F.",
                                    "Descreva o comportamento: dada uma configuração (estado, fita), há exatamente uma transição possível, levando a uma computação única e sequencial.",
                                    "Simule mentalmente uma TM simples que reconhece palíndromos pares, observando o caminho determinístico único.",
                                    "Anote as propriedades chave: previsibilidade total, uma única sequência de configurações por entrada.",
                                    "Compare com autômatos finitos determinísticos para reforçar o conceito de determinismo."
                                  ],
                                  "verification": "Escreva um diagrama de transição para uma TM simples e confirme que cada configuração tem no máximo uma transição.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Referência: Livro de Teoria da Computação (Sipser ou similar)"
                                  ],
                                  "tips": "Use setas unidirecionais em diagramas para visualizar o caminho único.",
                                  "learningObjective": "Compreender os elementos fundamentais de uma TM determinística e seu comportamento previsível.",
                                  "commonMistakes": [
                                    "Confundir função de transição com múltiplas saídas",
                                    "Ignorar o estado de rejeição ou halting."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Definição Formal de Máquina de Turing Não-Determinística (NTM)",
                                  "subSteps": [
                                    "Defina formalmente NTM: componentes similares à TM, mas δ: Q × Γ → finito(Q × Γ × {L, R}), permitindo múltiplas transições por configuração.",
                                    "Explique o não-determinismo: em uma configuração, o NTM 'escolhe' uma transição (como um oráculo), ramificando em múltiplas computações possíveis.",
                                    "Descreva a aceitação: uma entrada é aceita se existe pelo menos um caminho de computação que alcança um estado final.",
                                    "Diferencie conceitualmente: NTM modela escolha não-determinística, não aleatória.",
                                    "Esboce um diagrama de NTM com ramificações para uma linguagem simples como {a^n b^n}."
                                  ],
                                  "verification": "Construa a função δ para uma NTM simples com pelo menos duas transições de uma mesma configuração.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online (Draw.io)",
                                    "Notas de aula sobre NTM"
                                  ],
                                  "tips": "Pense no não-determinismo como 'forks' em programação paralela.",
                                  "learningObjective": "Dominar a definição formal de NTM e reconhecer múltiplas transições.",
                                  "commonMistakes": [
                                    "Interpretar não-determinismo como probabilidade",
                                    "Esquecer que aceitação requer apenas um caminho aceitador."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diretamente TM Determinística e NTM",
                                  "subSteps": [
                                    "Liste diferenças chave: TM tem δ única saída; NTM tem conjunto finito de saídas.",
                                    "Compare computação: TM tem árvore de computação linear (um caminho); NTM tem árvore ramificada.",
                                    "Discuta poder computacional: NTM reconhece mesma classe de linguagens (P vs NP contexto), mas simulável por TM em tempo exponencial.",
                                    "Analise configurações: TM uma por passo; NTM explode em paralelas.",
                                    "Crie uma tabela comparativa: colunas para componentes, comportamento, aceitação."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 diferenças precisas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Exemplos de TMs e NTMs de referências"
                                  ],
                                  "tips": "Use 'uma vs múltiplas' como mantra para transições.",
                                  "learningObjective": "Identificar e articular diferenças estruturais e comportamentais entre TM e NTM.",
                                  "commonMistakes": [
                                    "Achar que NTM é mais poderosa em linguagens reconhecíveis",
                                    "Confundir com TM probabilística."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Exemplos e Simulações para Reforçar a Diferenciação",
                                  "subSteps": [
                                    "Simule TM determinística para {ww | w em {0,1}*}: copie e compare, caminho único.",
                                    "Construa NTM para mesma linguagem: adivinha meio não-determinísticamente, verifica.",
                                    "Execute simulações paralelas: trace todos os branches na NTM vs único na TM.",
                                    "Discuta equivalência: toda NTM simulável por TM (construção padrão).",
                                    "Resuma em um fluxograma comparativo de execução."
                                  ],
                                  "verification": "Simule ambas em uma entrada curta e descreva os caminhos de computação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Simulador de TM online (ex: Turing Machine Simulator)",
                                    "Entradas de teste como '001001'"
                                  ],
                                  "tips": "Comece com entradas pequenas para evitar explosão de branches.",
                                  "learningObjective": "Aplicar a diferenciação em exemplos concretos via simulação.",
                                  "commonMistakes": [
                                    "Não simular todos os branches na NTM",
                                    "Assumir TM falha onde NTM succeeds sem verificação."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a linguagem {a^n b^n | n ≥ 0}. Uma TM determinística marca a's e b's sequencialmente em múltiplas passagens. Uma NTM 'adivinha' o número n, pulando não-determinísticamente para o n-ésimo b e verificando simultaneamente em branches paralelos, aceitando se um branch succeeder.",
                              "finalVerifications": [
                                "Explique verbalmente as diferenças em função de transição δ.",
                                "Desenhe diagramas de TM e NTM para uma configuração compartilhada.",
                                "Simule uma entrada em ambas e liste todos os caminhos.",
                                "Defina formalmente aceitação em NTM vs TM.",
                                "Discuta por que NTMs modelam não-determinismo sem aumentar poder recursivo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de δ para TM (única) vs NTM (múltipla).",
                                "Correta descrição de árvores de computação (linear vs ramificada).",
                                "Uso correto de terminologia: configuração, transição, aceitação.",
                                "Capacidade de simular exemplos sem erros lógicos.",
                                "Compreensão de equivalência computacional entre TM e NTM."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (árvores de computação como grafos ramificados).",
                                "Lógica: Não-determinismo similar a quantificadores existenciais (∃ caminho aceitador).",
                                "Algoritmos: Paralelismo e busca em grafos (BFS não-determinístico).",
                                "Filosofia da Computação: Limites da determinística vs escolha livre."
                              ],
                              "realWorldApplication": "Em verificadores de hardware (modelagem de circuitos paralelos), otimização combinatória (busca não-determinística em NP), e simuladores de sistemas concorrentes onde branches representam threads independentes."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.2.2",
                        "name": "Comportamento e Aceitação em NTMs",
                        "description": "Explica como uma NTM processa entradas através de configurações e caminhos de computação, definindo aceitação se existir pelo menos um caminho que leva a um estado de aceitação.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.2.1",
                            "name": "Descrever configurações e caminhos de computação",
                            "description": "Representar uma configuração como (estado, fita esquerda, cabeça, fita direita) e ilustrar árvores de computação ramificadas devido ao não-determinismo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e representar uma configuração básica de NTM",
                                  "subSteps": [
                                    "Defina os componentes de uma configuração: estado atual (q), fita esquerda (conteúdo à esquerda da cabeça), posição da cabeça (indicador), fita direita (conteúdo à direita da cabeça).",
                                    "Escreva a notação formal: (q, fita_esquerda | cabeça | fita_direita).",
                                    "Pratique representando configurações iniciais para uma fita de entrada simples, como '101'.",
                                    "Diferencie configurações de MT determinística vs. não-determinística."
                                  ],
                                  "verification": "Desenhe corretamente 3 configurações iniciais e finais para uma entrada dada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplos de fitas de entrada impressos"
                                  ],
                                  "tips": "Sempre inclua o símbolo de cabeça '|' para clareza visual.",
                                  "learningObjective": "Dominar a representação gráfica e formal de configurações de NTM.",
                                  "commonMistakes": "Esquecer a posição da cabeça ou inverter esquerda/direita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular transições não-determinísticas",
                                  "subSteps": [
                                    "Revise a função de transição δ(q, símbolo) → conjunto de (q', símbolo_escrever, direção).",
                                    "Para uma configuração, liste todas as transições possíveis (ramificações).",
                                    "Desenhe setas de uma configuração pai para filhos resultantes de cada transição.",
                                    "Simule 2-3 passos sequenciais em um caminho não-determinístico."
                                  ],
                                  "verification": "Gere corretamente 4 configurações filhas de uma configuração pai com múltiplas transições.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabela de transições de uma NTM exemplo",
                                    "Ferramenta online como JFLAP"
                                  ],
                                  "tips": "Use cores diferentes para ramificações para visualizar não-determinismo.",
                                  "learningObjective": "Aplicar transições para gerar configurações sucessoras em NTMs.",
                                  "commonMistakes": "Ignorar todas as ramificações possíveis, simulando apenas uma."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a árvore de computação completa",
                                  "subSteps": [
                                    "Inicie a árvore na raiz com configuração inicial.",
                                    "Expanda níveis da árvore seguindo todas as transições possíveis até estados finais.",
                                    "Marque estados de aceitação (q_accept) e rejeição (q_reject).",
                                    "Pode a árvore até um limite de profundidade (ex: 5 níveis) para gerenciabilidade."
                                  ],
                                  "verification": "Construa uma árvore completa para uma NTM simples com entrada de 3 símbolos.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Papel grande ou software de desenho (Draw.io)",
                                    "Exemplo de NTM para {w | w tem paridade par}"
                                  ],
                                  "tips": "Numere os nós da árvore para rastrear caminhos específicos.",
                                  "learningObjective": "Visualizar o espaço de computação ramificado de uma NTM.",
                                  "commonMistakes": "Parar expansão prematuramente ou confundir caminhos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar caminhos de aceitação e rejeição",
                                  "subSteps": [
                                    "Identifique todos os caminhos da raiz até folhas de aceitação.",
                                    "Marque caminhos de rejeição e explique por que não aceitam.",
                                    "Discuta o conceito de 'existe um caminho de aceitação' para aceitação de NTM.",
                                    "Compare com MT determinística (único caminho)."
                                  ],
                                  "verification": "Liste 2 caminhos de aceitação e 1 de rejeição em sua árvore, justificando.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Árvore construída no step anterior"
                                  ],
                                  "tips": "Use traçado de caminhos com linhas contínuas para aceitação.",
                                  "learningObjective": "Interpretar resultados de computação em árvores de NTM.",
                                  "commonMistakes": "Confundir aceitação (existe caminho) com todos os caminhos."
                                }
                              ],
                              "practicalExample": "Para NTM M que aceita strings com número par de 1's em {0,1}*: Configuração inicial: (q0, ε | ε 1 0 1 | ε). Transição em q0 lendo 1 gera duas ramificações: uma escreve 1 e move R para q1; outra para q2. A árvore ramifica mostrando um caminho aceitando via paridade par.",
                              "finalVerifications": [
                                "Representa corretamente configurações com notação (q, esquerda | cabeça | direita).",
                                "Gera todas as ramificações não-determinísticas sem omitir transições.",
                                "Constrói árvore de computação com pelo menos 3 níveis de profundidade.",
                                "Identifica precisamente caminhos de aceitação.",
                                "Explica diferenças entre NTM e DTM em termos de caminhos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação de configurações (20%).",
                                "Completude das ramificações na árvore (30%).",
                                "Correção na identificação de aceitação/rejeição (25%).",
                                "Clareza visual e rotulagem da árvore (15%).",
                                "Explicação conceitual do não-determinismo (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Árvores como grafos direcionados acíclicos.",
                                "Probabilidade e Estatística: Não-determinismo similar a processos estocásticos.",
                                "Algoritmos: Paralelo com busca em largura/profundidade em espaços de estados.",
                                "Lógica: Caminhos como provas existenciais."
                              ],
                              "realWorldApplication": "Modelagem de algoritmos de busca não-determinística em IA, como A* com heurísticas múltiplas, ou simulação de sistemas quânticos onde superposição cria ramificações computacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.2.2.2",
                            "name": "Definir linguagem aceita por uma NTM",
                            "description": "Estabelecer que L(M) = {w | existe uma sequência de configurações de aceitação partindo da configuração inicial para w}, incluindo halting e looping.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Configuração Inicial de uma NTM",
                                  "subSteps": [
                                    "Revise os componentes de uma NTM: conjunto de estados Q, alfabeto de fita Γ, função de transição δ não-determinística, estado inicial q₀, estados de aceitação F e rejeição R.",
                                    "Descreva a configuração inicial para uma entrada w: estado q₀, fita com w₀¹...wₙ rodeada por símbolos em branco (B), cabeçote posicionado na primeira célula de w.",
                                    "Represente formalmente como C₀ = (q₀, w₁...wₙ B B..., 1), onde o número indica a posição do cabeçote.",
                                    "Note que δ pode gerar múltiplas configurações sucessoras de C₀.",
                                    "Pratique com um exemplo simples de w."
                                  ],
                                  "verification": "Escreva a configuração inicial C₀ para w = 'ab' em uma NTM genérica e explique cada parte.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de NTM padrão",
                                    "Folha de anotações sobre componentes de NTM",
                                    "Exemplos de entradas w"
                                  ],
                                  "tips": [
                                    "Use notação tripla (q, fita, posição) para clareza.",
                                    "Lembre-se: fita é infinita em ambas as direções com blanks."
                                  ],
                                  "learningObjective": "Identificar e representar precisamente a configuração inicial de uma NTM para qualquer string w.",
                                  "commonMistakes": [
                                    "Esquecer os blanks infinitos além de w.",
                                    "Confundir posição inicial do cabeçote (sempre 1).",
                                    "Ignorar o não-determinismo na transição inicial."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Configurações de Aceitação e Rejeição",
                                  "subSteps": [
                                    "Identifique estados de aceitação F ⊆ Q e rejeição R ⊆ Q (disjuntos).",
                                    "Defina uma configuração de aceitação: qualquer C = (q, fita, posição) onde q ∈ F e a máquina halta.",
                                    "Defina configuração de rejeição: C = (q, fita, posição) onde q ∈ R e halta.",
                                    "Diferencie halting de looping: halting ocorre quando δ(C) é vazia; looping é computação infinita.",
                                    "Represente exemplos de configurações finais."
                                  ],
                                  "verification": "Classifique configurações dadas como de aceitação, rejeição ou neutras, justificando.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de estados Q, F, R de uma NTM exemplo",
                                    "Exemplos de configurações halting"
                                  ],
                                  "tips": [
                                    "Halting só em F ou R; caso contrário, pode loopar.",
                                    "F e R são fixos na definição da máquina."
                                  ],
                                  "learningObjective": "Distinguir configurações de aceitação/rejeição e entender halting em NTMs.",
                                  "commonMistakes": [
                                    "Confundir halting com looping.",
                                    "Achar que qualquer estado final aceita.",
                                    "Ignorar que F e R podem ser vazios."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender Sequências de Configurações Válidas",
                                  "subSteps": [
                                    "Defina uma sequência de configurações C₀, C₁, ..., Cₖ onde Cᵢ₊₁ ∈ δ(Cᵢ) para cada i.",
                                    "Especifique que a sequência é de aceitação se Cₖ é de aceitação e k é finito (halting).",
                                    "Discuta ramificações não-determinísticas: uma sequência válida é um caminho em uma árvore de computação.",
                                    "Verifique validade: cada transição deve seguir δ exatamente.",
                                    "Pratique traçando uma sequência curta para uma NTM simples."
                                  ],
                                  "verification": "Construa uma sequência válida de 3 configurações partindo de C₀ para uma transição dada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Função de transição δ de uma NTM exemplo",
                                    "Papel para desenhar árvores de computação"
                                  ],
                                  "tips": [
                                    "δ retorna conjunto finito de sucessores.",
                                    "Uma sequência válida não precisa ser única devido ao não-determinismo."
                                  ],
                                  "learningObjective": "Construir e validar sequências de configurações que seguem as regras de transição de uma NTM.",
                                  "commonMistakes": [
                                    "Pular transições inválidas.",
                                    "Confundir sucessão determinística com não-determinística.",
                                    "Permitir loops infinitos como sequências finitas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a Linguagem Aceita L(M)",
                                  "subSteps": [
                                    "Defina L(M) = { w ∈ Σ* | ∃ sequência finita C₀ → C₁ → ... → Cₖ onde C₀ é inicial para w e Cₖ é de aceitação }.",
                                    "Inclua halting: só sequências finitas contam; loops infinitos não aceitam nesse caminho.",
                                    "Esclareça aceitação: w ∈ L(M) se ∃ pelo menos um caminho de aceitação (outros podem rejeitar ou loopar).",
                                    "w ∉ L(M) se todos os caminhos rejeitam ou loopam infinitamente.",
                                    "Escreva a definição formal e teste com exemplos."
                                  ],
                                  "verification": "Escreva a definição formal de L(M) e prove se um w específico pertence ou não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Definição padrão de NTM do livro-texto",
                                    "Exemplos de NTMs com L(M) conhecidas"
                                  ],
                                  "tips": [
                                    "Use quantificador existencial ∃ para capturar não-determinismo.",
                                    "Aceitação requer halting em F, não loop."
                                  ],
                                  "learningObjective": "Formalizar precisamente L(M) incluindo tratamento de halting e looping.",
                                  "commonMistakes": [
                                    "Definir L(M) como todas as sequências halting, ignorando ∃.",
                                    "Confundir com DTMs (onde só uma sequência).",
                                    "Achar que looping aceita."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere NTM M que aceita {w ∈ {0,1}* | w tem comprimento par}. Para w = '00', C₀ = (q₀, 00BB...,1). Uma sequência: C₀ → (q₁, 0B0B...,2) [move direito] → (q₂, 00BB...,3) [move esquerdo, par] → C₃ = (qf, 00BB...,1) com qf ∈ F (halting aceitação). Logo '00' ∈ L(M). Para w='0', todos os caminhos loopam ou rejeitam, então '0' ∉ L(M).",
                              "finalVerifications": [
                                "Explique L(M) em suas palavras, incluindo o papel do ∃.",
                                "Dê um exemplo de w ∈ L(M) com sequência explícita.",
                                "Mostre por que um w ∉ L(M), citando todos os caminhos.",
                                "Diferencie aceitação de NTM vs DTM.",
                                "Descreva impacto de looping em aceitação.",
                                "Escreva notação formal de L(M)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de L(M) com ∃ sequência de aceitação.",
                                "Correta representação de configurações inicial e final.",
                                "Entendimento de não-determinismo (um caminho basta).",
                                "Tratamento adequado de halting vs looping.",
                                "Uso consistente de notação (Cᵢ, δ).",
                                "Capacidade de aplicar a exemplos concretos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Quantificadores Existenciais (∃ sequência).",
                                "Lógica: Não-determinismo modelado por ramificações em árvores de prova.",
                                "Filosofia da Computação: Discussão sobre paralelismo e escolha não-determinística.",
                                "Algoritmos: Ligação com classes NP e verifiers probabilísticos."
                              ],
                              "realWorldApplication": "Modela problemas NP onde 'existe uma solução' pode ser verificada (ex: SAT solvers não-determinísticos), usado em otimização, IA para busca paralela e comprovação de teoremas automatizada."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.8.2.2.3",
                            "name": "Analisar exemplos de NTMs simples",
                            "description": "Construir e simular NTMs para linguagens como {a^n b^n | n ≥ 0}, destacando como o não-determinismo 'adivinha' a posição correta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de NTMs e a Linguagem {a^n b^n}",
                                  "subSteps": [
                                    "Defina uma Máquina de Turing Não-Determinística (NTM) e suas diferenças em relação a DTMs.",
                                    "Explique a linguagem {a^n b^n | n ≥ 0} com exemplos como ε, ab, aabb.",
                                    "Identifique por que essa linguagem requer não-determinismo para reconhecimento eficiente.",
                                    "Descreva os componentes de uma NTM: estados, fita, cabeçote, transições não-determinísticas.",
                                    "Liste exemplos de 'adivinhação' em NTMs, como pular para o meio da fita."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e desenhe um diagrama simples da linguagem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre NTMs, papel e caneta ou software de desenho como Draw.io.",
                                  "tips": "Use analogias como 'forks na estrada' para visualizar não-determinismo.",
                                  "learningObjective": "Compreender os pré-requisitos teóricos para análise de NTMs.",
                                  "commonMistakes": "Confundir NTM com DTM; ignorar que NTMs podem ter múltiplas transições simultâneas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a NTM para Reconhecer {a^n b^n}",
                                  "subSteps": [
                                    "Desenhe os estados iniciais: q0 (início), q1 (contar a's), q2 (match b's), q_accept, q_reject.",
                                    "Defina transições: de q0, mova direita contando a's; não-deterministically mude para q2 após n a's.",
                                    "Especifique a 'adivinhação': em algum ponto após ler n a's, sem fita de b's, branch para verificar b's.",
                                    "Inclua limpeza da fita e verificação final de fim de entrada.",
                                    "Formalize as transições em tabela: δ(q, símbolo) = conjunto de (novo_q, novo_símbolo, direção)."
                                  ],
                                  "verification": "Crie um diagrama de estados completo e valide com uma entrada pequena como 'ab'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de modelagem de autômatos (JFLAP ou papel), exemplos de NTMs.",
                                  "tips": "Comece com o caso n=1 e expanda; rotule branches como 'guess n'.",
                                  "learningObjective": "Construir uma NTM funcional para a linguagem dada.",
                                  "commonMistakes": "Esquecer branches não-determinísticos; fazer determinístico acidentalmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Execução Passo a Passo para uma Entrada Específica",
                                  "subSteps": [
                                    "Escolha entrada 'aabb' na fita: _aabb_ (símbolos de blank nos fins).",
                                    "Simule de q0: leia 'a', escreva X, mova direita (rastreie cabeçote).",
                                    "No não-determinismo: em q1 após duas X's, branch para q2, mova esquerda até encontrar b's.",
                                    "Rastreie todas as branches: branches que falham vão para q_reject; uma aceita.",
                                    "Registre configurações da fita em cada macro-passo."
                                  ],
                                  "verification": "Produza uma tabela ou árvore de simulação mostrando aceitação via uma branch.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "JFLAP ou simulador NTM online, planilha para rastrear estados.",
                                  "tips": "Use cores para branches diferentes; foque em uma branch vencedora primeiro.",
                                  "learningObjective": "Executar simulação manual para visualizar comportamento não-determinístico.",
                                  "commonMistakes": "Perder o rastreamento do cabeçote; assumir todas branches devem aceitar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Papel do Não-Determinismo e Casos de Rejeição",
                                  "subSteps": [
                                    "Identifique onde o não-determinismo 'adivinha' a transição de a's para b's.",
                                    "Simule entrada inválida como 'aab' mostrando todas branches rejeitam.",
                                    "Compare tempo de simulação NTM vs. brute-force determinístico.",
                                    "Discuta aceitação: NTM aceita se ∃ branch que aceita em tempo polinomial.",
                                    "Extraia lições: eficiência via adivinhação vs. verificação exaustiva."
                                  ],
                                  "verification": "Escreva relatório de 200 palavras explicando por que NTM resolve eficientemente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Simulações anteriores, timer para medir passos.",
                                  "tips": "Pense em não-determinismo como 'tentativa paralela' sem custo extra.",
                                  "learningObjective": "Destacar vantagens do não-determinismo na análise.",
                                  "commonMistakes": "Confundir rejeição (todas branches rejeitam) com aceitação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Generalizar e Testar com Múltiplas Entradas",
                                  "subSteps": [
                                    "Teste n=0 (ε), n=3 (aaabbb), n=1 (ab).",
                                    "Ajuste a NTM se necessário para casos edge.",
                                    "Compare com NTM para outras linguagens NP como SAT.",
                                    "Documente padrões de adivinhação em NTMs.",
                                    "Resuma limitações: NTMs não são 'mais poderosas' que DTMs."
                                  ],
                                  "verification": "Crie tabela de testes com resultados esperados e observados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Lista de entradas de teste, JFLAP para automação.",
                                  "tips": "Automatize simulações em JFLAP para eficiência.",
                                  "learningObjective": "Validar robustez da NTM através de testes abrangentes.",
                                  "commonMistakes": "Ignorar casos n=0; generalizar erroneamente poder computacional."
                                }
                              ],
                              "practicalExample": "Para a entrada 'aabb': A NTM começa marcando a's com X's enquanto move direita. Após duas X's, não-determinísticamente branches para mover esquerda, passando X's, e então marca b's com Y's movendo direita até blank, depois esquerda verificando match. Uma branch adivinha perfeitamente após exatamente n=2 a's, aceitando; outras rejeitam rapidamente.",
                              "finalVerifications": [
                                "Diagrama da NTM está completo e correto para {a^n b^n}.",
                                "Simulação de 'aabb' mostra aceitação via branch específica.",
                                "Simulação de 'aab' mostra rejeição em todas branches.",
                                "Relatório explica 'adivinhação' do não-determinismo claramente.",
                                "Tabela de testes cobre n=0 a n=3 com resultados corretos.",
                                "Comparação com DTM destaca eficiência NTM."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de transições não-determinísticas (80% correto).",
                                "Clareza na simulação passo a passo com diagramas (visual e tabular).",
                                "Profundidade na análise do papel da adivinhação (explicação causal).",
                                "Cobertura de casos de aceitação e rejeição.",
                                "Generalização para outras entradas e linguagens NP.",
                                "Tempo de simulação dentro de bounds polinomiais esperados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Correspondência biunívoca em teoria dos conjuntos.",
                                "Lógica: Paralelos com busca exaustiva em árvores de decisão.",
                                "Física: Analogia com superposição quântica em computação quântica.",
                                "Probabilidade: Modelagem de branches como caminhos probabilísticos."
                              ],
                              "realWorldApplication": "NTMs modelam problemas NP-completos como SAT solvers em verificadores de software e otimização em IA, onde 'adivinhação' simula backtracking eficiente em algoritmos como DPLL para satisfatibilidade booleana."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.2.3",
                        "name": "Relação entre NTMs e a Classe NP",
                        "description": "Estabelece a equivalência entre problemas resolvíveis por NTMs em tempo polinomial e a classe NP, via simulação determinística e verificadores polinomiais.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.3.1",
                            "name": "Simular NTM por TM determinística em tempo exponencial",
                            "description": "Explicar a construção de uma TM que simula todas as ramificações de uma NTM usando busca em largura, consumindo tempo O(2^{p(n)}).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de TM e NTM",
                                  "subSteps": [
                                    "Defina formalmente uma Máquina de Turing (TM) determinística: conjunto de estados, alfabeto, função de transição δ única.",
                                    "Defina uma NTM: função de transição δ que produz múltiplas transições possíveis (não-determinismo).",
                                    "Explique configuração instantânea: estado, posição da cabeça de leitura/escrita, conteúdo da fita.",
                                    "Discuta aceitação: NTM aceita se existe pelo menos um caminho de computação que leva a um estado de aceitação.",
                                    "Compare tempo de execução: TM em tempo polinomial vs. NTM em tempo polinomial."
                                  ],
                                  "verification": "Escreva definições formais e diferenças em um papel; verifique com um colega ou referência padrão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Cap. 7)",
                                    "Notas de aula sobre autômatos",
                                    "Vídeo explicativo sobre NTMs no YouTube (canal AcademicGCS)"
                                  ],
                                  "tips": "Use diagramas para visualizar transições não-determinísticas como um grafo.",
                                  "learningObjective": "Dominar as definições precisas para basear a simulação.",
                                  "commonMistakes": [
                                    "Confundir aceitação de NTM (existe caminho) com TM (único caminho)",
                                    "Ignorar o papel das configurações instantâneas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Espaço de Configurações da NTM",
                                  "subSteps": [
                                    "Represente uma configuração da NTM como um tupla: (estado q, posição cabeça h, conteúdo fita w).",
                                    "Codifique configurações na fita de uma TM usando símbolos especiais (ex: #q# para estado, _ para branco).",
                                    "Construa o grafo de configurações: nós são configs, arestas são transições δ.",
                                    "Identifique configs iniciais, finais de aceitação e rejeição.",
                                    "Estime o número de configs possíveis: O(2^{p(n)}) para fita de tamanho polinomial p(n)."
                                  ],
                                  "verification": "Desenhe o grafo de configs para uma NTM simples com entrada de tamanho 2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Simulador online de TM (ex: Turing Machine Simulator web)",
                                    "Exemplos de Sipser p. 154-160"
                                  ],
                                  "tips": "Comece com NTMs pequenas (2-3 estados) para visualizar o espaço exponencial.",
                                  "learningObjective": "Entender o grafo implícito gerado pelo não-determinismo.",
                                  "commonMistakes": [
                                    "Subestimar o tamanho da fita: ela cresce com o tempo de computação",
                                    "Esquecer de codificar o estado e posição na config"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar a TM Simuladora Usando Busca em Largura (BFS)",
                                  "subSteps": [
                                    "Use uma fita única da TM para armazenar uma fila (queue) de configurações pendentes (BFS level-by-level).",
                                    "Defina estados da TM: 'gerar sucessores', 'adicionar à fila', 'simular um passo', 'checar aceitação'.",
                                    "Implemente lógica: extraia config da frente da fila, gere todas as configs sucessoras via δ, adicione à fila se não visitadas.",
                                    "Marque configs visitadas para evitar loops (use conjunto de visitados na fita).",
                                    "Pare se encontrar config de aceitação."
                                  ],
                                  "verification": "Descreva pseudocódigo da TM e simule manualmente 2 passos em uma entrada pequena.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Fita simulada em Excel ou papel (dividida em tracks)",
                                    "Pseudocódigo de BFS padrão adaptado",
                                    "Referência: Arora & Barak 'Computational Complexity' Cap. 2"
                                  ],
                                  "tips": "Pense na fita como multi-track: track1=fila, track2=visitados, track3=config atual.",
                                  "learningObjective": "Construir a estratégia de exploração exaustiva via BFS.",
                                  "commonMistakes": [
                                    "Usar DFS em vez de BFS: pode levar a tempo super-exponencial",
                                    "Não marcar visitados: loops infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detalhar Encoding e Transições na Fita da TM",
                                  "subSteps": [
                                    "Defina encoding completo: config = #q_i # h_pos # fita_content # (use símbolos Γ expandidos).",
                                    "Especifique como a TM move símbolos na fita para simular δ: escrever novo símbolo, mover cabeça, mudar estado.",
                                    "Implemente divisão da fita: esquerda=fila de configs, meio=config atual, direita=visitados.",
                                    "Descreva transições high-level da TM para cada sub-rotina (gerar, enqueue, etc.).",
                                    "Teste com exemplo: avance uma config através de uma transição não-determinística."
                                  ],
                                  "verification": "Codifique e execute simulação manual de uma transição completa na fita.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta online como JFLAP para TM",
                                    "Papel com tracks simulados",
                                    "Exercícios de Sipser 7.3-7.5"
                                  ],
                                  "tips": "Use símbolos únicos para delimitadores (#, $) para parsing fácil.",
                                  "learningObjective": "Masterizar a representação prática na fita determinística.",
                                  "commonMistakes": [
                                    "Erro de parsing: símbolos mal delimitados causam sobrescrita errada",
                                    "Cabeça de fita saindo dos limites"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Complexidade e Verificar Correção",
                                  "subSteps": [
                                    "Prove correção: BFS explora todos caminhos possíveis em ordem de comprimento.",
                                    "Calcule número de configs: para tempo p(n), |w| ≤ p(n), #configs ≤ |Q| * p(n) * 2^{p(n)} = O(2^{p(n)}).",
                                    "Tempo da TM: O(1) por config (simular passo), total O(2^{p(n)}).",
                                    "Discuta espaço: fita armazena todas configs pendentes, O(2^{p(n)}).",
                                    "Compare com NP: simulação mostra NTM em tempo poly ⊆ TIME(2^{poly})."
                                  ],
                                  "verification": "Derive formalmente o bound O(2^{p(n)}) e teste com NTM de 1 bit de entrada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Lápis e papel para provas",
                                    "Artigo 'Nondeterminism' de Savitch",
                                    "Calculadora para exponenciais pequenas"
                                  ],
                                  "tips": "Conte configs explicitamente para n=1,2 para validar.",
                                  "learningObjective": "Compreender por que a simulação é exponencial.",
                                  "commonMistakes": [
                                    "Confundir tempo com #branches: cada branch tem custo poly",
                                    "Ignorar fator polinomial no expoente"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma NTM M que, em entrada w de tamanho n (par), adivinha o meio m=n/2 não-determinísticamente, copia w[1..m] para fita auxiliar e compara com w[m+1..n] invertido. A TM simuladora usa BFS para explorar todas posições de 'adivinhação' possíveis (2^n branches potenciais), encontrando o caminho correto em tempo exponencial.",
                              "finalVerifications": [
                                "Construa e simule a TM para uma NTM com 2 estados e entrada '11'.",
                                "Explique verbalmente o encoding de uma config complexa.",
                                "Prove que a TM aceita iff a NTM aceita.",
                                "Calcule tempo para uma NTM com p(n)=n.",
                                "Identifique 3 erros comuns em simulações manuais.",
                                "Desenhe grafo de configs para NTM trivial."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de encoding de configurações (sem ambiguidades).",
                                "Correção da lógica BFS: evita loops e explora todos caminhos.",
                                "Análise temporal rigorosa com bounds assintóticos O(2^{p(n)}).",
                                "Clareza em diagramas de fita e transições.",
                                "Capacidade de simular exemplo prático sem erros.",
                                "Conexão explícita com classe NP."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: BFS em grafo implícito de configurações.",
                                "Algoritmos e Estruturas de Dados: Filas e conjuntos para busca exaustiva.",
                                "Complexidade Computacional: Relações entre classes TIME e NP.",
                                "Programação: Implementação de simuladores de autômatos em Python.",
                                "Lógica: Exploração de árvores de prova não-determinísticas."
                              ],
                              "realWorldApplication": "Essa simulação é fundamental em provas de NP-completude (ex: SAT solvers determinísticos), verificadores de hardware (model checking com BDDs), e compiladores de linguagens funcionais com busca paralela simulada."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.8.2.3.2",
                            "name": "Relacionar NTIME(f(n)) com NP",
                            "description": "Definir NP como união de NTIME(n^k) para k ≥ 1, mostrando que NTMs em tempo polinomial caracterizam problemas NP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir formalmente a classe NTIME(f(n))",
                                  "subSteps": [
                                    "Revise a definição de Máquina de Turing Não-Determinística (NTM).",
                                    "Defina NTIME(f(n)) como o conjunto de linguagens L ⊆ {0,1}* reconhecidas por alguma NTM M que para toda entrada x ∈ L, existe um caminho de aceitação com no máximo O(f(|x|)) passos.",
                                    "Escreva a notação formal: NTIME(f(n)) = { L | ∃ NTM M, ∃ c > 0, ∀ x ∈ L, |x| = n, existe caminho aceitando em ≤ c·f(n) passos }.",
                                    "Diferencie de DTIME(f(n)) destacando o não-determinismo.",
                                    "Exemplo simples: Mostre que {0^n 1^n | n ≥ 0} ∈ NTIME(n)."
                                  ],
                                  "verification": "Escreva a definição formal de NTIME(f(n)) e prove um exemplo simples como correto.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Cap. 7)",
                                    "Notas de aula sobre NTMs",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Comece com um exemplo concreto para fixar a ideia.",
                                    "Desenhe o grafo de computação da NTM para visualizar caminhos.",
                                    "Lembre-se: só caminhos de aceitação contam para o tempo."
                                  ],
                                  "learningObjective": "Compreender e formalizar a classe de tempo para NTMs.",
                                  "commonMistakes": [
                                    "Confundir tempo com número de branches (é o comprimento do caminho).",
                                    "Ignorar que o tempo é medido no pior caso para aceitação.",
                                    "Misturar com espaço (NSPACE)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar NTMs em tempo polinomial",
                                  "subSteps": [
                                    "Defina NTIME(poly(n)) informalmente como NTMs que rodam em tempo O(n^k) para algum k.",
                                    "Mostre que P ⊆ ∪_k NTIME(n^k) simulando DTM por NTM (mesmo tempo).",
                                    "Discuta como o não-determinismo permite 'adivinhar' soluções em tempo polinomial.",
                                    "Exemplo: NTM para SAT que adivinha atribuição e verifica em tempo polinomial.",
                                    "Prove que se uma linguagem está em NTIME(n^k), ela é decidível em tempo polinomial não-determinístico."
                                  ],
                                  "verification": "Construa uma NTM para um problema em P e meça seu tempo polinomial.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Ferramenta JFLAP para simular NTMs",
                                    "Exemplos de problemas P como PARITY",
                                    "Vídeos de teoria da computação no YouTube (Sipser lectures)"
                                  ],
                                  "tips": [
                                    "Pense no não-determinismo como 'fork' em programação paralela.",
                                    "Sempre normalize o tempo para O(n^k).",
                                    "Use pseudocódigo para descrever a NTM."
                                  ],
                                  "learningObjective": "Relacionar tempo polinomial em NTMs com poder computacional.",
                                  "commonMistakes": [
                                    "Achar que NTIME(n) = P (não é, P ⊆ NTIME(n)).",
                                    "Confundir verificação com busca.",
                                    "Esquecer que rejeição pode demorar mais (mas definimos por aceitação)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir NP como união de NTIME(n^k)",
                                  "subSteps": [
                                    "Defina formalmente NP = ∪_{k ≥ 1} NTIME(n^k).",
                                    "Justifique por que usar união: captura todos polinômios sem fixar k.",
                                    "Mostre que todo problema em NP tem uma NTM que roda em tempo n^k para algum k fixo.",
                                    "Exemplo: 3-SAT ∈ NP porque NTM adivinha atribuição (2^3n branches, mas caminho O(n)) e verifica.",
                                    "Compare com definição alternativa: problemas com verificador polinomial determinístico."
                                  ],
                                  "verification": "Escreva a definição de NP e prove que um problema conhecido como Hamiltoniano está em NP.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Paper sobre NP-completude",
                                    "Lista de problemas NP (Wikipedia)",
                                    "Sipser Theorem 7.18"
                                  ],
                                  "tips": [
                                    "Lembre: k é constante por máquina, não depende de n.",
                                    "Conecte com 'certificados' curtos.",
                                    "Evite provar P=NP aqui!"
                                  ],
                                  "learningObjective": "Estabelecer a definição padrão de NP via NTIME.",
                                  "commonMistakes": [
                                    "Pensar NP = NTIME(n) (é união).",
                                    "Confundir com co-NP.",
                                    "Ignorar que k ≥1 cobre todos polinômios."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar a caracterização de NP por NTMs em tempo polinomial",
                                  "subSteps": [
                                    "Prove: L ∈ NP iff L ∈ ∪_k NTIME(n^k).",
                                    "Direção ⇒: Dada NTM M para L em tempo p(n), assuma p(n) ≤ n^k para k grande o suficiente.",
                                    "Direção ⇐: Óbvio por definição da união.",
                                    "Discuta implicações: Toda linguagem em NP é reconhecida por NTM polinomial.",
                                    "Exemplo completo: Prove formalmente que SAT ∈ NP via NTIME(n^3)."
                                  ],
                                  "verification": "Escreva uma prova bidirecional curta da equivalência.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Arora & Barak 'Computational Complexity' (Cap. 5)",
                                    "Exercícios de provas em teoria da computação",
                                    "LaTeX para formalizar provas"
                                  ],
                                  "tips": [
                                    "Use lema de padding se necessário para normalizar polinômios.",
                                    "Foque em upper bounds para tempo.",
                                    "Pratique verbalizando a prova."
                                  ],
                                  "learningObjective": "Dominar a prova da relação NTIME com NP.",
                                  "commonMistakes": [
                                    "Não bounding k adequadamente.",
                                    "Confundir tempo de rejeição.",
                                    "Esquecer direção da prova."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o problema SAT: Construa uma NTM que, para fórmula φ com n variáveis, não-determinísticamente adivinha uma atribuição (em 1 passo), então verifica satisfatibilidade em O(n^3) tempo determinístico. Assim, SAT ∈ NTIME(n^3) ⊆ NP.",
                              "finalVerifications": [
                                "Defina corretamente NP como ∪ NTIME(n^k).",
                                "Prove P ⊆ NP via simulação DTM em NTM.",
                                "Construa NTM polinomial para um problema NP como Clique.",
                                "Explique por que o não-determinismo caracteriza NP.",
                                "Diferencie NTIME(f(n)) de SPACE.",
                                "Resolva exercício: Mostre VERTEX-COVER ∈ NP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de NTIME e NP (100% match).",
                                "Correção das provas bidirecionais (sem gaps lógicos).",
                                "Uso correto de exemplos concretos e bounds polinomiais.",
                                "Compreensão de não-determinismo vs. determinismo.",
                                "Capacidade de generalizar para outros problemas NP.",
                                "Clareza na explicação verbal ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e União Infinita.",
                                "Lógica: Verificadores e Certificados (semântica formal).",
                                "Algoritmos: Heurísticas para problemas NP-difíceis.",
                                "Filosofia: Questões de decidibilidade e Church-Turing."
                              ],
                              "realWorldApplication": "Essa relação fundamenta a classificação de problemas como NP-completos (ex: otimização de rotas em logística, scheduling em manufatura), guiando o design de algoritmos aproximados e solvers SAT usados em verificação de hardware e IA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.8.2.3.3",
                            "name": "Conectar NTMs a certificados e verificadores",
                            "description": "Interpretar um caminho aceitador de NTM como um certificado polinomial-length, verificável em tempo polinomial por uma TM determinística.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Caminho Aceitador em NTMs",
                                  "subSteps": [
                                    "Revise a definição de uma Máquina de Turing Não-Determinística (NTM), destacando sua capacidade de ramificação não-determinística.",
                                    "Identifique o que constitui um 'caminho de computação' em uma NTM, incluindo configuração inicial, transições e configuração final.",
                                    "Defina formalmente um 'caminho aceitador' como uma sequência de configurações que leva de uma entrada válida a um estado de aceitação.",
                                    "Analise por que uma NTM aceita uma linguagem se pelo menos um caminho aceitador existir para cada entrada na linguagem.",
                                    "Examine exemplos simples, como uma NTM para palíndromos pares."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito um caminho aceitador para uma NTM simples e confirme se ele leva à aceitação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Teoria da Computação (ex: Sipser)",
                                    "Papel e caneta para diagramas",
                                    "Simulador online de NTMs (opcional)"
                                  ],
                                  "tips": "Desenhe diagramas de configurações para visualizar ramificações; foque em um caminho específico, ignorando outros.",
                                  "learningObjective": "Entender a estrutura de um caminho aceitador como base para certificados.",
                                  "commonMistakes": [
                                    "Confundir caminho aceitador com todos os caminhos possíveis",
                                    "Ignorar a não-determinística como 'escolha adivinhação'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o Caminho Aceitador como Certificado de Tamanho Polinomial",
                                  "subSteps": [
                                    "Meça o comprimento de um caminho aceitador: prove que para entradas de tamanho n, o comprimento é O(n^k) para algum k constante.",
                                    "Codifique o caminho como uma string finita: sequência de símbolos de fita, cabeçote e estado em cada passo.",
                                    "Verifique que o tamanho do certificado é polinomial em n, pois o número de passos é polinomial.",
                                    "Compare com a definição de NP: linguagem onde 'sim' instâncias têm certificados curtos.",
                                    "Crie uma representação formal: cert(x, c) onde |c| ≤ p(|x|) para polinômio p."
                                  ],
                                  "verification": "Construa um certificado para uma entrada de tamanho n e calcule seu tamanho, confirmando que é ≤ n^3 (exemplo).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Notas de aula sobre NTMs e NP",
                                    "Editor de texto para pseudocódigo",
                                    "Calculadora para polinômios"
                                  ],
                                  "tips": "Use expoentes pequenos para exemplos; lembre que NTMs rodam em tempo polinomial por definição de NP.",
                                  "learningObjective": "Mapear caminhos de NTM diretamente a certificados curtos em NP.",
                                  "commonMistakes": [
                                    "Assumir certificados exponenciais",
                                    "Esquecer que apenas caminhos aceitadores contam"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir um Verificador Determinístico em Tempo Polinomial",
                                  "subSteps": [
                                    "Desenhe uma TM determinística V(x, c) que simula o caminho codificado em c.",
                                    "Implemente passos: valide formato de c, simule transições passo a passo sem ramificações.",
                                    "Garanta tempo polinomial: O(|c| * tempo por transição) = polinomial.",
                                    "Defina V aceita se simulação termina em aceitação sem erros.",
                                    "Teste com exemplo: valide transições locais entre configurações consecutivas."
                                  ],
                                  "verification": "Escreva pseudocódigo para V e simule manualmente em um exemplo curto.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Pseudocódigo templates para TMs",
                                    "Ferramenta de diagramação como Draw.io",
                                    "Exemplos de problemas NP como SAT"
                                  ],
                                  "tips": "Verificador só checa 'guesses' fornecidas; não procura caminhos.",
                                  "learningObjective": "Dominar a construção de verificadores DTIM para certificados de NTM.",
                                  "commonMistakes": [
                                    "Introduzir não-determinismo no verificador",
                                    "Não limitar a tempo polinomial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar Formalmente NTMs, Certificados e a Classe NP",
                                  "subSteps": [
                                    "Prove que L(NTM) ⊆ NP: para x em L, existe c (caminho), V(x,c) aceita em tempo poly.",
                                    "Mostre NP ⊆ L(NTM): para V em NP, construa NTM que adivinha c e roda V.",
                                    "Conclua que NP = {L | existe NTM com tempo poly aceitando L}.",
                                    "Discuta implicações: P=NP pergunta se verificadores podem ser eficientes sem certificados.",
                                    "Resuma em teorema: Caminhos aceitadores de NTMs poly-time definem NP."
                                  ],
                                  "verification": "Escreva uma prova curta (1 página) da equivalência e revise com critérios de correção.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Teorema de Cook-Levin ou Sipser Cap. 7",
                                    "Folha de exercícios NP-completude"
                                  ],
                                  "tips": "Use setas bidirecionais para ⊆ e ⊇ na prova.",
                                  "learningObjective": "Estabelecer a ponte conceitual entre NTMs e NP via certificados.",
                                  "commonMistakes": [
                                    "Confundir tempo da NTM com tempo do verificador",
                                    "Ignorar direção da inclusão"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o problema 'Clique': Dada uma grafo G e k, o certificado c é um conjunto S de k vértices. O verificador DTIM checa se toda par em S tem aresta em G (tempo O(k^2)). Isso simula um caminho aceitador de NTM que 'adivinha' S e verifica.",
                              "finalVerifications": [
                                "Explique como um caminho aceitador vira certificado curto.",
                                "Descreva o algoritmo do verificador sem não-determinismo.",
                                "Prove que o tempo total é polinomial para entrada n.",
                                "Dê um exemplo onde 'não' não tem certificado válido.",
                                "Compare com definição padrão de NP via verificadores.",
                                "Identifique por que isso não resolve P=NP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na codificação do certificado (tamanho poly).",
                                "Correção do verificador determinístico (simula sem branches).",
                                "Análise temporal rigorosa (O(n^k)).",
                                "Conexão clara com definição de NP.",
                                "Ausência de erros comuns como não-determinismo no V.",
                                "Uso de notação formal consistente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (cliques como exemplo NP).",
                                "Criptografia: Provas de Conhecimento Zero (verificadores eficientes).",
                                "Lógica: Teoremas de completude (analogia com provas curtas).",
                                "Filosofia da Computação: Limites da Computação (P vs NP).",
                                "Engenharia de Software: Testes automatizados (verificação de 'certificados' de código)."
                              ],
                              "realWorldApplication": "Em sistemas de blockchain e criptomoedas, verificadores polinomiais validam transações/provas sem revelar segredos (zk-SNARKs), simulando certificados de NTMs para escalabilidade segura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.2.2.2",
                              "10.1.8.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.8.2.3.4",
                            "name": "Exemplificar problemas NP via NTMs",
                            "description": "Modelar SAT ou Hamiltoniano como NTMs que 'adivinhham' atribuições ou caminhos e verificam em tempo polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de NTMs e Classe NP",
                                  "subSteps": [
                                    "Defina formalmente uma Máquina de Turing Não-Determinística (NTM), destacando branches não-determinísticos.",
                                    "Explique a relação entre NTMs e NP: uma linguagem está em NP se há uma NTM que aceita em tempo polinomial.",
                                    "Diferencie tempo de aceitação (existe branch aceitando) de tempo de rejeição (todos branches rejeitam).",
                                    "Liste exemplos clássicos de problemas NP: SAT e Hamiltonian Path/Cycle.",
                                    "Estude diagramas de NTMs simples para adivinhação."
                                  ],
                                  "verification": "Escreva definições precisas e desenhe um diagrama de NTM básica; compare com DTM equivalente.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 7), notas de aula, papel e caneta.",
                                  "tips": "Use setas ramificadas para visualizar não-determinismo em diagramas.",
                                  "learningObjective": "Compreender como NTMs modelam 'adivinhação' eficiente para NP.",
                                  "commonMistakes": "Confundir tempo polinomial de aceitação com tempo exponencial de simulação determinística."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar um Problema NP Específico: 3-SAT",
                                  "subSteps": [
                                    "Defina formalmente 3-SAT: fórmula em CNF com cláusulas de 3 literais.",
                                    "Explique por que 3-SAT é NP-completo via redução de SAT geral.",
                                    "Identifique a estrutura de solução: atribuição de valores verdadeiros/falsos para variáveis.",
                                    "Discuta o verificador determinístico: dada uma atribuição, cheque satisfação em O(n) tempo.",
                                    "Compare com Hamiltonian Path: 'adivinhar' permutação de vértices e verificar arestas."
                                  ],
                                  "verification": "Resolva manualmente uma instância pequena de 3-SAT e liste todas atribuições possíveis.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Ferramenta online SAT solver (para verificação), exemplos de fórmulas CNF.",
                                  "tips": "Comece com fórmulas pequenas (3 variáveis) para intuitivamente ver 8 atribuições.",
                                  "learningObjective": "Identificar o componente 'certificado' curto e verificável em problemas NP.",
                                  "commonMistakes": "Ignorar que verificação é polinomial apenas após adivinhação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir NTM para 3-SAT",
                                  "subSteps": [
                                    "Descreva estados iniciais: ler fórmula, não-determinísticamente gerar atribuição bit a bit.",
                                    "Detalhe branch não-determinístico: para cada variável, escolha 0 ou 1 via ε-transições.",
                                    "Implemente fase de verificação: deterministicamente cheque cada cláusula usando a atribuição gerada.",
                                    "Defina tape com fórmula, atribuição e ponteiro para cláusulas; rejeite se alguma cláusula falsa.",
                                    "Adapte para Hamiltonian Path: não-determinísticamente gerar caminho, verificar adjacência."
                                  ],
                                  "verification": "Desenhe diagrama completo da NTM com pelo menos 5 estados e transições anotadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de desenho de diagramas (Draw.io), pseudocódigo de NTMs.",
                                  "tips": "Use tape separado para atribuição gerada para evitar sobrescrita da entrada.",
                                  "learningObjective": "Modelar adivinhação como não-determinismo e verificação como DTM embutida.",
                                  "commonMistakes": "Fazer verificação não-determinística; deve ser determinística e polinomial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Correção e Complexidade da NTM",
                                  "subSteps": [
                                    "Prove aceitação: se SAT, existe branch gerando atribuição correta, verifica em O(n).",
                                    "Prove rejeição: todas branches verificam e rejeitam se não-SAT.",
                                    "Calcule tempo: adivinhação O(n), verificação O(m*3) onde m=cláusulas, polinomial.",
                                    "Simule passo a passo uma instância pequena em branches paralelas.",
                                    "Compare com NTM para Hamiltonian: similar, mas tape para permutação de vértices."
                                  ],
                                  "verification": "Simule NTM em 2 instâncias (uma SAT, uma não) e documente branches.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Planilha para simulação manual de tape/configuração.",
                                  "tips": "Pense em branches como 'paralelismo infinito' para tempo polinomial.",
                                  "learningObjective": "Confirmar que NTM captura essência de NP via tempo polinomial de aceitação.",
                                  "commonMistakes": "Confundir complexidade da NTM com a DTM simuladora (exponencial)."
                                }
                              ],
                              "practicalExample": "Para 3-SAT φ = (x1 ∨ ¬x2 ∨ x3) ∧ (¬x1 ∨ x2 ∨ ¬x3): NTM lê φ no tape, não-determinísticamente escreve atribuição (ex: 1,0,1) em tape auxiliar, verifica cláusula 1: 1∨¬0∨1=true; cláusula 2: ¬1∨0∨¬1=false? Não, rejeita este branch. Outro branch (0,1,0): verifica true/true, aceita.",
                              "finalVerifications": [
                                "Descreva corretamente como NTM aceita em polinomial se solução existe.",
                                "Desenhe NTM funcional para 3-SAT com adivinhação e verificação.",
                                "Explique diferença entre branches aceitantes e rejeitantes.",
                                "Aplique modelo similar a Hamiltonian Path.",
                                "Calcule tempo de tape usado: O(n) células.",
                                "Prove que sem não-determinismo seria PSPACE ou pior."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de não-determinismo para adivinhação (30%).",
                                "Correção da fase de verificação polinomial (25%).",
                                "Clareza no diagrama e pseudocódigo da NTM (20%).",
                                "Generalização para outros problemas NP (15%).",
                                "Identificação de erros comuns em provas de complexidade (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e teoria de grafos (Hamiltoniano).",
                                "Filosofia: Conceitos de 'busca exaustiva' vs. 'verificação eficiente'.",
                                "Engenharia de Software: Verificação de software e test oracles.",
                                "Inteligência Artificial: Busca heurística em espaços de solução NP."
                              ],
                              "realWorldApplication": "Em criptografia (quebra de chaves via SAT solvers como MiniSat), otimização de rotas (Hamiltoniano em logística) e verificação de hardware (modelagem de circuitos como SAT para fabricação de chips)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.3",
                    "name": "Verificadores Polinomiais",
                    "description": "Definição alternativa da classe NP via máquinas determinísticas que verificam certificados em tempo polinomial.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.3.1",
                        "name": "Certificado em Problemas NP",
                        "description": "Um certificado é uma string de comprimento polinomial que serve como prova de que uma dada instância de um problema pertence à linguagem decidida por uma máquina não-determinística em tempo polinomial.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.1.1",
                            "name": "Definir o conceito de certificado",
                            "description": "Explicar que um certificado c para uma instância x é uma string |c| ≤ p(|x|) para algum polinômio p, tal que comprova x ∈ L.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais: Instância e Linguagem",
                                  "subSteps": [
                                    "Relembre a definição de uma linguagem formal L como um subconjunto de strings Σ*.",
                                    "Entenda uma instância x como uma string específica em Σ* para a qual queremos decidir se x ∈ L.",
                                    "Diferencie problemas de decisão de linguagens formais em ciência da computação.",
                                    "Identifique exemplos simples de linguagens, como PALINDROMES ou EVEN-LENGTH.",
                                    "Pratique notação: |x| denota o comprimento da string x."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é uma instância x e seu papel em relação a L, com um exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre linguagens formais",
                                    "Quadro ou papel para diagramas",
                                    "Exemplos de problemas de decisão"
                                  ],
                                  "tips": "Use analogias cotidianas, como 'x é uma pergunta específica sobre se um número é primo (L = PRIMES)'.",
                                  "learningObjective": "Compreender os pré-requisitos para o conceito de certificado em problemas NP.",
                                  "commonMistakes": "Confundir instância x com a linguagem inteira L; ignorar que x é finita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito Informal de Certificado",
                                  "subSteps": [
                                    "Defina informalmente um certificado como uma 'prova curta' que convence que x ∈ L.",
                                    "Discuta por que precisamos de certificados: para problemas difíceis de decidir diretamente.",
                                    "Compare com uma prova completa: certificado é sucinto, verificável rapidamente.",
                                    "Pense em exemplos intuitivos: para 'x tem ciclo hamiltoniano', certificado é o ciclo.",
                                    "Escreva uma definição informal em suas palavras."
                                  ],
                                  "verification": "Forneça um exemplo informal de certificado para uma linguagem conhecida, como SAT.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos clássicos de problemas NP (SAT, HAM-CYCLE)",
                                    "Vídeo introdutório sobre NP (opcional)"
                                  ],
                                  "tips": "Visualize o certificado como um 'bilhete de loteria vencedora' que você verifica rapidamente.",
                                  "learningObjective": "Graspar intuitivamente o propósito de um certificado em contextos NP.",
                                  "commonMistakes": "Pensar que certificado resolve o problema; confundir com algoritmo de decisão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Definição do Certificado",
                                  "subSteps": [
                                    "Estude a definição: c é um certificado para x se |c| ≤ p(|x|) para algum polinômio p.",
                                    "Aprenda que c comprova x ∈ L via um verificador polinomial V(c, x) = 1.",
                                    "Escreva a definição matemática completa: ∃c, |c| ≤ p(|x|), V(c, x) aceita.",
                                    "Pratique com notação: p é polinômio em |x|, não em x.",
                                    "Diferencie 'comprova' de 'decide': só para sim, não para não."
                                  ],
                                  "verification": "Escreva a definição formal exata e identifique os componentes chave (c, p, V).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Folha de fórmulas",
                                    "Calculadora para polinômios simples"
                                  ],
                                  "tips": "Memorize a estrutura: tamanho polinomial + verificador polinomial.",
                                  "learningObjective": "Dominar a definição matemática precisa de certificado.",
                                  "commonMistakes": "Escrever |c| ≤ p(x) em vez de p(|x|); omitir o verificador V."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Propriedades e Exemplos do Certificado",
                                  "subSteps": [
                                    "Verifique por que o tamanho é polinomial: para eficiência de verificação.",
                                    "Analise um exemplo: para 3-SAT, c é uma atribuição de variáveis.",
                                    "Confirme que V(c, x) roda em tempo polinomial.",
                                    "Discuta o que acontece se x ∉ L: não existe tal c.",
                                    "Crie seu próprio exemplo simples para outra linguagem NP."
                                  ],
                                  "verification": "Aplique a definição a um exemplo específico e valide o certificado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de 3-SAT ou SUBSET-SUM",
                                    "Ferramenta online para SAT solvers (opcional)"
                                  ],
                                  "tips": "Sempre pergunte: 'O verificador é rápido? O certificado é curto?'",
                                  "learningObjective": "Aplicar e validar o conceito de certificado em contextos reais.",
                                  "commonMistakes": "Aceitar certificados de tamanho exponencial; ignorar tempo do verificador."
                                }
                              ],
                              "practicalExample": "Para o problema 3-SAT com instância x = cláusulas lógicas (ex: (a∨¬b∨c) ∧ (¬a∨b∨¬d)), um certificado c é uma atribuição como {a=1, b=0, c=1, d=0}, com |c| = O(n) onde n=|x|. O verificador V(c,x) pluga valores nas cláusulas e checa se todas são verdadeiras em tempo polinomial.",
                              "finalVerifications": [
                                "Defina corretamente certificado usando notação formal.",
                                "Identifique tamanho polinomial e papel do verificador.",
                                "Forneça exemplo válido de certificado para problema NP.",
                                "Explique por que certificados só existem para x ∈ L.",
                                "Diferencie certificado de algoritmo de decisão completo.",
                                "Valide um certificado dado para uma instância x."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (tamanho ≤ p(|x|), comprovação via V).",
                                "Compreensão do papel do verificador polinomial.",
                                "Capacidade de gerar exemplos corretos e validar certificados.",
                                "Identificação de erros comuns como tamanho exponencial.",
                                "Clareza na distinção entre 'sim' e 'não' instâncias.",
                                "Aplicação coerente em contextos NP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios e complexidade assintótica (O-notation).",
                                "Lógica: Fórmulas proposicionais e satisfatibilidade (SAT).",
                                "Criptografia: Provas de conhecimento zero (ZKPs) baseadas em verificadores.",
                                "Filosofia: Conceitos de prova e evidência verificável."
                              ],
                              "realWorldApplication": "Em criptografia, certificados NP são usados em protocolos como zk-SNARKs para provar conhecimento sem revelar informações (ex: transações blockchain privadas); em verificação de software, para checar propriedades críticas rapidamente com 'provas' curtas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.1.2",
                            "name": "Identificar propriedades de certificados",
                            "description": "Listar e justificar que certificados devem ter tamanho polinomial em |x| e serem verificáveis deterministicamente em tempo polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de certificado em problemas NP",
                                  "subSteps": [
                                    "Revise a definição de classe NP: problemas cujas soluções 'sim' têm certificados verificáveis rapidamente.",
                                    "Identifique que um certificado é uma 'prova' curta fornecida para instâncias 'sim'.",
                                    "Diferencie verificador determinístico de máquina não-determinística.",
                                    "Estude exemplos básicos como SAT ou Hamiltoniano.",
                                    "Anote as funções chave: V(x, c) aceita se x é sim e c é certificado válido."
                                  ],
                                  "verification": "Escreva uma definição precisa de certificado NP em suas próprias palavras e compare com fontes padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre complexidade computacional, livro-texto (ex: Sipser 'Introduction to the Theory of Computation'), Wikipedia página NP.",
                                  "tips": "Use diagramas para visualizar a interação entre instância x, certificado c e verificador V.",
                                  "learningObjective": "Compreender o papel fundamental dos certificados na definição de NP.",
                                  "commonMistakes": "Confundir certificado com solução completa; lembre-se que é uma prova curta, não a solução em si."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a propriedade de tamanho polinomial do certificado",
                                  "subSteps": [
                                    "Defina 'tamanho polinomial em |x|': |c| ≤ p(|x|) para algum polinômio p.",
                                    "Explique por que tamanho exponencial tornaria o certificado impraticável.",
                                    "Calcule tamanhos para exemplos: em SAT, certificado é atribuição de variáveis (tamanho O(n)).",
                                    "Prove informalmente que se |c| é superpolinomial, NP colapsa com PSPACE.",
                                    "Liste consequências: permite envio e armazenamento eficientes."
                                  ],
                                  "verification": "Para um problema NP dado, compute e justifique se um certificado proposto tem tamanho polinomial.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Exemplos de problemas NP (SAT, Clique), calculadora ou papel para simulações, slides sobre limites de tamanho.",
                                  "tips": "Pense em |x| como entrada; certificado deve caber em memória polinomial.",
                                  "learningObjective": "Dominar e justificar a necessidade de |c| polinomial em |x|.",
                                  "commonMistakes": "Ignorar dependência em |x|; sempre relacione com tamanho da entrada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar verificação determinística em tempo polinomial",
                                  "subSteps": [
                                    "Defina verificador: TM determinística V que em tempo p(|x| + |c|) decide se c prova x sim.",
                                    "Compare com não-determinismo: NP usa 'adivinhação', mas verificação é determinística.",
                                    "Implemente pseudocódigo para verificador SAT: cheque cláusulas com atribuição c.",
                                    "Meça complexidade: para SAT, O(n*m) onde n vars, m cláusulas, polinomial.",
                                    "Discuta por que determinístico: garante reprodutibilidade sem adivinhação."
                                  ],
                                  "verification": "Escreva um verificador simples para um problema NP e analise sua complexidade temporal.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Pseudocódigo editor (ex: Notepad++), exemplos de verificadores de problemas NP padrão.",
                                  "tips": "Foquem em worst-case; tempo deve ser polinomial mesmo para certificados grandes.",
                                  "learningObjective": "Entender e demonstrar verificação polinomial determinística.",
                                  "commonMistakes": "Confundir tempo de V com tempo de busca por c; V só verifica, não gera."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Listar e justificar ambas as propriedades integralmente",
                                  "subSteps": [
                                    "Liste as duas propriedades: 1) |c| polinomial em |x|, 2) V determinística em tempo polinomial.",
                                    "Justifique 1: evita certificados 'infinitos' ou impraticáveis.",
                                    "Justifique 2: assegura eficiência na checagem pós-'adivinhação'.",
                                    "Integre: sem ambas, definição NP perde sentido (nem curta nem rápida).",
                                    "Aplique a um novo problema: ex: Subconjunto Soma, certificado é subconjunto."
                                  ],
                                  "verification": "Redija uma justificativa completa das propriedades e teste em 2 problemas NP.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de exercícios com problemas NP, resumo anterior dos steps 1-3.",
                                  "tips": "Use bullet points para listar; justifique com impactos na teoria da complexidade.",
                                  "learningObjective": "Capacitar listar e justificar propriedades de certificados de forma autônoma.",
                                  "commonMistakes": "Omitir justificativa; sempre explique 'por quê' além do 'o quê'."
                                }
                              ],
                              "practicalExample": "Para SAT com fórmula (x1 ∨ ¬x2) ∧ (¬x1 ∨ x3): certificado c = {x1=0, x2=1, x3=1} (tamanho 3, polinomial em |x|≈10). Verificador: plugue valores, cheque cada cláusula em O(1) por cláusula, total polinomial.",
                              "finalVerifications": [
                                "Lista corretamente as duas propriedades principais de certificados NP.",
                                "Justifica tamanho polinomial com relação a |x| e praticidade.",
                                "Explica verificação determinística polinomial com exemplo de complexidade.",
                                "Identifica violações potenciais em exemplos hipotéticos.",
                                "Aplica propriedades a pelo menos dois problemas NP padrão.",
                                "Diferencia corretamente certificado de solução completa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e lista de propriedades (30%)",
                                "Qualidade das justificativas teóricas e práticas (25%)",
                                "Uso correto de notação de complexidade (20%)",
                                "Exemplos relevantes e cálculos de tamanho/tempo (15%)",
                                "Clareza e estrutura na exposição (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e polinômios (funções de crescimento).",
                                "Lógica: Estruturas de prova e verificação formal.",
                                "Algoritmos: Design de verificadores eficientes.",
                                "Filosofia da Ciência: Conceitos de 'prova' e reprodutibilidade."
                              ],
                              "realWorldApplication": "Em criptografia, protocolos zero-knowledge usam certificados NP para provar conhecimento sem revelar segredos (ex: Zcash transações), garantindo eficiência polinomial para escalabilidade em blockchains."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.1.3",
                            "name": "Fornecer exemplos de certificados",
                            "description": "Dar exemplos como certificado para SAT (atribuição de variáveis) ou para Hamiltoniano (caminho hamiltoniano explicitado).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de certificado em problemas NP",
                                  "subSteps": [
                                    "Revise a definição de problema NP: soluções verificáveis em tempo polinomial.",
                                    "Identifique que um certificado é uma 'prova' curta que um verificador polinomial usa para confirmar uma solução 'sim'.",
                                    "Diferencie certificado de solução: certificado é fornecido pelo 'sim', verificador checa rapidamente.",
                                    "Estude exemplos genéricos de problemas NP como SAT e Hamiltoniano.",
                                    "Anote as propriedades: tamanho polinomial e verificação em P."
                                  ],
                                  "verification": "Escreva uma definição própria de certificado NP e cite 2 propriedades chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de teoria da computação ou slides sobre NP-completude; papel e caneta.",
                                  "tips": "Use analogia: certificado é como um bilhete premiado que a loteria verifica rapidamente.",
                                  "learningObjective": "Compreender o papel e as características fundamentais de um certificado em problemas NP.",
                                  "commonMistakes": "Confundir certificado com algoritmo de busca exponencial; ignorar requisito de tempo polinomial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir exemplo de certificado para SAT",
                                  "subSteps": [
                                    "Lembre-se: SAT é satisfatibilidade booleana (3-SAT para NP-completude).",
                                    "Crie uma instância simples: fórmula como (x1 ∨ ¬x2 ∨ x3) ∧ (¬x1 ∨ x2 ∨ ¬x3).",
                                    "Forneça certificado: atribuição de variáveis, ex: x1=true, x2=false, x3=true.",
                                    "Explique verificação: substitua valores e cheque se todas cláusulas são verdadeiras em tempo linear.",
                                    "Teste com uma instância 'não' para contrastar (sem atribuição satisfatória)."
                                  ],
                                  "verification": "Escreva uma fórmula 3-SAT e seu certificado, simulando a verificação manual.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto ou papel; tabela-verdade opcional para fórmulas pequenas.",
                                  "tips": "Sempre liste todas variáveis atribuídas para evitar ambiguidades.",
                                  "learningObjective": "Aplicar o conceito de certificado a SAT, identificando atribuição válida.",
                                  "commonMistakes": "Atribuir só variáveis usadas em uma cláusula; esquecer verificação polinomial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir exemplo de certificado para Problema do Caminho Hamiltoniano",
                                  "subSteps": [
                                    "Defina Hamiltoniano: caminho que visita cada vértice exatamente uma vez em grafo direcionado.",
                                    "Crie grafo simples: 4 vértices A->B->C->D->A (ciclo).",
                                    "Forneça certificado: sequência de vértices, ex: A, B, C, D.",
                                    "Descreva verificador: cheque |sequência|=n+1, todos vértices únicos, arestas consecutivas existem (O(n) tempo).",
                                    "Compare com SAT: ambos certificados são listas curtas (atribuições ou sequências)."
                                  ],
                                  "verification": "Desenhe um grafo pequeno, forneça certificado e liste passos de verificação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel para desenhar grafos; software como Graphviz ou Draw.io opcional.",
                                  "tips": "Numere vértices na sequência para clareza visual.",
                                  "learningObjective": "Demonstrar certificado para Hamiltoniano, destacando verificação de arestas e unicidade.",
                                  "commonMistakes": "Permitir visitas repetidas; confundir com caminho euleriano (arestas únicas)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar e praticar exemplos adicionais",
                                  "subSteps": [
                                    "Identifique padrões: certificados são listas/estruturas de tamanho O(n).",
                                    "Crie exemplo para outro NP: Clique (subgrafo completo K_k). Certificado: lista de k vértices.",
                                    "Pratique verificação: escreva pseudocódigo para verificador genérico.",
                                    "Discuta por que certificados provam NP ≠ P? (não para 'não' instâncias).",
                                    "Resuma diferenças entre SAT (atribuição) e Hamilton (permutação)."
                                  ],
                                  "verification": "Forneça certificados para 2 novos problemas NP e explique verificadores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Notas anteriores; acesso a Wikipedia para problemas NP extras.",
                                  "tips": "Sempre especifique tamanho do input n para justificar polinomialidade.",
                                  "learningObjective": "Generalizar o fornecimento de certificados para múltiplos problemas NP.",
                                  "commonMistakes": "Usar certificados longos/exponenciais; pular verificação explícita."
                                }
                              ],
                              "practicalExample": "Para fórmula SAT: (x ∨ y ∨ ¬z) ∧ (¬x ∨ ¬y ∨ z). Certificado: {x=true, y=false, z=false}. Verificação: Primeira cláusula true (x), segunda true (¬x falso mas ¬y e z cobrem? Espera: ¬x=false, ¬y=true, z=false → true por ¬y). Tempo O(m*n) onde m=cláusulas.",
                              "finalVerifications": [
                                "Explica corretamente certificado para SAT com atribuição explícita.",
                                "Descreve verificador Hamiltoniano checando unicidade e arestas.",
                                "Identifica tamanho polinomial do certificado em exemplos.",
                                "Distingue instância 'sim' de 'não' via existência de certificado.",
                                "Fornece pseudocódigo simples para um verificador.",
                                "Compara certificados de 2 problemas NP diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição e propriedades corretas (30%).",
                                "Exemplos concretos: instâncias + certificados válidos (25%).",
                                "Descrição de verificação: passos claros e polinomiais (20%).",
                                "Generalização: padrões e comparações (15%).",
                                "Clareza e completude: sem ambiguidades (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e teoria dos grafos.",
                                "Algoritmos: Diferença entre P (verificação) e NP (busca).",
                                "Filosofia: Natureza da prova e verificabilidade.",
                                "Criptografia: Protocolos de prova de conhecimento zero."
                              ],
                              "realWorldApplication": "Em compiladores para verificar otimizações SAT-like; em jogos para validar soluções de puzzles NP (ex: Sudoku solvers); em blockchain para proofs de trabalho com verificadores rápidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.3.2",
                        "name": "Verificador Polinomial",
                        "description": "Uma máquina de Turing determinística que, recebendo uma instância x e um certificado c, decide em tempo polinomial se c é uma prova válida para x ∈ L.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.2.1",
                            "name": "Formalizar a definição de verificador",
                            "description": "Definir V como MT determinística onde V(x,c) aceita se c verifica x, com tempo de execução ≤ q(|x| + |c|) para polinômio q.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Máquinas de Turing Determinísticas",
                                  "subSteps": [
                                    "Relembre a definição formal de uma Máquina de Turing (MT) determinística: conjunto de estados Q, alfabeto Γ, função de transição δ, estado inicial q0, estados de aceitação F e rejeição.",
                                    "Entenda o conceito de configuração de uma MT e como ela evolui deterministicamente.",
                                    "Defina o tempo de execução de uma MT em uma entrada x como o número máximo de passos até halting.",
                                    "Estude tempo polinomial: existe polinômio q tal que tempo ≤ q(|x|) para toda x.",
                                    "Pratique simulando uma MT simples que decide uma linguagem regular em tempo polinomial."
                                  ],
                                  "verification": "Simule manualmente uma MT em uma entrada pequena e confirme que para em tempo polinomial, registrando o número de passos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Teoria da Computação (Sipser ou similar), simulador de MT online (ex: JFLAP).",
                                  "tips": "Desenhe a fita e cabeçote em papel para visualizar transições.",
                                  "learningObjective": "Compreender MT determinísticas e medida de tempo polinomial como base para verificadores.",
                                  "commonMistakes": "Confundir MT determinística com não-determinística; ignorar que tempo é função do tamanho da entrada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Certificado e Verificação",
                                  "subSteps": [
                                    "Defina certificado c como uma string curta (|c| ≤ q(|x|)) que 'prova' x ∈ L.",
                                    "Explique que V(x,c) deve aceitar IFF c verifica x (aceita se sim, rejeita se não).",
                                    "Discuta por que V é determinística: sem adivinhação, só checagem.",
                                    "Compare com decisor: decisor não precisa de c, mas verificador sim para eficiência.",
                                    "Analise exemplo informal: para SAT, c é atribuição de variáveis."
                                  ],
                                  "verification": "Escreva uma definição informal de verificador para o problema de paridade de números binários.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre NP, exemplos de problemas em NP (SAT, Hamiltoniano).",
                                  "tips": "Pense em c como 'evidência' que um juiz (V) checa rapidamente.",
                                  "learningObjective": "Graspar o papel do certificado c na distinção entre decisão e verificação.",
                                  "commonMistakes": "Achar que c pode ser longo; confundir aceitação com decisão sem c."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Definição Completa de Verificador Polinomial",
                                  "subSteps": [
                                    "Escreva: L ∈ NP se ∃ MT det. V, polinômio q s.t. (1) ∀x ∈ L, ∃c |c|≤q(|x|), V(x,c) aceita em ≤q(|x|+|c|) passos; (2) ∀x ∉ L, ∀c, V(x,c) rejeita.",
                                    "Especifique V(x,c) aceita se entra em estado de aceitação.",
                                    "Enfatize tempo ≤ q(|x| + |c|) polinomial no tamanho combinado.",
                                    "Prove que q deve ser o mesmo para comprimento e tempo.",
                                    "Formalize em notação matemática: V ∈ DTIME(poly), com condições de completude e correção."
                                  ],
                                  "verification": "Escreva a definição formal em um papel e verifique contra referência padrão (ex: Sipser).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Referência: Sipser 'Introduction to the Theory of Computation' Capítulo 8, papel e caneta.",
                                  "tips": "Use quantificadores ∀∃ corretamente: ∀x ∃c para x em L, ∀x ∀c para x não em L.",
                                  "learningObjective": "Dominar a definição precisa de verificador polinomial para NP.",
                                  "commonMistakes": "Esquecer a condição de rejeição para x ∉ L; usar tempo q(|x|) só, ignorando |c|."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar a Definição em Exemplos",
                                  "subSteps": [
                                    "Para SAT: defina V que checa se atribuição c satisfaz fórmula x em tempo polinomial.",
                                    "Simule V em uma instância pequena de 3-SAT com c dado.",
                                    "Mostre que para x insatisfazível, nenhum c faz aceitar.",
                                    "Discuta generalização para outros problemas NP como Clique ou Subset Sum.",
                                    "Escreva pseudocódigo para V genérica."
                                  ],
                                  "verification": "Implemente uma simulação simples de V para SAT em Python e teste com entradas válidas/inválidas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python), instâncias de SAT de sites como SATLIB.",
                                  "tips": "Comece com fórmulas pequenas (3 variáveis) para depuração fácil.",
                                  "learningObjective": "Aplicar a definição formal a problemas concretos e validar propriedades.",
                                  "commonMistakes": "Implementar V que adivinha c (não-det.); exceder tempo polinomial na simulação."
                                }
                              ],
                              "practicalExample": "Para 3-SAT com fórmula x = (a∨¬b∨c) ∧ (¬a∨b∨¬d), c = 'a=1,b=0,c=1,d=0'. V(x,c) parseia x, aplica c às cláusulas e checa se todas verdadeiras em O(|x|) tempo.",
                              "finalVerifications": [
                                "Escreva a definição formal sem olhar referências e compare com padrão.",
                                "Para um x ∈ L, encontre c válido e simule V aceitando em tempo poly.",
                                "Para x ∉ L, teste 3 cs diferentes e confirme rejeição.",
                                "Prove que |c| ≤ q(|x|) e tempo ≤ q(|x|+|c|).",
                                "Explique diferença entre verificador e decisor NP.",
                                "Crie diagrama de V para problema simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formalização: quantificadores e condições corretas (peso 30%).",
                                "Compreensão de tempo polinomial em |x|+|c| (peso 20%).",
                                "Exemplos corretos com simulações (peso 20%).",
                                "Identificação de erros comuns em definições (peso 15%).",
                                "Aplicação a problemas NP padrão (peso 10%).",
                                "Clareza na escrita e pseudocódigo (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica de primeira ordem (quantificadores ∀∃).",
                                "Filosofia: Epistemologia da prova e verificação.",
                                "Engenharia de Software: Testes unitários e validação de certificados.",
                                "Criptografia: Verificação de provas zero-knowledge."
                              ],
                              "realWorldApplication": "Em compiladores, verificadores polinomiais checam otimizações com provas curtas; em blockchain, valida transações com certificados eficientes sem reexecutar tudo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.2.2",
                            "name": "Analisar o tempo de execução do verificador",
                            "description": "Explicar por que o tempo polinomial em |x| + |c| implica polinomial em |x| dado |c| polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tamanhos de entrada |x| e |c|",
                                  "subSteps": [
                                    "Defina |x| como o tamanho da instância do problema.",
                                    "Defina |c| como o tamanho do certificado fornecido.",
                                    "Explique a suposição de que |c| é polinomial em |x|, ou seja, |c| ≤ p(|x|) para algum polinômio p.",
                                    "Ilustre com um exemplo simples onde |c| ≈ |x|."
                                  ],
                                  "verification": "Escreva definições claras e um exemplo numérico onde |c| ≤ |x|^2.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, notas de aula sobre NP",
                                  "tips": "Use notação O() para clareza assintótica desde o início.",
                                  "learningObjective": "Entender a relação entre tamanhos de entrada no contexto de verificadores NP.",
                                  "commonMistakes": "Confundir |x| com o número de variáveis em vez do tamanho da string."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recordar a definição de tempo polinomial",
                                  "subSteps": [
                                    "Lembre que um algoritmo é polinomial se T(n) ≤ k n^d para constantes k, d.",
                                    "Aplique isso ao verificador V(x, c) com tempo T(|x| + |c|).",
                                    "Discuta por que o tempo é medido em |x| + |c|, pois ambos são entradas.",
                                    "Verifique que T(m) é polinomial em m = |x| + |c|."
                                  ],
                                  "verification": "Escreva a definição formal e confirme com uma função exemplo T(m) = m^3.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Livro de teoria da computação (ex: Sipser), calculadora",
                                  "tips": "Pense em big-O para evitar contantes desnecessárias.",
                                  "learningObjective": "Dominar a noção de tempo polinomial em entradas concatenadas.",
                                  "commonMistakes": "Ignorar que o tempo é em relação ao tamanho total da entrada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a relação |x| + |c| quando |c| é polinomial em |x|",
                                  "subSteps": [
                                    "Mostre que |x| + |c| ≤ |x| + p(|x|) ≤ q(|x|) para polinômio q.",
                                    "Prove que soma de polinômios é polinômio: grau máximo domina.",
                                    "Substitua: se T é poly em m, e m ≤ r(|x|), então T(m) ≤ poly(|x|).",
                                    "Calcule explicitamente: se |c| ≤ |x|^k, então |x| + |c| ≤ 2 |x|^k para |x| grande."
                                  ],
                                  "verification": "Derive matematicamente que |x| + |c| = O(|x|^d) e escreva a prova.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para provas, software como Wolfram Alpha para verificar polinômios",
                                  "tips": "Use indução ou propriedades assintóticas para simplificar.",
                                  "learningObjective": "Compreender composição de funções polinomiais.",
                                  "commonMistakes": "Esquecer o fator assintótico para grandes |x|."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar à análise do tempo de execução do verificador",
                                  "subSteps": [
                                    "Conclua que T(|x| + |c|) é polinomial em |x| dado |c| poly em |x|.",
                                    "Discuta implicações para a classe NP.",
                                    "Teste com desigualdades: T(|x| + |c|) ≤ c (|x| + |c|)^d ≤ poly(|x|).",
                                    "Resuma em uma frase chave: 'polinomial em |x| + |c| implica polinomial em |x|'."
                                  ],
                                  "verification": "Escreva um parágrafo explicativo completo e teste com números.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplos de problemas NP (SAT, Clique)",
                                  "tips": "Sempre volte à definição original de NP para contextualizar.",
                                  "learningObjective": "Integrar todos os conceitos em uma explicação coesa.",
                                  "commonMistakes": "Não mencionar explicitamente a hipótese |c| polinomial."
                                }
                              ],
                              "practicalExample": "No problema SAT com fórmula φ de tamanho |x| ≈ 3n (n cláusulas, 3 literais), certificado c é atribuição de n bits (|c| = n ≤ |x|/3). Verificador constrói tabela verdade parcial em O((|x| + |c|)^2) = O(|x|^2), polinomial em |x|.",
                              "finalVerifications": [
                                "Explica corretamente por que |x| + |c| permanece polinomial em |x|.",
                                "Deriva matematicamente T(|x| + |c|) ≤ poly(|x|).",
                                "Identifica erros comuns como ignorar |c| poly.",
                                "Aplica a um exemplo concreto como SAT.",
                                "Resume em uma declaração precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de tamanhos e polinômios (30%)",
                                "Correção da prova assintótica (30%)",
                                "Clareza na explicação e uso de notação (20%)",
                                "Uso de exemplos práticos (10%)",
                                "Identificação de erros comuns (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e funções polinomiais",
                                "Algoritmos: Análise de complexidade temporal",
                                "Lógica: Verificação de fórmulas proposicionais",
                                "Otimização: Problemas combinatoriais em NP"
                              ],
                              "realWorldApplication": "Essa análise é crucial para provar que problemas como SAT, TSP e fatoração estão em NP, impactando algoritmos de IA, criptografia (ex: Shor's algorithm) e otimização em logística, onde certificados polinomiais garantem verificação eficiente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.2.3",
                            "name": "Construir um verificador simples",
                            "description": "Construir um verificador para o problema Hamiltoniano, verificando se o caminho dado forma um ciclo visitando todos vértices exatamente uma vez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Estrutura de Entrada do Verificador",
                                  "subSteps": [
                                    "Identifique os componentes de entrada: grafo G representado por matriz de adjacência ou lista de adjacência, e o caminho proposto como uma lista de vértices P = [p1, p2, ..., pn].",
                                    "Determine n como o número total de vértices no grafo G.",
                                    "Valide que o comprimento de P é exatamente n.",
                                    "Garanta que todos os vértices em P estão no conjunto de vértices de G.",
                                    "Prepare estruturas auxiliares, como um conjunto para rastrear vértices visitados."
                                  ],
                                  "verification": "Confirme que as entradas foram parseadas corretamente imprimindo n, lista P e representação do grafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para esboço",
                                    "Editor de texto ou IDE como VS Code",
                                    "Biblioteca de grafos opcional (ex: NetworkX em Python)"
                                  ],
                                  "tips": "Use representações eficientes como matriz booleana para adjacência para consultas O(1).",
                                  "learningObjective": "Compreender e formalizar as entradas para um verificador polinomial.",
                                  "commonMistakes": [
                                    "Assumir lista de adjacência sem converter para consultas rápidas",
                                    "Ignorar validação inicial de n == len(P)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Unicidade e Completude dos Vértices no Caminho",
                                  "subSteps": [
                                    "Crie um conjunto vazio para vértices únicos.",
                                    "Para cada vértice em P, verifique se já existe no conjunto; se sim, rejeite.",
                                    "Adicione o vértice ao conjunto.",
                                    "Após o loop, confirme se o tamanho do conjunto é igual a n.",
                                    "Se não, rejeite por não cobrir todos os vértices ou ter duplicatas."
                                  ],
                                  "verification": "Teste com um caminho duplicado (ex: [1,2,1]) e um faltante (ex: [1,2] para n=3); deve rejeitar ambos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pseudocódigo ou código em Python/Java",
                                    "Exemplos de grafos pequenos"
                                  ],
                                  "tips": "Use HashSet para O(1) inserções e lookups em linguagens como Java ou Python set.",
                                  "learningObjective": "Implementar verificação de permutação válida dos vértices.",
                                  "commonMistakes": [
                                    "Usar lista em vez de conjunto, levando a O(n^2)",
                                    "Esquecer de checar se todos vértices de G estão em P"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Adjacências Consecutivas no Caminho",
                                  "subSteps": [
                                    "Para i de 1 a n-1, cheque se existe aresta entre P[i] e P[i+1] usando a matriz/lista de adjacência.",
                                    "Se qualquer par consecutivo não for adjacente, rejeite imediatamente.",
                                    "Registre o índice do primeiro erro para depuração.",
                                    "Otimize consultas de adjacência para tempo constante.",
                                    "Confirme que o loop cobre todos os pares necessários."
                                  ],
                                  "verification": "Aplique em um grafo onde um par não é adjacente; deve rejeitar corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matriz de adjacência exemplo 3x3",
                                    "Ferramenta de visualização de grafos como Graphviz"
                                  ],
                                  "tips": "Implemente uma função isAdjacent(u, v) reutilizável.",
                                  "learningObjective": "Garantir conectividade sequencial em tempo linear.",
                                  "commonMistakes": [
                                    "Índices off-by-one no loop",
                                    "Não tratar grafos não-direcionados corretamente (adj[u][v] == adj[v][u])"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Fechamento do Ciclo",
                                  "subSteps": [
                                    "Cheque se existe aresta entre P[n] e P[1].",
                                    "Integre esta verificação após as anteriores.",
                                    "Se falhar, rejeite explicitamente com mensagem de ciclo não fechado.",
                                    "Teste casos onde só falta o fechamento.",
                                    "Documente esta etapa como essencial para ciclo hamiltoniano."
                                  ],
                                  "verification": "Teste um caminho válido exceto pelo fechamento (ex: [1,2,3] em ciclo 1-2-3-1, mas sem 3-1); rejeitar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmo ambiente de codificação",
                                    "Grafos de teste pré-definidos"
                                  ],
                                  "tips": "Lembre-se: Hamiltoniano requer ciclo fechado, não caminho.",
                                  "learningObjective": "Compreender a propriedade de ciclo no problema Hamiltoniano.",
                                  "commonMistakes": [
                                    "Esquecer esta verificação, confundindo com caminho hamiltoniano"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Analisar o Verificador Completo",
                                  "subSteps": [
                                    "Combine todas as verificações em uma função única que retorna true/false.",
                                    "Adicione análise de complexidade: O(n) tempo.",
                                    "Teste com exemplos positivos e negativos.",
                                    "Escreva pseudocódigo claro ou implemente em código.",
                                    "Documente pré e pós-condições."
                                  ],
                                  "verification": "Execute em 5 casos: 2 aceitos, 3 rejeitados; todos corretos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Suite de testes unitários",
                                    "IDE com debugger"
                                  ],
                                  "tips": "Estruture como if-else encadeados para rejeição precoce.",
                                  "learningObjective": "Construir um verificador polinomial completo para NP.",
                                  "commonMistakes": [
                                    "Complexidade superlinear por estruturas ineficientes",
                                    "Falta de testes edge-case como n=1 ou grafo vazio"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo C3 (ciclo de 3 vértices): adjacências 1-2, 2-3, 3-1. Caminho P=[1,2,3]. Verificações: len(P)=3=n, únicos, adj(1-2), adj(2-3), adj(3-1) → Aceita. P=[1,2,1]: duplicata → Rejeita. P=[1,2]: incompleto → Rejeita.",
                              "finalVerifications": [
                                "Verificador aceita todos os ciclos hamiltonianos válidos.",
                                "Rejeita caminhos com vértices duplicados.",
                                "Rejeita caminhos que não cobrem todos os vértices.",
                                "Rejeita caminhos sem adjacências consecutivas.",
                                "Rejeita caminhos sem fechamento de ciclo.",
                                "Executa em tempo O(n).",
                                "Funciona para grafos pequenos (n<=100) sem erros."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: todas verificações implementadas.",
                                "Eficiência: tempo polinomial O(n).",
                                "Clareza: código/pseudocódigo legível com comentários.",
                                "Testes abrangentes: casos positivos e negativos.",
                                "Tratamento de edge cases: n=1, grafo desconectado.",
                                "Documentação de complexidade e propriedades NP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Combinatória.",
                                "Lógica: Predicados e Verificação Formal.",
                                "Programação: Algoritmos e Estruturas de Dados (conjuntos, matrizes).",
                                "Filosofia da Computação: Classes de Complexidade NP.",
                                "Engenharia: Verificação em Otimização."
                              ],
                              "realWorldApplication": "Em roteirização de veículos (TSP), verificadores polinomiais validam soluções aproximadas para rotas eficientes em logística, garantindo cobertura de todos os pontos sem revisitas desnecessárias."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.3.3",
                        "name": "Definição de NP via Verificadores",
                        "description": "Uma linguagem L está na classe NP se existe um verificador polinomial V tal que x ∈ L iff existe certificado c com V(x,c) aceitando, e para x ∉ L nenhum c funciona.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.3.1",
                            "name": "Enunciar o teorema de caracterização de NP",
                            "description": "Estabelecer que NP = {L | existe verificador polinomial V e polinômio p s.t. x ∈ L ⇔ ∃c, |c|≤p(|x|), V(x,c) aceita}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição de NP via Máquinas de Turing Não-Determinísticas",
                                  "subSteps": [
                                    "Lembre-se que uma linguagem L está em NP se existe uma NTM M que decide L em tempo polinomial.",
                                    "Entenda que a NTM pode ter múltiplos caminhos de computação, aceitando se pelo menos um aceita.",
                                    "Identifique exemplos clássicos como SAT e Caminho Hamiltoniano em NP.",
                                    "Anote a formalização: L ∈ NP iff ∃ NTM M, polinômio p, ∀x ∈ L, M aceita x em ≤p(|x|) passos em algum caminho; ∀x ∉ L, todos caminhos rejeitam.",
                                    "Compare com P, onde todas as NTMs podem ser convertidas em DTMs."
                                  ],
                                  "verification": "Escreva a definição de NP via NTM e liste 2 exemplos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre classes de complexidade",
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (cap. 7)"
                                  ],
                                  "tips": "Use diagramas de NTM para visualizar ramificações não-determinísticas.",
                                  "learningObjective": "Compreender a perspectiva não-determinística de NP como base para a caracterização via verificadores.",
                                  "commonMistakes": [
                                    "Confundir aceitação com rejeição em todos os caminhos.",
                                    "Esquecer que o tempo é polinomial apenas nos caminhos aceitantes para x ∈ L."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Verificador Polinomial",
                                  "subSteps": [
                                    "Defina um verificador V como uma TM determinística que, dado (x,c), aceita ou rejeita em tempo polinomial em |x|.",
                                    "Explique o certificado c: uma 'prova' curta (|c| ≤ p(|x|)) que convence V de que x ∈ L.",
                                    "Discuta propriedades: V é determinístico e rápido; c existe apenas para x ∈ L.",
                                    "Formalize: V é um verificador polinomial para L se ∃ polinômio p tal que x ∈ L ⇔ ∃c (|c|≤p(|x|)) V(x,c) aceita.",
                                    "Diferencie de decisor: verificador não decide sozinho, precisa de c."
                                  ],
                                  "verification": "Defina verificador em suas palavras e dê um exemplo simples como paridade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo para TM verificadora",
                                    "Exemplos de problemas NP-completos"
                                  ],
                                  "tips": "Pense em V como um 'juiz' que checa uma solução proposta.",
                                  "learningObjective": "Dominar a noção de verificador e certificado como ponte para a definição alternativa de NP.",
                                  "commonMistakes": [
                                    "Confundir verificador (determinístico) com NTM.",
                                    "Ignorar o bound polinomial em |c|."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Enunciar Formalmente o Teorema de Caracterização de NP",
                                  "subSteps": [
                                    "Escreva o teorema: NP = {L | ∃ verificador polinomial V para L e polinômio p s.t. x ∈ L ⇔ ∃c, |c|≤p(|x|), V(x,c) aceita}.",
                                    "Quebre os símbolos: ∀x, a seta ⇔ captura ambas as direções.",
                                    "Memorize a estrutura exata: conjunto de linguagens com verificadores polinomiais.",
                                    "Pratique recitando em voz alta 3 vezes, variando exemplos.",
                                    "Anote variações equivalentes, como 'NP é o conjunto de linguagens com certificados polinomiais verificáveis'."
                                  ],
                                  "verification": "Escreva o teorema do zero, sem consultar notas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para escrita manual",
                                    "Flashcards com símbolos lógicos"
                                  ],
                                  "tips": "Use mnemônicos: 'NP = Linguagens com Verificador Polinomial e Certificado Polinomial'.",
                                  "learningObjective": "Enunciar precisamente o teorema com todos os componentes formais.",
                                  "commonMistakes": [
                                    "Omitir o quantificador ∃c ou o bound |c|≤p(|x|).",
                                    "Escrever 'decide' em vez de 'aceita'."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender a Prova da Equivalência (Intuição das Duas Direções)",
                                  "subSteps": [
                                    "Direção NP ⊆ Verificadores: Simule caminhos aceitantes da NTM como certificados c para V.",
                                    "Direção Verificadores ⊆ NP: Construa NTM que adivinha c e roda V(x,c).",
                                    "Verifique tempos: Ambos polinomiais pois |c| polinomial e V polinomial.",
                                    "Discuta por que isso mostra NP = co-NP? Não, só caracteriza NP.",
                                    "Resolva exercício: Mostre que SAT tem verificador polinomial."
                                  ],
                                  "verification": "Esboce as duas direções da prova em bullet points.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Prova esboçada do teorema de Sipser",
                                    "Exercícios de complexidade"
                                  ],
                                  "tips": "Desenhe setas: NTM → V e V → NTM para visualizar reduções.",
                                  "learningObjective": "Compreender por que a definição via verificadores é equivalente à via NTM.",
                                  "commonMistakes": [
                                    "Confundir as direções da inclusão.",
                                    "Esquecer que V é determinístico na construção."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o problema SAT (fórmula booleana φ em 3-CNF): x = φ, c = atribuição de variáveis (tamanho O(n)), V(φ, c) verifica em tempo polinomial se φ[c] é verdadeira, aceitando iff satisfazível.",
                              "finalVerifications": [
                                "Enuncie o teorema sem erros de símbolos ou quantificadores.",
                                "Explique o papel do certificado c em um exemplo como Hamiltoniano.",
                                "Distinga verificador de decisor.",
                                "Identifique se uma linguagem dada (ex: PARITY) está em NP via verificador.",
                                "Esboce uma direção da prova.",
                                "Liste 3 linguagens em NP com seus verificadores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática (símbolos corretos: ⇔, ∃c, |c|≤p(|x|), V(x,c) aceita).",
                                "Compreensão conceitual (explicar verificador vs NTM).",
                                "Capacidade de aplicar a exemplos reais (SAT, TSP).",
                                "Correção na intuição da prova de equivalência.",
                                "Clareza na recitação oral ou escrita.",
                                "Identificação de erros comuns em definições alternativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Lógica de Primeira Ordem (quantificadores ∃∀).",
                                "Filosofia: Questões de Provabilidade e Decidibilidade (Gödel, Turing).",
                                "Engenharia de Software: Verificação de Testes Unitários e Certificados de Correção.",
                                "Inteligência Artificial: Heurísticas para Problemas NP-Difíceis."
                              ],
                              "realWorldApplication": "Essa caracterização é crucial para otimizar algoritmos em IA e otimização (ex: solvers SAT em planejamento de rotas ou design de circuitos), permitindo heurísticas eficientes para problemas intratáveis assumindo P ≠ NP."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.3.2",
                            "name": "Provar equivalência com máquinas não-determinísticas",
                            "description": "Esboçar a prova de que toda linguagem aceita por MNT em tempo polinomial tem verificador, e vice-versa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de MNT e Verificadores Polinomiais",
                                  "subSteps": [
                                    "Defina formalmente uma Máquina de Turing Não-Determinística (MNT) e seu tempo de execução polinomial.",
                                    "Explique o conceito de linguagem aceita por MNT em tempo polinomial (NP via MNT).",
                                    "Defina um verificador polinomial V(x, w) onde |w| ≤ poly(|x|) e tempo polinomial.",
                                    "Descreva a linguagem L_V = {x | ∃w : V(x,w) aceita}.",
                                    "Compare as duas definições destacando similaridades e diferenças."
                                  ],
                                  "verification": "Escreva as definições formais em notação matemática e identifique pelo menos 3 similaridades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (Sipser ou similar)",
                                    "Folha de papel ou editor de texto para anotações",
                                    "Acesso a definições online de NP"
                                  ],
                                  "tips": "Use notação padrão como δ̂ para a transição estendida da MNT.",
                                  "learningObjective": "Dominar as definições precisas para evitar confusões na prova.",
                                  "commonMistakes": "Confundir tempo de aceitação com tempo de rejeição na MNT; ignorar o comprimento polinomial do certificado w."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar que Toda Linguagem Aceita por MNT em Tempo Polinomial Tem um Verificador Polinomial",
                                  "subSteps": [
                                    "Dada MNT M aceitando L em tempo p(n), descreva o verificador V(x, w) onde w é o caminho de aceitação não-determinístico.",
                                    "Codifique o caminho de aceitação como uma sequência de escolhas de transição (w com |w| = O(p(n))).",
                                    "Implemente V para simular deterministicamente o caminho especificado por w na MNT.",
                                    "Verifique que V roda em tempo polinomial (simulação determinística de p(n) passos).",
                                    "Mostre que x ∈ L iff ∃w tal que V(x,w) aceita."
                                  ],
                                  "verification": "Esboce o algoritmo de V e prove que tempo(V) ≤ q(|x|) para algum polinômio q.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel para diagramas de simulação",
                                    "Exemplos de MNT simples como aceitador de SAT"
                                  ],
                                  "tips": "Pense no w como uma 'fita de adivinhação' que guia a simulação determinística.",
                                  "learningObjective": "Construir o mapeamento explícito de caminhos não-determinísticos para certificados.",
                                  "commonMistakes": "Esquecer de limitar |w| ao polinômio; não provar que a simulação é determinística e polinomial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar o Inverso: Toda Linguagem com Verificador Polinomial é Aceita por MNT em Tempo Polinomial",
                                  "subSteps": [
                                    "Dado verificador V para L em tempo p(n), construa MNT M que adivinha w de tamanho ≤ p(|x|).",
                                    "Na MNT M, use não-determinismo para gerar w bit a bit.",
                                    "Simule V(x, w) deterministicamente após adivinhar w completo.",
                                    "Aceite se V aceita; rejeite se V rejeita ou |w| > p(|x|).",
                                    "Prove que M aceita x iff x ∈ L, com tempo de todas as ramificações ≤ O(p(|x|))."
                                  ],
                                  "verification": "Descreva formalmente a transição não-determinística de M e calcule o tempo máximo de branch.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Diagrama de fita para MNT",
                                    "Pseudocódigo para simulação"
                                  ],
                                  "tips": "A MNT 'adivinha' w em paralelo, mas cada branch é curta.",
                                  "learningObjective": "Entender como não-determinismo simula busca por certificado.",
                                  "commonMistakes": "Permitir branches infinitas; confundir tempo da MNT com tempo do V."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a Equivalência e Verificar a Prova Completa",
                                  "subSteps": [
                                    "Combine as duas direções para afirmar L ∈ NP via MNT iff L ∈ NP via verificador.",
                                    "Discuta implicações para a classe NP.",
                                    "Identifique suposições (ex: tempo polinomial uniforme).",
                                    "Teste a prova com um exemplo como o problema SAT.",
                                    "Resuma os pontos chave em um esboço unificado."
                                  ],
                                  "verification": "Escreva a prova bidirecional completa em 1-2 páginas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de SAT reduzido a 3-SAT",
                                    "Resumo da prova"
                                  ],
                                  "tips": "Use setas bidirecionais no diagrama para visualizar equivalência.",
                                  "learningObjective": "Sintetizar a prova e aplicá-la a casos conhecidos.",
                                  "commonMistakes": "Ignorar a direção inversa; não uniformizar os polinômios."
                                }
                              ],
                              "practicalExample": "Para o problema SAT (3-SAT é NP-completo): Dada fórmula φ, MNT adivinha atribuição de variáveis e verifica satisfação em tempo linear. Verificador recebe atribuição como w e checa cláusulas em tempo polinomial.",
                              "finalVerifications": [
                                "Pode esboçar corretamente o verificador V a partir de MNT M.",
                                "Constrói MNT M a partir de V sem exceder tempo polinomial.",
                                "Identifica certificados w de tamanho polinomial.",
                                "Prova bidirecional cobre aceitação e rejeição.",
                                "Aplica a equivalência a um problema NP como Hamiltoniano.",
                                "Explica por que isso define NP independentemente."
                              ],
                              "assessmentCriteria": [
                                "Precisão das definições formais (sem erros notacionais).",
                                "Corretude da simulação determinística no verificador.",
                                "Controle de tempo polinomial em ambas direções.",
                                "Completude da prova bidirecional com iff.",
                                "Clareza no uso de não-determinismo vs. busca por w.",
                                "Uso de exemplos para ilustrar conceitos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Indução para provas de tempo.",
                                "Lógica: Equivalências em lógica proposicional semelhantes a SAT.",
                                "Filosofia: Discussão sobre 'adivinhação' não-determinística vs. prova.",
                                "Engenharia de Software: Verificação de programas como certificados."
                              ],
                              "realWorldApplication": "Essa equivalência é fundamental para entender P vs NP, otimização em IA (busca heurística simulando não-determinismo), criptografia (problemas NP para segurança), e compiladores (análise de programas em tempo polinomial via verificadores)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.3.3",
                            "name": "Comparar definições de NP",
                            "description": "Discutir vantagens da definição via verificadores sobre a via não-determinismo para intuição e redução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição de NP via Máquinas de Turing Não-Determinísticas",
                                  "subSteps": [
                                    "Recordar que uma Máquina de Turing Não-Determinística (MTND) aceita uma entrada x se existe pelo menos um caminho de computação que leva ao estado de aceitação em tempo polinomial.",
                                    "Definir formalmente NP como a classe de linguagens L decididas por uma MTND em tempo polinomial.",
                                    "Exemplificar com um problema simples, como o problema de partição, mostrando o 'branching' não-determinístico como uma adivinhação paralela."
                                  ],
                                  "verification": "Escrever a definição formal em notação matemática e resolver um exemplo pequeno manualmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Notas de aula sobre classes de complexidade"
                                  ],
                                  "tips": "Visualize o não-determinismo como um 'demônio' que sempre escolhe o caminho certo, sem custo extra no modelo teórico.",
                                  "learningObjective": "Compreender a definição clássica de NP baseada em não-determinismo e sua interpretação intuitiva.",
                                  "commonMistakes": "Confundir tempo de aceitação não-determinístico com determinístico ou ignorar a existência de caminhos de rejeição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Definição de NP via Verificadores Polinomiais",
                                  "subSteps": [
                                    "Definir um verificador polinomial V para uma linguagem L: para x em L, existe certificado w de tamanho polinomial tal que V(x,w) aceita em tempo polinomial; para x não em L, nenhum w faz aceitar.",
                                    "Estabelecer que NP é o conjunto de linguagens com verificadores determinísticos polinomiais.",
                                    "Ilustrar com 3-SAT: w é uma atribuição de variáveis, V verifica se satisfaz a fórmula em tempo linear."
                                  ],
                                  "verification": "Construir um verificador simples para um problema NP-completo conhecido e testá-lo com entradas de exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pseudocódigo ou Python para simular verificador",
                                    "Exemplos de problemas NP como SAT ou Clique"
                                  ],
                                  "tips": "Pense no verificador como um 'juiz' imparcial que checa provas rapidamente, sem precisar inventar a solução.",
                                  "learningObjective": "Dominar a definição alternativa de NP via certificados e verificação determinística.",
                                  "commonMistakes": "Esquecer que o verificador é determinístico ou que o certificado deve ser de tamanho polinomial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Intuição entre as Duas Definições",
                                  "subSteps": [
                                    "Analisar a intuição da MTND: captura 'adivinhação' de soluções, mas difícil de visualizar computacionalmente devido aos branches exponenciais.",
                                    "Destacar vantagens da verificadores: modela 'provar correção de solução' de forma realista, alinhada com processos humanos de verificação.",
                                    "Discutir exemplos onde a intuição de verificadores facilita compreensão, como em otimização combinatória."
                                  ],
                                  "verification": "Escrever um parágrafo comparando as intuições e discutir com um colega ou gravar explicação oral.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Quadro branco ou ferramenta de mindmap (ex: Draw.io)",
                                    "Vídeos curtos sobre NP (ex: canal de teoria da computação)"
                                  ],
                                  "tips": "Use analogias cotidianas: MTND é como tentar todas as chaves; verificador é checar se a chave certa abre a porta.",
                                  "learningObjective": "Identificar e articular por que a definição via verificadores é mais intuitiva para problemas reais.",
                                  "commonMistakes": "Superestimar a intuição da MTND ou ignorar limitações práticas de simulação não-determinística."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens para Reduções e Provas",
                                  "subSteps": [
                                    "Explicar como reduções polinomiais Karp preservam estrutura de verificadores: se A reduz para B, verificador de B compõe com o redutor para A.",
                                    "Comparar com MTND: composições são mais complexas devido à necessidade de simular não-determinismo.",
                                    "Discutir impacto em provas de NP-completude: verificadores facilitam reduções diretas e certificados compostos."
                                  ],
                                  "verification": "Aplicar uma redução simples (ex: 3-SAT para Clique) nas duas definições e notar diferenças na prova.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigos ou capítulos sobre NP-completude",
                                    "Ferramentas de prova como LaTeX para formalizar"
                                  ],
                                  "tips": "Foque em 'composição de verificadores' como blocos de Lego para construir provas de completude.",
                                  "learningObjective": "Compreender vantagens da definição via verificadores em contextos de reduções polinomiais.",
                                  "commonMistakes": "Confundir reduções Cook-Turing (MTND) com Karp (verificadores) ou ignorar determinismo na composição."
                                }
                              ],
                              "practicalExample": "Para o problema Hamiltoniano (caminho hamiltoniano em grafo): Na MTND, adivinha ordem de vértices e verifica adjacências; no verificador, recebe ordem como w e checa em O(n^2) se é caminho válido e visita todos. A verificação é intuitiva como 'checar bilhete de loteria', facilitando reduções de outros problemas.",
                              "finalVerifications": [
                                "Explicar formalmente ambas as definições de NP sem erros.",
                                "Identificar pelo menos duas vantagens intuitivas dos verificadores.",
                                "Demonstrar uma redução usando verificadores com sucesso.",
                                "Discutir limitações da MTND em provas de NP-completude.",
                                "Resolver um exemplo prático comparando as abordagens."
                              ],
                              "assessmentCriteria": [
                                "Precisão e formalidade nas definições (30%).",
                                "Profundidade na análise de intuição (25%).",
                                "Clareza e correção na discussão de reduções (25%).",
                                "Uso de exemplos relevantes e verificáveis (10%).",
                                "Estrutura lógica e fluidez na comparação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e provas por contradição em complexidade.",
                                "Lógica: Verificação como inferência dedutiva em teoremas.",
                                "Filosofia da Ciência: Intuição formal vs. modelos abstratos em computação.",
                                "Algoritmos e IA: Design de heurísticas baseadas em verificadores para otimização NP-difícil."
                              ],
                              "realWorldApplication": "Na cibersegurança, a definição via verificadores facilita análise de protocolos criptográficos NP-difíceis (ex: fatoração), permitindo reduções para provar dureza e desenvolver esquemas de prova de conhecimento zero, onde 'certificados' são verificados sem revelar segredos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.4",
                    "name": "Propriedades Básicas da Classe NP",
                    "description": "Propriedades como P ⊆ NP, fechamento sob reduções polinomiais e exemplos clássicos como SAT.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.4.1",
                        "name": "Inclusão P ⊆ NP",
                        "description": "Compreender a relação hierárquica entre as classes de complexidade P e NP, demonstrando que todo problema solucionável em tempo polinomial por uma máquina determinística também é solucionável em tempo polinomial por uma máquina não-determinística.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.1.1",
                            "name": "Definir formalmente as classes P e NP",
                            "description": "Definir a classe P como o conjunto de linguagens decidíveis por uma máquina de Turing determinística em tempo polinomial e a classe NP como o conjunto de linguagens decidíveis por uma máquina de Turing não-determinística em tempo polinomial, incluindo exemplos como ordenação para P.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Máquinas de Turing",
                                  "subSteps": [
                                    "Relembre a definição formal de uma Máquina de Turing (MT) determinística: conjunto de estados Q, alfabeto de fita Γ, função de transição δ, estado inicial q0, estados finais F.",
                                    "Entenda MT não-determinística: δ pode mapear para múltiplas transições ou ε-transições.",
                                    "Defina 'tempo de execução' como o número máximo de passos até halting ou loop.",
                                    "Discuta tempo polinomial: função f(n) = O(n^k) para k constante.",
                                    "Compare MT determinística vs. não-determinística em termos de poder computacional."
                                  ],
                                  "verification": "Escreva definições curtas de MT-D e MT-N e dê um exemplo de tempo polinomial para entrada de tamanho n.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre Automata",
                                    "Sipser 'Introduction to the Theory of Computation' Capítulo 7",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use diagramas para visualizar transições; foque em como o não-determinismo permite 'ramificações'.",
                                  "learningObjective": "Compreender as bases formais necessárias para definir classes de complexidade temporal.",
                                  "commonMistakes": [
                                    "Confundir MT com autômatos finitos",
                                    "Ignorar que tempo é medido em passos, não em fita usada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente a Classe P",
                                  "subSteps": [
                                    "Defina P = { L | existe MT-D M tal que para toda x ∈ L, M aceita x em tempo ≤ p(|x|) para polinômio p }.",
                                    "Especifique que M é determinística e halting em tempo polinomial para entradas em L e rejeita corretamente.",
                                    "Escreva notação formal: L ∈ P iff ∃ MT-D M, ∃ c > 0, ∀ x ∈ L, M(x) aceita em ≤ |x|^c passos.",
                                    "Verifique que P é fechada sob união, interseção e complemento.",
                                    "Prove que linguagens regulares e context-free livre estão em P."
                                  ],
                                  "verification": "Formalize a definição de P em suas próprias palavras e prove que a linguagem de strings pares está em P.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de exercícios de complexidade",
                                    "Software como JFLAP para simular MT",
                                    "Referência: Arora & Barak 'Computational Complexity'"
                                  ],
                                  "tips": "Lembre-se: P foca em 'decidível eficientemente' por algoritmo determinístico rápido.",
                                  "learningObjective": "Dominar a definição precisa da classe P usando MT-D em tempo polinomial.",
                                  "commonMistakes": [
                                    "Esquecer que rejeição também deve ser em tempo polinomial",
                                    "Confundir P com NP desde o início"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente a Classe NP",
                                  "subSteps": [
                                    "Defina NP = { L | existe MT-N M tal que para x ∈ L, existe caminho de aceitação em ≤ p(|x|) passos }.",
                                    "Introduza o conceito de 'certificado' ou 'testemunha': para x ∈ L, existe y de tamanho polinomial tal que verificador determinístico aceita (x,y) em tempo polinomial.",
                                    "Escreva: L ∈ NP iff ∃ verificador V (MT-D), ∃ polinômio p, ∀ x: x ∈ L ⇔ ∃ y, |y|≤p(|x|), V(x,y) aceita em p(|x|) tempo.",
                                    "Compare com P: todo L em P está em NP (use y=ε).",
                                    "Discuta 'adivinhação' em MT-N como busca em árvore de ramificação."
                                  ],
                                  "verification": "Escreva a definição de NP via MT-N e via verificador, e dê um exemplo como SAT.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de problemas NP como 3-SAT",
                                    "Pseudocódigo para verificadores",
                                    "Livro de teoria da computação"
                                  ],
                                  "tips": "Pense em NP como 'fácil de verificar, possivelmente difícil de resolver'.",
                                  "learningObjective": "Entender a definição de NP tanto via MT-N quanto via reduzida verificável.",
                                  "commonMistakes": [
                                    "Achar que NP significa 'não polinomial'",
                                    "Confundir aceitação com decisão para todas as entradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplos e Inclusão P ⊆ NP",
                                  "subSteps": [
                                    "Exemplo para P: Ordenação – algoritmo como Merge Sort em O(n log n), simule com MT-D.",
                                    "Exemplo para NP: Clique – dado grafo G e k, existe subclique de tamanho k? Verificador checa adjacências.",
                                    "Prove P ⊆ NP: Para L em P, construa MT-N que simula MT-D (sem ramificação extra).",
                                    "Discuta que P =? NP é aberto, mas evidências sugerem P ≠ NP.",
                                    "Liste problemas conhecidos: PRIMES em P (AKS), TSP em NP."
                                  ],
                                  "verification": "Forneça exemplo concreto em P, prove inclusão e liste 2 problemas NP-completos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas de grafos para Clique",
                                    "Tabela de problemas P vs NP",
                                    "Artigos sobre AKS primality"
                                  ],
                                  "tips": "Use exemplos familiares para fixar: ordenação é trivial em P.",
                                  "learningObjective": "Aplicar definições com exemplos e entender a relação hierárquica P ⊆ NP.",
                                  "commonMistakes": [
                                    "Exemplos errados como Halting Problem em NP",
                                    "Ignorar que verificador é determinístico"
                                  ]
                                }
                              ],
                              "practicalExample": "Para mostrar ordenação em P: Construa MT-D que simula Bubble Sort em O(n^2) passos. Para entrada <3,1,2>, a MT itera bolhas, comparando e trocando adjacentes até ordenado, halting em tempo polinomial.",
                              "finalVerifications": [
                                "Defina P e NP corretamente em notação formal.",
                                "Prove P ⊆ NP com argumento válido.",
                                "Dê exemplo de problema em P e explique por quê.",
                                "Dê exemplo de problema em NP mas presumivelmente não em P.",
                                "Explique diferença entre MT-D e MT-N em tempo polinomial.",
                                "Liste propriedades de P e NP (fechamentos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal de P e NP (exata vs. vaga).",
                                "Correção na prova de inclusão P ⊆ NP.",
                                "Qualidade e relevância dos exemplos fornecidos.",
                                "Compreensão conceitual de verificadores vs. resolvedores.",
                                "Identificação de erros comuns evitados.",
                                "Clareza na distinção entre tempo polinomial e outras classes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e funções assintóticas O(n^k).",
                                "Lógica: Verificadores como provas em lógica proposicional.",
                                "Filosofia: Questões de decidibilidade e limites da computação.",
                                "Algoritmos: Análise de complexidade em programação prática."
                              ],
                              "realWorldApplication": "Essas definições são cruciais para otimização em logística (problemas NP como TSP), criptografia (fatores primos em P via AKS) e IA (busca em espaços de estados), guiando onde algoritmos eficientes existem ou requerem aproximações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.1.2",
                            "name": "Explicar intuitivamente P ⊆ NP",
                            "description": "Explicar conceitualmente por que uma máquina determinística pode ser simulada por uma máquina não-determinística sem aumentar a complexidade temporal além do polinomial, destacando a não-deterministicidade como uma generalização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Básicas de P e NP",
                                  "subSteps": [
                                    "Defina P como a classe de problemas decidíveis por uma máquina de Turing determinística em tempo polinomial.",
                                    "Defina NP como a classe de problemas decidíveis por uma máquina de Turing não-determinística em tempo polinomial.",
                                    "Explique que P ⊆ NP significa que todo problema em P também está em NP.",
                                    "Discuta por que isso é trivial em uma direção, mas requer prova na outra.",
                                    "Identifique exemplos simples: ordenação está em P, logo em NP."
                                  ],
                                  "verification": "Escreva definições precisas de P e NP e liste 2 problemas em P.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de teoria da computação",
                                    "Diagrama de classes de complexidade"
                                  ],
                                  "tips": "Use analogias cotidianas: P é 'fazer uma coisa de cada vez', NP é 'tentar múltiplas opções magicamente'.",
                                  "learningObjective": "Compreender as definições formais e a relação intuitiva entre P e NP.",
                                  "commonMistakes": [
                                    "Confundir P com problemas fáceis de resolver vs verificar.",
                                    "Achar que NP é só 'difícil' sem base formal."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Máquinas Determinísticas vs Não-Determinísticas",
                                  "subSteps": [
                                    "Descreva uma MT determinística (MTD): segue única transição por estado e entrada.",
                                    "Descreva uma MT não-determinística (MTN): pode ramificar em múltiplas transições simultaneamente.",
                                    "Explique que MTN 'adivinha' o caminho certo para aceitação.",
                                    "Note que para aceitação, MTN aceita se existe pelo menos um caminho aceitador.",
                                    "Compare poder computacional: MTN é mais poderosa em termos de tempo."
                                  ],
                                  "verification": "Desenhe diagramas de uma MTD e MTN simples resolvendo o mesmo problema.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Simulador de MT online (ex: JFLAP)"
                                  ],
                                  "tips": "Pense na MTN como um 'super-herói' que explora todos os caminhos ao mesmo tempo.",
                                  "learningObjective": "Diferenciar o comportamento de MTD e MTN e sua relação com tempo polinomial.",
                                  "commonMistakes": [
                                    "Achar que MTN é sempre mais rápida; ela só parece assim por não-determinismo."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Simulação de MTD por MTN",
                                  "subSteps": [
                                    "Construa uma MTN simuladora que gera todos os possíveis caminhos da MTD.",
                                    "Use não-determinismo para 'adivinhar' a sequência de configurações da MTD.",
                                    "Verifique passo a passo se a configuração simulada segue as regras da MTD.",
                                    "Aceite se encontrar um caminho que corresponda à execução completa da MTD e aceite.",
                                    "Mostre que essa simulação roda em tempo polinomial se a MTD o faz."
                                  ],
                                  "verification": "Esboce o algoritmo de simulação e trace um exemplo com 3 passos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo de simulação",
                                    "Exemplo de MTD para PAR ou ordenação"
                                  ],
                                  "tips": "A MTN não precisa simular todos os caminhos; basta um que funcione, mas na verdade simula via adivinhação.",
                                  "learningObjective": "Dominar a construção formal da simulação que prova P ⊆ NP.",
                                  "commonMistakes": [
                                    "Esquecer que a simulação é exponencial em determinístico, mas polinomial em não-determinístico."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Complexidade e Intuição Final",
                                  "subSteps": [
                                    "Calcule o tempo: para MTD de tempo p(n), simulação gera p(n) configurações, cada verificada em O(p(n)).",
                                    "Mostre que total é O(p(n)^2) ou polinomial.",
                                    "Intua: não-determinismo generaliza determinismo; simular é só 'adivinhar' o caminho único correto.",
                                    "Discuta por que NP não é estritamente maior (aberto).",
                                    "Reflita: P = NP? Mas P ⊆ NP é fato."
                                  ],
                                  "verification": "Prove informalmente que tempo da simulação é polinomial para p(n) = n^k.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fórmulas de complexidade",
                                    "Gráfico de crescimento polinomial"
                                  ],
                                  "tips": "Lembre: o 'poder extra' da MTN não é usado na simulação de MTD, pois há só um caminho.",
                                  "learningObjective": "Internalizar a intuição de que determinismo é caso especial de não-determinismo.",
                                  "commonMistakes": [
                                    "Confundir simulação determinística (exponencial) com não-determinística (polinomial)."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma MTD que verifica se um grafo tem caminho de comprimento <= k (em P). Construa MTN que adivinha a sequência de k arestas e verifica se forma caminho válido, aceitando em tempo O(k^2) polinomial.",
                              "finalVerifications": [
                                "Explicar verbalmente por que uma MTD de tempo n^2 pode ser simulada por MTN em tempo O(n^3).",
                                "Identificar que a simulação usa não-determinismo para pular busca exaustiva.",
                                "Diferenciar aceitação de MTN (existe caminho) vs MTD (único caminho).",
                                "Listar 3 problemas em P e afirmar corretamente que estão em NP.",
                                "Desenhar diagrama de simulação para MTD simples.",
                                "Explicar intuição: 'MTN pode fingir ser determinística adivinhando o único caminho certo'."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de simulação MTD por MTN.",
                                "Correta análise de complexidade temporal (polinomial).",
                                "Uso correto de intuição não-determinística como generalização.",
                                "Capacidade de traçar exemplo prático sem erros.",
                                "Clareza na distinção entre poder de MTD e MTN.",
                                "Identificação de erros comuns na prova."
                              ],
                              "crossCurricularConnections": [
                                "Filosofia: Debate sobre determinismo vs livre-arbítrio (não-determinismo como escolha múltipla).",
                                "Física Quântica: Paralelismo quântico similar a não-determinismo em computação.",
                                "Matemática: Teoria de conjuntos e inclusões (P como subconjunto de NP).",
                                "Lógica: Provas não-construtivas vs construtivas."
                              ],
                              "realWorldApplication": "Em verificadores de software e otimização, entender P ⊆ NP permite usar solvers NP para problemas P conhecidos (ex: SAT solvers para fórmulas em P), otimizando design de algoritmos e análise de complexidade em IA e criptografia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.1.3",
                            "name": "Provar formalmente P ⊆ NP",
                            "description": "Construir uma prova formal mostrando que para qualquer linguagem L ∈ P, existe uma máquina de Turing não-determinística que decide L em tempo polinomial, via simulação direta da máquina determinística.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Formais de P e NP",
                                  "subSteps": [
                                    "Defina formalmente a classe P como DTIME(poly(n)) para máquinas de Turing determinísticas.",
                                    "Defina NP como NTIME(poly(n)) para máquinas de Turing não-determinísticas.",
                                    "Esclareça a diferença entre tempo determinístico e não-determinístico.",
                                    "Escreva as definições usando notação padrão: L ∈ P iff ∃ TM M, ∀ w ∈ L, M aceita w em O(n^k) passos.",
                                    "Liste exemplos canônicos de linguagens em P (e.g., {a^n b^n})."
                                  ],
                                  "verification": "Verifique se as definições estão escritas corretamente e distinguem DTIME de NTIME.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre Teoria da Computação",
                                    "Livro 'Sipser - Introduction to the Theory of Computation'",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use quantificadores ∀ e ∃ com precisão para evitar confusões nas definições.",
                                  "learningObjective": "Dominar as definições exatas de P e NP para fundamentar a prova.",
                                  "commonMistakes": [
                                    "Confundir P com problemas solucionáveis em tempo linear",
                                    "Ignorar o aspecto polinomial no tempo de execução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formalizar a Hipótese: Assumir L ∈ P",
                                  "subSteps": [
                                    "Escolha uma linguagem arbitrária L ∈ P.",
                                    "Descreva uma TM determinística M que decide L em tempo polinomial: ∀ w, |w|=n, M(w) em O(n^k) passos.",
                                    "Especifique a configuração inicial de M: fita com w, cabeça no início, estado q0.",
                                    "Defina as transições de M como δ: Q × Γ → Q × Γ × {L,R}.",
                                    "Estabeleça que M é total e para em tempo polinomial."
                                  ],
                                  "verification": "Confirme que M é descrita como decididora polinomial de L.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagrama de TM genérica",
                                    "Exemplos de TMs para linguagens em P"
                                  ],
                                  "tips": "Mantenha M genérica; não especifique uma L particular ainda.",
                                  "learningObjective": "Estabelecer a premissa da prova corretamente.",
                                  "commonMistakes": [
                                    "Assumir M não-determinística prematuramente",
                                    "Esquecer que M deve decidir, não só reconhecer"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a NTM N que Simula M",
                                  "subSteps": [
                                    "Defina N com os mesmos estados, alfabeto e transições de M.",
                                    "Configure N para ser não-determinística, mas use apenas um caminho: sem branches reais.",
                                    "Descreva a simulação passo a passo: N copia entrada, simula transições de M deterministicamente.",
                                    "Especifique que em cada passo, N move cabeça e atualiza estado exatamente como M.",
                                    "Garanta que N pare quando M para: aceita se M aceita, rejeita se rejeita."
                                  ],
                                  "verification": "Simule manualmente N em uma entrada pequena para matching com M.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel para desenhar fitas de TM",
                                    "Simulador de TM online (opcional)"
                                  ],
                                  "tips": "Enfatize que N é 'não-determinística preguiçosa': só um caminho viável.",
                                  "learningObjective": "Construir explicitamente a simuladora NTM.",
                                  "commonMistakes": [
                                    "Introduzir não-determinismo desnecessário na simulação",
                                    "Esquecer de copiar a fita corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Complexidade de Tempo de N",
                                  "subSteps": [
                                    "Prove que cada passo de N simula um passo de M em tempo constante.",
                                    "Mostre que N roda no máximo O(n^k) passos, pois simula fielmente M.",
                                    "Argumente que overhead da não-determinidade é zero (um único caminho).",
                                    "Conclua que N decide L em tempo polinomial.",
                                    "Verifique que N aceita exatamente as mesmas entradas que M."
                                  ],
                                  "verification": "Calcule bound superior de tempo para uma entrada de tamanho n.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas sobre análise assintótica",
                                    "Exemplos de simulações TM"
                                  ],
                                  "tips": "Use indução no número de passos para rigor.",
                                  "learningObjective": "Demonstrar preservação da complexidade polinomial.",
                                  "commonMistakes": [
                                    "Confundir tempo de branches inexistentes",
                                    "Ignorar custo de cópia de fita (que é polinomial)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir a Prova e Verificar Propriedades",
                                  "subSteps": [
                                    "Afirme: Para toda L ∈ P, construímos NTM N em NTIME(poly(n)), logo L ∈ NP.",
                                    "Generalize: Como L arbitrária, P ⊆ NP.",
                                    "Verifique corretude: N decide L corretamente.",
                                    "Discuta unicidade da prova (simulação direta é padrão).",
                                    "Escreva a prova formal completa em notação matemática."
                                  ],
                                  "verification": "Leia a prova inteira para gaps lógicos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Template de prova formal"
                                  ],
                                  "tips": "Use teorema/lemma/proof estrutura.",
                                  "learningObjective": "Finalizar e polir a prova formal.",
                                  "commonMistakes": [
                                    "Pular generalização para todas L ∈ P",
                                    "Confundir ⊆ com ="
                                  ]
                                }
                              ],
                              "practicalExample": "Considere L = { w ∈ {0,1}^* | número de 1's em w é par }, decidida por TM M que conta 1's em O(n) tempo. Construa N simulando M: N lê w, conta paridade deterministicamente, aceita se par. Tempo de N: O(n), provando L ∈ NP via simulação.",
                              "finalVerifications": [
                                "Definições de P e NP estão precisas e distinguem DTIME/NTIME.",
                                "TM M é corretamente assumida como polinomial decididora.",
                                "NTM N simula M sem overhead não-polinomial.",
                                "Prova mostra L ∈ NP para L arbitrária em P.",
                                "Conclusão formal: P ⊆ NP.",
                                "Nenhuma suposição extra sobre não-determinismo."
                              ],
                              "assessmentCriteria": [
                                "Precisão formal nas definições e construções de TM.",
                                "Correta análise de tempo polinomial na simulação.",
                                "Generalização lógica para todas linguagens em P.",
                                "Ausência de erros em transições ou simulação.",
                                "Clareza e rigor matemático na redação da prova.",
                                "Verificação de corretude (aceitação/rejeição preservada)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Quantificadores Lógicos.",
                                "Algoritmos: Análise Assintótica de Complexidade.",
                                "Lógica Matemática: Provas por Construção e Indução.",
                                "Filosofia da Computação: Limites da Computação Eficiente."
                              ],
                              "realWorldApplication": "Essa prova estabelece que todo problema com algoritmo eficiente determinístico (P) tem uma versão não-determinística eficiente (NP), fundamental para otimização em IA, criptografia e entender o milênio P=?NP, impactando design de algoritmos práticos em software e hardware."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.4.2",
                        "name": "Fechamento sob Reduções Polinomiais",
                        "description": "Demonstrar que a classe NP é fechada sob reduções polinomiais many-one, ou seja, se A ≤_p B e B ∈ NP, então A ∈ NP, o que é fundamental para a teoria de NP-completude.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.2.1",
                            "name": "Definir redução polinomial many-one",
                            "description": "Definir formalmente uma redução polinomial many-one (≤_p) entre linguagens A e B como uma função computável em tempo polinomial f: Σ* → Σ* tal que x ∈ A se e só se f(x) ∈ B.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de linguagens e problemas decidíveis",
                                  "subSteps": [
                                    "Relembrar que uma linguagem A é um subconjunto de Σ* para algum alfabeto Σ.",
                                    "Entender que problemas decidíveis são linguagens aceitas por máquinas de Turing decisoras.",
                                    "Diferenciar linguagens recursivas de parcialmente recursivas.",
                                    "Exemplificar com Σ* como o conjunto de todas as strings possíveis.",
                                    "Discutir o papel de Σ* no domínio de entrada e saída de funções."
                                  ],
                                  "verification": "Escrever Σ* e dar 3 exemplos de linguagens A ⊆ Σ*.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Visualize Σ* como todas as possíveis entradas para um computador.",
                                  "learningObjective": "Compreender o universo de entrada/saída em computação formal.",
                                  "commonMistakes": [
                                    "Confundir Σ* com alfabeto finito Σ.",
                                    "Ignorar que linguagens são infinitas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender reduções many-one em geral",
                                  "subSteps": [
                                    "Definir redução many-one: função f: Σ* → Σ* tal que x ∈ A iff f(x) ∈ B.",
                                    "Explicar que 'many-one' significa que múltiplas entradas mapam para uma única saída.",
                                    "Discutir que f deve ser computável (total e decidível).",
                                    "Diferenciar de reduções Turing (que usam oráculos).",
                                    "Verificar simetria: se A ≤_m B e B decidível, então A decidível."
                                  ],
                                  "verification": "Escrever a definição de ≤_m e provar que preserva decidibilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas sobre reduções",
                                    "Exemplos de livros como Arora-Barak"
                                  ],
                                  "tips": "Pense em f como um 'tradutor' que preserva membership.",
                                  "learningObjective": "Dominar a noção de many-one sem restrições de tempo.",
                                  "commonMistakes": [
                                    "Omitir a bicondicional iff.",
                                    "Confundir computável com polinomial."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a restrição polinomial no tempo de computação",
                                  "subSteps": [
                                    "Definir tempo polinomial: |f(x)| ≤ p(|x|) para polinômio p, e computada em O(p(|x|)).",
                                    "Explicar por que polinomial: captura eficiência 'razoável'.",
                                    "Discutir classes P e NP em relação a reduções.",
                                    "Exemplificar função identidade como polinomial trivial.",
                                    "Verificar que comprimento de saída é polinomial no comprimento de entrada."
                                  ],
                                  "verification": "Classificar 3 funções como polinomiais ou não (ex: f(x)=x^2, exponencial).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora para polinômios",
                                    "Pseudocódigo de TM polinomial"
                                  ],
                                  "tips": "Lembre: polinomial em |x|, não no valor numérico de x.",
                                  "learningObjective": "Entender o que torna uma redução 'eficiente'.",
                                  "commonMistakes": [
                                    "Confundir tempo polinomial com espaço.",
                                    "Ignorar crescimento do tamanho de f(x)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a definição completa de redução polinomial many-one ≤_p",
                                  "subSteps": [
                                    "Combinar: f: Σ* → Σ* computável em tempo polinomial, x ∈ A iff f(x) ∈ B.",
                                    "Escrever notação formal: A ≤_p B.",
                                    "Provar fechamento: se A ≤_p B e B ∈ P, então A ∈ P.",
                                    "Discutir simetria para NP: fechamento sob ≤_p.",
                                    "Aplicar em contexto de NP-completude."
                                  ],
                                  "verification": "Escrever a definição exata e provar um lema simples de fechamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha para provas formais",
                                    "Referência: Definição 7.5 de Sipser"
                                  ],
                                  "tips": "Use LaTeX mental: A \\leq_p B iff \\exists f polinomial com x \\in A \\iff f(x) \\in B.",
                                  "learningObjective": "Capacitar-se a enunciar e usar a definição formal.",
                                  "commonMistakes": [
                                    "Esquecer 'computável em tempo polinomial'.",
                                    "Usar = em vez de iff."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e praticar a definição com exemplos",
                                  "subSteps": [
                                    "Analisar exemplo: A = { <M,w> | M aceita w }, B = EMPTY reduzido via padding.",
                                    "Construir redução trivial: A ≤_p A via f(x)=x.",
                                    "Identificar erros em definições incompletas.",
                                    "Discutir por que ≤_p é transitiva.",
                                    "Relacionar com Cook-Levin: SAT como completo."
                                  ],
                                  "verification": "Definir ≤_p para um par de linguagens simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos impressos de reduções NP"
                                  ],
                                  "tips": "Sempre cheque tamanho: |f(x)| deve ser poly(|x|).",
                                  "learningObjective": "Aplicar a definição em contextos reais de NP.",
                                  "commonMistakes": [
                                    "Exemplos não-polinomiais.",
                                    "Omitir verificação de iff."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere A = VERTEX-COVER e B = INDEPENDENT-SET. Uma redução ≤_p mapeia grafo G e k para G' e (n-k), onde n é número de vértices, preservando se G tem cover de tamanho k iff G' tem independent set de tamanho n-k. f é polinomial (O(n+m)).",
                              "finalVerifications": [
                                "Escrever a definição formal completa sem erros.",
                                "Identificar os 3 componentes essenciais: f, tempo polinomial, iff.",
                                "Provar corretamente que ≤_p preserva P.",
                                "Classificar uma função dada como ≤_p ou não.",
                                "Explicar verbalmente o propósito em NP-completude.",
                                "Construir redução trivial para si mesmo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal (≤_p, Σ*, iff).",
                                "Correta inclusão de tempo polinomial e computabilidade.",
                                "Compreensão da bicondicional e suas implicações.",
                                "Capacidade de provar propriedades básicas (fechamento).",
                                "Uso correto em exemplos simples.",
                                "Identificação de erros comuns em definições."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria das funções e relações bicondicionais.",
                                "Lógica: Proposições equivalentes e tabelas de verdade para iff.",
                                "Programação: Implementar funções polinomiais em Python para reduções.",
                                "Filosofia da Computação: Limites da eficiência algorítmica.",
                                "Algoritmos: Análise de complexidade temporal O(n^k)."
                              ],
                              "realWorldApplication": "Essencial para provar NP-completude de problemas reais como SAT (otimização em IA), TSP (rotas logísticas), e knapsack (otimização de recursos), permitindo classificar problemas intratáveis e guiar heurísticas em software industrial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.2.2",
                            "name": "Provar fechamento de NP sob ≤_p",
                            "description": "Provar que se B ∈ NP e A ≤_p B, então A ∈ NP, construindo uma máquina não-determinística para A que usa a redução f e a máquina para B em tempo polinomial combinado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de NP e redução polinomial ≤_p",
                                  "subSteps": [
                                    "Defina formalmente uma linguagem L ∈ NP: existe uma máquina de Turing não-determinística M_L tal que para todo x ∈ L, existe pelo menos um caminho de aceitação em tempo polinomial p(|x|), e para x ∉ L, todos os caminhos rejeitam em tempo ≤ p(|x|).",
                                    "Defina redução polinomial A ≤_p B: existe uma função f: Σ* → Σ* computável por uma TM determinística em tempo polinomial q(|x|), total, tal que x ∈ A se e somente se f(x) ∈ B.",
                                    "Explique o papel da NTM M_B para B ∈ NP, incluindo o não-determinismo na adivinhação de certificados.",
                                    "Anote que |f(x)| ≤ q(|x|), preservando o tamanho polinomial.",
                                    "Diferencie redução many-one de outras reduções."
                                  ],
                                  "verification": "Escreva as definições formais em um papel e verifique com uma referência padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 7)",
                                    "Notas de aula sobre classes de complexidade",
                                    "Folha para anotações formais"
                                  ],
                                  "tips": "Use notação exata como NTM, TM determinística e polinômios para evitar ambiguidades.",
                                  "learningObjective": "Compreender precisamente os conceitos fundamentais para a construção da prova.",
                                  "commonMistakes": [
                                    "Confundir NP com P, ignorando o não-determinismo.",
                                    "Esquecer que f deve ser total e computável em tempo determinístico polinomial.",
                                    "Omitir o 'se e somente se' na definição da redução."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a máquina não-determinística M_A para A",
                                  "subSteps": [
                                    "Em M_A, sobre input x: execute deterministicamente a TM da redução para computar f(x).",
                                    "Após obter f(x), use não-determinismo para adivinhar um certificado y com |y| ≤ r(|f(x)|), onde r é polinomial.",
                                    "Simule M_B sobre a entrada (f(x), y) e verifique se aceita.",
                                    "Se a simulação aceita, M_A aceita; caso contrário, rejeita nessa branch.",
                                    "Garanta que M_A pare em todas as branches."
                                  ],
                                  "verification": "Desenhe um fluxograma ou pseudocódigo da execução de M_A.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel milimetrado para diagramas de NTM",
                                    "Pseudocódigo de NTMs de exemplos anteriores",
                                    "Referência sobre simulação de Turing machines"
                                  ],
                                  "tips": "Visualize M_A como sequência: fase determinística (f(x)) + adivinhação + verificação.",
                                  "learningObjective": "Desenvolver a NTM M_A reutilizando M_B via redução.",
                                  "commonMistakes": [
                                    "Iniciar adivinhação antes de computar f(x).",
                                    "Adivinhar certificado para x em vez de f(x).",
                                    "Não especificar simulação de M_B com par (f(x), y)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que M_A opera em tempo polinomial",
                                  "subSteps": [
                                    "Tempo para f(x): ≤ p(|x|), e |f(x)| ≤ p(|x|).",
                                    "Tempo para adivinhar y: ≤ q(p(|x|)), polinomial.",
                                    "Tempo para simular M_B(f(x), y): ≤ r(|f(x)| + |y|) ≤ r(poly(|x|)), polinomial.",
                                    "Tempo total por branch: soma de polinômios, ainda polinomial s(|x|).",
                                    "Como número de branches é exponencial mas cada uma poly, a definição de NP é satisfeita."
                                  ],
                                  "verification": "Escreva a fórmula T(|x|) ≤ s(|x|)^k para algum polinômio s e k.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de composição de funções polinomiais",
                                    "Calculadora simbólica para O-notation",
                                    "Exemplos de provas de tempo em Sipser"
                                  ],
                                  "tips": "Lembre que poly(n) + poly(n) + poly(poly(n)) = poly(n).",
                                  "learningObjective": "Demonstrar que a composição preserva tempo polinomial.",
                                  "commonMistakes": [
                                    "Ignorar crescimento de |f(x)| na simulação.",
                                    "Confundir tempo por branch com tempo de todas as branches.",
                                    "Usar tempo exponencial para adivinhação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar corretude e concluir que A ∈ NP",
                                  "subSteps": [
                                    "Caso x ∈ A: f(x) ∈ B, existe y tal que M_B aceita (f(x), y), logo existe branch aceitante em M_A.",
                                    "Caso x ∉ A: f(x) ∉ B, para todo y, M_B rejeita (f(x), y), todas branches de M_A rejeitam.",
                                    "Confirme que M_A é NTM com tempo polinomial em todos os caminhos.",
                                    "Conclua: pela definição de NP, A ∈ NP.",
                                    "Discuta implicações para reduções encadeadas."
                                  ],
                                  "verification": "Redija a prova de corretude em formato formal (⇒ e ⇐).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Template de prova de corretude para teoremas de complexidade",
                                    "Exemplos de provas similares de livros-texto"
                                  ],
                                  "tips": "Estruture como 'Se x ∈ A então ... aceita' e 'Se x ∉ A então ... rejeita'.",
                                  "learningObjective": "Finalizar a prova completa de fechamento.",
                                  "commonMistakes": [
                                    "Reverter a direção da iff na redução.",
                                    "Esquecer o caso x ∉ A (todas branches rejeitam).",
                                    "Omitir paradas em branches rejeitantes."
                                  ]
                                }
                              ],
                              "practicalExample": "Sabemos que 3-SAT ∈ NP (com NTM que adivinha atribuição e verifica). Para mostrar CIRCUIT-SAT ∈ NP, construímos redução f: circuito → fórmula 3CNF equivalente (em tempo poly). Então M para CIRCUIT-SAT: computa f(circuito), adivinha atribuição para f, verifica com M_3-SAT. Isso prova CIRCUIT-SAT ∈ NP pelo fechamento.",
                              "finalVerifications": [
                                "Enuncie corretamente o teorema de fechamento de NP sob ≤_p.",
                                "Descreva com precisão a estrutura de M_A, incluindo fases.",
                                "Forneça análise detalhada do tempo polinomial com polinômios explícitos.",
                                "Prove corretude bidirecional (x ∈ A iff aceitação possível).",
                                "Explique por que a construção generaliza para qualquer B ∈ NP.",
                                "Identifique um exemplo concreto de aplicação."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições iniciais (20%)",
                                "Construção correta e detalhada de M_A (25%)",
                                "Análise rigorosa de tempo polinomial (20%)",
                                "Prova completa de corretude (20%)",
                                "Clareza, formalidade e ausência de erros (10%)",
                                "Conexão com exemplos práticos (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Composição de funções polinomiais e teoria dos conjuntos.",
                                "Lógica: Verificadores não-determinísticos e provas por casos.",
                                "Algoritmos: Simulação de máquinas de Turing e reduções computacionais.",
                                "Filosofia da Computação: Fundamentos de limites da decidibilidade."
                              ],
                              "realWorldApplication": "Essa prova permite provar que problemas reais como otimização de circuitos, escalonamento de tarefas e quebra de códigos em criptografia estão em NP via reduções de problemas conhecidos, guiando o desenvolvimento de heurísticas, algoritmos de aproximação e análise de viabilidade em IA e sistemas distribuídos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.2.3",
                            "name": "Aplicar o fechamento em exemplos simples",
                            "description": "Aplicar o teorema de fechamento para mostrar que problemas reduzidos a um problema em NP também pertencem a NP, usando um exemplo como redução de um grafo para outro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Teorema de Fechamento sob Reduções Polinomiais",
                                  "subSteps": [
                                    "Leia a definição formal do teorema: Se A ≤_p B e B ∈ NP, então A ∈ NP.",
                                    "Identifique os componentes chave: redução polinomial (≤_p), verificador polinomial e máquina não-determinística.",
                                    "Estude exemplos prévios de reduções para fixar o conceito.",
                                    "Anote as condições necessárias para uma redução ser válida (computável em tempo polinomial).",
                                    "Discuta com um colega ou anote dúvidas sobre o porquê da preservação da classe NP."
                                  ],
                                  "verification": "Escreva uma paraphrase do teorema em suas próprias palavras e liste 3 condições para ≤_p.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre NP",
                                    "Livro de Teoria da Computação (ex: Sipser)",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use diagramas para visualizar A → B via redutor f.",
                                  "learningObjective": "Compreender formalmente o teorema de fechamento e suas implicações.",
                                  "commonMistakes": "Confundir fechamento com composição de reduções ou ignorar o tempo polinomial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Entender um Exemplo de Problemas em Grafos",
                                  "subSteps": [
                                    "Escolha os problemas: Clique(G, k) e Conjunto Independente(Ĝ, n-k), onde Ĝ é o grafo complemento de G.",
                                    "Defina formalmente Clique: Existe subgrafo completo com k vértices?",
                                    "Defina Conjunto Independente: Existe conjunto de vértices sem arestas entre si?",
                                    "Construa um grafo exemplo pequeno (ex: G com 4 vértices) e seu complemento.",
                                    "Verifique manualmente se Clique(G,k) é verdadeiro iff Independente(Ĝ, n-k) é verdadeiro."
                                  ],
                                  "verification": "Desenhe G e Ĝ, marque um clique em G e o conjunto independente correspondente em Ĝ.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de grafos (ex: Graphviz ou papel]",
                                    "Exemplos de grafos impressos"
                                  ],
                                  "tips": "Lembre-se: complemento inverte arestas, transformando cliques em independentes.",
                                  "learningObjective": "Dominar a relação entre Clique e Conjunto Independente via complemento.",
                                  "commonMistakes": "Erros no cálculo de n-k ou confusão entre grafo original e complemento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Redução Polinomial Explícita",
                                  "subSteps": [
                                    "Defina o redutor f: f(G,k) = (Ĝ, n-k), onde Ĝ tem arestas onde G não tem.",
                                    "Implemente pseudocódigo para construir Ĝ em tempo O(n²).",
                                    "Prove correção: Se Clique(G,k) sim, então Independente(Ĝ, n-k) sim (e vice-versa).",
                                    "Analise complexidade: Construção de Ĝ é O(|V|² + |E|), polinomial.",
                                    "Teste com o grafo exemplo: Execute f e verifique tamanhos e propriedades."
                                  ],
                                  "verification": "Escreva pseudocódigo de f e prove |f(x)| ≤ poly(|x|) com seu exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Calculadora para análise de tempo"
                                  ],
                                  "tips": "Use adjacência matriz para Ĝ: inverte a matriz de G.",
                                  "learningObjective": "Construir e validar uma redução polinomial passo a passo.",
                                  "commonMistakes": "Não provar ambas as direções (sim→sim e não→não) ou superestimar complexidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Teorema e Concluir a Pertinência a NP",
                                  "subSteps": [
                                    "Assuma que Conjunto Independente ∈ NP (com verificador polinomial conhecido).",
                                    "Aplique o teorema: Como Clique ≤_p Independente e Independente ∈ NP, então Clique ∈ NP.",
                                    "Generalize para outros problemas reduzidos a NP.",
                                    "Discuta limitações: Isso não prova P=NP, só fechamento.",
                                    "Resuma em uma prova curta: premissas → conclusão."
                                  ],
                                  "verification": "Escreva uma prova formal de 5-10 linhas mostrando Clique ∈ NP.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Modelo de prova em branco",
                                    "Referência ao teorema"
                                  ],
                                  "tips": "Estruture prova como: 1. Redução existe. 2. Polinomial. 3. Teorema aplica.",
                                  "learningObjective": "Aplicar o fechamento para concluir pertinência a NP em exemplos.",
                                  "commonMistakes": "Pular prova de correção da redução ou confundir com completude NP."
                                }
                              ],
                              "practicalExample": "Considere o problema Clique(G=(V,E),k): Dado grafo G com n=|V| vértices, existe clique de tamanho k? Reduza para Conjunto Independente via f(G,k)=(Ĝ, n-k), onde Ĝ é complemento (aresta em Ĝ iff não em G). Exemplo: G com vértices {1,2,3,4}, arestas {1-2,2-3,3-1} (triângulo clique k=3). Ĝ tem arestas faltantes em G, n-k=1, e {4} é independente tamanho 1. Se Clique sim, Independente sim. Tempo: O(n²). Logo, Clique ∈ NP se Independente ∈ NP.",
                              "finalVerifications": [
                                "Construir corretamente o grafo complemento para um G dado.",
                                "Provar bidirecionalmente a equivalência decisória da instância.",
                                "Analisar e afirmar complexidade polinomial da redução.",
                                "Aplicar teorema verbalmente: 'Como ≤_p e alvo NP, origem NP'.",
                                "Identificar Clique como NP-completo conhecido via essa redução.",
                                "Generalizar para outro par de problemas similares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e construção da redução (correção bidirecional).",
                                "Análise correta de complexidade temporal (polinomial comprovada).",
                                "Clareza na aplicação do teorema de fechamento.",
                                "Uso de exemplo concreto com verificação manual.",
                                "Profundidade da prova escrita (lógica impecável).",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Complements.",
                                "Lógica: Equivalências e Provas Formais.",
                                "Algoritmos: Análise de Complexidade Polinomial.",
                                "Filosofia da Computação: Limites da Computabilidade."
                              ],
                              "realWorldApplication": "Em otimização combinatória, como design de redes (ex: alocação de canais sem interferência via grafos de conflito), reduções polinomiais permitem usar solvers NP para aproximar problemas reais, como roteamento em telecomunicações ou escalonamento de tarefas em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.4.3",
                        "name": "Exemplos Clássicos como SAT",
                        "description": "Analisar o problema de Satisfatibilidade Booleana (SAT) como exemplo paradigmático de linguagem na classe NP, focando em sua verificação polinomial.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.4.3.1",
                            "name": "Definir o problema SAT",
                            "description": "Definir formalmente SAT como o conjunto de fórmulas em forma normal conjuntiva (CNF) que são satisfatíveis, incluindo a representação de variáveis, cláusulas e atribuições booleanas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Lógica Proposicional",
                                  "subSteps": [
                                    "Identifique variáveis booleanas (ex: p, q) e seus valores (verdadeiro/falso).",
                                    "Entenda conectivos lógicos: AND (∧), OR (∨), NOT (¬).",
                                    "Construa tabelas-verdade simples para fórmulas com 2 variáveis.",
                                    "Diferencie fórmulas literais (variável ou sua negação) de cláusulas.",
                                    "Pratique convertendo expressões simples para disjunções de literais."
                                  ],
                                  "verification": "Crie uma tabela-verdade correta para (p ∧ q) ∨ ¬r e explique cada linha.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou software como Truth Table Generator online"
                                  ],
                                  "tips": "Comece com fórmulas pequenas para evitar confusão; memorize os 16 operadores booleanos básicos.",
                                  "learningObjective": "Dominar os blocos de construção da lógica booleana para CNF.",
                                  "commonMistakes": [
                                    "Confundir OR com AND em cláusulas",
                                    "Esquecer que NOT inverte o valor da variável"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Forma Normal Conjuntiva (CNF)",
                                  "subSteps": [
                                    "Defina CNF como conjunção (AND) de cláusulas, onde cada cláusula é disjunção (OR) de literais.",
                                    "Converta uma fórmula simples como (p → q) para CNF usando equivalências lógicas.",
                                    "Identifique exemplos de CNF válida e inválida.",
                                    "Conte o número de variáveis e cláusulas em uma fórmula dada.",
                                    "Escreva uma fórmula CNF com 3 variáveis e 2 cláusulas."
                                  ],
                                  "verification": "Converta ¬(p ∧ q) ∨ r para CNF e justifique cada transformação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de equivalências lógicas",
                                    "Editor de texto para fórmulas"
                                  ],
                                  "tips": "Use a lei de distributividade para expandir; verifique se não há conectivos aninhados além de OR/AND.",
                                  "learningObjective": "Representar qualquer fórmula booleana em CNF padronizada.",
                                  "commonMistakes": [
                                    "Deixar cláusulas vazias",
                                    "Não distribuir corretamente AND sobre OR"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Conceito de Satisfatibilidade",
                                  "subSteps": [
                                    "Defina uma atribuição booleana como mapeamento de variáveis para {0,1} (falso/verdadeiro).",
                                    "Avalie se uma atribuição satisfaz uma cláusula (pelo menos um literal verdadeiro).",
                                    "Verifique se uma fórmula CNF é satisfeita (todas cláusulas verdadeiras).",
                                    "Teste insatisfatibilidade com exemplo: cláusula vazia ou contradição.",
                                    "Gere atribuições exaustivas para 2 variáveis e avalie uma fórmula."
                                  ],
                                  "verification": "Para φ = (p ∨ ¬q) ∧ (¬p ∨ q), encontre uma atribuição satisfatória e prove.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de atribuições 2^n",
                                    "Python simples para avaliação booleana opcional"
                                  ],
                                  "tips": "Liste todas 2^n atribuições sistematicamente; foque em cláusulas unitárias primeiro.",
                                  "learningObjective": "Avaliar se uma CNF é satisfatível via atribuições.",
                                  "commonMistakes": [
                                    "Avaliar cláusula como falsa se todos literais falsos",
                                    "Ignorar negações em literais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar o Problema SAT",
                                  "subSteps": [
                                    "Defina SAT = {φ ∈ CNF | ∃ atribuição que satisfaz φ}.",
                                    "Especifique entrada: codificação de φ como string ou lista de cláusulas.",
                                    "Discuta decisão: SAT? (sim/não), não encontrar atribuição.",
                                    "Compare com TAUT (todas atribuições satisfazem) e UNSAT.",
                                    "Escreva a definição formal completa de SAT como linguagem."
                                  ],
                                  "verification": "Escreva a definição exata de SAT e classifique φ = (p) ∧ (¬p) como UNSAT.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referência: Livro 'Sipser Introduction to Theory of Computation'",
                                    "Notas de aula sobre NP"
                                  ],
                                  "tips": "Lembre que SAT é problema de decisão; entrada é sempre CNF válida.",
                                  "learningObjective": "Articular SAT como problema clássico NP-completo.",
                                  "commonMistakes": [
                                    "Confundir SAT com encontrar atribuição (otimização)",
                                    "Definir sem especificar CNF"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere φ = (x1 ∨ ¬x2) ∧ (¬x1 ∨ x2) ∧ (x1 ∨ x2). Atribuição x1=1, x2=1 satisfaz: primeira cláusula (1∨¬1)=1, segunda (¬1∨1)=1, terceira (1∨1)=1. Teste x1=0, x2=0 falha na terceira.",
                              "finalVerifications": [
                                "Explique CNF em suas palavras com exemplo.",
                                "Defina satisfatibilidade e dê contraexemplo UNSAT.",
                                "Escreva definição formal de SAT.",
                                "Classifique uma fórmula dada como SAT/UNSAT.",
                                "Discuta por que SAT é NP-completo basicamente.",
                                "Converta fórmula não-CNF para CNF corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de CNF e literais (30%)",
                                "Correta compreensão de atribuições e avaliação (25%)",
                                "Definição formal completa de SAT (20%)",
                                "Exemplos práticos sem erros (15%)",
                                "Uso correto de notação lógica (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (reduções para 3-SAT)",
                                "Inteligência Artificial: SAT Solvers em planejamento",
                                "Filosofia: Lógica proposicional e raciocínio deductivo",
                                "Engenharia de Software: Verificação formal de programas"
                              ],
                              "realWorldApplication": "SAT é base para solvers como MiniSat usados em verificação de hardware (circuitos lógicos), agendamento de tarefas, configuração de software e testes de teoremas automáticos em indústrias como semicondutores e aviação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.3.2",
                            "name": "Mostrar que SAT ∈ NP",
                            "description": "Construir uma máquina de Turing não-determinística que decide SAT em tempo polinomial, adivinhando uma atribuição e verificando todas as cláusulas em tempo linear no tamanho da fórmula.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de SAT e classe NP",
                                  "subSteps": [
                                    "Defina o problema SAT: dada uma fórmula booleana em Forma Normal Conjuntiva (CNF), determinar se existe uma atribuição de variáveis que a torna verdadeira.",
                                    "Explique os componentes de uma fórmula CNF: cláusulas (disjunções de literais) unidas por conjunções.",
                                    "Recapitule a classe NP: conjunto de linguagens decididas por uma Máquina de Turing Não-Determinística (NTM) em tempo polinomial.",
                                    "Descreva o funcionamento básico de uma NTM: pode 'adivinhar' branches não-determinísticos em tempo polinomial.",
                                    "Identifique o certificado de SAT: uma atribuição de verdade que satisfaz a fórmula."
                                  ],
                                  "verification": "O aluno explica corretamente as definições e diferencia SAT de problemas em P.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações",
                                    "Referência: Livro de Teoria da Computação (Sipser ou similar)"
                                  ],
                                  "tips": "Use diagramas para visualizar cláusulas CNF e branches não-determinísticos.",
                                  "learningObjective": "Compreender os conceitos fundamentais de SAT e NP para contextualizar a prova.",
                                  "commonMistakes": [
                                    "Confundir SAT com tautologia",
                                    "Ignorar que NP requer tempo polinomial na NTM"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar a estrutura da NTM para SAT",
                                  "subSteps": [
                                    "Defina o input: codificação da fórmula CNF φ com n variáveis e m cláusulas.",
                                    "Descreva o primeiro passo não-determinístico: a NTM gera uma atribuição aleatória para as n variáveis (cadeia de 0s e 1s de tamanho n).",
                                    "Estruture o fita: input φ, fita auxiliar para atribuição, contador para cláusulas.",
                                    "Implemente o estado inicial: mover cabeça para o início da atribuição gerada.",
                                    "Planeje os estados principais: estado de adivinhação, estado de verificação de cláusulas."
                                  ],
                                  "verification": "O aluno desenha um diagrama de estados da NTM mostrando a adivinhação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (JFLAP ou papel)",
                                    "Exemplo de fórmula CNF pequena"
                                  ],
                                  "tips": "Comece com poucas variáveis para testar intuitivamente.",
                                  "learningObjective": "Construir a parte não-determinística da NTM que gera o certificado.",
                                  "commonMistakes": [
                                    "Gerar atribuição maior que n bits",
                                    "Não copiar corretamente o input para fita auxiliar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a verificação das cláusulas na NTM",
                                  "subSteps": [
                                    "Para cada cláusula: posicione a cabeça na cláusula i, use a atribuição para avaliar cada literal.",
                                    "Avalie um literal: para x_j, cheque se atribuição[j] matches o sinal do literal; para ¬x_j, inverta.",
                                    "Se todos literais falsos na cláusula, rejeite; senão, avance para próxima cláusula.",
                                    "Após todas m cláusulas verificadas como satisfeitas, aceite.",
                                    "Garanta que rejeição ocorra se qualquer cláusula falhar."
                                  ],
                                  "verification": "O aluno simula a verificação em uma fórmula exemplo com atribuição dada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador de NTM (opcional)",
                                    "Fórmulas CNF de teste"
                                  ],
                                  "tips": "Conte o número de movimentos da cabeça: deve ser linear por cláusula.",
                                  "learningObjective": "Desenvolver o algoritmo determinístico de verificação em tempo linear.",
                                  "commonMistakes": [
                                    "Avaliar literais incorretamente (esquecer negação)",
                                    "Não iterar por todas cláusulas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar complexidade temporal e concluir a prova",
                                  "subSteps": [
                                    "Adivinhação: O(n) tempo para gerar atribuição.",
                                    "Verificação: Para cada de m cláusulas, O(tamanho médio da cláusula) = O(|φ| total).",
                                    "Total: tempo polinomial O(|φ|^k) para algum k, pois m e tamanho cláusulas são O(|φ|).",
                                    "Argumente: se existe branch aceitante, NTM aceita; branches rejeitantes ignoradas.",
                                    "Conclua: SAT decidido por NTM em tempo polinomial, logo SAT ∈ NP."
                                  ],
                                  "verification": "O aluno escreve a análise temporal formal e afirma corretamente SAT ∈ NP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha para análise O-notation"
                                  ],
                                  "tips": "Use |φ| para tamanho input; ignore constantes.",
                                  "learningObjective": "Provar rigorosamente a inclusão em NP via análise de tempo.",
                                  "commonMistakes": [
                                    "Confundir tempo não-determinístico com determinístico",
                                    "Subestimar tempo de verificação como exponencial"
                                  ]
                                }
                              ],
                              "practicalExample": "Fórmula φ = (x1 ∨ ¬x2) ∧ (x2 ∨ x3). NTM adivinha '101' (x1=1, x2=0, x3=1): Verifica 1ª cláusula (1∨¬0=1∨1=true), 2ª (0∨1=true). Aceita em O(1) por cláusula.",
                              "finalVerifications": [
                                "Descreve corretamente a NTM com adivinhação e verificação.",
                                "Simula aceitação/rejeição em exemplo dado.",
                                "Analisa tempo como polinomial em |φ|.",
                                "Explica por que branches rejeitantes não afetam decisão.",
                                "Afirma corretamente SAT ∈ NP sem erros lógicos.",
                                "Diferencia NP de P adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da NTM (adivinhação + verificação linear).",
                                "Correção da análise temporal polinomial.",
                                "Clareza no diagrama ou pseudocódigo da máquina.",
                                "Uso correto de notação O() e tamanho input.",
                                "Compreensão conceitual de não-determinismo.",
                                "Ausência de confusões com problemas NP-completos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e avaliação de fórmulas booleanas.",
                                "Inteligência Artificial: SAT solvers em planejamento e otimização.",
                                "Engenharia de Software: Verificação formal de programas.",
                                "Criptografia: Reduções em problemas NP para provas de segurança."
                              ],
                              "realWorldApplication": "Prova fundamental para SAT solvers (ex: MiniSat, Z3) usados em design de circuitos VLSI, agendamento de tarefas, verificação de hardware/software e resolução de restrições em IA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.4.3.3",
                            "name": "Discutir importância de SAT em NP",
                            "description": "Explicar por que SAT é um exemplo clássico que ilustra as propriedades de NP, incluindo sua verificabilidade polinomial e papel como problema NP-completo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição básica do problema SAT",
                                  "subSteps": [
                                    "Leia a definição formal de SAT: dada uma fórmula booleana em forma normal conjuntiva (CNF), determinar se existe uma atribuição de valores verdadeiros/falsos que a satisfaz.",
                                    "Identifique os componentes: cláusulas, literais e variáveis booleanas.",
                                    "Estude um exemplo simples: (x ∨ ¬y) ∧ (¬x ∨ z) ∧ (y ∨ ¬z).",
                                    "Pratique convertendo uma expressão booleana simples para CNF.",
                                    "Anote as diferenças entre SAT e problemas de decisão triviais."
                                  ],
                                  "verification": "Escreva uma definição precisa de SAT e resolva um exemplo pequeno manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Artigo ou vídeo sobre SAT (ex: Wikipedia SAT page)",
                                    "Editor de texto para fórmulas"
                                  ],
                                  "tips": "Comece com fórmulas de 3 variáveis para evitar sobrecarga cognitiva.",
                                  "learningObjective": "Definir SAT e identificar seus elementos fundamentais.",
                                  "commonMistakes": [
                                    "Confundir SAT com tautologia (sempre verdadeira)",
                                    "Ignorar a forma CNF obrigatória"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar a verificabilidade polinomial de SAT",
                                  "subSteps": [
                                    "Revise o conceito de verificador polinomial: dado um certificado (atribuição), verificar em tempo polinomial se satisfaz a fórmula.",
                                    "Descreva o algoritmo de verificação: para cada cláusula, cheque se pelo menos um literal é verdadeiro.",
                                    "Calcule a complexidade: O(n * m) onde n=variáveis, m=cláusulas, polinomial.",
                                    "Compare com busca não-determinística: 'adivinhar' atribuição e verificar.",
                                    "Implemente pseudocódigo para o verificador."
                                  ],
                                  "verification": "Implemente e teste um verificador simples em Python para uma instância SAT.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Python ou similar)",
                                    "Exemplos de fórmulas CNF",
                                    "Documentação de complexidade NP"
                                  ],
                                  "tips": "Use loops simples para iterar cláusulas; foque em eficiência O(n*m).",
                                  "learningObjective": "Demonstrar por que soluções candidatas para SAT podem ser verificadas rapidamente.",
                                  "commonMistakes": [
                                    "Pensar que resolução é polinomial (não é, só verificação)",
                                    "Confundir tempo de verificação com tempo de solução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Discutir o status NP-completo de SAT",
                                  "subSteps": [
                                    "Recapitule Cook-Levin Theorem: SAT é NP-completo, primeiro problema provado assim.",
                                    "Explique redução polinomial: qualquer problema em NP reduz para SAT em tempo polinomial.",
                                    "Estude implicações: se SAT é resolvível em P, então P=NP.",
                                    "Liste aplicações de reduções: 3-SAT, Clique, etc., todos NP-completos via SAT.",
                                    "Debata consequências teóricas de P vs NP usando SAT como pivô."
                                  ],
                                  "verification": "Descreva em 3 frases o teorema de Cook-Levin e uma redução simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro ou notas sobre Teoria da Computação (Sipser ou similar)",
                                    "Vídeos sobre Cook-Levin",
                                    "Papel para diagramas de redução"
                                  ],
                                  "tips": "Visualize reduções com diagramas; memorize que SAT é o 'ur-problema' de NP.",
                                  "learningObjective": "Entender o papel central de SAT na hierarquia de complexidade.",
                                  "commonMistakes": [
                                    "Confundir NP-completo com NP-duro",
                                    "Achar que todos problemas NP são NP-completos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a importância de SAT como exemplo clássico em NP",
                                  "subSteps": [
                                    "Compile razões: ilustra não-determinismo, verificação vs decisão, centralidade em provas de NP-completura.",
                                    "Compare com outros exemplos: por que SAT é mais fundamental que Hamiltoniano Path?",
                                    "Discuta impacto histórico: base para milhares de reduções e algoritmos heurísticos.",
                                    "Crie um resumo: 'SAT exemplifica NP perfeitamente por...'.",
                                    "Prepare argumentos para discussão: prós e contras de usá-lo em aulas."
                                  ],
                                  "verification": "Escreva um parágrafo explicando a importância de SAT para um colega iniciante.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resumo anterior dos steps 1-3",
                                    "Fórum ou parceiro para feedback"
                                  ],
                                  "tips": "Use analogias: SAT como 'detetive' que verifica pistas rapidamente mas demora para encontrar culpado.",
                                  "learningObjective": "Articular coerentemente por que SAT define as propriedades de NP.",
                                  "commonMistakes": [
                                    "Subestimar o teorema de Cook-Levin",
                                    "Ignorar aplicações práticas além da teoria"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a fórmula SAT: (x1 ∨ ¬x2) ∧ (¬x1 ∨ x3) ∧ (x2 ∨ ¬x3). Certificado: x1=verdadeiro, x2=falso, x3=verdadeiro. Verificação: Cláusula1: x1=true → ok; Cláusula2: x3=true → ok; Cláusula3: x2=false (¬x2=true) → ok. Tempo: polinomial. Discuta: isso mostra NP (verificação fácil), e como NP-completo, captura essência de problemas duros.",
                              "finalVerifications": [
                                "Pode definir SAT e fornecer um exemplo CNF satisfatível?",
                                "Explica o verificador polinomial com pseudocódigo?",
                                "Descreve o teorema de Cook-Levin em termos simples?",
                                "Lista 3 implicações de SAT ser NP-completo?",
                                "Compara SAT com outro problema NP para destacar sua importância?",
                                "Articula por que SAT ilustra propriedades de NP melhor que outros?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos de SAT (20%)",
                                "Clareza na explicação de verificabilidade polinomial (25%)",
                                "Compreensão correta de NP-completude e Cook-Levin (25%)",
                                "Profundidade na discussão de importância histórica/teórica (20%)",
                                "Uso de analogias e exemplos práticos para ilustrar conceitos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Lógica Proposicional (Matemática/Filosofia): SAT como satisfatibilidade lógica.",
                                "Otimização e IA (Engenharia): Heurísticas SAT em solvers como MiniSat.",
                                "Economia/Teoria dos Jogos: Problemas de alocação NP-completos reduzidos a SAT.",
                                "Física Computacional: Modelagem de spin glasses via 3-SAT.",
                                "Criptografia: Protocolos baseados em assumições P≠NP."
                              ],
                              "realWorldApplication": "SAT solvers são usados em hardware verification (Intel/AMD), scheduling de voos (airlines), software testing (Microsoft), e AI planning (NASA), provando que mesmo 'impossível' em pior caso, heurísticas práticas resolvem instâncias reais eficientemente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.5",
                    "name": "Relação entre P e NP",
                    "description": "Inclusão P ⊆ NP, hipótese P ≠ NP e implicações para problemas intratáveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.5.1",
                        "name": "Inclusão P ⊆ NP",
                        "description": "Compreensão da relação hierárquica entre as classes de complexidade P e NP, demonstrando que todo problema decidível em tempo polinomial está contido na classe NP.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.1.1",
                            "name": "Definir as classes P e NP",
                            "description": "Explicar formalmente a classe P como o conjunto de problemas de decisão resolvíveis por uma máquina de Turing determinística em tempo polinomial e NP como problemas verificáveis em tempo polinomial por uma máquina não-determinística.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Máquinas de Turing e Problemas de Decisão",
                                  "subSteps": [
                                    "Estude a definição formal de uma Máquina de Turing (TM) determinística, incluindo estados, fita, cabeçote e função de transição.",
                                    "Aprenda sobre problemas de decisão: conjuntos de strings aceitas ou rejeitadas por uma TM.",
                                    "Entenda o conceito de tempo de execução de uma TM: número de passos como função do tamanho da entrada n.",
                                    "Defina tempo polinomial: existe uma constante c tal que tempo ≤ n^c para entradas grandes.",
                                    "Diferencie TM determinística de não-determinística (múltiplas transições possíveis)."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando TM determinística, problemas de decisão e tempo polinomial, com um exemplo simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Capítulo 7 do livro 'Introduction to the Theory of Computation' de Sipser",
                                    "Vídeo 'Turing Machines Explained' no YouTube (Khan Academy)",
                                    "Papel e caneta para diagramas de TM"
                                  ],
                                  "tips": [
                                    "Desenhe diagramas de TM simples para visualizar o funcionamento.",
                                    "Compare TM com computadores reais para fixar conceitos.",
                                    "Pratique com exemplos de linguagens regulares aceitas por TM."
                                  ],
                                  "learningObjective": "Dominar os pré-requisitos teóricos necessários para definir classes de complexidade temporal.",
                                  "commonMistakes": [
                                    "Confundir tempo de execução com espaço.",
                                    "Ignorar que problemas de decisão são para 'sim/não'.",
                                    "Misturar determinismo com não-determinismo prematuramente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente a Classe P",
                                  "subSteps": [
                                    "Lembre que P é a classe de linguagens decidíveis.",
                                    "Defina P = { L | existe TM determinística M que decide L em tempo polinomial }.",
                                    "Formalize: Para todo x em L, M aceita x em ≤ p(|x|) passos; para x não em L, rejeita corretamente.",
                                    "Discuta exemplos: ordenação, busca binária, grafos conectados (BFS em O(n^2)).",
                                    "Prove que P é fechada sob união e interseção (usando simulações de TM)."
                                  ],
                                  "verification": "Escreva a definição formal de P e dê 2 exemplos de problemas em P com justificativa de tempo polinomial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas do Step 1",
                                    "Exercícios de complexidade do livro de Sipser (páginas 70-80)",
                                    "Simulador online de TM (ex: Turing Machine Simulator)"
                                  ],
                                  "tips": [
                                    "Use notação DTIME(f(n)) para generalizar: P = ∪_k DTIME(n^k).",
                                    "Pense em algoritmos eficientes do dia a dia como evidência intuitiva.",
                                    "Evite exemplos não-decidíveis."
                                  ],
                                  "learningObjective": "Capacitar-se a definir e exemplificar a classe P com precisão formal.",
                                  "commonMistakes": [
                                    "Definir P como 'rápido' sem formalismo temporal.",
                                    "Incluir problemas de otimização em vez de decisão.",
                                    "Esquecer que deve decidir corretamente sempre."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente a Classe NP",
                                  "subSteps": [
                                    "Introduza TM não-determinística (NTM): em cada passo, pode ramificar em múltiplos caminhos.",
                                    "Defina NP = { L | existe NTM N que aceita L em tempo polinomial }.",
                                    "Explique verificação: para x em L, existe caminho de aceitação ≤ p(|x|); para x não em L, todos caminhos rejeitam.",
                                    "Relacione com certificados: existe 'prova' y de tamanho polinomial verificável em tempo polinomial por TM determinística.",
                                    "Exemplos: SAT (verificar atribuição), Hamiltoniano (verificar ciclo dado)."
                                  ],
                                  "verification": "Escreva a definição formal de NP usando NTM e reformule com certificados; liste 3 problemas em NP.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Capítulo 8 de Sipser",
                                    "Artigo 'NP-Completeness' de Cook-Levin (resumo)",
                                    "Ferramenta online para SAT solvers"
                                  ],
                                  "tips": [
                                    "Pense em NTM como 'adivinhador' que tenta caminhos paralelos.",
                                    "Sempre reformule NP via verificadores determinísticos para clareza.",
                                    "Use árvores de computação para visualizar ramificações."
                                  ],
                                  "learningObjective": "Compreender e formalizar NP, destacando o papel do não-determinismo e verificação.",
                                  "commonMistakes": [
                                    "Confundir aceitação de NTM com decisão determinística.",
                                    "Achar que NP significa 'não polinomial'.",
                                    "Ignorar o requisito de rejeição em todos os caminhos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer a Inclusão P ⊆ NP e Sintetizar Definições",
                                  "subSteps": [
                                    "Prove P ⊆ NP: dada TM M em P, construa NTM N que simula M (um único caminho).",
                                    "Discuta que toda linguagem em P é verificável (certificado vazio).",
                                    "Compare definições lado a lado em uma tabela.",
                                    "Resolva exercícios: classificar problemas como P ou NP.",
                                    "Reflita sobre o problema aberto P =? NP."
                                  ],
                                  "verification": "Escreva a prova de P ⊆ NP e crie uma tabela comparativa de P vs NP.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Resumos dos steps anteriores",
                                    "Folha de exercícios de complexidade (GeeksforGeeks)",
                                    "Vídeo 'P vs NP' de minutephysics"
                                  ],
                                  "tips": [
                                    "A prova de inclusão é direta: determinismo é caso especial de não-determinismo.",
                                    "Memorize: P fácil de resolver, NP fácil de verificar.",
                                    "Conecte com aplicações práticas para motivação."
                                  ],
                                  "learningObjective": "Integrar definições de P e NP, provando relações fundamentais.",
                                  "commonMistakes": [
                                    "Invertir a inclusão (NP ⊆ P é desconhecido).",
                                    "Esquecer detalhes da simulação na prova.",
                                    "Confundir com NP-completo."
                                  ]
                                }
                              ],
                              "practicalExample": "Problema em P: 'Dado um grafo G e vértices s-t, existe caminho?' Resolvido por BFS em O(V+E) = O(n^2). Problema em NP: 'G tem ciclo Hamiltoniano?' Verifique um ciclo candidato em tempo linear na lista de vértices.",
                              "finalVerifications": [
                                "Definir P usando TM determinística e tempo polinomial corretamente.",
                                "Definir NP usando NTM ou certificados com precisão.",
                                "Explicar a prova de P ⊆ NP sem erros.",
                                "Classificar corretamente 3 problemas como P ou NP.",
                                "Diferenciar resolução de verificação intuitivamente.",
                                "Resumir diferenças em tabela ou parágrafo conciso."
                              ],
                              "assessmentCriteria": [
                                "Precisão e formalidade nas definições (uso de notação exata).",
                                "Correção na prova de inclusão P ⊆ NP.",
                                "Qualidade e relevância dos exemplos fornecidos.",
                                "Clareza na distinção entre determinismo e não-determinismo.",
                                "Compreensão de implicações (ex: por que verificação é chave em NP).",
                                "Ausência de confusões comuns (ex: otimização vs decisão)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Funções Assintóticas (O(n^k)).",
                                "Lógica: Verificação e Certificados como Provas.",
                                "Algoritmos: Análise de Complexidade Temporal.",
                                "Filosofia da Computação: Questões de Decidibilidade e Limites Computacionais."
                              ],
                              "realWorldApplication": "As definições de P e NP são cruciais para algoritmos de otimização em IA (ex: roteirização de veículos em P aproximado), criptografia (fatoração presumida em NP sem P conhecido, base do RSA) e verificação de software (testes automatizados em tempo polinomial)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.5.1.2",
                            "name": "Provar a inclusão P ⊆ NP",
                            "description": "Demonstrar matematicamente que qualquer linguagem em P pode ser reconhecida por uma máquina de Turing não-determinística em tempo polinomial, simulando o comportamento determinístico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer Definições Formais de P e NP",
                                  "subSteps": [
                                    "Defina formalmente uma Máquina de Turing Determinística (DTM) M com tempo de execução polinomial p(n).",
                                    "Defina a classe P como o conjunto de linguagens L reconhecidas por alguma DTM em tempo O(p(n)).",
                                    "Defina uma Máquina de Turing Não-Determinística (NTM) M' com tempo de execução polinomial q(n).",
                                    "Defina a classe NP como o conjunto de linguagens L reconhecidas por alguma NTM em tempo O(q(n)).",
                                    "Observe que as definições usam tempo de aceitação, não de decisão completa."
                                  ],
                                  "verification": "Escreva as definições em um papel e compare com uma referência padrão como o livro de Sipser.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (Capítulo 7)",
                                    "Folha de papel e caneta",
                                    "Notas de aula sobre complexidade"
                                  ],
                                  "tips": "Use notação formal como L(M) = {w | M aceita w em tempo ≤ p(|w|)} para clareza.",
                                  "learningObjective": "Dominar as definições precisas de P e NP para fundamentar a prova.",
                                  "commonMistakes": [
                                    "Confundir tempo polinomial com exponencial",
                                    "Ignorar que P usa DTMs e NP usa NTMs",
                                    "Misturar tempo de aceitação com tempo de halting"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Conceito de Simulação de DTM por NTM",
                                  "subSteps": [
                                    "Explique por que uma NTM pode simular uma DTM: a NTM pode 'escolher' o único caminho determinístico.",
                                    "Descreva uma simulação direta: a NTM segue exatamente as transições da DTM sem ramificações.",
                                    "Discuta que, sem não-determinismo efetivo usado, a simulação é determinística na prática.",
                                    "Estime o overhead: cada passo da DTM corresponde a um passo na NTM.",
                                    "Verifique que a linguagem aceita permanece a mesma: L(M') = L(M)."
                                  ],
                                  "verification": "Desenhe um diagrama de simulação para uma DTM simples e trace a execução na NTM.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Papel quadriculado para diagramas de estados",
                                    "Exemplos de TMs simples (ex: reconhecedor de {a^n b^n})",
                                    "Software de simulação de TM como JFLAP"
                                  ],
                                  "tips": "Pense na NTM como uma DTM disfarçada: ela não precisa de branches para simular determinismo.",
                                  "learningObjective": "Entender intuitivamente por que simular determinismo em não-determinismo preserva a linguagem e o tempo polinomial.",
                                  "commonMistakes": [
                                    "Achar que NTM sempre ramifica",
                                    "Subestimar que simulação direta não aumenta o tempo assintoticamente",
                                    "Confundir simulação com redução de problemas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Formalmente a NTM M' a partir da DTM M",
                                  "subSteps": [
                                    "Defina os estados, alfabeto e transições de M' idênticos aos de M.",
                                    "Especifique que M' em qualquer configuração segue a única transição de M (sem não-determinismo real).",
                                    "Formalize a configuração inicial: mesma fita de entrada para M e M'.",
                                    "Descreva a halting: M' aceita se M aceita, rejeita se M rejeita em tempo polinomial.",
                                    "Prove que M' é uma NTM válida, mesmo que comporte como DTM."
                                  ],
                                  "verification": "Escreva a construção formal em pseudocódigo ou notação matemática e teste com uma TM exemplo.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": [
                                    "Referência formal (Sipser Theorem 7.15)",
                                    "Editor de texto para pseudocódigo",
                                    "Exemplo de DTM para linguagem em P como PALINDROMES"
                                  ],
                                  "tips": "Use a definição: δ'(q, a) = δ(q, a), onde δ é a função de transição única de M.",
                                  "learningObjective": "Construir explicitamente a máquina simuladora para solidificar a prova.",
                                  "commonMistakes": [
                                    "Adicionar não-determinismo desnecessário",
                                    "Alterar o conjunto de estados ou transições",
                                    "Esquecer de lidar com rejeição em tempo polinomial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Tempo de Execução e Concluir a Inclusão P ⊆ NP",
                                  "subSteps": [
                                    "Prove que se M roda em O(p(n)), então M' roda em O(p(n)) ou O(p(n)^c) para constante c.",
                                    "Argumente que o número de passos é idêntico, pois não há branches.",
                                    "Conclua que para qualquer L ∈ P, existe NTM M' com tempo polinomial reconhecendo L.",
                                    "Formalize: P ⊆ NP.",
                                    "Discuta implicações: toda linguagem em P é também em NP."
                                  ],
                                  "verification": "Escreva a prova completa em 1 página e recite para um colega ou grave um vídeo explicando.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Papel para prova escrita",
                                    "Gravação de vídeo ou parceiro de estudo",
                                    "Artigo ou vídeo sobre P vs NP"
                                  ],
                                  "tips": "Overhead de simulação é O(1) por passo; foque em análise assintótica.",
                                  "learningObjective": "Completar a prova rigorosa e entender suas consequências teóricas.",
                                  "commonMistakes": [
                                    "Ignorar constantes no tempo polinomial",
                                    "Confundir ⊆ com = ",
                                    "Esquecer que NP inclui P independentemente de P=NP?"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a DTM M que reconhece a linguagem de palíndromos pares EVEN-PAL = {ww^R | w ∈ {0,1}* } em tempo O(n^2). Construa M' como simulação direta: M' varre a fita comparando símbolos simetricamente, sem branches. M' aceita exatamente os mesmos inputs em tempo O(n^2), provando EVEN-PAL ∈ NP.",
                              "finalVerifications": [
                                "Escrever a prova completa corretamente sem erros formais.",
                                "Explicar oralmente a construção da NTM para um leigo em teoria da computação.",
                                "Aplicar a prova a um exemplo específico em P e verificar aceitação.",
                                "Identificar por que a simulação preserva o tempo polinomial.",
                                "Discutir diferenças sutis entre tempo de DTM e NTM.",
                                "Resolver um exercício similar de conversão DTM para NTM."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das definições de P e NP (20%)",
                                "Correção formal da construção da NTM M' (30%)",
                                "Análise rigorosa do tempo de execução polinomial (25%)",
                                "Clareza na conclusão da inclusão P ⊆ NP (15%)",
                                "Uso correto de notação matemática e exemplos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Provas formais e indução em configurações de TM.",
                                "Algoritmos e Estruturas de Dados: Simulações e análise assintótica O(n^k).",
                                "Filosofia da Computação: Implicações de P vs NP para decidibilidade.",
                                "Matemática Discreta: Autômatos e linguagens formais.",
                                "Inteligência Artificial: Relação com busca não-determinística em problemas NP."
                              ],
                              "realWorldApplication": "Essa prova é crucial na teoria da complexidade computacional, sustentando que problemas eficientemente solucionáveis (P) são 'fáceis' mesmo para modelos não-determinísticos. Ela fundamenta hipóteses como P ≠ NP usadas em criptografia (ex: RSA), otimização de algoritmos e verificação de software, impactando campos como segurança cibernética e IA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.5.1.3",
                            "name": "Exemplificar problemas em P ⊆ NP",
                            "description": "Identificar e exemplificar problemas clássicos como ordenação ou busca binária em P e mostrar sua verificação em NP, como o problema de satisfação booleana SAT em NP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições de classes P e NP",
                                  "subSteps": [
                                    "Defina formalmente a classe P como problemas decidíveis por uma máquina de Turing determinística em tempo polinomial.",
                                    "Defina a classe NP como problemas cujas soluções positivas podem ser verificadas por uma máquina de Turing determinística em tempo polinomial.",
                                    "Explique a inclusão P ⊆ NP: todo problema em P tem um verificador trivial (a própria solução).",
                                    "Discuta exemplos iniciais: P inclui problemas 'fáceis', NP inclui 'potencialmente difíceis' mas verificáveis."
                                  ],
                                  "verification": "Escreva as definições em suas próprias palavras e confirme que P ⊆ NP é aceito por todos os teóricos da computação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (capítulo sobre complexidade)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar P dentro de NP.",
                                  "learningObjective": "Entender conceitualmente por que todo problema em P está automaticamente em NP.",
                                  "commonMistakes": "Confundir P com NP-completo; lembrar que P ⊆ NP é provado, mas NP ⊆ P? é aberto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Exemplificar problemas clássicos em P",
                                  "subSteps": [
                                    "Escolha ordenação: descreva como QuickSort ou MergeSort ordenam n elementos em O(n log n), polinomial.",
                                    "Detalhe busca binária: encontre elemento em array ordenado em O(log n) tempo.",
                                    "Implemente pseudocódigo simples para busca binária.",
                                    "Verifique com input pequeno: array [1,3,5,7], busque 5."
                                  ],
                                  "verification": "Execute o pseudocódigo manualmente e confirme resultado correto em tempo polinomial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE online como Replit",
                                    "Arrays de teste impressos"
                                  ],
                                  "tips": "Sempre meça complexidade assintótica: O(n log n) é polinomial.",
                                  "learningObjective": "Identificar problemas resolvíveis eficientemente em P.",
                                  "commonMistakes": "Ignorar pré-condições como array ordenado para busca binária."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir verificadores polinomiais para problemas em P",
                                  "subSteps": [
                                    "Para ordenação: dado array ordenado e original, verifique se é permutação e está crescente em O(n).",
                                    "Para busca binária: dado array ordenado, índice e alvo, verifique se array[índice] == alvo e está ordenado em O(n).",
                                    "Mostre que verificação é mais rápida ou igual à resolução.",
                                    "Compare: resolução O(n log n), verificação O(n)."
                                  ],
                                  "verification": "Escreva e teste verificador em pseudocódigo com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo anterior",
                                    "Calculadora para contar operações"
                                  ],
                                  "tips": "Verificador recebe 'certificado' (solução proposta) e input.",
                                  "learningObjective": "Demonstrar explicitamente P ⊆ NP via verificadores.",
                                  "commonMistakes": "Pensar que verificação precisa resolver o problema; ela só checa soluções propostas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com exemplo clássico em NP: SAT",
                                  "subSteps": [
                                    "Defina SAT: dada fórmula booleana em CNF, existe atribuição que satisfaz?",
                                    "Explique por que SAT ∈ NP: dado certificado (atribuição), plugue e avalie em tempo linear no tamanho da fórmula.",
                                    "Mostre por que SAT não é trivialmente em P (NP-completo).",
                                    "Compare: problemas em P como ordenação são resolvíveis e verificáveis; SAT verificável mas resolução aberta."
                                  ],
                                  "verification": "Construa fórmula SAT simples (ex: (x1 ∨ ¬x2) ∧ (¬x1 ∨ x2)) e encontre atribuição satisfatória.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta SAT solver online como minisat",
                                    "Fórmulas CNF de exemplo"
                                  ],
                                  "tips": "Use tabelas verdade para fórmulas pequenas.",
                                  "learningObjective": "Diferenciar verificação em NP de resolução em P.",
                                  "commonMistakes": "Confundir SAT com problemas em P; SAT é NP-completo."
                                }
                              ],
                              "practicalExample": "Implemente busca binária em Python para array de 1000 elementos e meça tempo (<1ms). Para SAT, use fórmula 3-SAT pequena e verifique certificado manualmente.",
                              "finalVerifications": [
                                "Liste pelo menos 3 problemas em P com complexidades.",
                                "Construa verificador correto para um problema em P.",
                                "Explique por que SAT está em NP mas não conhecido em P.",
                                "Diferencie resolução de verificação em exemplos.",
                                "Confirme P ⊆ NP com justificativa formal."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas (30%)",
                                "Exemplos relevantes e corretos (25%)",
                                "Verificadores funcionais e polinomiais (20%)",
                                "Contraste claro com NP (15%)",
                                "Clareza na explicação escrita (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos (ex: caminhos curtos em P)",
                                "Lógica: Proposicional e Satisfatibilidade",
                                "Filosofia: Questões indecidíveis e limites da computação",
                                "Engenharia de Software: Análise de complexidade em algoritmos"
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, usar algoritmos em P como busca binária para apps eficientes; entender NP guia evitar problemas intratáveis como otimização combinatória em roteirização de veículos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.5.2",
                        "name": "Hipótese P ≠ NP",
                        "description": "Análise da conjectura mais famosa da ciência da computação, que postula a separação das classes P e NP, e seu status atual como problema aberto.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.2.1",
                            "name": "Enunciar a hipótese P ≠ NP",
                            "description": "Descrever a hipótese como a afirmação de que existem problemas em NP que não são resolvíveis em tempo polinomial por máquinas determinísticas, com referências a Sipser e Hopcroft-Ullman.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definições fundamentais de P e NP",
                                  "subSteps": [
                                    "Estude a definição de máquina de Turing determinística (DTM) e o conceito de tempo de execução polinomial.",
                                    "Defina a classe P como o conjunto de problemas decidíveis por uma DTM em tempo polinomial.",
                                    "Entenda o conceito de verificador polinomial e defina a classe NP como problemas cujas soluções podem ser verificadas em tempo polinomial.",
                                    "Compare exemplos: problema de ordenação em P vs. Satisfatibilidade Booleana (SAT) em NP.",
                                    "Crie um diagrama ilustrando a inclusão P ⊆ NP."
                                  ],
                                  "verification": "Escreva definições precisas de P e NP e forneça um exemplo para cada classe.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Michael Sipser (Capítulo 7)",
                                    "Notas de aula sobre teoria da complexidade computacional"
                                  ],
                                  "tips": "Use analogias como 'P é como cozinhar com receita fixa rápida' vs. 'NP é verificar se a sobremesa está perfeita'.",
                                  "learningObjective": "Dominar as definições exatas de P e NP para contextualizar a hipótese.",
                                  "commonMistakes": [
                                    "Confundir tempo polinomial com exponencial",
                                    "Achar que todos os problemas em NP são 'difíceis' sem verificador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a relação hierárquica entre P e NP",
                                  "subSteps": [
                                    "Analise por que P ⊆ NP: todo problema em P pode ser verificado por si mesmo em tempo polinomial.",
                                    "Discuta se P = NP é possível ou provável, citando evidências empíricas como ausência de algoritmos polinomiais para NP-completos.",
                                    "Explore reduções polinomiais e o papel dos problemas NP-completos na separação potencial.",
                                    "Liste 3 problemas NP-completos e explique por que não esperamos soluções polinomiais determinísticas.",
                                    "Debata implicações se P = NP fosse provado."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que P ⊆ NP e dê um contraexemplo hipotético se P = NP.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Livro 'Introduction to Automata Theory, Languages, and Computation' de Hopcroft e Ullman (Capítulo 11)",
                                    "Vídeo Khan Academy sobre complexidade P vs NP"
                                  ],
                                  "tips": "Pense em termos de 'procurar agulha no palheiro' para NP nondeterminístico.",
                                  "learningObjective": "Entender a inclusão P ⊆ NP e a questão aberta da igualdade.",
                                  "commonMistakes": [
                                    "Acreditar que P = NP porque 'computadores modernos são rápidos'",
                                    "Ignorar que reduções mostram equivalência de dificuldade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar o enunciado da hipótese P ≠ NP",
                                  "subSteps": [
                                    "Enuncie formalmente: 'Existem linguagens em NP que não estão em P', ou equivalentemente, P ≠ NP.",
                                    "Traduza para termos de problemas: 'Nem todo problema em NP é resolvível em tempo polinomial por DTMs'.",
                                    "Escreva em notação matemática: P ⊈ NP ou |P| < |NP| em termos de hierarquia.",
                                    "Diferencie de conjecturas relacionadas como coNP.",
                                    "Pratique reescrevendo o enunciado em 3 variações sinônimas."
                                  ],
                                  "verification": "Escreva o enunciado exato da hipótese e prove que implica P ⊈ NP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo original de Cook (1971) sobre NP-completude",
                                    "Folha de papel e caneta para anotações formais"
                                  ],
                                  "tips": "Memorize a frase chave: 'Problemas em NP não são todos polinomiais em DTMs'.",
                                  "learningObjective": "Capacitar-se a enunciar precisamente a hipótese P ≠ NP.",
                                  "commonMistakes": [
                                    "Dizer 'P é subset de NP' como hipótese, quando é fato provado",
                                    "Confundir com undecidability de Halting Problem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Referenciar fontes autoritativas e praticar o enunciado",
                                  "subSteps": [
                                    "Leia Sipser (p. 266-270) sobre P vs NP e extraia o enunciado exato.",
                                    "Consulte Hopcroft-Ullman (Capítulo 11) para contexto histórico.",
                                    "Pratique enunciando a hipótese em contexto de um problema NP-completo como Clique.",
                                    "Crie flashcards com enunciado, prova informal e referências.",
                                    "Teste-se recitando para um colega ou gravando áudio."
                                  ],
                                  "verification": "Cite Sipser e Hopcroft-Ullman corretamente e recite a hipótese sem erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Cópias digitais dos livros Sipser e Hopcroft-Ullman",
                                    "App Anki para flashcards"
                                  ],
                                  "tips": "Associe a hipótese a prêmios como o Clay Millennium Prize para motivar.",
                                  "learningObjective": "Integrar referências padrão ao enunciado da hipótese.",
                                  "commonMistakes": [
                                    "Citar fontes erradas como Turing para P≠NP",
                                    "Enunciar vagamente sem menção a 'polinomial determinístico'"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma discussão sobre criptografia RSA, enuncie: 'A hipótese P ≠ NP sustenta que fatorar números grandes (em NP) não tem algoritmo polinomial determinístico, garantindo segurança assimétrica'.",
                              "finalVerifications": [
                                "Enuncia corretamente: 'Existem problemas em NP não resolvíveis em tempo polinomial por DTMs'.",
                                "Explica P ⊆ NP como fato e P ≠ NP como hipótese.",
                                "Cita Sipser e Hopcroft-Ullman com capítulos relevantes.",
                                "Distingue de problemas indecidíveis.",
                                "Aplica a um exemplo como SAT ou TSP.",
                                "Responde objeções comuns como 'P=NP em prática'.",
                                "Escreve formalmente em notação matemática."
                              ],
                              "assessmentCriteria": [
                                "Precisão terminológica (DTM, polinomial, verificador): 30%",
                                "Correção formal do enunciado: 25%",
                                "Referências bibliográficas exatas: 15%",
                                "Explicação contextual clara: 15%",
                                "Aplicação a exemplo real: 10%",
                                "Ausência de equívocos comuns: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos e cardinalidade infinita (para hierarquias).",
                                "Filosofia: Limites da computação e decidibilidade (Gödel, Turing).",
                                "Engenharia de Software: Análise de algoritmos e otimização combinatorial.",
                                "Economia: Complexidade em teoria dos jogos e leilões.",
                                "Física: Simulações quânticas e BQP vs NP."
                              ],
                              "realWorldApplication": "A crença em P ≠ NP justifica o uso de criptografia pública (ex: RSA, onde fatoração é assumida não-P), otimização em logística (sem soluções polinomiais exatas para TSP) e IA (busca exaustiva em espaços NP-difíceis)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.5.2.2",
                            "name": "Discutir evidências e tentativas de prova",
                            "description": "Apresentar argumentos informais, como a dificuldade de resolver SAT em tempo polinomial, relativização, oráculos e barreiras conhecidas para provas de separação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Explorar Evidências Empíricas e Heurísticas para P ≠ NP",
                                  "subSteps": [
                                    "Estude o problema SAT e sua importância como problema NP-completo.",
                                    "Analise o desempenho de solvers SAT atuais em instâncias reais e por que falham em grandes tamanhos.",
                                    "Discuta heurísticas como DPLL e por que elas não levam a algoritmos polinomiais.",
                                    "Examine experimentos empíricos mostrando o crescimento exponencial na prática.",
                                    "Compare com problemas em P para contrastar o comportamento."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo por que SAT é difícil na prática e liste 3 evidências empíricas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigos sobre solvers SAT (ex: MiniSat docs)",
                                    "Gráficos de desempenho de SAT competitions",
                                    "Vídeos introdutórios sobre NP-completude"
                                  ],
                                  "tips": "Use benchmarks de SAT competitions para dados reais; foque em phase transitions.",
                                  "learningObjective": "Compreender argumentos informais baseados em observações computacionais.",
                                  "commonMistakes": [
                                    "Confundir falha prática com prova teórica",
                                    "Ignorar instâncias fáceis vs difíceis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Relativização e o Teorema de Baker-Gill-Solovay",
                                  "subSteps": [
                                    "Defina relativização: adicionar um oráculo a uma máquina de Turing.",
                                    "Leia o teorema: existem oráculos A e B onde P^A = NP^A e P^B ≠ NP^B.",
                                    "Construa intuitivamente os oráculos: um que torna SAT fácil, outro difícil.",
                                    "Discuta implicações: provas de separação não podem relativizar.",
                                    "Compare com teoremas que relativizam, como IP=PSPACE."
                                  ],
                                  "verification": "Desenhe diagramas dos dois mundos relativizados e explique em voz alta as construções.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Papel original de Baker-Gill-Solovay (resumo)",
                                    "Notas de aula sobre teoria da complexidade relativizada",
                                    "Simulador de oráculos online"
                                  ],
                                  "tips": "Pense em oráculos como 'super-poderes' que mudam as regras do jogo.",
                                  "learningObjective": "Dominar o conceito de relativização e suas limitações para P vs NP.",
                                  "commonMistakes": [
                                    "Confundir relativização com oráculos absolutos",
                                    "Achar que prova relativização de tudo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Oráculos Específicos e Construções Não-Relativizantes",
                                  "subSteps": [
                                    "Explore oráculos padronizados como o oráculo de tônias para P=NP.",
                                    "Estude oráculos que separam PH de PSPACE para mostrar colapsos.",
                                    "Discuta técnicas não-relativizantes como interatividade em provas probabilísticas.",
                                    "Examine por que oráculos mostram que P vs NP é 'delicada'.",
                                    "Liste exemplos de resultados que não relativizam (ex: Shamir's theorem)."
                                  ],
                                  "verification": "Crie uma tabela comparando oráculos que unem vs separam P e NP.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Livro 'Computational Complexity' de Arora-Barak (capítulo relevante)",
                                    "Apresentações em slides sobre oráculos",
                                    "Ferramentas de visualização de hierarquias de complexidade"
                                  ],
                                  "tips": "Use analogias: oráculos como 'deuses' que alteram a realidade computacional.",
                                  "learningObjective": "Entender como oráculos revelam a fragilidade de provas para P vs NP.",
                                  "commonMistakes": [
                                    "Ignorar que oráculos não provam nada sobre o mundo sem oráculo",
                                    "Confundir oráculos com probabilismo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar Barreiras Conhecidas para Provas de Separação",
                                  "subSteps": [
                                    "Estude natural proofs de Razborov-Rudich: por que falham devido a pseudorandom generators.",
                                    "Analise algebrizing de Aaronson-Wigderson: barreiras para métodos algebricos.",
                                    "Discuta outras barreiras como Mulmuley-Sohoni geometric complexity theory.",
                                    "Avalie tentativas recentes e status aberto do problema.",
                                    "Debata implicações para pesquisa futura."
                                  ],
                                  "verification": "Escreva um ensaio curto (300 palavras) listando 3 barreiras e por que bloqueiam provas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Papers: Razborov-Rudich, Aaronson-Wigderson",
                                    "Surveys sobre barreiras P vs NP",
                                    "Clay Math Institute description of P vs NP"
                                  ],
                                  "tips": "Conecte barreiras a criptografia: PRGs assumem P≠NP.",
                                  "learningObjective": "Conhecer obstáculos teóricos modernos para resolver P vs NP.",
                                  "commonMistakes": [
                                    "Superestimar simplicidade das barreiras",
                                    "Confundir barreiras com provas de impossibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Discutir Argumentos em um Debate Estruturado",
                                  "subSteps": [
                                    "Compile todas as evidências em uma apresentação coesa.",
                                    "Prepare contra-argumentos (ex: otimismo de algoritmos quânticos).",
                                    "Simule um debate: defenda P≠NP usando os tópicos.",
                                    "Avalie forças e fraquezas de cada evidência.",
                                    "Reflita sobre o status filosófico do problema."
                                  ],
                                  "verification": "Grave um vídeo de 5 minutos discutindo as evidências ou apresente para um par.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta de gravação (Zoom)",
                                    "Slides prontos dos steps anteriores",
                                    "Fórum online para feedback (ex: StackExchange)"
                                  ],
                                  "tips": "Use linguagem acessível; evite jargão excessivo.",
                                  "learningObjective": "Capacitar-se a discutir evidências de forma convincente e crítica.",
                                  "commonMistakes": [
                                    "Focar só em um argumento",
                                    "Não reconhecer limitações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um fórum de ciência da computação, debata com colegas por que resolver SAT em tempo polinomial é improvável, citando desempenho de solvers, relativização via oráculos de Baker-Gill-Solovay e barreiras como natural proofs, convencendo um cético de que P≠NP é a hipótese dominante.",
                              "finalVerifications": [
                                "Explica corretamente o teorema de relativização com exemplos de oráculos.",
                                "Lista e descreve pelo menos 3 barreiras para provas de P vs NP.",
                                "Discute evidências empíricas de SAT sem confundir prática com teoria.",
                                "Sintetiza argumentos em um debate coerente.",
                                "Identifica limitações de cada evidência.",
                                "Conecta barreiras a implicações práticas como criptografia."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (ex: definição correta de oráculos).",
                                "Profundidade de análise (detalhes sobre construções e proofs).",
                                "Clareza na comunicação (explicações acessíveis).",
                                "Uso de evidências múltiplas e balanceadas.",
                                "Criatividade em conexões e exemplos.",
                                "Capacidade de crítica (reconhecer contra-argumentos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da prova e lógica (Gödel's theorems).",
                                "Filosofia: Epistemologia e problemas indecidíveis.",
                                "Física: Complexidade computacional em simulações quânticas.",
                                "Economia: Otimização e teoria dos jogos (NP-hard problems)."
                              ],
                              "realWorldApplication": "Em criptografia, assumir P≠NP sustenta segurança de RSA; em otimização logística, heurísticas SAT guiam soluções práticas para roteamento, informando políticas de pesquisa em IA e computação sustentável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1"
                            ]
                          },
                          {
                            "id": "10.1.8.5.2.3",
                            "name": "Analisar consequências de P = NP",
                            "description": "Explorar o impacto hipotético se P = NP fosse provado, como colapso de hierarquias de complexidade e quebra de criptosistemas baseados em NP-completude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de P, NP e Problemas NP-Completos",
                                  "subSteps": [
                                    "Defina formalmente as classes P e NP usando máquinas de Turing determinísticas e não-determinísticas.",
                                    "Liste exemplos clássicos de problemas em P (ex: ordenação rápida) e em NP (ex: problema da satisfatibilidade booleana - SAT).",
                                    "Explique o conceito de redução polinomial e identifique problemas NP-completos como o Viajante Comerciante (TSP).",
                                    "Discuta a hipótese P ≠ NP e evidências indiretas como oráculos e barreiras de prova.",
                                    "Crie um diagrama comparativo das classes de complexidade."
                                  ],
                                  "verification": "Produza um resumo escrito de 300 palavras com definições precisas e exemplos corretos, validado por auto-quiz com 90% de acerto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (capítulos relevantes)",
                                    "Artigos da Wikipedia sobre P vs NP",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use analogias cotidianas, como P sendo 'resolvível em tempo razoável' e NP 'verificável rapidamente mas possivelmente difícil de resolver'.",
                                  "learningObjective": "Compreender as bases teóricas para analisar cenários hipotéticos de P = NP.",
                                  "commonMistakes": [
                                    "Confundir NP com NP-completo",
                                    "Ignorar reduções polinomiais",
                                    "Subestimar o status aberto do problema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Colapso das Hierarquias de Complexidade",
                                  "subSteps": [
                                    "Explique como P = NP implicaria P = NP-completo, colapsando a hierarquia PH (Polynomial Hierarchy).",
                                    "Estude teoremas de Ladner e implicações para classes intermediárias como UP e coNP.",
                                    "Simule reduções em cadeia: resolva TSP reduzindo a SAT e vice-versa em tempo polinomial.",
                                    "Discuta barreiras relativização (Baker-Gill-Solovay) e por que P = NP as contorna.",
                                    "Crie um fluxograma mostrando o colapso de níveis Σ_k e Π_k no PH."
                                  ],
                                  "verification": "Desenvolva um diagrama de colapso hierárquico e explique em vídeo de 5 minutos como P = NP afeta níveis superiores.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Paper 'Relativization of Questions about Cellular Automata' de Baker-Gill-Solovay",
                                    "Ferramentas de modelagem como Lucidchart",
                                    "Vídeos de Scott Aaronson sobre complexidade"
                                  ],
                                  "tips": "Pense em hierarquias como camadas de cebola: provar P = NP derreteria todas as camadas externas.",
                                  "learningObjective": "Identificar e explicar o impacto estrutural em teorias de complexidade computacional.",
                                  "commonMistakes": [
                                    "Confundir colapso com igualdade trivial",
                                    "Ignorar implicações para PH além de NP",
                                    "Não considerar oráculos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Impacto na Criptografia e Segurança Computacional",
                                  "subSteps": [
                                    "Descreva criptosistemas baseados em NP-completos, como RSA (fatoração é em NP) e ECC.",
                                    "Simule quebra de RSA: dado P = NP, reduza fatoração a um problema NP-completo solucionável em P.",
                                    "Analise consequências para assinatura digital, blockchain e protocolos como Diffie-Hellman.",
                                    "Explore criptografia pós-quântica e por que P = NP seria catastrófico mesmo sem quânticos.",
                                    "Debata mitigações hipotéticas, como chaves simétricas massivas ou novos paradigmas."
                                  ],
                                  "verification": "Escreva um relatório de 500 palavras prevendo falhas em sistemas reais como Bitcoin, com simulação de ataque em pseudocódigo.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Documentação OpenSSL sobre RSA",
                                    "Ferramenta SageMath para simulações criptográficas",
                                    "Paper 'A Concrete Security Analysis of OCB'"
                                  ],
                                  "tips": "Teste com números pequenos: fatorar 15=3*5 é trivial, mas escale para chaves de 2048 bits.",
                                  "learningObjective": "Avaliar vulnerabilidades práticas em tecnologias de segurança dependentes de P ≠ NP.",
                                  "commonMistakes": [
                                    "Achar que só afeta assimetria",
                                    "Ignorar hash functions e one-way functions",
                                    "Superestimar criptografia quântica como solução"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Consequências Amplas e Implicações Globais",
                                  "subSteps": [
                                    "Discuta impactos em otimização: resolução instantânea de logística, scheduling e IA.",
                                    "Explore economia: monopólios em computação onipotente vs. desigualdades de acesso.",
                                    "Analise sociedade: privacidade universal colapsada, avanços em medicina (protein folding).",
                                    "Debata filosofia: limites do conhecimento computacional e 'fim da teoria computacional'.",
                                    "Crie um ensaio equilibrado com prós (progresso científico) e contras (caos de segurança)."
                                  ],
                                  "verification": "Apresente um ensaio de 800 palavras com referências, avaliado por rubrica de profundidade e equilíbrio.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Livro 'The P=NP Question and Gödel’s Lost Letter' de Fortnow",
                                    "Artigos de Quanta Magazine sobre P vs NP",
                                    "Ferramenta de escrita como Overleaf"
                                  ],
                                  "tips": "Estruture como debate: lado otimista vs. distópico para visão balanceada.",
                                  "learningObjective": "Integrar análises parciais em uma visão holística de transformações hipotéticas.",
                                  "commonMistakes": [
                                    "Focar só em negativos",
                                    "Ignorar limitações práticas como hardware",
                                    "Não contextualizar com avanços atuais"
                                  ]
                                }
                              ],
                              "practicalExample": "Imagine um mundo onde P=NP é provado: um programador usa um solver polinomial para quebrar a criptografia de um banco central em minutos, transferindo trilhões em criptomoedas enquanto otimiza rotas de entrega global em tempo real, colapsando mercados financeiros e revolucionando logística simultaneamente.",
                              "finalVerifications": [
                                "Explicar corretamente por que P=NP implica colapso de NP-completos para P.",
                                "Simular quebra de RSA via redução a SAT em pseudocódigo funcional.",
                                "Listar 5 hierarquias colapsadas e suas implicações.",
                                "Debater 3 impactos econômicos com exemplos reais.",
                                "Identificar 2 barreiras de prova superadas e limitações restantes.",
                                "Produzir diagrama preciso de classes de complexidade pré e pós P=NP."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e teoremas corretos (30%)",
                                "Profundidade de análise: conexões lógicas entre impactos (25%)",
                                "Criatividade em exemplos: simulações práticas viáveis (20%)",
                                "Equilíbrio: prós e contras bem argumentados (15%)",
                                "Clareza e estrutura: fluxogramas e relatórios organizados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e lógica matemática (fatoração, Gödel).",
                                "Filosofia: Epistemologia e limites do conhecimento humano/computacional.",
                                "Economia: Otimização de recursos e teoria dos jogos em mercados.",
                                "Física: Simulações computacionais em mecânica quântica e partículas.",
                                "Ética: Implicações morais de poder computacional onipotente."
                              ],
                              "realWorldApplication": "Essa análise prepara profissionais de TI para cenários de crise criptográfica, inspira pesquisas em computação quântica/ótica como hedges, e informa políticas de cibersegurança governamentais, como migração para criptografia resistente a P=NP."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.5.3",
                        "name": "Implicações para problemas intratáveis",
                        "description": "Exploração das consequências práticas da crença em P ≠ NP para a existência de problemas intratáveis em teoria da computação e aplicações reais.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.5.3.1",
                            "name": "Relacionar P ≠ NP com problemas NP-completos",
                            "description": "Explicar como problemas NP-completos, se intratáveis, implicam intratabilidade para toda a classe NP sob P ≠ NP, citando redução de Cook-Levin.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de P, NP e NP-Completos",
                                  "subSteps": [
                                    "Defina formalmente a classe P como problemas decidíveis em tempo polinomial por uma máquina de Turing determinística.",
                                    "Defina NP como problemas cujas soluções podem ser verificadas em tempo polinomial por uma máquina de Turing não-determinística.",
                                    "Explique NP-completos como problemas em NP aos quais todo problema em NP pode ser reduzido em tempo polinomial.",
                                    "Liste exemplos clássicos como SAT, Clique e TSP.",
                                    "Discuta a hipótese P ≠ NP como uma conjectura não provada."
                                  ],
                                  "verification": "Escreva definições precisas e exemplos em um resumo de 1 página, sem erros conceituais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (capítulos relevantes)",
                                    "Notas de aula sobre complexidade computacional",
                                    "Acesso a Wikipedia para verificação rápida"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar P ⊆ NP e a posição dos NP-completos.",
                                  "learningObjective": "Compreender as bases teóricas para contextualizar a relação com P ≠ NP.",
                                  "commonMistakes": [
                                    "Confundir P com NP (pensar que P = NP é provado)",
                                    "Ignorar que NP-completos estão na interseção mais 'difícil' de NP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Hipótese P ≠ NP e Seu Impacto em NP-Completos",
                                  "subSteps": [
                                    "Explique que se P = NP, todos os problemas NP (incluindo NP-completos) seriam resolvíveis em tempo polinomial.",
                                    "Discuta que sob P ≠ NP, problemas NP-completos seriam intratáveis (não polinomiais).",
                                    "Analise por que provar intratabilidade de um NP-completo implica para todos NP-completos via reduções polinomiais.",
                                    "Crie um fluxograma mostrando: P ≠ NP → NP-completos intratáveis → Reduções implicam NP intratável.",
                                    "Debata implicações filosóficas brevemente."
                                  ],
                                  "verification": "Desenhe e explique o fluxograma oralmente ou em vídeo curto (2 min).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e caneta para fluxogramas",
                                    "Vídeo Khan Academy sobre P vs NP",
                                    "Artigo 'P vs NP' de Scott Aaronson"
                                  ],
                                  "tips": "Pense em 'cadeia de implicações': um elo fraco quebra toda a classe.",
                                  "learningObjective": "Graspar como a hipótese afeta diretamente a classe NP via NP-completos.",
                                  "commonMistakes": [
                                    "Achar que P ≠ NP prova intratabilidade absoluta (só relativa a polinomial)",
                                    "Esquecer reduções transitivas entre NP-completos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar a Redução de Cook-Levin",
                                  "subSteps": [
                                    "Descreva a redução de Cook-Levin: reduz SAT (3-SAT) para problemas de máquina de Turing.",
                                    "Explique como qualquer problema em NP pode ser reduzido a SAT em tempo polinomial.",
                                    "Detalhe o teorema: SAT é NP-completo, logo todo NP reduz a SAT.",
                                    "Implemente um exemplo simples: reduza 'Halting Problem verificável' para SAT.",
                                    "Verifique formalmente os passos da prova de Cook-Levin."
                                  ],
                                  "verification": "Escreva pseudocódigo da redução para um problema NP simples e valide.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Paper original de Cook (1971) ou resumo em Sipser",
                                    "Ferramenta online como Logicly para simular SAT",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Foquem em como a redução preserva polinomialidade: tempo de redução ≤ polinomial.",
                                  "learningObjective": "Dominar a prova pivotal que estabelece SAT como o 'líder' dos NP-completos.",
                                  "commonMistakes": [
                                    "Confundir redução com simulação direta",
                                    "Ignorar que é redução muitos-um polinomial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Implicações para Toda a Classe NP",
                                  "subSteps": [
                                    "Conclua: Se um NP-completo é intratável (sob P ≠ NP), todos NP-completos o são via reduções encadeadas.",
                                    "Estenda: Todo problema em NP reduz a um NP-completo, implicando intratabilidade geral para NP.",
                                    "Discuta contra-exemplos hipotéticos e por que P = NP colapsaria as classes.",
                                    "Crie um mapa mental conectando Cook-Levin a implicações globais.",
                                    "Resuma em uma declaração formal: 'P ≠ NP ⇒ NP intratável'."
                                  ],
                                  "verification": "Apresente o mapa mental e explique em 3 minutos sem pausas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de mind mapping como MindMeister",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Use setas para mostrar direções de implicação: NP → NP-C → SAT.",
                                  "learningObjective": "Integrar todos os conceitos em uma visão coesa das implicações.",
                                  "commonMistakes": [
                                    "Superestimar: achar que prova existência de problemas intratáveis além de polinomiais",
                                    "Subestimar: ignorar que reduções são 'fáceis'"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere otimização de rotas de entrega (TSP, NP-completo). Sob P ≠ NP, se TSP é intratável, via Cook-Levin reduzimos Clique (outro NP) a TSP, implicando que detectar grupos densos em redes sociais (Clique) também é intratável para instâncias grandes.",
                              "finalVerifications": [
                                "Explica corretamente a cadeia: P ≠ NP → NP-completos intratáveis → NP intratável.",
                                "Cita e resume a redução de Cook-Levin sem erros.",
                                "Distingue verificação polinomial de solução polinomial.",
                                "Fornece exemplo de redução entre dois NP-completos.",
                                "Discute implicações se P = NP fosse provado.",
                                "Identifica limitações (não prova intratabilidade exponencial)"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições exatas de P, NP, NP-C (90%+ correto).",
                                "Compreensão de reduções: explica Cook-Levin com passos lógicos.",
                                "Profundidade de implicações: conecta corretamente a toda classe NP.",
                                "Uso de exemplos: aplica a cenários reais sem distorções.",
                                "Clareza de comunicação: fluxogramas/mapas mentais bem estruturados.",
                                "Originalidade: sintetiza em declaração formal própria."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da complexidade e provas por contradição.",
                                "Lógica: Proposições booleanas e tautologias em SAT.",
                                "Filosofia: Questões irresolúveis e limites do conhecimento humano.",
                                "Engenharia de Software: Análise de algoritmos e heurísticas práticas."
                              ],
                              "realWorldApplication": "Em criptografia, se P ≠ NP sustentar, problemas como fatoração (base de RSA) permanecem seguros; em logística, justifica uso de heurísticas para NP-completos como scheduling de voos, impactando eficiência global de supply chains."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.2"
                            ]
                          },
                          {
                            "id": "10.1.8.5.3.2",
                            "name": "Identificar problemas intratáveis práticos",
                            "description": "Discutir exemplos como o problema do caixeiro viajante (TSP), particionamento e implicações em otimização combinatória e IA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Problemas Intratáveis",
                                  "subSteps": [
                                    "Defina problemas decidíveis, indecidíveis e intratáveis (NP-completos e NP-difíceis).",
                                    "Explique a relação entre P, NP, NP-completos e NP-difíceis usando diagramas de Venn.",
                                    "Discuta por que problemas NP-difíceis não têm algoritmos eficientes conhecidos para instâncias grandes.",
                                    "Revise teoremas de Cook-Levin e redução polinomial para mostrar equivalência entre problemas.",
                                    "Identifique critérios para classificar um problema como intratável."
                                  ],
                                  "verification": "Crie um mapa conceitual resumindo P vs NP e exemplos de classes, e explique para um colega.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Introduction to the Theory of Computation' de Sipser (capítulos relevantes)",
                                    "Artigo da Wikipedia sobre P vs NP",
                                    "Vídeo Khan Academy sobre complexidade computacional"
                                  ],
                                  "tips": "Use analogias como 'procurar uma agulha no palheiro' para visualizar explosão combinatória.",
                                  "learningObjective": "Dominar terminologia e fundamentos teóricos de intratabilidade computacional.",
                                  "commonMistakes": "Confundir NP-completo com 'impossível de resolver' (eles são resolvíveis, mas ineficientemente)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos Clássicos: TSP e Particionamento",
                                  "subSteps": [
                                    "Descreva o Problema do Caixeiro Viajante (TSP): encontre o ciclo hamiltoniano de menor custo em um grafo completo.",
                                    "Implemente uma solução exaustiva simples para TSP em Python para n=5 cidades.",
                                    "Explique o problema de Particionamento: divida um conjunto de números em dois subconjuntos com soma igual.",
                                    "Mostre reduções: TSP reduz para Hamiltoniano e Particionamento é NP-completo via Subconjunto Soma.",
                                    "Compare crescimento exponencial: calcule 2^n para n=20 no particionamento."
                                  ],
                                  "verification": "Resolva manualmente TSP para 4 cidades e prove que é ótimo; liste passos de redução para particionamento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Pseudocódigo TSP no GeeksforGeeks",
                                    "Ferramenta online TSP Solver",
                                    "Jupyter Notebook para simulações NP"
                                  ],
                                  "tips": "Desenhe grafos à mão para visualizar TSP antes de codificar.",
                                  "learningObjective": "Reconhecer e formalizar problemas intratáveis clássicos com provas de NP-dificuldade.",
                                  "commonMistakes": "Ignorar que heurísticas aproximam, mas não garantem otimalidade em NP-hard."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Implicações em Otimização Combinatória e IA",
                                  "subSteps": [
                                    "Discuta otimização combinatória: enumerar soluções em espaços discretos explode para NP-hard.",
                                    "Explique heurísticas e meta-heurísticas (genéticos, simulated annealing) para TSP prático.",
                                    "Analise impacto em IA: planejamento autônomo, aprendizado por reforço lida com MDPs aproximados de problemas intratáveis.",
                                    "Debata implicações de P=NP: criptografia quebra se P=NP.",
                                    "Compare branch-and-bound vs exaustivo em cenários reais."
                                  ],
                                  "verification": "Escreva um parágrafo comparando exato vs heurístico para TSP em logística.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Paper 'The Traveling Salesman Problem' de Applegate et al.",
                                    "Tutorial scikit-opt para heurísticas",
                                    "Vídeo MIT OCW sobre otimização combinatória"
                                  ],
                                  "tips": "Teste heurísticas em datasets reais para ver trade-offs tempo vs qualidade.",
                                  "learningObjective": "Entender estratégias práticas para contornar intratabilidade em otimização e IA.",
                                  "commonMistakes": "Achar que 'IA resolve tudo' sem reconhecer limites teóricos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Classificar Problemas Intratáveis Práticos",
                                  "subSteps": [
                                    "Liste 5 problemas práticos NP-hard: escalonamento de jobs, coloração de grafos, knapsack.",
                                    "Classifique um problema real (ex: roteirização de veículos) como NP-hard via redução.",
                                    "Avalie quando usar exato, aproximação ou relaxação linear.",
                                    "Crie um checklist para identificar intratabilidade: combinatório? Redução conhecida?",
                                    "Debata cenários onde 'intratável' vira tratável via estrutura especial."
                                  ],
                                  "verification": "Identifique 3 problemas do dia a dia como NP-hard e proponha heurística para cada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Lista de problemas NP-completos no Wikipedia",
                                    "Ferramenta OR-Tools Google para modelagem",
                                    "Exercícios de Garey & Johnson 'Computers and Intractability'"
                                  ],
                                  "tips": "Procure padrões: 'melhor caminho', 'partilha ótima' geralmente são NP-hard.",
                                  "learningObjective": "Desenvolver habilidade de detectar e lidar com intratabilidade em contextos aplicados.",
                                  "commonMistakes": "Classificar problemas polinomiais (ex: Dijkstra) como intratáveis por confusão."
                                }
                              ],
                              "practicalExample": "Em uma empresa de entregas, use TSP para otimizar rotas de 10 caminhões: solução exata demora dias (2^10 permutações), então aplique heurística genética para rota 95% ótima em minutos, economizando combustível.",
                              "finalVerifications": [
                                "Liste e explique 3 problemas NP-hard práticos com reduções.",
                                "Implemente e compare exato vs heurístico para TSP pequeno.",
                                "Discuta 2 implicações se P=NP fosse provado.",
                                "Crie checklist para identificar intratabilidade.",
                                "Avalie um problema real propondo estratégia prática.",
                                "Explique por que IA usa aproximações para otimização combinatória."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de classes de complexidade (P, NP, NP-hard).",
                                "Correta formalização e redução de exemplos como TSP e Particionamento.",
                                "Profundidade na discussão de heurísticas e implicações em IA.",
                                "Capacidade de identificar novos problemas intratáveis com justificativa.",
                                "Clareza em exemplos práticos e verificações.",
                                "Uso correto de terminologia teórica sem erros conceituais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Combinatória (Hamiltonianos, reduções).",
                                "Inteligência Artificial: Algoritmos de Busca, Aprendizado por Reforço Heurístico.",
                                "Engenharia de Software: Análise de Complexidade em Design de Sistemas.",
                                "Economia: Otimização de Recursos e Modelos de Decisão.",
                                "Filosofia da Ciência: Limites do Computacional e Epistemologia."
                              ],
                              "realWorldApplication": "Na logística global (Amazon, UPS), TSP intratável guia bilhões em rotas diárias via heurísticas; em IA, otimização de redes neurais usa aproximações NP-hard para hiperparâmetros, impactando desde entregas até diagnósticos médicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.2"
                            ]
                          },
                          {
                            "id": "10.1.8.5.3.3",
                            "name": "Explorar abordagens para problemas NP-difíceis",
                            "description": "Descrever heurísticas, aproximações polinomiais e meta-heurísticas como ramificação e corte para lidar com problemas presumidamente intratáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Heurísticas e Aproximações Polinomiais para Problemas NP-Difíceis",
                                  "subSteps": [
                                    "Defina heurísticas como regras práticas que encontram soluções boas, mas não necessariamente ótimas, em tempo polinomial.",
                                    "Explique aproximações polinomiais: algoritmos que garantem soluções dentro de um fator de um ótimo conhecido (ex.: fator de aproximação ρ).",
                                    "Estude exemplos clássicos como o algoritmo greedy para Vertex Cover ou Christofides para TSP (fator 1.5).",
                                    "Analise classes de problemas: APX (aproximáveis) vs. inaproximáveis.",
                                    "Pratique calculando a razão de aproximação para um grafo simples."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre heurísticas e aproximações, com um exemplo numérico resolvido.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Livro 'Computers and Intractability' de Garey e Johnson; Khan Academy ou MIT OCW vídeos sobre NP-completude; papel e lápis para grafos.",
                                  "tips": "Comece com problemas pequenos para visualizar o trade-off entre tempo e qualidade da solução.",
                                  "learningObjective": "Identificar quando usar heurísticas vs. exatas e calcular fatores de aproximação básicos.",
                                  "commonMistakes": "Confundir heurística (sem garantia) com aproximação (com garantia de qualidade); ignorar análise de complexidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Meta-Heurísticas para Soluções Robóticas",
                                  "subSteps": [
                                    "Defina meta-heurísticas: frameworks de alto nível como Algoritmos Genéticos (AG), Simulated Annealing (SA) e Tabu Search.",
                                    "Estude AG: população inicial, crossover, mutação, seleção por fitness.",
                                    "Analise SA: inspiração no recozimento metálico, temperatura decrescente, probabilidade de aceitação.",
                                    "Compare Tabu Search: memória de curto/longo prazo para evitar ciclos.",
                                    "Implemente um pseudocódigo simples para SA em um problema como Knapsack."
                                  ],
                                  "verification": "Crie um fluxograma de uma meta-heurística escolhida e simule 5 iterações manualmente.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Artigos de Glover (Tabu Search); tutoriais em Python para AG (DEAP library); simulador online de meta-heurísticas.",
                                  "tips": "Visualize evoluções com ferramentas como AnyLogic ou desenhos manuais para entender convergência.",
                                  "learningObjective": "Descrever o mecanismo de busca local e global em meta-heurísticas.",
                                  "commonMistakes": "Subestimar parâmetros (ex.: taxa de mutação alta causa caos); não monitorar estagnação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar Métodos de Ramificação e Corte (Branch-and-Bound e Branch-and-Cut)",
                                  "subSteps": [
                                    "Explique Branch-and-Bound (B&B): árvore de decisão, relaxação LP, poda por limites (upper/lower bound).",
                                    "Estude Branch-and-Cut: B&B + cortes válidos (ex.: Gomory cuts) para apertar relaxações.",
                                    "Aplique a TSP: use held-karp para lower bounds.",
                                    "Discuta estratégias de branching: mais fraco/conflitante primeiro.",
                                    "Resolva um problema pequeno de 0-1 Knapsack com B&B manualmente."
                                  ],
                                  "verification": "Desenhe a árvore de B&B para um Knapsack com 4 itens e identifique podas.",
                                  "estimatedTime": "4-5 horas",
                                  "materials": "Solver como CPLEX/GLPK (versão gratuita); tutoriais em Operations Research Stack Exchange; grafos em Graphviz.",
                                  "tips": "Sempre compute bounds antes de ramificar para maximizar podas.",
                                  "learningObjective": "Construir e otimizar árvores de busca exata para problemas NP-difíceis.",
                                  "commonMistakes": "Esquecer de atualizar bounds globais; branching ineficiente levando a explosão exponencial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Abordagens e Aplicar em um Caso Prático",
                                  "subSteps": [
                                    "Compare heurísticas (rápidas, sem garantia), meta-heurísticas (flexíveis, probabilísticas) e B&B/Cut (exatas, lentas).",
                                    "Avalie trade-offs: tempo vs. qualidade via experimentos simulados.",
                                    "Escolha abordagem baseada em instância: exatas para pequenas, heurísticas para grandes.",
                                    "Integre híbridos: meta-heurística + B&B local.",
                                    "Documente prós/contras em uma tabela para TSP e Knapsack."
                                  ],
                                  "verification": "Escreva um relatório de 1 página comparando soluções para o mesmo problema com 3 abordagens.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Planilha Excel para benchmarks; problemas de benchmark como TSPLIB.",
                                  "tips": "Meça tempo real com cronômetro para sentir a diferença prática.",
                                  "learningObjective": "Selecionar e justificar a melhor abordagem para um problema dado.",
                                  "commonMistakes": "Ignorar escalabilidade; superestimar exatidão sem considerar tamanho da instância."
                                }
                              ],
                              "practicalExample": "Para o Problema do Caixeiro Viajante (TSP) com 10 cidades: use heurística nearest neighbor (rápida), AG (boa solução em minutos) e Branch-and-Cut via solver (ótima em horas), comparando tours e tempos.",
                              "finalVerifications": [
                                "Descreva com precisão 3 heurísticas e 2 meta-heurísticas com exemplos.",
                                "Resolva manualmente um B&B para Knapsack pequeno, mostrando podas.",
                                "Calcule fator de aproximação para um algoritmo em Vertex Cover.",
                                "Compare tempos e qualidades em um benchmark TSP.",
                                "Explique por que P=NP implicaria falha dessas abordagens.",
                                "Liste 2 híbridos e suas vantagens."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (30%)",
                                "Exemplos práticos: relevância e cálculos corretos (25%)",
                                "Análise comparativa: trade-offs claros e justificados (20%)",
                                "Profundidade técnica: detalhes em bounds/cortes (15%)",
                                "Criatividade: sugestões de híbridos ou aplicações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Programação Linear e Otimização Combinatória.",
                                "Inteligência Artificial: Algoritmos Evolucionários e Busca Heurística.",
                                "Engenharia de Software: Design de solvers e testes de performance.",
                                "Economia: Modelagem de otimização em alocação de recursos."
                              ],
                              "realWorldApplication": "Em logística (roteirização de entregas na Amazon via heurísticas/meta-heurísticas), manufatura (job-shop scheduling com branch-and-cut) e bioinformática (alinhamento de sequências com aproximações), onde soluções exatas são inviáveis para instâncias reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.5.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 372
          }
        ],
        "totalSkills": 372
      }
    ]
  }
}