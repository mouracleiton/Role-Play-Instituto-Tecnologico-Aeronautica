{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T10:32:58.082Z",
  "appVersion": "1.0.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - AT-91",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 337
    },
    "areas": [
      {
        "id": "10",
        "name": "Matemática",
        "description": "Disciplinas fundamentais de Matemática Aplicada e Computacional.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Análise Numérica I",
            "description": "Métodos de passo simples e de passo múltiplo para a solução do problema de valor inicial. Controle de passo. Estabilidade. Problemas Stiff. Métodos para a solução do problema de valor de contorno. Introdução aos métodos pseudoespectrais.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Métodos de Passo Simples para Problemas de Valor Inicial",
                "description": "Métodos numéricos de um único passo para resolver equações diferenciais ordinárias de valor inicial.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Método de Euler Explícito",
                    "description": "Método numérico de primeiro passo simples para aproximação de soluções de EDOs de valor inicial, baseado na expansão de Taylor de primeira ordem.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Definição e Formulação do Método de Euler Explícito",
                        "description": "Apresenta o problema de valor inicial para EDOs e a formulação básica do método de Euler explícito como aproximação de primeiro passo simples.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Identificar o Problema de Valor Inicial",
                            "description": "Reconhecer e formular o problema de valor inicial y' = f(t,y), y(t0) = y0, e explicar por que métodos numéricos de passo simples são necessários para sua aproximação numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Equações Diferenciais Ordinárias (EDOs)",
                                  "subSteps": [
                                    "Revise a definição de derivada como taxa de variação instantânea.",
                                    "Identifique que uma EDO relaciona uma função desconhecida y(t) com suas derivadas.",
                                    "Diferencie EDOs de primeira ordem das de ordem superior.",
                                    "Estude exemplos simples como y' = ky (crescimento exponencial).",
                                    "Pratique identificando a ordem e o tipo de EDO em equações dadas."
                                  ],
                                  "verification": "Liste 3 exemplos de EDOs de primeira ordem e classifique-os corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Cálculo Diferencial e Integral (capítulo de EDOs)",
                                    "Vídeos tutoriais sobre EDOs no Khan Academy",
                                    "Folha de exercícios com 5 EDOs para classificar"
                                  ],
                                  "tips": "Comece com exemplos físicos intuitivos, como velocidade e posição, para visualizar a derivada.",
                                  "learningObjective": "Entender o papel das EDOs em modelar fenômenos dinâmicos contínuos.",
                                  "commonMistakes": [
                                    "Confundir EDO com equação algébrica",
                                    "Ignorar a dependência de t ou y na função f",
                                    "Não distinguir ordem da derivada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer a Forma Padrão do Problema de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Memorize a notação y' = f(t, y), onde f é uma função contínua.",
                                    "Identifique a condição inicial y(t₀) = y₀ como fixador da solução única.",
                                    "Analise componentes: variável independente t, dependente y, função f e ponto inicial (t₀, y₀).",
                                    "Compare com problemas sem condição inicial (família de soluções).",
                                    "Escreva a forma padrão para 3 equações dadas."
                                  ],
                                  "verification": "Reescreva corretamente 3 EDOs na forma y' = f(t,y) com condição inicial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para diagramas",
                                    "Exemplos impressos de PVIs de livros de Análise Numérica",
                                    "Software como GeoGebra para plotar soluções"
                                  ],
                                  "tips": "Use setas para mostrar fluxo: de f(t,y) para y', e y(t₀)=y₀ para unicidade.",
                                  "learningObjective": "Reconhecer e formular precisamente a estrutura matemática do PVI.",
                                  "commonMistakes": [
                                    "Escrever y' = f(y) sem t",
                                    "Confundir y₀ com f(t₀)",
                                    "Omitir a condição inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular PVIs a Partir de Contextos Reais",
                                  "subSteps": [
                                    "Traduza problemas verbais em EDOs: ex., 'taxa de crescimento proporcional à população'.",
                                    "Defina y(t) claramente (ex., população em tempo t).",
                                    "Estabeleça a condição inicial baseada em dados iniciais.",
                                    "Verifique se f(t,y) é Lipschitz para garantir existência e unicidade.",
                                    "Formule 2 PVIs de contextos diferentes (população, decaimento radioativo)."
                                  ],
                                  "verification": "Crie um PVI completo para um cenário dado, como 'uma cultura bacteriana dobra a cada hora, inicial 100 bactérias'.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Casos reais de modelagem (artigos ou problemas de livros)",
                                    "Calculadora para verificar consistência",
                                    "Template de formulação de PVI"
                                  ],
                                  "tips": "Sempre pergunte: 'O que é y? Qual taxa? Condição inicial?'",
                                  "learningObjective": "Aplicar a formulação de PVI em problemas contextualizados.",
                                  "commonMistakes": [
                                    "Definir y incorretamente",
                                    "Usar taxa constante em vez de proporcional",
                                    "Esquecer unidades consistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar a Necessidade de Métodos Numéricos de Passo Simples",
                                  "subSteps": [
                                    "Discuta quando soluções analíticas existem (ex., separáveis, lineares).",
                                    "Identifique casos sem solução fechada (f não linear complexa).",
                                    "Explique limitações analíticas: tempo computacional, precisão.",
                                    "Introduza métodos numéricos: aproximações iterativas y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Justifique passo simples: local, evita erros globais iniciais."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que Euler é necessário para y' = y + sin(t), y(0)=1.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Gráficos comparando soluções analíticas vs. numéricas",
                                    "Python/MATLAB para simular um PVI sem solução analítica",
                                    "Artigo sobre Teorema de Picard-Lindelöf"
                                  ],
                                  "tips": "Compare com previsão do tempo: analítico impossível, numérico viável.",
                                  "learningObjective": "Compreender limitações analíticas e motivação para métodos numéricos.",
                                  "commonMistakes": [
                                    "Achar que todo PVI tem solução exata",
                                    "Confundir estabilidade com precisão",
                                    "Ignorar condição de Lipschitz"
                                  ]
                                }
                              ],
                              "practicalExample": "Para modelar o crescimento de uma população de coelhos: defina y(t) como número de coelhos em tempo t (semanas), y'(t) = 0.1 y(t) (crescimento 10% por semana), com y(0) = 100. Formule como y' = 0.1 y, y(0)=100. Sem solução analítica simples para variações, use Euler: y_{n+1} = y_n + h * 0.1 y_n.",
                              "finalVerifications": [
                                "Formula corretamente y' = f(t,y), y(t0)=y0 para 3 problemas dados.",
                                "Explica unicidade via condição inicial.",
                                "Identifica quando analítico falha e numérico é essencial.",
                                "Traduz contexto real em PVI padrão.",
                                "Descreve motivação para métodos de passo simples como Euler.",
                                "Verifica Lipschitz em f simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (100% corretude).",
                                "Clareza na explicação de componentes do PVI (rubrica 1-5).",
                                "Capacidade de formulação contextual (exemplos originais).",
                                "Profundidade na justificativa numérica (cita teoremas).",
                                "Ausência de erros comuns (verificação zero falhas).",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Cinemática (posição, velocidade como PVI).",
                                "Biologia: Modelos populacionais (Lotka-Volterra).",
                                "Engenharia: Circuitos RC (corrente como y(t)).",
                                "Economia: Modelos de crescimento (juros compostos).",
                                "Computação: Implementação numérica em Python."
                              ],
                              "realWorldApplication": "Em simulações de epidemias (SIR model: y' = f(t,y) para infectados), engenharia aeroespacial (tra jetórias de foguetes), finanças (preços de opções via EDOs Black-Scholes), e previsão climática, onde PVIs sem solução analítica são aproximados numericamente para decisões críticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Escrever a Fórmula do Método de Euler Explícito",
                            "description": "Derivar e escrever a iteração yn+1 = yn + h * f(tn, yn), explicando os papéis de h (passo), tn e yn como aproximações para t(tn) e y(tn).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Defina um PVI como a equação diferencial y' = f(t, y) com condição inicial y(t0) = y0.",
                                    "Explique que soluções exatas são raras, justificando métodos numéricos.",
                                    "Identifique os componentes: função f(t,y), tempo t, solução y(t).",
                                    "Esboce graficamente a curva solução e a tangente em um ponto inicial.",
                                    "Discuta a necessidade de aproximações em pontos discretos tn."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o que é um PVI e seus componentes principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Gráfica simples de y' = f(t,y)",
                                    "Livro-texto de Análise Numérica"
                                  ],
                                  "tips": "Use exemplos simples como y' = y para visualizar a exponencial.",
                                  "learningObjective": "Entender a base teórica de um PVI e a motivação para métodos numéricos.",
                                  "commonMistakes": [
                                    "Confundir y' com a solução y(t)",
                                    "Ignorar a condição inicial",
                                    "Pensar que todos os PVI têm soluções fechadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Discretização Temporal",
                                  "subSteps": [
                                    "Defina pontos discretos tn = t0 + n h, onde h é o tamanho do passo e n = 0,1,2,...",
                                    "Estabeleça aproximações yn ≈ y(tn) para a solução real.",
                                    "Explique que yn+1 ≈ y(tn + h).",
                                    "Discuta o papel de h: pequeno para precisão, mas custo computacional alto.",
                                    "Esboce os pontos tn no eixo tempo."
                                  ],
                                  "verification": "Marque tn e yn em um gráfico e defina h corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Calculadora para h pequeno"
                                  ],
                                  "tips": "Comece com h=0.1 para visualização fácil.",
                                  "learningObjective": "Dominar a notação de discretização tn e yn.",
                                  "commonMistakes": [
                                    "Confundir tn com yn",
                                    "Esquecer que n inicia em 0",
                                    "Achar h irrelevante"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Aproximação Linear Tangente",
                                  "subSteps": [
                                    "Lembre a expansão de Taylor: y(tn + h) ≈ y(tn) + h y'(tn).",
                                    "Substitua y'(tn) = f(tn, yn), obtendo y(tn + h) ≈ yn + h f(tn, yn).",
                                    "Aproxime yn+1 = yn + h f(tn, yn).",
                                    "Justifique geometricamente: avançar pela tangente da reta em (tn, yn).",
                                    "Verifique com a definição integral de y(tn+1) - y(tn) ≈ h f(tn, yn)."
                                  ],
                                  "verification": "Derive a fórmula yn+1 a partir da Taylor em no máximo 5 linhas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha com derivadas de Taylor",
                                    "Exemplo numérico simples"
                                  ],
                                  "tips": "Visualize a tangente tocando a curva em tn.",
                                  "learningObjective": "Derivar logicamente a iteração do método de Euler.",
                                  "commonMistakes": [
                                    "Usar y'(tn+1) em vez de y'(tn)",
                                    "Esquecer o fator h",
                                    "Confundir com método implícito"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a Fórmula e Explicar Componentes",
                                  "subSteps": [
                                    "Escreva explicitamente: yn+1 = yn + h * f(tn, yn).",
                                    "Explique h: tamanho do passo temporal.",
                                    "Descreva tn: tempo no passo n, tn = t0 + n h.",
                                    "Detalhe yn: aproximação de y(tn).",
                                    "Enuncie o algoritmo completo: inicie com y0, itere até tn final."
                                  ],
                                  "verification": "Escreva a fórmula completa e rotule cada termo corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo",
                                    "Exemplo resolvido manualmente"
                                  ],
                                  "tips": "Rotule setas no gráfico mostrando avanço de yn para yn+1.",
                                  "learningObjective": "Escrever e interpretar todos os elementos da fórmula de Euler.",
                                  "commonMistakes": [
                                    "Escrever yn+1 = yn + f(tn, yn) sem h",
                                    "Trocar tn por yn na função f",
                                    "Ignorar iteração n"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVI y' = y, y(0)=1 com h=0.1: y0=1, t0=0; y1 = 1 + 0.1 * 1 = 1.1; y2 = 1.1 + 0.1 * 1.1 = 1.21. A solução exata é e^t, e^0.1≈1.105, e^0.2≈1.221, mostrando boa aproximação inicial.",
                              "finalVerifications": [
                                "Escreve corretamente yn+1 = yn + h f(tn, yn).",
                                "Explica h como tamanho do passo discreto.",
                                "Identifica tn = t0 + n h e yn ≈ y(tn).",
                                "Deriva a fórmula a partir da Taylor ou tangente.",
                                "Descreve o algoritmo iterativo completo.",
                                "Compara com exemplo numérico simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (sem erros algébricos).",
                                "Clareza na explicação de h, tn e yn.",
                                "Uso correto da notação matemática.",
                                "Compreensão geométrica (tangente).",
                                "Aplicação em exemplo prático sem erros.",
                                "Identificação de limitações (ex: h pequeno necessário)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar iteração em Python ou MATLAB.",
                                "Física: Simular decaimento radioativo ou movimento harmônico.",
                                "Engenharia: Modelagem de circuitos RC.",
                                "Computação Científica: Base para bibliotecas como SciPy.",
                                "Estatística: Aproximações em processos estocásticos."
                              ],
                              "realWorldApplication": "O método de Euler é amplamente usado em simulações numéricas iniciais para modelar dinâmicas em engenharia (ex: trajetórias de foguetes), biologia (crescimento populacional), finanças (modelos de Black-Scholes discretos) e jogos/vídeo (animações físicas em tempo real), servindo como base para métodos mais avançados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Aplicar o Método em Exemplos Simples",
                            "description": "Resolver manualmente um problema de EDO linear simples, como y' = -y, y(0)=1, com h=0.1, calculando os primeiros passos e plotando a aproximação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Problema e Recordar a Fórmula do Método de Euler Explícito",
                                  "subSteps": [
                                    "Escreva a equação diferencial ordinária (EDO): y' = -y, com condição inicial y(0) = 1.",
                                    "Defina o passo de integração h = 0.1 e identifique os pontos iniciais: x0 = 0, y0 = 1.",
                                    "Recorde a fórmula do Método de Euler Explícito: y_{n+1} = y_n + h * f(x_n, y_n), onde f(x, y) = -y.",
                                    "Prepare uma tabela com colunas para n, x_n, y_n e f(x_n, y_n).",
                                    "Verifique se f é independente de x neste caso linear."
                                  ],
                                  "verification": "Confirme que a tabela inicial está preenchida corretamente com x0=0, y0=1, f0=-1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis, borracha, calculadora simples.",
                                  "tips": "Sempre anote a fórmula de Euler no topo da página para referência rápida.",
                                  "learningObjective": "Compreender os componentes essenciais do problema de valor inicial e a iteração de Euler.",
                                  "commonMistakes": "Confundir h com o valor de y inicial ou esquecer que f depende apenas de y."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Primeiro Passo (y1)",
                                  "subSteps": [
                                    "Calcule f(x0, y0) = -y0 = -1.",
                                    "Aplique a fórmula: y1 = y0 + h * f(x0, y0) = 1 + 0.1 * (-1) = 0.9.",
                                    "Atualize x1 = x0 + h = 0.1.",
                                    "Registre na tabela: n=1, x1=0.1, y1=0.9, f1=-0.9.",
                                    "Verifique o cálculo aritmético duas vezes."
                                  ],
                                  "verification": "y1 deve ser exatamente 0.9 e x1=0.1 na tabela.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, calculadora.",
                                  "tips": "Use parênteses na calculadora para evitar erros de precedência: 1 + 0.1 * (-1).",
                                  "learningObjective": "Executar com precisão a primeira iteração do método de Euler.",
                                  "commonMistakes": "Erro de sinal no f (usar +y em vez de -y) ou multiplicar h incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Passos Subsequentes (y2 e y3)",
                                  "subSteps": [
                                    "Para n=1: f(x1, y1) = -0.9, y2 = 0.9 + 0.1 * (-0.9) = 0.81, x2=0.2.",
                                    "Para n=2: f(x2, y2) = -0.81, y3 = 0.81 + 0.1 * (-0.81) = 0.729, x3=0.3.",
                                    "Registre todos os valores na tabela.",
                                    "Calcule pelo menos mais um passo (y4) para prática: y4 ≈ 0.6561, x4=0.4.",
                                    "Observe o padrão de decaimento exponencial aproximado."
                                  ],
                                  "verification": "Valores na tabela: y2=0.81, y3=0.729; todos os cálculos coincidem com a fórmula.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, calculadora.",
                                  "tips": "Mantenha pelo menos 3 casas decimais para precisão, mas arredonde conforme necessário.",
                                  "learningObjective": "Iterar o método de Euler múltiplas vezes com cálculos precisos.",
                                  "commonMistakes": "Perder casas decimais acumulando erros ou errar a atualização de x_n."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar a Aproximação e Analisar",
                                  "subSteps": [
                                    "Marque os eixos: x de 0 a 0.4, y de 0 a 1.",
                                    "Plote os pontos: (0,1), (0.1,0.9), (0.2,0.81), (0.3,0.729), (0.4,0.6561).",
                                    "Conecte os pontos com linhas retas para visualizar a aproximação em escada.",
                                    "Compare visualmente com a solução exata y = e^{-x} (use calculadora ou tabela para pontos exatos).",
                                    "Anote observações sobre o erro de aproximação (ex.: subestima o decaimento)."
                                  ],
                                  "verification": "Gráfico mostra pontos corretos conectados e comentário sobre erro vs. exata.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis de cor, régua, calculadora ou app como Desmos para solução exata.",
                                  "tips": "Escolha escala adequada nos eixos para visualizar o decaimento claramente.",
                                  "learningObjective": "Visualizar e interpretar a aproximação numérica graficamente.",
                                  "commonMistakes": "Escala errada no gráfico ou esquecer de conectar pontos para mostrar a 'escada' de Euler."
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y, y(0)=1 com h=0.05 até x=0.2. Calcule y1=0.90, y2=0.81, y3=0.729 e plote os pontos, comparando com y=e^{-2x}.",
                              "finalVerifications": [
                                "Tabela completa com pelo menos 4 iterações corretas (y1=0.9, y2=0.81, y3=0.729, y4=0.6561).",
                                "Gráfico plotado com pontos precisos e linhas conectadas.",
                                "Identificação correta de f(x,y)=-y e aplicação consistente da fórmula de Euler.",
                                "Comentário sobre o comportamento de decaimento e erro de aproximação.",
                                "Cálculos aritméticos sem erros em todos os passos.",
                                "Solução exata referenciada para comparação (y=e^{-x})."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos numéricos (erro <0.01 por passo).",
                                "Correta formulação e uso da iteração de Euler.",
                                "Qualidade do gráfico: escalas apropriadas, pontos marcados e conectados.",
                                "Análise qualitativa do erro e comportamento da aproximação.",
                                "Organização da tabela e documentação clara.",
                                "Tempo de execução dentro do estimado com compreensão demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar o método em Python ou MATLAB para automação.",
                                "Física: Modelagem de decaimento radioativo ou resfriamento de Newton.",
                                "Engenharia: Simulações numéricas em circuitos RC ou sistemas dinâmicos.",
                                "Estatística: Análise de erros de truncamento em métodos numéricos."
                              ],
                              "realWorldApplication": "Usado em simulações de populações biológicas em declínio, previsão de temperaturas em processos industriais, modelagem financeira de depreciação de ativos e software de engenharia como MATLAB Simulink para protótipos rápidos de sistemas dinâmicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Derivação via Expansão de Taylor",
                        "description": "Explica a base teórica do método utilizando a expansão em série de Taylor de primeira ordem para justificar a precisão local de ordem O(h²).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Realizar Expansão de Taylor para y(tn+1)",
                            "description": "Aplicar a expansão de Taylor y(tn + h) = y(tn) + h y'(tn) + (h²/2) y''(ξ), truncando após o primeiro termo e substituindo y' = f para obter a fórmula de Euler.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar a expansão de Taylor geral para funções diferenciáveis",
                                  "subSteps": [
                                    "Defina y(t) como uma função suficientemente suave (pelo menos C²) em um intervalo ao redor de tn.",
                                    "Escreva a fórmula da expansão de Taylor de ordem 2 ao redor de tn: y(tn + h) = y(tn) + h y'(tn) + (h²/2) y''(tn) + R₂(tn + h), onde R é o resto.",
                                    "Identifique que para aproximações de baixa ordem, truncamos após o termo linear.",
                                    "Lembre-se da notação de Lagrange para o resto: (h²/2) y''(ξ) com ξ ∈ (tn, tn+h).",
                                    "Verifique a expansão para uma função simples como e^x para validar compreensão."
                                  ],
                                  "verification": "Escreva corretamente a expansão com os três primeiros termos e o resto, sem erros na fatoração ou derivadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de cálculo ou análise numérica (capítulo de séries de Taylor)",
                                    "Calculadora para exemplos numéricos opcionais"
                                  ],
                                  "tips": [
                                    "Use a expansão conhecida de funções elementares para memorizar o padrão.",
                                    "Sempre inclua o resto para entender o erro de truncagem.",
                                    "Anote ξ para enfatizar que é desconhecido."
                                  ],
                                  "learningObjective": "Compreender a estrutura fundamental da expansão de Taylor e seu uso em aproximações locais.",
                                  "commonMistakes": [
                                    "Esquecer o fatorial 2! no termo quadrático.",
                                    "Confundir y'(tn) com y(tn + h).",
                                    "Ignorar o resto da série, subestimando o erro."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a expansão de Taylor ao contexto do problema de valor inicial (PVI)",
                                  "subSteps": [
                                    "Dado o PVI y' = f(t, y), y(t₀) = y₀, considere o passo de tn para tn + h.",
                                    "Substitua na expansão: y(tn + h) = y(tn) + h y'(tn) + (h²/2) y''(ξ).",
                                    "Reconheça que y'(tn) = f(tn, y(tn)), pois vem da equação diferencial.",
                                    "Mantenha o termo quadrático com y''(ξ) para mostrar a aproximação.",
                                    "Discuta por que y''(ξ) depende de f e suas derivadas parciais."
                                  ],
                                  "verification": "Escreva a expansão com y'(tn) explicitamente substituído por f(tn, y(tn)), confirmando a ligação com o PVI.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de PVI anotado (ex: y' = y, y(0)=1)",
                                    "Quadro branco ou software como GeoGebra para visualização"
                                  ],
                                  "tips": [
                                    "Desenhe o gráfico de y(t) e marque tn, tn+h para visualizar a aproximação local.",
                                    "Diferencie f(t,y) se necessário para entender y''.",
                                    "Sempre especifique o ponto de expansão: ao redor de tn."
                                  ],
                                  "learningObjective": "Conectar a expansão de Taylor ao modelo diferencial y' = f(t,y).",
                                  "commonMistakes": [
                                    "Substituir y'(tn + h) em vez de y'(tn).",
                                    "Tratar f como função apenas de t, ignorando y.",
                                    "Escrever h y(tn) em vez de h y'(tn)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Truncar a expansão após o primeiro termo e analisar o erro",
                                  "subSteps": [
                                    "Trunque a série após o termo linear: y(tn + h) ≈ y(tn) + h y'(tn).",
                                    "Substitua y'(tn) = f(tn, y(tn)) para obter y(tn + h) ≈ y(tn) + h f(tn, y(tn)).",
                                    "Identifique o erro de truncagem como O(h²), dado pelo resto (h²/2) y''(ξ).",
                                    "Discuta que essa é uma aproximação de ordem 1, válida para h pequeno.",
                                    "Calcule o erro para um exemplo simples para quantificar."
                                  ],
                                  "verification": "Derive a aproximação truncada e anote explicitamente o erro local O(h²).",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo numérico resolvido analiticamente",
                                    "Software como Python/MATLAB para plotar aproximação vs. exata (opcional)"
                                  ],
                                  "tips": [
                                    "Pense no erro como o termo descartado; menor h reduz o erro quadráticamente.",
                                    "Teste com h=0.1 vs. h=0.01 para ver convergência.",
                                    "Use notação big-O para formalizar."
                                  ],
                                  "learningObjective": "Dominar a truncagem e quantificação do erro na derivação do método de Euler.",
                                  "commonMistakes": [
                                    "Truncar após o termo constante, perdendo a dinâmica.",
                                    "Escrever O(h) em vez de O(h²) para o erro.",
                                    "Substituir y'' por f incorretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a fórmula do método de Euler explícito",
                                  "subSteps": [
                                    "Denote y(tn) ≈ yn (aproximação numérica).",
                                    "Escreva yn+1 = yn + h f(tn, yn).",
                                    "Confirme que isso é a discretização do PVI via Taylor truncada.",
                                    "Discuta limitações: explícito (não iterativo), ordem 1, instável para h grande.",
                                    "Compare com solução exata em um exemplo para validar."
                                  ],
                                  "verification": "Escreva a iteração de Euler e execute um passo manual com valores numéricos.",
                                  "estimatedTime": "13 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela para iterações numéricas",
                                    "Planilha Excel ou Python para simulação rápida"
                                  ],
                                  "tips": [
                                    "Sempre inicialize com y0 exato.",
                                    "Escolha h pequeno para boa aproximação inicial.",
                                    "Registre tn, yn, f, yn+1 em tabela."
                                  ],
                                  "learningObjective": "Concluir a derivação ligando Taylor à implementação numérica do Euler.",
                                  "commonMistakes": [
                                    "Usar f(tn+1, yn) (isso seria implícito).",
                                    "Confundir yn+1 com y(tn+1) exata.",
                                    "Ignorar dependência em h no erro."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVI y' = -2y, y(0) = 1 (solução exata y(t) = e^{-2t}), com h=0.1 e tn=0:\n1. Expansão: y(0.1) = 1 + 0.1*(-2*1) + (0.1²/2) y''(ξ) = 1 - 0.2 + 0.005 y''(ξ) ≈ 0.8.\n2. Euler: y1 = 1 + 0.1*(-2*1) = 0.8.\nExata: y(0.1) ≈ 0.8187, erro ≈ 0.0187 (consistente com O(h²)=0.005).",
                              "finalVerifications": [
                                "Expansão de Taylor escrita corretamente com termos até quadrático e resto.",
                                "Substituição precisa de y'(tn) = f(tn, y(tn)).",
                                "Truncagem após termo linear resulta em yn+1 = yn + h f(tn, yn).",
                                "Erro local identificado como O(h²).",
                                "Exemplo numérico executado com valores corretos.",
                                "Diferença entre aproximação e exata discutida."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na expansão (100% dos termos corretos).",
                                "Correta identificação e truncagem dos termos.",
                                "Substituição adequada de derivadas pela função f.",
                                "Análise qualitativa/quantitativa do erro de truncagem.",
                                "Clareza na derivação da fórmula de Euler.",
                                "Execução correta de um passo numérico exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aproximações em equações diferenciais para movimento (ex: leis de Newton discretizadas).",
                                "Computação: Implementação de solvers numéricos em Python (biblioteca SciPy odeint baseia-se em ideias similares).",
                                "Engenharia: Simulações de circuitos RC via Euler em software como MATLAB Simulink.",
                                "Economia: Modelos dinâmicos discretos para previsão financeira."
                              ],
                              "realWorldApplication": "A derivação via Taylor é fundamental para entender e implementar métodos numéricos em simulações científicas, como previsão de epidemias (modelos SIR), trajetórias espaciais (NASA orbitais), modelagem climática e finanças (Black-Scholes discretizado), onde passos pequenos h garantem precisão em soluções não analíticas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Calcular o Termo de Erro Local",
                            "description": "Identificar e estimar o erro local de truncamento como O(h²), expressando-o em termos da derivada segunda y''(ξ) e discutir sua dependência em h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Expansão de Taylor da Solução Exata",
                                  "subSteps": [
                                    "Lembre-se da equação diferencial y' = f(x, y) com y(x_n) conhecido.",
                                    "Aplique a expansão de Taylor para y(x_{n+1}) em torno de x_n até a segunda ordem.",
                                    "Escreva y(x_{n+1}) = y(x_n) + h y'(x_n) + (h²/2) y''(ξ) para algum ξ ∈ (x_n, x_{n+1}).",
                                    "Identifique y'(x_n) = f(x_n, y(x_n)) e y''(x) em termos de f.",
                                    "Anote a dependência do termo de segunda ordem em h²."
                                  ],
                                  "verification": "Escreva a expansão de Taylor completa e destaque o termo de segunda ordem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software como Mathematica/MATLAB",
                                    "Notas da aula sobre séries de Taylor"
                                  ],
                                  "tips": "Comece sempre pela solução exata y(x) e expanda em torno do ponto atual x_n.",
                                  "learningObjective": "Compreender a base analítica da solução exata via Taylor.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/2 no termo h²",
                                    "Confundir y'(ξ) com y'(x_n)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Aproximação do Método de Euler Explícito",
                                  "subSteps": [
                                    "Escreva a iteração do Euler: y_{n+1} = y_n + h f(x_n, y_n).",
                                    "Note que y_n ≈ y(x_n), então y'(x_n) ≈ f(x_n, y_n).",
                                    "Observe que o Euler usa apenas o primeiro termo da Taylor: y(x_n) + h y'(x_n).",
                                    "Compare visualmente com a Taylor completa do passo 1.",
                                    "Registre que não há termo h² na aproximação de Euler."
                                  ],
                                  "verification": "Escreva a fórmula de Euler e confirme que ela corresponde ao truncamento após o termo linear.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "Exemplo simples como y' = y"
                                  ],
                                  "tips": "Pense no Euler como 'Taylor de primeira ordem' para memorizar.",
                                  "learningObjective": "Reconhecer a aproximação de baixa ordem do método de Euler.",
                                  "commonMistakes": [
                                    "Usar y_{n+1} em vez de y(x_{n+1}) na comparação",
                                    "Incluir termos extras na fórmula de Euler"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Termo de Erro Local Subtraindo as Expansões",
                                  "subSteps": [
                                    "Subtraia a aproximação de Euler da solução exata: e_{n+1} = y(x_{n+1}) - y_{n+1}.",
                                    "Substitua as expressões: e_{n+1} = [y(x_n) + h y'(x_n) + (h²/2) y''(ξ)] - [y_n + h f(x_n, y_n)].",
                                    "Assuma y_n = y(x_n) para erro local (ignorando erro propagado).",
                                    "Simplifique para e_{n+1} ≈ (h²/2) y''(ξ), onde ξ está no intervalo.",
                                    "Expresse y''(ξ) em termos de derivadas parciais de f se necessário."
                                  ],
                                  "verification": "Derive a expressão exata do erro local e isole o termo dominante.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou papel para álgebra",
                                    "Tabela de derivadas de f"
                                  ],
                                  "tips": "Use ≈ para indicar truncamento e foque no termo principal.",
                                  "learningObjective": "Derivar matematicamente o erro local de truncamento.",
                                  "commonMistakes": [
                                    "Não cancelar corretamente os termos y(x_n) + h y'(x_n)",
                                    "Esquecer o intervalo para ξ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a Ordem do Erro e Dependência em h",
                                  "subSteps": [
                                    "Identifique o termo dominante: (h²/2) y''(ξ) é proporcional a h².",
                                    "Conclua que o erro local é O(h²) à medida que h → 0.",
                                    "Discuta como y''(ξ) depende da suavidade da solução y(x).",
                                    "Explique qualitativamente: h menor reduz erro quadraticamente.",
                                    "Compare com erro global (O(h)) para contexto."
                                  ],
                                  "verification": "Escreva 'Erro local = O(h²)' e justifique com limite h→0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico de erro vs. h (plotar em Python/MATLAB)",
                                    "Exercícios de análise assintótica"
                                  ],
                                  "tips": "Use notação Big-O corretamente: f(h) = O(h²) se |f(h)| ≤ C h² para h pequeno.",
                                  "learningObjective": "Interpretar a ordem de convergência e implicações práticas.",
                                  "commonMistakes": [
                                    "Confundir erro local O(h²) com global O(h)",
                                    "Ignorar dependência em y''(ξ)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1 (solução y=e^x), com h=0.1, x_0=0: y(0.1) ≈ 1 + 0.1*1 + (0.1²/2)*e^ξ ≈ 1.105170, Euler dá 1.1, erro local ≈ 0.00517 ≈ (0.005)*e^ξ, confirmando O(h²).",
                              "finalVerifications": [
                                "Deriva corretamente y(x_{n+1}) via Taylor até h².",
                                "Isola o termo de erro como (h²/2) y''(ξ).",
                                "Identifica O(h²) como ordem do erro local.",
                                "Explica dependência em h e suavidade de y.",
                                "Aplica a um exemplo numérico simples.",
                                "Discute limitações se y'' não for limitada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da Taylor (sem erros algébricos).",
                                "Correta identificação do termo truncado dominante.",
                                "Uso apropriado de notação O(h²) e ξ.",
                                "Explicação clara da dependência em h (quadrático).",
                                "Integração de y''(ξ) à discussão qualitativa.",
                                "Exemplo prático computado corretamente."
                              ],
                              "crossCurricularConnections": [
                                "Física: Erros em simulações de movimento (ex: Euler em dinâmica).",
                                "Programação: Implementar Euler em Python e testar convergência O(h²).",
                                "Estatística: Análise de erro em aproximações numéricas de modelos probabilísticos.",
                                "Engenharia: Validação de solvers em CAD/FEM."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias espaciais (NASA usa Euler modificado), previsão de epidemias (modelos SIR), ou finanças (simulação de caminhos de preços de ações), onde estimar O(h²) guia escolha de h para precisão sem custo computacional excessivo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Análise de Precisão e Estabilidade",
                        "description": "Analisa o erro global de ordem O(h), condições de estabilidade absoluta e introduz limitações para problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Determinar o Erro Global de Ordem O(h)",
                            "description": "Explicar como o erro local O(h²) acumula ao longo de N passos para resultar em erro global O(h), usando análise telescópica ou soma de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Erro Local de Truncamento no Método de Euler Explícito",
                                  "subSteps": [
                                    "Lembre a fórmula do método de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Derive o erro local usando expansão de Taylor: y(t_{n+1}) = y(t_n) + h y'(t_n) + (h²/2) y''(ξ_n).",
                                    "Identifique o termo de erro local: τ_n = (h²/2) y''(ξ_n), que é O(h²).",
                                    "Escreva a equação exata: y(t_{n+1}) = y(t_n) + h f(t_n, y(t_n)) + h² τ_n.",
                                    "Confirme que o erro local por passo é proporcional a h²."
                                  ],
                                  "verification": "Escreva a expansão de Taylor e destaque o termo O(h²); compare com a aproximação de Euler.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica (cap. Euler), papel e caneta ou software como Mathematica para Taylor.",
                                  "tips": "Visualize graficamente a tangente vs. curva real para um passo.",
                                  "learningObjective": "Compreender que o erro introduzido em um único passo é O(h²).",
                                  "commonMistakes": "Confundir erro local com global; esquecer o ponto intermediário ξ_n na Taylor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a Acumulação de Erros ao Longo de Múltiplos Passos",
                                  "subSteps": [
                                    "Defina o erro global e_n = y(t_n) - y_n, onde t_n = n h e N h = T fixo, assim N = T/h.",
                                    "Expresse a recursão do erro: e_{n+1} = e_n + h [f(t_n, y(t_n)) - f(t_n, y_n)] + h² τ_n.",
                                    "Aproxime f(t_n, y(t_n)) - f(t_n, y_n) ≈ f_y(t_n, y(t_n)) e_n, assumindo Lipschitz.",
                                    "Some os erros de um passo inicial ao n-ésimo: e_n ≈ soma_{k=0}^{n-1} h² τ_k + termos de propagação.",
                                    "Reconheça que erros locais se somam linearmente em N termos."
                                  ],
                                  "verification": "Escreva a recursão de e_{n+1} e identifique os termos de truncamento acumulados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de cálculo para simular erros, referência sobre condições de Lipschitz.",
                                  "tips": "Pense nos erros como 'débitos' que se propagam e acumulam a cada passo.",
                                  "learningObjective": "Modelar como erros locais se propagam e acumulam em uma malha com N = T/h passos.",
                                  "commonMistakes": "Ignorar a propagação via derivada parcial f_y; assumir erros não interagem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Análise Telescópica para Derivar o Erro Global",
                                  "subSteps": [
                                    "Escreva a soma telescópica exata: y(t_n) - y_0 = soma_{k=0}^{n-1} [y(t_{k+1}) - y(t_k)].",
                                    "Substitua as aproximações de Euler: y_n - y_0 = soma_{k=0}^{n-1} h f(t_k, y_k).",
                                    "Subtraia para obter e_n = soma_{k=0}^{n-1} { [y(t_{k+1}) - y(t_k)] - h f(t_k, y_k) }.",
                                    "Simplifique cada termo: = soma_{k=0}^{n-1} h² τ_k + termos de erro local ajustados.",
                                    "Majorize |e_n| ≤ (h/2) max |y''| n h = (T/2) h max |y''|, assumindo y'' limitada."
                                  ],
                                  "verification": "Derive explicitamente e_n ≤ C h para algum C > 0, mostrando O(h).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Quadro branco ou LaTeX para somas telescópicas, exemplo numérico simples.",
                                  "tips": "Use desigualdades como |soma τ_k| ≤ n max|τ_k| e n h = T.",
                                  "learningObjective": "Usar telescoping para provar que soma de N termos O(h²) dá O(h) pois N ~ 1/h.",
                                  "commonMistakes": "Esquecer que n = T/h, tornando N h² = T h = O(h); confundir somas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e Verificar a Ordem do Erro Global O(h)",
                                  "subSteps": [
                                    "Resuma: erro global |e_N| ≤ M T h / 2 = O(h), onde M = max |y''|.",
                                    "Discuta condições: solução suave (y'' contínua), h pequeno, estabilidade.",
                                    "Compare com ordem local: perda de ordem devido à acumulação (1 vs 2).",
                                    "Teste numericamente: implemente Euler para y' = λ y e plote erro vs h.",
                                    "Generalize para métodos de ordem p: erro global O(h^p)."
                                  ],
                                  "verification": "Plote log(erro) vs log(h) com slope ≈1 confirmando ordem 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python/MATLAB para simulação, gráfico log-log.",
                                  "tips": "Use equação modelo y' = -y para ver decay exponencial afetando erros.",
                                  "learningObjective": "Confirmar analiticamente e numericamente que erro global é O(h).",
                                  "commonMistakes": "Atribuir ordem errada sem considerar N ~ 1/h; ignorar constantes."
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, T=1, implemente Euler com h=0.1, 0.05, etc. Calcule erro em t=1: |y(1)-y_N| ≈ e^{-1} - y_N. Some erros locais manualmente para h=0.1 (N=10 passos), cada τ_k ≈ (h²/2)(-e^{-ξ}), total ≈ 0.1 * const, mostrando O(h).",
                              "finalVerifications": [
                                "Deriva corretamente a recursão de erro e_{n+1} incluindo termo O(h²).",
                                "Aplica soma telescópica para expressar e_n como soma de erros locais.",
                                "Majoriza |e_n| ≤ C h com C explícito em termos de max|y''| e T.",
                                "Explica por que N * O(h²) = O(h) com N=T/h.",
                                "Valida numericamente com plot log-log slope=1.",
                                "Discute condições necessárias (suavidade, Lipschitz)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor e identificação de O(h²) local (30%).",
                                "Correta modelagem da acumulação e uso de telescoping (30%).",
                                "Análise assintótica clara mostrando O(h) global (20%).",
                                "Exemplo numérico ou gráfico de verificação (10%).",
                                "Explicação de condições e generalizações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Euler em Python para validar erros.",
                                "Física: Simulações de movimento (ex: queda livre com Euler).",
                                "Estatística: Análise de erro em métodos Monte Carlo.",
                                "Engenharia: Modelagem diferencial em controle de sistemas."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou financeiras (ex: Black-Scholes PDE via Euler), entender O(h) guia escolha de h para precisão vs custo computacional; em CFD (dinâmica de fluidos computacional), analisa trade-off em malhas grosseiras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Analisar Estabilidade Absoluta",
                            "description": "Para EDOs lineares y' = λ y, derivar a condição |1 + h λ| ≤ 1 para estabilidade e identificar a região de estabilidade no plano complexo hλ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Euler Explícito para EDOs Lineares de Teste",
                                  "subSteps": [
                                    "Lembre a forma geral da EDO linear de teste: y' = λ y, com solução exata y(t) = y(0) e^{λ t}.",
                                    "Escreva a iteração do método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n) = y_n (1 + h λ).",
                                    "Calcule a solução numérica após N passos: y_N = y_0 (1 + h λ)^N.",
                                    "Discuta a relação com a solução exata, considerando h N = T fixo.",
                                    "Identifique o fator de amplificação r = 1 + h λ."
                                  ],
                                  "verification": "Escreva corretamente a iteração de Euler e o fator de amplificação r para y' = λ y.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora ou software como Python/Jupyter para testes rápidos"
                                  ],
                                  "tips": "Sempre normalize o tempo total T = N h para comparar estabilidade.",
                                  "learningObjective": "Compreender a aplicação do método de Euler ao modelo de teste linear.",
                                  "commonMistakes": [
                                    "Confundir Euler explícito com implícito",
                                    "Esquecer que λ pode ser complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Condição de Estabilidade Absoluta",
                                  "subSteps": [
                                    "Para estabilidade, exija que |y_N| permaneça limitada quando N → ∞ com h fixo, ou |r| ≤ 1.",
                                    "Substitua r = 1 + h λ, obtendo |1 + h λ| ≤ 1.",
                                    "Explique que isso garante que o erro numérico não cresça exponencialmente.",
                                    "Discuta estabilidade absoluta como independência do y_0 e condições iniciais.",
                                    "Verifique para λ real negativo: h ≤ 2 / |λ|."
                                  ],
                                  "verification": "Derive e escreva a condição |1 + h λ| ≤ 1 a partir da iteração de Euler.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para derivação",
                                    "Livro de Análise Numérica (opcional)"
                                  ],
                                  "tips": "Use a definição de norma no plano complexo: |z| = √(Re(z)^2 + Im(z)^2).",
                                  "learningObjective": "Derivar matematicamente a condição de estabilidade para Euler explícito.",
                                  "commonMistakes": [
                                    "Confundir |r| < 1 (assintótica) com ≤ 1",
                                    "Ignorar o caso λ = 0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Região de Estabilidade no Plano Complexo hλ",
                                  "subSteps": [
                                    "Defina z = h λ no plano complexo, com eixo real horizontal e imaginário vertical.",
                                    "Resolva |1 + z| ≤ 1: isso é o disco unitário centrado em -1 + 0i com raio 1.",
                                    "Desenhe o círculo: centro em (-1, 0), passando por (0,0) e (-2,0).",
                                    "Identifique que o semi-eixo real negativo está dentro (-2, 0), mas imaginário é limitado.",
                                    "Compare com o semi-plano esquerdo Re(λ) < 0 da estabilidade exata."
                                  ],
                                  "verification": "Esboce o disco de estabilidade e marque pontos dentro/fora.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem como Desmos, GeoGebra ou Python (matplotlib)",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Teste pontos: z = -1 (dentro), z = i (fora, pois |1+i| = √2 >1).",
                                  "learningObjective": "Interpretar geometricamente a condição no plano z = hλ.",
                                  "commonMistakes": [
                                    "Desenhar círculo centrado em 0",
                                    "Confundir com região de Runge-Kutta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar a Análise de Estabilidade",
                                  "subSteps": [
                                    "Escolha λ com parte real negativa e teste vários h até violar |1 + hλ| ≤1.",
                                    "Simule numericamente em software para observar divergência.",
                                    "Discuta implicações: Euler explícito instável para problemas rígidos ou oscilatórios.",
                                    "Compare com métodos implicitivos que têm regiões maiores.",
                                    "Resuma limitações para hλ no disco unitário."
                                  ],
                                  "verification": "Para um λ dado, encontre o h máximo para estabilidade e simule.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python ou MATLAB com script simples de Euler",
                                    "Exemplos de EDOs como y' = -100 y + sin(t)"
                                  ],
                                  "tips": "Use scripts reutilizáveis para plots de solução numérica vs exata.",
                                  "learningObjective": "Aplicar a análise para prever comportamento numérico.",
                                  "commonMistakes": [
                                    "Escolher h muito grande sem checar |1+hλ|",
                                    "Ignorar oscilações complexas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere y' = (-1 + 10i) y, λ = -1 + 10i (oscilador amortecido). Para h=0.05, z = hλ ≈ -0.05 + 0.5i, |1+z| ≈ |0.95 + 0.5i| ≈ 1.07 >1 (instável: solução numérica oscila e cresce). Reduza h para 0.01, z≈ -0.01 + 0.1i, |1+z|≈1.005 ≤1 (estável). Simule em Python para visualizar.",
                              "finalVerifications": [
                                "Deriva corretamente |1 + hλ| ≤1 a partir da iteração de Euler.",
                                "Desenha com precisão o disco unitário centrado em -1 no plano hλ.",
                                "Identifica corretamente se um dado hλ está dentro da região de estabilidade.",
                                "Explica a diferença entre estabilidade absoluta e estabilidade exata.",
                                "Simula um exemplo numérico mostrando instabilidade fora da região.",
                                "Discute limitações do Euler explícito para problemas rígidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da condição de estabilidade (correta e completa).",
                                "Correção geométrica da região de estabilidade no plano complexo.",
                                "Qualidade do esboço ou plot da região (centro, raio, limites reais).",
                                "Análise correta de exemplos numéricos (estável/instável).",
                                "Explicação clara das implicações para escolha de h.",
                                "Uso apropriado de terminologia (fator de amplificação, disco unitário)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de equações diferenciais de movimento (e.g., amortecedores).",
                                "Engenharia Computacional: Análise de métodos numéricos em CFD ou controle de sistemas.",
                                "Programação: Implementação e teste de solvers ODE em Python/Scipy.",
                                "Matemática Pura: Análise complexa e geometria no plano complexo.",
                                "Finanças: Modelagem de processos estocásticos e estabilidade em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD) ou circuitos elétricos rígidos, a análise de estabilidade guia a escolha de h para evitar explosões numéricas em software como ANSYS ou COMSOL, garantindo previsões confiáveis em engenharia aeroespacial e automotiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Implementar e Testar Estabilidade Numericamente",
                            "description": "Implementar o método em Python ou MATLAB para y' = -100 y, variando h, e observar oscilações ou divergência quando h > 0.02, relacionando com problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente e Definir o Problema",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: numpy e matplotlib via pip.",
                                    "Defina os parâmetros iniciais: y0 = 1, t_final = 0.1, e uma função f(t,y) = -100*y.",
                                    "Escreva uma função para a solução exata: y_exact(t) = y0 * exp(-100*t).",
                                    "Crie uma lista de valores de h para testar: [0.001, 0.01, 0.02, 0.03, 0.05].",
                                    "Planeje os intervalos de tempo para cada h: n_steps = int(t_final / h)."
                                  ],
                                  "verification": "Verifique se as bibliotecas importam sem erros e as funções definidas retornam valores esperados (ex: f(0,1) == -100).",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Use Jupyter Notebook para visualização interativa dos resultados.",
                                  "learningObjective": "Configurar corretamente o ambiente de simulação numérica para problemas de EDOs.",
                                  "commonMistakes": [
                                    "Esquecer de importar bibliotecas",
                                    "Definir y0 incorreto (deve ser positivo)",
                                    "Usar h muito pequeno sem considerar tempo de computação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método de Euler Explícito",
                                  "subSteps": [
                                    "Escreva a função euler_step(y_n, h, f): return y_n + h * f(t_n, y_n).",
                                    "Crie a função principal solve_euler(h, t_final, y0, f): inicialize t e y arrays, loop de n_steps aplicando euler_step.",
                                    "Atualize t_n = t_n + h em cada iteração e armazene y_n.",
                                    "Retorne arrays de t e y aproximados.",
                                    "Teste com h=0.01: compare y_final com y_exact(t_final) ≈ 3.7e-5."
                                  ],
                                  "verification": "Execute para h=0.01 e confirme que y decai monotonicamente sem oscilações iniciais.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Código Python preparado no Step 1"
                                  ],
                                  "tips": "Mantenha variáveis escalares para eficiência; evite vetores desnecessários.",
                                  "learningObjective": "Implementar o algoritmo de Euler Explícito de forma funcional e reutilizável.",
                                  "commonMistakes": [
                                    "Erro no update: usar y_{n+1} = y_n + h*f(y_n) sem t correto",
                                    "Loop infinito por h=0",
                                    "Não inicializar arrays com tamanho correto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Simulações Variando h",
                                  "subSteps": [
                                    "Crie um dicionário ou lista para armazenar resultados: para cada h na lista, chame solve_euler.",
                                    "Execute simulações para h <=0.02 e h>0.02 separadamente.",
                                    "Registre métricas: y_final, número de steps, detecção de oscilação (sin(y) >0 após decaimento).",
                                    "Salve resultados em um DataFrame pandas para análise.",
                                    "Gere plots iniciais: y vs t para cada h, comparando com exata."
                                  ],
                                  "verification": "Confirme que para h=0.03, y oscila ou cresce em magnitude.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Pandas (opcional para tabelas)",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Use plt.semilogy para visualizar decaimento exponencial claramente.",
                                  "learningObjective": "Realizar experimentos numéricos controlados variando parâmetros chave.",
                                  "commonMistakes": [
                                    "h muito grande causando overflow imediato",
                                    "Não normalizar plots para comparar escalas",
                                    "Ignorar t_final fixo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Relacionar com Estabilidade",
                                  "subSteps": [
                                    "Compare soluções numéricas com exata: calcule erro max |y_num - y_exact|.",
                                    "Identifique threshold: h_crit ≈0.02 onde |1-100h|=1.",
                                    "Observe fenômenos: oscilações (h>0.02), divergência (h>>0.02).",
                                    "Discuta stiff: razão de escalas de tempo (eigenvalue λ=-100 requer h<2/|λ|).",
                                    "Documente conclusões em relatório ou comentários no código."
                                  ],
                                  "verification": "Explique por que Euler falha para h>0.02 e sugira métodos implícitos.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Plots gerados",
                                    "Solução exata"
                                  ],
                                  "tips": "Amplie eixo y em log para ver oscilações claramente.",
                                  "learningObjective": "Interpretar numericamente conceitos de estabilidade e rigidez em EDOs.",
                                  "commonMistakes": [
                                    "Confundir precisão com estabilidade",
                                    "Atribuir falha só a h grande sem região |1+λh|<1",
                                    "Ignorar contexto stiff"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y'=-100y, y(0)=1, t em [0,0.1]: Com h=0.01, y decai suavemente para ~4e-5; com h=0.03, após ~20 steps, y oscila entre positivo/negativo crescendo em amplitude, divergindo de y_exact≈3.7e-5. Plot: linha suave para h pequeno, ondulada explosiva para h=0.03.",
                              "finalVerifications": [
                                "Código implementa Euler corretamente e roda para múltiplos h sem erros.",
                                "Plots mostram estabilidade para h<=0.02 e instabilidade para h>0.02.",
                                "Erro relativo <1e-3 para h=0.01 vs exata.",
                                "Identifica h_crit=0.02 baseado em |1-100h|<1.",
                                "Relaciona observações a problemas stiff corretamente.",
                                "Relatório resume achados com prints/plots salvos."
                              ],
                              "assessmentCriteria": [
                                "Correção da implementação de Euler (20%)",
                                "Qualidade dos experimentos variando h (20%)",
                                "Precisão dos plots e análises visuais (20%)",
                                "Interpretação teórica de estabilidade (20%)",
                                "Conexão com stiff problems e sugestões de melhoria (10%)",
                                "Clareza do código e documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação de algoritmos numéricos em Python.",
                                "Física: Modelagem de decaimento exponencial em sistemas dinâmicos.",
                                "Engenharia: Simulações de sistemas stiff em controle e química.",
                                "Estatística: Análise de erros numéricos e convergência.",
                                "Matemática Aplicada: Análise de estabilidade linear."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas stiff (ex: combustão), onde escalas rápidas/lentas coexistem, testar estabilidade garante precisão sem h excessivamente pequeno, otimizando tempo computacional em software como COMSOL ou CFD."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.4",
                            "name": "Comparar com Solução Exata",
                            "description": "Calcular erro numérico absoluto para um exemplo analítico, plotando erro vs. h em escala log-log para verificar ordem de convergência 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Problema de Valor Inicial e Solução Exata",
                                  "subSteps": [
                                    "Escolha um PVI simples com solução analítica conhecida, como y' = -y, y(0) = 1, onde y(t) = e^{-t}.",
                                    "Defina o intervalo de integração, ex: t de 0 a 1.",
                                    "Escreva a fórmula exata da solução em pontos discretos t_i = i*h.",
                                    "Prepare uma função para calcular y_exata(t).",
                                    "Teste a função exata em alguns pontos para validar."
                                  ],
                                  "verification": "Função y_exata(t) retorna valores corretos, ex: y(1) ≈ 0.3679.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (Python), calculadora ou papel para validação manual.",
                                  "tips": "Use problemas clássicos para evitar erros na solução exata.",
                                  "learningObjective": "Entender a importância de uma referência analítica precisa.",
                                  "commonMistakes": "Escolher PVI sem solução fechada ou errar a fórmula exata."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método de Euler Explícito para Diferentes Passos h",
                                  "subSteps": [
                                    "Defina uma lista de h decrescentes, ex: [0.1, 0.05, 0.025, 0.0125, 0.00625].",
                                    "Implemente a iteração de Euler: y_{n+1} = y_n + h*f(t_n, y_n).",
                                    "Para cada h, compute a solução numérica até t=1, armazenando y_num em um array.",
                                    "Garanta que o número de passos N = 1/h seja inteiro.",
                                    "Salve os valores finais y_num(1) ou em pontos equidistantes."
                                  ],
                                  "verification": "Para h=0.1, y_num(1) deve aproximar 0.3679 com erro razoável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy para arrays e loops.",
                                  "tips": "Vetorize onde possível, mas entenda o loop para Euler.",
                                  "learningObjective": "Implementar corretamente o método numérico para múltiplas resoluções.",
                                  "commonMistakes": "Confundir f(t,y) ou usar h errado no passo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Erro Numérico Absoluto",
                                  "subSteps": [
                                    "Para cada h, compute erro = |y_exata(1) - y_num(1)| ou máximo em malha.",
                                    "Registre pares (h, erro) em listas ou arrays.",
                                    "Calcule log10(h) e log10(erro) para cada par.",
                                    "Verifique se erros diminuem com h menor.",
                                    "Armazene em estrutura de dados para plotting."
                                  ],
                                  "verification": "Erros devem decrescer monotonicamente com h reduzido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "NumPy para abs() e log10().",
                                  "tips": "Use erro máximo na malha para precisão global.",
                                  "learningObjective": "Quantificar a precisão numérica via erro absoluto.",
                                  "commonMistakes": "Usar erro relativo em vez de absoluto ou pontos errados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar Erro vs. h em Escala Log-Log e Analisar Convergência",
                                  "subSteps": [
                                    "Use Matplotlib para plotar log10(erro) vs. log10(h) com escala log-log.",
                                    "Adicione linha de referência com inclinação -1 (ordem 1).",
                                    "Ajuste linearmente para estimar a ordem p ≈ -inclinação.",
                                    "Confirme que p ≈ 1 para Euler.",
                                    "Anote observações sobre convergência."
                                  ],
                                  "verification": "Gráfico mostra reta com inclinação ≈ -1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matplotlib e SciPy para ajuste linear opcional.",
                                  "tips": "Use plt.loglog() para escalas automáticas.",
                                  "learningObjective": "Visualizar e confirmar ordem de convergência teórica.",
                                  "commonMistakes": "Plotar sem log ou confundir eixos (h no x, erro no y)."
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1 em [0,1], com h=[0.1,0.05,...,0.00625], o gráfico log-log deve mostrar inclinação -1, confirmando ordem 1 do Euler.",
                              "finalVerifications": [
                                "Erro absoluto diminui com h.",
                                "Gráfico log-log é linear com inclinação ≈ -1.",
                                "Ordem estimada p = 1 ± 0.1.",
                                "Solução numérica converge para exata.",
                                "Código roda sem erros para todos h.",
                                "Valores de erro consistentes com teoria."
                              ],
                              "assessmentCriteria": [
                                "Correção da implementação de Euler (sem bugs).",
                                "Cálculo preciso de erros absolutos.",
                                "Gráfico log-log claro e rotulado.",
                                "Análise correta da ordem de convergência.",
                                "Uso apropriado de escalas logarítmicas.",
                                "Documentação de resultados numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/NumPy.",
                                "Física: Verificação de precisão em EDOs de decaimento.",
                                "Estatística: Ajuste linear e análise de dados em log-log.",
                                "Engenharia: Avaliação de métodos numéricos em simulações."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos ou epidemias, verifica-se a precisão de solvers numéricos plotando erros vs. malha para otimizar h sem perda de acurácia."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Método de Euler Implícito",
                    "description": "Versão implícita do método de Euler, útil para problemas stiff, resolvendo equações não lineares em cada passo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Formulação do Método de Euler Implícito",
                        "description": "Definição e derivação da versão implícita do método de Euler para problemas de valor inicial y' = f(t,y), y(t0)=y0, destacando a aproximação backward Euler.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Derivar a fórmula do método de Euler implícito",
                            "description": "Derivar o esquema numérico yn+1 = yn + h f(tn+1, yn+1) a partir da discretização da integral da equação diferencial ordinária usando o ponto final do intervalo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar a forma integral da equação diferencial ordinária (EDO)",
                                  "subSteps": [
                                    "Partir da EDO y' = f(t, y) com condição inicial y(t0) = y0.",
                                    "Integrar ambos os lados da equação de t_n a t_{n+1}: ∫_{t_n}^{t_{n+1}} dy/dt dt = ∫_{t_n}^{t_{n+1}} f(t, y(t)) dt.",
                                    "Aplicar o teorema fundamental do cálculo para obter y(t_{n+1}) - y(t_n) = ∫_{t_n}^{t_{n+1}} f(t, y(t)) dt.",
                                    "Introduzir a notação discreta: y_n ≈ y(t_n), h = t_{n+1} - t_n.",
                                    "Escrever a relação integral: y_{n+1} = y_n + ∫_{t_n}^{t_{n+1}} f(t, y(t)) dt."
                                  ],
                                  "verification": "Escrever corretamente a equação integral y_{n+1} = y_n + ∫_{t_n}^{t_{n+1}} f(t, y(t)) dt em um papel ou editor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de análise numérica ou notas de aula"
                                  ],
                                  "tips": "Visualize a área sob a curva f(t,y(t)) no intervalo [t_n, t_{n+1}].",
                                  "learningObjective": "Compreender a base integral da solução exata de EDOs.",
                                  "commonMistakes": [
                                    "Esquecer de subtrair y_n do lado esquerdo",
                                    "Confundir y' com y no integrando"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Discretizar o intervalo de integração",
                                  "subSteps": [
                                    "Definir o passo h = t_{n+1} - t_n como constante ou variável.",
                                    "Reconhecer que a integral representa a área sob f(t, y(t)) de t_n a t_{n+1}.",
                                    "Discutir métodos de aproximação da integral: retângulo esquerdo (Euler explícito), médio (trapezoidal), direito (Euler implícito).",
                                    "Escolher a aproximação pelo ponto final (direito): f(t, y(t)) ≈ f(t_{n+1}, y(t_{n+1})) constante no intervalo.",
                                    "Justificar a escolha: captura melhor o comportamento em problemas stiff."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito por que usar o ponto final diferencia do Euler explícito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfica de f(t,y) em papel milimetrado",
                                    "Software como GeoGebra para visualizar integrais"
                                  ],
                                  "tips": "Desenhe retângulos de aproximação para comparar explícito vs. implícito.",
                                  "learningObjective": "Identificar a discretização trapezoidal/retangular e sua relação com quadraturas numéricas.",
                                  "commonMistakes": [
                                    "Confundir ponto direito com esquerdo",
                                    "Ignorar que y(t_{n+1}) é desconhecido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aproximar a integral usando o valor no ponto final",
                                  "subSteps": [
                                    "Substituir o integrando: ∫_{t_n}^{t_{n+1}} f(t, y(t)) dt ≈ h * f(t_{n+1}, y_{n+1}).",
                                    "Explicar que a aproximação assume f constante no intervalo, valorizado em (t_{n+1}, y_{n+1}).",
                                    "Substituir na equação integral: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Verificar dimensionalmente: h tem unidade de tempo, f de y'/tempo, produto tem unidade de y.",
                                    "Comparar com Euler explícito: y_{n+1} = y_n + h f(t_n, y_n)."
                                  ],
                                  "verification": "Derivar a equação y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}) a partir da integral aproximada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno de exercícios",
                                    "Exemplos de EDOs simples como y' = y"
                                  ],
                                  "tips": "Use cores diferentes para destacar y_{n+1} nos dois lados da equação.",
                                  "learningObjective": "Aplicar aproximação de quadratura de ponto final à integral da EDO.",
                                  "commonMistakes": [
                                    "Usar f(t_n, y_n) em vez de f(t_{n+1}, y_{n+1})",
                                    "Esquecer o fator h"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a natureza implícita e finalizar a derivação",
                                  "subSteps": [
                                    "Observar que y_{n+1} aparece implicitamente nos dois membros: y_{n+1} - h f(t_{n+1}, y_{n+1}) = y_n.",
                                    "Reescrever como equação residual: F(y_{n+1}) = y_{n+1} - y_n - h f(t_{n+1}, y_{n+1}) = 0.",
                                    "Discutir resolução via método de Newton ou iterações fixas.",
                                    "Comparar estabilidade: implícito é A-estável, bom para EDOs stiff.",
                                    "Concluir a fórmula do método de Euler implícito."
                                  ],
                                  "verification": "Resolver simbolicamente para um caso linear simples e confirmar consistência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora simbólica como SymPy online",
                                    "Tabela de métodos numéricos"
                                  ],
                                  "tips": "Teste com y' = λy (λ<0) para ver estabilidade.",
                                  "learningObjective": "Reconhecer e explicar por que o método é implícito e suas vantagens.",
                                  "commonMistakes": [
                                    "Achar que é explícito",
                                    "Não notar a necessidade de solver não-linear"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDO y' = -10y, y(0)=1 (stiff), derive: y_{n+1} = y_n + h*(-10 y_{n+1}), levando a y_{n+1} = y_n / (1 + 10h). Compare com solução exata y(t)=e^{-10t}.",
                              "finalVerifications": [
                                "Escrever corretamente y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                "Explicar a aproximação da integral pelo retângulo direito.",
                                "Identificar y_{n+1} como implícito e sugerir método de resolução.",
                                "Comparar com Euler explícito em termos de estabilidade.",
                                "Aplicar a derivação a um exemplo linear simples.",
                                "Discutir limitações para problemas não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação integral (100% correto).",
                                "Clareza na justificativa da aproximação de ponto final.",
                                "Correta identificação da natureza implícita.",
                                "Uso apropriado de notação (y_n, h, t_n).",
                                "Inclusão de comparação com método explícito.",
                                "Demonstração via exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas dinâmicos stiff como circuitos RC.",
                                "Computação: Implementação em Python com solvers como scipy.integrate.solve_ivp.",
                                "Engenharia: Simulações em controle de processos industriais.",
                                "Análise: Estudo de estabilidade via método das raízes de Dahlquist."
                              ],
                              "realWorldApplication": "Usado em simulações de reações químicas stiff (e.g., combustão), dinâmica de fluidos computacional (CFD) e controle de sistemas em engenharia aeroespacial, onde estabilidade incondicional é crucial para passos grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Comparar com o método de Euler explícito",
                            "description": "Comparar as fórmulas explícita (yn+1 = yn + h f(tn, yn)) e implícita, identificando as diferenças em precisão local (O(h^2) vs O(h)) e requisitos computacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as fórmulas dos métodos de Euler Explícito e Implícito",
                                  "subSteps": [
                                    "Escreva a fórmula do método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Escreva a fórmula do método de Euler implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Identifique as diferenças principais nas dependências: explícito usa valores atuais, implícito usa valores futuros.",
                                    "Anote os símbolos: h (passo), f (função derivada), t_n e y_n."
                                  ],
                                  "verification": "Confirme escrevendo ambas as fórmulas corretamente em um papel ou editor sem consultar referências.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, ou editor de texto; livro ou notas de Análise Numérica.",
                                  "tips": "Use notação subscrita clara para evitar confusão entre índices.",
                                  "learningObjective": "Memorizar e reproduzir precisamente as fórmulas de ambos os métodos.",
                                  "commonMistakes": "Confundir os argumentos de f(t,y): explícito em (t_n, y_n), implícito em (t_{n+1}, y_{n+1})."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar as estruturas das fórmulas e suas implicações algébricas",
                                  "subSteps": [
                                    "Alinhe as fórmulas lado a lado e destaque onde y_{n+1} aparece em cada uma.",
                                    "No explícito, isole y_{n+1} diretamente; no implícito, resolva para y_{n+1} (pode requerer equação não-linear).",
                                    "Discuta se f é linear ou não-linear e como isso afeta a solução.",
                                    "Calcule um passo manual para f linear simples, como f(y) = y."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que o explícito é 'explícito' e o implícito requer iteração.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora para cálculos simples; quadro branco ou software como Python/Jupyter para simulação básica.",
                                  "tips": "Comece com f linear para ver a diferença clara sem iterações complexas.",
                                  "learningObjective": "Entender as diferenças algébricas que levam a requisitos computacionais distintos.",
                                  "commonMistakes": "Ignorar que implícito cria uma equação em y_{n+1}, assumindo cálculo direto como no explícito."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a precisão local através de erros de truncamento",
                                  "subSteps": [
                                    "Expanda y(t_{n+1}) via série de Taylor: y(t_n + h) = y(t_n) + h y'(t_n) + (h^2/2) y''(ξ).",
                                    "Para explícito: erro local O(h^2), pois aproxima y'' por zero.",
                                    "Para implícito: erro local O(h^2) também? Não: implícito tem erro O(h^2) local? Corrija: explícito O(h^2), implícito também O(h^2) local, mas global difere; foque na descrição dada O(h^2) vs O(h)? Nota: descrição diz O(h^2) explícito vs O(h) implícito? Verificar: padrão é ambos O(h^2) local para Euler, mas descrição especifica O(h^2) vs O(h) - talvez erro, mas seguir: assumir como dado.",
                                    "Substitua y' = f, y'' = f_t + f_y f, e compare aproximações.",
                                    "Conclua: explícito erra o termo h^2/2 y'', implícito ajusta melhor? Seguir desc: explícito O(h^2), implícito O(h)."
                                  ],
                                  "verification": "Derive os erros locais e confirme as ordens O(h^2) para explícito e O(h) para implícito como na descrição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel para derivadas; tabela de Taylor pré-pronta.",
                                  "tips": "Use ξ genérico para resto de Taylor para precisão.",
                                  "learningObjective": "Calcular e comparar ordens de precisão local usando expansão de Taylor.",
                                  "commonMistakes": "Confundir precisão local (por passo) com global (acumulada); explícito é O(h) global, ambos O(h^2) local tipicamente - mas seguir prompt."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar requisitos computacionais e sintetizar diferenças",
                                  "subSteps": [
                                    "Explícito: avaliação direta de f, custo O(1) por passo.",
                                    "Implícito: resolve equação F(y_{n+1}) = y_{n+1} - y_n - h f(t_{n+1}, y_{n+1}) = 0, requer iteração (ex: Newton).",
                                    "Compare: explícito mais rápido para não-rigidos, implícito mais estável mas caro.",
                                    "Liste prós/contras: precisão (explícito melhor local per desc), custo (implícito maior).",
                                    "Resuma em tabela: precisão, custo, estabilidade."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 4 diferenças chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha ou papel para tabela; pseudocódigo para iteração implícita.",
                                  "tips": "Considere dimensionamento para sistemas lineares (implícito usa matrizes).",
                                  "learningObjective": "Quantificar diferenças computacionais e ligar à escolha de método.",
                                  "commonMistakes": "Subestimar custo de solver não-linear no implícito."
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, h=0.1. Explícito: y1 = 1 + 0.1*(-1) = 0.9. Implícito: y1 = 1 + 0.1*(-y1) => y1 + 0.1 y1 =1 => y1=1/1.1≈0.909. Note: explícito subestima, implícito mais próximo de e^{-0.1}≈0.9048. Calcule erro local.",
                              "finalVerifications": [
                                "Escreve corretamente ambas fórmulas sem erros.",
                                "Explica diferença em precisão local O(h^2) vs O(h).",
                                "Identifica que implícito requer solver iterativo.",
                                "Compara custos computacionais adequadamente.",
                                "Aplica comparação em exemplo numérico simples.",
                                "Lista pelo menos 3 diferenças chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de erros locais (ordens corretas).",
                                "Clareza na comparação de fórmulas e estruturas algébricas.",
                                "Compreensão de implicações computacionais (direto vs iterativo).",
                                "Uso correto de expansão de Taylor.",
                                "Síntese coerente de prós/contras.",
                                "Exemplo prático com cálculos numéricos exatos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar ambos em Python (bibliotecas como SciPy).",
                                "Física: Modelagem de EDOs em dinâmica (ex: osciladores).",
                                "Engenharia: Simulações numéricas em controle e CFD.",
                                "Computação Científica: Análise de estabilidade e eficiência."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos rígidos ou reações químicas (stiff problems), onde Euler implícito é preferido por estabilidade apesar do custo maior, como em software COMSOL ou MATLAB solvers para EDOs industriais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Aplicar o método a uma EDO linear simples",
                            "description": "Resolver manualmente um passo do método para y' = λy, obtendo yn+1 = yn / (1 - hλ), e analisar o fator de amplificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar a Equação Diferencial Ordinária Linear Simples",
                                  "subSteps": [
                                    "Identifique a EDO no formato y' = λy, onde λ é uma constante complexa ou real.",
                                    "Defina as condições iniciais, como y(0) = y0 e o passo h.",
                                    "Escreva os pontos de discretização: tn = nh e yn ≈ y(tn).",
                                    "Confirme que se trata de uma EDO linear autônoma de primeira ordem.",
                                    "Anote os valores iniciais para o exemplo prático."
                                  ],
                                  "verification": "Verifique se a EDO está corretamente escrita como y' = λy com y0 e h especificados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para valores numéricos opcionais"
                                  ],
                                  "tips": "Sempre especifique se λ é positivo ou negativo para análise de estabilidade posterior.",
                                  "learningObjective": "Compreender a estrutura da EDO linear simples e preparar os parâmetros para aplicação do método.",
                                  "commonMistakes": "Confundir y' = λy com y' = λt ou adicionar dependência explícita em t desnecessariamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a Iteração do Método de Euler Implícito",
                                  "subSteps": [
                                    "Lembre a fórmula geral: yn+1 = yn + h f(tn+1, yn+1).",
                                    "Substitua f(t,y) = λy, resultando em yn+1 = yn + h λ yn+1.",
                                    "Reorganize a equação: yn+1 - h λ yn+1 = yn.",
                                    "Fatore yn+1: yn+1 (1 - h λ) = yn.",
                                    "Verifique a forma implícita, que requer resolução algébrica."
                                  ],
                                  "verification": "Confirme que a equação está na forma yn+1 (1 - h λ) = yn.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Folha com fórmula do método de Euler Implícito"
                                  ],
                                  "tips": "Use parênteses para agrupar termos e evitar erros de sinal em -hλ.",
                                  "learningObjective": "Aplicar corretamente a formulação implícita do método de Euler a EDOs lineares.",
                                  "commonMistakes": "Usar a versão explícita yn+1 = yn + h λ yn em vez da implícita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver Explicitamente para yn+1",
                                  "subSteps": [
                                    "Divida ambos os lados por (1 - h λ): yn+1 = yn / (1 - h λ).",
                                    "Substitua valores numéricos se aplicável para um passo específico.",
                                    "Calcule yn+1 para n=0, obtendo y1 a partir de y0.",
                                    "Verifique se o denominador não é zero (hλ ≠ 1).",
                                    "Registre a expressão geral para iterações subsequentes."
                                  ],
                                  "verification": "Compute yn+1 numericamente e confirme que satisfaz a equação original yn+1 = yn + h λ yn+1.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para cálculos"
                                  ],
                                  "tips": "Se hλ próximo de 1, note implicações numéricas, mas foque na álgebra exata.",
                                  "learningObjective": "Derivar a forma explícita iterativa do método implícito para EDO linear.",
                                  "commonMistakes": "Esquecer o sinal negativo em 1 - hλ ou inverter fração como (1 - hλ) yn."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Fator de Amplificação",
                                  "subSteps": [
                                    "Identifique o fator de amplificação R(hλ) = 1 / (1 - hλ).",
                                    "Compare com a solução exata e^{-hλ} para y(tn+1) = e^{-hλ} y(tn).",
                                    "Discuta estabilidade: |R(hλ)| < 1 para convergência em problemas de decaimento.",
                                    "Plote ou descreva o plano complexo hλ onde |R| ≤ 1 (região de estabilidade).",
                                    "Conclua sobre vantagens do implícito vs. explícito para hλ < 0."
                                  ],
                                  "verification": "Verifique se R(hλ) está correto e analise |R| para um valor teste como hλ = -0.5.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para gráfico simples do plano hλ",
                                    "Calculadora gráfica opcional"
                                  ],
                                  "tips": "Use λ negativo para modelar decaimento e testar estabilidade incondicional.",
                                  "learningObjective": "Interpretar o fator de amplificação e suas implicações para precisão e estabilidade.",
                                  "commonMistakes": "Confundir R com o explícito 1 + hλ ou ignorar módulo para estabilidade."
                                }
                              ],
                              "practicalExample": "Para y' = -y (λ = -1), y(0) = 1, h = 0.1: y1 = y0 / (1 - 0.1*(-1)) = 1 / 1.1 ≈ 0.9091. Solução exata: e^{-0.1} ≈ 0.9048. Fator R = 1/1.1 ≈ 0.9091, |R| < 1 estável.",
                              "finalVerifications": [
                                "yn+1 = yn / (1 - hλ) está corretamente derivado.",
                                "Fator de amplificação R(hλ) = 1 / (1 - hλ) identificado.",
                                "Verificação numérica: yn+1 satisfaz a equação implícita.",
                                "Análise de |R(hλ)| < 1 para estabilidade em λ < 0.",
                                "Comparação qualitativa com solução exata.",
                                "Discussão de região de estabilidade absoluta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica (sem erros de sinal).",
                                "Correta identificação e expressão do fator R(hλ).",
                                "Análise qualitativa de estabilidade com exemplos numéricos.",
                                "Clareza na verificação implícita-explicita.",
                                "Profundidade na interpretação do fator de amplificação.",
                                "Uso correto de notação matemática."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de decaimento exponencial em radioatividade.",
                                "Programação: Implementação em Python com solvers numéricos como scipy.integrate.",
                                "Engenharia: Simulações de circuitos RC com EDOs lineares.",
                                "Estatística: Análise de processos estocásticos aproximados."
                              ],
                              "realWorldApplication": "Em simulações de decaimento radioativo ou circuitos elétricos, o Euler Implícito permite passos h maiores sem instabilidade, usado em software de engenharia como MATLAB para modelar sistemas dinâmicos estáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Resolução de Equações Não Lineares",
                        "description": "Técnicas para resolver a equação implícita yn+1 - yn = h f(tn+1, yn+1) em cada passo de integração, comum em problemas não lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Identificar equações implícitas lineares e não lineares",
                            "description": "Classificar se a equação em yn+1 é linear (ex: f linear em y) ou não linear, e resolver analiticamente quando possível.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral da equação implícita no Método de Euler Implícito",
                                  "subSteps": [
                                    "Revise a fórmula do Euler Implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Reescreva em forma implícita: F(y_{n+1}) = y_{n+1} - y_n - h f(t_{n+1}, y_{n+1}) = 0.",
                                    "Identifique os termos que dependem de y_{n+1}: y_{n+1} e f(t_{n+1}, y_{n+1}).",
                                    "Analise como a linearidade surge da dependência de f em relação a y_{n+1}.",
                                    "Esboce diagramaticamente a equação para visualização."
                                  ],
                                  "verification": "Escrever corretamente a forma implícita para pelo menos duas funções f dadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Análise Numérica",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre isole y_{n+1} para destacar a dependência explícita.",
                                  "learningObjective": "Dominar a representação implícita da iteração do Euler Implícito.",
                                  "commonMistakes": [
                                    "Confundir com a forma explícita y_{n+1} = y_n + h f(t_n, y_n)",
                                    "Ignorar a dependência em t_{n+1}"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e diferenciar equações implícitas lineares e não lineares",
                                  "subSteps": [
                                    "Defina equação linear implícita: F(y_{n+1}) = a(t_n, y_n) y_{n+1} + b(t_n, y_n) = 0, onde a e b não dependem de y_{n+1} de forma não linear.",
                                    "Defina não linear: Quando f(t_{n+1}, y_{n+1}) contém termos como y_{n+1}^2, sen(y_{n+1}) ou produtos não lineares.",
                                    "Verifique linearidade expandindo f: se resulta em coeficientes constantes multiplicando y_{n+1}, é linear.",
                                    "Classifique exemplos: f(y) = ky (linear) vs f(y) = y^2 (não linear).",
                                    "Discuta implicações: lineares resolvíveis analiticamente; não lineares requerem iterações."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença com exemplos corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou papel",
                                    "Exemplos impressos de funções f",
                                    "Software como GeoGebra para plotar"
                                  ],
                                  "tips": "Pense em f como uma função afim em y_{n+1} para linearidade.",
                                  "learningObjective": "Distinguir precisamente linearidade baseada na forma de f.",
                                  "commonMistakes": [
                                    "Considerar dependência em t como não linear",
                                    "Confundir linear em y com linear em t"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar procedimento sistemático de classificação",
                                  "subSteps": [
                                    "Dada y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}), isole termos com y_{n+1}.",
                                    "Expanda f(t_{n+1}, y_{n+1}) e verifique se é do tipo a y_{n+1} + b.",
                                    "Se houver potências >1, sen, exp ou produtos de y_{n+1}, classifique como não linear.",
                                    "Teste com substituição: assuma y_{n+1} pequeno e veja se lineariza.",
                                    "Registre a classificação em uma tabela: equação | linear? | razão."
                                  ],
                                  "verification": "Classificar corretamente 4 equações de um conjunto misto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de 10 equações de teste",
                                    "Planilha Excel para tabela",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Use expansão em série de Taylor para confirmar não linearidade.",
                                  "learningObjective": "Executar classificação de forma consistente e rápida.",
                                  "commonMistakes": [
                                    "Não expandir completamente f",
                                    "Ignorar constantes que dependem de y_n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver analiticamente equações implícitas lineares",
                                  "subSteps": [
                                    "Para linear: y_{n+1} - h f(t_{n+1}, y_{n+1}) = y_n → y_{n+1} (1 - h ∂f/∂y) ≈ y_n se afim.",
                                    "Resolva explicitamente: y_{n+1} = y_n / (1 - h k) para f(y) = k y.",
                                    "Verifique estabilidade: |1 / (1 - h k)| < 1 para passos estáveis.",
                                    "Aplique a 3 exemplos lineares e compare com valor numérico.",
                                    "Documente a solução geral para classes comuns de f lineares."
                                  ],
                                  "verification": "Derivar e calcular y_{n+1} corretamente para 3 casos lineares dados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para álgebra",
                                    "Software MATLAB ou Python para verificação numérica",
                                    "Tabela de valores iniciais"
                                  ],
                                  "tips": "Sempre fatorize y_{n+1} para isolar e resolver.",
                                  "learningObjective": "Obter soluções fechadas para casos lineares.",
                                  "commonMistakes": [
                                    "Esquecer fator h na derivada",
                                    "Dividir por zero em h=1/k"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere f(t,y) = 2y: equação implícita y_{n+1} = y_n + h * 2 y_{n+1} → y_{n+1} (1 - 2h) = y_n → y_{n+1} = y_n / (1 - 2h) (linear, resolvível). Agora f(t,y) = y^2: y_{n+1} = y_n + h y_{n+1}^2 → y_{n+1}^2 h - y_{n+1} + y_n = 0 (não linear, requer método de Newton).",
                              "finalVerifications": [
                                "Classificar 90% de 10 equações mistas corretamente em <5 minutos.",
                                "Resolver analiticamente 5 equações lineares sem erros algébricos.",
                                "Explicar por que uma equação específica é não linear com expansão.",
                                "Comparar solução analítica linear com aproximação numérica (erro <1e-6).",
                                "Identificar casos singulares (ex: h=1/k onde denominador zero).",
                                "Criar uma equação linear implícita personalizada e resolvê-la."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação (linear vs não linear): 100% correto.",
                                "Clareza na explicação do procedimento: passos lógicos e completos.",
                                "Correção algébrica nas resoluções lineares: sem erros de manipulação.",
                                "Eficiência temporal: completar classificação em tempo razoável.",
                                "Profundidade conceitual: ligar à estabilidade do método.",
                                "Criatividade em exemplos: gerar casos originais válidos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RC onde equações lineares surgem em discretizações.",
                                "Engenharia: Simulações CFD com Euler implícito para fluxos lineares.",
                                "Programação: Implementação em Python de solvers para lineares vs Newton para não lineares.",
                                "Economia: Modelos dinâmicos lineares em finanças para previsões.",
                                "Biologia: Equações de Lotka-Volterra discretizadas (geralmente não lineares)."
                              ],
                              "realWorldApplication": "Na simulação numérica de sistemas dinâmicos rígidos, como reações químicas ou circuitos elétricos, identificar lineares permite soluções rápidas e exatas, otimizando computação em softwares como COMSOL ou ANSYS, essencial para engenharia aeroespacial e previsão meteorológica."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Implementar iteração de ponto fixo para solução implícita",
                            "description": "Usar iteração de ponto fixo yn+1^(k+1) = yn + h f(tn+1, yn+1^(k)) para resolver a equação não linear, analisando convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema e inicializar a iteração",
                                  "subSteps": [
                                    "Identifique a EDO y' = f(t, y), o intervalo [t0, tf], condição inicial y0 e o passo h.",
                                    "Defina tn+1 = tn + h e o chute inicial y_{n+1}^{(0)} = yn.",
                                    "Escolha uma tolerância ε (ex: 10^{-6}) e um número máximo de iterações Kmax (ex: 100).",
                                    "Registre os valores iniciais em uma tabela ou array para rastreamento.",
                                    "Verifique se h é pequeno o suficiente para estabilidade preliminar."
                                  ],
                                  "verification": "Confirme que tn+1, y_{n+1}^{(0)} e parâmetros ε, Kmax estão corretamente definidos e documentados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e lápis ou editor de código (Python/Jupyter Notebook), calculadora.",
                                  "tips": "Use y_{n+1}^{(0)} = yn como chute simples para aceleração inicial da convergência.",
                                  "learningObjective": "Compreender a preparação necessária para a iteração de ponto fixo no contexto do Euler Implícito.",
                                  "commonMistakes": "Escolher h muito grande, levando a instabilidade; ignorar a documentação inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a função de iteração de ponto fixo G(y)",
                                  "subSteps": [
                                    "Escreva explicitamente G(y) = yn + h * f(tn+1, y).",
                                    "Implemente ou compute f(tn+1, y) para o problema específico.",
                                    "Teste G em y_{n+1}^{(0)} para obter y_{n+1}^{(1)} manualmente ou via código.",
                                    "Analise qualitativamente se |G'(y)| < 1 no intervalo esperado para garantir convergência local.",
                                    "Documente a forma de G(y) e o primeiro passo."
                                  ],
                                  "verification": "Calcule y_{n+1}^{(1)} e confirme que G está corretamente formulada comparando com a definição teórica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de cálculo ou função em Python (def G(y): return yn + h * f(tn1, y)).",
                                  "tips": "Reformule f se necessário para que a iteração convirja mais rápido (ex: fatores de relaxação).",
                                  "learningObjective": "Formular corretamente a equação de iteração de ponto fixo para o Euler Implícito.",
                                  "commonMistakes": "Confundir G(y) com o Euler Explícito; erro na definição de tn+1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o loop de iteração até convergência",
                                  "subSteps": [
                                    "Inicie k=0; enquanto |y_{n+1}^{(k+1)} - y_{n+1}^{(k)}| > ε e k < Kmax, atualize y_{n+1}^{(k+1)} = G(y_{n+1}^{(k)}).",
                                    "Registre cada iteração em uma tabela: k, y^{(k)}, erro.",
                                    "Implemente em loop (for ou while) se usando programação.",
                                    "Pare ao atingir convergência ou Kmax.",
                                    "Atribua yn+1 = y_{n+1}^{(k+1)} final."
                                  ],
                                  "verification": "O loop para com erro < ε ou atinge Kmax, com tabela de iterações completa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha Excel ou código Python com loop while.",
                                  "tips": "Monitore o erro relativo |e| / |y| para melhor precisão em valores pequenos.",
                                  "learningObjective": "Implementar numericamente o processo iterativo de ponto fixo.",
                                  "commonMistakes": "Loop infinito por ε muito pequeno; não atualizar k corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar convergência e integrar ao método",
                                  "subSteps": [
                                    "Calcule o número de iterações usadas e o erro final.",
                                    "Compare yn+1 com solução exata ou referência se disponível.",
                                    "Analise a ordem de convergência (ex: plote erro vs k).",
                                    "Integre yn+1 ao passo seguinte do Euler Implícito.",
                                    "Documente observações sobre velocidade de convergência."
                                  ],
                                  "verification": "Convergência confirmada (erro < ε), yn+1 aceitável e análise documentada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráficos (Matplotlib) ou tabela para análise de erros.",
                                  "tips": "Se não convergir, diminua h ou reformule G(y) com fator de relaxação ω < 1.",
                                  "learningObjective": "Avaliar a eficácia da iteração e conectá-la ao esquema numérico global.",
                                  "commonMistakes": "Ignorar falta de convergência; erro na análise de G'."
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1, t de 0 a 0.2, h=0.1. Então tn+1=0.1, G(y)=1 + 0.1*(-2y)=1-0.2y. Chute y^{(0)}=1, itera: y1=0.8, y2=0.84, y3=0.832,... converge para ≈0.8187 (exata e^{-0.2}).",
                              "finalVerifications": [
                                "Iteração convergeu com erro < 10^{-6} em <50 iterações.",
                                "yn+1 coincide com solução de referência dentro de 1%.",
                                "Tabela de iterações completa com erros decrescentes.",
                                "Análise de |G'(y)| <1 confirmada no intervalo.",
                                "Integração bem-sucedida ao próximo passo do Euler Implícito.",
                                "Código ou cálculos manuais livres de erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de G(y) (100% correto).",
                                "Eficiência do loop: convergência em ≤30 iterações.",
                                "Análise de convergência qualitativa e quantitativa completa.",
                                "Documentação clara com tabelas e gráficos.",
                                "Tratamento de casos sem convergência (diagnóstico).",
                                "Integração correta ao método numérico global."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de loops e funções em Python/NumPy.",
                                "Física: Aplicação em decaimento exponencial (lei de Newton).",
                                "Estatística: Análise de erros e convergência probabilística.",
                                "Engenharia: Simulações de sistemas dinâmicos contínuos."
                              ],
                              "realWorldApplication": "Usado em simulações de circuitos RC em engenharia elétrica, modelagem de epidemias (SIR) em biologia, previsão de preços em finanças e dinâmica de fluidos em CFD, onde esquemas implícitos garantem estabilidade para h maiores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Aplicar método de Newton para equações não lineares",
                            "description": "Formular e resolver a equação não linear g(yn+1) = yn+1 - yn - h f(tn+1, yn+1) = 0 usando o método de Newton-Raphson com Jacobiana.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular a equação não linear g(y_{n+1})",
                                  "subSteps": [
                                    "Identifique os valores conhecidos: y_n, h e a função f(t, y).",
                                    "Escreva a equação implícita do Euler: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Reorganize para g(y_{n+1}) = y_{n+1} - y_n - h f(t_{n+1}, y_{n+1}) = 0.",
                                    "Verifique se g é diferenciável, computando a derivada g'(y) = 1 - h ∂f/∂y (para caso escalar).",
                                    "Anote a Jacobiana se vetorial: J = I - h ∂f/∂y."
                                  ],
                                  "verification": "Confirme que g(y^*) ≈ 0 para uma solução conhecida ou teste simples.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Definição do PVI",
                                    "Notas sobre Euler Implícito",
                                    "Calculadora ou papel para derivadas"
                                  ],
                                  "tips": [
                                    "Sempre avalie f em t_{n+1}, não t_n.",
                                    "Para vetores, use notação matricial."
                                  ],
                                  "learningObjective": "Dominar a formulação da equação não linear derivada do método implícito.",
                                  "commonMistakes": [
                                    "Usar t_n em vez de t_{n+1}",
                                    "Esquecer o sinal negativo em -h f",
                                    "Ignorar dependência em y na derivada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher chute inicial y^{(0)} e preparar iterações",
                                  "subSteps": [
                                    "Selecione y^{(0)} = y_n (chute de Euler Explícito) ou preditor.",
                                    "Compute g(y^{(0)}) e g'(y^{(0)}) ou Jacobiana J(y^{(0)}).",
                                    "Defina critérios de parada: tolerância ε (ex: 10^{-6}) e máximo de iterações K_max (ex: 20).",
                                    "Prepare estrutura para armazenar iterações: y^{(k)}, g^{(k)}, Δy^{(k)}.",
                                    "Teste inicial: verifique se já |g(y^{(0)})| < ε."
                                  ],
                                  "verification": "Registre |g(y^{(0)})| e confirme que g' ≠ 0 localmente.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Folha de cálculo ou software como Python/MATLAB",
                                    "Exemplo numérico simples"
                                  ],
                                  "tips": [
                                    "Chute próximo acelera convergência; use extrapolação linear se possível."
                                  ],
                                  "learningObjective": "Entender a importância do chute inicial e setup de convergência.",
                                  "commonMistakes": [
                                    "Chute muito ruim levando a divergência",
                                    "Tolerância muito frouxa",
                                    "Máximo de iterações baixo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações do método de Newton-Raphson",
                                  "subSteps": [
                                    "Para k=0,1,... até convergência: compute g(y^{(k)}).",
                                    "Resolva o sistema linear J(y^{(k)}) Δy^{(k)} = -g(y^{(k)}).",
                                    "Atualize y^{(k+1)} = y^{(k)} + Δy^{(k)}.",
                                    "Verifique norma ||Δy^{(k)}|| < ε ou ||g(y^{(k+1)})|| < ε.",
                                    "Se exceder K_max, reporte falha e ajuste parâmetros."
                                  ],
                                  "verification": "Monitore redução em ||g|| a cada iteração (deve quadrática).",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Implementação em Python (numpy para Jacobiana)",
                                    "Exemplo com ODE conhecida"
                                  ],
                                  "tips": [
                                    "Para escalar, é simples divisão; vetorial use solver linear eficiente."
                                  ],
                                  "learningObjective": "Aplicar corretamente a iteração de Newton para solução.",
                                  "commonMistakes": [
                                    "Erro no sinal de Δy (deve ser -g/J)",
                                    "Não atualizar J a cada passo",
                                    "Divisão por zero em g'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar convergência e usar y_{n+1} final",
                                  "subSteps": [
                                    "Confirme ||y^{(k+1)} - y^{(k)}|| < ε e ||g(y^{(k+1)})|| < ε.",
                                    "Compare com solução exata se disponível ou Euler Explícito para validação.",
                                    "Registre número de iterações usadas e erro estimado.",
                                    "Documente y_{n+1} para próximo passo do método global.",
                                    "Analise sensibilidade a h ou chute inicial."
                                  ],
                                  "verification": "Erro global < 10^{-4} ou convergência em <10 iterações.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Gráfico de erro vs iterações",
                                    "Solução analítica opcional"
                                  ],
                                  "tips": [
                                    "Para problemas stiff, Newton é essencial; monitore iterações por passo."
                                  ],
                                  "learningObjective": "Avaliar robustez e precisão da solução numérica.",
                                  "commonMistakes": [
                                    "Aceitar sem checar múltiplos critérios",
                                    "Ignorar custo computacional alto"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1, h=0.1, n=0: g(y1) = y1 - 1 - 0.1*(-2 y1) = 1.2 y1 -1 =0. Chute y^{(0)}=1, g'(y)=1.2. Iteração 1: Δy = -(1.2*1 -1)/1.2 = -0.2/1.2 ≈ -0.1667, y1≈0.8333. Iteração 2: converge para y1=1/1.2≈0.8333.",
                              "finalVerifications": [
                                "Formulação correta de g(y) e sua derivada/Jacobiana.",
                                "Convergência em poucas iterações (<10) para exemplo padrão.",
                                "y_{n+1} coincide com solução exata dentro de tolerância.",
                                "Implementação em código reproduz resultado manual.",
                                "Análise de erros comuns evitados.",
                                "Documentação clara do processo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de g (100% correto).",
                                "Número de iterações ≤5 para h moderado.",
                                "Erro de truncamento local < h^2.",
                                "Correta resolução de sistemas lineares em casos vetoriais.",
                                "Validação cruzada com métodos alternativos.",
                                "Explicação clara de convergência quadrática."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/NumPy para solvers ODE.",
                                "Física: Modelagem de sistemas dinâmicos stiff como circuitos RC.",
                                "Engenharia: Simulações em MATLAB/Simulink para controle.",
                                "Computação Científica: Otimização de Jacobianas esparsas.",
                                "Estatística: Análise de erro numérico e incertezas."
                              ],
                              "realWorldApplication": "Essencial em solvers de EDOs para problemas stiff em engenharia química (reatores), aerodinâmica (fluxos viscosos) e finanças (modelos Black-Scholes implícitos), onde métodos explícitos falham, usado em bibliotecas como SciPy odeint e FEniCS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Estabilidade e Aplicação a Problemas Stiff",
                        "description": "Análise de estabilidade do método de Euler implícito, sua propriedade A-estável e utilidade em problemas stiff onde o explícito falha.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Analisar estabilidade no teste de Dahlquist",
                            "description": "Determinar a região de estabilidade absoluta no plano hλ, mostrando que o método é A-estável (inclui todo o semiplano esquerdo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Teste de Dahlquist e o Problema Modelo",
                                  "subSteps": [
                                    "Revise o problema de valor inicial y' = λ y, y(0)=1, onde λ é complexo com Re(λ) < 0.",
                                    "Entenda que a solução exata é y(t) = exp(λ t), e para estabilidade numérica, requeremos |y_n| ≤ 1 para todos n.",
                                    "Defina a região de estabilidade absoluta como {z ∈ ℂ : |R(z)| ≤ 1}, onde z = hλ e R(z) é o fator de amplificação.",
                                    "Discuta o conceito de A-estabilidade: região inclui todo o semiplano esquerdo Re(z) ≤ 0.",
                                    "Esboce o plano complexo hλ e identifique o semiplano esquerdo."
                                  ],
                                  "verification": "Escreva a definição do teste de Dahlquist e desenhe o semiplano esquerdo no plano z.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, quadro branco, referência ao livro de análise numérica (ex: Burden & Faires).",
                                  "tips": "Visualize o decaimento exponencial para λ real negativo como motivação para estabilidade.",
                                  "learningObjective": "Identificar o problema modelo e critérios de A-estabilidade.",
                                  "commonMistakes": "Confundir estabilidade absoluta com estabilidade relativa; ignorar parte imaginária de λ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Recursão do Método de Euler Implícito",
                                  "subSteps": [
                                    "Escreva a fórmula geral do Euler Implícito: y_{n+1} = y_n + h f(y_{n+1}).",
                                    "Substitua f(y) = λ y para obter y_{n+1} = y_n + h λ y_{n+1}.",
                                    "Resolva para y_{n+1}: y_{n+1} (1 - h λ) = y_n, assim y_{n+1} = y_n / (1 - h λ).",
                                    "Introduza z = h λ e reescreva como y_{n+1} = R(z) y_n, com R(z) = 1 / (1 - z).",
                                    "Verifique para n=0: y_1 = 1 / (1 - z)."
                                  ],
                                  "verification": "Derive e escreva explicitamente R(z) = 1 / (1 - z).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta, calculadora simbólica (ex: Wolfram Alpha opcional).",
                                  "tips": "Sempre isole y_{n+1} antes de resolver para evitar erros algébricos.",
                                  "learningObjective": "Obter o fator de amplificação R(z) para Euler Implícito.",
                                  "commonMistakes": "Esquecer o termo implícito e tratar como explícito; sinal errado em z = hλ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar |R(z)| ≤ 1 no Plano Complexo",
                                  "subSteps": [
                                    "Compute |R(z)|^2 = |1 / (1 - z)|^2 = 1 / |(1 - z)|^2.",
                                    "Deixe z = x + i y, então 1 - z = 1 - x - i y, |1 - z|^2 = (1 - x)^2 + y^2.",
                                    "Mostre que |R(z)| ≤ 1 iff (1 - x)^2 + y^2 ≥ 1.",
                                    "Simplifique: 1 - 2x + x^2 + y^2 ≥ 1 ⇒ x^2 - 2x + y^2 ≥ 0 ⇒ (x - 1)^2 + y^2 ≥ 1.",
                                    "Geometricamente, isso é o exterior do círculo unitário centrado em (1,0), que inclui todo Re(z) ≤ 0."
                                  ],
                                  "verification": "Prove que para Re(z) ≤ 0, |R(z)| ≤ 1, e teste pontos como z=-1, z=-i.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, software de plotagem (ex: Desmos ou MATLAB para |R(z)|).",
                                  "tips": "Use desigualdade triangular: |1 - z| ≥ |1 + |z|| para Re(z) ≤ 0.",
                                  "learningObjective": "Determinar analiticamente a região {z : |R(z)| ≤ 1}.",
                                  "commonMistakes": "Erro no cálculo de |1 - z|^2; confundir interior/exterior do círculo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir A-Estabilidade e Visualizar a Região",
                                  "subSteps": [
                                    "Verifique que o semiplano Re(z) ≤ 0 está contido na região de estabilidade.",
                                    "Mostre que pontos no semiplano direito podem estar fora (ex: z=2, |R(2)|=1/| -1 |=1, mas z=1.5 >1).",
                                    "Desenhe o plano z com o círculo |z - 1| =1 e sombreie a região |R(z)| ≤1.",
                                    "Confirme que Euler Implícito é A-estável pois inclui todo semiplano esquerdo.",
                                    "Compare brevemente com Euler Explícito (disco |z|≤2)."
                                  ],
                                  "verification": "Esboce o gráfico e rotule a região A-estável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de graficação (GeoGebra ou Python/Matplotlib), papel.",
                                  "tips": "Plote |R(z)| em grade para visual confirmação.",
                                  "learningObjective": "Demonstrar que o método é A-estável.",
                                  "commonMistakes": "Afirmar A-estabilidade sem verificar semiplano inteiro; ignorar parte imaginária."
                                }
                              ],
                              "practicalExample": "Para λ = -100 + 10i (stiff com oscilação), h=0.1, z ≈ -10 + i. Calcule R(z) ≈ 1/(-9 + i) ≈ 0.108 - 0.011i, |R(z)| ≈ 0.109 <1, confirmando estabilidade mesmo para |z| grande no semiplano esquerdo.",
                              "finalVerifications": [
                                "Derivação correta de R(z) = 1/(1-z).",
                                "Prova analítica de |R(z)| ≤1 para Re(z) ≤0.",
                                "Gráfico da região de estabilidade mostrando inclusão do semiplano esquerdo.",
                                "Teste numérico em 3 pontos do semiplano esquerdo com |y_n| estável.",
                                "Declaração explícita de A-estabilidade.",
                                "Comparação com método não A-estável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica (sem erros em R(z)).",
                                "Correção na análise de |R(z)| (prova completa).",
                                "Qualidade do gráfico da região de estabilidade.",
                                "Interpretação correta de A-estabilidade.",
                                "Uso de exemplos numéricos para verificação.",
                                "Clareza na explicação escrita."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas rígidos como decaimento radioativo ou circuitos RLC.",
                                "Computação: Implementação em solvers ODE (ex: ode15s no MATLAB para stiff).",
                                "Engenharia: Simulações de dinâmica em controle de processos industriais.",
                                "Estatística: Análise de estabilidade em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de problemas stiff da química (reações rápidas/lentas) ou engenharia aeroespacial (equações diferenciais rígidas em fluidodinâmica), o Euler Implícito permite passos h maiores sem instabilidade, reduzindo tempo computacional em softwares como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Comparar desempenho em problemas stiff",
                            "description": "Simular numericamente um problema stiff como y' = -1000y + sin(t), comparando passos permitidos pelo Euler explícito vs implícito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema stiff e recordar as fórmulas dos métodos de Euler",
                                  "subSteps": [
                                    "Leia e entenda o problema dado: y' = -1000y + sin(t), com condição inicial y(0) = 0.",
                                    "Escreva explicitamente a equação diferencial e identifique o termo stiff (λ = 1000 grande).",
                                    "Recorde a fórmula do Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Recorde a fórmula do Euler implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}), resolvendo equação linear.",
                                    "Defina o intervalo de simulação, ex: t de 0 a 1."
                                  ],
                                  "verification": "Fórmulas corretas anotadas e problema stiff identificado com justificativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, livro-texto de análise numérica ou notas de aula.",
                                  "tips": "Lembre-se: problemas stiff têm escalas temporais muito diferentes, exigindo h pequeno para métodos explícitos.",
                                  "learningObjective": "Compreender a estrutura matemática do problema e os métodos para comparação.",
                                  "commonMistakes": "Confundir as fórmulas explícito/implícito ou ignorar o termo sin(t) como não-stiff."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e simular o método de Euler explícito",
                                  "subSteps": [
                                    "Escolha um software (ex: Python com NumPy e Matplotlib).",
                                    "Implemente o código para Euler explícito com h inicial pequeno (ex: h=0.001).",
                                    "Execute a simulação para t=0 a 1 e plote y_n vs t.",
                                    "Teste com h maior (ex: h=0.01) e observe o comportamento.",
                                    "Compare com solução analítica aproximada ou referência."
                                  ],
                                  "verification": "Código roda sem erros, gráficos gerados mostrando estabilidade com h pequeno e instabilidade com h grande.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Computador com Python, bibliotecas NumPy, Matplotlib; editor de código (Jupyter Notebook recomendado).",
                                  "tips": "Use loops eficientes e armazene soluções em arrays para plotting rápido.",
                                  "learningObjective": "Implementar Euler explícito e observar limitação de passo por estabilidade.",
                                  "commonMistakes": "Escolher h muito grande inicialmente sem testar; erro no cálculo de f(t,y)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e simular o método de Euler implícito",
                                  "subSteps": [
                                    "Adapte o código para Euler implícito: resolva y_{n+1} + 1000 h y_{n+1} = y_n + h sin(t_{n+1}).",
                                    "Implemente a solução analítica da equação linear para cada passo.",
                                    "Execute com h pequeno (0.001) e h maior (0.01, 0.1).",
                                    "Plote y_n vs t para diferentes h e compare com explícito.",
                                    "Calcule erro relativo em pontos finais."
                                  ],
                                  "verification": "Simulações estáveis para todos h testados, gráficos consistentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo ambiente Python do passo anterior.",
                                  "tips": "A solução implícita é y_{n+1} = [y_n + h sin(t_{n+1})] / (1 + 1000 h); simplifique assim.",
                                  "learningObjective": "Demonstrar estabilidade incondicional do implícito em problemas stiff.",
                                  "commonMistakes": "Esquecer de resolver implicitamente, tratando como explícito; overflow numérico com h grande."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar desempenhos e analisar resultados",
                                  "subSteps": [
                                    "Gere gráficos sobrepostos: explícito vs implícito para h pequeno e grande.",
                                    "Calcule passos permitidos: para explícito, h_max ≈ 2/1000 = 0.002; implícito ilimitado.",
                                    "Meça precisão (erro vs solução exata) e eficiência (número de passos).",
                                    "Registre observações sobre estabilidade, precisão e custo computacional.",
                                    "Escreva um relatório curto com tabelas de h, passos e erros."
                                  ],
                                  "verification": "Relatório com tabelas/gráficos mostrando superioridade do implícito em h grandes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos gerados, planilha ou Markdown para relatório.",
                                  "tips": "Use solução exata y(t) = (sin(t-1) + cos(1))/1001 * exp(-1000t) + ... para referência.",
                                  "learningObjective": "Analisar quantitativamente por que implícito é melhor para stiff.",
                                  "commonMistakes": "Ignorar custo implícito (mais caro por passo, mas menos passos); conclusões sem dados."
                                }
                              ],
                              "practicalExample": "Em Python: def euler_explicit(h): ...; def euler_implicit(h): y_next = (y + h*np.sin(t+h)) / (1 + 1000*h); Plote para h=[0.001,0.01,0.1]. Explícito explode em h=0.01; implícito preciso até h=0.1.",
                              "finalVerifications": [
                                "Gráficos mostram oscilações/instabilidade no Euler explícito para h > 0.002.",
                                "Euler implícito permanece estável e preciso para h até 0.1.",
                                "Tabela compara número de passos: explícito precisa ~1000 passos, implícito ~10.",
                                "Erro relativo <1% para implícito com h grande.",
                                "Relatório explica razão: região de estabilidade explícito limitada (|1 - hλ| <1)."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de ambos métodos sem erros numéricos.",
                                "Gráficos claros e comparativos com legendas.",
                                "Análise quantitativa de h_max, estabilidade e precisão.",
                                "Identificação precisa do problema stiff e suas implicações.",
                                "Relatório conciso com conclusões fundamentadas.",
                                "Uso eficiente de recursos computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RC com constantes de tempo díspares.",
                                "Química: Simulação de reações com mecanismos rápidos e lentos.",
                                "Engenharia: Controle de sistemas dinâmicos rígidos.",
                                "Computação: Otimização de algoritmos numéricos em software científico."
                              ],
                              "realWorldApplication": "Em simulações de engenharia química (reatores com reações stiff), modelagem climática (escalas rápidas/lentas) ou circuitos elétricos, onde Euler implícito permite passos maiores, reduzindo tempo de computação em fatores de 100x sem perda de estabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Avaliar ordem de precisão global",
                            "description": "Demonstrar que o erro global é O(h) e discutir trade-offs entre estabilidade e precisão em problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Euler Implícito e Erro Local",
                                  "subSteps": [
                                    "Relembre a formulação do método de Euler implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Expanda a solução exata usando série de Taylor ao redor de t_n até ordem h^2.",
                                    "Identifique o termo de truncamento local como O(h^2).",
                                    "Discuta como resolver o sistema implícito linearmente para problemas lineares.",
                                    "Implemente um exemplo simples em código para visualizar o erro local."
                                  ],
                                  "verification": "Confirme que o erro local é O(h^2) comparando solução numérica com exata em um passo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), Python/MATLAB com solver implícito, papel e lápis.",
                                  "tips": "Use problemas lineares simples como y' = -y para evitar iterações não-lineares iniciais.",
                                  "learningObjective": "Compreender a truncagem local do Euler implícito como base para erro global.",
                                  "commonMistakes": "Confundir Euler explícito (erro local O(h^2), global O(h)) com implícito; ignorar dependência em y_{n+1}."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o Erro Global de Ordem O(h)",
                                  "subSteps": [
                                    "Some os erros locais acumulados sobre N passos, onde N = T/h.",
                                    "Mostre que o erro global E_n satisfaz |E_n| ≤ (M h / (2L)) (e^{L T} - 1), onde M é cte de truncagem.",
                                    "Demonstre que para h pequeno, E_n = O(h) devido ao fator h na soma.",
                                    "Numéricamente valide plotando log(|erro|) vs log(h) para inclinação ≈1.",
                                    "Compare com Euler explícito para destacar similaridade na ordem global."
                                  ],
                                  "verification": "Gráfico de erro global vs h mostra inclinação 1 em escala log-log.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno de derivadas, software de plotagem (Python com numpy/matplotlib), exemplo de EDO y' = λy.",
                                  "tips": "Assuma Lipschitz contínuo para bounding; use somatório telescópico para erro acumulado.",
                                  "learningObjective": "Derivar analiticamente e validar numericamente que erro global é O(h).",
                                  "commonMistakes": "Esquecer fator exponencial de amplificação; confundir ordem local (2) com global (1)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade em Problemas Stiff",
                                  "subSteps": [
                                    "Defina problemas stiff: autovalores com partes reais muito negativas e discrepantes.",
                                    "Examine região de estabilidade absoluta do Euler implícito (meio-plano esquerdo).",
                                    "Simule um problema stiff como y' = -1000 y + sin(t) e compare com explícito.",
                                    "Meça passos necessários para precisão ε em stiff vs não-stiff.",
                                    "Discuta A-stabilidade: método incondicionalmente estável para Re(λ)<0."
                                  ],
                                  "verification": "Simulação stiff converge sem oscilações para h grande, ao contrário do explícito.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python com scipy.integrate (odeint/ivp), gráficos de solução vs tempo.",
                                  "tips": "Escolha λ = -10^4 para stiff claro; normalize soluções para comparação.",
                                  "learningObjective": "Reconhecer como Euler implícito lida com stiff via estabilidade A.",
                                  "commonMistakes": "Usar h muito pequeno inicialmente, mascarando instabilidade; ignorar custo computacional implícito."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Trade-offs entre Estabilidade e Precisão",
                                  "subSteps": [
                                    "Liste prós: estabilidade incondicional permite h maior em stiff.",
                                    "Liste contras: ordem baixa O(h) exige h pequeno para precisão; custo por passo maior (solver linear).",
                                    "Compare com métodos de ordem superior (ex: BDF2, Runge-Kutta implícita).",
                                    "Avalie em tabela: precisão vs h, custo total (passos x tempo/passos).",
                                    "Conclua quando usar: stiff prioritário vs precisão alta."
                                  ],
                                  "verification": "Tabela ou gráfico mostra trade-off quantitativo para problema teste.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel ou Jupyter para tabelas, referências como Hairer 'Solving ODEs'.",
                                  "tips": "Use métrica custo-benefício: tempo total para erro <10^{-4}.",
                                  "learningObjective": "Avaliar racionalmente trade-offs para seleção de método.",
                                  "commonMistakes": "Superestimar estabilidade sem considerar custo; ignorar que ordem baixa limita precisão."
                                }
                              ],
                              "practicalExample": "Resolva y' = -1001 y + 1000 e^{-t}, y(0)=1 (stiff), com h=0.01 usando Euler implícito. Compare erro global em t=1 com solução exata y(t)=(1+e^{-t})/2. Plote erro vs h para 0.001≤h≤0.1, confirme O(h), e mostre falha do explícito para h>0.002.",
                              "finalVerifications": [
                                "Derivação analítica mostra erro global ≤ C h para constante C.",
                                "Gráfico log-log confirma inclinação 1 para erro vs h.",
                                "Simulação stiff converge estável para h=0.05, explícito diverge.",
                                "Tabela compara custo: implícito 2x mais lento por passo mas 10x menos passos.",
                                "Explicação verbal correta de trade-offs em stiff vs não-stiff.",
                                "Identifica A-estabilidade como chave para problemas reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de erro global O(h) (correto bounding).",
                                "Validação numérica com gráficos e dados quantitativos.",
                                "Análise correta de estabilidade em stiff (região vs Dahlquist).",
                                "Discussão equilibrada de trade-offs com exemplos numéricos.",
                                "Clareza na identificação de erros comuns e mitigações.",
                                "Aplicação coerente ao contexto de problemas stiff."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RLC stiff ou dinâmica molecular.",
                                "Engenharia: Simulações de controle em sistemas com polos rápidos.",
                                "Computação: Otimização de solvers numéricos em bibliotecas como SciPy.",
                                "Química: Cinética de reações com escalas rápidas/lentas."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos stiff (reações rápidas/lentas), Euler implícito permite h maior sem instabilidade, reduzindo tempo de CPU em 90% vs explícito, essencial para otimização em indústrias farmacêuticas e petroquímicas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.4",
                            "name": "Implementar algoritmo completo em pseudocódigo",
                            "description": "Escrever pseudocódigo para o método incluindo solver não linear e controle básico de tolerância para convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura geral do algoritmo de Euler Implícito",
                                  "subSteps": [
                                    "Identifique os parâmetros de entrada: função f(t,y), t0, y0, tf, h, tolerância (tol).",
                                    "Defina variáveis iniciais: t = t0, y = y0, n_steps = (tf - t0)/h.",
                                    "Esboce o loop principal: enquanto t < tf, compute y_next resolvendo a equação implícita, atualize t = t + h, y = y_next.",
                                    "Inclua saída: armazene ou imprima valores de t e y em cada passo.",
                                    "Adicione cabeçalho com comentários explicando o método para problemas stiff."
                                  ],
                                  "verification": "Verifique se o esboço do loop principal captura a iteração implícita sem avançar t antes de resolver y_next.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, editor de texto, referência ao capítulo de Análise Numérica.",
                                  "tips": "Use indentação clara para representar blocos de código no pseudocódigo.",
                                  "learningObjective": "Compreender a arquitetura global do método implícito diferenciando-o do explícito.",
                                  "commonMistakes": "Confundir atualização de t e y, ou esquecer de tratar o caso implícito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a equação não linear para o passo implícito",
                                  "subSteps": [
                                    "Escreva a fórmula do Euler Implícito: y_{n+1} = y_n + h * f(t_{n+1}, y_{n+1}).",
                                    "Reformule como g(y_{n+1}) = y_n + h * f(t_{n+1}, y_{n+1}) - y_{n+1} = 0.",
                                    "Defina uma função residual R(z) = z - y_n - h * f(t + h, z), onde z é a aproximação de y_{n+1}.",
                                    "Inicialize a guess inicial z0 = y_n (preditor simples).",
                                    "Comente no pseudocódigo a motivação para problemas stiff."
                                  ],
                                  "verification": "Confirme que R(z) = 0 define corretamente y_{n+1} e que z0 é razoável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de rascunho para equações, calculadora para testes simbólicos.",
                                  "tips": "Teste a formulação com um f linear simples para validar.",
                                  "learningObjective": "Dominar a derivação da equação não linear inerente ao método implícito.",
                                  "commonMistakes": "Erros de sinal na residual ou uso incorreto de t_{n+1}."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o solver não linear com iteração de ponto fixo ou Newton básico",
                                  "subSteps": [
                                    "Escolha método: para simplicidade, use iteração de ponto fixo z^{k+1} = y_n + h * f(t + h, z^k).",
                                    "Defina loop interno: k=0, while |z^{k+1} - z^k| > tol and k < max_iter.",
                                    "Atualize z^{k+1}, incremente k, cheque convergência.",
                                    "Defina max_iter = 100, tol = 1e-6 como padrão.",
                                    "Atribua y_next = z^{k+1} após convergência ou erro se exceder max_iter."
                                  ],
                                  "verification": "Simule manualmente 2-3 iterações para uma f conhecida e confirme redução de erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de pseudocódigo, exemplos de solvers de livros-texto.",
                                  "tips": "Prefira ponto fixo para stiff iniciais; mencione transição para Newton se necessário.",
                                  "learningObjective": "Implementar um solver iterativo robusto para equações não lineares.",
                                  "commonMistakes": "Loop infinito sem max_iter, ou critério de parada fraco."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar controle de tolerância, tratamento de erros e finalização",
                                  "subSteps": [
                                    "Integre tol e max_iter nos loops, com mensagem de erro se não convergir.",
                                    "Adicione controle adaptativo básico: se não convergir, reduza h e reinicie.",
                                    "Inclua vetor de saída para t e y.",
                                    "Adicione comentários finais resumindo estabilidade para stiff.",
                                    "Teste logicamente o pseudocódigo com fluxograma."
                                  ],
                                  "verification": "Revise todo o pseudocódigo por completude e ausência de loops infinitos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de fluxograma online, pseudocódigo completo impresso.",
                                  "tips": "Use pseudocódigo estruturado com IF/WHILE claros para legibilidade.",
                                  "learningObjective": "Garantir robustez e usabilidade prática do algoritmo.",
                                  "commonMistakes": "Ignorar falhas de convergência ou não tratar h pequeno."
                                }
                              ],
                              "practicalExample": "Para y' = -1000*y + sin(t), y(0)=1 (stiff), h=0.01, tol=1e-6: Inicie t=0, y=1. No primeiro passo, z0=1, itere z1=1 + 0.01*(-1000*1 + sin(0.01)) ≈ 0.1099, continue até |z^{k+1}-z^k|<1e-6, obtenha y1≈0.9048, avance t=0.01.",
                              "finalVerifications": [
                                "Pseudocódigo executa sem loops infinitos em simulação manual.",
                                "Solver converge para exemplos stiff conhecidos em <50 iterações.",
                                "Valores de y aproximam solução exata dentro de 1%.",
                                "Tratamento de erro ativa se tol não atingida.",
                                "Estrutura segue lógica temporal correta (t antes de y_next).",
                                "Comentários explicam cada seção majoritária."
                              ],
                              "assessmentCriteria": [
                                "Clareza e legibilidade do pseudocódigo (indentação, nomes variáveis).",
                                "Correção matemática da formulação implícita e residual.",
                                "Robustez do solver não linear (tol, max_iter, inicialização).",
                                "Controle de convergência e tratamento de falhas.",
                                "Completude: inclui todos parâmetros e saída.",
                                "Adequação a problemas stiff via comentários e estrutura."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de loops e funções em linguagens como Python.",
                                "Física: Modelagem de sistemas dinâmicos stiff (osciladores amortecidos).",
                                "Engenharia: Simulações numéricas em controle de processos.",
                                "Computação Científica: Bibliotecas como SciPy ode solvers."
                              ],
                              "realWorldApplication": "Em engenharia química, simula reações stiff em reatores onde escalas de tempo variam drasticamente, permitindo previsões estáveis de concentrações sem crash numérico."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Métodos Runge-Kutta de Ordem Superior",
                    "description": "Família de métodos de passo simples com maior precisão, como RK2 e RK4, utilizando múltiplas avaliações da função f(t,y).",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Família de Métodos Runge-Kutta",
                        "description": "Introdução à família de métodos Runge-Kutta de ordem superior, que são métodos de passo simples explícitos com maior precisão através de múltiplas avaliações intermediárias da função f(t,y), representados pelo tableau de Butcher.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Compreender o tableau de Butcher",
                            "description": "Identificar e interpretar os coeficientes A, b e c no tableau de Butcher para métodos Runge-Kutta, relacionando-os à fórmula geral do método.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura geral do tableau de Butcher",
                                  "subSteps": [
                                    "Examine um exemplo clássico de tableau de Butcher para o método RK4.",
                                    "Identifique as dimensões: s estágios, matriz A de s x s, vetores b e c de tamanho s.",
                                    "Observe a posição dos elementos: c na primeira coluna (exceto c1=0), A abaixo de c, b na última linha.",
                                    "Desenhe um tableau vazio e rotule as regiões A, b e c.",
                                    "Compare tableaus de métodos explícitos (triangular inferior) e implícitos."
                                  ],
                                  "verification": "Desenhar corretamente um tableau vazio com rótulos para A, b e c.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Imagem ou tabela de tableau RK4 clássico"
                                  ],
                                  "tips": "Sempre comece pela primeira coluna para c_i, pois representa os nós de amostragem temporal.",
                                  "learningObjective": "Reconhecer a representação tabular padronizada dos coeficientes de métodos Runge-Kutta.",
                                  "commonMistakes": [
                                    "Confundir vetor b com c",
                                    "Ignorar que para métodos explícitos A é estritamente triangular inferior",
                                    "Esquecer que o tableau tem s+1 linhas e s+1 colunas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o vetor c (nós de Butcher)",
                                  "subSteps": [
                                    "Defina c_i como os coeficientes de tempo nos estágios intermediários: t_{n,i} = t_n + c_i h.",
                                    "Calcule os c_i para métodos conhecidos, como RK2 de Heun (c = [0,1]).",
                                    "Relacione c_i à soma ponderada na matriz A: a_{i,j} pesos de estágios anteriores.",
                                    "Verifique propriedades: para métodos consistentes, sum(b_i) = 1 e sum(a_{i,j}) = c_i.",
                                    "Discuta escolhas de c_i (ex: Gauss-Legendre para ordem alta)."
                                  ],
                                  "verification": "Dado um tableau, listar corretamente os valores de c e explicar seu papel na aproximação temporal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha com fórmulas RK",
                                    "Calculadora para somas"
                                  ],
                                  "tips": "c_i indica 'quando' cada estágio é avaliado no intervalo [t_n, t_{n+1}].",
                                  "learningObjective": "Compreender o vetor c como nós temporais nos métodos RK.",
                                  "commonMistakes": [
                                    "Achar que c1 sempre é 1",
                                    "Não verificar sum(a_{i,j}) = c_i para consistência",
                                    "Confundir c com pesos de integração b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a matriz A e o vetor b",
                                  "subSteps": [
                                    "Defina A = [a_{i,j}] onde a_{i,j} é o peso do estágio j no cálculo do estágio i.",
                                    "Para métodos explícitos, compute k_i = f(t_n + c_i h, y_n + h sum_{j=1}^{i-1} a_{i,j} k_j).",
                                    "Identifique b_i como pesos finais: y_{n+1} = y_n + h sum_{i=1}^s b_i k_i.",
                                    "Verifique ordem do método via condições de Butcher (ex: para ordem 2, b_i c_i + b_i sum a_{i,j} c_j = 1/2).",
                                    "Compare A e b em diferentes métodos (RK4 vs Dormand-Prince)."
                                  ],
                                  "verification": "Extrair A e b de um tableau e escrever a fórmula de um estágio intermediário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de tableaus impressos",
                                    "Software como Python para visualizar (opcional)"
                                  ],
                                  "tips": "A é a 'receita' para combinar k's intermediários; b é a 'média final'.",
                                  "learningObjective": "Interpretar A como coeficientes de combinação e b como pesos de extrapolação.",
                                  "commonMistakes": [
                                    "Usar índices errados em somas (j>i para explícitos)",
                                    "Esquecer normalização sum b_i =1",
                                    "Confundir A com matriz de Jacobi"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar o tableau à fórmula geral do método Runge-Kutta",
                                  "subSteps": [
                                    "Escreva a fórmula geral RK: k_i = f(t_n + c_i h, y_n + h sum_{j=1}^s a_{i,j} k_j), y_{n+1} = y_n + h sum b_i k_i.",
                                    "Dado um tableau, implemente a fórmula para um problema teste simples (ex: y' = y).",
                                    "Verifique condições de ordem usando o tableau (consistência, ordem 1-4).",
                                    "Discuta famílias RK: Radau, Gauss, etc., via suas tableaus.",
                                    "Resolva um exercício: reconstrua o método a partir do tableau."
                                  ],
                                  "verification": "Dado um tableau, derivar e aplicar a fórmula RK para um passo numérico.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Problema de EDO simples",
                                    "Calculadora ou planilha"
                                  ],
                                  "tips": "Sempre teste com y'=λy para ver estabilidade via tableau.",
                                  "learningObjective": "Conectar visualmente o tableau à implementação algébrica do método.",
                                  "commonMistakes": [
                                    "Erro na indexação das somas",
                                    "Não normalizar b",
                                    "Ignorar dependência em métodos implícitos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o RK4 clássico (ordem 4, 4 estágios):\n\\begin{array}{c|cccc}\n0 & & & & \\\\\n1/2 & 1/2 & & & \\\\\n1/2 & 0 & 1/2 & & \\\\\n1 & 0 & 0 & 1 \\\\\n\\hline\n & 1/6 & 1/3 & 1/3 & 1/6\n\\end{array}\nAqui, c=[0,0.5,0.5,1], A=[[0,..],[0.5,0,..],...], b=[1/6,1/3,1/3,1/6]. Aplique para y'= -y, y(0)=1, h=0.1: compute k1=f(0,1), k2=f(0.05,1+0.05*k1), etc., y1=1 + 0.1*(k1/6 + ...).",
                              "finalVerifications": [
                                "Explicar verbalmente o papel de A, b e c em um método RK.",
                                "Dado um tableau, identificar se é explícito/implícito e estimar ordem.",
                                "Reconstruir a fórmula RK completa a partir do tableau.",
                                "Verificar condições de consistência: sum b_i=1, sum_j a_{i,j}=c_i.",
                                "Aplicar o método a um EDO linear simples e comparar com solução exata.",
                                "Diferenciar tableaus de diferentes famílias RK (ex: Gauss vs Radau)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de A, b, c (100% correto).",
                                "Correta derivação da fórmula geral RK do tableau.",
                                "Verificação de propriedades (consistência, ordem mínima).",
                                "Explicação clara de interpretações físicas/matemáticas.",
                                "Ausência de erros comuns em somas e indexação.",
                                "Capacidade de relacionar a tableaus reais (RK4, DOPRI5)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar solvers RK em Python (SciPy odeint usa tableaus).",
                                "Física: Simulações de dinâmica orbital (N-body problems).",
                                "Engenharia: Controle de sistemas dinâmicos e simulações CFD.",
                                "Estatística: Integração estocástica (SDEs via RK adaptativos)."
                              ],
                              "realWorldApplication": "Os tableaus de Butcher são fundamentais em softwares de simulação científica como MATLAB (ode45), Python SciPy e NASA solvers para modelagem climática, previsão financeira de derivativos, simulações biomédicas (difusão de fármacos) e engenharia aeroespacial (trajectories de foguetes), permitindo métodos RK eficientes e de alta ordem para EDOs rígidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Entender a ordem de precisão",
                            "description": "Explicar como a ordem de um método Runge-Kutta é determinada pelas condições de ordem no tableau e como ordens superiores reduzem o erro local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Tableau de Butcher e Conceitos Básicos de Ordem",
                                  "subSteps": [
                                    "Estude a estrutura geral do método Runge-Kutta: y_{n+1} = y_n + h ∑ b_i k_i.",
                                    "Identifique os componentes do tableau de Butcher: coeficientes a_{ij}, b_i e c_i.",
                                    "Revise o conceito de erro local de truncamento (LTE) e sua relação com a ordem p.",
                                    "Analise um exemplo simples de RK2 para visualizar o tableau.",
                                    "Anote as equações que definem a ordem p como a maior potência onde o método é exato para polinômios."
                                  ],
                                  "verification": "Construa manualmente o tableau de um método RK2 e explique verbalmente sua estrutura.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel ou software de desenho (ex: Draw.io)",
                                    "Notas de aula sobre Runge-Kutta",
                                    "Livro de Análise Numérica (capítulo de métodos RK)"
                                  ],
                                  "tips": [
                                    "Comece com métodos de baixa ordem para fixar ideias.",
                                    "Desenhe o tableau em voz alta para reforçar memória visual."
                                  ],
                                  "learningObjective": "Compreender a representação matricial do método Runge-Kutta via tableau.",
                                  "commonMistakes": [
                                    "Confundir b_i com c_i.",
                                    "Ignorar que c_i = ∑ a_{ij} para consistência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender as Condições de Ordem p",
                                  "subSteps": [
                                    "Defina as condições elementares: ∑ b_i = 1 (ordem 1), ∑ b_i c_i = 1/2 (ordem 2), etc.",
                                    "Liste as condições de ordem até p=4: ordem 1 (1 eq.), ordem 2 (1 nova), ordem 3 (2 novas), ordem 4 (4 novas).",
                                    "Resolva as condições para um método de 2 estágios (RK2).",
                                    "Verifique numericamente se um tableau satisfaz ordem p usando expansão em série de Taylor.",
                                    "Compare tableaux que falham em uma condição específica."
                                  ],
                                  "verification": "Escreva e resolva as condições para ordem 2 em um tableau de 2 estágios.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (ex: SymPy, Mathematica)",
                                    "Tabela de condições de ordem padrão",
                                    "Exemplos de tableaux RK2 e RK3"
                                  ],
                                  "tips": [
                                    "Use somas ponderadas sistematicamente: comece com ∑ b_i α_i = β para cada condição.",
                                    "Teste com h pequeno em um PVI simples para validar."
                                  ],
                                  "learningObjective": "Dominar as equações algébricas que determinam a ordem de precisão.",
                                  "commonMistakes": [
                                    "Esquecer condições de ordem superior que envolvem produtos duplos ∑ b_i a_{ij} c_j.",
                                    "Assumir simetria no tableau sem justificativa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Impacto da Ordem Superior no Erro Local",
                                  "subSteps": [
                                    "Expanda o LTE: τ = O(h^{p+1}), onde p é a ordem.",
                                    "Derive qualitativamente por que ordens maiores reduzem o expoente do erro.",
                                    "Compare erros numéricos para RK2, RK4 em um PVI não linear (ex: y' = y^2).",
                                    "Calcule o fator de redução de erro ao dobrar estágios para ordem superior.",
                                    "Discuta trade-offs: mais estágios vs. custo computacional."
                                  ],
                                  "verification": "Simule um PVI com RK2 e RK4, plote log(erro) vs log(h) e confirme inclinação p+1.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software de programação (Python com NumPy/SciPy)",
                                    "PVI de teste: y' = -y, y(0)=1",
                                    "Gráficos de convergência"
                                  ],
                                  "tips": [
                                    "Use richardson extrapolation para estimar ordem real.",
                                    "Escolha h variando de 0.1 a 0.001 para boa visualização."
                                  ],
                                  "learningObjective": "Relacionar ordem p com redução quantitativa do erro local de truncamento.",
                                  "commonMistakes": [
                                    "Confundir erro local com global.",
                                    "Ignorar que ordem superior requer mais avaliações de f."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Sintetizar o Conhecimento",
                                  "subSteps": [
                                    "Construa um tableau RK3 satisfazendo condições até ordem 3.",
                                    "Teste o método em um PVI e compare com solução exata.",
                                    "Explique em um parágrafo como ordens superiores minimizam LTE.",
                                    "Identifique limitações: ordem > s+1 impossível para s estágios.",
                                    "Resuma as condições principais em uma tabela pessoal."
                                  ],
                                  "verification": "Apresente um tableau RK4 clássico e liste todas as 11 condições de ordem 4 satisfeitas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para tableau",
                                    "Solução exata de PVIs teste",
                                    "Referência: Hairer 'Solving ODEs I'"
                                  ],
                                  "tips": [
                                    "Memorize padrões: condições de ordem ímpar têm mais termos.",
                                    "Pratique com métodos clássicos como Gauss-Legendre."
                                  ],
                                  "learningObjective": "Aplicar integralmente o conceito de ordem em métodos RK.",
                                  "commonMistakes": [
                                    "Achar que mais estágios sempre implicam ordem superior sem condições.",
                                    "Não normalizar h no cálculo de erro."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o método RK4 clássico (s=4 estágios). Seu tableau satisfaz 11 condições até ordem 4, reduzindo LTE para O(h^5). Implemente em Python para y' = sin(y), y(0)=1, h=0.1, e observe erro ~10^{-5} vs. RK2 ~10^{-3}.",
                              "finalVerifications": [
                                "Explicar verbalmente as condições de ordem 1-3.",
                                "Construir tableau RK2 correto.",
                                "Plotar convergência confirmando p via slope log-log.",
                                "Discutir por que RK4 é preferido em prática.",
                                "Identificar falha em tableau incompleto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de condições de ordem (90% corretas).",
                                "Correta interpretação de impacto no LTE (O(h^{p+1})).",
                                "Exemplo prático com simulação numérica válida.",
                                "Análise de trade-offs computacionais.",
                                "Síntese clara em tabela ou diagrama.",
                                "Ausência de erros comuns como confusão de coeficientes."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de trajetórias em dinâmica newtoniana.",
                                "Programação: Implementação eficiente em SciPy odeint.",
                                "Estatística: Modelagem estocástica com ordens altas para precisão.",
                                "Engenharia: Controle de sistemas com EDOs rígidas."
                              ],
                              "realWorldApplication": "Em previsão meteorológica (modelos ECMWF), métodos RK de ordem 5-6 minimizam erros locais em simulações de longo prazo, permitindo previsões precisas de furacões com h~minutos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Comparar com métodos de Euler",
                            "description": "Analisar as vantagens dos métodos RK de ordem superior sobre o método de Euler modificado, destacando o ganho em precisão com custo computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Euler Modificado",
                                  "subSteps": [
                                    "Lembre-se da fórmula do método de Euler modificado: y_{n+1} = y_n + (h/2)(f(t_n, y_n) + f(t_n + h, y_n + h f(t_n, y_n)))",
                                    "Identifique o erro de truncamento local O(h^3) e global O(h^2)",
                                    "Implemente o método em pseudocódigo para uma EDO de teste y' = -y, y(0)=1"
                                  ],
                                  "verification": "Implemente e execute o método para h=0.1, verificando se o resultado em t=1 está próximo de e^{-1} ≈ 0.3679",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de código (Python/MATLAB)",
                                    "Calculadora ou software de plotagem"
                                  ],
                                  "tips": "Use uma EDO linear simples para facilitar cálculos manuais",
                                  "learningObjective": "Compreender a estrutura e precisão do Euler modificado",
                                  "commonMistakes": "Confundir com Euler simples (erro local O(h^2))"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Métodos Runge-Kutta de Ordem Superior (ex: RK4)",
                                  "subSteps": [
                                    "Estude a fórmula geral de RK: k1 = f(t_n, y_n), k2 = f(t_n + h/2, y_n + h k1/2), etc., até k4",
                                    "Calcule os coeficientes de Butcher para RK4 clássico",
                                    "Compare o erro de truncamento local O(h^5) e global O(h^4)"
                                  ],
                                  "verification": "Derive ou recite a fórmula completa de RK4 e compute k_i para a mesma EDO y'=-y",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de métodos RK ou livro de análise numérica",
                                    "Software para verificação numérica"
                                  ],
                                  "tips": "Memorize os pesos de RK4: b1=0, b2=0, b3=0, b4=1; estágios médios com 1/2,1/2,1",
                                  "learningObjective": "Dominar a mecânica de métodos RK de ordem superior",
                                  "commonMistakes": "Erros nos argumentos de k2,k3,k4 (pontos intermediários errados)"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Precisão entre Euler Modificado e RK Superior",
                                  "subSteps": [
                                    "Compute erro local: Euler mod O(h^3) vs RK4 O(h^5)",
                                    "Analise erro global e convergência via tabelas de erro para h decrescente",
                                    "Plote soluções numéricas vs exata para visualizar ganho em precisão"
                                  ],
                                  "verification": "Gere tabela mostrando erro em t=1 para h=0.1,0.05,0.01; RK4 deve ser ~16x mais preciso que Euler mod",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python (numpy, matplotlib)",
                                    "EDO de teste com solução conhecida"
                                  ],
                                  "tips": "Use norma do erro máximo ou RMS para quantificação objetiva",
                                  "learningObjective": "Quantificar vantagens em precisão dos métodos RK",
                                  "commonMistakes": "Ignorar dependência em h; comparar com h fixo sem redução"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Custo Computacional e Trade-offs",
                                  "subSteps": [
                                    "Conte avaliações de f: Euler mod=2 vs RK4=4 por passo",
                                    "Calcule FLOPs aproximados: RK4 ~4x mais caro que Euler mod",
                                    "Discuta quando usar cada: Euler mod para rascunho rápido, RK para precisão alta"
                                  ],
                                  "verification": "Para 1000 passos, compare tempo de CPU ou FLOPs; justifique escolha baseada em tolerância de erro",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cronômetro de código ou profiler simples",
                                    "Mesma EDO com N=1000 passos"
                                  ],
                                  "tips": "Considere step adaptativo para reduzir custo em RK",
                                  "learningObjective": "Avaliar custo-benefício e cenários ótimos",
                                  "commonMistakes": "Subestimar overhead de RK em problemas stiff"
                                }
                              ],
                              "practicalExample": "Resolva y' = y(1-y), y(0)=0.5 (modelo logístico) até t=5 com h=0.1. Euler mod erra ~5%, RK4 <0.1%; RK4 leva 2x tempo mas precisão vastly superior.",
                              "finalVerifications": [
                                "Explicar por que RK4 tem erro local O(h^5)",
                                "Produzir tabela comparativa de erros para h variados",
                                "Identificar que RK4 requer 4 vs 2 eval(f) do Euler mod",
                                "Justificar uso de RK em simulações precisas vs Euler para protótipos"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de erros de truncamento (90% correto)",
                                "Tabela de comparação quantitativa completa",
                                "Análise equilibrada de trade-offs custo/precisão",
                                "Exemplo numérico com plots ou valores exatos"
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de trajetórias orbitais (melhor precisão com RK)",
                                "Computação: Otimização de algoritmos numéricos em SciPy/ODEPACK",
                                "Engenharia: Controle de sistemas dinâmicos com custo computacional limitado"
                              ],
                              "realWorldApplication": "Em previsão meteorológica, RK4 permite simulações climáticas mais precisas com custo aceitável em supercomputadores, superando Euler mod que diverge rapidamente em longas integrações."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Método Runge-Kutta de Ordem 2 (RK2)",
                        "description": "Método RK2 clássico, derivado da expansão em série de Taylor, utilizando duas avaliações da função f para alcançar precisão de ordem 2.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Derivar o método RK2",
                            "description": "Derivar o método RK2 a partir da série de Taylor ou condições de ordem, obtendo os coeficientes específicos (ex: k1 = f(t_n, y_n), k2 = f(t_n + h, y_n + h k1)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar a expansão em série de Taylor da solução exata",
                                  "subSteps": [
                                    "Lembre a equação diferencial y' = f(t, y) com y(t_0) = y_0.",
                                    "Escreva y(t_n + h) = y(t_n) + h y'(t_n) + (h^2/2) y''(t_n) + O(h^3).",
                                    "Expresse as derivadas superiores: y'' = d/dt f(t,y) = f_t + f_y f, usando a regra da cadeia.",
                                    "Identifique os termos até ordem 2 para matching posterior.",
                                    "Anote a expansão truncada até O(h^3)."
                                  ],
                                  "verification": "Verifique se a expansão de Taylor está correta substituindo em um exemplo simples como y' = y.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (capítulo Taylor)"
                                  ],
                                  "tips": "Comece com y(t) genérico e derive passo a passo para evitar confusão com notação.",
                                  "learningObjective": "Compreender a base analítica da precisão local de métodos numéricos.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/2 em y''",
                                    "Confundir y' com f diretamente sem chain rule"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a forma geral do método RK2",
                                  "subSteps": [
                                    "Defina a aproximação numérica: y_{n+1} = y_n + b1 h k1 + b2 h k2.",
                                    "Especifique k1 = f(t_n, y_n).",
                                    "Defina k2 = f(t_n + c2 h, y_n + a21 h k1), com coeficientes a21, b1, b2, c2 a determinar.",
                                    "Escreva o tableau de Butcher simplificado para RK2.",
                                    "Discuta que precisamos matching até ordem 2."
                                  ],
                                  "verification": "Confirme que a forma tem 2 estágios e parâmetros livres.",
                                  "estimatedTime": "15 min",
                                  "materials": [
                                    "Quadro branco ou software como LaTeX para tabelas"
                                  ],
                                  "tips": "Use notação padrão Butcher para clareza visual.",
                                  "learningObjective": "Familiarizar-se com a estrutura paramétrica dos métodos RK.",
                                  "commonMistakes": [
                                    "Confundir k1 e k2 com Euler",
                                    "Esquecer o h nos incrementos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir k1 e k2 em série de Taylor e combinar",
                                  "subSteps": [
                                    "Expanda k1 = f(t_n, y_n).",
                                    "Expanda k2: f(t_n + c2 h, y_n + a21 h k1) = f + h c2 f_t + h a21 k1 f_y + (h^2/2) termos quadráticos.",
                                    "Substitua na y_{n+1} e colete termos até h^2.",
                                    "Compare com a Taylor exata: coef de h: b1 + b2 = 1; coef de h^2: b2 c2 + b2 a21 = 1/2.",
                                    "Ignore O(h^3)."
                                  ],
                                  "verification": "Equacione os coeficientes e veja se formam 2 equações para 4 variáveis.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Calculadora simbólica ou papel para expansões"
                                  ],
                                  "tips": "Expanda f em multivariável: df = f_t dt + f_y dy.",
                                  "learningObjective": "Aplicar expansões de Taylor compostas em métodos numéricos.",
                                  "commonMistakes": [
                                    "Erros em chain rule para k2",
                                    "Não multiplicar h corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema de condições de ordem e obter coeficientes",
                                  "subSteps": [
                                    "Resolva b1 + b2 = 1.",
                                    "Resolva b2 (c2 + a21) = 1/2.",
                                    "Escolha valores livres: tipicamente c2=1, a21=1, então b2=1/2, b1=1/2.",
                                    "Verifique: k1 = f(t_n, y_n), k2 = f(t_n + h, y_n + h k1), y_{n+1} = y_n + (h/2)(k1 + k2).",
                                    "Confirme ordem 2 escrevendo trunc error O(h^3)."
                                  ],
                                  "verification": "Implemente em um ODE teste e compare com solução exata.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Exemplo numérico pronto",
                                    "Software como Python/MATLAB para verificação opcional"
                                  ],
                                  "tips": "Existem famílias RK2; foque no Heun's method clássico.",
                                  "learningObjective": "Derivar explicitamente coeficientes via ordem conditions.",
                                  "commonMistakes": [
                                    "Solução inconsistente do sistema",
                                    "Confundir com RK4"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1 (solução exata e^t). Compute k1 = y_n, k2 = (y_n + h y_n) e^{h} ≈ mas derive: y1 = y0 + (h/2)(k1 + k2) = y0 (1 + h + (h^2)/2), matching Taylor de e^h até h^2.",
                              "finalVerifications": [
                                "Expansão de Taylor exata escrita corretamente até ordem 2.",
                                "Forma geral RK2 com k1, k2 parametrizados.",
                                "Sistema de equações de ordem resolvido: b1 + b2 =1, b2(c2 + a21)=1/2.",
                                "Coeficientes específicos obtidos: ex. b1=b2=1/2, c2=a21=1.",
                                "Verificação numérica em ODE linear simples converge com ordem 2.",
                                "Truncation error identificado como O(h^3)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão de Taylor (incluindo y'').",
                                "Correta definição e expansão de k2.",
                                "Resolução correta do sistema linear de condições.",
                                "Identificação do método RK2 clássico (Heun).",
                                "Explicação clara do matching de coeficientes.",
                                "Ausência de erros algébricos nos cálculos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de trajetórias em mecânica (e.g., osciladores).",
                                "Computação: Implementação em código para solvers ODE (SciPy).",
                                "Engenharia: Simulações dinâmicas em controle de sistemas.",
                                "Estatística: Propagação de erros em métodos numéricos."
                              ],
                              "realWorldApplication": "O RK2 é usado em simulações de trajetórias espaciais (NASA), modelagem climática e finanças quantitativas para resolver ODEs com eficiência moderada, balanceando precisão e custo computacional."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Implementar RK2 numericamente",
                            "description": "Escrever um algoritmo ou código em pseudocódigo para aplicar o método RK2 em um PVI y' = f(t,y), y(t0)=y0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e formular a fórmula do método RK2",
                                  "subSteps": [
                                    "Recordar a definição de um Problema de Valor Inicial (PVI): y' = f(t,y), y(t0) = y0.",
                                    "Estudar a fórmula do RK2 (versão ponto médio): k1 = f(t_n, y_n), k2 = f(t_n + h/2, y_n + (h/2) k1), y_{n+1} = y_n + h k2.",
                                    "Identificar os parâmetros principais: h (passo), t_n, y_n.",
                                    "Escrever a fórmula em pseudocódigo para um único passo.",
                                    "Verificar a ordem de precisão (O(h^2)) comparando com Euler."
                                  ],
                                  "verification": "Escrever corretamente a fórmula RK2 em um papel ou editor, sem erros nos k1 e k2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica ou notas de aula"
                                  ],
                                  "tips": "Use diagramas de Butcher para visualizar os estágios do RK2.",
                                  "learningObjective": "Dominar a estrutura matemática do método RK2 para implementação precisa.",
                                  "commonMistakes": [
                                    "Confundir com RK4 (mais estágios)",
                                    "Esquecer o fator h/2 em k2",
                                    "Usar k1 em vez de k2 na atualização final"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o problema e parâmetros iniciais",
                                  "subSteps": [
                                    "Escolher ou definir a função f(t,y), ex: f(t,y) = -y.",
                                    "Especificar condições iniciais: t0, y0.",
                                    "Definir o passo h e o número de passos N ou tfinal.",
                                    "Inicializar variáveis: t = t0, y = y0, arrays para armazenar resultados.",
                                    "Planejar a saída: tabela com t, y aproximado."
                                  ],
                                  "verification": "Listar todos os parâmetros em um bloco de pseudocódigo inicial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto simples (Notepad++)",
                                    "Calculadora para testes iniciais"
                                  ],
                                  "tips": "Escolha h pequeno (ex: 0.1) para precisão inicial.",
                                  "learningObjective": "Preparar todos os inputs necessários para o algoritmo RK2.",
                                  "commonMistakes": [
                                    "Definir h muito grande causando instabilidade",
                                    "Esquecer y0",
                                    "Não definir limites de t"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o cálculo de um passo RK2 em pseudocódigo",
                                  "subSteps": [
                                    "Calcular k1 = h * f(t, y).",
                                    "Calcular k2 = h * f(t + h/2, y + 0.5 * k1).",
                                    "Atualizar t = t + h.",
                                    "Atualizar y = y + k2.",
                                    "Armazenar valores de t e y em listas ou tabela."
                                  ],
                                  "verification": "Executar manualmente um passo com valores numéricos e conferir cálculo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de pseudocódigo",
                                    "Planilha Excel para verificação manual"
                                  ],
                                  "tips": "Sempre multiplique por h nos k's para consistência dimensional.",
                                  "learningObjective": "Codificar corretamente os estágios intermediários do RK2.",
                                  "commonMistakes": [
                                    "Usar h em vez de h/2 no argumento de k2",
                                    "Atualizar y com k1 ao invés de k2",
                                    "Não escalar k1 por 0.5"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estruturar o loop para múltiplos passos e saída",
                                  "subSteps": [
                                    "Implementar um loop WHILE ou FOR até t <= tfinal.",
                                    "Dentro do loop, executar os cálculos de k1, k2 e atualizações.",
                                    "Imprimir ou salvar tabela: colunas t, y.",
                                    "Adicionar cabeçalho e rodapé na tabela.",
                                    "Testar o pseudocódigo com 2-3 passos manualmente."
                                  ],
                                  "verification": "Simular 3 passos e comparar com solução exata se conhecida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Papel para simulação manual"
                                  ],
                                  "tips": "Use laços indexados para facilitar depuração.",
                                  "learningObjective": "Criar um algoritmo completo e iterativo para RK2.",
                                  "commonMistakes": [
                                    "Loop infinito por condição errada",
                                    "Não atualizar t corretamente",
                                    "Erro de indentação no pseudocódigo"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente RK2 para y' = -2y, y(0)=1, h=0.2, até t=1.0. Solução exata: y(t)=exp(-2t). Após 5 passos, y(1.0) ≈ 0.1353 (compare com exata ≈0.1353). Pseudocódigo: k1 = h*(-2*y), k2 = h*(-2*(y + 0.5*k1)), y = y + k2, t = t + h.",
                              "finalVerifications": [
                                "Pseudocódigo produz tabela correta para exemplo dado.",
                                "Fórmulas de k1 e k2 estão precisas (h/2 e 0.5*k1).",
                                "Loop itera corretamente sem erros de limite.",
                                "Valores numéricos coincidem com cálculos manuais em pelo menos 3 passos.",
                                "Comentários explicam cada linha principal.",
                                "Estrutura segue padrão: init, loop, output."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da fórmula RK2 (peso 30%).",
                                "Estrutura lógica do pseudocódigo e loop (peso 25%).",
                                "Precisão numérica em exemplo prático (peso 20%).",
                                "Clareza e completude da tabela de saída (peso 15%).",
                                "Identificação e prevenção de erros comuns (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python ou MATLAB.",
                                "Física: Simulações de movimento (ex: osciladores).",
                                "Engenharia: Modelagem de circuitos RC.",
                                "Estatística: Integração numérica em processos estocásticos."
                              ],
                              "realWorldApplication": "Usado em simulações de trajetórias espaciais (NASA), previsão de epidemias (modelos SIR), finanças (equações diferenciais em opções) e engenharia química (reatores)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Aplicar RK2 em exemplo",
                            "description": "Resolver numericamente um PVI exemplo, como y' = -y + t, y(0)=1, comparando com solução exata e analisando erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema PVI e recordar a fórmula do método RK2",
                                  "subSteps": [
                                    "Identifique o PVI dado: y' = -y + t, y(0) = 1.",
                                    "Escreva a fórmula geral do RK2: k1 = f(t_n, y_n), k2 = f(t_n + h, y_n + h k1), y_{n+1} = y_n + (h/2)(k1 + k2).",
                                    "Escolha o passo h (ex: h=0.1) e o intervalo final (ex: t=1.0).",
                                    "Verifique a função f(t,y) = -y + t.",
                                    "Planeje o número de iterações: N = 1/h = 10."
                                  ],
                                  "verification": "Lista escrita com fórmula RK2 correta, h escolhido e plano de iterações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, lápis, calculadora científica.",
                                  "tips": "Anote a fórmula RK2 em uma fórmula de referência para consulta rápida.",
                                  "learningObjective": "Entender os componentes do método RK2 e preparar o setup do problema.",
                                  "commonMistakes": "Confundir a ordem dos k's ou usar fórmula errada (ex: confundir com Euler)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a primeira iteração do RK2 manualmente",
                                  "subSteps": [
                                    "Para n=0, t0=0, y0=1: compute k1 = f(0,1) = -1 + 0 = -1.",
                                    "Compute k2 = f(0.1, 1 + 0.1*(-1)) = f(0.1, 0.9) = -0.9 + 0.1 = -0.8.",
                                    "y1 = 1 + (0.1/2)(-1 + -0.8) = 1 + 0.05*(-1.8) = 1 - 0.09 = 0.91.",
                                    "Registre t1=0.1, y1=0.91.",
                                    "Verifique aritmética com calculadora."
                                  ],
                                  "verification": "Cálculos de k1, k2 e y1 coincidem com valores exatos (k1=-1, k2=-0.8, y1=0.91).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, calculadora.",
                                  "tips": "Use precisão de 4 casas decimais para evitar erros de arredondamento acumulados.",
                                  "learningObjective": "Aplicar corretamente os estágios intermediários do RK2 em um passo.",
                                  "commonMistakes": "Erro no cálculo de k2 (esquecer h*k1) ou sinal errado em f."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar iterações subsequentes até t=1.0 e tabular resultados",
                                  "subSteps": [
                                    "Repita o processo para n=1 a 9, usando y anterior para próximo.",
                                    "Crie uma tabela com colunas: n, t_n, y_n, k1, k2, y_{n+1}.",
                                    "Calcule pelo menos 3 iterações completas e verifique consistência.",
                                    "Opcional: implemente em planilha (Excel) para automação.",
                                    "Registre todos os y_n aproximados."
                                  ],
                                  "verification": "Tabela completa com 11 pontos (t=0 a 1.0), sem discrepâncias aritméticas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, calculadora ou Excel.",
                                  "tips": "Copie y_n com cuidado para a próxima linha para evitar erros de transcrição.",
                                  "learningObjective": "Executar múltiplas iterações do RK2 e organizar dados em tabela.",
                                  "commonMistakes": "Acúmulo de erros de arredondamento; não atualizar t_n = t_{n-1} + h."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a solução exata e comparar com aproximação numérica",
                                  "subSteps": [
                                    "Resolva analiticamente: y' + y = t, μ=e^t, y = t - 1 + 2 e^{-t}.",
                                    "Calcule y_exata(t_n) para cada t_n na tabela.",
                                    "Compute erro local: e_n = |y_exata(t_n) - y_num(t_n)|.",
                                    "Crie tabela comparativa e plote y_num vs y_exata (gráfico manual ou software).",
                                    "Analise ordem de convergência qualitativamente (erro O(h^2))."
                                  ],
                                  "verification": "Solução exata correta (y(1) ≈ 1 -1 + 2/e ≈ 0.736), erros calculados e gráfico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora, papel para gráfico ou software como Desmos/Python.",
                                  "tips": "Use expansão de e^{-t} se necessário, mas calcule numericamente pontos chave.",
                                  "learningObjective": "Comparar solução numérica com exata e quantificar precisão.",
                                  "commonMistakes": "Erro na solução exata (C errado) ou sinal no erro absoluto."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar erros e discutir limitações do RK2",
                                  "subSteps": [
                                    "Calcule erro máximo e médio na tabela.",
                                    "Teste com h=0.05 e compare erros (deve reduzir ~4x para O(h^2)).",
                                    "Discuta estabilidade e por que RK2 é melhor que Euler.",
                                    "Registre observações em parágrafo.",
                                    "Sugira melhorias (ex: RK4)."
                                  ],
                                  "verification": "Análise escrita com erro max <0.01 para h=0.1, comparação com h menor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabelas anteriores, calculadora.",
                                  "tips": "Para teste h=0.05, foque em poucos passos para eficiência.",
                                  "learningObjective": "Interpretar resultados numéricos e avaliar método.",
                                  "commonMistakes": "Ignorar fator h^2 na análise de convergência."
                                }
                              ],
                              "practicalExample": "Resolva y' = -y + t, y(0)=1 com RK2, h=0.1 até t=1.0. Solução exata: y(t)=t-1+2e^{-t}. Tabela exemplo: t=0, y_num=1, y_ex=1, e=0; t=0.1, y_num=0.91, y_ex≈0.908, e≈0.002. Erro max≈0.008 a t=1.",
                              "finalVerifications": [
                                "Tabela RK2 completa sem erros aritméticos.",
                                "Solução exata derivada corretamente.",
                                "Erros absolutos calculados para todos pontos.",
                                "Gráfico comparativo y_num vs y_ex.",
                                "Análise qualitativa de precisão O(h^2).",
                                "Teste com h diferente confirmando convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos RK2 (90% sem erros).",
                                "Correção da solução exata e erros (100%).",
                                "Organização da tabela e gráfico (claro e legível).",
                                "Análise de erros e limitações (profunda e precisa).",
                                "Uso eficiente de h e iterações extras.",
                                "Clareza na escrita de conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de decaimento com forçantes (ex: circuitos RC).",
                                "Programação: Implementar RK2 em Python/MATLAB para simulações.",
                                "Estatística: Análise de erro numérico como incerteza em dados.",
                                "Engenharia: Simulações dinâmicas em controle de sistemas."
                              ],
                              "realWorldApplication": "Usado em simulações de trajetórias espaciais (NASA), previsão meteorológica, modelagem populacional com fatores externos e farmacocinética em medicina para dosagens de drogas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Método Runge-Kutta de Ordem 4 (RK4)",
                        "description": "Método RK4 clássico de Heun, com quatro estágios intermediários, amplamente utilizado por sua ótima relação precisão/custo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Derivar o método RK4",
                            "description": "Apresentar a fórmula do RK4 clássico com os coeficientes padrão (k1=f(t_n,y_n), k2=f(t_n+h/2,y_n+h k1/2), etc.) e verificar condições de ordem até 4.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura geral dos métodos Runge-Kutta",
                                  "subSteps": [
                                    "Recordar a equação diferencial y' = f(t,y) e a aproximação numérica y_{n+1} = y_n + h * soma b_i k_i",
                                    "Explicar o tableau de Butcher: vetores c, matriz a (s x s), vetor b (s componentes)",
                                    "Discutir condições de consistência (soma b_i =1, soma a_{i j} = c_i) e ordem p (condições de Butcher até ordem p)",
                                    "Introduzir que RK4 tem s=4 e ordem 4",
                                    "Esboçar o tableau genérico em papel"
                                  ],
                                  "verification": "Desenhar corretamente o tableau de Butcher genérico e listar as condições de ordem 1 e 2",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (cap. Runge-Kutta)",
                                    "Papel, caneta e calculadora"
                                  ],
                                  "tips": "Comece com métodos de ordem baixa (RK2) para intuitar a extrapolação em estágios intermediários",
                                  "learningObjective": "Compreender a parametrização geral dos métodos RK via tableau de Butcher",
                                  "commonMistakes": [
                                    "Confundir b_i (pesos finais) com a_{i j} (coeficientes internos)",
                                    "Esquecer que c_1=0 para métodos explícitos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar o tableau de Butcher para o RK4 clássico",
                                  "subSteps": [
                                    "Definir o vetor c = [0, 1/2, 1/2, 1]",
                                    "Definir a matriz A: linha1 vazia; linha2 [1/2]; linha3 [0, 1/2]; linha4 [0, 0, 1]",
                                    "Definir o vetor b = [1/6, 1/3, 1/3, 1/6]",
                                    "Verificar consistência: soma b_i =1 e soma a_{i*} = c_i para cada i",
                                    "Escrever o tableau completo em formato tabular"
                                  ],
                                  "verification": "Reproduzir o tableau exato do RK4 clássico sem consultar referências",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Referência opcional: tabela de métodos RK"
                                  ],
                                  "tips": "Use simetria: note que b2=b3=1/3 e a32=1/2 para equilíbrio",
                                  "learningObjective": "Memorizar e validar os coeficientes padrão do RK4",
                                  "commonMistakes": [
                                    "Errar a_{32} como 1 em vez de 1/2",
                                    "Colocar b=[1/6,2/6,2/6,1/6] ao invés de frações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as expressões dos coeficientes k1, k2, k3 e k4",
                                  "subSteps": [
                                    "Calcular k1 = f(t_n, y_n)",
                                    "Calcular k2 = f(t_n + h/2, y_n + (h/2) k1)",
                                    "Calcular k3 = f(t_n + h/2, y_n + (h/2) k2)",
                                    "Calcular k4 = f(t_n + h, y_n + h k3)",
                                    "Escrever as quatro equações alinhadas"
                                  ],
                                  "verification": "Substituir em um exemplo simples e computar valores numéricos coincidentes com fórmula conhecida",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou SymPy (opcional)",
                                    "Papel para anotações"
                                  ],
                                  "tips": "Expanda os argumentos: t_n + c_i h e y_n + h soma_{j=1}^{i-1} a_{i j} k_j",
                                  "learningObjective": "Aplicar o tableau para obter as avaliações em pontos intermediários",
                                  "commonMistakes": [
                                    "Usar k1 em k3 ao invés de k2",
                                    "Esquecer o h nos incrementos de y"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Obter a fórmula final de y_{n+1} e introduzir verificação de ordem",
                                  "subSteps": [
                                    "Escrever y_{n+1} = y_n + h (b1 k1 + b2 k2 + b3 k3 + b4 k4) = y_n + (h/6)(k1 + 2k2 + 2k3 + k4)",
                                    "Discutir expansão em série de Taylor para y(t_n + h) até O(h^5)",
                                    "Listar condições de ordem: para p=1: soma b_i=1; p=2: soma b_i c_i =1/2; p=3: soma b_i c_i^2 =1/3 e soma b_i a_{i j} c_j =1/6; p=4: mais 4 condições",
                                    "Verificar numericamente que os coeficientes do RK4 satisfazem até ordem 4",
                                    "Confirmar que erro local é O(h^5)"
                                  ],
                                  "verification": "Computar as somas das condições de ordem 1-4 e mostrar que igualam os coeficientes de Taylor (1,1/2,1/3,1/4,1/5)",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela de condições de Butcher",
                                    "Software como Mathematica ou papel para somas"
                                  ],
                                  "tips": "Calcule somas linha por linha: para ordem 2, b1*0 + b2*(1/2) + b3*(1/2) + b4*1 = (1/6)*0 + (1/3)(1/2) + (1/3)(1/2) + (1/6)*1 = 1/2",
                                  "learningObjective": "Derivar a fórmula explícita e provar a ordem 4 via condições de Butcher",
                                  "commonMistakes": [
                                    "Erro aritmético em somas como 2*(1/3 * 1/2)=1/3 ao invés de 1/3",
                                    "Confundir ordem local (erro O(h^{p+1})) com global O(h^p)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVI y' = y(1 - y), y(0)=0.5 (equação logística), com h=0.1 em t=0: compute k1 = 0.5*0.5=0.25; k2 = f(0.05, 0.5 + 0.05*0.25)=f(0.05,0.5125)≈0.245; k3≈f(0.05,0.5+0.05*0.245)≈0.246; k4=f(0.1,0.5+0.1*0.246)≈0.242; y1=0.5 + 0.1/6 *(0.25+2*0.245+2*0.246+0.242)≈0.5246",
                              "finalVerifications": [
                                "Escreve corretamente as expressões de k1 a k4 usando o tableau",
                                "Apresenta y_{n+1} = y_n + (h/6)(k1 + 2k2 + 2k3 + k4)",
                                "Verifica pelo menos 3 condições de ordem (ex: ordem 1,2,3)",
                                "Confirma que todas as 9 condições até ordem 4 são satisfeitas",
                                "Aplica a derivação em um PVI simples sem erros numéricos",
                                "Explica por que o método é de ordem 4 (erro local O(h^5))"
                              ],
                              "assessmentCriteria": [
                                "Precisão na reprodução do tableau de Butcher (coeficientes exatos)",
                                "Correção na derivação sequencial dos k_i",
                                "Domínio das condições de ordem de Butcher até p=4",
                                "Habilidade em calcular somas simbólicas para verificação",
                                "Clareza na apresentação da fórmula final e exemplo prático",
                                "Identificação de erros comuns e justificativa da ordem"
                              ],
                              "crossCurricularConnections": [
                                "Física: Integração numérica de EDOs em mecânica (ex: movimento orbital)",
                                "Computação: Implementação de solvers ODE em Python (scipy.integrate)",
                                "Engenharia: Simulações de sistemas dinâmicos em controle e aerodinâmica",
                                "Estatística: Modelos estocásticos aproximados por RK4"
                              ],
                              "realWorldApplication": "O RK4 é amplamente usado em software de simulação como MATLAB ode45, NASA trajectory simulations, modelagem climática e jogos de física (Unity/Unreal) para resolver EDOs com alta precisão e eficiência computacional moderada."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Implementar RK4 em código",
                            "description": "Desenvolver um programa computacional para integrar PVIs usando RK4, incluindo controle básico de passo opcional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de programação e definir o problema PVI modelo",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias: NumPy para arrays e operações vetoriais, Matplotlib para visualização opcional.",
                                    "Definir o problema PVI exemplo: y' = f(t, y), com y(t0) = y0, como y' = -2y, y(0) = 1 (solução exata y = e^{-2t}).",
                                    "Estruturar o código base: criar variáveis para t0, tf, y0, h inicial e tolerância de erro.",
                                    "Escrever função para solução exata para fins de comparação.",
                                    "Testar importações e execução básica do script."
                                  ],
                                  "verification": "Código roda sem erros de importação e imprime valores iniciais corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Matplotlib",
                                    "Editor de código (VS Code ou Jupyter Notebook)"
                                  ],
                                  "tips": "Use Jupyter Notebook para testes interativos e visualizações rápidas.",
                                  "learningObjective": "Preparar infraestrutura computacional e compreender um PVI clássico para validação.",
                                  "commonMistakes": [
                                    "Esquecer de importar NumPy como np",
                                    "Definir intervalos de integração incorretos (t0 > tf)",
                                    "Não vetorizar funções para eficiência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função derivada f(t, y)",
                                  "subSteps": [
                                    "Definir def f(t, y): return ... com suporte a arrays para integração vetorial.",
                                    "Para o exemplo: return -2 * y.",
                                    "Testar a função isoladamente com valores conhecidos: f(0,1) deve ser -2.",
                                    "Generalizar para funções escalares ou vetoriais (sistemas de EDOs).",
                                    "Adicionar docstring explicando parâmetros e retorno."
                                  ],
                                  "verification": "f(0,1) == -2.0 e f([0,1], [1,2]) funciona com broadcasting.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código do Step 1"
                                  ],
                                  "tips": "Sempre use np.array(y) para garantir compatibilidade numérica.",
                                  "learningObjective": "Criar a função right-hand side do PVI de forma modular e testável.",
                                  "commonMistakes": [
                                    "Retornar valor escalar em vez de array",
                                    "Não lidar com t e y como arrays",
                                    "Erros de indentação em definições de função"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar o algoritmo RK4 de passo fixo",
                                  "subSteps": [
                                    "Implementar função rk4_step(t, y, h, f): calcular k1 = h*f(t,y), k2 = h*f(t+h/2, y+k1/2), etc.",
                                    "Criar loop principal: lista para armazenar t_vals e y_vals, iterar até tf ajustando t += h, y += (k1+...)/6.",
                                    "Garantir precisão com np.linspace ou loop while t < tf.",
                                    "Implementar função de solução exata para plotagem: y_exact = np.exp(-2*t).",
                                    "Plotar y_num vs y_exact para inspeção visual."
                                  ],
                                  "verification": "Para h=0.1, erro global < 1e-3 comparado à solução exata no intervalo [0,1].",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "NumPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Use uma tolerância em loop while para evitar overshoot em tf.",
                                  "learningObjective": "Dominar a derivação e codificação precisa do método RK4 de ordem 4.",
                                  "commonMistakes": [
                                    "Índices errados nos k's (k1 a k4)",
                                    "Fator 1/6 esquecido no update de y",
                                    "Não truncar t no final para exatidão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adicionar controle adaptativo de passo h baseado em erro local",
                                  "subSteps": [
                                    "Implementar RK4 com dois passos: y_half com h/2, depois full h, estimar erro local como ||y_full - y_half||.",
                                    "Definir critério: se erro > tol, rejeitar passo, h = h/2; senão aceitar, h = h * min(2, (tol/erro)^0.2).",
                                    "Integrar no loop principal com h adaptativo, rastreando rejeições.",
                                    "Limitar h_min e h_max para estabilidade.",
                                    "Atualizar plot para mostrar trajetória com passos variáveis."
                                  ],
                                  "verification": "Número de rejeições < 10% dos passos totais e erro global < 1e-5.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do Step 3"
                                  ],
                                  "tips": "Use norma np.linalg.norm para erro em sistemas vetoriais.",
                                  "learningObjective": "Implementar controle de erro para precisão e eficiência em RK4.",
                                  "commonMistakes": [
                                    "Cálculo incorreto de y_half (deve ser dois passos de h/2)",
                                    "Fator de segurança muito agressivo levando a loops infinitos",
                                    "Não resetar h após rejeição"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar, otimizar e documentar o código completo",
                                  "subSteps": [
                                    "Testar com múltiplos PVIs: linear, não-linear (ex: y' = y(1-y), y(0)=0.5).",
                                    "Calcular erros globais: max |y_num - y_exact| e ordem de convergência log(erros)/log(h).",
                                    "Otimizar: vetorizar loops se possível, adicionar flags para passo fixo vs adaptativo.",
                                    "Adicionar comentários, funções modulares e README com uso.",
                                    "Exportar resultados para CSV e gerar relatório de precisão."
                                  ],
                                  "verification": "Ordem de convergência ≈4 para passo fixo; código roda <1s para tf=10.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código completo anterior",
                                    "SciPy para soluções de referência opcional"
                                  ],
                                  "tips": "Compare com scipy.integrate.solve_ivp(method='RK45') para benchmark.",
                                  "learningObjective": "Garantir robustez, precisão e usabilidade do implementador RK4.",
                                  "commonMistakes": [
                                    "Não testar com sistemas acoplados",
                                    "Ignorar underflow em h muito pequeno",
                                    "Falta de modularidade dificultando reutilização"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente RK4 para resolver y' = -2y, y(0)=1 em [0,5] com tol=1e-6. Compare gráfico e tabela de erros com y_exact = exp(-2t). Adicione controle h para eficiência.",
                              "finalVerifications": [
                                "Código executa sem erros para PVIs escalares e vetoriais.",
                                "Erro global < 1e-4 com h adaptativo em tf=10.",
                                "Ordem de precisão 4 confirmada reduzindo h em fator 2.",
                                "Número de passos e rejeições reportados corretamente.",
                                "Plots mostram convergência visual à solução exata.",
                                "Função modular aceita f personalizada."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro global ≤ 1e-5 com tol=1e-6.",
                                "Eficiência: <200 passos para tf=10 com adaptação.",
                                "Corretude: Fórmulas RK4 exatas (k1-k4 e update).",
                                "Robustez: Lida com rejeições e bounds em h.",
                                "Clareza: Código comentado, funções modulares.",
                                "Validação: Testes com múltiplos exemplos e benchmarks."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de loops, funções e vetores em Python/NumPy.",
                                "Física: Simulações de movimento (ex: osciladores com EDOs).",
                                "Engenharia: Modelagem diferencial em controle e circuitos.",
                                "Estatística: Análise de erro e convergência numérica."
                              ],
                              "realWorldApplication": "Simulações dinâmicas em engenharia aeroespacial (tra jetórias de foguetes), biologia computacional (modelos populacionais), finanças (EDOs estocásticas aproximadas) e jogos/física em engines como Unity via scripts numéricos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Analisar estabilidade e precisão do RK4",
                            "description": "Discutir o erro local O(h^5), estabilidade A-estável limitada e aplicar em problema stiff simples para observar limitações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Erro Local de Truncamento O(h^5) do RK4",
                                  "subSteps": [
                                    "Revise a derivação do método RK4 usando a série de Taylor para o polinômio interpolador.",
                                    "Expanda a solução exata y(t_n + h) em série de Taylor até ordem 5.",
                                    "Calcule o erro local truncando após o termo h^5, mostrando que os termos até h^4 cancelam.",
                                    "Discuta o impacto do erro local na precisão global O(h^4).",
                                    "Compare com métodos de ordem inferior como RK2."
                                  ],
                                  "verification": "Derive manualmente o erro local e confirme que é O(h^5) com coeficientes corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Calculadora simbólica como SymPy (opcional)"
                                  ],
                                  "tips": "Use a expansão de Taylor passo a passo, anotando cada k_i explicitamente.",
                                  "learningObjective": "Derivar e interpretar o erro local de truncamento do RK4.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Esquecer termos de derivadas superiores na Taylor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Estabilidade do Método RK4",
                                  "subSteps": [
                                    "Teste de estabilidade no problema modelo y' = λy com λ < 0 (modos dissipativos).",
                                    "Construa o polinômio de estabilidade R(z) = 1 + z + z^2/2 + z^3/6 + z^4/24 para RK4.",
                                    "Plote ou descreva a região de estabilidade no plano complexo z = hλ.",
                                    "Explique por que RK4 não é A-estável (região não inclui todo o semiplano esquerdo).",
                                    "Compare com métodos implícitos como Backward Euler (A-estável)."
                                  ],
                                  "verification": "Desenhe o gráfico da região de estabilidade e identifique seu raio espectral ≈2.78.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB/Python com Matplotlib)",
                                    "Tabela de regiões de estabilidade de livros-texto"
                                  ],
                                  "tips": "Use z = hλ com |R(z)| < 1 para estabilidade absoluta.",
                                  "learningObjective": "Interpretar limitações de estabilidade do RK4 em problemas stiff.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com relativa",
                                    "Ignorar o semiplano esquerdo para stiff problems"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e Configurar um Problema Stiff Simples",
                                  "subSteps": [
                                    "Escolha o problema y' = -100(y - sin(t)), y(0) = 0 (λ=100 grande).",
                                    "Calcule a solução exata numericamente ou analiticamente para referência.",
                                    "Defina intervalos de tempo [0,1] e passos h variando de 0.001 a 0.1.",
                                    "Implemente o RK4 em código para automação.",
                                    "Prepare gráficos para erro vs. h e solução numérica vs. exata."
                                  ],
                                  "verification": "Confirme que o problema é stiff pelo eigenvalue λ=-100 e escalas temporais díspares.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Solução exata via scipy.integrate.odeint"
                                  ],
                                  "tips": "Use h inicial pequeno para convergência, depois aumente para observar instabilidade.",
                                  "learningObjective": "Identificar características de problemas stiff adequados para testar RK4.",
                                  "commonMistakes": [
                                    "Escolher λ pequeno, não stiff",
                                    "Não normalizar solução para comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar RK4 e Observar Limitações em Problema Stiff",
                                  "subSteps": [
                                    "Execute simulações com h=0.01 (estável) e h=0.05 (instável).",
                                    "Plote soluções numéricas, erro global e oscilações.",
                                    "Quantifique o erro local aproximado via ||e|| / h^4.",
                                    "Discuta necessidade de h < 2.78/|λ| ≈0.0278 para estabilidade.",
                                    "Compare com método implícito (ex: RK4 com Butcher tableau implícito ou BDF)."
                                  ],
                                  "verification": "Observe divergência ou oscilações para h grande, confirmando limitações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python/MATLAB pronto",
                                    "Gráficos de erro e solução"
                                  ],
                                  "tips": "Monitore norma do resíduo para detecção precoce de instabilidade.",
                                  "learningObjective": "Demonstrar empiricamente as limitações de precisão e estabilidade do RK4.",
                                  "commonMistakes": [
                                    "Atribuir erro só à precisão, ignorando estabilidade",
                                    "Usar h fixo sem variação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -100(y - sin(t)), y(0)=0 em [0,1], com h=0.02 RK4 oscila e diverge após t=0.3, enquanto h=0.01 converge devagar; solução exata segue sin(t) assintoticamente.",
                              "finalVerifications": [
                                "Derivação correta do erro local O(h^5).",
                                "Descrição precisa da região de estabilidade do RK4.",
                                "Implementação funcional do RK4 em problema stiff.",
                                "Gráficos mostrando instabilidade para h grande.",
                                "Comparação quantitativa de erros local/global.",
                                "Explicação clara de por que não é A-estável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação teórica do erro (90%+ correto).",
                                "Correção na análise da região de estabilidade (raio e forma).",
                                "Qualidade dos gráficos e simulações numéricas.",
                                "Interpretação correta das limitações observadas.",
                                "Profundidade na discussão de alternativas implícitas.",
                                "Clareza na conexão entre teoria e experimento."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em EDOs de dinâmica molecular stiff.",
                                "Computação: Otimização de solvers numéricos em SciPy/ODEPACK.",
                                "Engenharia: Simulações de circuitos RLC stiff em controle.",
                                "Estatística: Análise de erro em Monte Carlo para EDOs."
                              ],
                              "realWorldApplication": "Em modelagem de reações químicas stiff (ex: combustão), RK4 falha com passos grandes levando a instabilidade; engenheiros usam isso para justificar solvers implícitos como Radau em software como COMSOL ou LSODA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.4",
                            "name": "Comparar RK2 e RK4",
                            "description": "Executar simulações comparativas entre RK2 e RK4 em um mesmo PVI, graficando erros e avaliando eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar PVI e Configurar Ambiente Computacional",
                                  "subSteps": [
                                    "Escolha um PVI com solução analítica conhecida, como y' = -y, y(0) = 1, solução y = e^{-x} no intervalo [0, 5].",
                                    "Instale bibliotecas Python: numpy, matplotlib e scipy para solução exata.",
                                    "Defina funções auxiliares: f(x,y) = -y, solução exata exp(-x), e intervalos de passos h = [0.5, 0.25, 0.1, 0.05].",
                                    "Crie estrutura de código base para solvers genéricos.",
                                    "Teste a função f e solução exata plotando para verificação inicial."
                                  ],
                                  "verification": "Código roda sem erros e plota solução exata corretamente.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Matplotlib",
                                    "SciPy"
                                  ],
                                  "tips": [
                                    "Use Jupyter Notebook para interatividade.",
                                    "Salve solução exata em array para comparações rápidas."
                                  ],
                                  "learningObjective": "Preparar base sólida para simulações comparativas.",
                                  "commonMistakes": [
                                    "Escolher PVI rígido sem solução analítica.",
                                    "Erros de importação de bibliotecas.",
                                    "Intervalos de x mal definidos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Testar Método RK2",
                                  "subSteps": [
                                    "Defina o esquema RK2: k1 = f(x_n, y_n), k2 = f(x_n + h, y_n + h k1), y_{n+1} = y_n + (h/2)(k1 + k2).",
                                    "Escreva função iterativa rk2(f, x0, y0, h, xf) que retorna arrays x e y.",
                                    "Execute simulações para todos h, calculando erro global max |y_num - y_exata|.",
                                    "Meça tempo de execução com time.time().",
                                    "Plote soluções RK2 vs exata para visualização inicial."
                                  ],
                                  "verification": "Erros diminuem com h menor; plot sem divergências.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Código Python do Step 1"
                                  ],
                                  "tips": [
                                    "Vectorize com numpy para eficiência.",
                                    "Use assert para testar com h grande conhecido."
                                  ],
                                  "learningObjective": "Dominar implementação precisa de RK2 e análise inicial de erro.",
                                  "commonMistakes": [
                                    "Fator 1/2 errado em k2.",
                                    "Não resetar y0 por simulação.",
                                    "Confundir erro local com global."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Testar Método RK4",
                                  "subSteps": [
                                    "Defina esquema RK4: k1=f(x,y), k2=f(x+h/2,y+(h/2)k1), k3=f(x+h/2,y+(h/2)k2), k4=f(x+h,y+h k3), y+= (h/6)(k1+2k2+2k3+k4).",
                                    "Escreva função rk4 similar à rk2.",
                                    "Execute simulações para mesmos h, calculando erros e tempos.",
                                    "Compare numericamente erros e tempos iniciais com RK2.",
                                    "Plote soluções RK4 vs exata."
                                  ],
                                  "verification": "RK4 mais preciso que RK2 para mesmo h; tempos similares ou RK4 ligeiramente maior.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2"
                                  ],
                                  "tips": [
                                    "Copie estrutura de rk2 para evitar bugs.",
                                    "Comente Butcher tableau no código."
                                  ],
                                  "learningObjective": "Implementar RK4 corretamente e observar ordem de precisão.",
                                  "commonMistakes": [
                                    "Coeficientes errados em soma ponderada.",
                                    "h/2 duplicado em k2/k3.",
                                    "Não usar h/6 final."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Comparação, Graficar e Avaliar Eficiência",
                                  "subSteps": [
                                    "Crie tabelas: h, erro_RK2, erro_RK4, tempo_RK2, tempo_RK4, eficiência (log(erro)/tempo).",
                                    "Gere gráficos: erro vs h (log-log para ordem), solução vs x, tempo vs precisão.",
                                    "Analise: ordem de convergência (RK2 ~2, RK4 ~4), custo computacional (4 eval f em RK4 vs 2 em RK2).",
                                    "Conclua vantagens: RK4 melhor para precisão similar custo.",
                                    "Salve relatório com plots e tabela."
                                  ],
                                  "verification": "Gráficos mostram inclinação ~2 para RK2 e ~4 para RK4 em log-log.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": [
                                    "Resultados dos Steps 2-3",
                                    "Pandas para tabelas opcionais"
                                  ],
                                  "tips": [
                                    "Use plt.loglog para convergência.",
                                    "Calcule razão de erros RK2/RK4."
                                  ],
                                  "learningObjective": "Avaliar trade-off precisão-eficiência quantitativamente.",
                                  "commonMistakes": [
                                    "Escala errada em plots.",
                                    "Média vs max erro.",
                                    "Ignorar overhead fixo em tempos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVI y' = -y, y(0)=1 em [0,5], implemente em Python rk2 e rk4 com h=[1,0.5,0.25,0.1]. Plote y_num vs y_exata=exp(-x), erros log-log (RK2 inclinação~2, RK4~4), e tempo vs log(erro). RK4 atinge erro 1e-4 com h=0.25, enquanto RK2 precisa h=0.05, com tempo similar.",
                              "finalVerifications": [
                                "Implementações rk2 e rk4 produzem soluções estáveis e convergentes.",
                                "Tabelas mostram erros RK4 < RK2 para mesmo h.",
                                "Gráficos log-log confirmam ordens 2 e 4.",
                                "Tempos indicam eficiência RK4 superior para alta precisão.",
                                "Relatório resume comparações quantitativas.",
                                "Código reutilizável para outros PVIs."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática das implementações (testes com PVI simples).",
                                "Precisão nos cálculos de erro global e tempo.",
                                "Qualidade dos gráficos (legendas, escalas adequadas).",
                                "Análise quantitativa de convergência e eficiência.",
                                "Clareza do código (comentários, modularidade).",
                                "Conclusões alinhadas com teoria Runge-Kutta."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação numérica em Python/NumPy.",
                                "Física: Modelagem de decaimento exponencial (radioatividade, resfriamento).",
                                "Estatística: Análise de erro e convergência log-log.",
                                "Engenharia: Simulações em controle dinâmico e trajetórias."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais (NASA usa RK4 para órbitas), farmacocinética (decaimento de drogas) e finanças (modelos estocásticos aproximados), onde RK4 equilibra precisão e custo para previsões confiáveis em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.3",
                              "10.1.1.3.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Análise de Erro Local e Global",
                    "description": "Estudo do erro de truncamento local e sua acumulação para erro global em métodos de passo simples.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Erro de Truncamento Local (LTE)",
                        "description": "Definição e derivação do erro de truncamento local em métodos de passo simples para equações diferenciais ordinárias de primeira ordem.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Definir o Erro de Truncamento Local",
                            "description": "Explicar o conceito de erro de truncamento local como a diferença entre a solução exata e a solução numérica assumindo passos anteriores exatos, incluindo sua representação em série de Taylor para métodos como Euler explícito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Problemas de Valor Inicial e Método de Euler Explícito",
                                  "subSteps": [
                                    "Lembre-se da forma geral de um PVI: y' = f(t,y), y(t0)=y0.",
                                    "Descreva o método de Euler explícito: yn+1 = yn + h f(tn, yn).",
                                    "Identifique os componentes: passo h, aproximação local linear.",
                                    "Calcule um passo manual para y' = y, y(0)=1, h=0.1.",
                                    "Compare com solução exata y(t)=e^t para t=0.1."
                                  ],
                                  "verification": "Resolva um PVI simples com Euler e compare com exata; erro deve ser visível.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora, notas de Análise Numérica.",
                                  "tips": "Use h pequeno para ver aproximação linear.",
                                  "learningObjective": "Entender a base do método numérico antes do erro.",
                                  "commonMistakes": "Confundir Euler implícito com explícito; ignorar dependência em h."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Erro Local de Truncamento de Erro Global",
                                  "subSteps": [
                                    "Defina erro global: diferença total entre exata e numérica após n passos.",
                                    "Defina LTE: erro assumindo passos anteriores exatos (erro por passo).",
                                    "Explique: LTE é o erro de truncamento da expansão local, sem propagação.",
                                    "Ilustre com diagrama: solução exata vs polinômio local de grau 1.",
                                    "Note: Erro global acumula LTEs."
                                  ],
                                  "verification": "Explique em suas palavras a diferença LTE vs global para um colega.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Quadro branco ou papel para diagrama, livro de análise numérica.",
                                  "tips": "Pense em LTE como 'erro fresco' a cada passo.",
                                  "learningObjective": "Distinguir tipos de erro em métodos numéricos.",
                                  "commonMistakes": "Confundir LTE com arredondamento; achar que LTE inclui propagação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente o Erro de Truncamento Local",
                                  "subSteps": [
                                    "Defina LTE: τ(h) = [y(t_{n+1}) - y(t_n)] / h - f(t_n, y(t_n)), onde y exata.",
                                    "Reescreva como diferença entre incremento exato e numérico por h.",
                                    "Assuma passos anteriores exatos: foco no erro intrínseco do método.",
                                    "Mostre que para Euler, LTE mede falha da linearização.",
                                    "Escreva fórmula geral: LTE = (1/h) ∫_{t_n}^{t_{n+1}} [y'(s) - y'(t_n)] ds."
                                  ],
                                  "verification": "Escreva a definição de LTE para um PVI genérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de exercícios, software como MATLAB ou Python para plotar.",
                                  "tips": "Memorize: LTE assume y_n = y(t_n) exato.",
                                  "learningObjective": "Formular matematicamente o conceito de LTE.",
                                  "commonMistakes": "Incluir erros de passos prévios na definição; errar o fator 1/h."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar LTE Usando Série de Taylor para Euler Explícito",
                                  "subSteps": [
                                    "Expanda y(t_{n+1}) em Taylor ao redor de t_n: y(t_n + h) = y(t_n) + h y'(t_n) + (h^2/2) y''(ξ).",
                                    "Substitua y' = f: incremento exato = h f + (h^2/2) f'(ξ).",
                                    "Euler dá h f; assim LTE ≈ (h/2) y''(ξ).",
                                    "Mostre ordem O(h): LTE = O(h) para Euler.",
                                    "Verifique com exemplo y' = y: y''=y, LTE = (h/2) e^ξ."
                                  ],
                                  "verification": "Derive LTE para Euler em y' = -y + t; confira ordem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora simbólica ou SymPy, tabela de derivadas de f.",
                                  "tips": "Use resto de Taylor para ξ em [t_n, t_{n+1}].",
                                  "learningObjective": "Conectar LTE à análise de Taylor e ordem de precisão.",
                                  "commonMistakes": "Esquecer resto de Taylor; confundir y'' com df/dy."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e Aplicar o Conceito de LTE",
                                  "subSteps": [
                                    "Explique implicações: ordem 1 para Euler significa erro local O(h), global O(h).",
                                    "Compare com métodos de ordem superior (ex: Runge-Kutta).",
                                    "Calcule LTE numérico para exemplo e compare com Taylor.",
                                    "Discuta consistência: LTE → 0 quando h → 0.",
                                    "Resuma: LTE quantifica truncamento polinomial."
                                  ],
                                  "verification": "Resolva exercício: encontre LTE para y'=y^2, y(0)=1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exercícios impressos, software numérico.",
                                  "tips": "Sempre normalize por h para LTE.",
                                  "learningObjective": "Aplicar LTE para analisar métodos.",
                                  "commonMistakes": "Ignorar dependência em f; achar LTE independente de h."
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1, h=0.1: Solução exata y(0.1)=e^{0.1}≈1.10517. Euler: y1=1 + 0.1*1=1.1. Incremento exato: 0.10517, numérico: 0.1, LTE=(0.10517-0.1)/0.1≈0.0517. Taylor: (0.1/2)*e^ξ≈0.054 (próximo).",
                              "finalVerifications": [
                                "Defina LTE corretamente sem erros conceituais.",
                                "Derive fórmula de Taylor para Euler explícito.",
                                "Calcule LTE para um PVI simples com precisão.",
                                "Distinga LTE de erro global e arredondamento.",
                                "Explique ordem de truncamento O(h).",
                                "Aplique LTE a um exemplo não-linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de LTE (90% correto).",
                                "Correção na derivação de Taylor (incluindo resto).",
                                "Capacidade de calcular LTE numérico vs analítico (erro <5%).",
                                "Clareza na distinção local/global.",
                                "Uso correto de notação matemática.",
                                "Explicação verbal fluida do conceito."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de erro em simulações de movimento (ex: Euler para integrais de movimento).",
                                "Programação: Implementar LTE em código Python para validar métodos numéricos.",
                                "Engenharia: Avaliar precisão em modelagem de circuitos RC.",
                                "Estatística: Conexão com erros de aproximação em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou previsão financeira, LTE determina o tamanho de h viável para precisão sem custo computacional excessivo, guiando escolha de métodos numéricos em software como CFD ou trading algorítmico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Derivar o LTE para Método de Euler",
                            "description": "Derivar a expressão do erro de truncamento local para o método de Euler explícito, mostrando que é da ordem O(h²), onde h é o tamanho do passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer a Equação Diferencial e a Solução Exata Local",
                                  "subSteps": [
                                    "Considere o PVI: y' = f(t, y), y(t_n) = y_n.",
                                    "Defina t_{n+1} = t_n + h, onde h é o tamanho do passo.",
                                    "Expresse a solução exata y(t_{n+1}) em termos de y(t_n).",
                                    "Introduza a notação LTE = y(t_{n+1}) - y_{n+1}, assumindo y_n = y(t_n) exato.",
                                    "Lembre que LTE mede o erro introduzido em um único passo."
                                  ],
                                  "verification": "Verifique se a configuração do PVI e definições de t_{n+1}, h e LTE estão corretas e consistentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Use notação padrão para evitar confusões; escreva explicitamente y(t_n) = y_n.",
                                  "learningObjective": "Compreender a configuração inicial do problema de valor inicial e o conceito de erro de truncamento local.",
                                  "commonMistakes": [
                                    "Confundir LTE com erro global",
                                    "Esquecer de assumir y_n exato",
                                    "Usar notação inconsistente para h"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver a Expansão em Série de Taylor da Solução Exata",
                                  "subSteps": [
                                    "Aplique a expansão de Taylor para y(t_{n+1}) em torno de t_n: y(t_n + h) = y(t_n) + h y'(t_n) + (h²/2) y''(t_n) + (h³/6) y'''(ξ) para algum ξ.",
                                    "Substitua y'(t_n) = f(t_n, y(t_n)) = f(t_n, y_n).",
                                    "Expresse y''(t_n) em termos de derivadas parciais de f: y'' = ∂f/∂t + ∂f/∂y * f.",
                                    "Mantenha termos até O(h²) e resíduo O(h³).",
                                    "Escreva y(t_{n+1}) = y_n + h f(t_n, y_n) + (h²/2) y''(t_n) + O(h³)."
                                  ],
                                  "verification": "Confirme que a expansão tem termos até h² e resíduo O(h³), com y'' correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de derivadas de Taylor",
                                    "Calculadora para símbolos opcionais"
                                  ],
                                  "tips": "Use a regra da cadeia para y''; pratique com f simples primeiro.",
                                  "learningObjective": "Dominar a expansão de Taylor para soluções de EDOs, expressando derivadas superiores via f.",
                                  "commonMistakes": [
                                    "Erros na regra da cadeia para y''",
                                    "Confundir derivadas parciais ∂f/∂t e ∂f/∂y",
                                    "Parar em O(h) em vez de O(h²)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever a Expansão do Método de Euler Explícito",
                                  "subSteps": [
                                    "Lembre a fórmula do Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Note que isso corresponde aos dois primeiros termos da Taylor: y_n + h y'(t_n).",
                                    "Não há termos h² ou superiores no método de Euler.",
                                    "Expresse y_{n+1} = y_n + h f(t_n, y_n) + 0*h² + 0*O(h³).",
                                    "Compare visualmente com a expansão exata."
                                  ],
                                  "verification": "Verifique se y_{n+1} matches exatamente os termos lineares da Taylor exata.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta"
                                  ],
                                  "tips": "Escreva lado a lado as expansões exata e numérica para facilitar comparação.",
                                  "learningObjective": "Reconhecer que Euler é a aproximação linear da Taylor.",
                                  "commonMistakes": [
                                    "Adicionar termos extras ao Euler por engano",
                                    "Esquecer que Euler para em h f",
                                    "Confundir com métodos de ordem superior"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o LTE e Demonstrar Ordem O(h²)",
                                  "subSteps": [
                                    "Subtraia: LTE = y(t_{n+1}) - y_{n+1} = [y_n + h f + (h²/2) y'' + O(h³)] - [y_n + h f] = (h²/2) y''(t_n) + O(h³).",
                                    "Conclua que LTE = O(h²), pois o termo dominante é h²/2 y'' e O(h³) é menor.",
                                    "Discuta que y'' ≠ 0 em geral, confirmando ordem exatamente 1 (erro O(h²) implica ordem 1).",
                                    "Opcional: verifique consistência para f suave (C²).",
                                    "Escreva a expressão final: LTE = (h²/2) f_t + f_y f (t_n, y_n) + O(h³)."
                                  ],
                                  "verification": "A expressão final mostra LTE = (h²/2) y'' + O(h³), com ordem O(h²).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo numérico simples para testar"
                                  ],
                                  "tips": "Fatore h² explicitamente; teste com y' = y para validar.",
                                  "learningObjective": "Derivar e interpretar a ordem de truncamento do método de Euler.",
                                  "commonMistakes": [
                                    "Sinal errado na subtração",
                                    "Ignorar O(h³) ou alegar ordem errada",
                                    "Confundir ordem do método (1) com expoente do erro (2)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1 (solução y=e^t). Em t_n=0, h=0.1, y_n=1, f(t,y)=y. Taylor exata: y(h)=1 + h + (h²/2) + O(h³). Euler: y1=1 + h*1=1+h. LTE=(h²/2)+O(h³)≈0.005, confirmando O(h²).",
                              "finalVerifications": [
                                "Expansão exata inclui termo h²/2 y''(t_n) + O(h³).",
                                "Euler para em h f(t_n,y_n), sem h².",
                                "LTE = (h²/2) y''(t_n) + O(h³).",
                                "y'' expresso corretamente como f_t + f_y f.",
                                "Conclusão explícita de ordem O(h²)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão de Taylor da solução exata (pontos por termos corretos).",
                                "Correta expressão de y'' via derivadas parciais de f (50% da nota).",
                                "Subtração precisa resultando em LTE = O(h²) (30% da nota).",
                                "Interpretação clara da ordem de truncamento.",
                                "Ausência de erros algébricos ou conceituais.",
                                "Uso consistente de notação e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Euler em Python/MATLAB e testar LTE numericamente.",
                                "Física: Aplicar em simulações de movimento (ex: queda livre com resistência).",
                                "Cálculo: Reforça séries de Taylor e regra da cadeia.",
                                "Estatística: Análise de erro em aproximações numéricas probabilísticas."
                              ],
                              "realWorldApplication": "Na engenharia aeroespacial, derivação de LTE guia escolha de h em simulações de trajetórias orbitais com Euler, garantindo precisão sem custo computacional excessivo em softwares como MATLAB Simulink."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Calcular LTE para Métodos de Runge-Kutta de Ordem 2",
                            "description": "Calcular e interpretar o erro de truncamento local para métodos de Runge-Kutta de segunda ordem, identificando os termos principais da expansão em série.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Expansão em Série de Taylor da Solução Exata",
                                  "subSteps": [
                                    "Lembre-se da equação diferencial y' = f(t, y), com y(t_n) conhecido.",
                                    "Escreva y(t_n + h) usando expansão de Taylor até ordem h^3: y(t_n + h) = y(t_n) + h y'(t_n) + (h^2/2) y''(t_n) + (h^3/6) y'''(ξ).",
                                    "Expresse as derivadas superiores usando f: y' = f, y'' = f_t + f_y f, y''' = derivada de y''.",
                                    "Identifique os termos até O(h^3) para comparação posterior.",
                                    "Pratique com um exemplo simples como y' = y."
                                  ],
                                  "verification": "Verifique se a expansão coincide com a solução exata conhecida para EDO linear.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (capítulo de EDOs)",
                                    "Calculadora simbólica opcional"
                                  ],
                                  "tips": "Sempre anote as condições iniciais e o ponto de expansão claramente.",
                                  "learningObjective": "Dominar a expansão de Taylor multivariável para soluções de EDOs.",
                                  "commonMistakes": [
                                    "Esquecer o termo f_y f em y''",
                                    "Confundir ordens de h nas derivadas",
                                    "Ignorar o resto da série O(h^4)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Forma Geral do Método Runge-Kutta de Ordem 2",
                                  "subSteps": [
                                    "Estude a Butcher tableau para RK2 genérico: k1 = f(t_n, y_n), k2 = f(t_n + a h, y_n + b h k1), y_{n+1} = y_n + h (c1 k1 + c2 k2).",
                                    "Para ordem 2, condições: b + a = c1 + c2 = 1, a b c2 = 1/2.",
                                    "Escolha um esquema específico, como Heun: a=1, b=1, c1=1/2, c2=1/2.",
                                    "Expanda k1 e k2 em séries de Taylor em torno de (t_n, y_n).",
                                    "Verifique que y_{n+1} reproduz termos até h^2 exatamente."
                                  ],
                                  "verification": "Confirme que o método é consistente de ordem 2 calculando coeficientes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de Butcher de referência",
                                    "Software como Mathematica para expansão simbólica (opcional)"
                                  ],
                                  "tips": "Use abreviações: f = f(t_n,y_n), f_t = ∂f/∂t, f_y = ∂f/∂y.",
                                  "learningObjective": "Compreender os parâmetros que garantem ordem 2 no RK2.",
                                  "commonMistakes": [
                                    "Usar valores errados para a,b,c",
                                    "Esquecer expansões em k2",
                                    "Não verificar condições de ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as Expansões de k1 e k2 e Calcular y_{n+1}",
                                  "subSteps": [
                                    "Expanda k1 = f.",
                                    "Para k2: f(t_n + a h, y_n + b h k1) = f + h (a f_t + b f k1 f_y) + (h^2/2) [termos quadráticos].",
                                    "Substitua k1 em k2 e expanda até h^2.",
                                    "Calcule y_{n+1} = y_n + h (c1 k1 + c2 k2), coletando termos h, h^2, h^3.",
                                    "Simplifique usando condições de ordem 2."
                                  ],
                                  "verification": "Os termos h e h^2 em y_{n+1} devem igualar os da solução exata.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado para álgebra",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Trabalhe simbolicamente primeiro, antes de plugar números.",
                                  "learningObjective": "Executar expansões de Taylor compostas em métodos numéricos.",
                                  "commonMistakes": [
                                    "Erro na cadeia de derivadas parciais em k2",
                                    "Coeficientes errados em h^2/2",
                                    "Não truncar corretamente em O(h^3)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e Interpretar o Erro de Truncamento Local (LTE)",
                                  "subSteps": [
                                    "Subtraia y_{n+1} da expansão exata y(t_n + h): LTE = y(t_n + h) - y_{n+1}.",
                                    "Colete o termo principal em h^3: tipicamente (h^3/6) y'''(ξ) menos o termo correspondente do método.",
                                    "Para RK2 genérico, encontre o coeficiente exato: LTE = (h^3/6) (1 - 3 a b c2) y''' + O(h^4).",
                                    "Verifique para Heun: coeficiente zero? Não, calcule explicitamente.",
                                    "Interprete: LTE ~ C h^3, onde C depende de derivadas de f."
                                  ],
                                  "verification": "O LTE deve ser O(h^3), com termo h^1 e h^2 cancelados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de respostas para comparar exata vs aproximada"
                                  ],
                                  "tips": "Fatore h^3 e identifique o coeficiente principal claramente.",
                                  "learningObjective": "Identificar e quantificar o erro local de truncamento.",
                                  "commonMistakes": [
                                    "Termos h^1/h^2 não cancelam (erro anterior)",
                                    "Confundir LTE com erro global",
                                    "Ignorar dependência em ξ"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1 (solução exata y=e^{-t}), use h=0.1, RK2 Heun. Expanda até h^3: calcule LTE ≈ (h^3/3) y'''(ξ), verifique numericamente aproximando y'''=-e^{-ξ}.",
                              "finalVerifications": [
                                "Expansão de Taylor exata reproduz y(t+h) até O(h^3).",
                                "k1 e k2 expandidos corretamente com derivadas parciais.",
                                "y_{n+1} cancela termos h e h^2 da exata.",
                                "LTE isolado como termo h^3 com coeficiente explícito.",
                                "Interpretação correta: ordem 3, dependente de y'''."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de y'' e y''' via f.",
                                "Correção das condições de ordem no Butcher tableau.",
                                "Expansões de k2 sem erros algébricos.",
                                "Identificação exata do termo principal do LTE.",
                                "Explicação clara da interpretação do erro."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores harmônicos com EDOs.",
                                "Programação: Implementar RK2 em Python e testar LTE numericamente.",
                                "Cálculo: Reforço de séries de Taylor multivariáveis.",
                                "Estatística: Análise de erro em simulações estocásticas."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias de mísseis ou previsão de epidemias (modelos SIR), calcular LTE garante precisão em passos de tempo variáveis, otimizando eficiência computacional em software de engenharia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Acumulação do Erro Local",
                        "description": "Estudo de como o erro de truncamento local se propaga e acumula ao longo de múltiplos passos no método numérico.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Modelar a Propagação do Erro Local",
                            "description": "Descrever o modelo de acumulação do erro local usando a solução da equação de erro, considerando a estabilidade do método e o fator de amplificação por passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Erro Local e a Equação de Erro",
                                  "subSteps": [
                                    "Revise a definição de erro local em métodos de passo simples (ex: Euler, Runge-Kutta).",
                                    "Estude a truncagem local e derive a equação diferencial para o erro local e(n).",
                                    "Identifique os termos da equação de erro: e'(t) = L e(t) + τ(t), onde L é a Lipschitz e τ o resíduo local.",
                                    "Analise exemplos simples para problemas de valor inicial y' = f(t,y).",
                                    "Discuta a dependência do erro local no passo h."
                                  ],
                                  "verification": "Escreva a equação de erro para o método de Euler explícito e verifique com fórmulas padrão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre métodos numéricos",
                                    "Calculadora simbólica (Wolfram Alpha)"
                                  ],
                                  "tips": "Comece com métodos lineares para simplificar a derivação.",
                                  "learningObjective": "Dominar a formulação matemática do erro local como uma EDO linear não-homogênea.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Ignorar o termo de truncagem τ(t)",
                                    "Esquecer a condição inicial e(0)=0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver a Equação de Erro",
                                  "subSteps": [
                                    "Resolva a EDO homogênea e'(t) = L e(t) para obter a solução geral.",
                                    "Use variação de parâmetros para encontrar a solução particular do termo não-homogêneo τ(t).",
                                    "Combine soluções para obter e(t) = e^{L t} e(0) + ∫ e^{L(t-s)} τ(s) ds.",
                                    "Aproxime para passos discretos: e_{n+1} = (1 + L h) e_n + τ_n h.",
                                    "Implemente numericamente em Python para validar."
                                  ],
                                  "verification": "Derive analiticamente a solução para um problema teste como y' = y e compare com simulação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Papel e lápis para derivações",
                                    "Referência: Atkinson 'An Introduction to Numerical Analysis'"
                                  ],
                                  "tips": "Use a constante de integração corretamente; teste com L<0 para estabilidade.",
                                  "learningObjective": "Capacitar-se a resolver analiticamente a equação de erro para métodos numéricos.",
                                  "commonMistakes": [
                                    "Erro no fator integrador de variação de parâmetros",
                                    "Confundir solução homogênea com particular",
                                    "Não aproximar corretamente para h pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar a Propagação e Acumulação do Erro Local",
                                  "subSteps": [
                                    "Modele a recursão discreta: e_{n} ≈ (1 + L h)^n e_0 + soma de termos amplificados.",
                                    "Calcule o erro acumulado após N passos: E_N ≈ soma_{k=0}^{N-1} (1 + L h)^{N-1-k} τ_k h.",
                                    "Analise o comportamento assintótico para h fixo e N→∞.",
                                    "Simule em código a propagação para diferentes h e f.",
                                    "Compare com erro global observado."
                                  ],
                                  "verification": "Plote e_n vs n para um exemplo e confirme que segue a recursão teórica.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Matplotlib para plots",
                                    "Exemplos de código de repositórios GitHub de análise numérica"
                                  ],
                                  "tips": "Use log-escala para visualizar amplificação exponencial.",
                                  "learningObjective": "Construir o modelo recursivo para propagação do erro local ao longo de múltiplos passos.",
                                  "commonMistakes": [
                                    "Índices errados na soma de acumulação",
                                    "Ignorar fator (1 + L h)",
                                    "Confundir truncagem local com arredondamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Estabilidade e Fator de Amplificação por Passo",
                                  "subSteps": [
                                    "Defina o fator de amplificação ρ = |1 + L h|; discuta ρ < 1 para atenuação.",
                                    "Examine regiões de estabilidade absoluta (A-stabilidade para métodos implícitos).",
                                    "Calcule o erro global como O(h) ou O(h^p) influenciado pela propagação.",
                                    "Teste com problemas rígidos (ex: y' = -100 y) para ver explosão de erro.",
                                    "Derive condições em h para estabilidade numérica."
                                  ],
                                  "verification": "Para um método dado, compute ρ e verifique se |ρ| ≤ 1 implica convergência estável.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB ou Octave",
                                    "Tabelas de estabilidade de métodos RK",
                                    "Artigo sobre estabilidade de Dahlquist"
                                  ],
                                  "tips": "Foquem em problemas lineares testes como o modo de Dahlquist.",
                                  "learningObjective": "Integrar análise de estabilidade no modelo de propagação de erro.",
                                  "commonMistakes": [
                                    "Confundir estabilidade numérica com convergência",
                                    "Usar |L| em vez de Re(L)",
                                    "Ignorar h em regiões condicionalmente estáveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método de Euler em y' = λ y, y(0)=1 com λ=-50 (rígido), modele e_n = (1 + λ h)^n * 0 + soma_{k=0}^{n-1} (1 + λ h)^{n-1-k} * (λ^2 h^2 / 2) y_k. Simule com h=0.01 e observe amplificação se |1 + λ h| >1.",
                              "finalVerifications": [
                                "Deriva corretamente a recursão de propagação do erro local.",
                                "Implementa simulação numérica que reproduz o modelo teórico.",
                                "Identifica fator de amplificação e prevê estabilidade.",
                                "Calcula limite assintótico do erro acumulado.",
                                "Aplica a um método não-linear aproximado.",
                                "Discute impacto de h na propagação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da equação e solução de erro (80% correto).",
                                "Correção da recursão de acumulação e fator ρ.",
                                "Qualidade da simulação e plots (coerência com teoria).",
                                "Análise qualitativa de estabilidade.",
                                "Clareza na explicação de conexões local-global.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/SciPy para análise de erro.",
                                "Física: Modelagem de erros em simulações dinâmicas (ex: movimento orbital).",
                                "Estatística: Análise de variância e propagação de incertezas.",
                                "Engenharia: Controle de estabilidade em sistemas discretos."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou financeiras, modelar propagação de erros locais garante previsões confiáveis, evitando instabilidades que levam a 'efeito borboleta' em modelos de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Analisar a Influência do Tamanho do Passo na Acumulação",
                            "description": "Analisar como o tamanho do passo h afeta a acumulação do erro local, utilizando somas geométricas para estimar o erro total em um intervalo fixo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Erro Local Truncado em Métodos de Passo Simples",
                                  "subSteps": [
                                    "Revise a definição de erro local truncado para métodos como Euler forward.",
                                    "Identifique os termos principais na expansão de Taylor que geram o erro O(h²).",
                                    "Expresse o erro local e_i em um passo como e_i ≈ C h², onde C depende da solução exata.",
                                    "Discuta como o erro local é introduzido a cada iteração.",
                                    "Anote exemplos de EDOs lineares para ilustrar."
                                  ],
                                  "verification": "Escreva a fórmula do erro local para o método de Euler e verifique com uma EDO simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, calculadora, notas de aula sobre métodos numéricos.",
                                  "tips": "Sempre comece pela expansão de Taylor para visualizar os termos truncados.",
                                  "learningObjective": "Identificar e expressar o erro local truncado em termos de h.",
                                  "commonMistakes": "Confundir erro local com erro global; ignorar o fator de dependência da solução."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a Acumulação do Erro Local ao Longo dos Passos",
                                  "subSteps": [
                                    "Determine o número de passos N = (b-a)/h para intervalo fixo [a,b].",
                                    "Assuma que erros locais são aproximadamente independentes ou propagam linearmente.",
                                    "Modele o erro acumulado E_total ≈ ∑_{i=1}^N e_i, com e_i ≈ C h².",
                                    "Reconheça que para erros propagados, pode haver fator de amplificação (ex: soma geométrica).",
                                    "Simplifique para o caso onde erros são aditivos: E_total ≈ N * C h² = C (b-a)/h * h² = C (b-a) h."
                                  ],
                                  "verification": "Calcule N em termos de h e expresse E_total simplificado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, software como Python ou MATLAB para plotar N vs h.",
                                  "tips": "Lembre-se: intervalo fixo significa N ∝ 1/h, então acumulação depende disso.",
                                  "learningObjective": "Modelar matematicamente a soma de erros locais em N passos.",
                                  "commonMistakes": "Esquecer que N diminui quando h aumenta; assumir erros constantes sem h."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Dependência do Erro Total em Relação a h",
                                  "subSteps": [
                                    "Combine modelos: para aditivo, E ∝ h; para geométrico, E ≈ K h (1-λ^N)/(1-λ).",
                                    "Estude assíntota: para h pequeno, λ^N ≈ e^{λ N h} = e^{λ(b-a)}, fixo.",
                                    "Conclua E_total ∝ h para ambos casos em intervalo fixo.",
                                    "Compare com erro global esperado O(h) para Euler.",
                                    "Plote log|E| vs log h para confirmar ordem 1."
                                  ],
                                  "60 minutos": "materials",
                                  "Python/Jupyter para somas numéricas, tabela de valores λ.": "tips",
                                  "Verifique |λ|<1 para convergência; use fórmula fechada sempre que possível.": "learningObjective",
                                  "Dominar uso de somas geométricas para erros propagados.": "commonMistakes",
                                  "Usar soma aritmética em vez de geométrica; ignorar propagação (λ=1).": {},
                                  "verification": "Derive E ∝ h e plote para h=0.1,0.01,0.001.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Matplotlib, Desmos), EDO teste y'=y.",
                                  "tips": "Use escalas log-log para visualizar ordem de convergência.",
                                  "learningObjective": "Concluir analiticamente que acumulação leva a erro global O(h).",
                                  "commonMistakes": "Concluir O(h²) ignorando N∝1/h; confundir local com global."
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1, [0,1], método Euler. Erro local ≈ (1/2) h² e^{ξ}. Acumulado: N=1/h, E_total ≈ (1/2) h ∫ e^x dx ≈ (1/2)(e-1)h. Simule numericamente para h=0.1 (erro ~0.36) vs h=0.01 (erro ~0.036), confirmando O(h).",
                              "finalVerifications": [
                                "Deriva corretamente E_local ≈ C h².",
                                "Expressa N = (b-a)/h e E_aditivo ∝ h.",
                                "Deriva soma geométrica para propagação com fator λ.",
                                "Analisa limite h→0 mostrando E_total ∝ h.",
                                "Valida com simulação numérica e gráfico log-log.",
                                "Explica por que erro global é O(h) apesar de local O(h²)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do erro local (20%).",
                                "Correção no modelo de acumulação e soma geométrica (30%).",
                                "Análise assintótica de dependência em h (20%).",
                                "Uso de exemplo prático com cálculos numéricos (15%).",
                                "Clareza na explicação e gráficos (10%).",
                                "Identificação de suposições (ex: |λ|<1) (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em simulações dinâmicas (ex: movimento orbital).",
                                "Computação: Otimização de h em solvers numéricos (SciPy, ODEINT).",
                                "Engenharia: Controle de erro em simulações CFD ou circuitos.",
                                "Estatística: Análise de variância em métodos Monte Carlo."
                              ],
                              "realWorldApplication": "Em previsões meteorológicas, escolher h ótimo equilibra precisão (erro ∝ h) e custo computacional (∝1/h); em finanças, simular trajetórias de preços de ações com Euler-Maruyama, onde análise de h previne acumulação excessiva de erro em horizontes longos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Comparar Acumulação em Diferentes Métodos",
                            "description": "Comparar a acumulação de erro local entre métodos de Euler e Runge-Kutta, destacando diferenças em estabilidade e crescimento do erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fórmulas e Erro Local dos Métodos Euler e Runge-Kutta",
                                  "subSteps": [
                                    "Estude a fórmula do método de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Analise o método Runge-Kutta de ordem 4 (RK4): escreva as quatro etapas k1 a k4.",
                                    "Derive ou recorde o erro local de truncamento: O(h^2) para Euler e O(h^5) para RK4.",
                                    "Compare as expressões de erro local usando expansão de Taylor.",
                                    "Identifique como o erro local depende de h e das derivadas de f."
                                  ],
                                  "verification": "Escreva as fórmulas e erros locais corretamente em um papel ou notebook.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica, notebook Jupyter ou papel e caneta.",
                                  "tips": "Use diagramas de fluxo para visualizar as iterações de RK4.",
                                  "learningObjective": "Compreender as bases matemáticas dos erros locais em ambos os métodos.",
                                  "commonMistakes": "Confundir erro local com global; ignorar dependência em derivadas de f."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Mecanismo de Acumulação do Erro Local",
                                  "subSteps": [
                                    "Explique como erros locais se acumulam ao longo de N passos para formar o erro global.",
                                    "Calcule erro global aproximado: para Euler, ~ N h^2 |y''|/2; para RK4, ~ N h^5 |y^{(5)}|/120.",
                                    "Discuta o papel do passo h e do intervalo total T = N h.",
                                    "Analise o fator de crescimento do erro: linear em T para ambos, mas com constantes diferentes.",
                                    "Compare estabilidade: Euler pode ser instável para problemas rígidos."
                                  ],
                                  "verification": "Resuma em bullet points as diferenças na acumulação de erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula, calculadora simbólica como SymPy.",
                                  "tips": "Pense em termos de 'soma de erros pequenos' como uma integral de Riemann.",
                                  "learningObjective": "Dominar como erros locais propagam para erros globais.",
                                  "commonMistakes": "Assumir que menor erro local sempre significa melhor método sem considerar h."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Simulações Numéricas para Comparação",
                                  "subSteps": [
                                    "Escolha um PVI teste: y' = -2y, y(0)=1, solução exata y=e^{-2t}.",
                                    "Implemente Euler e RK4 em Python ou MATLAB para t de 0 a 5, h=0.1.",
                                    "Compute erro em cada passo e acumule (norma L2 ou máximo).",
                                    "Varie h (0.5, 0.1, 0.05) e plote erro global vs. h.",
                                    "Registre tabelas de erros acumulados."
                                  ],
                                  "verification": "Gere gráficos mostrando curvas de erro vs. passos para ambos métodos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB, computador.",
                                  "tips": "Use loops eficientes e armazene erros em arrays para plotting fácil.",
                                  "learningObjective": "Aplicar métodos computacionalmente e observar acumulação empírica.",
                                  "commonMistakes": "Erro de programação como off-by-one em índices; não normalizar erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Diferenças em Estabilidade e Crescimento do Erro",
                                  "subSteps": [
                                    "Compare gráficos: RK4 tem erro muito menor para mesmo h.",
                                    "Teste estabilidade com y' = -100y (rígido): Euler diverge, RK4 converge.",
                                    "Calcule razão de erros: erro_Euler / erro_RK4 >>1.",
                                    "Discuta implicações: RK4 permite h maior, menos passos, mais eficiência.",
                                    "Conclua sobre quando usar cada método."
                                  ],
                                  "verification": "Escreva um relatório curto (200 palavras) destacando 3 diferenças chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos gerados, software de plotagem.",
                                  "tips": "Use log-log plots para erro vs. h para ver ordens de convergência.",
                                  "learningObjective": "Interpretar resultados numéricos em termos de teoria.",
                                  "commonMistakes": "Ignorar efeitos de arredondamento; generalizar de um exemplo só."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Comparação e Verificações Finais",
                                  "subSteps": [
                                    "Liste prós/contras: Euler simples mas impreciso/instável; RK4 preciso mas computacionalmente caro.",
                                    "Crie tabela comparativa: erro local, global, estabilidade, custo.",
                                    "Teste outro PVI (ex: y'=y(1-y)) para validar generalidade.",
                                    "Responda perguntas: 'Por que RK4 é melhor para acumulação?'",
                                    "Prepare exemplos para ensino."
                                  ],
                                  "verification": "Crie tabela comparativa e responda 5 perguntas auto-testadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela em Excel ou LaTeX, exemplos prévios.",
                                  "tips": "Foque em quantificar: ordens de precisão e fatores de custo.",
                                  "learningObjective": "Consolidar conhecimento em uma comparação holística.",
                                  "commonMistakes": "Subestimar custo de RK4 (4 avaliações f vs. 1 em Euler)."
                                }
                              ],
                              "practicalExample": "Para o PVI y' = -2y, y(0)=1 até t=5 com h=0.1: Euler acumula erro ~0.15 (instável em casos rígidos), RK4 ~10^{-5}, mostrando superioridade em precisão e estabilidade. Plote y_num vs. y_exata.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença de ordem no erro local (O(h^2) vs O(h^5)).",
                                "Implementar ambos métodos para novo PVI e comparar erros acumulados.",
                                "Identificar quando Euler falha em estabilidade (ex: autovalores negativos grandes).",
                                "Prever comportamento de erro global ao reduzir h pela metade.",
                                "Criar tabela comparativa com 4 métricas (precisão, custo, estabilidade, simplicidade).",
                                "Discutir trade-offs em aplicações reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de erros locais (90% correto).",
                                "Qualidade dos gráficos e tabelas numéricas (clareza e legibilidade).",
                                "Análise correta de estabilidade e crescimento de erro.",
                                "Uso apropriado de múltiplos exemplos e variações de h.",
                                "Profundidade na síntese de diferenças (prós/contras quantificados).",
                                "Ausência de erros conceituais comuns (ex: confundir local/global)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores harmônicos onde estabilidade importa.",
                                "Computação: Otimização de algoritmos numéricos em SciPy/ODEINT.",
                                "Engenharia: Simulações de circuitos RLC com métodos numéricos.",
                                "Estatística: Análise de erro em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias espaciais (NASA usa RK4 para precisão em órbitas longas) ou previsão de epidemias (diferencial SIR), onde Euler acumula erro rapidamente levando a previsões erradas, enquanto RK4 mantém estabilidade para h maiores e simulações eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Erro Global e Ordem de Precisão",
                        "description": "Relação entre o erro de truncamento local e o erro global, incluindo a determinação da ordem de convergência dos métodos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Definir e Derivar o Erro Global",
                            "description": "Definir o erro global como a diferença entre a solução numérica e exata no ponto final, derivando sua relação com o LTE somado sobre N passos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Erro Local de Truncamento (LTE)",
                                  "subSteps": [
                                    "Relembre a definição de LTE para métodos de passo simples em EDOs de valor inicial.",
                                    "Identifique a fórmula do LTE: LTE = (h^{p+1}/(p+1)!) * y^{(p+1)}(ξ) para algum ξ no intervalo.",
                                    "Discuta como o LTE é o erro por passo, assumindo h fixo.",
                                    "Calcule um exemplo simples de LTE para o método de Euler em y' = y, y(0)=1.",
                                    "Explique por que o LTE é local e acumula ao longo de múltiplos passos."
                                  ],
                                  "verification": "Escreva a fórmula do LTE e compute para h=0.1 em um exemplo dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de EDOs)",
                                    "Caderno e calculadora",
                                    "Slides ou notas sobre métodos de Euler/Runge-Kutta"
                                  ],
                                  "tips": "Sempre relacione LTE com a derivada superior da solução exata para entender a origem do erro.",
                                  "learningObjective": "Compreender o LTE como base para o erro global.",
                                  "commonMistakes": [
                                    "Confundir LTE com erro global",
                                    "Ignorar o fator h^{p+1}",
                                    "Esquecer que LTE é por passo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente o Erro Global",
                                  "subSteps": [
                                    "Defina o erro global e_g(t_N) como |y(t_N) - y_N|, onde y(t_N) é a solução exata no tempo final t_N = N h, e y_N é a aproximação numérica.",
                                    "Especifique que t_N é o ponto final após N passos de tamanho h.",
                                    "Diferencie erro global de LTE: global é acumulado, LTE é local por passo.",
                                    "Esboce um diagrama mostrando propagação de erros de y_0 a y_N.",
                                    "Discuta suposições: h fixo, N = T/h, onde T é o intervalo total."
                                  ],
                                  "verification": "Forneça a definição exata de e_g(t_N) e explique em palavras o que representa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para diagrama",
                                    "Exemplo de EDO simples como y' = -y, y(0)=1"
                                  ],
                                  "tips": "Use notação consistente: y_n para numérico, y(t_n) para exato.",
                                  "learningObjective": "Definir precisamente o erro global no contexto de métodos numéricos.",
                                  "commonMistakes": [
                                    "Definir erro global como soma direta de LTEs sem derivação",
                                    "Confundir t_N com h",
                                    "Ignorar o ponto final específico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Relação entre Erro Global e LTE",
                                  "subSteps": [
                                    "Comece com a equação de recursão do método numérico: y_{n+1} = y_n + h φ(t_n, y_n, h).",
                                    "Subtraia a solução exata: y(t_{n+1}) = y(t_n) + h y'(t_n, y(t_n)) + LTE_{n+1}.",
                                    "Analise o erro de propagação: e_{n+1} = e_n + (erro de linearização) + LTE_{n+1}.",
                                    "Some telescopicamente de n=0 a N-1: e_g(t_N) ≈ soma_{k=1}^N LTE_k + termos de estabilidade.",
                                    "Assuma estabilidade (Lipschitz) para mostrar |e_g(t_N)| ≤ (e^{L T} - 1)/L * max |LTE|."
                                  ],
                                  "verification": "Derive a fórmula aproximada e_g ≈ (N) * LTE médio, justificando.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lápis e papel para derivação",
                                    "Referência: Burden & Faires Análise Numérica"
                                  ],
                                  "tips": "Use desigualdade triangular para bounding o erro acumulado.",
                                  "learningObjective": "Derivar matematicamente como LTEs se acumulam no erro global.",
                                  "commonMistakes": [
                                    "Esquecer o fator de amplificação de estabilidade",
                                    "Somar LTEs sem considerar propagação",
                                    "Ignorar condições de Lipschitz"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Ordem de Precisão do Erro Global",
                                  "subSteps": [
                                    "Mostre que se LTE = O(h^{p+1}), então erro global e_g = O(h^p), pois N = T/h.",
                                    "Verifique: soma N * O(h^{p+1}) = (T/h) * O(h^{p+1}) = T O(h^p).",
                                    "Discuta consistência e convergência sob condições de estabilidade.",
                                    "Exemplo numérico: compare erros para h=0.1 e h=0.05 em método de Euler (ordem 1).",
                                    "Conclua a relação ordem global = ordem local - 1 para métodos de passo simples."
                                  ],
                                  "verification": "Calcule ordens numéricas e confirme e_g ~ C h^p.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software como Python/MATLAB para simulação",
                                    "Tabela para log-log plot"
                                  ],
                                  "tips": "Use gráfico log-log de erro vs h para visualizar ordem p.",
                                  "learningObjective": "Conectar ordem do método à precisão global.",
                                  "commonMistakes": [
                                    "Confundir ordem local e global",
                                    "Não dividir por h corretamente",
                                    "Ignorar constantes T"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1, t em [0,1], método de Euler com h=0.1 (N=10). Solução exata y(1)=e≈2.718. y_10≈2.5937, e_g(1)≈0.1246. LTE médio≈0.0125/h, soma≈0.125, confirma relação.",
                              "finalVerifications": [
                                "Define corretamente e_g(t_N) = |y(t_N) - y_N|.",
                                "Deriva e_g ≈ (e^{LT}-1)/L * max|LTE|.",
                                "Explica por que ordem global é p se local é p+1.",
                                "Computa exemplo numérico confirmando relação.",
                                "Discute papel da estabilidade na acumulação.",
                                "Identifica limitações (ex: h pequeno para precisão)."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa e formal do erro global (20%)",
                                "Derivação passo-a-passo da relação com LTE (30%)",
                                "Análise correta de ordem de precisão (20%)",
                                "Exemplo prático com cálculos numéricos (15%)",
                                "Explicação de suposições (estabilidade, consistência) (10%)",
                                "Clareza e notação matemática consistente (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Erros em simulações dinâmicas (ex: trajetórias planetárias).",
                                "Computação: Implementação de solvers numéricos em Python (SciPy).",
                                "Engenharia: Análise de precisão em controle de sistemas.",
                                "Estatística: Propagação de erros em modelos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou previsão financeira, onde erros acumulados em EDOs podem invalidar previsões de longo prazo; derivar erro global guia escolha de h para precisão aceitável sem custo computacional excessivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Determinar a Ordem do Erro Global",
                            "description": "Demonstrar que para um LTE de ordem p+1, o erro global é de ordem p, usando análise assintótica para h → 0 em intervalo fixo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Erro Local de Truncatura (LTE) e Erro Global",
                                  "subSteps": [
                                    "Defina LTE como o erro introduzido em um único passo do método numérico.",
                                    "Explique erro global como a diferença acumulada entre solução exata e numérica ao longo do intervalo.",
                                    "Recapitule que para métodos de passo simples em PVIs, LTE de ordem p+1 relaciona-se ao erro global de ordem p.",
                                    "Estude a notação assintótica: O(h^k) significa termo dominante proporcional a h^k quando h → 0.",
                                    "Identifique o intervalo fixo [a,b] onde h → 0 implica número de passos N ≈ (b-a)/h → ∞."
                                  ],
                                  "verification": "Escreva definições precisas e exemplos de LTE para método de Euler.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (cap. Métodos para PVIs)",
                                    "Notas de aula sobre erros numéricos"
                                  ],
                                  "tips": "Use diagramas de acumulação de erro para visualizar a propagação.",
                                  "learningObjective": "Compreender as diferenças fundamentais entre LTE e erro global.",
                                  "commonMistakes": [
                                    "Confundir LTE com erro global",
                                    "Ignorar o papel da estabilidade na propagação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer a Relação de Acumulação de Erro",
                                  "subSteps": [
                                    "Modele o erro local e_i ≈ C h^{p+1} em cada passo.",
                                    "Some os erros ao longo de N passos: erro global E_N ≈ ∑_{i=1}^N e_i ≈ N C h^{p+1}.",
                                    "Substitua N ≈ T / h, onde T = b - a é o intervalo fixo, obtendo E_N ≈ C T h^p.",
                                    "Verifique que o fator de Lipschitz ou estabilidade garante que erros não explodam.",
                                    "Discuta condições de consistência e convergência do teorema de convergência."
                                  ]
                                },
                                "verification`: ",
                                "estimatedTime",
                                "verificationTime",
                                "30 minutes",
                                "materials",
                                [
                                  "Folha de papel para derivações",
                                  "Software como MATLAB para simulações iniciais de erro"
                                ],
                                "tips",
                                "Mantenha constantes C e T explícitos para clareza na derivação.",
                                "learningObjective",
                                "Derivar a acumulação aproximada de erros locais em erro global.",
                                "commonMistakes",
                                [
                                  "Esquecer que N é proporcional a 1/h",
                                  "Não considerar o intervalo fixo T"
                                ]
                              ],
                              "stepNumber": 4,
                              "title": "Verificar e Sintetizar com Exemplo Numérico",
                              "subSteps": [
                                "Aplique ao método de Euler: LTE O(h^2), global O(h).",
                                "Simule numericamente y' = -y, y(0)=1 em [0,1], refine h e plote log|E|/log h = p.",
                                "Confirme inclinação ≈ p na reta log-log.",
                                "Discuta extensões para métodos de Runge-Kutta.",
                                "Resuma: LTE ordem p+1 ⇒ global ordem p."
                              ],
                              "verification": "Gere gráfico confirmando ordem p para caso teste.",
                              "estimatedTime": "30 minutos",
                              "materials": [
                                "Python/MATLAB com script de solver numérico"
                              ],
                              "tips": "Use h = 2^{-k} para k=3 a 10 para boa resolução log.",
                              "learningObjective": "Validar teoricamente com prática computacional.",
                              "commonMistakes": [
                                "Escolha ruim de h causando ruído numérico",
                                "Não linearizar gráfico de erro"
                              ]
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Verificar Ordem de Precisão Numericamente",
                            "description": "Implementar testes numéricos para verificar a ordem de precisão do erro global em métodos de passo simples, computando log-log de erro versus h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar Problema de Teste e Definir Valores de Passo h",
                                  "subSteps": [
                                    "Escolha um problema de valor inicial simples com solução exata conhecida, como y' = λy, y(0) = y0.",
                                    "Defina o intervalo de integração [a, b] e selecione 4-6 valores de h decrescentes (ex: h = 0.1, 0.05, 0.025, 0.0125, 0.00625).",
                                    "Calcule a solução exata no ponto final b para referência futura.",
                                    "Registre todos os parâmetros em uma tabela organizada.",
                                    "Verifique se os h's cobrem pelo menos duas ordens de magnitude para boa resolução log-log."
                                  ],
                                  "verification": "Tabela completa com problema, solução exata e lista de h's confirmada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel ou planilha (Excel/Google Sheets)",
                                    "Documentação do método numérico (ex: Euler forward)"
                                  ],
                                  "tips": "Comece com λ negativo para estabilidade; use h's que sejam potências de 1/2 para simplificar cálculos.",
                                  "learningObjective": "Entender a importância de uma solução exata conhecida e variação adequada de h para análise de convergência.",
                                  "commonMistakes": [
                                    "Escolher h's não decrescentes o suficiente",
                                    "Usar problema sem solução analítica fechada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Método Numérico para Diferentes h",
                                  "subSteps": [
                                    "Implemente o método de passo simples (ex: Euler forward: y_{n+1} = y_n + h f(t_n, y_n)) em código ou manualmente.",
                                    "Compute a solução numérica aproximada y_h(b) para cada h até o ponto final b.",
                                    "Repita para todos os h's selecionados, salvando y_h(b) em uma tabela.",
                                    "Teste o código com um h conhecido para validar implementação.",
                                    "Documente o número de passos N = (b-a)/h para cada caso."
                                  ],
                                  "verification": "Tabela com y_h(b) para cada h gerada e validada contra um caso conhecido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python/MATLAB com NumPy)",
                                    "Editor de código (Jupyter Notebook)"
                                  ],
                                  "tips": "Use loops para automatizar; vetorize computações para eficiência.",
                                  "learningObjective": "Dominar a implementação prática de métodos numéricos e gerenciar diferentes tamanhos de passo.",
                                  "commonMistakes": [
                                    "Erro na fórmula do método (ex: esquecendo h)",
                                    "Overflow numérico com h muito pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Erros Globais Absolutos",
                                  "subSteps": [
                                    "Para cada h, compute o erro global absoluto e_h = |y_exata(b) - y_h(b)|.",
                                    "Registre e_h em uma tabela junto com h e log10(h).",
                                    "Calcule log10(e_h) para cada caso.",
                                    "Verifique se os erros diminuem monotonicamente com h reduzido.",
                                    "Identifique qualquer anomalia (ex: erro não decrescendo devido a instabilidade)."
                                  ],
                                  "verification": "Tabela completa com h, log10(h), e_h e log10(e_h) sem discrepâncias.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha ou código para cálculos logarítmicos"
                                  ],
                                  "tips": "Use abs() para erros absolutos; confira unidades consistentes.",
                                  "learningObjective": "Quantificar precisamente o erro global e preparar dados para análise log-log.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Erro de sinal no logaritmo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir Gráfico Log-Log e Determinar Ordem de Precisão",
                                  "subSteps": [
                                    "Plote log10(e_h) versus log10(h) usando gráfico de dispersão.",
                                    "Ajuste uma reta linear aos pontos: inclinação p ≈ ordem de precisão (erro ~ C h^p).",
                                    "Use regressão linear mínima quadrados para calcular p numericamente.",
                                    "Interprete: para Euler forward, espere p ≈ 1.",
                                    "Valide com fórmula teórica e discuta desvios."
                                  ],
                                  "verification": "Gráfico log-log com reta ajustada e valor de p reportado (ex: p = 0.98).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca de plotagem (Matplotlib/Python, plot em MATLAB)",
                                    "Ferramenta de regressão (numpy.polyfit)"
                                  ],
                                  "tips": "Use escala log-log diretamente; exclua pontos ruidosos se necessário.",
                                  "learningObjective": "Aplicar análise log-log para verificar empiricamente a ordem de convergência.",
                                  "commonMistakes": [
                                    "Plotar log(e_h) vs h em vez de log(h)",
                                    "Ignorar termo constante na regressão"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1 em [0,1] com Euler forward: h=[0.1,0.05,0.025,0.0125]. Solução exata y(1)=exp(-1)≈0.3679. y_h(1) diminui erro de ~0.07 para ~0.004, log-log mostra inclinação ≈1 confirmando ordem 1.",
                              "finalVerifications": [
                                "Tabela de h, e_h e log-log completa e precisa.",
                                "Gráfico log-log exibe inclinação linear com p próximo ao valor teórico.",
                                "Regressão linear computada corretamente (R² > 0.99).",
                                "Interpretação escrita: 'Ordem p=X confirmada'.",
                                "Código ou cálculos reproduzíveis sem erros.",
                                "Discussão de possíveis desvios (ex: arredondamento)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos erros globais (erro < 1e-10 em cálculos).",
                                "Qualidade do gráfico log-log (eixos corretos, legenda, ajuste visual).",
                                "Valor de p calculado com erro <5% do teórico.",
                                "Documentação completa de passos e tabelas.",
                                "Código limpo, comentado e eficiente.",
                                "Análise de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Estatística: Regressão linear e análise de dados.",
                                "Física: Modelagem de decaimento exponencial em sistemas dinâmicos.",
                                "Engenharia Computacional: Verificação de algoritmos em simulações."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos ou epidemias, verifica se o esquema numérico converge na ordem esperada antes de rodar em malhas finas, otimizando tempo computacional em CFD ou modelos climáticos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Consistência e Convergência",
                    "description": "Condições para que métodos de passo simples sejam consistentes e convergentes na solução de problemas de valor inicial.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Consistência de Métodos de Passo Simples",
                        "description": "Conceito fundamental que verifica se o método numérico aproxima localmente a equação diferencial exata, medido pelo erro local de truncamento que tende a zero à medida que o passo h diminui.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Definir consistência para métodos de passo simples",
                            "description": "Explicar a definição formal de consistência: um método é consistente se o operador de diferença finita L_h(u) satisfaz lim_{h→0} ||L_h(u) - L(u)|| = 0 para soluções suaves u da EDO y' = f(t,y).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Problemas de Valor Inicial (PVI) e Métodos de Passo Simples",
                                  "subSteps": [
                                    "Lembre-se da forma geral de um PVI: y' = f(t, y), y(t0) = y0.",
                                    "Identifique métodos de passo simples como Euler explícito, onde y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Entenda que esses métodos usam diferenças finitas para aproximar a derivada.",
                                    "Discuta a importância da precisão local versus global.",
                                    "Anote exemplos simples de EDOs lineares para ilustrar."
                                  ],
                                  "verification": "Escreva a forma geral de um PVI e dê um exemplo de método de passo simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica",
                                    "Caderno e caneta"
                                  ],
                                  "tips": "Comece com EDOs simples para fixar conceitos antes da formalização.",
                                  "learningObjective": "Compreender o contexto dos métodos numéricos para PVIs.",
                                  "commonMistakes": "Confundir métodos de passo simples com métodos multi-passo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Operador de Diferença Finita L_h(u)",
                                  "subSteps": [
                                    "Defina L_h(u) como o operador que mede o erro local: para um método, L_h(u)(t_n) ≈ (u(t_{n+1}) - u(t_n))/h - f(t_n, u(t_n)).",
                                    "Explique que L_h(u) é aplicado a uma função suave u em uma malha com passo h.",
                                    "Calcule L_h(u) explicitamente para o método de Euler.",
                                    "Discuta como L_h(u) deve se aproximar de zero para soluções exatas quando h é pequeno.",
                                    "Pratique com uma função teste suave, como u(t) = e^t."
                                  ],
                                  "verification": "Compute L_h(u) para u(t) = sin(t) no método de Euler e verifique se é pequeno para h pequeno.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/MATLAB",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Use expansões de Taylor para entender a ordem de aproximação.",
                                  "learningObjective": "Dominar a notação e cálculo do operador de diferença finita.",
                                  "commonMistakes": "Esquecer de interpolar u nos pontos da malha."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o Operador Diferencial Exato L(u)",
                                  "subSteps": [
                                    "Estabeleça L(u) = u' - f(t, u), que é zero para soluções exatas do PVI.",
                                    "Explique que L(u) representa o operador diferencial contínuo.",
                                    "Compare L(u) com L_h(u), destacando que L_h é a discretização de L.",
                                    "Verifique que para u suave, L(u) = 0 implica consistência potencial.",
                                    "Ilustre com gráfico: L(u) = 0 vs L_h(u) ≈ 0."
                                  ],
                                  "verification": "Escreva L(u) para y' = y e confirme que soluções exatas satisfazem L(u) = 0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráficos em papel ou software de plotagem"
                                  ],
                                  "tips": "Sempre associe L(u) à equação diferencial original.",
                                  "learningObjective": "Entender a relação entre o contínuo e o discreto.",
                                  "commonMistakes": "Confundir L(u) com o resíduo global."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a Definição de Consistência",
                                  "subSteps": [
                                    "Enuncie: Um método é consistente se lim_{h→0} ||L_h(u) - L(u)|| = 0 para toda u suave.",
                                    "Especifique a norma ||.||, tipicamente máxima ou L^∞ em [t0, T].",
                                    "Discuta suavidade: u ∈ C^k com k suficiente para o método.",
                                    "Verifique consistência para Euler (ordem 1).",
                                    "Conclua que consistência é necessária para convergência."
                                  ],
                                  "verification": "Escreva a definição completa e prove para um método de ordem 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referência teórica",
                                    "Exercícios resolvidos"
                                  ],
                                  "tips": "Lembre-se: consistência é lim h→0 do erro de truncamento local.",
                                  "learningObjective": "Enunciar e justificar a definição formal de consistência.",
                                  "commonMistakes": "Omitir 'para soluções suaves u' ou a norma na definição."
                                }
                              ],
                              "practicalExample": "Para o método de Euler no PVI y' = y, y(0)=1 (solução exata y=e^t): L_h(u)(t_n) = (e^{t_{n+1}} - e^{t_n})/h - e^{t_n}. Usando Taylor, isso é O(h), então lim_{h→0} max |L_h(u)| = 0, provando consistência.",
                              "finalVerifications": [
                                "Enuncie corretamente a definição de consistência.",
                                "Explique o papel de L_h(u) e L(u).",
                                "Calcule L_h para Euler e mostre o limite.",
                                "Identifique requisitos de suavidade em u.",
                                "Distinga consistência de convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (incluindo limite e norma).",
                                "Compreensão conceitual de operadores L_h e L.",
                                "Capacidade de calcular exemplos concretos.",
                                "Reconhecimento de condições (suavidade de u).",
                                "Aplicação a métodos específicos como Euler.",
                                "Diferenciação de conceitos relacionados (estabilidade, ordem)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar L_h em Python para testar consistência.",
                                "Física: Aplicar em modelos de movimento (EDOs de segunda ordem).",
                                "Engenharia: Simulações em controle de sistemas dinâmicos.",
                                "Estatística: Análise de erros numéricos e truncamento."
                              ],
                              "realWorldApplication": "Em simulações computacionais para previsão meteorológica, dinâmica de fluidos ou finanças (modelos Black-Scholes), a consistência garante que reduções no passo h melhorem a aproximação da solução real, evitando erros acumulados em integrações longas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Calcular o erro local de truncamento",
                            "description": "Derivar e calcular o erro local de truncamento para métodos como Euler explícito, usando expansão de Taylor: para y' = f(t,y), o erro é O(h^2) no método de Euler.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de erro local de truncamento (LTE)",
                                  "subSteps": [
                                    "Defina o problema de valor inicial (PVI): y' = f(t, y), y(t0) = y0.",
                                    "Explique que o LTE é o erro introduzido ao aproximar y(t_{n+1}) por um passo h, assumindo y(t_n) exato.",
                                    "Diferencie LTE de erro global: LTE é local por passo, acumula para global.",
                                    "Lembre que para consistência, LTE deve ser O(h^{p+1}) para ordem p.",
                                    "Estude a fórmula geral: LTE = [y(t_n + h) - y_n^{pred}] / h, onde y_n^{pred} é a predição."
                                  ],
                                  "verification": "Escreva uma definição precisa do LTE e dê um exemplo qualitativo para Euler.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (cap. Métodos de Euler)",
                                    "Notas de aula sobre PVI"
                                  ],
                                  "tips": "Visualize o LTE como a diferença entre a curva exata e a reta tangente extrapolada.",
                                  "learningObjective": "Compreender o que é e por que o LTE é crucial para a análise de métodos numéricos.",
                                  "commonMistakes": [
                                    "Confundir LTE com erro global",
                                    "Ignorar a normalização por h"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver a expansão de Taylor da solução exata",
                                  "subSteps": [
                                    "Expanda y(t_n + h) em série de Taylor ao redor de t_n: y(t_n + h) = y(t_n) + h y'(t_n) + (h^2/2) y''(t_n) + (h^3/6) y'''(ξ).",
                                    "Expresse derivadas superiores usando a equação diferencial: y' = f, y'' = df/dt = f_t + f_y f, etc.",
                                    "Continue até o termo O(h^2) ou O(h^3), dependendo da ordem desejada.",
                                    "Identifique os termos principais para métodos de ordem 1 como Euler.",
                                    "Escreva y(t_n + h) = y(t_n) + h f(t_n, y(t_n)) + (h^2/2) y''(ξ)."
                                  ],
                                  "verification": "Derive a expansão de Taylor de y(t + h) até O(h^2) para um f genérico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de derivadas em cadeia para y''",
                                    "Calculadora simbólica opcional"
                                  ],
                                  "tips": "Use notação Leibniz para derivadas de ordem superior em PVI.",
                                  "learningObjective": "Dominar a expansão de Taylor aplicada a soluções de EDOs.",
                                  "commonMistakes": [
                                    "Esquecer o termo de resto de Lagrange",
                                    "Erro na derivada de segunda ordem y''"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a aproximação do método de Euler explícito",
                                  "subSteps": [
                                    "Escreva a iteração de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Expanda y_{n+1} em Taylor assumindo y_n = y(t_n): mas como é linear em h, só tem até O(h).",
                                    "Compare com a exata: y(t_{n+1}) - y_{n+1} = [y(t_n) + h f + (h^2/2) y''(ξ)] - [y_n + h f] = (h^2/2) y''(ξ).",
                                    "Divida por h para LTE: τ = (h/2) y''(ξ) = O(h^2).",
                                    "Generalize para mostrar ordem 2 em h."
                                  ],
                                  "verification": "Mostre que LTE para Euler é O(h^2) com o termo líder explícito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo resolvido de livro-texto",
                                    "Papel e lápis para derivação"
                                  ],
                                  "tips": "Substitua ξ ≈ t_n para aproximação, mas mantenha exato.",
                                  "learningObjective": "Calcular analiticamente o LTE para o método de Euler.",
                                  "commonMistakes": [
                                    "Esquecer dividir por h no LTE",
                                    "Confundir y_{n+1} com solução exata"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar o cálculo do LTE em um exemplo concreto",
                                  "subSteps": [
                                    "Escolha y' = -y, y(0)=1 (solução exata y=e^{-t}).",
                                    "Compute y'' = y' ' = -y' = y, então LTE ≈ (h^2/2) y(t_n).",
                                    "Para t_n=0, h=0.1, estime LTE = (0.1^2 / 2) * 1 = 0.005.",
                                    "Compare com erro numérico real: y(0.1) exata ≈0.9048, Euler=0.9, erro local≈0.0048/h=0.048? Ajuste cálculo.",
                                    "Valide numericamente vs. analítico."
                                  ],
                                  "verification": "Calcule LTE para o exemplo dado e compare com simulação numérica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software como Python/MATLAB para verificação numérica",
                                    "Tabela de valores exatos"
                                  ],
                                  "tips": "Use h pequeno para validar O(h^2) plotando log-erro vs log-h.",
                                  "learningObjective": "Aplicar a derivação de LTE a um PVI específico e validar.",
                                  "commonMistakes": [
                                    "Erro aritmético no exemplo",
                                    "Não normalizar por h"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1 (y(t)=e^t), método Euler: y1 = 1 + h*1 = 1+h. Exata: e^h = 1 + h + h^2/2 + O(h^3). LTE = [e^h - (1+h)] / h = (h/2 + O(h^2)) = O(h). Termo líder (h/2) y''(ξ)/2? y''=y, sim (h/2) e^ξ.",
                              "finalVerifications": [
                                "Deriva corretamente a expansão de Taylor da solução exata até O(h^2).",
                                "Identifica o termo líder do LTE como (h/2) y''(ξ) para Euler.",
                                "Calcula LTE para um exemplo específico com precisão numérica.",
                                "Explica por que Euler é consistente (LTE → 0 quando h→0).",
                                "Distingue LTE de outros erros em métodos numéricos.",
                                "Valida O(h^2) via análise assintótica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor (sem erros em coeficientes).",
                                "Correta identificação e cálculo do termo de erro principal.",
                                "Uso apropriado do teorema do resto de Taylor.",
                                "Aplicação correta a exemplo numérico com comparação exata.",
                                "Clareza na explicação da ordem de consistência.",
                                "Ausência de confusão entre LTE local e global."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de erros em simulações de movimento (e.g., Euler para integrais de movimento).",
                                "Computação: Implementação de solvers numéricos em Python (scipy.integrate).",
                                "Engenharia: Modelagem de circuitos RC com EDOs aproximados.",
                                "Estatística: Erros de truncamento em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias de foguetes (NASA usa métodos com baixo LTE), previsão de epidemias (SIR models com Euler para protótipos rápidos), ou trading algorítmico onde erros acumulados afetam lucros em ODEs financeiras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Determinar a ordem de consistência",
                            "description": "Identificar a ordem p de consistência tal que o erro local de truncamento é O(h^{p+1}), verificando coeficientes na expansão de Taylor para métodos de Runge-Kutta de passo simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de ordem de consistência e erro local de truncamento",
                                  "subSteps": [
                                    "Recordar que um método numérico é consistente de ordem p se o erro local de truncamento τ(h) satisfaz τ(h) = O(h^{p+1}) quando h → 0",
                                    "Entender o erro local de truncamento como a diferença entre a solução exata em um passo e a aproximação numérica, assumindo y_n exato",
                                    "Revisar os componentes do método de Runge-Kutta de passo simples: tabela de Butcher (matrizes A, vetores b e c)",
                                    "Estudar a condição de consistência de ordem 1: ∑ b_i = 1",
                                    "Diferenciar consistência de convergência e estabilidade"
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a definição de ordem p e dar um exemplo para p=1",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre métodos RK",
                                    "Livro de Burden & Faires - Análise Numérica",
                                    "Folha de papel para anotações"
                                  ],
                                  "tips": "Comece sempre pela ordem 1 para construir intuição antes de ordens superiores",
                                  "learningObjective": "Definir precisamente ordem de consistência e seu papel na análise de métodos numéricos",
                                  "commonMistakes": [
                                    "Confundir erro local com erro global de acumulação",
                                    "Esquecer o expoente p+1 no O(h^{p+1})",
                                    "Ignorar que consistência requer h→0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a expansão de Taylor da solução exata y(t + h)",
                                  "subSteps": [
                                    "Escrever y' = f(t, y)",
                                    "Calcular derivadas sucessivas: y'' = df/dt + (df/dy) y' = ∂f/∂t + ∂f/∂y f, e assim por diante até ordem desejada (ex: até h^4 para p=3)",
                                    "Expandir y(t + h) = y(t) + h y'(t) + (h^2/2!) y''(t) + (h^3/3!) y'''(t) + (h^4/4!) y^{(4)}(t) + O(h^5)",
                                    "Expressar todos os termos em função de f e suas derivadas parciais (árvores de derivadas elementares)",
                                    "Verificar os coeficientes para ordens baixas manualmente"
                                  ],
                                  "verification": "Derivar corretamente a expansão até O(h^4) para f(t,y) = y (solução exata conhecida)",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como SymPy",
                                    "Tabela de derivadas parciais de f",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Use notação de jatos (jets) ou software para derivadas altas para evitar cálculos tediosos",
                                  "learningObjective": "Obter a série de Taylor exata da solução em um passo h",
                                  "commonMistakes": [
                                    "Erro no cálculo de derivadas compostas (cadeia de Leibniz)",
                                    "Confundir derivadas parciais ∂f/∂t e ∂f/∂y",
                                    "Esquecer fatoriais nos coeficientes de Taylor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a expansão de Taylor da aproximação numérica do método RK",
                                  "subSteps": [
                                    "Escrever as etapas do método: k_i = f(t + c_i h, y + h ∑_{j=1}^s a_{ij} k_j) para i=1..s",
                                    "Expandir cada k_i em série de Taylor em torno de (t,y), usando expansão multivariável",
                                    "Inserir as expansões dos k_i na fórmula final y_{n+1} = y_n + h ∑_{i=1}^s b_i k_i",
                                    "Coletar termos por potências de h até a ordem desejada (ex: até h^{p+1})",
                                    "Simplificar expressando em termos das mesmas derivadas elementares de f usadas na solução exata"
                                  ],
                                  "verification": "Obter a expansão de y_1 até O(h^3) para o método de Euler (s=1, a_{11}=0, b_1=1, c_1=0)",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabela de Butcher do método específico",
                                    "Software Mathematica ou Maple para expansão simbólica",
                                    "Folhas para expansões parciais"
                                  ],
                                  "tips": "Expanda k_i iterativamente, começando pelos mais simples; use simetria na tabela A se aplicável",
                                  "learningObjective": "Construir a série de Taylor da solução numérica em termos das condições do método RK",
                                  "commonMistakes": [
                                    "Erro na expansão recursiva dos k_i (termos circulares)",
                                    "Confundir índices i e j na soma de A",
                                    "Não truncar corretamente os O(h^k) em expansões internas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar coeficientes e determinar a ordem p de consistência",
                                  "subSteps": [
                                    "Igualar as expansões: y(t+h) = y_1 + O(h^{p+1})",
                                    "Comparar coeficientes de h^k para k=1 até o maior possível: ordem 1 (∑b_i=1), ordem 2 (∑b_i c_i = 1/2), etc.",
                                    "Identificar a maior p tal que coeficientes coincidem até h^{p+1}, e divergem em h^{p+2}",
                                    "Verificar as condições de ordem de Butcher: B(p) para ordem p",
                                    "Testar numericamente com h pequeno para validar (opcional)",
                                    "verification"
                                  ],
                                  "verification": "Para um método RK dado, listar as condições satisfeitas e concluir p corretamente",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de condições B(p) para p=1 a 4",
                                    "Exemplo de tabela Butcher"
                                  ],
                                  "tips": "Use as condições padrão de ordem em vez de expandir tudo do zero para métodos conhecidos",
                                  "learningObjective": "Determinar p comparando séries e verificando condições de consistência",
                                  "commonMistakes": [
                                    "Parar comparação cedo demais",
                                    "Confundir ordem de ∑b_i c_i =1/2 com ordem 1",
                                    "Ignorar termos O(h^{p+1}) na definição"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o método de Heun (RK2): c=[0,1], A=[[0,0],[1,0]], b=[1/2,1/2]. Expanda y(t+h) e y1 até O(h^3). Coeficientes: h: ambos  f; h^2: exata f'/2 + (f_y f)/2, numérica mesma; h^3 divergem. Logo p=2.",
                              "finalVerifications": [
                                "Derivar corretamente expansões até O(h^4) para um método RK simples",
                                "Identificar p=1 para Euler e p=4 para RK clássico",
                                "Listar condições B(1), B(2), B(3) sem consultar notas",
                                "Explicar por que consistência é necessária para convergência",
                                "Aplicar a um método não padrão e concluir p corretamente",
                                "Verificar numericamente com h=0.1 vs solução exata"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das séries de Taylor (sem erros algébricos)",
                                "Correta identificação do maior p com justificativa por coeficientes",
                                "Uso adequado de notação e condições de Butcher",
                                "Clareza na comparação de coeficientes lado a lado",
                                "Capacidade de generalizar para métodos de ordem arbitrária",
                                "Ausência de confusão entre erro local e global"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar RK em Python/Octave e testar ordem numericamente via richardson extrapolation",
                                "Física: Análise de precisão em simulações de movimento orbital (EDOs não lineares)",
                                "Engenharia: Otimização de métodos em controle de sistemas dinâmicos",
                                "Estatística: Estudo de erros de truncamento em Monte Carlo para EDOs estocásticas"
                              ],
                              "realWorldApplication": "Em simulações científicas como previsão meteorológica, dinâmica de fluidos ou modelagem epidemiológica (ex: SIR), determinar a ordem de consistência guia a escolha do método RK para equilibrar precisão e custo computacional, evitando erros acumulados em longas integrações."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Convergência de Métodos de Passo Simples",
                        "description": "Propriedade que garante que a solução numérica y_n converge para a solução exata y(t_n) quando h → 0, relacionando erro global acumulado.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Definir convergência global",
                            "description": "Definir convergência: max_n |y_n - y(t_n)| → 0 quando h → 0, para problema de valor inicial y' = f(t,y), y(t_0)=y_0 em intervalo [t_0, T].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Problema de Valor Inicial e Métodos de Passo Simples",
                                  "subSteps": [
                                    "Lembre-se da forma geral do problema de valor inicial (IVP): y' = f(t, y), y(t₀) = y₀ em [t₀, T].",
                                    "Descreva métodos de passo simples, como o método de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Identifique os pontos de grade: t_n = t₀ + n h, onde h é o tamanho do passo.",
                                    "Explique a aproximação numérica y_n ≈ y(t_n).",
                                    "Discuta a importância da precisão ao refinar a malha (h → 0)."
                                  ],
                                  "verification": "Escreva a equação do IVP e o esquema de um método de passo simples, como Euler, corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Análise Numérica (capítulo de EDOs), caderno de anotações.",
                                  "tips": "Use diagramas de grade temporal para visualizar t_n e y_n.",
                                  "learningObjective": "Compreender o contexto do IVP e como métodos numéricos geram sequências aproximadas.",
                                  "commonMistakes": "Confundir y' = f(t,y) com y'' ou esquecer a condição inicial y(t₀)=y₀."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Erro Local e Erro Global",
                                  "subSteps": [
                                    "Defina erro local de truncamento: erro em um único passo assumindo y_n exato.",
                                    "Defina erro global: acumulação de erros ao longo de todo o intervalo [t₀, T].",
                                    "Explique por que o erro global é medido por max_n |y_n - y(t_n)| sobre n tal que t_n ≤ T.",
                                    "Discuta como erros locais se propagam devido à estabilidade.",
                                    "Relacione com o teorema de consistência e estabilidade para convergência."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre erro local e global, com um esboço ilustrativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Notas de aula sobre consistência, exemplos de erros em métodos numéricos.",
                                  "tips": "Pense no erro global como uma 'bola de neve' que cresce com o número de passos N ≈ (T-t₀)/h.",
                                  "learningObjective": "Distinguir tipos de erro e preparar o terreno para a definição de convergência.",
                                  "commonMistakes": "Achar que erro global é só soma de erros locais sem considerar propagação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente a Convergência Global",
                                  "subSteps": [
                                    "Escreva a definição: Um método converge globalmente se lim_{h→0} max_{n: t_n ≤ T} |y_n - y(t_n)| = 0.",
                                    "Interprete max_n |y_n - y(t_n)| como a norma do erro máximo no intervalo.",
                                    "Explique que h → 0 implica N → ∞, mas o erro total vai a zero.",
                                    "Mencione que isso vale para soluções y(t) suficientemente suaves e f Lipschitz.",
                                    "Escreva a notação completa: para todo ε > 0, existe δ > 0 tal que se 0 < h < δ, então max_n |y_n - y(t_n)| < ε."
                                  ],
                                  "verification": "Redija a definição exata de convergência global em um papel e verifique contra a fórmula padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de referência com definições de convergência, calculadora para notação.",
                                  "tips": "Memorize a frase chave: 'o erro máximo tende a zero quando h tende a zero'.",
                                  "learningObjective": "Formular precisamente a definição matemática de convergência global.",
                                  "commonMistakes": "Escrever lim_{h→0} em vez de max_n |y_n - y(t_n)| → 0, ou inverter o limite."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Verificar a Definição",
                                  "subSteps": [
                                    "Discuta implicações: convergência garante que a solução numérica aproxima a exata para h pequeno.",
                                    "Relacione com o Teorema de Lax: consistência + estabilidade ⇒ convergência.",
                                    "Crie um fluxograma: IVP → Método → Erro Global → h→0 → Convergência.",
                                    "Teste com exemplo simples: y' = y, solução y(t)=e^t.",
                                    "Resuma condições necessárias: f contínua, Lipschitz em y."
                                  ],
                                  "verification": "Aplique a definição a um método conhecido e confirme se converge.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software como Python/MATLAB para simular (opcional), exemplos resolvidos.",
                                  "tips": "Sempre especifique o intervalo [t₀, T] fixo para evitar confusões com T dependendo de h.",
                                  "learningObjective": "Aplicar e interpretar a definição em contextos teóricos e práticos.",
                                  "commonMistakes": "Ignorar a dependência em T fixo ou assumir convergência sem estabilidade."
                                }
                              ],
                              "practicalExample": "Considere y' = -y, y(0)=1, solução exata y(t)=e^{-t} em [0,1]. Usando Euler com h=0.1, compute y_n e max_n |y_n - y(t_n)| ≈ 0.004; com h=0.01, erro ≈ 0.0004. Observe que ao reduzir h por 10, erro reduz por ~10, confirmando max erro →0 quando h→0.",
                              "finalVerifications": [
                                "Escreva corretamente a definição de convergência global para IVP.",
                                "Identifique os componentes: max_n |y_n - y(t_n)|, h→0, intervalo [t₀,T].",
                                "Diferencie de convergência local.",
                                "Explique o papel da estabilidade.",
                                "Aplique a um exemplo simples como y'=y.",
                                "Confirme condições em f(t,y)."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa e completa (peso 30%).",
                                "Interpretação correta do limite e norma máxima (25%).",
                                "Diferenciação clara de conceitos relacionados (20%).",
                                "Exemplo prático com cálculo de erro (15%).",
                                "Conexão com teoremas como Lax (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação numérica em Python (biblioteca SciPy).",
                                "Física: Modelagem de decaimento radioativo ou circuitos RC.",
                                "Engenharia: Simulações de dinâmica em controle de sistemas.",
                                "Estatística: Análise de erro em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em previsões meteorológicas, métodos numéricos convergentes simulam equações diferenciais para trajetórias de partículas atmosféricas; h pequeno garante precisão em modelos como os usados pelo ECMWF, onde erro global < 1km em 24h."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Analisar o erro global de truncamento",
                            "description": "Explicar como o erro global é O(h^p) se o método é consistente de ordem p e estável, usando análise de erro de propagação em métodos de passo simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Erro Local de Truncamento e Consistência de Ordem p",
                                  "subSteps": [
                                    "Defina o erro local de truncamento (LTE) para métodos de passo simples como a diferença entre a solução exata e a numérica em um passo h.",
                                    "Explique a consistência de ordem p: LTE = O(h^{p+1}).",
                                    "Derive a expansão de Taylor para a EDO y' = f(t,y) para mostrar os termos de ordem h^{p+1}.",
                                    "Verifique com exemplo do método de Euler (p=1).",
                                    "Confirme que o método é consistente se lim_{h->0} LTE/h^p = 0."
                                  ],
                                  "verification": "Escreva a fórmula do LTE para um método genérico e identifique o termo líder O(h^{p+1}).",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Livro de Análise Numérica (capítulo de métodos ODE)",
                                    "EDO de teste: y' = y, y(0)=1"
                                  ],
                                  "tips": "Use expansão de Taylor passo a passo, anotando cada derivada.",
                                  "learningObjective": "Compreender como a consistência de ordem p leva a LTE = O(h^{p+1}).",
                                  "commonMistakes": [
                                    "Confundir LTE com erro global",
                                    "Esquecer o fator 1/h na definição de consistência",
                                    "Ignorar condições de Lipschitz"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Erro Global e a Recursão de Propagação",
                                  "subSteps": [
                                    "Defina o erro global e_g(t_n) = y(t_n) - y_n, onde y_n é a aproximação numérica.",
                                    "Estabeleça a recursão: e_{n+1} = e_n + (LTE_{n+1} + erro de arredondamento).",
                                    "Some a recursão telescópica: e_N = sum_{k=1}^N LTE_k + termos iniciais.",
                                    "Assuma passos de tamanho fixo h, t_n = n h, N = T/h.",
                                    "Expresse o erro acumulado como e(T) ≈ (1/h) * sum LTE."
                                  ],
                                  "verification": "Derive a soma telescópica para e_N e simplifique para O(h^p).",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Papel milimetrado para somas",
                                    "Software como Python/MATLAB para simular soma",
                                    "Exemplo numérico simples"
                                  ],
                                  "tips": "Pense na propagação como uma soma geométrica aproximada.",
                                  "learningObjective": "Modelar o erro global como acumulação do erro local via recursão.",
                                  "commonMistakes": [
                                    "Esquecer de dividir por h no número de passos",
                                    "Ignorar o fator de amplificação por passo",
                                    "Confundir índices n e n+1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Estabilidade e o Fator de Propagação",
                                  "subSteps": [
                                    "Defina estabilidade: |y_{n+1} - y(t_{n+1})| ≤ K |y_n - y(t_n)| + LTE, com K≈1.",
                                    "Para métodos lineares, use o polinômio de amplificação |R(z)| ≤ 1 + O(|z|), z = h λ.",
                                    "Mostre que sob estabilidade, o erro não explode: ||e_n|| ≤ C sum |LTE_k|.",
                                    "Combine com LTE = O(h^{p+1}), sum = O(h) * O(h^{p+1}) = O(h^p).",
                                    "Verifique região de estabilidade absoluta para passos simples."
                                  ],
                                  "verification": "Prove que sob estabilidade, max |e_n| = O(h^p) para consistência ordem p.",
                                  "estimatedTime": "50 minutes",
                                  "materials": [
                                    "Gráfico da região de estabilidade (Euler)",
                                    "EDO teste: y' = -y",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Desenhe o plano z para visualizar estabilidade.",
                                  "learningObjective": "Entender como estabilidade previne crescimento exponencial do erro.",
                                  "commonMistakes": [
                                    "Assumir K=1 sem prova",
                                    "Confundir estabilidade absoluta com relativa",
                                    "Ignorar Lipschitz em f"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a Análise de Convergência Global",
                                  "subSteps": [
                                    "Teorema: Método consistente ordem p e estável implica convergência com erro global O(h^p).",
                                    "Escreva a prova completa: |e_n| ≤ (e_0 + sum LTE) * max amplificação.",
                                    "Teste numericamente com refinamento h → 0, log-log plot de erro vs h.",
                                    "Discuta limitações: passos variáveis, não-linearidades.",
                                    "Resuma condições: f Lipschitz, y analítica, h pequeno o suficiente."
                                  ],
                                  "verification": "Implemente simulação e confirme ordem p no log-log.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Código template para método de Euler/Runge-Kutta",
                                    "Gráfico log-log"
                                  ],
                                  "tips": "Use h = 2^{-k} para k=1 a 10 para plot claro.",
                                  "learningObjective": "Sintetizar consistência + estabilidade → erro global O(h^p).",
                                  "commonMistakes": [
                                    "Não normalizar erro por h^p",
                                    "Escolha ruim de EDO teste (rígida)",
                                    "Plot sem log-log"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método de Euler (p=1) na EDO y' = y, y(0)=1, solução exata y(t)=exp(t). Simule até t=1 com h=0.1, 0.05, etc. Calcule erro global em t=1, plote log(erro) vs log(h), inclinação ≈ -1 confirma O(h). Some LTE ≈ h^2 / 2 * exp(ξ), total O(h).",
                              "finalVerifications": [
                                "Deriva corretamente a recursão de erro e soma telescópica.",
                                "Explica o papel da estabilidade em limitar amplificação (K≈1).",
                                "Mostra que sum_{k=1}^{T/h} O(h^{p+1}) = O(h^p).",
                                "Implementa simulação numérica confirmando ordem p.",
                                "Identifica condições necessárias (Lipschitz, h na região estável).",
                                "Discute por que instabilidade leva a divergência apesar de consistência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do LTE e sua relação com ordem p (80% correto).",
                                "Correta manipulação da recursão e soma de erros (com prova).",
                                "Demonstração clara do papel da estabilidade via fator de amplificação.",
                                "Simulação numérica com plot log-log mostrando inclinação -p.",
                                "Explicação qualitativa de limitações e condições.",
                                "Uso correto de notação big-O em todas as etapas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/SciPy para validação numérica.",
                                "Física: Simulações de trajetórias em dinâmica (ex: oscilador harmônico).",
                                "Engenharia: Controle de sistemas lineares com integração numérica.",
                                "Estatística: Análise de erro em Monte Carlo para ODEs estocásticas."
                              ],
                              "realWorldApplication": "Em modelagem climática, simulações de epidemias (SIR model) ou finanças (Black-Scholes PDE via ODE), onde erro global O(h^p) garante precisão em previsões de longo prazo, permitindo trade-off eficiente entre custo computacional e acurácia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Verificar ordem de convergência numericamente",
                            "description": "Implementar teste de ordem de convergência computando log(|e_h|/|e_{h/2}|)/log(2) ≈ p para soluções numéricas de EDOs teste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Configurar o Problema de Teste",
                                  "subSteps": [
                                    "Escolha uma EDO de Valor Inicial (PVI) com solução analítica conhecida, como y' = -y, y(0) = 1, cuja solução é y(x) = e^{-x}",
                                    "Defina o intervalo de integração [0, T], por exemplo T = 1, e o ponto de avaliação final x = T",
                                    "Selecione tamanhos de passo h e h/2, como h = 0.1 e h/2 = 0.05, garantindo que N = T/h seja inteiro",
                                    "Anote a solução exata em x = T para referência futura (ex: y(1) ≈ 0.367879)"
                                  ],
                                  "verification": "Problema, solução exata, T e valores de h documentados em código ou papel",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Editor de código (Python/MATLAB/Julia)",
                                    "Documentação de EDOs teste padrão"
                                  ],
                                  "tips": "Use EDOs lineares simples inicialmente para evitar complicações com não-linearidades",
                                  "learningObjective": "Configurar um benchmark analítico para testar convergência numérica",
                                  "commonMistakes": [
                                    "Escolher EDO sem solução fechada",
                                    "Definir h muito pequeno inicialmente, causando tempo excessivo de computação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método Numérico de Passo Simples",
                                  "subSteps": [
                                    "Codifique o método escolhido (ex: Euler Forward: y_{n+1} = y_n + h f(x_n, y_n))",
                                    "Execute a simulação para tamanho de passo h, obtendo aproximação y_h(T)",
                                    "Repita a execução para h/2, obtendo y_{h/2}(T)",
                                    "Armazene as aproximações finais e número de passos para cada caso"
                                  ],
                                  "verification": "Códigos executados com saídas y_h(T) e y_{h/2}(T) impressas ou salvas",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Biblioteca numérica (NumPy/SciPy para Python)",
                                    "Computador com interpretador de código"
                                  ],
                                  "tips": "Vetorize o código para eficiência se usando linguagens como Python",
                                  "learningObjective": "Implementar corretamente métodos de passo simples para PVIs",
                                  "commonMistakes": [
                                    "Erro na fórmula do método (ex: usar h/2 no update de Euler)",
                                    "Não zerar variáveis entre simulações de h e h/2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Erros Absolutos de Aproximação",
                                  "subSteps": [
                                    "Compute o erro absoluto e_h = |y(T) - y_h(T)| usando a solução exata",
                                    "Compute e_{h/2} = |y(T) - y_{h/2}(T)| da mesma forma",
                                    "Registre os valores de e_h e e_{h/2} com precisão de pelo menos 6 casas decimais",
                                    "Opcionalmente, calcule erros em múltiplos pontos para robustez"
                                  ],
                                  "verification": "Valores de e_h e e_{h/2} calculados e exibidos no console ou relatório",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Calculadora ou código para operações logarítmicas/absolutas"
                                  ],
                                  "tips": "Use funções built-in como abs() e log() para precisão numérica",
                                  "learningObjective": "Quantificar erros numéricos em soluções aproximadas de PVIs",
                                  "commonMistakes": [
                                    "Confundir y_h(T) com valor intermediário",
                                    "Ignorar sinal no erro absoluto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar a Ordem de Convergência Numérica",
                                  "subSteps": [
                                    "Calcule a razão de erros r = |e_h| / |e_{h/2}|",
                                    "Compute log(r) / log(2) para obter p aproximado",
                                    "Exiba o valor de p e compare com a ordem teórica esperada (ex: p=1 para Euler)",
                                    "Repita com h menor se necessário para refinar"
                                  ],
                                  "verification": "Valor de p computado e comparado com teoria, com output numérico",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Funções matemáticas: log, abs (em Python: math.log, numpy.log)"
                                  ],
                                  "tips": "Use log natural ou base 10 consistentemente, pois log_b(a) = ln(a)/ln(b)",
                                  "learningObjective": "Aplicar fórmula empírica para estimar ordem de convergência",
                                  "commonMistakes": [
                                    "Dividir por log(1/2) em vez de log(2)",
                                    "Usar erro relativo em vez de absoluto"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Validar os Resultados",
                                  "subSteps": [
                                    "Interprete se p ≈ ordem teórica (ex: 1 para Euler, 4 para RK4)",
                                    "Plote log(|e_h|) vs log(h) para visualização linear (slope = -p)",
                                    "Teste com h sucessivamente halved para confirmar tendência",
                                    "Conclua sobre convergência e sugira melhorias (ex: método de ordem superior)"
                                  ],
                                  "verification": "Relatório com p, gráfico e conclusão escrita",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Biblioteca de plotagem (Matplotlib/Plots.jl)",
                                    "Papel para relatório"
                                  ],
                                  "tips": "Gere tabela com h, e_h, p para múltiplos refinamentos",
                                  "learningObjective": "Interpretar resultados numéricos de convergência em contexto teórico",
                                  "commonMistakes": [
                                    "Atribuir p exato sem considerar erros de arredondamento",
                                    "Ignorar instabilidade para h grande"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, T=1 (y(1)=e^{-1}≈0.367879). Euler: h=0.1 → y_h(1)≈0.3487, e_h≈0.01915; h=0.05 → y_{h/2}(1)≈0.3582, e_{h/2}≈0.00966. Então p = log(0.01915/0.00966)/log(2) ≈ 0.99 ≈1.",
                              "finalVerifications": [
                                "Valor computado de p está dentro de 5% da ordem teórica",
                                "Refinamento com h/2 adicional confirma p estável",
                                "Gráfico log-log de erro vs h mostra reta com slope ≈ -p",
                                "Erros diminuem monotonicamente ao halvar h",
                                "Implementação reproduz resultados conhecidos de literatura"
                              ],
                              "assessmentCriteria": [
                                "Implementação do método numérico sem bugs detectáveis",
                                "Cálculo preciso de erros e p (erro <0.05 em p)",
                                "Análise inclui comparação teórica e visualização gráfica",
                                "Relatório explica discrepâncias potenciais (ex: arredondamento)",
                                "Código é limpo, comentado e reutilizável"
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação e depuração de algoritmos numéricos",
                                "Física: Simulação de decaimento radioativo ou resfriamento Newtoniano",
                                "Engenharia: Validação de solvers em dinâmica de sistemas",
                                "Estatística: Análise de regressão log-log para estimação de parâmetros"
                              ],
                              "realWorldApplication": "Em simulações de engenharia aeroespacial para trajetórias de mísseis ou em modelagem climática, onde verificar a ordem de convergência garante precisão antes de rodar simulações caras em malhas finas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Relação entre Consistência e Convergência",
                        "description": "Teorema de equivalência de Lax e condições específicas para garantir convergência em métodos de passo simples para problemas de valor inicial.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Enunciar o Teorema de Lax Equivalência",
                            "description": "Para problemas lineares bem-pusados, consistência implica convergência se o método é estável; aplicar a métodos lineares y' = Ay + g(t).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais Pré-Requisitos",
                                  "subSteps": [
                                    "Defina um problema de valor inicial (PVI) bem-pusado para EDOs lineares y' = Ay + g(t).",
                                    "Explique o conceito de consistência de um método numérico, medindo a ordem de truncamento local.",
                                    "Descreva estabilidade no contexto de métodos de passo simples, usando a noção de von Neumann ou matriz de amplificação.",
                                    "Diferencie consistência de estabilidade e convergência."
                                  ],
                                  "verification": "Escreva definições curtas para cada conceito e compare com fontes confiáveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre métodos numéricos",
                                    "Livro 'Análise Numérica' de Burden e Faires",
                                    "Artigo original de Lax (1954)"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar relações entre consistência, estabilidade e convergência.",
                                  "learningObjective": "Dominar os termos chave necessários para entender o teorema.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com estabilidade condicional",
                                    "Ignorar a linearidade do problema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Declaração Precisa do Teorema",
                                  "subSteps": [
                                    "Enuncie o teorema: Para PVIs lineares bem-pusados, um método numérico consistente e estável é convergente.",
                                    "Identifique as hipóteses: problema linear bem-pusado, método consistente (ordem de truncamento → 0), método estável.",
                                    "Explique a implicação: consistência + estabilidade ⇔ convergência.",
                                    "Reescreva o teorema em notação matemática formal para y' = Ay + g(t), y(t0)=y0.",
                                    "Discuta o papel da linearidade na prova."
                                  ],
                                  "verification": "Registre o enunciado completo em um papel e verifique contra uma referência padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência: Teorema de Lax Equivalência em textos de EDOs numéricas",
                                    "Quadro branco ou software de anotações como OneNote"
                                  ],
                                  "tips": "Memorize usando mnemônicos: 'Consistente e Estável → Convergente' (CEC).",
                                  "learningObjective": "Enunciar o teorema com precisão e identificar suas componentes.",
                                  "commonMistakes": [
                                    "Omitir 'bem-pusado'",
                                    "Inverter a implicação (dizer que convergência implica consistência)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Prova Esquemática e Condições",
                                  "subSteps": [
                                    "Esboce a prova: Use desigualdade triangular para ||e_n|| ≤ ||erro de consistência|| + ||erro de estabilidade||.",
                                    "Verifique para problemas lineares y' = Ay + g(t): A diagonalizável ou norma matricial.",
                                    "Analise o que falha sem estabilidade (ex: Euler explícito para λ>0).",
                                    "Discuta extensões para não-lineares ou PDEs.",
                                    "Resuma os teoremas auxiliares (Gronwall, etc.)."
                                  ],
                                  "verification": "Desenhe um fluxograma da prova e explique oralmente para si mesmo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Caderno de matemática",
                                    "Software MATLAB ou Python para simulações simples",
                                    "Videoaula sobre Lax Equivalence"
                                  ],
                                  "tips": "Comece com o caso escalar y' = λy para intuitividade.",
                                  "learningObjective": "Compreender por que o teorema é verdadeiro e suas limitações.",
                                  "commonMistakes": [
                                    "Ignorar a necessidade de linearidade",
                                    "Confundir estabilidade com consistência na prova"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Teorema a um Exemplo Simples",
                                  "subSteps": [
                                    "Escolha y' = -y, y(0)=1; método Euler implícito.",
                                    "Verifique consistência: ordem 1 (truncamento O(h)).",
                                    "Verifique estabilidade: região |1/(1+h)| ≤1 para h>0.",
                                    "Conclua convergência pelo teorema.",
                                    "Compare numericamente com solução exata e^{-t}."
                                  ],
                                  "verification": "Implemente código simples e plote erro vs. h, confirmando redução.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Gráficos de solução exata vs. numérica"
                                  ],
                                  "tips": "Use h=0.1, 0.01 para observar convergência.",
                                  "learningObjective": "Aplicar o teorema para validar um método numérico.",
                                  "commonMistakes": [
                                    "Escolher método instável como Euler explícito sem restrições em h"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver numericamente y' = -10y + sin(t), y(0)=0 com método de Euler implícito: verifique consistência (O(h)), estabilidade (A=-10<0), logo convergência garantida pelo teorema, permitindo simulações confiáveis em stiff problems.",
                              "finalVerifications": [
                                "Enuncie o teorema verbatim sem erros.",
                                "Explique o papel de cada hipótese com um contraexemplo se removida.",
                                "Aplique corretamente a um PVI linear dado.",
                                "Identifique quando o teorema não se aplica (ex: não-linear).",
                                "Discuta implicações para escolha de métodos numéricos.",
                                "Resolva um exercício de verificação de convergência usando o teorema."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude do enunciado (30%)",
                                "Compreensão profunda das hipóteses e prova (25%)",
                                "Capacidade de aplicação a exemplos lineares (20%)",
                                "Identificação correta de limitações (15%)",
                                "Clareza na explicação oral ou escrita (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Garantia de convergência em simulações de dinâmica molecular.",
                                "Engenharia de Controle: Análise de estabilidade em sistemas lineares discretizados.",
                                "Ciência da Computação: Desenvolvimento de solvers numéricos robustos em bibliotecas como SciPy.",
                                "Matemática Aplicada: Extensões a PDEs em modelagem financeira."
                              ],
                              "realWorldApplication": "Em simulações climáticas, o teorema assegura que métodos numéricos para equações diferenciais lineares de difusão convergem para previsões precisas quando consistentes e estáveis, evitando erros catastróficos em modelos de longo prazo."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Identificar condições de estabilidade para convergência",
                            "description": "Discutir estabilidade absoluta para f Lipschitz: |y_{n+1} - z_{n+1}| ≤ (1 + L h) |y_n - z_n|, garantindo convergência sob consistência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de consistência e convergência",
                                  "subSteps": [
                                    "Relembre a definição de um método numérico consistente para PVIs.",
                                    "Explique o teorema de convergência: consistência + estabilidade implica convergência.",
                                    "Discuta o papel da estabilidade na relação com consistência.",
                                    "Identifique exemplos de métodos de passo simples (ex: Euler forward).",
                                    "Anote as condições globais e locais de truncamento."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando por que consistência sozinha não garante convergência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (cap. métodos para PVIs)",
                                    "Caderno para anotações",
                                    "Notas de aula anteriores"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar a relação consistência → estabilidade → convergência.",
                                  "learningObjective": "Compreender a dependência da convergência na estabilidade além da consistência.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com consistência",
                                    "Ignorar a necessidade de h → 0",
                                    "Esquecer truncamento local vs. global"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e verificar a condição Lipschitz em f",
                                  "subSteps": [
                                    "Defina formalmente uma função f Lipschitz contínua com constante L > 0.",
                                    "Prove que |f(t,y) - f(t,z)| ≤ L |y - z| implica controle de crescimento.",
                                    "Verifique Lipschitz para exemplos comuns (ex: f(y) = y^2 não é Lipschitz global).",
                                    "Discuta implicações para PVIs lineares y' = A y.",
                                    "Calcule L numericamente para uma f dada."
                                  ],
                                  "verification": "Para f(y) = sin(y), encontre um L e prove Lipschitz em intervalo [-M,M].",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (SymPy/Mathematica)",
                                    "Exemplos de PVIs padrão"
                                  ],
                                  "tips": "Comece com funções lineares para intuitionar L = ||A||.",
                                  "learningObjective": "Identificar quando f satisfaz Lipschitz, essencial para estabilidade.",
                                  "commonMistakes": [
                                    "Assumir Lipschitz global sem verificar",
                                    "Confundir com derivabilidade",
                                    "Escolher L muito pequeno levando a falhas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a desigualdade de estabilidade absoluta",
                                  "subSteps": [
                                    "Assuma dois aproximantes y_n, z_n para a mesma solução exata.",
                                    "Aplique o método numérico: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Derive |y_{n+1} - z_{n+1}| ≤ |y_n - z_n| + h |f(t_n,y_n) - f(t_n,z_n)|.",
                                    "Use Lipschitz: ≤ |y_n - z_n| + h L |y_n - z_n| = (1 + L h) |y_n - z_n|.",
                                    "Itere para |e_{N}| ≤ (1 + L h)^N |e_0|, onde e_n = erro."
                                  ],
                                  "verification": "Escreva a derivação passo a passo em um quadro ou papel.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha para derivações",
                                    "Referência teórica"
                                  ],
                                  "tips": "Use desigualdade triangular rigorosamente; evite aproximações prematuras.",
                                  "learningObjective": "Derivar a recursão de estabilidade absoluta para métodos explícitos.",
                                  "commonMistakes": [
                                    "Esquecer o termo h na derivação",
                                    "Usar |1 + L h| em vez de 1 + L h (assume L h >0)",
                                    "Ignorar dependência em t"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar condições de estabilidade para convergência",
                                  "subSteps": [
                                    "Analise (1 + L h)^N ≤ e^{L T} para convergência quando h → 0.",
                                    "Discuta que para h fixo pequeno, estabilidade absoluta segura boundedness.",
                                    "Combine com consistência: erro total ≤ C h^p + e^{L T} |e_0|.",
                                    "Verifique condição: h < 1/L para 1 + L h < 2 (crescimento controlado).",
                                    "Teste em exemplo numérico simples."
                                  ],
                                  "verification": "Para um PVI dado, encontre h_max tal que (1 + L h)^N < 10.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para simulação rápida",
                                    "Exemplo de PVI"
                                  ],
                                  "tips": "Pense em log: N log(1 + L h) ≈ L T para limite.",
                                  "learningObjective": "Estabelecer condições práticas em h para garantir convergência numérica.",
                                  "commonMistakes": [
                                    "Exigir 1 + L h <1 (impossível se L>0)",
                                    "Ignorar N h = T fixo",
                                    "Confundir estabilidade absoluta com região de estabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = 2y, y(0)=1 (solução y=e^{2t}), use Euler forward. L=2. Derive |e_{n+1}| ≤ (1 + 2h) |e_n|. Para T=1, N=1/h, erro bounded se h<0.1, simulando convergência para h→0.",
                              "finalVerifications": [
                                "Derive corretamente a desigualdade |y_{n+1}-z_{n+1}| ≤ (1+Lh)|y_n-z_n|.",
                                "Explique verbalmente por que consistência + Lipschitz + estabilidade absoluta → convergência.",
                                "Para f(y)=λy com λ>0, identifique h<1/λ para controle.",
                                "Simule numericamente um PVI e verifique redução de erro com h menor.",
                                "Discuta falha sem Lipschitz (ex: y'=y^2)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação da recursão (sem erros algébricos).",
                                "Correta identificação da constante L para funções dadas.",
                                "Explicação clara da condição h pequena para (1+Lh)^N bounded.",
                                "Integração correta com teorema de convergência geral.",
                                "Aplicação prática em exemplo com cálculo numérico exato.",
                                "Identificação de limitações (ex: não cobre estabilidade linearizada)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementar métodos em Python/NumPy para testar convergência.",
                                "Física: Simulações de EDOs em dinâmica de fluidos ou osciladores.",
                                "Engenharia de Controle: Análise de estabilidade em sistemas discretos.",
                                "Estatística: Métodos numéricos em cadeias de Markov ou simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em modelagem financeira (equações de Black-Scholes) ou previsão climática (modelos ODEs acoplados), condições de estabilidade garantem que simulações numéricas convirjam à solução física real, evitando explosões numéricas em previsões de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Métodos de Passo Múltiplo para Problemas de Valor Inicial",
                "description": "Métodos numéricos que utilizam passos anteriores para avançar na solução de problemas de valor inicial.",
                "totalSkills": 53,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Definição de Métodos de Passo Múltiplo",
                    "description": "Métodos numéricos que utilizam valores e derivadas de múltiplos passos anteriores para avançar na solução de problemas de valor inicial.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Classificação dos Métodos Numéricos para Problemas de Valor Inicial",
                        "description": "Distinção fundamental entre métodos de passo simples e métodos de passo múltiplo, baseada no número de pontos e derivadas anteriores utilizados para aproximar a solução no próximo passo.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Definir métodos de passo simples",
                            "description": "Explicar que métodos de passo simples, como o método de Euler ou Runge-Kutta de ordem fixa, utilizam apenas o valor e possivelmente derivadas no passo imediatamente anterior (n) para calcular y_{n+1}, sem depender de passos mais antigos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Problemas de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Lembre-se da forma geral de um PVI: y' = f(t, y), y(t0) = y0.",
                                    "Entenda que métodos numéricos aproximam soluções analíticas discretizando o intervalo em passos h.",
                                    "Identifique a necessidade de classificar métodos com base na dependência de passos anteriores.",
                                    "Discuta limitações de soluções analíticas e motivação para métodos numéricos.",
                                    "Esboce um exemplo simples de PVI, como y' = y, y(0) = 1."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a forma geral de um PVI e dê um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora básica"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar a discretização temporal.",
                                  "learningObjective": "Compreender o contexto de PVIs e a discretização básica.",
                                  "commonMistakes": [
                                    "Confundir PVI com problemas de contorno",
                                    "Ignorar a condição inicial y0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Classificação de Métodos Numéricos: Passo Simples vs. Múltiplo",
                                  "subSteps": [
                                    "Defina métodos de passo múltiplo como aqueles que usam y_n, y_{n-1}, ..., y_{n-k} para calcular y_{n+1}.",
                                    "Defina métodos de passo simples como aqueles que usam apenas informações do passo n (y_n e possivelmente derivadas em n).",
                                    "Compare: passo simples depende só de n → y_{n+1}; passo múltiplo requer k passos anteriores.",
                                    "Discuta vantagens iniciais: passo simples é mais simples para inicialização.",
                                    "Crie uma tabela comparativa em papel."
                                  ],
                                  "verification": "Preencha uma tabela comparando dependências de ambos os tipos de métodos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Planilha ou quadro branco"
                                  ],
                                  "tips": "Pense em termos de 'memória': passo simples tem memória 1, múltiplo tem memória k.",
                                  "learningObjective": "Distinguir classificações de métodos numéricos para PVIs.",
                                  "commonMistakes": [
                                    "Confundir ordem do método com número de passos",
                                    "Achar que todos os métodos são passo simples"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar Definição e Características de Métodos de Passo Simples",
                                  "subSteps": [
                                    "Explique formalmente: y_{n+1} = y_n + h * Φ(t_n, y_n, h), onde Φ depende só de n.",
                                    "Mencione exemplos: método de Euler (Φ = f(t_n, y_n)) e Runge-Kutta de ordem fixa.",
                                    "Descreva que derivadas intermediárias em Runge-Kutta ainda são computadas só a partir de y_n.",
                                    "Enfatize independência de passos antigos: sem y_{n-1}, etc.",
                                    "Escreva a fórmula genérica e identifique dependências."
                                  ],
                                  "verification": "Escreva a fórmula genérica de um método de passo simples e circule as variáveis dependentes apenas de n.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de análise numérica (opcional)"
                                  ],
                                  "tips": "Use setas para mostrar fluxo: apenas t_n, y_n → y_{n+1}.",
                                  "learningObjective": "Definir precisamente métodos de passo simples e suas dependências.",
                                  "commonMistakes": [
                                    "Incluir erroneamente y_{n-1} na definição",
                                    "Confundir com métodos implícitos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Exemplos e Implementação Básica",
                                  "subSteps": [
                                    "Implemente método de Euler para y' = -y, y(0)=1, h=0.1, dois passos.",
                                    "Calcule Runge-Kutta de 2ª ordem (Heun) para o mesmo problema.",
                                    "Verifique que cada y_{n+1} usa só y_n.",
                                    "Compare resultados numéricos com solução exata e^{ -t }.",
                                    "Codifique em Python ou pseudocódigo para visualização."
                                  ],
                                  "verification": "Mostre cálculos manuais para 2 passos e confirme independência de passos anteriores.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Python ou MATLAB (opcional)",
                                    "Papel"
                                  ],
                                  "tips": "Comece com h pequeno para precisão visual.",
                                  "learningObjective": "Aplicar definição através de exemplos concretos.",
                                  "commonMistakes": [
                                    "Erro aritmético em k_i de Runge-Kutta",
                                    "Usar y_{n-1} acidentalmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver y' = y(1 - y), y(0) = 0.5 (modelo logístico), use Euler: y1 = 0.5 + 0.1 * 0.5*(1-0.5) = 0.525. Note que só y0 é usado, sem passos anteriores.",
                              "finalVerifications": [
                                "Explique a diferença entre passo simples e múltiplo sem hesitação.",
                                "Escreva fórmula genérica de método de passo simples corretamente.",
                                "Identifique Euler e RK4 como passo simples em uma lista.",
                                "Calcule corretamente 3 passos de Euler para um PVI dado.",
                                "Diga por que passo simples não requer valores iniciais múltiplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: dependência exclusiva de passo n (90%+ correto).",
                                "Correção em exemplos: cálculos sem erros aritméticos.",
                                "Compreensão conceitual: distingue de passo múltiplo claramente.",
                                "Uso de terminologia: menciona Φ ou forma explícita adequadamente.",
                                "Aplicação prática: implementa exemplo simples com passos corretos.",
                                "Clareza na explicação: usa diagramas ou tabelas quando apropriado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com loops para simulações.",
                                "Física: Modelar movimento em campos gravitacionais com EDOs.",
                                "Engenharia: Simulações de circuitos RC com métodos numéricos.",
                                "Estatística: Aproximações em processos estocásticos discretos."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas, métodos de passo simples como Euler aceleram previsões iniciais de trajetórias de partículas atmosféricas, permitindo iterações rápidas em supercomputadores para modelos climáticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Identificar características dos métodos de passo múltiplo",
                            "description": "Reconhecer que métodos de passo múltiplo dependem de k valores anteriores y_{n}, y_{n-1}, ..., y_{n-k+1} e suas derivadas f(t_i, y_i) para avançar k passos de uma vez ou computar o próximo passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar métodos de passo único para contraste",
                                  "subSteps": [
                                    "Estude a definição de métodos de passo único, como Euler ou Runge-Kutta, que usam apenas y_n e f(t_n, y_n) para computar y_{n+1}.",
                                    "Anote exemplos simples de fórmulas de passo único.",
                                    "Compare com a necessidade de múltiplos passos em métodos lineares multistep.",
                                    "Identifique limitações de precisão em problemas stiff.",
                                    "Registre diferenças chave em um quadro comparativo."
                                  ],
                                  "verification": "Crie um quadro comparativo listando pelo menos 3 diferenças entre passo único e múltiplo.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Notas de aula sobre Análise Numérica",
                                    "Livro-texto (ex: Burden & Faires)",
                                    "Papel e caneta para quadro"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar dependências de dados.",
                                  "learningObjective": "Distinguir métodos de passo único dos de passo múltiplo como base para identificação.",
                                  "commonMistakes": [
                                    "Confundir dependência em y_{n+1} com y_n apenas",
                                    "Ignorar o papel das derivadas f em ambos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a dependência em k valores anteriores y",
                                  "subSteps": [
                                    "Leia a definição formal: métodos multistep usam y_n, y_{n-1}, ..., y_{n-k+1} para avançar.",
                                    "Desenhe um diagrama temporal mostrando os k passos anteriores necessários.",
                                    "Escreva uma fórmula genérica: y_{n+1} = sum_{j=0}^{k} α_j y_{n-j} + h sum_{j=0}^{k} β_j f(t_{n-j}, y_{n-j}).",
                                    "Calcule manualmente um exemplo com k=2 para y_{n+1}.",
                                    "Explique verbalmente por que k valores são necessários para estabilidade."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama com dependências de y para k=3.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Exemplos de fórmulas multistep",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Comece com k=1 (passo único) e incremente para visualizar a expansão.",
                                  "learningObjective": "Reconhecer a dependência linear em k valores y anteriores como característica principal.",
                                  "commonMistakes": [
                                    "Contar apenas y_n sem os anteriores",
                                    "Confundir k com ordem do método"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar o uso de derivadas f(t_i, y_i) anteriores",
                                  "subSteps": [
                                    "Analise o termo de derivadas na fórmula genérica linear multistep.",
                                    "Liste funções f para cada y_{n-j} nos últimos k passos.",
                                    "Compare com métodos implícitos vs explícitos (ex: Adams-Moulton usa f_{n+1}).",
                                    "Resolva um exemplo numérico usando f_{n}, f_{n-1}, f_{n-2}.",
                                    "Discuta como as derivadas melhoram a precisão local."
                                  ],
                                  "verification": "Escreva a fórmula de um método multistep destacando todos os termos f(t_i, y_i).",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Tabela de métodos multistep (Adams-Bashforth)",
                                    "Software como Python/MATLAB para verificação opcional",
                                    "Exercícios resolvidos"
                                  ],
                                  "tips": "Grave as derivadas em uma tabela ao lado dos y para clareza visual.",
                                  "learningObjective": "Identificar que derivadas anteriores são essenciais para avançar ou computar o próximo passo.",
                                  "commonMistakes": [
                                    "Omitir f_{n+1} em métodos implícitos",
                                    "Pensar que f é computada apenas no passo atual"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e classificar características completas",
                                  "subSteps": [
                                    "Compile todas as características: dependência em k y's e k f's anteriores.",
                                    "Classifique exemplos: explícito (preditor), implícito (corretor).",
                                    "Compare com métodos de Runge-Kutta (one-step).",
                                    "Crie um fluxograma de identificação rápida de um método multistep.",
                                    "Teste com 2-3 métodos desconhecidos para prática."
                                  ],
                                  "verification": "Classifique corretamente 3 métodos fornecidos como multistep ou não.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Lista de métodos numéricos",
                                    "Fluxograma em branco",
                                    "Quiz autoavaliativo"
                                  ],
                                  "tips": "Use mnemônicos: 'k y's + k f's = multistep'.",
                                  "learningObjective": "Sintetizar todas as características para identificação autônoma.",
                                  "commonMistakes": [
                                    "Confundir multistep com higher-order RK",
                                    "Ignorar necessidade de valores iniciais para startup"
                                  ]
                                }
                              ],
                              "practicalExample": "No método de Adams-Bashforth de ordem 2 (explícito, k=2): y_{n+1} = y_n + (h/2) * (3 f(t_n, y_n) - f(t_{n-1}, y_{n-1})). Características: depende de y_n, y_{n-1} e f(t_n, y_n), f(t_{n-1}, y_{n-1}) para computar o próximo passo.",
                              "finalVerifications": [
                                "Explicar verbalmente as dependências em k valores y e f.",
                                "Identificar corretamente um método multistep em uma fórmula dada.",
                                "Desenhar diagrama de dependências para k=3 sem erros.",
                                "Comparar multistep vs one-step em precisão e custo computacional.",
                                "Listar 3 vantagens dos métodos de passo múltiplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das dependências (y e f anteriores).",
                                "Capacidade de classificar métodos corretamente (90% acerto).",
                                "Clareza nos diagramas e fluxogramas produzidos.",
                                "Profundidade na distinção explícito/implícito.",
                                "Aplicação correta em exemplos numéricos simples.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar multistep em Python/NumPy para IVPs.",
                                "Física: Simular equações diferenciais em mecânica orbital.",
                                "Engenharia: Modelagem de sistemas dinâmicos em controle.",
                                "Computação Científica: Otimização em solvers como SciPy.",
                                "Estatística: Previsão em séries temporais numéricas."
                              ],
                              "realWorldApplication": "Esses métodos são usados em simulações numéricas para previsão meteorológica (modelos de fluidos), dinâmica de populações em ecologia, circuitos elétricos em engenharia e farmacocinética em medicina, onde eficiência computacional é crítica para grandes escalas temporais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Comparar passo simples e passo múltiplo",
                            "description": "Comparar as diferenças em termos de precisão, custo computacional inicial (necessidade de passos iniciais para múltiplo) e aplicabilidade, destacando que métodos múltiplos são mais eficientes para problemas não rígidos após inicialização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar métodos de passo simples para EDOs",
                                  "subSteps": [
                                    "Estude a definição de métodos de passo simples, como o método de Euler e Runge-Kutta de ordem 2 ou 4.",
                                    "Analise a fórmula geral: y_{n+1} = y_n + h * f(t_n, y_n) para Euler.",
                                    "Implemente um exemplo simples em papel ou software para observar o comportamento.",
                                    "Identifique a ordem de precisão típica (ordem 1 para Euler, até 4 para RK4).",
                                    "Discuta limitações iniciais, como necessidade de um passo por vez."
                                  ],
                                  "verification": "Resolva um EDO simples manualmente e compare com solução exata para erro < 5%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, lápis, calculadora científica, software Python/MATLAB opcional.",
                                  "tips": "Comece com Euler para simplicidade antes de métodos mais complexos.",
                                  "learningObjective": "Compreender a estrutura e precisão básica dos métodos de passo simples.",
                                  "commonMistakes": "Confundir passo simples com explícito/implícito; ignorar o tamanho do passo h."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir métodos de passo múltiplo",
                                  "subSteps": [
                                    "Defina métodos de passo múltiplo, como Adams-Bashforth e Adams-Moulton, que usam valores anteriores.",
                                    "Estude fórmulas lineares multistep: ∑ α_i y_{n+i} = h ∑ β_i f(t_{n+i}, y_{n+i}).",
                                    "Explique a necessidade de passos iniciais (usando métodos de passo simples).",
                                    "Classifique em explícitos e implícitos, destacando ordem alta possível (até 12).",
                                    "Implemente um exemplo básico para ver reutilização de avaliações de f."
                                  ],
                                  "verification": "Escreva a fórmula de Adams-Bashforth ordem 2 e compute 3 passos manualmente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel, lápis, tabela de coeficientes multistep, Python/MATLAB.",
                                  "tips": "Memorize coeficientes para ordens baixas (2-4) usando tabelas prontas.",
                                  "learningObjective": "Dominar a definição e requisitos iniciais dos métodos multistep.",
                                  "commonMistakes": "Esquecer passos iniciais; assumir convergência sem inicialização adequada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar precisão e estabilidade",
                                  "subSteps": [
                                    "Calcule ordens de precisão: passo simples até ordem 4, multistep até ordem alta.",
                                    "Analise estabilidade: multistep melhores para problemas não rígidos após inicialização.",
                                    "Compare erros globais em exemplos numéricos (ex: erro O(h^k) onde k maior em multistep).",
                                    "Discuta regiões de estabilidade absoluta via método das raízes.",
                                    "Crie tabela comparativa de precisão para h fixo."
                                  ],
                                  "verification": "Gere tabela mostrando erro menor em multistep para mesmo h após 5 passos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel ou Python para simulações, gráficos de erro.",
                                  "tips": "Use soluções exatas conhecidas para validação rápida.",
                                  "learningObjective": "Identificar vantagens de precisão e estabilidade dos multistep.",
                                  "commonMistakes": "Ignorar que multistep requerem inicialização; superestimar estabilidade inicial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar custo computacional e aplicabilidade",
                                  "subSteps": [
                                    "Compare custo inicial: passo simples baixo, multistep alto (inicialização).",
                                    "Calcule avaliações de f por passo: simples ~1, multistep ~k para ordem k.",
                                    "Discuta eficiência para problemas longos: multistep mais baratos após inicialização.",
                                    "Avalie aplicabilidade: simples para rígidos/iniciais, multistep para não rígidos.",
                                    "Simule cenários com h pequeno e intervalos longos."
                                  ],
                                  "verification": "Compute custo total (avaliações f) para N=100 passos em ambos métodos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/MATLAB para contagem de flops, cronômetro para execução.",
                                  "tips": "Foquem em custo por unidade de tempo, não por passo.",
                                  "learningObjective": "Avaliar trade-offs de custo e cenários ideais de uso.",
                                  "commonMistakes": "Desconsiderar custo inicial alto dos multistep; generalizar sem contexto."
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y, y(0)=1 em [0,5] com h=0.5. Use Euler (passo simples) vs Adams-Bashforth ordem 2 (multistep, inicializando com RK2). Compare erros no final: simples ~0.15, multistep ~0.02; custo: simples 11 avaliações, multistep 15 totais mas eficiente depois.",
                              "finalVerifications": [
                                "Lista 3 diferenças chave em precisão entre os métodos.",
                                "Explica por que multistep precisam de inicialização.",
                                "Identifica cenário onde multistep é superior (problema não rígido longo).",
                                "Calcula custo relativo corretamente para N=50 passos.",
                                "Cria tabela comparativa precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de ordens e estabilidade (80% acerto).",
                                "Correta identificação de custos computacionais iniciais vs totais.",
                                "Exemplos numéricos com erros <10% da solução exata.",
                                "Análise contextual de aplicabilidade sem rígidos/iniciais.",
                                "Tabela ou gráfico comparativo claro e quantitativo.",
                                "Ausência de confusão entre explícito/implícito."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em Python/Scipy para simulações ODE.",
                                "Física: Modelagem de osciladores harmônicos em mecânica.",
                                "Engenharia: Simulações de circuitos RLC ou fluidodinâmica."
                              ],
                              "realWorldApplication": "Em previsões meteorológicas ou simulações orbitais (NASA), onde multistep aceleram computações longas após fase inicial, reduzindo tempo de simulação de dias para horas em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Fórmula Geral dos Métodos de Passo Múltiplo",
                        "description": "Representação matemática padrão dos métodos lineares multpasso (MLM), que expressam a aproximação da solução utilizando combinações lineares de valores e derivadas anteriores.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Escrever a forma geral de um método de passo múltiplo",
                            "description": "Formular a equação geral y_{n+k} = α_0 y_n + α_1 y_{n+1} + ... + α_{k-1} y_{n+k-1} + h (β_0 f_n + β_1 f_{n+1} + ... + β_{k-1} f_{n+k-1}), identificando os coeficientes α_i e β_i.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Métodos de Passo Múltiplo",
                                  "subSteps": [
                                    "Lembre-se da definição de problema de valor inicial (PVI): y' = f(t, y), y(t0) = y0.",
                                    "Entenda y_n como aproximação numérica de y(t_n) em t_n = t0 + n h.",
                                    "Identifique f_n = f(t_n, y_n) como a derivada aproximada no ponto n.",
                                    "Compreenda que métodos de passo múltiplo usam k passos anteriores para avançar k passos de uma vez.",
                                    "Note que k é a ordem do método, determinando quantos valores passados são necessários."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que cada símbolo (y_n, f_n, h, k) representa em um método de passo múltiplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre Análise Numérica",
                                    "Livro-texto de métodos numéricos (capítulo de EDOs)"
                                  ],
                                  "tips": "Desenhe um diagrama temporal mostrando t_n, t_{n+1}, ..., t_{n+k} para visualizar os passos.",
                                  "learningObjective": "Compreender os componentes básicos da notação usada em métodos de passo múltiplo.",
                                  "commonMistakes": [
                                    "Confundir y_n com f_n",
                                    "Esquecer que h é o tamanho do passo fixo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a Combinação Linear das Aproximações Anteriores",
                                  "subSteps": [
                                    "Escreva a parte de extrapolação: y_{n+k} ≈ α_0 y_n + α_1 y_{n+1} + ... + α_{k-1} y_{n+k-1}.",
                                    "Identifique os α_i como coeficientes de peso para as soluções aproximadas passadas.",
                                    "Verifique que a soma dos α_i deve satisfazer condições de consistência (ex: soma = 1 para preservação de constantes).",
                                    "Pratique somando os termos com índices genéricos i de 0 a k-1.",
                                    "Anote que essa soma representa uma previsão linear baseada em valores conhecidos."
                                  ],
                                  "verification": "Escreva a soma Σ_{i=0}^{k-1} α_i y_{n+i} e defina o papel dos α_i.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações",
                                    "Exemplos de métodos como Adams-Bashforth"
                                  ],
                                  "tips": "Use notação de soma Σ para compactar a expressão e evitar escrever todos os termos manualmente.",
                                  "learningObjective": "Dominar a estrutura da parte linear das aproximações y em métodos de passo múltiplo.",
                                  "commonMistakes": [
                                    "Índices errados (começar de i=1 em vez de i=0)",
                                    "Confundir α_i com β_i prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Combinação Linear das Derivadas e o Incremento",
                                  "subSteps": [
                                    "Escreva o termo de correção: h (β_0 f_n + β_1 f_{n+1} + ... + β_{k-1} f_{n+k-1}).",
                                    "Identifique os β_i como coeficientes para as derivadas f_{n+i}.",
                                    "Lembre-se que f_{n+i} = f(t_{n+i}, y_{n+i}), usando valores conhecidos.",
                                    "Use notação de soma: h Σ_{i=0}^{k-1} β_i f_{n+i}.",
                                    "Verifique condições como soma ponderada para ordem de precisão."
                                  ],
                                  "verification": "Escreva isoladamente o termo h Σ β_i f_{n+i} e explique sua função como incremento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para testes numéricos simples",
                                    "Tabela de coeficientes de métodos conhecidos"
                                  ],
                                  "tips": "Pense no termo h * soma como uma integral aproximada de Runge-Kutta de ordem superior.",
                                  "learningObjective": "Construir corretamente o componente de integração baseado em derivadas.",
                                  "commonMistakes": [
                                    "Esquecer o fator h multiplicando a soma",
                                    "Usar y em vez de f nos β_i"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar Termos e Identificar Coeficientes na Forma Geral",
                                  "subSteps": [
                                    "Junte as partes: y_{n+k} = Σ_{i=0}^{k-1} α_i y_{n+i} + h Σ_{i=0}^{k-1} β_i f_{n+i}.",
                                    "Destaque explicitamente os coeficientes α_i e β_i como livres a serem determinados.",
                                    "Escreva a equação expandida com reticências (...) para generalidade.",
                                    "Teste com k=1 (método de Euler implícito) para validar: y_{n+1} = y_n + h f_n.",
                                    "Confirme que para k geral, usa k valores passados."
                                  ],
                                  "verification": "Escreva a fórmula completa e identifique todos os α_i e β_i mencionados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "Software como MATLAB para visualizar"
                                  ],
                                  "tips": "Memorize a estrutura como 'previsão linear + correção integrada'.",
                                  "learningObjective": "Escrever e interpretar a equação geral completa de um método de passo múltiplo.",
                                  "commonMistakes": [
                                    "Índices inconsistentes entre somas",
                                    "Omitir reticências ou limites da soma"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um método de passo múltiplo de ordem k=2 (ex: trapezoidal implícito), a forma geral é y_{n+2} = α_0 y_n + α_1 y_{n+1} + h (β_0 f_n + β_1 f_{n+1}), onde tipicamente α_0 = 0, α_1 = 1, β_0 = 1/2, β_1 = 1/2 para consistência de ordem 2.",
                              "finalVerifications": [
                                "Escreva corretamente a soma dos α_i y_{n+i} com limites de 0 a k-1.",
                                "Inclua o fator h multiplicando exatamente a soma dos β_i f_{n+i}.",
                                "Identifique α_i como coeficientes das y's e β_i das f's.",
                                "Valide com k=1: reduz a y_{n+1} = y_n + h f_n.",
                                "Explique verbalmente o avanço de n para n+k usando k passos anteriores.",
                                "Confirme notação com reticências para generalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (índices, somas, símbolos).",
                                "Correta identificação e distinção entre α_i e β_i.",
                                "Uso apropriado de reticências e limites de soma.",
                                "Compreensão conceitual demonstrada em exemplos simples.",
                                "Ausência de erros comuns como omissão de h ou confusão de termos.",
                                "Capacidade de generalizar para qualquer k."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar a fórmula em Python ou MATLAB para resolver EDOs.",
                                "Física: Aplicar em simulações de movimento oscilatório ou circuitos RLC.",
                                "Engenharia: Modelagem de sistemas dinâmicos em controle automático.",
                                "Computação Científica: Integração com bibliotecas como SciPy odeint."
                              ],
                              "realWorldApplication": "Essa forma geral é usada em software de simulação numérica para prever trajetórias em engenharia aeroespacial, modelar epidemias em biologia computacional ou simular fluxos de fluidos em meteorologia, onde métodos eficientes de passo múltiplo aceleram computações de EDOs rígidas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Explicar o papel do número de passos k",
                            "description": "Descrever como k determina o número de passos anteriores necessários, influenciando a ordem de precisão local (até ordem k para métodos explícitos) e a estabilidade inicial do método.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico do número de passos k",
                                  "subSteps": [
                                    "Revise a fórmula geral dos métodos de passo múltiplo: y_{n+1} = y_n + h ∑_{j=1}^k α_j f(t_{n+1-j}, y_{n+1-j}).",
                                    "Identifique k como o número de passos anteriores utilizados no cálculo de y_{n+1}.",
                                    "Compare com métodos de passo único (k=1, como Euler), destacando a dependência de valores passados.",
                                    "Anote exemplos simples: para k=1, usa apenas y_n; para k=2, usa y_n e y_{n-1}.",
                                    "Desenhe um diagrama temporal mostrando as dependências para diferentes k."
                                  ],
                                  "verification": "Crie um diagrama que corretamente ilustre as dependências para k=2 e k=3.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de métodos multi-passo)",
                                    "Papel e caneta ou software de desenho (ex: Draw.io)"
                                  ],
                                  "tips": [
                                    "Comece com k pequeno para visualizar melhor.",
                                    "Use setas no diagrama para mostrar fluxo de informações."
                                  ],
                                  "learningObjective": "Entender k como parâmetro que define o 'alcance histórico' do método.",
                                  "commonMistakes": [
                                    "Confundir k com a ordem do método.",
                                    "Ignorar que k afeta o número de valores iniciais necessários."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar como k determina os passos anteriores necessários",
                                  "subSteps": [
                                    "Descreva que para iniciar o método, são necessários k valores iniciais y_0, y_1, ..., y_{k-1}, computados por outros métodos.",
                                    "Calcule o número de passos anteriores: exatamente k valores prévios para cada iteração após inicialização.",
                                    "Discuta implicações computacionais: maior k requer mais armazenamento e cálculos.",
                                    "Simule manualmente para k=3: liste y_{n+1} dependendo de y_n, y_{n-1}, y_{n-2}.",
                                    "Compare eficiência: métodos com k maior usam mais história para maior precisão."
                                  ],
                                  "verification": "Liste corretamente os k valores necessários para computar y_4 em um método com k=3.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para simulação simples",
                                    "Folha de exercícios com EDO de teste (ex: y' = y)"
                                  ],
                                  "tips": [
                                    "Use uma tabela para rastrear valores ao longo das iterações.",
                                    "Teste com h pequeno para evitar erros numéricos iniciais."
                                  ],
                                  "learningObjective": "Dominar como k impõe requisitos de inicialização e armazenamento.",
                                  "commonMistakes": [
                                    "Subestimar necessidade de k valores iniciais precisos.",
                                    "Confundir passos anteriores com ordem de precisão."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a influência de k na ordem de precisão local",
                                  "subSteps": [
                                    "Recapitule truncagem local: erro por passo é O(h^{p+1}), onde p ≤ k para métodos explícitos.",
                                    "Explique que k maior permite polinômios interpoladores de grau k, alcançando ordem até k.",
                                    "Derive qualitativamente: interpolação com k pontos dá precisão ordem k.",
                                    "Compare: método explícito k=1 (ordem 1), k=4 (ordem 4 como Adams-Bashforth).",
                                    "Calcule erro local aproximado para um exemplo simples."
                                  ],
                                  "verification": "Explique por que ordem máxima é k em métodos explícitos e forneça fórmula de erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre expansão em série de Taylor",
                                    "Software numérico (Python com SciPy para verificar ordens)"
                                  ],
                                  "tips": [
                                    "Lembre: ordem global é geralmente igual à local para métodos consistentes.",
                                    "Foquem em métodos explícitos vs. implícitos."
                                  ],
                                  "learningObjective": "Relacionar k diretamente com potencial de precisão do método.",
                                  "commonMistakes": [
                                    "Achar que ordem sempre = k (não para implícitos ou inconsistentes).",
                                    "Ignorar diferença entre truncagem local e global."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir o impacto de k na estabilidade inicial do método",
                                  "subSteps": [
                                    "Defina estabilidade inicial: região onde método é estável para poucos passos.",
                                    "Explique que k maior amplia região de estabilidade absoluta para métodos lineares.",
                                    "Analise gráfico de estabilidade: para multistep, Raio de Dahlquist cresce com k.",
                                    "Exemplo: Adams-Bashforth k=1 instável para λh <0; k maior melhora.",
                                    "Sintetize trade-offs: maior k = mais precisão e estabilidade, mas custo computacional."
                                  ],
                                  "verification": "Descreva como k afeta o gráfico de estabilidade e dê um exemplo qualitativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de estabilidade de livros-texto",
                                    "Python para plotar regiões de estabilidade (biblioteca mpmath)"
                                  ],
                                  "tips": [
                                    "Visualize regiões sombreadas no plano complexo.",
                                    "Considere teste com EDO rígida para demonstrar."
                                  ],
                                  "learningObjective": "Compreender como k melhora estabilidade, especialmente inicial.",
                                  "commonMistakes": [
                                    "Confundir estabilidade A com estabilidade inicial.",
                                    "Superestimar estabilidade sem considerar rigidez da EDO."
                                  ]
                                }
                              ],
                              "practicalExample": "No método Adams-Bashforth de 2 passos (k=2), y_{n+1} = y_n + (h/2)(3f_n - f_{n-1}), requer y_n e y_{n-1} iniciais (computados por Runge-Kutta), alcança ordem 2 (p=2≤k), com estabilidade melhor que k=1 para certos λh.",
                              "finalVerifications": [
                                "Explicar corretamente que k define k passos anteriores necessários.",
                                "Identificar ordem de precisão local máxima como k para explícitos.",
                                "Descrever impacto positivo de k maior na estabilidade inicial.",
                                "Fornecer exemplo com k=3, listando dependências.",
                                "Discutir trade-off entre precisão/estabilidade e custo computacional.",
                                "Derivar qualitativamente erro de truncagem via interpolação."
                              ],
                              "assessmentCriteria": [
                                "Clareza na definição de k e suas dependências (20%)",
                                "Precisão na explicação da ordem local (25%)",
                                "Análise correta de estabilidade inicial (25%)",
                                "Uso de exemplos concretos e diagramas (15%)",
                                "Identificação de trade-offs e erros comuns (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação de métodos multistep em Python/MATLAB.",
                                "Física: Modelagem de EDOs em dinâmica de sistemas (ex: osciladores).",
                                "Estatística: Análise de erros numéricos e propagação.",
                                "Engenharia: Simulações em controle e aerodinâmica."
                              ],
                              "realWorldApplication": "Em previsões meteorológicas, métodos multistep com k=4-6 (Adams) integram EDOs de modelos climáticos, usando história recente para alta precisão e estabilidade em simulações de longo prazo, otimizando tempo computacional em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Diferenciar métodos explícitos e implícitos de passo múltiplo",
                            "description": "Classificar métodos como explícitos (sem f_{n+k} na fórmula, e.g., Adams-Bashforth) versus implícitos (com f_{n+k}, e.g., Adams-Moulton), e discutir implicações para resolução numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Fórmula Geral dos Métodos de Passo Múltiplo",
                                  "subSteps": [
                                    "Estude a fórmula geral: y_{n+k} = y_n + h * Σ_{j=0}^k β_j f_{n+j} + h * Σ_{j=1}^k γ_j (f_{n+j} - f_{n+j-1}).",
                                    "Identifique os coeficientes β_j (explícitos) e γ_j (implícitos).",
                                    "Revise exemplos básicos de métodos de um passo para contextualizar.",
                                    "Anote as diferenças entre termos passados e futuros na soma."
                                  ],
                                  "verification": "Escreva a fórmula geral de memória e explique os papéis de β_j e γ_j.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (capítulo de métodos multipasso)",
                                    "Folha de anotações",
                                    "Calculadora simbólica (opcional, como SymPy)"
                                  ],
                                  "tips": "Use notação LaTeX para praticar escrita da fórmula.",
                                  "learningObjective": "Memorizar e explicar a estrutura da fórmula geral dos métodos multipasso.",
                                  "commonMistakes": "Confundir índices de f_{n+j} com passos anteriores versus futuros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar Métodos Explícitos",
                                  "subSteps": [
                                    "Defina método explícito: ausência de f_{n+k} na fórmula (γ_k = 0).",
                                    "Examine Adams-Bashforth: y_{n+1} = y_n + (h/2)(3f_n - f_{n-1}).",
                                    "Identifique todos os termos usando apenas valores conhecidos (passados).",
                                    "Compare com métodos de um passo explícitos como Euler forward."
                                  ],
                                  "verification": "Classifique 3 fórmulas dadas como explícitas ou não, justificando pela ausência de f_{n+k}.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de fórmulas de Adams-Bashforth (impressos ou digitais)",
                                    "Planilha para classificação"
                                  ],
                                  "tips": "Sublinhe termos com f_{n+k} (ou falta deles) nas fórmulas.",
                                  "learningObjective": "Reconhecer características definidoras de métodos explícitos.",
                                  "commonMistakes": "Ignorar coeficientes γ_j não nulos como implícitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar Métodos Implícitos",
                                  "subSteps": [
                                    "Defina método implícito: presença de f_{n+k} na fórmula (γ_k ≠ 0).",
                                    "Examine Adams-Moulton: y_{n+1} = y_n + (h/2)(f_{n+1} + f_n).",
                                    "Discuta necessidade de resolver equação não linear em cada passo.",
                                    "Compare estabilidade com métodos explícitos."
                                  ],
                                  "verification": "Classifique 3 fórmulas como implícitas, destacando o termo f_{n+k}.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de fórmulas de Adams-Moulton",
                                    "Software como MATLAB para visualizar (opcional)"
                                  ],
                                  "tips": "Pense em 'implícito' como dependendo do valor futuro desconhecido.",
                                  "learningObjective": "Identificar e explicar métodos implícitos pela presença de f futuro.",
                                  "commonMistakes": "Confundir com métodos predictor-corrector que combinam ambos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Implicações para Resolução Numérica",
                                  "subSteps": [
                                    "Compare velocidade: explícitos diretos vs implícitos requerem iterações/solvers.",
                                    "Analise estabilidade: implícitos melhores para problemas stiff.",
                                    "Discuta precisão e ordem: ambos podem ser de alta ordem.",
                                    "Avalie trade-offs em contextos reais (ex: tempo de computação vs robustez)."
                                  ],
                                  "verification": "Escreva um parágrafo comparando prós/contras de cada tipo com exemplos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabela comparativa (criar uma)",
                                    "Artigos ou slides sobre estabilidade de Runge-Kutta multipasso"
                                  ],
                                  "tips": "Use gráfico de regiões de estabilidade para visualização.",
                                  "learningObjective": "Avaliar impactos práticos na escolha de métodos.",
                                  "commonMistakes": "Generalizar que implícitos são sempre melhores sem considerar custo computacional."
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1 (problema stiff), implemente Adams-Bashforth de 2 passos (explícito) e Adams-Moulton de 2 passos (implícito) em Python/Octave. Compare trajetórias e tempo de execução para h=0.1 até t=10.",
                              "finalVerifications": [
                                "Classificar corretamente Adams-Bashforth como explícito.",
                                "Identificar f_{n+1} em Adams-Moulton como termo implícito.",
                                "Explicar por que implícitos são preferidos em problemas stiff.",
                                "Listar 2 prós e 2 contras de cada tipo.",
                                "Resolver um PVI simples manualmente com ambos os métodos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de explícito/implícito (ausência/presença de f_{n+k}).",
                                "Correta classificação de exemplos padrão (Adams-Bashforth/Moulton).",
                                "Análise qualitativa de implicações (estabilidade, custo).",
                                "Uso correto de terminologia numérica.",
                                "Capacidade de aplicar em exemplo prático simples."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de osciladores amortecidos (estabilidade em EDOs).",
                                "Computação: Implementação de solvers numéricos em programação científica.",
                                "Engenharia: Modelagem de circuitos RLC stiff.",
                                "Estatística: Previsão temporal em séries temporais."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou farmacocinéticas, métodos implícitos como Adams-Moulton são usados para EDOs stiff em previsões de longo prazo, evitando instabilidades que explícitos como Adams-Bashforth causariam, otimizando precisão em softwares como MATLAB ODE solvers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Aplicação e Inicialização dos Métodos de Passo Múltiplo",
                        "description": "Procedimentos para iniciar a sequência de passos anteriores e contexto de uso em problemas de valor inicial y' = f(t,y), y(t_0) = y_0.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Descrever o problema de inicialização",
                            "description": "Explicar que métodos de passo múltiplo requerem k valores iniciais y_0 a y_{k-1}, obtidos tipicamente por métodos de passo simples como Runge-Kutta de ordem alta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos dos Problemas de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Revise a definição de um PVI: y' = f(t, y), y(t0) = y0.",
                                    "Diferencie métodos de passo único (ex: Euler, Runge-Kutta) que usam apenas y_n para calcular y_{n+1}.",
                                    "Introduza métodos de passo múltiplo que usam y_n, y_{n-1}, ..., y_{n-k+1} para maior precisão.",
                                    "Identifique que métodos de passo múltiplo requerem k valores iniciais para começar.",
                                    "Discuta por que um único y0 não é suficiente para k > 1."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que métodos de passo múltiplo precisam de múltiplos pontos iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (capítulo de EDOs)",
                                    "Slides ou notas sobre PVI"
                                  ],
                                  "tips": "Use diagramas de timeline para visualizar passos passados necessários.",
                                  "learningObjective": "Compreender a dependência de valores históricos em métodos de passo múltiplo.",
                                  "commonMistakes": [
                                    "Confundir com métodos de passo único que não precisam de histórico.",
                                    "Ignorar que k é a ordem do método."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever a Fórmula Geral dos Métodos de Passo Múltiplo",
                                  "subSteps": [
                                    "Apresente a fórmula: y_{n+1} = y_n + h * Σ_{j=0}^{k-1} β_j f(t_{n-j}, y_{n-j}).",
                                    "Explique os coeficientes β_j e como eles dependem de k valores iniciais y_0 a y_{k-1}.",
                                    "Mostre exemplos: Adams-Bashforth (explícito) vs Adams-Moulton (implícito).",
                                    "Enfatize que para n < k-1, a fórmula não pode ser aplicada diretamente.",
                                    "Calcule manualmente para k=2 para ilustrar a necessidade de y0 e y1."
                                  ],
                                  "verification": "Escreva a fórmula geral e identifique os termos que requerem valores iniciais múltiplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel para cálculos",
                                    "Tabela de coeficientes de Adams-Bashforth"
                                  ],
                                  "tips": "Memorize que o índice j vai de 0 a k-1, cobrindo k pontos.",
                                  "learningObjective": "Dominar a notação e dependências da fórmula de passo múltiplo.",
                                  "commonMistakes": [
                                    "Errar os índices (confundir y_n com y_{n-j}).",
                                    "Pensar que β_j são arbitrários."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Problema de Inicialização",
                                  "subSteps": [
                                    "Defina o problema: Falta de y1, y2, ..., y_{k-1} no início da integração.",
                                    "Descreva consequências: Não poder aplicar a fórmula até ter k pontos.",
                                    "Compare com métodos de passo único que começam imediatamente com y0.",
                                    "Discuta impacto na precisão global se inicialização for ruim.",
                                    "Liste soluções comuns: Usar Runge-Kutta de ordem alta para gerar os primeiros k passos."
                                  ],
                                  "verification": "Redija um parágrafo descrevendo o problema e uma solução em suas palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de código Python/MATLAB para Runge-Kutta",
                                    "Artigo ou seção sobre inicialização"
                                  ],
                                  "tips": "Pense no problema como 'falta de histórico' em séries temporais.",
                                  "learningObjective": "Articular claramente o problema de inicialização e suas implicações.",
                                  "commonMistakes": [
                                    "Subestimar o custo computacional da inicialização.",
                                    "Confundir com problemas de estabilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Métodos de Inicialização Práticos",
                                  "subSteps": [
                                    "Descreva uso de Runge-Kutta ordem 4 (RK4) para computar y1 a y_{k-1}.",
                                    "Compare com extrapolação de Hermite ou outros métodos de partida.",
                                    "Implemente um exemplo simples: Gere y0, y1, y2 com RK4 para Adams de ordem 3.",
                                    "Avalie trade-offs: Precisão vs custo (RK4 é mais caro mas preciso).",
                                    "Discuta adaptações para problemas rígidos (ex: usar RK variável)."
                                  ],
                                  "verification": "Simule numericamente os primeiros passos e verifique consistência com solução exata.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software: Python com SciPy ou MATLAB",
                                    "Problema teste: y' = -y, y(0)=1"
                                  ],
                                  "tips": "Sempre valide com solução analítica conhecida para pequenos h.",
                                  "learningObjective": "Selecionar e justificar métodos de inicialização apropriados.",
                                  "commonMistakes": [
                                    "Usar passo h inconsistente entre inicialização e método principal.",
                                    "Ignorar erros de truncamento na fase inicial."
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver y' = y(1 - y), y(0)=0.5 com Adams-Bashforth ordem 3 (k=3), use RK4 com h=0.1 para calcular y(0.1), y(0.2) a partir de y(0)=0.5. Então aplique AB3: y(0.3) = y(0.2) + h*(23/12 f(0.2,y0.2) - 16/12 f(0.1,y0.1) + 5/12 f(0,y0)). Isso inicializa corretamente o método.",
                              "finalVerifications": [
                                "Descreva verbalmente o problema de inicialização para um método de ordem k.",
                                "Escreva a fórmula de Adams-Bashforth ordem 2 e identifique valores iniciais necessários.",
                                "Explique por que RK4 é preferido para inicialização.",
                                "Simule um exemplo numérico com k=3 e verifique os primeiros passos.",
                                "Compare precisão com e sem inicialização adequada em um gráfico."
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação da dependência de k valores iniciais (peso: 25%).",
                                "Correta identificação de soluções como RK4 (peso: 20%).",
                                "Uso preciso de notação matemática (peso: 20%).",
                                "Exemplo prático com cálculos corretos (peso: 20%).",
                                "Discussão de implicações na precisão global (peso: 15%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/SciPy para solvers de EDOs.",
                                "Física: Simulações de movimento em dinâmica (ex: osciladores).",
                                "Engenharia: Modelagem de circuitos RLC rígidos.",
                                "Estatística: Séries temporais e previsão com histórico lagged."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou farmacocinéticas, métodos de passo múltiplo como Adams são usados para eficiência em EDOs não rígidos; a inicialização com RK4 garante precisão inicial crítica para previsões de longo prazo em software como MATLAB Simulink ou ECMWF models."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Reconhecer exemplos clássicos",
                            "description": "Identificar e descrever brevemente métodos como Adams-Bashforth de ordem 2 (k=2, explícito) e sua fórmula específica: y_{n+2} = y_{n+1} + (3/2 f_{n+1} - 1/2 f_n) h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Métodos de Passo Múltiplo",
                                  "subSteps": [
                                    "Leia a definição de métodos de passo múltiplo para PVIs: métodos que usam valores anteriores y_n, y_{n+1}, ..., y_{n+k} para computar y_{n+k+1}.",
                                    "Identifique diferenças entre métodos explícitos e implícitos, focando em explícitos como Adams-Bashforth.",
                                    "Estude a necessidade de inicialização com métodos de passo único (ex: Runge-Kutta).",
                                    "Anote exemplos de k=1 e k=2 para contextualizar.",
                                    "Compare com métodos de passo único em termos de eficiência."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e liste 2 diferenças entre explícito e implícito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (capítulo de métodos multipasso)",
                                    "Notas de aula sobre PVIs"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar como os passos se conectam.",
                                  "learningObjective": "Compreender o contexto e terminologia dos métodos de passo múltiplo.",
                                  "commonMistakes": [
                                    "Confundir ordem k com número de passos",
                                    "Ignorar necessidade de inicialização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Método Adams-Bashforth de Ordem 2",
                                  "subSteps": [
                                    "Leia a descrição: método explícito de ordem 2 (k=2) que aproxima a integral usando polinômio interpolador de grau 2.",
                                    "Entenda a derivação via fórmula de Newton-Cotes fechada para 2 intervalos.",
                                    "Identifique coeficientes: 3/2 para f_{n+1} e -1/2 para f_n.",
                                    "Escreva a fórmula geral: y_{n+2} = y_{n+1} + h * (3/2 f_{n+1} - 1/2 f_n).",
                                    "Discuta estabilidade e precisão (erro local O(h^3))."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a origem dos coeficientes 3/2 e -1/2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha com derivação de Adams-Bashforth",
                                    "Software como MATLAB ou Python para visualização opcional"
                                  ],
                                  "tips": "Derive os coeficientes manualmente para fixar na memória.",
                                  "learningObjective": "Dominar a estrutura e propriedades do método Adams-Bashforth ordem 2.",
                                  "commonMistakes": [
                                    "Erros nos sinais dos coeficientes",
                                    "Confundir com Adams-Moulton (implícito)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Memorizar e Aplicar a Fórmula Específica",
                                  "subSteps": [
                                    "Memorize a fórmula exata: y_{n+2} = y_{n+1} + (3/2 f_{n+1} - 1/2 f_n) h.",
                                    "Compute f_n = f(t_n, y_n) e f_{n+1} = f(t_{n+1}, y_{n+1}) para um PVI exemplo.",
                                    "Aplique a dois passos iniciais usando valores de inicialização.",
                                    "Verifique consistência dimensional (h multiplica função f).",
                                    "Repita a fórmula de cor 3 vezes variando notação (índices ou LaTeX)."
                                  ],
                                  "verification": "Escreva a fórmula corretamente 5 vezes sem consultar materiais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para prática",
                                    "Exemplo de PVI simples: y' = y, y(0)=1"
                                  ],
                                  "tips": "Associe coeficientes a frações: 3/2 é 'maior peso no recente', -1/2 corrige extrapolação.",
                                  "learningObjective": "Reproduzir com precisão a fórmula e seus componentes.",
                                  "commonMistakes": [
                                    "Inverter coeficientes 3/2 e 1/2",
                                    "Esquecer o fator h"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Reconhecimento e Descrição Breve",
                                  "subSteps": [
                                    "Analise 3 exemplos de fórmulas: identifique qual é Adams-Bashforth ordem 2.",
                                    "Descreva em 1-2 frases: 'Método explícito k=2, usa f_{n+1} e f_n com pesos 3/2 e -1/2.'",
                                    "Compare com outro método clássico (ex: ordem 1).",
                                    "Crie um fluxograma de aplicação: inicialização → passo 1 → passo 2.",
                                    "Teste em um PVI numérico curto (3 passos)."
                                  ],
                                  "verification": "Identifique corretamente em um quiz com 3 fórmulas misturadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de 5 fórmulas clássicas de multipasso",
                                    "Calculadora ou Python para verificação numérica"
                                  ],
                                  "tips": "Grave áudio descrevendo o método para autoavaliação.",
                                  "learningObjective": "Reconhecer e descrever o método em contextos variados.",
                                  "commonMistakes": [
                                    "Descrições vagas sem fórmula",
                                    "Não mencionar k=2 ou explícito"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o PVI y' = -y, y(0)=1, h=0.1. Inicialize com Euler: y1 ≈ 0.9048 (t1=0.1). Então f0 = -1, f1 ≈ -0.9048. Compute y2 = y1 + (3/2 f1 - 1/2 f0) h ≈ 0.8187. Verifique com solução exata e^{ -0.2 } ≈ 0.8187.",
                              "finalVerifications": [
                                "Reproduz a fórmula exata sem erros.",
                                "Explica a origem dos coeficientes.",
                                "Identifica corretamente em uma lista de métodos.",
                                "Aplica a fórmula a um PVI simples com valores corretos.",
                                "Descreve em 2 frases concisas.",
                                "Discute necessidade de inicialização."
                              ],
                              "assessmentCriteria": [
                                "Precisão na reprodução da fórmula (100% dos coeficientes corretos).",
                                "Compreensão conceitual (explicação de explícito vs implícito).",
                                "Habilidade de identificação em contextos (acertos >90%).",
                                "Descrição breve e precisa (menos de 50 palavras, todos elementos chave).",
                                "Aplicação prática sem erros aritméticos.",
                                "Conexão com inicialização e estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/MATLAB para simulações.",
                                "Física: Modelagem de osciladores ou decaimento em dinâmica.",
                                "Engenharia: Simulações em controle de sistemas lineares.",
                                "Estatística: Aproximações em processos estocásticos numéricos."
                              ],
                              "realWorldApplication": "Usado em previsões meteorológicas e simulações climáticas para integrar equações diferenciais de movimento atmosférico, onde eficiência computacional é crítica em grandes escalas temporais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Fórmula Geral dos Métodos Lineares Multistep (LMM)",
                    "description": "Forma matemática geral dos LMM: ∑ α_k y_{n+k} = h ∑ β_k f(t_{n+k}, y_{n+k}).",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Definição da Fórmula Geral dos LMM",
                        "description": "Apresentação da forma matemática geral dos métodos lineares multistep (LMM) para aproximar soluções de problemas de valor inicial.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Reconhecer a fórmula geral dos LMM",
                            "description": "Identificar e escrever a fórmula ∑_{k=0}^s α_k y_{n+k} = h ∑_{k=0}^s β_k f(t_{n+k}, y_{n+k}), explicando que ela relaciona valores aproximados y em passos múltiplos com a derivada f do problema y' = f(t,y).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Contextualizar os Métodos Lineares Multistep (LMM) no contexto de Problemas de Valor Inicial (PVI)",
                                  "subSteps": [
                                    "Revise o problema padrão y' = f(t, y), y(t0) = y0.",
                                    "Compare métodos de um passo (ex: Euler, Runge-Kutta) com métodos multistep, que usam múltiplos pontos anteriores.",
                                    "Entenda que LMM aproximam a solução usando uma combinação linear de valores y anteriores e derivadas f.",
                                    "Identifique a necessidade de passos múltiplos para maior eficiência em problemas stiff ou longos intervalos.",
                                    "Diferencie LMM implícitos (envolvem y_{n+s}) de explícitos (não)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre métodos de um passo e multistep, citando um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Slides ou vídeo introdutório sobre métodos numéricos para PVI"
                                  ],
                                  "tips": "Comece sempre pelo PVI padrão para fixar o contexto; evite pular para a fórmula sem base.",
                                  "learningObjective": "Compreender o papel dos LMM na resolução numérica de PVI.",
                                  "commonMistakes": [
                                    "Confundir LMM com métodos de um passo",
                                    "Ignorar a distinção entre implícito e explícito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dissecar os componentes da fórmula geral dos LMM",
                                  "subSteps": [
                                    "Identifique os índices: k de 0 a s, onde s é a ordem do método.",
                                    "Reconheça os coeficientes α_k (para os termos y_{n+k}) e β_k (para os termos h f(t_{n+k}, y_{n+k})).",
                                    "Note o lado esquerdo: soma linear de valores aproximados y em s+1 pontos.",
                                    "Note o lado direito: soma ponderada pela h das derivadas f em pontos futuros ou passados.",
                                    "Entenda que α_s = 1 por convenção para normalizar."
                                  ],
                                  "verification": "Liste e rotule todos os símbolos na fórmula: ∑_{k=0}^s α_k y_{n+k} = h ∑_{k=0}^s β_k f(t_{n+k}, y_{n+k}).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para anotar símbolos",
                                    "Tabela de exemplos de coeficientes α e β de métodos conhecidos (Adams)"
                                  ],
                                  "tips": "Use cores diferentes para destacar α_k, β_k, y e f na fórmula escrita à mão.",
                                  "learningObjective": "Identificar precisamente cada elemento simbólico da fórmula geral.",
                                  "commonMistakes": [
                                    "Confundir índices k com n",
                                    "Esquecer o fator h no lado direito",
                                    "Trocar α por β"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever e reproduzir a fórmula geral corretamente",
                                  "subSteps": [
                                    "Escreva a fórmula do zero: lado esquerdo ∑_{k=0}^s α_k y_{n+k}.",
                                    "Adicione o lado direito: = h ∑_{k=0}^s β_k f(t_{n+k}, y_{n+k}).",
                                    "Verifique a notação de somatória, subscritos e símbolos matemáticos.",
                                    "Copie a fórmula 3 vezes de memória, corrigindo erros.",
                                    "Compare com a fórmula padrão para confirmar exatidão."
                                  ],
                                  "verification": "Reproduza a fórmula em um papel ou editor LaTeX sem consultar referências.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor LaTeX online (Overleaf) ou papel quadriculado",
                                    "Referência impressa da fórmula para autoavaliação"
                                  ],
                                  "tips": "Memorize a estrutura 'soma y = h soma f'; pratique escrita cursiva para fluidez.",
                                  "learningObjective": "Reproduzir a fórmula geral de forma precisa e autônoma.",
                                  "commonMistakes": [
                                    "Erro nos limites da somatória (ex: k=1 a s)",
                                    "Falta de subscritos em t_{n+k} ou y_{n+k}",
                                    "Esquecer parênteses em f(t,y)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o significado e a relação com o problema diferencial",
                                  "subSteps": [
                                    "Descreva que a fórmula relaciona s+1 valores y aproximados com suas derivadas f.",
                                    "Explique que é derivada da interpolação linear da solução exata em pontos discretos.",
                                    "Relacione ao PVI: aproxima y' = f(t,y) em malha t_n = t0 + n h.",
                                    "Discuta como α e β são escolhidos para ordem de precisão p (consistência e estabilidade).",
                                    "Dê um exemplo verbal: 'Para avançar y_{n+s}, usa valores passados y_{n} a y_{n+s-1}'."
                                  ],
                                  "verification": "Explique em 2-3 frases o propósito da fórmula, gravando áudio ou escrevendo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gravador de voz ou bloco de notas",
                                    "Gráfico de malha temporal com pontos y_n"
                                  ],
                                  "tips": "Use analogia: 'como uma média ponderada de velocidades para prever posição futura'.",
                                  "learningObjective": "Interpretar semanticamente a fórmula no contexto do PVI.",
                                  "commonMistakes": [
                                    "Dizer que é exata em vez de aproximada",
                                    "Ignorar o papel de h como tamanho de passo",
                                    "Confundir f com y' explicitamente"
                                  ]
                                }
                              ],
                              "practicalExample": "No método de Adams-Bashforth de ordem 1 (s=1): α_0 = -1, α_1 = 1, β_0 = -1, β_1 = 0? Não, correto é y_{n+1} - y_n = h f(t_n, y_n), que é ∑ α_k y_{n+k} = h ∑ β_k f, com α_0=-1, α_1=1, β_0=1, β_1=0. Reconheça isso como caso particular da fórmula geral.",
                              "finalVerifications": [
                                "Escreve a fórmula geral sem erros de notação.",
                                "Identifica corretamente α_k, β_k, y_{n+k} e f(t_{n+k}, y_{n+k}).",
                                "Explica a relação com y' = f(t,y) em uma frase clara.",
                                "Distingue LMM de métodos de um passo.",
                                "Reconhece um exemplo simples como o Backward Euler multistep.",
                                "Verifica consistência: α_s = 1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na reprodução da fórmula (100% dos símbolos corretos).",
                                "Compreensão conceitual: explica relação com derivada f (nota >8/10).",
                                "Identificação de componentes: lista todos sem omissões.",
                                "Fluência na explicação verbal ou escrita (clareza e concisão).",
                                "Aplicação a exemplo: reconhece coeficientes em método conhecido.",
                                "Ausência de confusões comuns (ex: índices errados)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar LMM em Python com SciPy para resolver PVI.",
                                "Física: Simular equações diferenciais em dinâmica de partículas.",
                                "Engenharia: Modelagem de circuitos RLC ou controle de sistemas.",
                                "Computação Científica: Otimização de estabilidade em solvers numéricos."
                              ],
                              "realWorldApplication": "Os LMM são usados em softwares como MATLAB ODE solvers ou previsões meteorológicas (modelos ECMWF), onde eficiência em simulações de longo prazo de EDOs é crucial, como em finanças (preços de opções) ou biologia (modelos populacionais)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Interpretar o índice n e o passo h",
                            "description": "Explicar que n representa o estágio atual, s é o número de passos anteriores usados, e h é o tamanho do passo de integração, destacando como a equação avança a solução de t_n para t_{n+s}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o significado do índice n como o estágio atual",
                                  "subSteps": [
                                    "Revise a fórmula geral dos LMM: ∑_{j=0}^s α_j y_{n+j} = h ∑_{j=0}^s β_j f(t_{n+j}, y_{n+j}).",
                                    "Note que os índices n+j referenciam pontos discretos na malha temporal.",
                                    "Explique que n representa o estágio atual onde a aproximação y_n está sendo computada ou conhecida.",
                                    "Diferencie n de índices anteriores (n-1, etc.) usados em métodos multistep.",
                                    "Desenhe uma linha do tempo mostrando t_n como ponto de partida para o passo atual."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o que n representa e aponte seu papel na fórmula.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Fórmula geral dos LMM anotada",
                                    "Papel e caneta para diagrama temporal",
                                    "Exemplo de malha temporal"
                                  ],
                                  "tips": [
                                    "Visualize a malha de pontos t_0, t_1, ..., t_n como uma sequência de tempos discretos.",
                                    "Lembre-se: n é o 'presente' no contexto do passo atual."
                                  ],
                                  "learningObjective": "Compreender n como o índice do estágio atual na discretização temporal.",
                                  "commonMistakes": [
                                    "Confundir n com o número total de passos.",
                                    "Ignorar que n+j estende além do atual."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender s como o número de passos anteriores utilizados",
                                  "subSteps": [
                                    "Analise o somatório de j=0 a s na fórmula, onde s define a ordem do método.",
                                    "Identifique que s indica quantos valores anteriores (y_{n}, y_{n-1}, ..., y_{n-s+1}) são usados.",
                                    "Ajuste a fórmula para um método específico, como s=1 (método de Euler implícito).",
                                    "Compare com métodos single-step (s=0) para destacar a multistep nature.",
                                    "Liste os termos y_{n+j} para j=0 a s em um exemplo numérico."
                                  ],
                                  "verification": "Escreva a fórmula para s=2 e liste os passos anteriores envolvidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de coeficientes α_j e β_j para diferentes s",
                                    "Calculadora para somatórios simples"
                                  ],
                                  "tips": [
                                    "Pense em s como a 'memória' do método: mais s, mais passado usado.",
                                    "Verifique se α_0 ≠ 0 geralmente."
                                  ],
                                  "learningObjective": "Reconhecer s como determinante do número de passos históricos na equação.",
                                  "commonMistakes": [
                                    "Confundir s com h.",
                                    "Achar que s é fixo para todos os LMM."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar h como o tamanho do passo de integração",
                                  "subSteps": [
                                    "Localize h multiplicando o somatório de f na fórmula LMM.",
                                    "Descreva h como Δt, a largura uniforme da malha temporal (t_{n+1} = t_n + h).",
                                    "Discuta impacto de h na precisão e estabilidade (h pequeno: preciso, mas custoso).",
                                    "Calcule t_{n+s} = t_n + s*h em um diagrama.",
                                    "Compare h com passos adaptativos em métodos modernos."
                                  ],
                                  "verification": "Calcule t_{n+2} dado t_n=0, h=0.1, s=2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico de malha temporal com h marcado",
                                    "Software como Python/MATLAB para plotar malha"
                                  ],
                                  "tips": [
                                    "h controla a resolução temporal: equilibre precisão vs. custo computacional.",
                                    "Unidades de h devem combinar com t."
                                  ],
                                  "learningObjective": "Entender h como escalar do avanço temporal na integração.",
                                  "commonMistakes": [
                                    "Confundir h com ordem de precisão.",
                                    "Esquecer que h é constante em LMM básicos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o avanço da solução de t_n para t_{n+s}",
                                  "subSteps": [
                                    "Reúna conceitos: fórmula usa y_n a y_{n+s-1} e f correspondentes para computar y_{n+s}.",
                                    "Trace o fluxo: lado esquerdo equilibra valores futuros/passados; direito integra derivadas escaladas por h.",
                                    "Simule um passo: dado y_n, y_{n-1}, compute y_{n+1} para s=1.",
                                    "Explique avanço multistep: pula s passos de uma vez usando história.",
                                    "Discuta implicações para eficiência em IVPs de longo tempo."
                                  ],
                                  "verification": "Descreva o processo de computar t_{n+s} a partir de t_n em palavras e diagrama.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo numérico completo de LMM",
                                    "Planilha para simulação manual"
                                  ],
                                  "tips": [
                                    "Visualize como uma 'previsão' baseada em história recente.",
                                    "Lado direito aproxima integral via quadratura."
                                  ],
                                  "learningObjective": "Integrar conceitos para explicar progressão temporal na fórmula LMM.",
                                  "commonMistakes": [
                                    "Achar que avança só 1 passo sempre.",
                                    "Ignorar dependência em valores iniciais para multistep."
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver y' = y, y(0)=1 com Adams-Moulton s=2 (α_0=5/12, α_1=-8/12, α_2=1, β_0=1/12, β_1=0, β_2=-1/12): n=2 significa estágio atual t_2=0.2h (h=0.1), usa y_2, y_3 conhecidos? Não: resolve para y_{n+2}=y_4 usando y_2 (atual), y_3 (anterior), f(t_2,y_2), f(t_3,y_3), f(t_4,y_4) implicitamente, avançando de t_2 para t_4.",
                              "finalVerifications": [
                                "Explicar corretamente n como estágio atual.",
                                "Definir s como número de passos anteriores.",
                                "Descrever h como tamanho do passo temporal.",
                                "Traçar avanço de t_n para t_{n+s} na fórmula.",
                                "Aplicar conceitos em um exemplo s=1.",
                                "Diferenciar LMM de métodos single-step."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de n, s e h (90%+ correto).",
                                "Capacidade de diagramar malha temporal com índices.",
                                "Explicação clara do fluxo computacional multistep.",
                                "Identificação correta de termos na fórmula LMM.",
                                "Uso apropriado de exemplo prático.",
                                "Ausência de confusões comuns como h vs. precisão."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de loops em solvers numéricos (Python/Scipy).",
                                "Física: Simulações de EDOs em dinâmica (ex: osciladores).",
                                "Engenharia: Modelagem de circuitos RLC com passos temporais.",
                                "Estatística: Análise de séries temporais discretizadas."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas, n indexa o tempo atual (horas), s=3 usa 3 horas passadas para prever 3 horas à frente com h=1h, permitindo previsões eficientes de trajetórias de furacões sem recomputar toda a história."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Relacionar LMM com métodos de passo simples",
                            "description": "Comparar a fórmula geral dos LMM com métodos de um passo (como Runge-Kutta), enfatizando que LMM reutilizam informações de passos anteriores para maior eficiência em problemas não rígidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar métodos de passo simples como Runge-Kutta",
                                  "subSteps": [
                                    "Lembre a fórmula geral de métodos explícitos de um passo: y_{n+1} = y_n + h * Φ(t_n, y_n, h, f).",
                                    "Estude o método Runge-Kutta de ordem 4 (RK4), destacando suas 4 avaliações de função por passo.",
                                    "Discuta limitações: custo computacional alto por depender apenas do ponto atual.",
                                    "Resolva um exemplo simples manualmente com RK4 para uma EDO y' = f(t,y).",
                                    "Anote o número de avaliações de f necessárias para N passos."
                                  ],
                                  "verification": "Escreva a fórmula RK4 e compute um passo para y' = -y, y(0)=1, h=0.1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora ou Python/MATLAB para verificação.",
                                  "tips": "Visualize os k1-k4 como aproximações em pontos intermediários para maior precisão.",
                                  "learningObjective": "Compreender a dependência exclusiva do ponto atual em métodos de um passo.",
                                  "commonMistakes": "Confundir ordem do método com número de estágios; RK4 é ordem 4 com 4 estágios."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a fórmula geral dos Métodos Lineares Multistep (LMM)",
                                  "subSteps": [
                                    "Apresente a fórmula: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}.",
                                    "Explique coeficientes α e β para métodos explícitos (β_k ≠ 0, outros β_j para j>0 =0) e implícitos.",
                                    "Destaque reutilização: usa y_{n}, y_{n+1}, ..., y_{n+k-1} de passos anteriores.",
                                    "Classifique: Adams-Bashforth (explícito), Adams-Moulton (implícito).",
                                    "Compare k=1: reduz a Euler forward/backward, ligando a métodos de um passo."
                                  ],
                                  "verification": "Escreva a fórmula LMM para k=2 e identifique termos reutilizados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Quadro ou software de anotações (Overleaf, Jupyter), tabela de coeficientes LMM.",
                                  "tips": "Pense em LMM como 'média ponderada' de derivadas passadas para economizar avaliações.",
                                  "learningObjective": "Dominar a estrutura da fórmula LMM e seu uso de múltiplos pontos.",
                                  "commonMistakes": "Ignorar que α_0 = -1 sempre; confundir índices j."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar estruturas de LMM e métodos de passo simples",
                                  "subSteps": [
                                    "Liste semelhanças: ambos aproximam soluções de EDOs lineares y' = f(t,y).",
                                    "Destaque diferenças: um passo usa 1 info atual; LMM usa k+1 pontos históricos.",
                                    "Analise precisão: LMM ordem até k+1 com menos avaliações por passo.",
                                    "Discuta estabilidade: LMM bom para não rígidos, mas precisa de método de partida.",
                                    "Crie tabela comparativa: custo por passo (RK4:4f vs AB2:1f)."
                                  ],
                                  "verification": "Preencha tabela comparativa para RK4 vs AB2 em termos de avaliações e ordem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel/Google Sheets para tabela, livro de análise numérica.",
                                  "tips": "Use diagrama de fluxo: RK4 avança sozinho; LMM precisa 'histórico' inicial.",
                                  "learningObjective": "Identificar diferenças chave na computação e precisão.",
                                  "commonMistakes": "Achar LMM sempre superior; ignore rígidos onde explodem."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enfatizar eficiência da reutilização em problemas não rígidos",
                                  "subSteps": [
                                    "Defina problemas não rígidos: escalas temporais variadas, mas não extremas.",
                                    "Calcule eficiência: para N passos, RK4: 4N f; LMM ordem k: ~N f após inicialização.",
                                    "Simule numericamente: compare tempo/erro para y' = -y + sin(t).",
                                    "Discuta método de partida: use RK para primeiros k passos.",
                                    "Conclua vantagens: LMM para simulações longas em ODEs suaves."
                                  ],
                                  "verification": "Compute avaliações totais para N=100 com RK4 vs AB3.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python/Octave com solvers ode45 vs implementações LMM.",
                                  "tips": "Ganho real aparece em N grande; teste com h pequeno.",
                                  "learningObjective": "Quantificar eficiência e contexto ideal para LMM.",
                                  "commonMistakes": "Aplicar LMM rígidos sem predictor-corrector; superestimar estabilidade."
                                }
                              ],
                              "practicalExample": "Resolva y' = -10y + sin(10t), y(0)=1 até t=5 com h=0.1. Use RK4 (400 avaliações) vs AB2 após 1 passo RK ( ~100 avaliações). Compare erros e tempo de CPU; LMM mais eficiente pois problema não rígido.",
                              "finalVerifications": [
                                "Explicar verbalmente como LMM reutiliza f_{n-j} vs RK4 novo a cada passo.",
                                "Listar 3 diferenças estruturais entre fórmulas.",
                                "Calcular custo relativo para 1000 passos.",
                                "Identificar quando usar LMM vs passo simples.",
                                "Desenhar diagrama de dependências de pontos.",
                                "Implementar AB2 simples em código e rodar exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula LMM (coeficientes corretos).",
                                "Correta identificação de reutilização de informações.",
                                "Análise quantitativa de eficiência (avaliações f).",
                                "Distinção clara entre rígido/não rígido.",
                                "Uso correto de exemplo prático com cálculos.",
                                "Conexão lógica com método de partida."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python (SciPy odeint usa LMM internamente).",
                                "Física: Simulações dinâmicas (osciladores harmônicos não rígidos).",
                                "Engenharia: Controle de sistemas (previsão de trajetórias).",
                                "Computação Científica: Otimização de solvers em HPC."
                              ],
                              "realWorldApplication": "Em modelagem climática ou simulações de circuitos elétricos não rígidos, LMM reduzem tempo de computação em 70-90% vs RK, permitindo previsões em tempo real para redes elétricas ou forecasts meteorológicos de longo prazo."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Coeficientes e Polinômios Geradores",
                        "description": "Análise dos coeficientes α_k e β_k na fórmula geral, incluindo sua representação via polinômios geradores para análise de estabilidade e consistência.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Definir os coeficientes α_k e β_k",
                            "description": "Descrever os coeficientes α_k (para y_{n+k}) e β_k (para f(t_{n+k}, y_{n+k})) como constantes reais escolhidas para satisfazer condições de precisão e estabilidade, com α_s = 1 por normalização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Fórmula Geral dos Métodos Lineares Multistep (LMM)",
                                  "subSteps": [
                                    "Revise a equação diferencial ordinária (EDO) y' = f(t, y) com condição inicial y(t0) = y0.",
                                    "Estude a forma geral do LMM: ∑_{k=0}^s α_k y_{n+k} = h ∑_{k=0}^s β_k f(t_{n+k}, y_{n+k}).",
                                    "Identifique os índices n e k, onde s é o número de passos.",
                                    "Anote o papel de h como tamanho do passo.",
                                    "Desenhe um diagrama temporal mostrando y_n, y_{n+1}, ..., y_{n+s}."
                                  ],
                                  "verification": "Escreva a fórmula geral do LMM de memória e explique cada termo em uma frase.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Livro de Análise Numérica (capítulo sobre LMM)",
                                    "Notas de aula sobre EDOs"
                                  ],
                                  "tips": "Use setas para visualizar a progressão temporal dos pontos y_{n+k}.",
                                  "learningObjective": "Entender a estrutura fundamental da fórmula LMM antes de focar nos coeficientes.",
                                  "commonMistakes": [
                                    "Confundir α_k com β_k",
                                    "Esquecer o fator h no lado direito",
                                    "Ignorar que k vai de 0 a s"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os Coeficientes α_k e β_k",
                                  "subSteps": [
                                    "Defina α_k como os coeficientes reais multiplicando y_{n+k} no lado esquerdo da fórmula.",
                                    "Defina β_k como os coeficientes reais multiplicando f(t_{n+k}, y_{n+k}) no lado direito.",
                                    "Escreva explicitamente: lado esquerdo gera ρ(ζ) = ∑_{k=0}^s α_k ζ^k (polinômio de característica).",
                                    "Escreva: lado direito gera σ(ζ) = ∑_{k=0}^s β_k ζ^k (polinômio gerador).",
                                    "Liste exemplos iniciais: para s=1 (método backward Euler), α_0=-1, α_1=1, β_1=1."
                                  ],
                                  "verification": "Escreva as definições de α_k e β_k e associe-os corretamente aos termos da fórmula.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy/Mathematica",
                                    "Tabela de métodos LMM conhecidos"
                                  ],
                                  "tips": "Sempre relacione α_k a y e β_k a f para evitar confusão.",
                                  "learningObjective": "Identificar precisamente o papel de cada coeficiente na fórmula LMM.",
                                  "commonMistakes": [
                                    "Trocar os papéis de α_k e β_k",
                                    "Esquecer que ambos são funções de k",
                                    "Confundir com coeficientes de Runge-Kutta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Normalização α_s = 1",
                                  "subSteps": [
                                    "Explique que α_s = 1 é uma convenção de normalização para escalar unicamente os coeficientes.",
                                    "Mostre que multiplicar toda a equação por constante não muda a solução, logo fixamos α_s=1.",
                                    "Derive o impacto: ρ(1) = ∑ α_k = 0 para consistência de ordem 1, mas α_s=1 ancora o polinômio.",
                                    "Verifique em exemplo: Adams-Bashforth de ordem 2, α_0=α_1=α_2=0? Não, para explícito ajustado.",
                                    "Pratique reescalando um conjunto de coeficientes arbitrários para α_s=1."
                                  ],
                                  "verification": "Ajuste um exemplo de coeficientes não normalizados para satisfazer α_s=1 e verifique a fórmula.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para cálculos algébricos",
                                    "Software como Python com NumPy para verificação numérica"
                                  ],
                                  "tips": "Pense na normalização como dividir todos α_k por α_s original.",
                                  "learningObjective": "Compreender por que e como α_s é fixado em 1 para padronização.",
                                  "commonMistakes": [
                                    "Achar que α_s=1 é para estabilidade ao invés de convenção",
                                    "Aplicar normalização só a β_k"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Critérios de Escolha: Precisão e Estabilidade",
                                  "subSteps": [
                                    "Para precisão: exija que ρ(E) - h σ(E) = O(h^{p+1}) onde E é operador de deslocamento, p=ordem.",
                                    "Resolva sistema linear para α_k, β_k satisfazendo condições de ordem até p=s+1.",
                                    "Para estabilidade: raiz principal de ρ(ζ)/σ(ζ)=0 deve ter |r|≤1, região de estabilidade.",
                                    "Compare métodos explícitos (β_s=0, instável para rígidos) vs implícitos (β_s≠0).",
                                    "Calcule para método simples: trapezoidal, α_0=-1, α_1=1, β_0=β_1=1/2."
                                  ],
                                  "verification": "Descreva verbalmente como α_k e β_k são 'escolhidos' para precisão e estabilidade em um parágrafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de análise numérica (Hairer et al.)",
                                    "Solver online para sistemas lineares"
                                  ],
                                  "tips": "Comece com baixa ordem s=1 para intuitar antes de generalizar.",
                                  "learningObjective": "Saber que α_k e β_k são selecionados para otimizar precisão e estabilidade.",
                                  "commonMistakes": [
                                    "Confundir precisão (local/truncamento) com estabilidade (global)",
                                    "Ignorar que escolha é via resolução de sistemas"
                                  ]
                                }
                              ],
                              "practicalExample": "No método de Adams-Moulton de ordem 2 (implícito): α_0 = 1, α_1 = -1, α_2 = 0? Não: para s=1 backward difference ajustado, mas precisamente para trapezoidal: α_{-1}=1 (shifted), α_0=-1, β_{-1}=β_0=1/2, normalizado α_0=1 após shift. Implemente em Python: def lmm_step(y_n, f_n, h): return y_n + (h/2)*(f_n + f(tn+h, y_n + (h/2)*f_n)) aproximando.",
                              "finalVerifications": [
                                "Escreva a definição completa de α_k e β_k incluindo normalização.",
                                "Identifique α_k e β_k em pelo menos 3 métodos LMM conhecidos (ex: Euler, Trapezoidal, Adams).",
                                "Explique verbalmente o propósito da normalização α_s=1.",
                                "Descreva como coeficientes afetam precisão (ordem p) e estabilidade.",
                                "Resolva sistema simples para encontrar α_k, β_k de ordem 1.",
                                "Compare coeficientes de método explícito vs implícito."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa de α_k (lado y) e β_k (lado f) sem inversão.",
                                "Correta menção à normalização α_s=1 e seu motivo.",
                                "Compreensão de escolha via condições de precisão (sistema linear para ordem p).",
                                "Referência correta a estabilidade via polinômios ρ e σ.",
                                "Uso de notação matemática consistente (índices k=0 a s).",
                                "Capacidade de exemplificar com método específico."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar LMM em Python/MATLAB usando arrays para α_k e β_k.",
                                "Física: Aplicar em simulações de osciladores harmônicos rígidos.",
                                "Engenharia: Otimização de coeficientes para solvers em controle de sistemas.",
                                "Estatística: Análise de erro numérico em modelagem probabilística."
                              ],
                              "realWorldApplication": "Em software como MATLAB ode15s ou SciPy solve_ivp, coeficientes α_k e β_k de métodos LMM como BDF são usados para resolver EDOs rígidas em simulações químicas (reações), aerodinâmica e circuitos elétricos, garantindo estabilidade em problemas industriais reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Introduzir polinômios geradores ρ(ζ) e σ(ζ)",
                            "description": "Definir ρ(ζ) = ∑_{k=0}^s α_k ζ^k e σ(ζ) = ∑_{k=0}^s β_k ζ^k, explicando seu uso na análise da ordem do método e na região de estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Fórmula Geral dos Métodos Linears Multistep (LMM)",
                                  "subSteps": [
                                    "Recordar a forma geral do LMM: ∑_{j=0}^s α_j y_{n+j} = h ∑_{j=0}^s β_j f(t_{n+j}, y_{n+j}).",
                                    "Identificar os coeficientes α_j e β_j como elementos chave da fórmula.",
                                    "Explicar que esses coeficientes definem propriedades como ordem e estabilidade.",
                                    "Derivar a motivação para representar os coeficientes via polinômios.",
                                    "Discutir a notação polinomial em termos da variável ζ."
                                  ],
                                  "verification": "Escrever corretamente a fórmula geral do LMM e listar os papéis dos coeficientes α_j e β_j.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Apostila de Análise Numérica",
                                    "Quadro branco ou papel para anotações",
                                    "Calculadora simbólica opcional"
                                  ],
                                  "tips": "Use exemplos numéricos simples de métodos de um passo para contextualizar a transição para multistep.",
                                  "learningObjective": "Compreender a base da fórmula LMM que motiva os polinômios geradores.",
                                  "commonMistakes": "Confundir os índices j com o número de passos s; ignorar o fator h na parte direita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Polinômio Gerador ρ(ζ)",
                                  "subSteps": [
                                    "Escrever ρ(ζ) = ∑_{k=0}^s α_k ζ^k, destacando que é o polinômio de primeira diferença.",
                                    "Explicar que ρ(ζ) corresponde à aproximação da solução exata y(t).",
                                    "Verificar a raiz ρ(1) = 0 para consistência de ordem 1.",
                                    "Calcular ρ'(1) = 1 para consistência de ordem pelo menos 1.",
                                    "Explorar exemplos: ρ(ζ) = ζ - 1 para método de Euler implícito."
                                  ],
                                  "verification": "Derivar ρ(ζ) a partir dos α_k de um LMM conhecido e verificar ρ(1) = 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de exercícios com coeficientes de LMM",
                                    "Software como Mathematica ou SymPy para polinômios"
                                  ],
                                  "tips": "Sempre normalize os coeficientes dividindo pelo α_s para monico.",
                                  "learningObjective": "Definir formalmente ρ(ζ) e suas propriedades de consistência básica.",
                                  "commonMistakes": "Esquecer o índice k de 0 a s; confundir ρ(ζ) com o polinômio da função f."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o Polinômio Gerador σ(ζ)",
                                  "subSteps": [
                                    "Definir σ(ζ) = ∑_{k=0}^s β_k ζ^k, associado à aproximação do integrando h f(y).",
                                    "Relacionar σ(ζ)/ρ'(1) ≈ ∫_0^1 e^{(1-u)ζ} du para análise de ordem.",
                                    "Verificar σ(1) = 0 se β_0 = 0 em métodos explícitos.",
                                    "Comparar com ρ(ζ): σ gera a parte 'direita' da equação LMM.",
                                    "Exemplo: σ(ζ) = (ζ - 1)/2 para trapezoidal."
                                  ],
                                  "verification": "Construir σ(ζ) para um método dado e relacioná-lo à integral de quadratura.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de métodos multistep padrão",
                                    "Gráficos de polinômios (opcional)"
                                  ],
                                  "tips": "Desenhe os polinômios para visualizar raízes e comportamento.",
                                  "learningObjective": "Definir σ(ζ) e diferenciá-lo de ρ(ζ) em termos funcionais.",
                                  "commonMistakes": "Trocar os papéis de ρ e σ; omitir o fator de normalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Usos na Ordem do Método e Região de Estabilidade",
                                  "subSteps": [
                                    "Derivar a ordem p: truncamento local O(h^{p+1}) quando ρ(ζ)/ζ e σ(ζ)/ρ'(1) coincidem até ordem p.",
                                    "Definir a região de estabilidade via |ρ(e^{iθ}) + μ σ(e^{iθ})| ≤ 1 para |μ| grande.",
                                    "Analisar estabilidade A(α): raízes de ρ dentro do círculo unitário.",
                                    "Estudar estabilidade B(∞): comportamento assintótico para hλ grande.",
                                    "Aplicar a um exemplo como Adams-Moulton."
                                  ],
                                  "verification": "Calcular a ordem de um LMM dado usando expansões de ρ e σ em ζ=1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Burden & Faires",
                                    "Software MATLAB para plots de estabilidade"
                                  ],
                                  "tips": "Comece com métodos de baixa ordem para construir intuição.",
                                  "learningObjective": "Aplicar ρ(ζ) e σ(ζ) para analisar ordem e estabilidade.",
                                  "commonMistakes": "Confundir ordem de consistência com ordem global; ignorar multiplicidade de raízes."
                                }
                              ],
                              "practicalExample": "Para o método de backward differentiation de ordem 2 (BDF2): α_0 = 4/3, α_1 = -4/3, α_2 = 1/3, β_2 = 2/3 (outros β=0). Então ρ(ζ) = (1/3)ζ^2 - (4/3)ζ + 4/3, σ(ζ) = (2/3)ζ^2. Verifique ordem 2 expandindo Taylor em ζ=1 e plot a região de estabilidade absoluta.",
                              "finalVerifications": [
                                "Escrever definições exatas de ρ(ζ) e σ(ζ) sem erros.",
                                "Calcular corretamente ρ(1)=0 e ρ'(1)=1 para um exemplo.",
                                "Explicar verbalmente o papel de σ na aproximação quadrada.",
                                "Derivar condição de ordem p usando resíduos de Taylor.",
                                "Desenhar região de estabilidade básica para método explícito vs implícito.",
                                "Identificar raízes principais de ρ para estabilidade A(α)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições matemáticas (ρ e σ corretos).",
                                "Clareza na distinção entre papéis de ρ (solução) e σ (forçante).",
                                "Correção nos cálculos de ordem e consistência.",
                                "Profundidade na análise de estabilidade (raízes, plots).",
                                "Uso apropriado de exemplos concretos de LMM.",
                                "Capacidade de derivar propriedades a partir da definição geral."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Análise de raízes e autovalores para estabilidade.",
                                "Programação Numérica: Implementação em solvers como ODE45 no MATLAB.",
                                "Física Computacional: Simulações de EDOs em dinâmica de fluidos.",
                                "Estatística: Quadraturas em métodos Monte Carlo para integrais."
                              ],
                              "realWorldApplication": "Esses polinômios são fundamentais em pacotes como SciPy (solve_ivp) e MATLAB ODE solvers para projetar métodos multistep estáveis em simulações de longo prazo, como previsão meteorológica, circuitos elétricos e modelagem epidemiológica (ex: SIR models para COVID-19)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Determinar ordem do método via polinômios",
                            "description": "Explicar a condição de ordem p: a equação de diferença deve coincidir com a derivada exata até ordem p, verificando ∑ k^j α_k = 0 para j=0,...,p-1 e ∑ k^j β_k = (1/p!) ∑ k^{j+1} α_k para j=0,...,p-1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os polinômios geradores e a fórmula do LMM",
                                  "subSteps": [
                                    "Revise a fórmula geral dos métodos lineares multistep: ∑_{k=0}^m α_k y_{n+k} = h ∑_{k=0}^m β_k f_{n+k}.",
                                    "Defina os polinômios geradores ρ(ζ) = ∑_{k=0}^m α_k ζ^k e σ(ζ) = ∑_{k=0}^m β_k ζ^k.",
                                    "Verifique propriedades básicas, como ρ(1) = 0 para consistência.",
                                    "Esboce ρ(ζ) e σ(ζ) para um exemplo simples como o método de Euler forward.",
                                    "Discuta o papel dos coeficientes na aproximação numérica."
                                  ],
                                  "verification": "Escreva corretamente ρ(ζ) e σ(ζ) para pelo menos dois métodos multistep conhecidos e confirme ρ(1) = 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre LMM",
                                    "Livro de análise numérica",
                                    "Papel e lápis"
                                  ],
                                  "tips": [
                                    "Indexe sempre k de 0 a m consistentemente.",
                                    "Normalize dividindo por α_m = 1 quando possível.",
                                    "Visualize ρ(ζ) como polinômio de diferença."
                                  ],
                                  "learningObjective": "Dominar a representação polinomial dos coeficientes α_k e β_k em métodos LMM.",
                                  "commonMistakes": [
                                    "Confundir α_k com β_k.",
                                    "Esquecer o fator h na equação.",
                                    "Índice errado no operador de shift E."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender conceitualmente a condição de ordem p",
                                  "subSteps": [
                                    "Explique que a ordem p significa que a equação de diferença coincide com a derivada exata até termos de ordem h^p.",
                                    "Revise a expansão de Taylor da solução y(t + kh) em torno de t_n.",
                                    "Discuta como o operador de diferença ρ(E) - h σ(E) D deve ser O(h^{p+1}), onde D é d/dt.",
                                    "Introduza a necessidade de condições nos momentos das potências para coincidir os coeficientes de Taylor.",
                                    "Compare com métodos de Runge-Kutta para contextualizar."
                                  ],
                                  "verification": "Descreva em 3-5 frases como a ordem p afeta o erro local de truncamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de expansões Taylor",
                                    "Software simbólico como SymPy ou Mathematica (opcional)",
                                    "Gráficos de erro vs h"
                                  ],
                                  "tips": [
                                    "Pense em termos de série de Taylor infinita e truncamento.",
                                    "Use o operador forward E y_n = y_{n+1}.",
                                    "Ligue à precisão global O(h^p)."
                                  ],
                                  "learningObjective": "Compreender a relação entre aproximação de Taylor e ordem do método.",
                                  "commonMistakes": [
                                    "Confundir erro local O(h^{p+1}) com global O(h^p).",
                                    "Ignorar contribuições de ordens baixas.",
                                    "Não considerar o ponto de expansão em t_n."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer as condições algébricas via polinômios",
                                  "subSteps": [
                                    "Estude a condição para α_k: ∑_{k} k^j α_k = 0 para cada j = 0, ..., p-1.",
                                    "Estude a condição para β_k: ∑_{k} k^j β_k = (1/(j+1)!) ∑_{k} k^{j+1} α_k para j = 0, ..., p-1 (corrigindo para consistência didática).",
                                    "Derive conceitualmente essas condições a partir das derivadas de ρ(ζ) - ζ σ(ζ) em ζ=1.",
                                    "Crie uma tabela de momentos μ_j^α = ∑ k^j α_k e μ_j^β = ∑ k^j β_k.",
                                    "Verifique para p=1: apenas j=0."
                                  ],
                                  "verification": "Liste as condições matemáticas exatas para ordem p=2 e confirme com um cálculo simbólico simples.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora ou Excel para somas",
                                    "Tabela de potências k^j para k=0 a 5",
                                    "Notas derivadas"
                                  ],
                                  "tips": [
                                    "Use fatoriais corretamente nos denominadores.",
                                    "Comece sempre por j=0: ∑ α_k = 0 e ∑ β_k ≈ 1.",
                                    "Automatize somas com loop em Python se possível."
                                  ],
                                  "learningObjective": "Memorizar e justificar as condições algébricas para determinar a ordem p.",
                                  "commonMistakes": [
                                    "Usar p! em vez de (j+1)! nos coeficientes.",
                                    "Esquecer =0 para momentos de α_k.",
                                    "Cálculos aritméticos errados em potências altas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o procedimento para determinar a ordem p",
                                  "subSteps": [
                                    "Dado α_k e β_k, crie tabela de momentos para j=0,1,2,... até 5.",
                                    "Teste sucessivamente: para cada candidato p, verifique todas condições j=0 a p-1.",
                                    "Identifique o menor p onde pelo menos uma condição falha.",
                                    "Analise o coeficiente de erro principal quando falha.",
                                    "Repita para 2-3 métodos diferentes."
                                  ],
                                  "verification": "Determine a ordem para um método dado e justifique com cálculos numéricos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python/NumPy",
                                    "Lista de coeficientes de métodos padrão (ex: AB2, AM2)",
                                    "Papel para tabela"
                                  ],
                                  "tips": [
                                    "Faça tabela com colunas j, μ_j^α, condição α, μ_j^β, condição β.",
                                    "Teste p=1,2,3,... sequencialmente.",
                                    "Confirme com ordem conhecida do método."
                                  ],
                                  "learningObjective": "Executar cálculo prático da ordem p para qualquer conjunto de coeficientes.",
                                  "commonMistakes": [
                                    "Não testar todas j para um dado p.",
                                    "Arredondamentos em somas decimais.",
                                    "Confundir ordem p com grau dos polinômios."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o método trapezoidal: α = [-1, 1], β = [0.5, 0.5].\nTabela de momentos:\nj=0: ∑ α_k = 0 ✓, ∑ β_k = 1, (1/1!) ∑ k α_k = 1*1 = 1 ✓\nj=1: ∑ k α_k = 1 ≠ 0 (falha para p>1, mas contexto permite ordem 2 via condições β), ∑ k β_k = 0.5, (1/2!) ∑ k^2 α_k = 0.5*1 = 0.5 ✓\nj=2: falha. Ordem p=2.",
                              "finalVerifications": [
                                "Consegui escrever ρ(ζ) e σ(ζ) corretamente para 3 métodos.",
                                "Expliquei a condição de ordem p em termos de Taylor sem erros.",
                                "Calculei momentos corretamente para um exemplo e identifiquei p.",
                                "Verifiquei condições para j=0,1,2 em um método conhecido.",
                                "Analisei por que a condição falha determina o erro principal.",
                                "Comparei ordem calculada com literatura padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de somatórios de momentos (sem erros aritméticos).",
                                "Correta identificação da ordem p com justificativa completa.",
                                "Entendimento conceitual demonstrado em explicações.",
                                "Uso adequado de tabelas e verificações sistemáticas.",
                                "Capacidade de generalizar para novos coeficientes.",
                                "Análise de erros comuns evitados nos cálculos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra: Manipulação de polinômios e derivadas em ζ=1.",
                                "Programação: Implementação de somas em loops (Python/NumPy para automação).",
                                "Física: Aplicação em EDOs de movimento (ex: simulações orbitais).",
                                "Estatística: Análise de erro e convergência numérica."
                              ],
                              "realWorldApplication": "Em simulações científicas como previsão do tempo, dinâmica de fluidos ou modelagem financeira, determinar a ordem de métodos multistep permite escolher precisão vs custo computacional, otimizando simulações de longo prazo onde erros acumulam."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Classificação e Propriedades Básicas dos LMM",
                        "description": "Classificação dos métodos LMM em explícitos e implícitos, com ênfase em consistência, convergência e relação com problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Classificar LMM como explícitos ou implícitos",
                            "description": "Distinguir métodos explícitos (β_s = 0, y_{n+s} computado diretamente) de implícitos (β_s ≠ 0, requer solução de equação não linear em y_{n+s}), citando vantagens para problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a fórmula geral dos Métodos Lineares Multistep (LMM)",
                                  "subSteps": [
                                    "Escreva a fórmula geral dos LMM: ∑_{j=0}^s α_j y_{n+j} = h ∑_{j=0}^s β_j f(t_{n+j}, y_{n+j}).",
                                    "Identifique os coeficientes α_j (para aproximações y) e β_j (para derivadas f).",
                                    "Explique o papel de y_{n+s} no lado esquerdo e como ela é o valor a ser computado.",
                                    "Discuta o contexto de problemas de valor inicial (PVI) com EDOs ordinárias.",
                                    "Anote os índices de j=0 a s, destacando j=s como o passo avançado."
                                  ],
                                  "verification": "Confirme escrevendo a fórmula corretamente e identificando todos os coeficientes em um papel ou editor.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Análise Numérica ou notas de aula",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Use notação LaTeX ou simbólica para clareza; memorize apenas a estrutura geral.",
                                  "learningObjective": "Compreender a estrutura matemática fundamental dos LMM para basear a classificação.",
                                  "commonMistakes": [
                                    "Confundir α_j com β_j",
                                    "Esquecer o fator h (passo de integração)",
                                    "Ignorar que é multistep (s ≥ 1)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o coeficiente β_s e sua implicação",
                                  "subSteps": [
                                    "Localize β_s na soma do lado direito da fórmula.",
                                    "Defina método explícito: β_s = 0, y_{n+s} é computado diretamente sem dependência de si mesmo.",
                                    "Defina método implícito: β_s ≠ 0, y_{n+s} aparece em ambos os lados, formando equação não linear.",
                                    "Derive a equação para y_{n+s} em cada caso: explícito é algébrico direto; implícito requer solver iterativo.",
                                    "Discuta linearidade: para EDOs lineares, implícitos podem ser resolvidos linearmente."
                                  ],
                                  "verification": "Escreva as definições de explícito e implícito com base em β_s e resolva um caso simples manualmente.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de fórmulas LMM de referência (e.g., tabela de coeficientes)"
                                  ],
                                  "tips": "Pense em β_s como o 'feedback' de f_{n+s}; zero significa sem feedback.",
                                  "learningObjective": "Distinguir matematicamente explícitos de implícitos via β_s.",
                                  "commonMistakes": [
                                    "Achar que β_s afeta apenas precisão, não computação",
                                    "Confundir com métodos single-step como Euler"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar exemplos de LMM",
                                  "subSteps": [
                                    "Pegue método Adams-Bashforth de ordem 2: verifique β_2 = 0 → explícito.",
                                    "Pegue método Adams-Moulton de ordem 2: verifique β_2 ≠ 0 → implícito.",
                                    "Classifique BDF (Backward Differentiation Formula) de ordem 1: implícito.",
                                    "Crie uma tabela comparativa: método, ordem, β_s, tipo.",
                                    "Teste com fórmula genérica: defina β_s=0 ou 0.5 e classifique."
                                  ],
                                  "verification": "Classifique 3 métodos conhecidos corretamente e preencha tabela sem erros.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Tabela de coeficientes LMM (online ou livro)",
                                    "Planilha Excel ou papel para tabela"
                                  ],
                                  "tips": "Memorize: Adams-Bashforth sempre explícito, Adams-Moulton implícito.",
                                  "learningObjective": "Aplicar a classificação a métodos padrão de LMM.",
                                  "commonMistakes": [
                                    "Classificar errado BDF como explícito",
                                    "Ignorar ordem s na verificação de β_s"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir vantagens, especialmente para problemas stiff",
                                  "subSteps": [
                                    "Defina problemas stiff: EDOs com escalas temporais muito diferentes (e.g., componentes rápidas e lentas).",
                                    "Explique limitação de explícitos: instabilidade para h grande em stiff (erro amplificado).",
                                    "Vantagens de implícitos: A-stabilidade (regiões de estabilidade maiores), ideais para stiff.",
                                    "Cite exemplos: Gear's method (BDF implícito) para stiff em química.",
                                    "Compare estabilidade: diagrama de regiões de estabilidade qualitativo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que implícitos são melhores para stiff, com exemplo.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Gráficos de estabilidade de LMM (referência online)",
                                    "Software como MATLAB ode15s para demo opcional"
                                  ],
                                  "tips": "Associe 'stiff' a rigidez estrutural: precisa de suporte (implícito).",
                                  "learningObjective": "Citar vantagens contextuais da classificação para seleção de métodos.",
                                  "commonMistakes": [
                                    "Achar explícitos sempre melhores por simplicidade",
                                    "Confundir stiff com não-linearidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada a fórmula LMM de ordem 2: α_0 y_n + α_1 y_{n+1} - y_{n+2} = h (β_0 f_n + β_1 f_{n+1} + β_2 f_{n+2}), com β_2 = 0: classifique como explícito (computa y_{n+2} diretamente). Se β_2 = 3/2, classifique como implícito (resolve equação não linear em y_{n+2}). Para stiff como y' = -1000(y-1) + sin(t), prefira implícito para h=0.1 estável.",
                              "finalVerifications": [
                                "Escreva definições precisas de LMM explícito e implícito baseadas em β_s.",
                                "Classifique corretamente Adams-Bashforth e Adams-Moulton.",
                                "Explique por que implícitos são vantajosos para problemas stiff.",
                                "Identifique β_s em uma fórmula genérica dada.",
                                "Diferencie LMM de métodos Runge-Kutta single-step.",
                                "Descreva o processo de solução para caso implícito."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de β_s como critério de classificação (100%).",
                                "Correção em exemplos de métodos padrão (explícito/implícito).",
                                "Explicação clara de implicações computacionais (direto vs iterativo).",
                                "Compreensão de estabilidade em problemas stiff com exemplos.",
                                "Uso correto de terminologia (LMM, multistep, A-estabilidade).",
                                "Capacidade de criar tabela comparativa completa."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em Python (SciPy solve_ivp) ou MATLAB ode solvers.",
                                "Física: Simulação de EDOs stiff em dinâmica de fluidos ou osciladores amortecidos.",
                                "Engenharia Química: Modelagem de reações stiff (cinética rápida/lenta).",
                                "Programação Numérica: Análise de estabilidade e escolha de solvers.",
                                "Matemática Aplicada: Teoria de estabilidade de Dahlquist."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos RLC stiff (componentes com constantes de tempo díspares), solvers implícitos como BDF evitam instabilidade numérica, permitindo h maior e simulações mais rápidas em software como SPICE ou COMSOL."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Verificar consistência do método",
                            "description": "Definir consistência como lim_{h→0} do operador de diferença reproduzir a equação diferencial (ρ(1)=σ(1)=0 e ρ'(1)=σ'(1)), essencial para convergência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição dos polinômios ρ(z) e σ(z) nos Métodos Lineares Multistep (LMM)",
                                  "subSteps": [
                                    "Lembre-se da forma geral do LMM: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j})",
                                    "Identifique o polinômio de diferença ρ(z) = ∑_{j=0}^k α_j z^j",
                                    "Identifique o polinômio de suavização σ(z) = ∑_{j=0}^k β_j z^j",
                                    "Escreva exemplos simples, como para o método de Euler backward: ρ(z) = z - 1, σ(z) = 1",
                                    "Verifique o grau k do método e normalize os coeficientes (α_k = 1)"
                                  ],
                                  "verification": "Escreva corretamente ρ(z) e σ(z) para um LMM dado e confirme que α_k = 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Livro de Análise Numérica (capítulo LMM)",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Sempre normalize dividindo pelos coeficientes de y_{n+k} para padronizar.",
                                  "learningObjective": "Compreender a representação polinomial dos LMM e extrair ρ(z) e σ(z) de coeficientes.",
                                  "commonMistakes": [
                                    "Confundir α_j com β_j",
                                    "Esquecer de normalizar α_k=1",
                                    "Índices errados nos polinômios"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a definição de consistência via limite h→0",
                                  "subSteps": [
                                    "Defina consistência: o operador de diferença L[h,y(t);f] → 0 quando h→0 para soluções suaves y(t) da EDO y'=f(t,y)",
                                    "Expanda L[h,y(t);f] em série de Taylor em torno de t_n",
                                    "Mostre que para consistência de ordem 1, o termo constante e linear em h devem vanishing",
                                    "Conclua que isso requer ∑ α_j = 0 e ∑ j α_j = ∑ j β_j",
                                    "Relacione com condições polinomiais: ρ(1)=0 e ρ'(1)=σ'(1)"
                                  ],
                                  "verification": "Derive as condições de consistência a partir do limite e escreva ρ(1)=0, σ(1)=0, ρ'(1)=σ'(1).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para expansões de Taylor",
                                    "Notas de aula sobre LMM",
                                    "Software como Mathematica para derivadas simbólicas"
                                  ],
                                  "tips": "Use a regra da cadeia para derivadas de ρ e σ; lembre que ρ'(z) = ∑ j α_j z^{j-1}.",
                                  "learningObjective": "Derivar as condições equivalentes de consistência usando análise assintótica.",
                                  "commonMistakes": [
                                    "Esquecer σ(1)=0",
                                    "Confundir ρ'(1) com σ(1)",
                                    "Erros em derivadas polinomiais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender a computar as condições de consistência para ρ(z) e σ(z)",
                                  "subSteps": [
                                    "Calcule ρ(1) = ∑_{j=0}^k α_j",
                                    "Calcule σ(1) = ∑_{j=0}^k β_j",
                                    "Calcule ρ'(z) = ∑_{j=1}^k j α_j z^{j-1}, então ρ'(1) = ∑_{j=1}^k j α_j",
                                    "Calcule σ'(1) = ∑_{j=1}^k j β_j",
                                    "Verifique se ρ(1)=0, σ(1)=0 e ρ'(1)=σ'(1); se sim, o método é consistente"
                                  ],
                                  "verification": "Para coeficientes dados, compute os três valores e declare consistente ou não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de coeficientes de LMM comuns",
                                    "Planilha Excel ou Python para somas",
                                    "Exemplos de métodos como Adams-Bashforth"
                                  ],
                                  "tips": "Agrupe termos para somas: use propriedades lineares para eficiência.",
                                  "learningObjective": "Dominar o cálculo numérico das condições de consistência.",
                                  "commonMistakes": [
                                    "Índice off-by-one em derivadas",
                                    "Não multiplicar por j em ρ'(1)",
                                    "Ignorar σ(1)=0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar verificação de consistência em métodos conhecidos",
                                  "subSteps": [
                                    "Pegue o método trapezoidal: α_0=-1, α_1=1, β_0=1/2, β_1=1/2",
                                    "Compute ρ(1)=0?, σ(1)=1?, ρ'(1)=1, σ'(1)=1",
                                    "Teste um método inconsistente, como α_0=1, α_1=1 (ρ(1)=2≠0)",
                                    "Registre resultados em tabela: método | ρ(1) | σ(1) | ρ'(1)-σ'(1)",
                                    "Discuta implicações para convergência (consistência necessária para ordem >0)"
                                  ],
                                  "verification": "Crie tabela com 3 métodos e classifique cada um como consistente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de LMM de ordem 1-3",
                                    "Python script para automação",
                                    "Artigo sobre propriedades de LMM"
                                  ],
                                  "tips": "Teste com k pequeno primeiro; automatize para evitar erros aritméticos.",
                                  "learningObjective": "Aplicar rotineiramente a verificação em exemplos reais de LMM.",
                                  "commonMistakes": [
                                    "Escolher métodos já conhecidos sem calcular",
                                    "Erros aritméticos em somas",
                                    "Confundir ordem de consistência com ordem do método"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar implicações e zero-stability",
                                  "subSteps": [
                                    "Ligue consistência a convergência: necessário com zero-stability (raiz ρ(z)=1 simples)",
                                    "Verifique consistência + zero-stability para convergência",
                                    "Dê exemplo de método consistente mas não zero-stable",
                                    "Resuma critérios completos para LMM convergentes",
                                    "Planeje verificação em código para solvers numéricos"
                                  ],
                                  "verification": "Explique verbalmente por que consistência é essencial e dê contraexemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Teorema de convergência de LMM",
                                    "Código MATLAB/Octave de solvers",
                                    "Gráficos de erro vs h"
                                  ],
                                  "tips": "Visualize com plots de erro numérico para métodos consistentes vs não.",
                                  "learningObjective": "Contextualizar consistência no quadro maior de análise de LMM.",
                                  "commonMistakes": [
                                    "Confundir consistência com estabilidade",
                                    "Ignorar multiplicidade da raiz ρ(1)=0",
                                    "Subestimar papel em convergência global"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método de Adams-Moulton de ordem 2: ρ(z) = (z-1)^2 / 2, σ(z) = (z^2 + z)/12. Compute ρ(1)=0, σ(1)=1/6≠0? Não, espere: coeficientes corretos α_0=2, α_1=-4, α_2=2? Padronize. Método correto: ρ(z)=z^2 -1, σ(z)=(3z^2 + 3z -1)/12? Verificação: ρ(1)=0, ρ'(z)=2z, ρ'(1)=2; σ(1)=5/12? Use exemplo trapezoidal: consistente pois ρ(1)=0, σ(1)=1, ρ'(1)=1=σ'(1).",
                              "finalVerifications": [
                                "Define corretamente consistência usando limite h→0?",
                                "Computa ρ(1), σ(1), ρ'(1), σ'(1) sem erros para LMM dado?",
                                "Classifica corretamente 3 métodos como consistentes?",
                                "Explica ligação com convergência?",
                                "Identifica erros comuns em verificações?",
                                "Aplica em código simples para automação?"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos polinomiais (100% correto)",
                                "Compreensão conceitual do limite assintótico (derivação completa)",
                                "Número e variedade de exemplos testados (mínimo 3)",
                                "Clareza na tabela de verificações",
                                "Integração com zero-stability e convergência",
                                "Capacidade de debugar erros aritméticos próprios"
                              ],
                              "crossCurricularConnections": [
                                "Física: Verificação em simulações numéricas de EDOs em dinâmica (ex: orbitas)",
                                "Computação: Implementação em bibliotecas como SciPy ode solvers",
                                "Engenharia: Análise de estabilidade em controle de sistemas",
                                "Estatística: Modelos estocásticos com métodos multistep"
                              ],
                              "realWorldApplication": "Em software de simulação como MATLAB ODE45 ou COMSOL, verificar consistência garante precisão em predições de trajetórias de mísseis, fluxos de fluidos ou epidemias, evitando divergência numérica em cenários de engenharia crítica."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Família de Métodos de Adams",
                    "description": "Métodos explícitos (Adams-Bashforth) e implícitos (Adams-Moulton) para integração numérica de PVIs.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Métodos Explícitos Adams-Bashforth",
                        "description": "Métodos de passo múltiplo explícitos baseados na interpolação polinomial para aproximar a integral na equação diferencial y' = f(t,y).",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Derivação da fórmula de Adams-Bashforth",
                            "description": "Derivar as fórmulas de Adams-Bashforth de ordem k (para k=1 a 4) usando interpolação de Lagrange sobre os k pontos anteriores de f(t_i, y_i), integrando para obter y_{n+1}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Polinômio de Interpolação de Lagrange",
                                  "subSteps": [
                                    "Lembre a fórmula geral do polinômio de Lagrange interpolando k+1 pontos: P(t) = Σ y_i * l_i(t), onde l_i(t) = Π (t - t_j)/(t_i - t_j) para j≠i.",
                                    "Identifique os pontos de interpolação para Adams-Bashforth: t_n, t_{n-1}, ..., t_{n-k} com valores f_n = f(t_n, y_n), ..., f_{n-k}.",
                                    "Escreva explicitamente P(t) em termos de h (passo), assumindo grade uniforme t_i = t_n - i h.",
                                    "Verifique para k=1: P(t) deve aproximar f(t_n).",
                                    "Pratique calculando l_i(s) onde s = (t - t_n)/h."
                                  ],
                                  "verification": "Construa P(t) para k=1 e confirme que P(t_n) = f_n e P(t_{n-1}) = f_{n-1}.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora simbólica (opcional, como Wolfram Alpha)",
                                    "Referência: Livro de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": [
                                    "Use s = (t - t_n)/h para normalizar e simplificar cálculos.",
                                    "Desenhe os pontos no plano para visualizar."
                                  ],
                                  "learningObjective": "Dominar a construção do interpolante de Lagrange para valores de f em pontos passados.",
                                  "commonMistakes": [
                                    "Confundir índices (n vs n-k)",
                                    "Esquecer o denominador em l_i(t)",
                                    "Não normalizar com h"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Interpolação para os k Pontos Anteriores",
                                  "subSteps": [
                                    "Defina os nós: x_i = -i para i=0 a k-1, onde x_0=0 corresponde a t_n, x_1=-1 para t_{n-1}, etc.",
                                    "Escreva as bases de Lagrange: l_i(s) = Π_{j=0, j≠i}^{k-1} (s - x_j)/(x_i - x_j), com s = (t - t_n)/h.",
                                    "Forme o interpolante: P(s) = Σ_{i=0}^{k-1} f_{n-i} l_i(s).",
                                    "Expanda para k=2 explicitamente: l_0(s) = (s+1)/1, l_1(s) = -s/1.",
                                    "Verifique P(0) = f_n e P(-1) = f_{n-1}."
                                  ],
                                  "verification": "Calcule P(s) para k=2 e confirme interpolação nos nós.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de álgebra computacional (Mathematica ou SymPy)",
                                    "Notas de aula sobre Lagrange"
                                  ],
                                  "tips": [
                                    "Mantenha os coeficientes simbólicos para generalidade.",
                                    "Tabule os x_i para evitar erros de sinal."
                                  ],
                                  "learningObjective": "Configurar corretamente o interpolante para pontos passados em grade uniforme.",
                                  "commonMistakes": [
                                    "Índices errados nos nós (x_i = -i)",
                                    "Sinais negativos em l_i(s)",
                                    "Confundir f_{n-i} com y"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar o Interpolante para Obter a Fórmula de Adams-Bashforth",
                                  "subSteps": [
                                    "Lembre a integral: y_{n+1} ≈ y_n + h ∫_0^1 P(s) ds, onde integral de t_n a t_{n+1} normalizada.",
                                    "Compute os coeficientes β_i = ∫_0^1 l_i(s) ds para i=0 a k-1.",
                                    "Mostre que y_{n+1} = y_n + h Σ_{i=0}^{k-1} β_i f_{n-i}.",
                                    "Para k=1: β_0 = ∫_0^1 1 ds = 1, então AB1: y_{n+1} = y_n + h f_n.",
                                    "Calcule β_i para k=2: β_0 = 3/2, β_1 = -1/2."
                                  ],
                                  "verification": "Derive a fórmula AB1 e AB2 completas e compare com fórmulas padrão.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Papel e lápis",
                                    "SymPy ou Mathematica para integrais simbólicas",
                                    "Tabela de coeficientes AB conhecida"
                                  ],
                                  "tips": [
                                    "Integre l_i(s) termo a termo: ∫ Π (s - x_j)/(x_i - x_j) ds.",
                                    "Use propriedades de Lagrange para simplificar."
                                  ],
                                  "learningObjective": "Entender a origem da soma ponderada via integração do interpolante.",
                                  "commonMistakes": [
                                    "Limites da integral errados (0 a 1 em s)",
                                    "Confundir ∫ P(s) ds com ∫ P(t) dt",
                                    "Sinais nos β_i"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar Fórmulas Explícitas para Ordens k=2,3,4",
                                  "subSteps": [
                                    "Para k=2: Compute β_0 = ∫_0^1 (s+1) ds = 3/2, β_1 = ∫_0^1 -s ds = -1/2.",
                                    "Para k=3: Nós x=0,-1,-2; calcule l_0(s)=(s+1)(s+2)/2, etc., integre cada.",
                                    "Para k=4: Nós 0,-1,-2,-3; derive β_0=55/24, β_1=-59/24, β_2=37/24, β_3=-9/24.",
                                    "Escreva as fórmulas completas: AB2: y_{n+1}=y_n + h(3/2 f_n - 1/2 f_{n-1}), etc.",
                                    "Verifique truncamento: ordem deve ser k para ABk."
                                  ],
                                  "verification": "Reproduza as fórmulas padrão de AB2, AB3, AB4 sem olhar tabela.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Tabela de verificação de coeficientes AB"
                                  ],
                                  "tips": [
                                    "Use frações exatas e reduza.",
                                    "Verifique soma de β_i ≈1 para consistência de ordem 1."
                                  ],
                                  "learningObjective": "Calcular coeficientes e escrever fórmulas explícitas para ABk até k=4.",
                                  "commonMistakes": [
                                    "Erros aritméticos em integrais",
                                    "Índices trocados em f_{n-i}",
                                    "Não reduzir frações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver y' = -y, y(0)=1 com h=0.1, derive e aplique AB2 nos primeiros passos: compute y1 com AB1, y2 com AB2 usando f0 e f1, compare com solução exata e^{ -t }.",
                              "finalVerifications": [
                                "Derivação correta de AB1: y_{n+1} = y_n + h f_n",
                                "Coeficientes exatos para AB2: 3/2, -1/2",
                                "Coeficientes para AB3: 23/12, -16/12, 5/12",
                                "Coeficientes para AB4: 55/24, -59/24, 37/24, -9/24",
                                "Explicação conceitual da integração do interpolante",
                                "Identificação da ordem de truncamento O(h^{k+1})"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos coeficientes β_i (erro zero)",
                                "Clareza e lógica na sequência de derivação",
                                "Correta normalização com s = (t-t_n)/h",
                                "Verificação de interpolação nos nós",
                                "Uso correto de integrais definidas de 0 a 1",
                                "Generalização para ordem k"
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar ABk em Python (SciPy odeint)",
                                "Física Computacional: Simular osciladores harmônicos ou trajetórias",
                                "Engenharia: Modelagem de circuitos RLC via EDOs",
                                "Estatística: Integração numérica em MCMC",
                                "Ciência de Dados: Solvers para redes neurais dinâmicas"
                              ],
                              "realWorldApplication": "Fórmulas Adams-Bashforth são usadas em pacotes como MATLAB ode45, previsão numérica do tempo (modelos ECMWF), simulações aeroespaciais (NASA solvers), e modelagem epidemiológica (COVID-19 propagação)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Implementação numérica do método Adams-Bashforth",
                            "description": "Implementar em pseudocódigo ou código (ex: Python/MATLAB) o método Adams-Bashforth de ordem 2 e 4, inicializando com método de Euler ou Runge-Kutta e aplicando a passos subsequentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a formulação matemática do método Adams-Bashforth de ordens 2 e 4",
                                  "subSteps": [
                                    "Revise as equações diferenciais de valor inicial (PVI): y' = f(t,y), y(t0)=y0.",
                                    "Estude a fórmula do Adams-Bashforth ordem 2 (AB2): y_{n+1} = y_n + h*(3/2 f_n - 1/2 f_{n-1}).",
                                    "Memorize a fórmula AB4: y_{n+1} = y_n + h*(55/24 f_n - 59/24 f_{n-1} + 37/24 f_{n-2} - 9/24 f_{n-3}).",
                                    "Identifique a necessidade de k passos iniciais usando Euler ou Runge-Kutta ordem 4 (RK4).",
                                    "Escolha um problema teste simples: y' = -y, y(0)=1 (solução exata y=exp(-t))."
                                  ],
                                  "verification": "Escreva corretamente as fórmulas AB2 e AB4 em pseudocódigo e liste os 4 coeficientes de AB4.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre métodos multistep",
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta para derivações"
                                  ],
                                  "tips": "Anote os coeficientes em uma tabela para consulta rápida durante a codificação.",
                                  "learningObjective": "Dominar as equações explícitas do método Adams-Bashforth e sua dependência de passos prévios.",
                                  "commonMistakes": [
                                    "Confundir os sinais dos coeficientes negativos",
                                    "Esquecer que AB4 requer 4 valores iniciais f_{n-3} a f_n",
                                    "Ignorar o step size h nas fórmulas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método de inicialização com Runge-Kutta ordem 4 (RK4)",
                                  "subSteps": [
                                    "Defina a função f(t,y) para o problema teste em Python.",
                                    "Implemente a função RK4 para computar os primeiros k passos (k=3 para AB4).",
                                    "Escreva uma função que retorne y e f em pontos iniciais: t0, t1, ..., tk.",
                                    "Teste a inicialização gerando valores y[0] a y[3] e f[0] a f[3] com h=0.1.",
                                    "Armazene os valores em listas ou arrays NumPy para eficiência."
                                  ],
                                  "verification": "Execute o código de inicialização e verifique que y[1] ≈ exp(-0.1) ≈ 0.9048 para o problema teste.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python 3 com NumPy e Matplotlib instalados",
                                    "Editor de código (VSCode ou Jupyter Notebook)"
                                  ],
                                  "tips": "Use arrays NumPy para vetores t, y, f para facilitar indexação.",
                                  "learningObjective": "Implementar um resolvedor one-step preciso para inicializar métodos multistep.",
                                  "commonMistakes": [
                                    "Erro na fórmula RK4 (k1 a k4 mal calculados)",
                                    "Indexação incorreta de arrays (off-by-one)",
                                    "Não normalizar h nos argumentos de f"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o predictor Adams-Bashforth ordem 2 (AB2)",
                                  "subSteps": [
                                    "Crie uma função ab2_step(y_n, f_n, f_nm1, h) retornando y_np1.",
                                    "Integre à inicialização: após 2 passos RK4, aplique AB2 para passos subsequentes.",
                                    "Atualize listas t, y, f iterativamente até o tempo final.",
                                    "Adicione comentários explicando cada coeficiente.",
                                    "Teste com h=0.1 no intervalo [0,1] e plote y_num vs y_exata."
                                  ],
                                  "verification": "Erro global máximo < 0.01 comparado à solução exata exp(-t).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código do Step 2",
                                    "NumPy para arrays",
                                    "Matplotlib para plotagem"
                                  ],
                                  "tips": "Mantenha f atualizado: após cada y_{n+1}, compute f_{n+1} = f(t_{n+1}, y_{n+1}).",
                                  "learningObjective": "Codificar e aplicar o método AB2 de forma estável e precisa.",
                                  "commonMistakes": [
                                    "Não atualizar f após previsão",
                                    "Usar índices errados para f_{n-1}",
                                    "Acumular erros por h muito grande"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o predictor Adams-Bashforth ordem 4 (AB4) e integrar tudo",
                                  "subSteps": [
                                    "Crie função ab4_step(y_n, f_n, f_nm1, f_nm2, f_nm3, h) com coeficientes 55/24, -59/24, 37/24, -9/24.",
                                    "Após 4 passos RK4, aplique AB4 iterativamente.",
                                    "Escreva uma função master que aceite ordem (2 ou 4), h, t_final e rode o método.",
                                    "Compare precisão AB2 vs AB4 plotando erros.",
                                    "Adicione tratamento de erro para passos insuficientes."
                                  ],
                                  "verification": "Para AB4 com h=0.1, erro global < 10^{-4}; confirme coeficientes hardcoded corretos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código dos Steps anteriores",
                                    "Solução exata: numpy.exp(-t)",
                                    "Gráficos de erro logarítmico"
                                  ],
                                  "tips": "Use uma loop while t < t_final com t += h para simplicidade.",
                                  "learningObjective": "Estender para ordens mais altas e analisar ganho de precisão.",
                                  "commonMistakes": [
                                    "Coeficientes fracionários imprecisos (use floats exatos)",
                                    "Buffer overflow em listas sem pré-alocação",
                                    "Instabilidade para problemas rígidos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar a implementação e analisar resultados",
                                  "subSteps": [
                                    "Teste com outro problema: y' = y*(1-y), y(0)=0.5 (logística).",
                                    "Calcule erros absolutos e relativos em múltiplos h (0.05, 0.1, 0.2).",
                                    "Plote soluções numéricas vs exatas e tabelas de erros.",
                                    "Verifique convergência: ordem 2 para AB2, ordem 4 para AB4.",
                                    "Documente o código em Markdown ou comentários extensos."
                                  ],
                                  "verification": "Tabelas mostram ordem de convergência correta (log(error)/log(h) ≈ ordem).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código completo",
                                    "SciPy para solução exata se necessário",
                                    "Excel ou Pandas para tabelas"
                                  ],
                                  "tips": "Use np.linalg.norm para erro global L2.",
                                  "learningObjective": "Avaliar numericamente a precisão e robustez da implementação.",
                                  "commonMistakes": [
                                    "Comparar com solução errada",
                                    "Escala log errada para convergência",
                                    "Ignorar truncamento em plots"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente em Python o método AB4 para resolver y' = -2y + sin(t), y(0)=1 no intervalo [0,5] com h=0.05. Inicialize com 4 passos RK4. Plote a solução numérica contra a exata (resolvida analiticamente ou via SciPy odeint) e compute erro máximo < 10^{-5}.",
                              "finalVerifications": [
                                "Código executa sem erros para AB2 e AB4 em problemas teste.",
                                "Solução numérica converge à exata com ordem correta ao reduzir h.",
                                "Listas t, y, f têm comprimentos consistentes e passos exatos.",
                                "Plots mostram sobreposição visual perfeita para h pequeno.",
                                "Coeficientes AB4 hardcoded: [55/24, -59/24, 37/24, -9/24] exatos.",
                                "Função master flexível para ordens 2/4 e múltiplos f(t,y)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro global O(h^ordem) demonstrado numericamente.",
                                "Corretude: fórmulas e coeficientes implementados exatamente.",
                                "Eficiência: uso de arrays vetorizados, sem loops desnecessários.",
                                "Robustez: funciona para diferentes f(t,y) e intervalos.",
                                "Clareza: código comentado, funções modulares, plots informativos.",
                                "Documentação: README com exemplo de uso e análise de erros."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos numéricos e estruturas de dados (arrays dinâmicos).",
                                "Física: Simulação de sistemas dinâmicos como decaimento exponencial ou osciladores.",
                                "Engenharia: Modelagem em controle de processos e aerodinâmica.",
                                "Estatística: Aproximações em simulações Monte Carlo para EDOs.",
                                "Ciência de Dados: Integração numérica em machine learning (ex: redes neurais recorrentes)."
                              ],
                              "realWorldApplication": "Usado em simulações meteorológicas (modelos de previsão numérica), dinâmica de populações em ecologia, circuitos elétricos em engenharia, e finanças para simular trajetórias de preços de ativos sob modelos diferenciais estocásticos aproximados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Análise de erro de truncamento local",
                            "description": "Calcular e interpretar o erro de truncamento local O(h^{k+1}) para Adams-Bashforth de ordem k, derivando o termo principal envolvendo a derivada (k+1)-ésima de f.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a fórmula geral do método Adams-Bashforth de ordem k",
                                  "subSteps": [
                                    "Escreva a fórmula: y_{n+1} = y_n + h ∑_{j=0}^k β_j f(t_{n-j}, y_{n-j}), onde β_j são coeficientes derivados da interpolação de Newton backward.",
                                    "Liste os coeficientes β_j para ordens baixas (ex: k=1: β_0=1; k=2: β_0=3/2, β_1=-1/2; k=3: β_0=23/12, β_1=-16/12, β_2=5/12).",
                                    "Explique que os β_j aproximam a integral ∫_{t_n}^{t_{n+1}} f(s, y(s)) ds.",
                                    "Verifique consistência de ordem k comparando com método de Euler para k=1.",
                                    "Anote a origem como extrapolação polinomial de grau k."
                                  ],
                                  "verification": "Escrever corretamente a fórmula e coeficientes para k=2 e k=3 sem consulta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre métodos multistep",
                                    "Tabela de coeficientes Adams-Bashforth",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Comece com k=1 para intuitivamente conectar ao método de Euler; memorize os primeiros β_j usando mnemônicos.",
                                  "learningObjective": "Compreender a estrutura algébrica e os coeficientes do método ABk.",
                                  "commonMistakes": [
                                    "Confundir β_j com coeficientes de Adams-Moulton (implícitos)",
                                    "Erros de sinal nos β_j negativos",
                                    "Esquecer que é método explícito unipasso multistep"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a expansão de Taylor da solução exata y(t_{n+1})",
                                  "subSteps": [
                                    "Expanda y(t_{n+1}) = y(t_n + h) = ∑_{m=0}^{k+2} (h^m / m!) y^{(m)}(t_n) + O(h^{k+3}).",
                                    "Expresse y^{(m)}(t) em termos de f usando y' = f(t,y), e regras de chain rule para derivadas superiores (ou fórmula de Faà di Bruno).",
                                    "Integre formalmente: a solução exata satisfaz y(t_{n+1}) = y(t_n) + ∫_{t_n}^{t_{n+1}} f(s, y(s)) ds.",
                                    "Mantenha termos até ordem k+1 explicitamente, agrupando o resto como O(h^{k+2}).",
                                    "Verifique para k=1: deve recuperar erro O(h^2) do Euler."
                                  ],
                                  "verification": "Derivar a expansão até h^{k+2} e identificar o termo integral exato.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Livro de análise numérica (cap. métodos Runge-Kutta para analogia)",
                                    "Software como Mathematica para verificação simbólica"
                                  ],
                                  "tips": "Use notação y^{(m)} para simplificar; pratique chain rule iterativamente começando de y'' = df/dt + (df/dy) f.",
                                  "learningObjective": "Dominar a expansão de Taylor multivariable para soluções de EDOs.",
                                  "commonMistakes": [
                                    "Parar cedo na expansão (antes de h^{k+1})",
                                    "Erros na chain rule para y^{(m)}",
                                    "Confundir derivadas parciais de f"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir a aproximação do método ABk usando séries de Taylor",
                                  "subSteps": [
                                    "Expanda cada f(t_{n-j}, y_{n-j}) = f(t_n - j h, y(t_n - j h)) em torno de t_n.",
                                    "Use Taylor bivariado: f(t_n - j h, y(t_n - j h)) = ∑_{m=0}^{k+1} [( -j h)^m / m!] ∂^m f / ∂ t^m |_{(t_n,y_n)} + O(h^{k+2}).",
                                    "Substitua na soma: ∑_{j=0}^k β_j f(t_{n-j}, y_{n-j}) = ∑_{m=1}^{k+1} (h^{m-1} / m!) γ_m + O(h^{k+1}), onde γ_m são somas ponderadas.",
                                    "Mostre que γ_m = m para m=1,...,k (propriedade de consistência e ordem).",
                                    "Identifique que para m=k+1, γ_{k+1} ≠ k+1, levando ao erro."
                                  ],
                                  "verification": "Calcular as somas γ_m para m=1 a k+1 e confirmar γ_m = m para m≤k.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de cálculo para somas simbólicas",
                                    "Tabela de coeficientes β_j",
                                    "Python com SymPy para automação"
                                  ],
                                  "tips": "Agrupe por potências de h; use propriedades de quadratura de Newton para prever exatidão até ordem k.",
                                  "learningObjective": "Aplicar Taylor multivariado à interpolação polinomial subjacente.",
                                  "commonMistakes": [
                                    "Erros aritméticos nas somas ∑ β_j (-j)^m",
                                    "Esquecer fatores 1/m! nas expansões",
                                    "Não expandir y_{n-j} corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e interpretar o erro de truncamento local",
                                  "subSteps": [
                                    "Subtraia: erro local τ_{n+1} = [y(t_{n+1}) - y_n]/h - ∑_{j=0}^k β_j f_{n-j} = (h^k / (k+1)!) [ (k+1) - ∑_{j=0}^k β_j (j)^{k+1} ] y^{(k+1)}(ξ).",
                                    "Derive o coeficiente principal: c_{k+1} = 1/(k+1)! ∑_{j=0}^k β_j j^{k+1} (note o sinal).",
                                    "Mostre τ = c_{k+1} h^k y^{(k+1)}(ξ), logo erro O(h^{k+1}).",
                                    "Interprete: ordem k significa precisão local O(h^{k+1}), global O(h^k).",
                                    "Exemplo para k=2: c_3 = -1/12, τ = - (h^3 /12) y'''(ξ)."
                                  ],
                                  "verification": "Derivar o termo exato de erro para k=2 e confirmar com literatura.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência padrão (ex: Burden & Faires)",
                                    "Exemplos numéricos resolvidos",
                                    "Gráfica para visualizar ordem de convergência"
                                  ],
                                  "tips": "O coeficiente é negativo para AB; compare com AM para precisão similar.",
                                  "learningObjective": "Interpretar magnitude e origem do erro de truncamento.",
                                  "commonMistakes": [
                                    "Sinal errado no coeficiente c_{k+1}",
                                    "Confundir erro local τ com global",
                                    "Não normalizar pelo h na definição de τ"
                                  ]
                                }
                              ],
                              "practicalExample": "Para AB2 (k=2) resolvendo y' = -y, y(0)=1 (solução y=e^{-t}). Tome h=0.1, t_n=0. Calcule y_1^{AB2} ≈ 0.904837, exato y(0.1)≈0.904837, erro local ~ 10^{-6}, consistente com O(h^3) ~10^{-6}. Derive τ ≈ - (0.1)^3 /12 * y'''(ξ) ≈ -8.3e-7 * (-e^{-ξ}), confirmando.",
                              "finalVerifications": [
                                "Derivação completa do erro local O(h^{k+1}) com termo principal correto.",
                                "Cálculo explícito de c_{k+1} para pelo menos duas ordens k.",
                                "Interpretação qualitativa: impacto na estabilidade e precisão global.",
                                "Verificação numérica simples para k=1 ou 2 com EDO linear.",
                                "Identificação de y^{(k+1)} como fonte do erro.",
                                "Comparação com ordem do método."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor (pontos por termos corretos até k+2).",
                                "Correção dos coeficientes γ_m e c_{k+1} (exata para k≤3).",
                                "Clareza na subtração para obter τ_{n+1}.",
                                "Interpretação física/matemática do erro (ordem local vs global).",
                                "Exemplo numérico com cálculo de erro relativo <5% discrepância.",
                                "Uso correto de notação e limites O(h^{k+2})."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar ABk em Python/Octave e plotar log(erros) vs log(h) para confirmar ordem.",
                                "Física: Aplicar análise em simulações de movimento orbital (EDOs não-lineares).",
                                "Estatística: Avaliar incerteza numérica em modelos estocásticos.",
                                "Engenharia: Otimização de h em solvers de CFD (Computational Fluid Dynamics)."
                              ],
                              "realWorldApplication": "Em previsões meteorológicas e simulações climáticas, onde métodos ABk são usados em pacotes como ODEPACK para integrar EDOs rígidos de longa duração, permitindo análise de truncamento para escolher h ótimo e balancear precisão vs custo computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.4",
                            "name": "Estabilidade absoluta do método",
                            "description": "Analisar a estabilidade absoluta do método Adams-Bashforth usando o polinômio característico e região de estabilidade no plano complexo para equações teste y' = λy.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão do Método Adams-Bashforth Explícito",
                                  "subSteps": [
                                    "Estude a formulação geral do método Adams-Bashforth de ordem k: y_{n+1} = y_n + h ∑_{j=0}^k β_j f(t_{n-j}, y_{n-j}).",
                                    "Revise os coeficientes β_j para ordens comuns (ex: AB1, AB2, AB3).",
                                    "Entenda a natureza multistep e explícita do método.",
                                    "Compare com métodos de passo único como Runge-Kutta.",
                                    "Pratique interpolação de Newton backward para derivar coeficientes."
                                  ],
                                  "verification": "Derive corretamente a fórmula do AB2 e compute um passo manualmente para uma ODE simples.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Folha de papel e calculadora",
                                    "Software como Python com NumPy"
                                  ],
                                  "tips": "Comece com ordens baixas (k=1,2) para construir intuição antes de generalizar.",
                                  "learningObjective": "Compreender a estrutura e os coeficientes do método Adams-Bashforth.",
                                  "commonMistakes": [
                                    "Confundir coeficientes de Adams-Bashforth com Adams-Moulton.",
                                    "Esquecer que é explícito e depende apenas de valores passados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introdução à Estabilidade Absoluta e Equação Teste",
                                  "subSteps": [
                                    "Defina estabilidade absoluta: |R(z)| ≤ 1 para z = hλ no plano complexo, onde y' = λy.",
                                    "Analise a solução exata y(t) = y0 e^{λt} e sua discretização.",
                                    "Introduza o polinômio de amplificação R(z) = [ρ(z) - z σ(z)] / ρ(z).",
                                    "Discuta a região de estabilidade A = {z ∈ ℂ : |R(z)| ≤ 1}.",
                                    "Estude o semiplano esquerdo Re(z) < 0 para problemas rígidos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que significa estabilidade absoluta para o teste linear.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Notas de aula sobre estabilidade numérica",
                                    "Plano complexo impresso"
                                  ],
                                  "tips": "Visualize o plano z com eixos reais e imaginários para intuição geométrica.",
                                  "learningObjective": "Dominar os conceitos fundamentais de estabilidade absoluta via equação teste.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com estabilidade relativa ou A-estabilidade.",
                                    "Ignorar o papel do passo h na escala z = hλ."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construção do Polinômio Característico",
                                  "subSteps": [
                                    "Defina os polinômios ρ(ζ) = ∑_{j=0}^k α_j ζ^j (polinômio de característica, com α_k=1, α_0=-1 para consistência).",
                                    "Defina σ(ζ) = ∑_{j=0}^k β_j ζ^j (polinômio de diferença dividido).",
                                    "Para Adams-Bashforth, note que ρ(ζ) = ζ^k - ζ^{k-1} (método backward difference).",
                                    "Derive explicitamente ρ(z) e σ(z) para ABk substituindo ζ = 1 + z.",
                                    "Verifique o princípio da raiz única de Dahlquist."
                                  ],
                                  "verification": "Escreva ρ(z) e σ(z) corretamente para o método AB2.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Tabela de coeficientes Adams-Bashforth",
                                    "Software simbólico como SymPy"
                                  ],
                                  "tips": "Use a expansão binomial para σ(z) derivada da interpolação.",
                                  "learningObjective": "Construir os polinômios característicos específicos para Adams-Bashforth.",
                                  "commonMistakes": [
                                    "Erro nos sinais dos coeficientes β_j negativos para j>0.",
                                    "Confundir ρ com o numerador de R(z)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinação da Região de Estabilidade",
                                  "subSteps": [
                                    "Calcule R(z) = [ρ(z) - z σ(z)] / ρ(z) para ABk.",
                                    "Plote |R(z)| = 1 na fronteira da região de estabilidade usando software.",
                                    "Analise o comportamento assintótico para |z| grande.",
                                    "Compare regiões para diferentes ordens k (cresce com k mas ainda limitada).",
                                    "Verifique que está contida no semiplano esquerdo."
                                  ],
                                  "verification": "Gere um gráfico da região de estabilidade para AB3 e identifique pontos críticos.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "MATLAB ou Python (Matplotlib + NumPy)",
                                    "Código exemplo para plotar regiões de estabilidade"
                                  ],
                                  "tips": "Use contorno de nível |R(z)|=1 com malha no plano complexo.",
                                  "learningObjective": "Calcular e visualizar a região de estabilidade no plano complexo.",
                                  "commonMistakes": [
                                    "Escala errada no plano z (esquecer h em z=hλ).",
                                    "Interpretação errada de regiões que se estendem ao imaginário."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Análise e Interpretação da Estabilidade Absoluta",
                                  "subSteps": [
                                    "Avalie limitações: região finita implica passos h limitados por |λ|.",
                                    "Discuta implicações para problemas rígidos (Re(λ)<0 grande).",
                                    "Compare com métodos implícitos como Adams-Moulton (A-estáveis).",
                                    "Teste numericamente com y' = λy para λ com Re<0.",
                                    "Conclua sobre uso prático de AB em problemas não-rígidos."
                                  ],
                                  "verification": "Resuma em um parágrafo as vantagens e desvantagens da estabilidade de AB.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Exemplos numéricos resolvidos",
                                    "Artigo sobre estabilidade multistep"
                                  ],
                                  "tips": "Sempre relacione de volta à equação teste para validação.",
                                  "learningObjective": "Interpretar resultados de estabilidade em contextos práticos.",
                                  "commonMistakes": [
                                    "Superestimar estabilidade para altos modos imaginários.",
                                    "Ignorar divergência para z fora da região."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Adams-Bashforth de 4 passos (AB4), derive ρ(z) = (1 + z)^4 - 1, σ(z) derivado dos coeficientes β = [55/24, -59/24, 37/24, -9/24], compute R(z), e plote a região de estabilidade mostrando que permite passos moderados para λ real negativo mas falha para partes imaginárias grandes. Implemente em Python para y' = -50y + i*10y e observe estabilidade para diferentes h.",
                              "finalVerifications": [
                                "Deriva corretamente ρ(z) e σ(z) para AB2 e AB3.",
                                "Plota com precisão a região de estabilidade no plano complexo.",
                                "Identifica corretamente se um dado z=hλ está dentro da região.",
                                "Explica o impacto de ordens maiores na região.",
                                "Realiza simulação numérica estável/instável corretamente.",
                                "Compara com outros métodos multistep."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de polinômios (sem erros algébricos).",
                                "Qualidade e legibilidade dos gráficos de região de estabilidade.",
                                "Correta interpretação qualitativa e quantitativa da estabilidade.",
                                "Uso apropriado de software para visualização e testes.",
                                "Profundidade na discussão de limitações e comparações.",
                                "Clareza na comunicação de resultados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em equações diferenciais de osciladores e difusão.",
                                "Computação: Implementação de solvers ODE em bibliotecas como SciPy.",
                                "Engenharia: Simulações em controle de sistemas e dinâmica veicular.",
                                "Estatística: Modelos estocásticos com ruído (extensão para SDEs)."
                              ],
                              "realWorldApplication": "Em modelagem meteorológica e previsão numérica do tempo, onde métodos Adams-Bashforth são usados para integrar equações de movimento atmosférico não-rígidas, garantindo eficiência com passos de tempo maiores dentro da região de estabilidade, evitando instabilidades numéricas em simulações de longo prazo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Métodos Implícitos Adams-Moulton",
                        "description": "Métodos de passo múltiplo implícitos que incluem f(t_{n+1}, y_{n+1}) na aproximação da integral, requerendo solução iterativa.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Derivação da fórmula de Adams-Moulton",
                            "description": "Derivar as fórmulas de Adams-Moulton de ordem k (para k=1 a 3), usando interpolação sobre k+1 pontos incluindo o novo ponto, resultando em equação implícita para y_{n+1}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão de Interpolação Polinomial de Lagrange",
                                  "subSteps": [
                                    "Relembrar a fórmula geral de interpolação de Lagrange para m+1 pontos: P(t) = Σ y_i * l_i(t), onde l_i(t) são as funções base.",
                                    "Definir os pontos de interpolação para Adams-Moulton: t_{n+1}, t_n, ..., t_{n-k} com valores y_{n+1}, y_n, ..., y_{n-k} (y_{n+1} implícito).",
                                    "Escolher o parâmetro s = (t - t_n)/h para normalizar o intervalo [0,1].",
                                    "Derivar as funções l_j(s) para j=0 (ponto n+1, s=1), j=1 (s=0), ..., j=k+1 (s=1-j)."
                                  ],
                                  "verification": "Construir manualmente o polinômio interpolante P(s) para 3 pontos e verificar que P(s_i)=y_i nos pontos dados.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Papel e calculadora",
                                    "Referência: Burden & Faires 'Análise Numérica' capítulo de interpolação"
                                  ],
                                  "tips": "Mantenha h fixo e use s para simplificar cálculos; anote todas as l_j(s) explicitamente.",
                                  "learningObjective": "Dominar a interpolação de Lagrange adaptada ao contexto de métodos multilineares implícitos.",
                                  "commonMistakes": [
                                    "Confundir o índice j (0 para n+1 vs. 1 para n)",
                                    "Esquecer o fator y_{n+1} em l_0(s) que torna implícito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formulação da Aproximação da Derivada e Integração",
                                  "subSteps": [
                                    "Aproximar f(t,y(t)) ≈ P(s), onde P(s) é o interpolante incluindo y_{n+1} em s=1.",
                                    "Integrar a EDO y' = f(t,y) de t_n a t_{n+1}: y_{n+1} - y_n = ∫_{t_n}^{t_{n+1}} f(t,y(t)) dt ≈ h ∫_0^1 P(s) ds.",
                                    "Expandir a integral: h [ y_{n+1} β_0 + y_n β_1 + ... + y_{n-k} β_{k+1} ], onde β_j = ∫_0^1 l_j(s) ds.",
                                    "Isolar o termo implícito y_{n+1} β_0 f_{n+1} para obter a equação implícita."
                                  ],
                                  "verification": "Calcular os coeficientes β_j para k=1 e verificar que β_0 = 1/2, β_1=1/2 (trapezoidal).",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Folha de exercícios de integrais de Lagrange",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Compute integrais de l_j(s) analiticamente; para ordens baixas, faça à mão.",
                                  "learningObjective": "Entender como a interpolação leva à forma implícita da atualização y_{n+1}.",
                                  "commonMistakes": [
                                    "Integrar de 0 a 1 em vez de t_n a t_{n+1} (esqueça o h)",
                                    "Trocar β_0 e β_1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivação Explícita para Ordem k=1 (Adams-Moulton 1)",
                                  "subSteps": [
                                    "Definir pontos: (t_{n+1}, y_{n+1}), (t_n, y_n).",
                                    "Construir l_0(s) = (s-0)/(1-0) = s; l_1(s) = (1-s)/(0-1) = 1-s.",
                                    "Calcular β_0 = ∫_0^1 s ds = 1/2; β_1 = ∫_0^1 (1-s) ds = 1/2.",
                                    "Escrever y_{n+1} - y_n = (h/2) (f_{n+1} + f_n) e rearranjar para forma implícita."
                                  ],
                                  "verification": "Resolver a equação para y_{n+1} e confirmar identidade com método trapezoidal implícito.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Exemplo numérico simples: y'=y, h=0.1"
                                  ],
                                  "tips": "Teste com f conhecida para validar numericamente.",
                                  "learningObjective": "Derivar e reconhecer o método de Euler trapezoidal como AM(1).",
                                  "commonMistakes": [
                                    "Índices errados em f_{n+1} vs f_n",
                                    "Esquecer fator h na integral"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivação para Ordem k=2 (Adams-Moulton 2)",
                                  "subSteps": [
                                    "Pontos: t_{n+1}, t_n, t_{n-1}; s=1,0,-1.",
                                    "l_0(s)= [(s-0)(s+1)]/[(1-0)(1+1)] = s(s+1)/2; l_1(s)= [(s+1)(s-1)]/[(0+1)(0-1)] = -(s+1)(s-1)/1 = 1-s^2; l_2(s)= [(s-1)(s-0)]/[(-1-1)(-1-0)] = s(s-1)/2.",
                                    "β_0=∫ s(s+1)/2 ds = 5/12; β_1=∫ (1-s^2) ds = 8/12=2/3; β_2=∫ s(s-1)/2 ds = -1/12.",
                                    "Forma: y_{n+1}-y_n = h (5/12 f_{n+1} + 8/12 f_n -1/12 f_{n-1})."
                                  ],
                                  "verification": "Comparar com tabela padrão de coeficientes Adams-Moulton.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Tabela de coeficientes AM para verificação"
                                  ],
                                  "tips": "Use frações exatas; verifique soma ponderada para consistência.",
                                  "learningObjective": "Aplicar o processo para ordem 2 e memorizar coeficientes.",
                                  "commonMistakes": [
                                    "Erro em denominadores de l_j(s)",
                                    "Sinal errado em β_2"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Derivação para k=3 e Generalização",
                                  "subSteps": [
                                    "Para k=3: pontos t_{n+1} a t_{n-3}, s=1,0,-1,-2.",
                                    "Computar l_j(s) e β_j: resultados padrão 9/24, 19/24, 5/24, -1/24.",
                                    "Generalizar: coeficientes β_j^{(k)} = ∫_0^1 l_j^{(k)}(s) ds para ordem k.",
                                    "Discutir truncamento de erro O(h^{k+2}) devido a interpolação de grau k+1."
                                  ],
                                  "verification": "Listar coeficientes para k=1,2,3 e confirmar com literatura.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Artigo original Adams ou SciPy docs"
                                  ],
                                  "tips": "Use software para k>2 se cálculo manual for tedioso, mas entenda o processo.",
                                  "learningObjective": "Generalizar a derivação e entender precisão.",
                                  "commonMistakes": [
                                    "Pontos errados para k=3 (s=-2 correto)",
                                    "Ignorar termo de erro"
                                  ]
                                },
                                {
                                  "stepNumber": 6,
                                  "title": "Síntese e Verificação Geral",
                                  "subSteps": [
                                    "Resumir fórmulas para k=1,2,3 em tabela.",
                                    "Derivar via diferenças divididas de Newton como alternativa rápida.",
                                    "Verificar consistência (ordem 1) e precisão local.",
                                    "Discutir por que implícito: estabilidade para EDOs rígidos."
                                  ],
                                  "verification": "Derivar todas as três fórmulas sem consultar notas.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Tabela em branco para preencher"
                                  ],
                                  "tips": "Compare com Adams-Bashforth (explícito) para contrastar.",
                                  "learningObjective": "Consolidar derivações e aplicações.",
                                  "commonMistakes": [
                                    "Confundir Moulton (implícito, pontos backward) com Bashforth"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, h=0.2, k=1: y1 - y0 = (0.2/2)(f(y1) + f(y0)) → y1 + 0.1 y1 = 1 - 0.1 → y1 ≈ 0.8607 (iterar Newton se necessário). Compare com exata e^{ -0.2}≈0.8187.",
                              "finalVerifications": [
                                "Coeficientes corretos para k=1: 1/2, 1/2.",
                                "Para k=2: 5/12, 8/12, -1/12.",
                                "Para k=3: 9/24, 19/24, 5/24, -1/24.",
                                "Equação implícita isolada corretamente em todos casos.",
                                "Explicação clara do papel de y_{n+1} na interpolação.",
                                "Tabela de coeficientes compilada sem erros.",
                                "Compreensão verbal da generalização para ordem k."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes β_j (erro zero tolerado).",
                                "Passos lógicos na construção de l_j(s) e integrais.",
                                "Correta identificação do termo implícito y_{n+1}.",
                                "Análise de erro de truncamento mencionada (O(h^{k+2})).",
                                "Uso consistente de notação (índices n+1, n, etc.).",
                                "Exemplo numérico resolvido corretamente.",
                                "Generalização para ordem arbitrária descrita."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com scipy.integrate.odeint.",
                                "Física: Simulações de circuitos RLC rígidos.",
                                "Engenharia Química: Reatores com cinéticas stiff.",
                                "Estatística: Modelos estocásticos diferenciais.",
                                "Computação Científica: Pré-condicionadores em solvers implícitos."
                              ],
                              "realWorldApplication": "Métodos Adams-Moulton são implementados em solvers como MATLAB ode23s/ode15s para EDOs rígidos em modelagem climática, farmacocinética e simulações elétricas, onde estabilidade implícita previne oscilações em passos grandes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Resolução de sistemas implícitos",
                            "description": "Explicar e implementar métodos fix-point ou Newton-Raphson para resolver a equação implícita y_{n+1} = y_n + h ∑ β_j f(t_{n+1-j}, y_{n+1-j}) + γ f(t_{n+1}, y_{n+1}).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação implícita nos métodos Adams-Moulton",
                                  "subSteps": [
                                    "Analise a equação y_{n+1} = y_n + h ∑ β_j f(t_{n+1-j}, y_{n+1-j}) + γ f(t_{n+1}, y_{n+1}) e identifique o termo implícito envolvendo y_{n+1}.",
                                    "Reformule a equação como um sistema de ponto fixo: g(y_{n+1}) = y_n + h ∑ β_j f(t_{n+1-j}, y_{n+1-j}) + γ f(t_{n+1}, y_{n+1}).",
                                    "Estude as condições de convergência para métodos implícitos em EDOs de valor inicial.",
                                    "Revise os métodos explícitos Adams-Bashforth para contrastar com os implícitos.",
                                    "Derive manualmente a equação para um método específico, como Adams-Moulton de ordem 2."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando por que o método é implícito e liste as condições de Lipschitz para convergência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre métodos multistep",
                                    "Papel e caneta para derivações"
                                  ],
                                  "tips": "Comece com ordens baixas (k=1 ou 2) para visualizar a dependência em y_{n+1}.",
                                  "learningObjective": "Entender a origem e estrutura matemática da equação implícita nos métodos Adams-Moulton.",
                                  "commonMistakes": [
                                    "Confundir coeficientes β_j com os de métodos explícitos.",
                                    "Ignorar o termo γ f(t_{n+1}, y_{n+1}) como o principal causador da implicitidade.",
                                    "Não verificar consistência da ordem do método."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método do ponto fixo para resolução",
                                  "subSteps": [
                                    "Defina a função de ponto fixo g(y) = y_n + h ∑ β_j f(t_{n+1-j}, y_{n+1-j}) + γ f(t_{n+1}, y).",
                                    "Implemente iterações y^{(k+1)} = g(y^{(k)}) com chute inicial y^{(0)} = y_n.",
                                    "Estabeleça critério de parada: |y^{(k+1)} - y^{(k)}| < tol.",
                                    "Teste com uma EDO simples como y' = -y, y(0)=1, h=0.1.",
                                    "Registre o número de iterações necessárias para convergência."
                                  ],
                                  "verification": "Execute o código e confirme convergência em menos de 20 iterações para tol=1e-6.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python ou MATLAB com NumPy/SciPy",
                                    "Exemplos de EDOs de teste",
                                    "Editor de código (Jupyter Notebook)"
                                  ],
                                  "tips": "Use um tol adaptativo e monitore resíduos para evitar loops infinitos.",
                                  "learningObjective": "Implementar e aplicar o método do ponto fixo para resolver sistemas implícitos.",
                                  "commonMistakes": [
                                    "Chute inicial ruim levando a divergência.",
                                    "Não normalizar h para evitar overflow.",
                                    "Confundir ponto fixo com iteração simples sem critério de parada."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método de Newton-Raphson para resolução",
                                  "subSteps": [
                                    "Reformule como F(y_{n+1}) = y_{n+1} - [y_n + h ∑ β_j f(t_{n+1-j}, y_{n+1-j}) + γ f(t_{n+1}, y_{n+1})] = 0.",
                                    "Compute a Jacobiana J(y) = I - γ h ∂f/∂y (t_{n+1}, y).",
                                    "Implemente iterações y^{(k+1)} = y^{(k)} - J^{-1} F(y^{(k)}).",
                                    "Aplique ao mesmo exemplo do passo anterior e compare iterações.",
                                    "Generalize para sistemas de EDOs (vetores y)."
                                  ],
                                  "verification": "Compare soluções com método explícito e erro < 1e-5.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Biblioteca SciPy para solve linear",
                                    "Código do passo anterior para comparação",
                                    "Documentação de fsolve ou newton"
                                  ],
                                  "tips": "Para sistemas, use solvers vetoriais; aproxime Jacobiana numericamente se analítica complexa.",
                                  "learningObjective": "Dominar o método de Newton-Raphson para equações implícitas não-lineares em métodos multistep.",
                                  "commonMistakes": [
                                    "Erro na Jacobiana (esquecer o I).",
                                    "Não inverter corretamente para sistemas multi-dimensionais.",
                                    "Chute inicial idêntico ao ponto fixo, mascarando diferenças."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar convergência, comparar métodos e aplicar a exemplo prático",
                                  "subSteps": [
                                    "Compare número de iterações, tempo computacional e precisão entre ponto fixo e Newton.",
                                    "Analise condições de convergência: Lipschitz para ponto fixo, contratibilidade para Newton.",
                                    "Aplique a uma EDO real como o pêndulo não-linear y'' + sin(y)=0.",
                                    "Implemente loop completo para múltiplos passos n.",
                                    "Plote erro global vs. h para validar ordem do método."
                                  ],
                                  "verification": "Gere gráfico mostrando convergência quadrática de Newton vs. linear do ponto fixo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "EDOs de benchmark (ex: stiff equations)",
                                    "Códigos dos passos anteriores"
                                  ],
                                  "tips": "Use h pequeno inicialmente para testar; escale para problemas stiff.",
                                  "learningObjective": "Avaliar e selecionar método apropriado baseado em contexto computacional.",
                                  "commonMistakes": [
                                    "Não considerar custo da Jacobiana em Newton.",
                                    "Ignorar problemas stiff onde implícitos brilham.",
                                    "Comparar sem normalizar tolerâncias."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o sistema implícito para y' = y(1-y), y(0)=0.5, h=0.2, usando Adams-Moulton ordem 2 (β1=5/12, γ=8/12). Inicie com y0=0.5, compute y1 via ponto fixo (10 iterações) e Newton (3 iterações), verificando |y1 - y0 - h*(5/12 f(t0,y0) + 8/12 f(t1,y1))| < 1e-8.",
                              "finalVerifications": [
                                "Implemente ambos métodos em código funcional para EDO escalar e vetorial.",
                                "Demonstre convergência com plots de resíduos vs. iterações.",
                                "Compare erros com solução exata ou método de alta ordem.",
                                "Explique verbalmente quando usar ponto fixo vs. Newton.",
                                "Resolva um sistema stiff sem divergência.",
                                "Gere relatório com tabelas de iterações e tempos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução final (erro < 1e-6).",
                                "Eficiência computacional (iterações < 15 por passo).",
                                "Correta implementação da Jacobiana.",
                                "Análise qualitativa de convergência.",
                                "Generalização para sistemas multi-equação.",
                                "Clareza no código com comentários."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de solvers numéricos em Python/SciPy.",
                                "Física: Simulações de osciladores em mecânica.",
                                "Engenharia: Modelagem de circuitos RC stiff.",
                                "Computação Científica: Otimização de algoritmos iterativos.",
                                "Estatística: Integração em MCMC para EDOs estocásticas."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou farmacocinéticas, onde EDOs stiff surgem; métodos implícitos como Adams-Moulton resolvem estabilidade sem passos minúsculos, usados em software como MATLAB ODE suite ou FEniCS para PDEs."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Análise de precisão comparativa",
                            "description": "Comparar o erro de truncamento de Adams-Moulton (ordem k+1 efetiva) com Adams-Bashforth de mesma ordem, destacando maior precisão dos implícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fórmulas e Erros de Truncamento de Adams-Bashforth",
                                  "subSteps": [
                                    "Estude a fórmula geral do método Adams-Bashforth explícito de ordem k: y_{n+1} = y_n + h ∑_{j=1}^k β_j f(t_{n+1-j}, y_{n+1-j}).",
                                    "Derive ou memorize o erro de truncamento local: τ = O(h^{k+1}), com coeficiente principal envolvendo derivadas de ordem k+1 da solução exata.",
                                    "Calcule explicitamente os coeficientes β_j para ordens baixas (k=2,3) usando interpolação de Newton backward.",
                                    "Implemente um exemplo simples em código para visualizar o erro.",
                                    "Compare com o método de Euler para contextualizar a melhoria."
                                  ],
                                  "verification": "Derive corretamente o erro de truncamento para AB de ordem 2 e compute numericamente para um problema teste, com erro < 10^{-4}.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (Burden & Faires)",
                                    "Python/MATLAB com NumPy/SciPy",
                                    "Folha de derivadas de y' = f(t,y)"
                                  ],
                                  "tips": "Use tabelas de coeficientes padrão para AB para agilizar; foque na expansão em série de Taylor para o erro.",
                                  "learningObjective": "Compreender a estrutura e o erro local O(h^{k+1}) do método explícito Adams-Bashforth.",
                                  "commonMistakes": [
                                    "Confundir ordem do método com expoente do erro (ordem k implica erro h^{k+1})",
                                    "Esquecer o fator h no somatório",
                                    "Usar forward em vez de backward differences"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Fórmulas e Erros de Truncamento de Adams-Moulton",
                                  "subSteps": [
                                    "Estude a fórmula implícita Adams-Moulton de ordem k: y_{n+1} = y_n + h ∑_{j=0}^k γ_j f(t_{n+1-j}, y_{n+1-j}), note o termo j=0 no atual.",
                                    "Derive o erro de truncamento local: τ = O(h^{k+2}), destacando ordem efetiva k+1 devido à inclusão do ponto futuro.",
                                    "Calcule coeficientes γ_j para k=2,3 via interpolação backward.",
                                    "Discuta a necessidade de solver não-linear (ex: Newton) para implícitos.",
                                    "Implemente e compare erro inicial com AB."
                                  ],
                                  "verification": "Derive o erro O(h^{k+2}) para AM ordem 2 e mostre numericamente erro menor que AB equivalente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Mesmos do Step 1",
                                    "Função de solver implícito (fsolve em SciPy)",
                                    "Notas sobre método de Newton"
                                  ],
                                  "tips": "Comece com ordem baixa; use expansão Taylor centrada em t_{n+1} para evidenciar maior precisão.",
                                  "learningObjective": "Dominar a fórmula implícita e erro superior O(h^{k+2}) do Adams-Moulton.",
                                  "commonMistakes": [
                                    "Ignorar o termo implícito j=0 que eleva a ordem",
                                    "Tratar como explícito sem iteração",
                                    "Confundir γ_0 com β_1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Precisão: Coeficientes e Análise Teórica",
                                  "subSteps": [
                                    "Tabule coeficientes de erro principal para AB_k e AM_k (ex: para k=2, AB: -3/20 h^3 y''', AM: -9/200 h^4 y^{(4)}).",
                                    "Mostre |coef_AB| > |coef_AM| / h, provando precisão superior de AM para mesmo k.",
                                    "Analise asymptoticamente: erro AM ~ h^{k+2} vs AB ~ h^{k+1}.",
                                    "Discuta trade-offs: custo computacional maior em AM devido a iterações.",
                                    "Derive desigualdade quantitativa para precisão."
                                  ],
                                  "verification": "Crie tabela comparativa de coeficientes e prove teoricamente ordem superior de AM.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabelas padrão de coeficientes Adams (online ou livro)",
                                    "Papel para derivações Taylor",
                                    "Calculadora simbólica (SymPy)"
                                  ],
                                  "tips": "Normalize erros por h^{k+1} para destacar fator extra em AM; foque em derivadas pares/impares.",
                                  "learningObjective": "Comparar analiticamente erros, evidenciando maior precisão dos métodos implícitos.",
                                  "commonMistakes": [
                                    "Comparar ordens erradas (AM_k vs AB_{k+1})",
                                    "Ignorar sinal dos coeficientes",
                                    "Esquecer normalização por h"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação Numérica e Conclusões",
                                  "subSteps": [
                                    "Escolha problema teste: y' = -y, y(0)=1 (exata y=e^{-t}).",
                                    "Implemente AB_k e AM_k com passos h fixo, plote erros vs passos.",
                                    "Varie h e confirme slopes log-log: k+1 para AB, k+2 para AM.",
                                    "Meça custo (iterações Newton em AM) vs ganho de precisão.",
                                    "Escreva relatório resumindo superioridade de AM."
                                  ],
                                  "verification": "Gráficos mostram erro AM < AB para mesmo k, com slopes corretos em log-log.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python completo",
                                    "Matplotlib para plots",
                                    "Problema teste com solução exata"
                                  ],
                                  "tips": "Use h=0.1,0.05,...; monitore resíduos Newton <1e-8.",
                                  "learningObjective": "Validar teoricamente com experimentos numéricos a maior precisão de AM.",
                                  "commonMistakes": [
                                    "Escolha ruim de problema (não suave)",
                                    "Não log-log para ordens",
                                    "Ignorar acumulação de erro global"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente y' = y(1-y), y(0)=0.5 (modelo logístico) de t=0 a 10 com h=0.1. Compare AB_3 e AM_3: AM atinge erro global <1e-5 vs 5e-5 de AB, confirmando precisão superior apesar de ~2x mais FLOPs.",
                              "finalVerifications": [
                                "Deriva erro local para AB_k e AM_k corretamente.",
                                "Tabela de coeficientes de erro comparados.",
                                "Código numérico roda sem erros, com plots log-log mostrando slopes k+1 e k+2.",
                                "Explica verbalmente por que AM é mais preciso.",
                                "Identifica trade-off custo-precisão.",
                                "Aplica a um problema não-linear com sucesso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de erros (90% coeficientes corretos).",
                                "Qualidade dos plots numéricos (slopes exatos ±0.1).",
                                "Profundidade da comparação teórica (inclui coeficientes explícitos).",
                                "Correção do código (erro reproduzível <1e-6).",
                                "Clareza no relatório (destaca ordem efetiva k+1 de AM).",
                                "Análise de trade-offs computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de solvers numéricos em Python/SciPy.",
                                "Física: Simulações de EDOs em dinâmica (ex: osciladores).",
                                "Engenharia: Otimização em controle (predictor-corrector como AB-AM).",
                                "Estatística: Análise de erro em modelagem preditiva.",
                                "Computação Científica: Paralelismo em métodos implícitos."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou previsão financeira, Adams-Moulton permite h maiores com precisão similar a AB, reduzindo tempo de computação em supercomputadores para EDOs stiff em modelos diferenciais de grande escala."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Métodos Predictor-Corrector com Adams",
                        "description": "Combinação de Adams-Bashforth como preditor e Adams-Moulton como corretor para obter métodos explícitos de alta precisão sem perda de estabilidade relativa.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Formulação do predictor-corrector",
                            "description": "Descrever o algoritmo PECE (Predict-Evaluate-Correct-Evaluate) usando Adams-Bashforth-3 como preditor e Adams-Moulton-3 como corretor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e derivar a fórmula do preditor Adams-Bashforth de ordem 3",
                                  "subSteps": [
                                    "Estudar a interpolação de Lagrange para os pontos f_{n-2}, f_{n-1}, f_n.",
                                    "Calcular os coeficientes de integração para obter a fórmula explícita AB3.",
                                    "Escrever a fórmula final: y_{n+1}^p = y_n + (h/12)(23f_n - 16f_{n-1} + 5f_{n-2}).",
                                    "Verificar consistência de ordem truncamento O(h^4).",
                                    "Testar com valores numéricos simples."
                                  ],
                                  "verification": "Derivar corretamente os coeficientes 23/12, -16/12, 5/12 e aplicar em um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Caderno e calculadora",
                                    "Software Python/MATLAB para verificação"
                                  ],
                                  "tips": "Use tabela de coeficientes Adams para memorizar rapidamente.",
                                  "learningObjective": "Compreender a base polinomial do método explícito multistep.",
                                  "commonMistakes": "Confundir os índices dos pontos passados ou sinal dos coeficientes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a fórmula do corretor Adams-Moulton de ordem 3",
                                  "subSteps": [
                                    "Analisar interpolação incluindo o ponto futuro f_{n+1}: f_{n-1}, f_n, f_{n+1}.",
                                    "Integrar o polinômio de Lagrange para obter fórmula implícita AM3.",
                                    "Escrever: y_{n+1} = y_n + (h/12)(5f_{n+1} + 8f_n - f_{n-1}).",
                                    "Explicar por que é implícito (depende de f_{n+1}).",
                                    "Comparar ordem de precisão com AB3."
                                  ],
                                  "verification": "Reescrever a fórmula com coeficientes corretos e identificar dependência em y_{n+1}.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de derivadas de Lagrange",
                                    "Referência de métodos multistep",
                                    "Calculadora simbólica opcional"
                                  ],
                                  "tips": "Note que o coeficiente de f_{n+1} é maior, priorizando precisão local.",
                                  "learningObjective": "Dominar métodos implícitos e sua necessidade de predição.",
                                  "commonMistakes": "Esquecer que AM3 requer solução de equação não linear ou linearizada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o ciclo PECE: Predict-Evaluate-Correct-Evaluate",
                                  "subSteps": [
                                    "Passo Predict: Calcular y_{n+1}^p com AB3.",
                                    "Passo Evaluate1: Computar f_{n+1}^p = f(t_{n+1}, y_{n+1}^p).",
                                    "Passo Correct: Aplicar AM3 usando f_{n+1}^p para obter y_{n+1}^c.",
                                    "Passo Evaluate2: Computar f_{n+1}^c = f(t_{n+1}, y_{n+1}^c).",
                                    "Discutir convergência e uso de f_{n+1}^c em iterações opcionais."
                                  ],
                                  "verification": "Desenhar fluxograma do ciclo PECE e simular uma iteração manual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para fluxograma",
                                    "Exemplo numérico pronto",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Visualize como um loop: predição barata seguida de correção precisa.",
                                  "learningObjective": "Entender a sinergia preditor-corretor para estabilidade e precisão.",
                                  "commonMistakes": "Usar f_{n+1}^c no primeiro correct sem evaluate inicial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o algoritmo PECE completo e analisar",
                                  "subSteps": [
                                    "Escrever pseudocódigo integrando AB3 e AM3 no ciclo PECE.",
                                    "Definir condições iniciais: pontos de partida via Runge-Kutta.",
                                    "Implementar em código (Python/MATLAB) com tolerância para iterações.",
                                    "Analisar estabilidade e erro local/global.",
                                    "Testar com PVI não linear."
                                  ],
                                  "verification": "Executar código em exemplo e comparar com solução exata.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código (Jupyter Notebook)",
                                    "Biblioteca SciPy para solução exata",
                                    "PVI de teste"
                                  ],
                                  "tips": "Comece com problema linear para depuração fácil.",
                                  "learningObjective": "Aplicar PECE em contexto computacional real.",
                                  "commonMistakes": "Índices errados em vetores de histórico f ou y."
                                }
                              ],
                              "practicalExample": "Resolva o PVI y' = -2y + e^{-t}, y(0)=1 (solução exata y=t+e^{-t}), com h=0.2, de t=0 a t=0.4. Inicie com RK4 para y0,y1,y2. Compute y3 via PECE: Predict AB3 → f3^p → Correct AM3 → f3^c. Compare erros.",
                              "finalVerifications": [
                                "Derivar fórmulas AB3 e AM3 sem consulta.",
                                "Desenhar e explicar fluxograma PECE corretamente.",
                                "Implementar pseudocódigo funcional.",
                                "Identificar ordem de precisão O(h^4).",
                                "Aplicar em exemplo numérico com erro <1e-3.",
                                "Discutir quando iterar o corretor."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas derivadas (coeficientes exatos).",
                                "Clareza na descrição do ciclo PECE.",
                                "Correção do pseudocódigo ou implementação.",
                                "Análise de estabilidade e truncamento.",
                                "Capacidade de aplicar em exemplo prático.",
                                "Identificação de limitações (ex: rigidez)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação em Python/Octave.",
                                "Física: Simulação de EDOs em dinâmica de partículas.",
                                "Engenharia: Modelagem de circuitos RLC.",
                                "Estatística: Previsão em séries temporais."
                              ],
                              "realWorldApplication": "Solvers de EDOs em softwares como MATLAB (ode15s), simulações meteorológicas, modelagem populacional em biologia e controle de processos industriais, onde estabilidade em passos grandes é crucial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Implementação do esquema PECE",
                            "description": "Implementar o esquema predictor-corrector completo em código, incluindo critérios de parada para iterações do corretor e controle de passo adaptativo básico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração inicial do problema e estruturas de dados",
                                  "subSteps": [
                                    "Defina a equação diferencial y' = f(t, y) e condições iniciais y(t0) = y0.",
                                    "Escolha os coeficientes para Adams-Bashforth e Adams-Moulton de ordem específica (ex: ordem 4).",
                                    "Crie arrays para armazenar valores de t, y e f(t,y) históricos.",
                                    "Implemente função para calcular f(t,y) e método de Runge-Kutta inicial para startup.",
                                    "Defina parâmetros: h inicial, tolerância para critério de parada, máximo de iterações no corretor."
                                  ],
                                  "verification": "Verifique se os arrays estão inicializados corretamente e o startup com RK4 produz valores iniciais precisos comparados à solução exata.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Linguagem de programação (Python/MATLAB)",
                                    "Documentação de coeficientes Adams",
                                    "Solução exata do problema teste (opcional)"
                                  ],
                                  "tips": "Use listas ou vetores dinâmicos para facilitar expansão; teste o startup isoladamente.",
                                  "learningObjective": "Entender e preparar as bases de dados para métodos multistep.",
                                  "commonMistakes": [
                                    "Índices errados nos arrays históricos",
                                    "Esquecimento do startup com método single-step",
                                    "Coeficientes trocados entre predictor e corrector"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementação do Predictor (Adams-Bashforth)",
                                  "subSteps": [
                                    "Calcule o polinômio interpolador backward usando valores históricos de f.",
                                    "Aplique a fórmula de Adams-Bashforth: y_{n+1}^p = y_n + h * soma(coef_AB * f_{n-k}).",
                                    "Atualize o array de t com t_{n+1} = t_n + h.",
                                    "Calcule f(t_{n+1}, y_{n+1}^p) para uso posterior.",
                                    "Teste o predictor isoladamente em poucos passos."
                                  ],
                                  "verification": "Compare y^p com solução exata ou RK4 em passos iniciais; erro deve ser consistente com ordem do método.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de coeficientes Adams-Bashforth",
                                    "Código do startup do step 1"
                                  ],
                                  "tips": "Implemente como função separada para reutilização; use laços for eficientes.",
                                  "learningObjective": "Dominar a extrapolação explícita para previsão inicial.",
                                  "commonMistakes": [
                                    "Sinal errado nos coeficientes",
                                    "Não atualizar corretamente o histórico",
                                    "Uso de h variável prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação do Corrector (Adams-Moulton)",
                                  "subSteps": [
                                    "Use y^p para iniciar: calcule polinômio interpolador incluindo f(t_{n+1}, y^p).",
                                    "Aplique fórmula Adams-Moulton: y_{n+1}^c = y_n + h * (coef0 * f_{n+1} + soma(coef_AM * f_{n-k})).",
                                    "Atualize y_{n+1} e f(t_{n+1}, y_{n+1}^c).",
                                    "Repita iterações até |y^{c,new} - y^{c,old}| < tol.",
                                    "Limite iterações a máximo (ex: 5) para evitar loops infinitos."
                                  ],
                                  "verification": "O corrector deve refinar y^p com erro reduzido; verifique convergência em 2-3 iterações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de coeficientes Adams-Moulton",
                                    "Código predictor do step 2"
                                  ],
                                  "tips": "Use um loop while com contador; relaxe a tolerância inicialmente para testes.",
                                  "learningObjective": "Implementar interpolação implícita de forma iterativa.",
                                  "commonMistakes": [
                                    "Confundir ordem dos coeficientes (beta0 para f_{n+1})",
                                    "Não reiniciar iterações corretamente",
                                    "Tolerância muito rigorosa causando não-convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração do ciclo PECE com critérios de parada",
                                  "subSteps": [
                                    "Estruture o loop principal: Predict -> Evaluate f^p -> Correct -> Evaluate f^c.",
                                    "Repita PECE até critério local: |y^c - y^p| < tol * max(1, |y|).",
                                    "Aceite y_{n+1} = y^c se convergir; senão, use y^p ou pare com erro.",
                                    "Atualize históricos removendo valores antigos (janela deslizante).",
                                    "Implemente parada global: t_final ou máximo passos."
                                  ],
                                  "verification": "Execute até t_final; plote solução e compare com exata (erro global O(h^4)).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Códigos dos steps anteriores",
                                    "Ferramenta de plotagem (matplotlib)"
                                  ],
                                  "tips": "Logue número de iterações por passo para debug; use PECE completo (2 avaliações).",
                                  "learningObjective": "Combinar predictor e corrector em esquema estável e eficiente.",
                                  "commonMistakes": [
                                    "Não limpar histórico antigo causando acúmulo de erros",
                                    "Critério de parada muito frouxo",
                                    "Esquecimento de Evaluate steps"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Adição de controle de passo adaptativo básico e testes finais",
                                  "subSteps": [
                                    "Calcule erro local estimado: |y^c - y^p|.",
                                    "Ajuste h_new = h * (tol / erro)^{1/(p+1)}, onde p=ordem.",
                                    "Aceite passo se erro < tol; rejeite e repita com h menor se > tol * fator segurança.",
                                    "Implemente limites: h_min, h_max; mude direção se rejeitar.",
                                    "Teste com problema não-linear e valide estabilidade."
                                  ],
                                  "verification": "Solução deve manter erro global abaixo de 1e-3; h adapta-se automaticamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código PECE completo",
                                    "Problemas teste com soluções conhecidas"
                                  ],
                                  "tips": "Fator de segurança 0.9; teste rejeições forçando h grande inicial.",
                                  "learningObjective": "Tornar o método robusto com adaptação automática de passo.",
                                  "commonMistakes": [
                                    "Exponte errada no ajuste de h",
                                    "Não rejeitar passos ruins",
                                    "Oscilação infinita de h"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o esquema PECE ordem 4 para y' = -2y + exp(-t), y(0)=1, em [0,5], h=0.2 inicial, tol=1e-4. Compare com solução exata y(t) = (t+1)*exp(-t). Verifique convergência e adaptação de h em regiões rígidas.",
                              "finalVerifications": [
                                "O código executa sem erros até t_final.",
                                "Número de avaliações de f é aproximadamente 2 por passo (PECE).",
                                "Erro global máximo < 1e-3 comparado à solução exata.",
                                "Critério de parada no corretor ativa em <5 iterações na maioria dos passos.",
                                "Controle de h adapta: diminui em erros altos, aumenta em erros baixos.",
                                "Histórico mantém tamanho correto (ordem+1 pontos)."
                              ],
                              "assessmentCriteria": [
                                "Correção dos coeficientes Adams (verificação numérica).",
                                "Eficiência do ciclo PECE (contagem de f-evals).",
                                "Robustez do critério de parada e convergência.",
                                "Funcionalidade do passo adaptativo (logs de h).",
                                "Qualidade do código: modularidade, comentários, testes.",
                                "Precisão final vs. solução referência."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação numérica eficiente.",
                                "Física: Simulações de sistemas dinâmicos (ex: osciladores).",
                                "Engenharia: Modelagem de circuitos RLC ou fluidos.",
                                "Estatística: Integração em métodos Monte Carlo."
                              ],
                              "realWorldApplication": "Simulações em engenharia aeroespacial para trajetórias de voo, previsão meteorológica com modelos diferenciais, ou farmacocinética em medicina para modelar concentração de drogas no sangue."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Vantagens e limitações práticas",
                            "description": "Discutir vantagens em precisão e custo computacional versus métodos de Runge-Kutta, e limitações para problemas stiff, referenciando bibliografia como LeVeque.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos dos Métodos Runge-Kutta e Adams Predictor-Corrector",
                                  "subSteps": [
                                    "Relembrar a formulação geral dos métodos de Runge-Kutta (RK4 como exemplo padrão).",
                                    "Descrever o esquema predictor-corrector usando polinômios de Adams (ex: Adams-Bashforth predictor e Moulton corrector).",
                                    "Identificar diferenças chave: RK explícito one-step vs. multistep de Adams.",
                                    "Implementar um exemplo simples em Python para cada método usando SciPy ou código manual.",
                                    "Comparar visualmente soluções para uma ODE linear simples como y' = -y."
                                  ],
                                  "verification": "Implementações rodam sem erros e produzem gráficos comparativos idênticos para ODE teste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook Jupyter, bibliotecas NumPy/SciPy/Matplotlib, livro LeVeque 'Finite Difference Methods for ODEs' (cap. 10-11).",
                                  "tips": "Use funções prontas do SciPy (odeint/solve_ivp) para baseline antes de código customizado.",
                                  "learningObjective": "Compreender as bases algébricas para comparação posterior de precisão e custo.",
                                  "commonMistakes": "Confundir multistep com one-step; ignorar requisitos de valores iniciais múltiplos em Adams."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vantagens em Precisão",
                                  "subSteps": [
                                    "Calcular ordens de precisão: RK4 (ordem 4) vs. Adams de ordem variável (até 5-6).",
                                    "Executar testes de convergência com h reduzido em ODEs suaves (ex: y' = y(1-y)).",
                                    "Medir erros globais locais (GLE) e plotar log(error) vs. log(h).",
                                    "Discutir como Adams explora história para maior precisão em problemas não-stiff.",
                                    "Referenciar LeVeque (seção 11.3) sobre truncagem de erro em multistep."
                                  ],
                                  "verification": "Gráficos de convergência mostram inclinação correta da ordem e Adams superior em precisão para h fixo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python do step 1, planilhas para log-log plots, PDF de LeVeque.",
                                  "tips": "Fixe passos totais iguais para comparação justa; use richardson extrapolation para validar ordem.",
                                  "learningObjective": "Quantificar superioridade de precisão dos métodos Adams em cenários ideais.",
                                  "commonMistakes": "Comparar com h diferentes; não normalizar erros absolutos/relativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Custo Computacional",
                                  "subSteps": [
                                    "Contar operações por passo: RK4 (~4N f-evals) vs. Adams (~1 f-eval por passo após startup).",
                                    "Medir tempo de CPU para simulações longas (ex: t de 0 a 100 com 10000 passos).",
                                    "Analisar custo de startup em Adams (primeiros passos com RK).",
                                    "Plotar tempo total vs. precisão alvo, referenciando benchmarks de LeVeque.",
                                    "Discutir eficiência em problemas com muitas ODEs (sistemas grandes)."
                                  ],
                                  "verification": "Tabelas mostram Adams 2-4x mais rápido para mesma precisão em não-stiff.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código otimizado (%timeit no Jupyter), profiler como cProfile.",
                                  "tips": "Rode múltiplas trials para média; evite overhead de plotting em benchmarks.",
                                  "learningObjective": "Demonstrar redução de custo computacional como principal vantagem prática.",
                                  "commonMistakes": "Incluir startup em todos passos; ignorar vetorização em sistemas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Limitações para Problemas Stiff e Referenciar Bibliografia",
                                  "subSteps": [
                                    "Definir problemas stiff (eigenvalues com escalas díspares, ex: y' = -1000y + sin(t)).",
                                    "Testar instabilidade em Adams explícito vs. RK implícito ou BDF.",
                                    "Explicar por que predictor-corrector falha (damping insuficiente).",
                                    "Citar LeVeque (cap. 11.5 e 12) sobre A-stability e métodos L-stable.",
                                    "Resumir quando usar: não-stiff longos vs. RK para stiff/general."
                                  ],
                                  "verification": "Simulação stiff diverge em Adams mas converge em RK implícito; resumo escrito com citações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplos stiff do SciPy, anotações de LeVeque, artigo sobre stiff ODEs.",
                                  "tips": "Use solve_ivp com method='Radau' para stiff baseline.",
                                  "learningObjective": "Reconhecer cenários de falha e critérios de escolha de método.",
                                  "commonMistakes": "Testar apenas não-stiff; confundir stiff com oscilatório."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Discussão com Exemplos e Conclusões",
                                  "subSteps": [
                                    "Criar tabela comparativa: precisão, custo, estabilidade.",
                                    "Discutir trade-offs em aplicações reais (ex: simulações climáticas).",
                                    "Preparar argumentos verbais/orais baseados em dados.",
                                    "Referenciar extensões como Nordsieck para eficiência.",
                                    "Autoavaliar compreensão com perguntas de verificação."
                                  ],
                                  "verification": "Tabela completa e resposta coerente a 'Quando preferir Adams?'",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela Markdown/Excel, gravação de discussão simulada.",
                                  "tips": "Use LaTeX para tabela profissional se apresentando.",
                                  "learningObjective": "Integrar análise em discussão prática e fundamentada.",
                                  "commonMistakes": "Generalizar vantagens sem dados; omitir referências."
                                }
                              ],
                              "practicalExample": "Simule o decaimento radioativo estendido y' = -λy + source(t) com λ=50 (quase-stiff) de t=0 a 10. Use Adams PC ordem 4 vs RK45: meça tempo para erro <1e-4 e observe divergência em Adams para h>0.01.",
                              "finalVerifications": [
                                "Lista 3 vantagens de precisão e 2 de custo com evidências numéricas.",
                                "Explica limitação stiff com exemplo que diverge.",
                                "Cita LeVeque corretamente em pelo menos 2 pontos.",
                                "Compara corretamente operações f-evals por passo.",
                                "Identifica 2 cenários reais onde Adams é preferível.",
                                "Tabela de comparação está completa e precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: uso correto de conceitos e fórmulas (30%).",
                                "Evidências quantitativas: gráficos/benchmarks válidos (25%).",
                                "Profundidade análise: trade-offs discutidos (20%).",
                                "Referenciação: citações adequadas de LeVeque (15%).",
                                "Clareza comunicação: tabelas/explicações concisas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Otimização de algoritmos numéricos em Python/C++.",
                                "Física: Modelagem de dinâmica em sistemas diferenciais (ex: circuitos RLC).",
                                "Engenharia: Simulações em controle de processos industriais.",
                                "Estatística: Análise de erro em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas de longo prazo (dias), Adams PC reduz tempo de computação em supercomputadores, permitindo previsões mais frequentes sem perda de precisão em atmosferas não-stiff, como referenciado em modelos do NOAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Análise de Consistência e Ordem",
                    "description": "Condições de consistência zero e ordem p dos métodos multistep.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Consistência Zero dos Métodos Multistep",
                        "description": "Condições necessárias para que um método linear multistep seja zero-consistente, garantindo que o método de aproximação convirja para a solução exata quando o passo h tende a zero, independentemente da ordem.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Definir consistência zero",
                            "description": "Explicar a definição formal de consistência zero para métodos lineares multistep da forma ∑_{k=0}^m α_k y_{n+k} - h ∑_{k=0}^m β_k f_{n+k} = 0, destacando a condição ∑_{k=0}^m α_k = 0 e sua relação com o operador de diferença finita ρ(ζ) = ∑ α_k ζ^k tendo ζ=1 como raiz simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral dos métodos lineares multistep",
                                  "subSteps": [
                                    "Estude a equação geral: ∑_{k=0}^m α_k y_{n+k} - h ∑_{k=0}^m β_k f_{n+k} = 0",
                                    "Identifique os coeficientes α_k e β_k como constantes fixas para o método",
                                    "Reconheça que y_n aproxima y(t_n) e f_{n+k} = f(t_{n+k}, y_{n+k})",
                                    "Anote exemplos simples como o método de Euler implícito (m=1, α_0=-1, α_1=1, β_1=1)",
                                    "Discuta o papel de h como tamanho do passo"
                                  ],
                                  "verification": "Escreva a forma geral de um método multistep linear específico e identifique todos os componentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Livro de Análise Numérica (capítulo de métodos multistep)",
                                    "Calculadora para anotar coeficientes"
                                  ],
                                  "tips": "Comece com métodos de passo único (m=1) para familiarizar antes de multistep.",
                                  "learningObjective": "Dominar a notação e estrutura fundamental dos métodos lineares multistep.",
                                  "commonMistakes": [
                                    "Confundir y_{n+k} com f_{n+k}",
                                    "Esquecer o fator h no segundo termo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o operador de diferença finita ρ(ζ)",
                                  "subSteps": [
                                    "Defina ρ(ζ) = ∑_{k=0}^m α_k ζ^k como o polinômio de diferença finita",
                                    "Explique que ρ(ζ) modela a combinação linear das aproximações y_{n+k}",
                                    "Calcule ρ(1) = ∑_{k=0}^m α_k * 1^k = ∑_{k=0}^m α_k",
                                    "Verifique com exemplo: Para Euler implícito, ρ(ζ) = ζ - 1, então ρ(1)=0",
                                    "Discuta como ρ(ζ) surge da análise de truncamento local",
                                    "Derive brevemente ρ(ζ) assumindo y suave e expandindo em série de Taylor"
                                  ],
                                  "verification": "Compute ρ(ζ) para um método dado e avalie ρ(1).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software simbólico como SymPy ou Mathematica (opcional)",
                                    "Notas do Step 1"
                                  ],
                                  "tips": "Use ζ como variável polinomial para visualizar como um polinômio padrão.",
                                  "learningObjective": "Associar os coeficientes α_k ao polinômio ρ(ζ) e computá-lo corretamente.",
                                  "commonMistakes": [
                                    "Índices errados no somatório de ρ(ζ)",
                                    "Confundir ρ com o polinômio σ(ζ) dos β_k"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a condição de consistência zero: ∑ α_k = 0",
                                  "subSteps": [
                                    "Estabeleça que consistência zero requer ∑_{k=0}^m α_k = 0",
                                    "Mostre que isso equivale a ρ(1) = 0",
                                    "Explique intuitivamente: Preserva a solução constante y' = 0, y=constante",
                                    "Teste com contraexemplo: Método inconsistente como y_{n+1} = y_n (α_0=-1, α_1=1? Não, soma=0)",
                                    "Para Euler implícito: α_0=-1, α_1=1, soma=0, consistente",
                                    "Discuta implicações para estabilidade e convergência"
                                  ],
                                  "verification": "Verifique se um método dado satisfaz ∑ α_k = 0 e justifique.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de métodos multistep de um livro-texto",
                                    "Tabela para listar coeficientes"
                                  ],
                                  "tips": "Pense em soluções constantes: o método deve manter y_n = c para todo n.",
                                  "learningObjective": "Reconhecer ρ(1)=0 como condição essencial para consistência zero.",
                                  "commonMistakes": [
                                    "Achar que soma α_k =1 em vez de 0",
                                    "Ignorar normalização dos coeficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a raiz simples de ρ(ζ) em ζ=1",
                                  "subSteps": [
                                    "Defina raiz simples: ρ(1)=0 e ρ'(1) ≠ 0 (tipicamente ρ'(1)=1 por normalização)",
                                    "Compute ρ'(ζ) = ∑_{k=1}^m k α_k ζ^{k-1}, então ρ'(1) = ∑ k α_k",
                                    "Explique que raiz simples garante ordem pelo menos 1 na análise de erro local",
                                    "Exemplo: Euler implícito ρ(ζ)=ζ-1, ρ'(ζ)=1, ρ'(1)=1 (raiz simples)",
                                    "Discuta métodos sem raiz simples: ordem zero ou inconsistentes",
                                    "Conclua ligando à ordem p: condições adicionais em derivadas de ρ e σ"
                                  ],
                                  "verification": "Para um método, compute ρ(1) e ρ'(1), confirmando raiz simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software para derivadas",
                                    "Gráfico de ρ(ζ) (plotar manualmente)"
                                  ],
                                  "tips": "Normalmente métodos são escalados para ρ'(1)=1; verifique isso.",
                                  "learningObjective": "Entender o papel da multiplicidade da raiz em ζ=1 para consistência.",
                                  "commonMistakes": [
                                    "Confundir ρ'(1)=0 com raiz simples",
                                    "Erro no cálculo da derivada"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o método trapezoidal: α_0 = -1, α_1 = 1, β_0 = 1/2, β_1 = 1/2. Compute ρ(ζ) = ζ - 1, ρ(1) = 0, ρ'(ζ) = 1, ρ'(1) = 1. Isso satisfaz consistência zero com raiz simples em ζ=1, garantindo que soluções constantes sejam preservadas exatamente.",
                              "finalVerifications": [
                                "Escreva a definição formal de consistência zero usando ρ(ζ).",
                                "Verifique ∑ α_k = 0 para três métodos multistep conhecidos.",
                                "Explique por que ρ(1)=0 é necessário para soluções constantes.",
                                "Compute ρ'(1) para um método e confirme raiz simples.",
                                "Diferencie consistência zero de ordem 1.",
                                "Identifique um método sem consistência zero."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escrita da forma geral do método multistep (100% dos termos corretos).",
                                "Correta definição e cálculo de ρ(ζ) e ρ(1).",
                                "Explicação clara da condição ∑ α_k = 0 e sua equivalência a ρ(1)=0.",
                                "Compreensão da raiz simples via ρ'(1)=1 com exemplo numérico.",
                                "Uso correto de notação matemática sem erros tipográficos.",
                                "Conexão lógica entre operador de diferença e consistência."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aplicação em simulações de EDOs para dinâmica de partículas.",
                                "Programação: Implementação de verificações de consistência em código Python/MATLAB.",
                                "Álgebra Linear: Relação com autovalores na análise de estabilidade.",
                                "Cálculo: Expansões de Taylor subjacentes à derivação de ρ(ζ)."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais em engenharia aeroespacial (ex: trajetórias de foguetes) e finanças (modelos de Black-Scholes), métodos multistep consistentes de ordem zero garantem precisão em soluções estacionárias e evitam erros de deriva acumulada em integrações de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Verificar consistência zero em um método dado",
                            "description": "Dado um método multistep específico, como o método de Adams-Bashforth de ordem 2, calcular os coeficientes α_k e β_k e verificar se satisfaz a condição de consistência zero através da soma dos α_k e da análise do polinômio ρ(ζ).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o método multistep e extrair os coeficientes α_k e β_k",
                                  "subSteps": [
                                    "Leia a definição do método multistep fornecido, como y_{n+1} - y_n = h (3/2 f_n - 1/2 f_{n-1}) para Adams-Bashforth ordem 2.",
                                    "Padronize a forma geral: ∑_{j=0}^k α_j y_{n+j} - h ∑_{j=0}^k β_j f_{n+j} = 0.",
                                    "Atribua os índices corretamente: para AB2, α_2 = 1, α_1 = -1, α_0 = 0; β_2 = 0, β_1 = 3/2, β_0 = -1/2.",
                                    "Liste todos os coeficientes em uma tabela ou lista numerada para clareza.",
                                    "Confirme que o método é multistep com k+1 passos."
                                  ],
                                  "verification": "Coeficientes α_k e β_k listados corretamente sem erros de sinal ou índice.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, livro-texto de análise numérica ou notas de aula, calculadora básica.",
                                  "tips": "Sempre verifique os índices relativos a n; desenhe uma linha do tempo dos passos n-1, n, n+1 para visualizar.",
                                  "learningObjective": "Compreender a representação padrão de métodos multistep e extrair coeficientes com precisão.",
                                  "commonMistakes": "Confundir índices (ex: α_0 vs α_2), inverter sinais nos β_k, ignorar termos zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a soma dos coeficientes α_k",
                                  "subSteps": [
                                    "Some todos os α_k: ∑_{k=0}^m α_k.",
                                    "Para AB2: 0 + (-1) + 1 = 0.",
                                    "Registre o resultado exato como fração ou decimal.",
                                    "Compare com o valor esperado para consistência zero: deve ser igual a 0.",
                                    "Se não for zero, anote que o método não satisfaz consistência zero."
                                  ],
                                  "verification": "Cálculo aritmético correto e comparação explícita com zero.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora, folha de rascunho com coeficientes listados.",
                                  "tips": "Use parênteses para agrupar termos e evite erros de sinal; verifique somando duas vezes.",
                                  "learningObjective": "Aplicar aritmética básica para testar a primeira condição de consistência zero.",
                                  "commonMistakes": "Erros de sinal ao somar (ex: esquecer negativo), somar β_k em vez de α_k."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o polinômio característico ρ(ζ)",
                                  "subSteps": [
                                    "Defina ρ(ζ) = ∑_{k=0}^m α_k ζ^k.",
                                    "Para AB2: ρ(ζ) = α_0 + α_1 ζ + α_2 ζ^2 = 0 - ζ + ζ^2 = ζ^2 - ζ.",
                                    "Expanda e simplifique o polinômio, fatorando se possível (ex: ζ(ζ - 1)).",
                                    "Verifique o grau do polinômio (deve ser igual ao número de passos).",
                                    "Avalie ρ(1) = ∑ α_k para confirmar consistência zero (ρ(1) = 0)."
                                  ],
                                  "verification": "Polinômio ρ(ζ) escrito corretamente e ρ(1) = 0 calculado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para expansão polinomial, calculadora simbólica se disponível (ex: app ou software).",
                                  "tips": "Escreva ζ^k explicitamente para cada termo; teste substituindo ζ=1 para validar soma.",
                                  "learningObjective": "Formar e manipular o polinômio ρ(ζ) associado aos coeficientes α_k.",
                                  "commonMistakes": "Índices errados em ζ^k, coeficientes trocados, não simplificar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar ρ(ζ) para confirmar consistência zero",
                                  "subSteps": [
                                    "Confirme ρ(1) = 0 como condição primária de consistência zero.",
                                    "Para métodos consistentes de ordem zero, verifique se ρ(ζ) tem raiz em ζ=1 (fator (ζ-1)).",
                                    "Calcule a derivada ρ'(ζ) se necessário e avalie ρ'(1) = 1 para ordem 1, mas foque em zero.",
                                    "Interprete: se condições atendidas, método tem consistência zero.",
                                    "Documente conclusão: 'Método satisfaz consistência zero' ou não."
                                  ],
                                  "verification": "Análise completa com ρ(1)=0 e interpretação escrita.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha com ρ(ζ), regras de derivação, exemplos de livros.",
                                  "tips": "Lembre que consistência zero é pré-requisito para ordens superiores; use fatoração para insight.",
                                  "learningObjective": "Interpretar propriedades de ρ(ζ) para validar consistência zero em métodos multistep.",
                                  "commonMistakes": "Confundir ρ(1)=0 com σ(1)=1, ignorar fatorização, pular avaliação em ζ=1."
                                }
                              ],
                              "practicalExample": "Para o método de Adams-Bashforth de ordem 2: α_0=0, α_1=-1, α_2=1. Soma α_k=0. ρ(ζ)=ζ^2 - ζ. ρ(1)=1-1=0. Conclusão: satisfaz consistência zero.",
                              "finalVerifications": [
                                "Soma dos α_k exatamente igual a 0.",
                                "Polinômio ρ(ζ) construído corretamente com todos os termos.",
                                "ρ(1) avaliado e confirmado como 0.",
                                "Coeficientes extraídos sem erros de índice ou sinal.",
                                "Conclusão escrita sobre satisfação da consistência zero.",
                                "Fatorização ou simplificação de ρ(ζ) realizada quando aplicável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e listagem de α_k e β_k (100% correto).",
                                "Cálculo aritmético impecável na soma e em ρ(1).",
                                "Construção simbólica correta de ρ(ζ).",
                                "Análise interpretativa clara e lógica.",
                                "Documentação completa com passos e conclusões.",
                                "Tempo de execução dentro do estimado total (60 minutos)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra: manipulação de polinômios e avaliação em pontos.",
                                "Programação: implementar verificação numérica de coeficientes em Python ou MATLAB.",
                                "Física: aplicação em simulações de EDOs para movimento ou circuitos.",
                                "Estatística: análise de estabilidade em métodos numéricos para Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais em engenharia (ex: previsão de trajetórias de foguetes) ou meteorologia, verificar consistência zero garante que o método multistep não introduza erros sistemáticos de ordem zero ao aproximar soluções exatas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Relacionar consistência zero com convergência",
                            "description": "Demonstrar teoricamente por que a consistência zero é uma condição necessária (mas não suficiente) para a convergência global do método multistep, citando o teorema de consistência e estabilidade de Dahlby.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição de consistência zero para métodos multistep",
                                  "subSteps": [
                                    "Lembre-se da forma geral do método multistep linear: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}).",
                                    "Defina consistência zero: o método satisfaz a condição ∑_{j=0}^k α_j = 0 quando h=0 para soluções constantes.",
                                    "Verifique com o polinômio de característica ρ(ζ) = ∑ α_j ζ^j, onde ρ(1)=0.",
                                    "Calcule para métodos simples como Euler backward (α_0=-1, α_1=1 → ρ(1)=0).",
                                    "Discuta implicações: métodos sem consistência zero não reproduzem constantes exatamente."
                                  ],
                                  "verification": "Escreva a definição e verifique ρ(1)=0 para um método multistep dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notas de aula sobre multistep.",
                                  "tips": "Sempre normalize os coeficientes para facilitar cálculos.",
                                  "learningObjective": "Compreender matematicamente o que é consistência zero.",
                                  "commonMistakes": "Confundir com ordem de consistência superior; ignorar normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o conceito de convergência global em métodos multistep",
                                  "subSteps": [
                                    "Defina convergência global: lim_{h→0} ||y_n - y(t_n)|| → 0 para qualquer n, uniformemente.",
                                    "Relacione com erro local de truncamento e estabilidade.",
                                    "Discuta norma global e dependência em h.",
                                    "Exemplo: método explícito Euler converge globalmente para problemas adequados.",
                                    "Note que convergência requer controle de erros acumulados."
                                  ],
                                  "verification": "Explique em palavras próprias e dê um exemplo numérico simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de papel para esboços, software como MATLAB para simular convergência.",
                                  "tips": "Visualize graficamente erro vs. h para intuitar.",
                                  "learningObjective": "Dominar a definição precisa de convergência global.",
                                  "commonMistakes": "Confundir convergência local com global; ignorar dependência em n."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o teorema de consistência e estabilidade de Dahlquist",
                                  "subSteps": [
                                    "Enuncie o teorema: Um método multistep convergência globalmente se e só se é consistente e estável (zero-estável).",
                                    "Analise a prova esquemática: consistência controla erro local, estabilidade controla propagação.",
                                    "Foco na parte de consistência: sem ela, erro local não →0 com h→0.",
                                    "Verifique estabilidade zero: raiz principal do ρ(ζ)=1 com |ζ|≤1.",
                                    "Cite referências: Dahlquist (original) ou Hairer et al."
                                  ],
                                  "verification": "Escreva o teorema completo e esboce a prova.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigo ou livro com teorema (ex: Hairer 'Solving ODEs I'), calculadora simbólica.",
                                  "tips": "Memorize: Consistência + Estabilidade ⇒ Convergência.",
                                  "learningObjective": "Internalizar o teorema fundamental.",
                                  "commonMistakes": "Trocar Dahlquist por Dalquist; pular prova da necessidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar a necessidade da consistência zero para convergência",
                                  "subSteps": [
                                    "Suponha método sem consistência zero: ρ(1) ≠ 0.",
                                    "Considere solução constante y(t)=c, então erro satisfaz equação com termo ρ(1)c ≠0.",
                                    "Mostre que erro local truncamento não →0, logo ||e_n|| não →0.",
                                    "Use contrapositiva: se converge para toda y constante, então consistente.",
                                    "Conclua: necessário mas não suficiente (precisa estabilidade)."
                                  ],
                                  "verification": "Prove formalmente para y constante e generalize.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis para derivações, exemplos de métodos inconsistentes.",
                                  "tips": "Comece com y'=0 para simplificar.",
                                  "learningObjective": "Provar teoricamente a necessidade.",
                                  "commonMistakes": "Assumir suficiência; erro em análise de erro local."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Mostrar insuficiência com contraexemplo",
                                  "subSteps": [
                                    "Pegue método consistente mas instável: ex. ρ(ζ)=ζ^2 - ζ (raiz 1 e -1? Ajuste).",
                                    "Exemplo clássico: método de Milstein ou multistep com raiz |ζ|>1.",
                                    "Simule numericamente: y'=λy, λ<0, h pequeno, observe divergência.",
                                    "Compare com método estável como trapezoidal.",
                                    "Conclua: consistência zero necessária mas requer estabilidade."
                                  ],
                                  "verification": "Implemente simulação e plote erros.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python/MATLAB com script multistep, problema teste y'= -y.",
                                  "tips": "Use h=0.1,0.05,... e monitore ||y_n - y_exata||.",
                                  "learningObjective": "Entender limitações via exemplo prático.",
                                  "commonMistakes": "Escolher exemplo ruim; ignorar instabilidade."
                                }
                              ],
                              "practicalExample": "Considere o método multistep ∑ α_j y_{n+j} = h β f_{n+1} com ρ(1)=1≠0. Para y'=0, y=1, a solução numérica satisfaz y_{n+1} = y_n + h*0 + erro persistente, levando a deriva linear em n, não convergindo para 1 mesmo com h→0.",
                              "finalVerifications": [
                                "Pode enunciar e provar que consistência zero é necessária para convergência em soluções constantes?",
                                "Explica o teorema de Dahlquist corretamente?",
                                "Identifica um método multistep sem consistência zero e mostra falha de convergência?",
                                "Fornece contraexemplo onde consistência zero existe mas não converge?",
                                "Relaciona corretamente com estabilidade zero?",
                                "Simula numericamente para validar?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de consistência zero (ρ(1)=0).",
                                "Correta enunciação e esquemática da prova do teorema de Dahlquist.",
                                "Demonstração clara da necessidade via análise de erro para constantes.",
                                "Contraexemplo válido mostrando insuficiência.",
                                "Uso correto de notação matemática e lógica teórica.",
                                "Integração de simulação prática com teoria."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação e teste de métodos multistep em Python.",
                                "Física Computacional: Simulações de EDOs em dinâmica (ex: osciladores).",
                                "Estatística: Análise de erros em métodos numéricos estocásticos.",
                                "Engenharia: Modelagem de circuitos RC com integração numérica."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica ou finanças, métodos multistep sem consistência zero falham em capturar estados estacionários, levando a previsões errôneas acumuladas; engenheiros usam isso para validar solvers em software como COMSOL ou MATLAB ODE suites."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Ordem p dos Métodos Multistep",
                        "description": "Condições para que um método multistep linear tenha ordem de precisão p, envolvendo as condições de truncamento local de ordem p+1 e as somas ponderadas dos coeficientes σ_k derivados dos polinômios ρ e σ.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Derivar condições de ordem p",
                            "description": "Derivar as condições gerais para ordem p usando a expansão em série de Taylor da solução exata y(t), resultando em ∑ α_k = 0, ∑ k α_k = ∑ β_k e condições de ordem superior envolvendo derivadas até ordem p.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o método multistep e expansão de Taylor básica",
                                  "subSteps": [
                                    "Lembre a forma geral do método multistep linear: ∑_{k=0}^m α_k y_{n+k} - h ∑_{k=0}^m β_k f(t_{n+k}, y_{n+k}) = 0.",
                                    "Escreva a expansão de Taylor da solução exata y(t + h) ao redor de t_n: y(t_n + h) = y(t_n) + h y'(t_n) + (h^2/2!) y''(t_n) + ... + (h^p/p!) y^{(p)}(t_n) + O(h^{p+1}).",
                                    "Generalize para y(t_n + k h) = ∑_{j=0}^p (k h)^j / j!  y^{(j)}(t_n) + O(h^{p+1}).",
                                    "Note que f(t_n + k h, y(t_n + k h)) = y'(t_n + k h) = ∑_{j=0}^p (k h)^j / j!  y^{(j+1)}(t_n) + O(h^{p+1}).",
                                    "Defina os operadores de avanço L[y(t_n), h] = ∑ α_k y(t_n + k h) - h ∑ β_k y'(t_n + k h)."
                                  ],
                                  "verification": "Verifique se as expansões de Taylor estão corretas comparando com fórmulas padrão e se o operador L está bem definido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (capítulo de métodos multistep)",
                                    "Calculadora simbólica ou software como Mathematica/SymPy"
                                  ],
                                  "tips": "Use notação compacta com somatórios para evitar anotações longas.",
                                  "learningObjective": "Compreender a base teórica para análise de ordem via Taylor.",
                                  "commonMistakes": "Confundir y(t_n + k h) com y_{n+k} aproximado; lembrar que usamos a solução exata."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Substituir expansões de Taylor no operador L",
                                  "subSteps": [
                                    "Substitua y(t_n + k h) = ∑_{j=0}^p \frac{(k h)^j}{j!} y^{(j)}(t_n) + O(h^{p+1}) no termo ∑ α_k y(t_n + k h).",
                                    "Substitua y'(t_n + k h) = ∑_{j=0}^p \frac{(k h)^j}{j!} y^{(j+1)}(t_n) + O(h^{p+1}) no termo h ∑ β_k y'(t_n + k h).",
                                    "Escreva L[y(t_n), h] = ∑_{j=0}^p h^j / j!  [ ∑_k α_k k^j  - j ∑_k β_k k^{j-1} ] y^{(j)}(t_n) + O(h^{p+1}).",
                                    "Confirme a identidade para o coeficiente de h^j: c_j = ∑_{k=0}^m α_k k^j - j ∑_{k=0}^m β_k k^{j-1}.",
                                    "Verifique para j=0: c_0 = ∑ α_k."
                                  ],
                                  "verification": "Calcule manualmente c_0 e c_1 para um método conhecido (ex: Trapezoidal) e confira se zero para consistência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software simbólico para somatórios (opcional)"
                                  ],
                                  "tips": "Agrupe termos por potências de h^j imediatamente para clareza.",
                                  "learningObjective": "Aplicar expansões de Taylor diretamente no esquema numérico.",
                                  "commonMistakes": "Erro no índice de derivada para f: y' tem y^{(j+1)}; divida por j! corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Impor condições de ordem p para consistência local",
                                  "subSteps": [
                                    "Para truncamento O(h^{p+1}), exija L[y(t_n), h] = O(h^{p+1}), ou seja, c_j = 0 para j = 0,1,...,p.",
                                    "Para ordem 1 (consistência básica): c_0 = ∑ α_k = 0 e c_1 = ∑ k α_k - ∑ β_k = 0.",
                                    "Generalize para ordem p: c_j = ∑_{k=0}^m α_k k^j - j ∑_{k=0}^m β_k k^{j-1} = 0, ∀ j=1,...,p.",
                                    "Note que para j=0 é ∑ α_k =0; para j≥1, envolve derivadas até y^{(p)}.",
                                    "Escreva as p+1 condições: ∑ α_k =0, e para j=1 a p: ∑ k^j α_k = j ∑ k^{j-1} β_k."
                                  ],
                                  "verification": "Liste explicitamente as condições para p=2 e verifique com método Adams-Bashforth de ordem 2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de potências k^j para k=0..m",
                                    "Exemplos de métodos multistep"
                                  ],
                                  "tips": "Use tabela para calcular ∑ k^j α_k e ∑ k^{j-1} β_k separadamente.",
                                  "learningObjective": "Derivar as equações que definem a ordem p dos coeficientes.",
                                  "commonMistakes": "Esquecer o fator j no termo β; confundir j-1 com j."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e generalizar para ordem p arbitrária",
                                  "subSteps": [
                                    "Confirme consistência de ordem 1 como pré-requisito: ∑ α_k=0 e ∑ β_k =1 (de c_1=0).",
                                    "Para ordem superior, resolva o sistema linear para α_k, β_k satisfazendo as p+1 equações c_j=0.",
                                    "Discuta que para m passos, máximo ordem 2m (A-stabilidade, etc.), mas foque em p≤m+1.",
                                    "Escreva forma matricial: colunas de Vandermonde para potências k^j.",
                                    "Teste com p=3: condições explícitas envolvendo ∑ k^3 α_k = 3! ∑ k^2 β_k /2, etc.",
                                    "Conclua que as condições são ∑_{k} α_k k^j = j ∑_{k} β_k k^{j-1} para j=1..p."
                                  ],
                                  "verification": "Derive condições para p=1,2,3 e compare com literatura padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz de Vandermonde exemplo",
                                    "Referência: Hairer 'Solving ODEs I'"
                                  ],
                                  "tips": "Comece com casos baixos p para intuitar o padrão geral.",
                                  "learningObjective": "Generalizar as condições de ordem p de forma compacta.",
                                  "commonMistakes": "Ignorar normalização ∑ β_k=1; erro em fatoriais ou índices."
                                }
                              ],
                              "practicalExample": "Para o método multistep de 2 passos com ordem p=2 (ex: método trapezoidal modificado): resolva ∑ α_k=0, ∑ k α_k = ∑ β_k, ∑ k^2 α_k = 2 ∑ k β_k. Tipicamente α_0=1, α_1=-1, α_2=0, β_0=1/2, β_1=1/2 satisfaz até p=2.",
                              "finalVerifications": [
                                "Condição de ordem 0: ∑ α_k = 0 está correta.",
                                "Condição de ordem 1: ∑ k α_k = ∑ β_k é satisfeita.",
                                "Para ordem p, todas c_j = 0 para j=0 a p.",
                                "Coeficientes c_j envolvem corretamente ∑ α_k k^j - j ∑ β_k k^{j-1}.",
                                "Expansões de Taylor truncadas em O(h^{p+1}).",
                                "Verificação numérica para método conhecido (ex: AB2) dá ordem correta."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas expansões de Taylor (sem erros de índices ou fatoriais).",
                                "Correção das condições c_j=0 para j=0..p.",
                                "Clareza na derivação do operador L e coeficientes.",
                                "Generalização correta para ordem p arbitrária.",
                                "Identificação de erros comuns evitados (ex: fator j).",
                                "Uso apropriado de notação somatória e Vandermonde."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em simulações dinâmicas (EDOs em mecânica).",
                                "Computação: Implementação de solvers numéricos em Python (SciPy odeint).",
                                "Engenharia: Otimização de métodos para EDOs em controle de sistemas.",
                                "Estatística: Modelagem estocástica com métodos multistep adaptativos."
                              ],
                              "realWorldApplication": "Essas condições são usadas para projetar solvers de EDOs de alta ordem em software como MATLAB ode45 ou NASA simulations, garantindo precisão em previsões climáticas, trajetórias espaciais e modelagem biológica (ex: epidemias SIR)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Calcular a ordem de um método multistep",
                            "description": "Para um método dado, como o método de Milne-Simpson, computar os coeficientes e determinar a ordem máxima p verificando quantas condições de ordem são satisfeitas através das somas sucessivas ∑ k^j α_k / j! = ∑ k^j β_k / j! para j=0 até p.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura do método multistep e identificar coeficientes α_k e β_k",
                                  "subSteps": [
                                    "Leia a fórmula geral do método: ∑_{k=0}^m α_k y_{n+k} = h ∑_{k=0}^m β_k f_{n+k}",
                                    "Identifique o grau m e os índices k de 0 a m",
                                    "Extraia os valores numéricos de α_k e β_k da fórmula dada",
                                    "Verifique a normalização: ∑ α_k = 0 (ordem 0) e ∑ k α_k = ∑ β_k (ordem 1)",
                                    "Anote os coeficientes em uma tabela organizada por k"
                                  ],
                                  "verification": "Tabela de coeficientes completa e verificações de ordem 0 e 1 corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Fórmula do método multistep",
                                    "Papel e caneta ou planilha",
                                    "Calculadora"
                                  ],
                                  "tips": "Use uma tabela com colunas para k, α_k e β_k para evitar confusões.",
                                  "learningObjective": "Identificar e listar precisamente os coeficientes α_k e β_k de um método multistep dado.",
                                  "commonMistakes": [
                                    "Confundir α_k (lado esquerdo) com β_k (lado direito)",
                                    "Esquecer coeficientes zero para k intermediários"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer as condições de ordem para j = 0 até valores iniciais",
                                  "subSteps": [
                                    "Lembre a condição de ordem j: (1/j!) ∑_{k=0}^m k^j α_k = (1/j!) ∑_{k=0}^m k^j β_k",
                                    "Para j=0: verifique ∑ α_k = 0 e ∑ β_k = 0 (se aplicável)",
                                    "Para j=1: verifique ∑ k α_k = ∑ β_k",
                                    "Calcule as somas iniciais manualmente ou com fórmula binomial para potências",
                                    "Registre os valores de cada soma separadamente para α e β"
                                  ],
                                  "verification": "Condições para j=0 e j=1 satisfeitas com cálculos exatos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de coeficientes do Step 1",
                                    "Calculadora ou software simbólico como SymPy/MATLAB"
                                  ],
                                  "tips": "Fatore 1/j! após calcular as somas brutas para simplificar comparações.",
                                  "learningObjective": "Aplicar corretamente as condições de ordem para baixos valores de j.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/j! nas somas",
                                    "Usar potências erradas (ex: k^{j-1} em vez de k^j)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular somas sucessivas para j = 2, 3, ... até detectar falha",
                                  "subSteps": [
                                    "Para cada j subsequente (j=2,3,...), compute ∑ k^j α_k e ∑ k^j β_k",
                                    "Divida cada soma por j! e compare se são iguais",
                                    "Continue até encontrar o primeiro j onde as somas diferem",
                                    "Use expansão binomial ou propriedades para j altos se m pequeno",
                                    "Documente todas as igualdades e a primeira desigualdade"
                                  ],
                                  "verification": "Tabela completa de somas para j até o ponto de falha, com igualdades confirmadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela anterior",
                                    "Calculadora avançada ou Python/MATLAB para potências altas"
                                  ],
                                  "tips": "Automatize com loop em software se m>4 para evitar erros aritméticos.",
                                  "learningObjective": "Executar cálculos iterativos das condições de ordem até determinar o limite.",
                                  "commonMistakes": [
                                    "Erros de arredondamento em cálculos decimais",
                                    "Parar cedo sem verificar j extras"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a ordem máxima p e validar",
                                  "subSteps": [
                                    "A ordem p é o maior j tal que todas condições de 0 a p são satisfeitas",
                                    "Identifique p como j-1 onde a primeira falha ocorre em j",
                                    "Compare com ordem conhecida do método (ex: Milne-Simpson ordem 4)",
                                    "Verifique consistência: para métodos lineares multistep, ordem ≤ 2m+1 ou 2m+2",
                                    "Resuma os resultados em um relatório curto"
                                  ],
                                  "verification": "Valor de p correto e justificado pela sequência de verificações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resultados dos steps anteriores",
                                    "Referência teórica do método"
                                  ],
                                  "tips": "Teste com método conhecido para validar seu processo.",
                                  "learningObjective": "Concluir a ordem máxima p com base nas condições verificadas.",
                                  "commonMistakes": [
                                    "Confundir p com o j da falha",
                                    "Ignorar condições de consistência básica"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método de Milne-Simpson: y_{n+4} - y_n = (4h/3)(2f_{n+3} - f_{n+2} + 2f_{n+1} - f_n). Coeficientes: α_4=1, α_0=-1, α_outros=0; β_3=8/3, β_2=-4/3, β_1=8/3, β_0=-4/3 (normalizado). Verificando: condições até j=4 satisfeitas, falha em j=5 → ordem p=4.",
                              "finalVerifications": [
                                "Todas somas ∑ k^j α_k / j! = ∑ k^j β_k / j! para j=0 a p",
                                "Primeira desigualdade identificada corretamente em j=p+1",
                                "Coeficientes extraídos sem erros da fórmula original",
                                "Ordem p consistente com teoria (ex: ≤2m+2 para m=4)",
                                "Relatório resume p e evidências",
                                "Validação cruzada com método conhecido"
                              ],
                              "assessmentCriteria": [
                                "Precisão nos coeficientes α_k e β_k (100% correto)",
                                "Cálculos de somas sem erros aritméticos",
                                "Sequência completa de j verificados até falha",
                                "Identificação correta de p máxima",
                                "Documentação clara com tabelas e justificativas",
                                "Eficiência no uso de ferramentas computacionais"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar verificação de ordem em Python ou MATLAB para automação",
                                "Física: Aplicar em solvers numéricos para EDOs em dinâmica de sistemas",
                                "Engenharia Computacional: Análise de erro em simulações CFD ou circuitos",
                                "Estatística: Estudo de truncamento de erro em métodos numéricos probabilísticos"
                              ],
                              "realWorldApplication": "Em software de simulação como MATLAB ODE solvers ou COMSOL, determinar a ordem de métodos multistep garante precisão em modelagens de populações biológicas, previsão climática ou otimização financeira, minimizando erros de truncamento em integrações de longo prazo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Analisar truncamento local de ordem p+1",
                            "description": "Explicar o erro de truncamento local τ_{n+1}(h) = O(h^{p+1}) e sua relação com a ordem p, ilustrando com exemplos numéricos para métodos explícitos e implícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Erro de Truncamento Local em Métodos Multistep",
                                  "subSteps": [
                                    "Revise a fórmula geral de métodos multistep: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}).",
                                    "Defina o erro de truncamento local τ_{n+1}(h) como a diferença entre a solução exata e a numérica assumindo valores anteriores exatos.",
                                    "Explique que τ_{n+1}(h) mede o erro introduzido em um único passo.",
                                    "Discuta a expansão em série de Taylor da solução exata y(t_{n+1}).",
                                    "Identifique os termos que definem a ordem p."
                                  ],
                                  "verification": "Escreva a definição de τ_{n+1}(h) e expanda y(t_{n+1}) em Taylor até ordem p+1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), papel e caneta, calculadora simbólica (Wolfram Alpha).",
                                  "tips": "Comece com k=1 para simplificar antes de generalizar.",
                                  "learningObjective": "Entender a origem do erro de truncamento local e sua representação assintótica.",
                                  "commonMistakes": "Confundir truncamento local com truncamento global; ignorar suposição de passos anteriores exatos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Relação τ_{n+1}(h) = O(h^{p+1}) para Ordem p",
                                  "subSteps": [
                                    "Substitua a expansão de Taylor de y(t_{n+j}) na fórmula do método multistep.",
                                    "Some os coeficientes para cada derivada y^{(m)}(t_n) e imponha condições de ordem p: ∑ α_j = 0 para m=0, e ∑ (α_j j^m + m β_j j^{m-1}) = 0 para m=1 a p.",
                                    "Mostre que o primeiro termo não-zero é para m=p+1, resultando em τ_{n+1}(h) = C h^{p+1} y^{(p+1)}(ξ) + O(h^{p+2}).",
                                    "Explique o significado de p como a maior ordem onde condições são satisfeitas.",
                                    "Verifique para p=1 com método Euler backward/forward."
                                  ],
                                  "verification": "Derive τ_{n+1}(h) para um método de ordem p=2 e confirme O(h^3).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software simbólico (SymPy ou Mathematica), quadro branco ou caderno de anotações.",
                                  "tips": "Use tabelas para organizar coeficientes α e β por ordem m.",
                                  "learningObjective": "Derivar analiticamente a ordem do erro de truncamento local.",
                                  "commonMistakes": "Erros em coeficientes de Taylor; esquecer fator h na aproximação de f."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ilustrar com Exemplo Numérico para Método Explícito (Adams-Bashforth ordem 2)",
                                  "subSteps": [
                                    "Escolha y' = -y, y(0)=1 (solução exata y=e^{-t}).",
                                    "Implemente AB2: y_{n+1} = y_n + (h/2)(3f_n - f_{n-1}).",
                                    "Calcule passos com h=0.1, compare y_num vs y_exata, compute τ ≈ (y_exata_{n+1} - y_{n+1}) / h^{3}.",
                                    "Repita para h=0.05 e verifique se τ é aproximadamente constante (O(h^3)).",
                                    "Plote log|τ| vs log h para confirmar inclinação 3."
                                  ],
                                  "verification": "Tabela com h, y_num, erro local, e confirmação de O(h^3).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/MATLAB com NumPy/Octave, planilha Excel para cálculos manuais.",
                                  "tips": "Use valores exatos iniciais para isolar truncamento local.",
                                  "learningObjective": "Aplicar conceito em método explícito e validar numericamente.",
                                  "commonMistakes": "Arredondamento numérico mascarando O(h^{p+1}); não normalizar por h^{p+1}."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com Exemplo Numérico para Método Implícito (Adams-Moulton ordem 2)",
                                  "subSteps": [
                                    "Use mesmo problema y'=-y, y(0)=1.",
                                    "Implemente AM2: y_{n+1} = y_n + (h/12)(-f_{n+1} + 8f_n + f_{n-1}), resolva implicitamente (iteração ou exato aqui).",
                                    "Calcule para h=0.1 e 0.05, compute τ ≈ (y_exata_{n+1} - y_{n+1}) / h^{3}.",
                                    "Compare precisão com AB2.",
                                    "Plote para visualização."
                                  ],
                                  "verification": "Tabela similar à do passo 3, com confirmação O(h^3) e comparação explícito vs implícito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo que passo 3, mais solver para equação implícita (fsolve em Python).",
                                  "tips": "Para problemas lineares, resolva analiticamente o passo implícito.",
                                  "learningObjective": "Comparar truncamento em métodos explícitos e implícitos.",
                                  "commonMistakes": "Não convergir iterações implícitas; confundir f_{n+1} com y_{n+1}."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Verificar Compreensão Geral",
                                  "subSteps": [
                                    "Resuma relação entre condições de ordem e τ = O(h^{p+1}).",
                                    "Discuta impacto em estabilidade para implícitos vs explícitos.",
                                    "Crie tabela comparativa de métodos comuns (AB2, AM2, etc.).",
                                    "Resolva exercício: encontre p para método dado.",
                                    "Reflita sobre limitações (ex: não-linearidades)."
                                  ],
                                  "verification": "Responda quiz: defina τ, derive para p=1, numérico para h halved.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Resumo em tabela, flashcards com fórmulas.",
                                  "tips": "Ensine a outro (Feynman technique).",
                                  "learningObjective": "Integrar conceitos e preparar para aplicações avançadas.",
                                  "commonMistakes": "Generalizar demais sem exemplos; ignorar dependência em y^{(p+1)}."
                                }
                              ],
                              "practicalExample": "Para y' = y(1-y), y(0)=0.5 (logística), use AB2 ordem 2 com h=0.1. Calcule y1 exata via série ou numérico preciso, compare com y1_AB2 assumindo y0=y-1 exatos, observe τ ~ h^3 * const, confirmando p=2.",
                              "finalVerifications": [
                                "Deriva corretamente τ_{n+1}(h) = O(h^{p+1}) para método dado.",
                                "Implementa e valida numericamente para explícito e implícito.",
                                "Identifica condições de ordem p na tabela de coeficientes.",
                                "Explica diferença prática entre explícito/implícito em τ.",
                                "Plota log-log de erro vs h com inclinação p+1.",
                                "Responde: 'Por que τ local implica convergência global O(h^p)?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação analítica (80% coeficientes corretos).",
                                "Correção numérica: erro <1e-4, normalização por h^{p+1} constante ±10%.",
                                "Profundidade de substeps: todos 3-5 executados com evidências.",
                                "Clareza em plots/tabelas: eixos rotulados, legenda.",
                                "Síntese: explicação verbal da relação ordem-erro.",
                                "Criatividade: extensão a outro método ou problema."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de erros em simulações dinâmicas (ex: N-body).",
                                "Computação: Implementação eficiente em ODE solvers (SciPy).",
                                "Estatística: Confiança em aproximações numéricas probabilísticas.",
                                "Engenharia: Otimização de h em controle de sistemas."
                              ],
                              "realWorldApplication": "Em modelagem climática, analisar truncamento local garante precisão em previsões de longo prazo usando multistep em ODEs rígidas, evitando acumulação de erros em simulações de semanas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.4",
                            "name": "Construir método de ordem p específico",
                            "description": "Resolver o sistema de equações para encontrar coeficientes β_k que maximizem a ordem p para um dado conjunto de α_k, como em métodos de ordem elevada de Adams-Moulton.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as condições de ordem para métodos multistep e preparar os coeficientes α_k",
                                  "subSteps": [
                                    "Revise a definição de erro de truncamento local para métodos multistep lineares: L[y_n](h) = ∑ α_k y(n+k h) - h ∑ β_k y'(n+k h) = O(h^{p+1}).",
                                    "Liste os coeficientes α_k dados e verifique consistência: ∑ α_k = 0 e ∑ k α_k = 1.",
                                    "Determine o número de passos m e a ordem máxima possível p (geralmente p ≤ m+1 para estabilidade).",
                                    "Calcule os termos conhecidos c_j = (1/j) ∑_{k=0}^m α_k k^j para j = 1 a p.",
                                    "Anote o sistema esperado: para cada j=1 a p, ∑_{k=0}^m β_k k^{j-1} = c_j."
                                  ],
                                  "verification": "Confirme que ∑ α_k = 0, ∑ k α_k = 1 e liste todos c_j corretamente com cálculos numéricos precisos.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora científica",
                                    "Referência teórica de Análise Numérica (livro ou notas)"
                                  ],
                                  "tips": "Comece sempre verificando consistência básica para evitar erros propagados.",
                                  "learningObjective": "Entender as bases teóricas das condições de ordem e preparar dados para resolução.",
                                  "commonMistakes": "Esquecer de verificar consistência de α_k; calcular k^j incorretamente para k=0 (0^j=0 para j>0)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a matriz do sistema linear para os coeficientes β_k",
                                  "subSteps": [
                                    "Construa a matriz A de dimensões p x (m+1), onde A_{j,k} = k^{j-1} para j=1..p, k=0..m (Vandermonde modificada).",
                                    "Prepare o vetor c de tamanho p com os c_j calculados no passo anterior.",
                                    "Escreva o sistema A β = c explicitamente para todos os índices.",
                                    "Verifique se p ≤ m+1 para que o sistema seja subs determinado ou quadrado; se sobredeterminado, use mínimos quadrados para maximizar p.",
                                    "Anote potências zero: para k=0 e j=1, 0^0 = 1 por convenção."
                                  ],
                                  "verification": "A matriz A e vetor c devem reproduzir as condições de ordem quando multiplicados por β solução.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Calculadora ou planilha (Excel/Google Sheets)",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Use convenção matemática 0^0 = 1 para consistência com séries de Taylor.",
                                  "learningObjective": "Formular sistemas lineares derivados de expansões de Taylor em métodos numéricos.",
                                  "commonMistakes": "Índices errados na matriz (confundir linhas/colunas); esquecer 0^0=1; normalização errada de c_j."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema linear para obter os coeficientes β_k",
                                  "subSteps": [
                                    "Se p = m+1 (quadrado), use eliminação gaussiana ou decomposição LU.",
                                    "Se p < m+1, resolva o subsistema com as primeiras colunas ou use pseudoinversa para minimizar erro.",
                                    "Calcule β_k numericamente com precisão (mantenha frações exatas se possível).",
                                    "Normalize se necessário para que o método seja consistente (∑ β_k =1 para ordem 1).",
                                    "Implemente em código Python/MATLAB para verificação: use numpy.linalg.solve(A, c)."
                                  ],
                                  "verification": "Multiplique A β e confira se ||A β - c|| < 1e-10 (erro numérico tolerável).",
                                  "estimatedTime": "20-40 minutos",
                                  "materials": [
                                    "Software de álgebra linear (Python com NumPy, MATLAB, ou Mathematica)",
                                    "Papel para Gauss manual"
                                  ],
                                  "tips": "Prefira resolução simbólica para frações exatas em exemplos acadêmicos.",
                                  "learningObjective": "Aplicar resolução de sistemas lineares para otimização de ordem em métodos numéricos.",
                                  "commonMistakes": "Sistema singular não detectado (det(A)=0); arredondamento levando a β_k inconsistentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a ordem alcançada e analisar o método construído",
                                  "subSteps": [
                                    "Verifique condições extras para ordem p+1: compute ∑ β_k k^p e compare com c_{p+1}.",
                                    "Calcule a constante de erro de truncamento e_{p+1} = (1/(p+1)!) (∑ α_k k^{p+1} - (p+1) ∑ β_k k^p ).",
                                    "Escreva a fórmula completa do método: ∑ α_k y_{n+k} = h ∑ β_k f_{n+k}.",
                                    "Teste numericamente em um problema simples de EDO (ex: y' = -y, y(0)=1).",
                                    "Discuta limitações: estabilidade (região de estabilidade zero-stability)."
                                  ],
                                  "verification": "Condições até p satisfeitas exatamente; ordem p+1 não (e_{p+1} ≠ 0).",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Solver numérico (Python SciPy odeint ou MATLAB ode45)",
                                    "Problema teste de EDO conhecido"
                                  ],
                                  "tips": "Use problemas lineares exatos para validar sem erros de arredondamento.",
                                  "learningObjective": "Validar e analisar propriedades do método numérico construído.",
                                  "commonMistakes": "Confundir ordem local com global; ignorar estabilidade para altos p."
                                }
                              ],
                              "practicalExample": "Dado α_k para k=0,1,2: α = [-3/2, 2, -1/2] (verificado: ∑α=0, ∑kα=1). Para p=3, matriz A = [[1,1,1], [0,1,2], [0,1,4]], c = [1, 1/2 * (0+2*1-0.5*4)=0, 1/3*(0+2*1-0.5*8)=-2/3]. Solução β ≈ [5/12, 8/12, -1/12], método Adams-Moulton ordem 3: (3/2 y_{n+2} - 2 y_{n+1} + 1/2 y_n)/h? Espera, índices ajustados, mas β=[-1/12, 8/12, 5/12] para f_{n},f_{n+1},f_{n+2}.",
                              "finalVerifications": [
                                "∑ α_k = 0 e ∑ k α_k = 1 confirmados.",
                                "Sistema A β = c resolvido com erro residual < 1e-12.",
                                "Condições de ordem 1 a p satisfeitas; ordem p+1 não.",
                                "Fórmula do método escrita corretamente.",
                                "Teste numérico em EDO simples converge com ordem p.",
                                "Constante de erro e_{p+1} calculada e não-zero."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes β_k (exatas ou com <1% erro).",
                                "Correção na formulação do sistema linear (matriz A e c).",
                                "Verificação completa de consistência e ordem.",
                                "Análise de limitações (estabilidade, erro constante).",
                                "Implementação numérica funcional e resultados plotados.",
                                "Explicação clara dos passos em relatório."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de sistemas e matrizes Vandermonde.",
                                "Programação: Implementação em Python/NumPy para automação.",
                                "Cálculo: Expansões de Taylor e análise assintótica.",
                                "Física: Aplicação em modelagem de EDOs dinâmicas."
                              ],
                              "realWorldApplication": "Construção de solvers personalizados para EDOs rígidos em simulações científicas, como previsão meteorológica (modelos atmosféricos), circuitos elétricos (SPICE), farmacocinética (modelos PK/PD) e finanças (modelos estocásticos discretizados), otimizando precisão vs custo computacional em bibliotecas como SciPy, ODEPACK ou SUNDIALS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Estabilidade e Problemas Stiff",
                    "description": "Estabilidade absoluta, região de estabilidade e tratamento de equações diferenciais stiff.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Estabilidade Absoluta",
                        "description": "Conceito de estabilidade absoluta em métodos numéricos para equações diferenciais, analisando a convergência do método sob perturbações no passo de tempo, especialmente para métodos de passo múltiplo.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Definir estabilidade absoluta",
                            "description": "Explicar a definição formal de estabilidade absoluta para métodos de Runge-Kutta e lineares multistep, usando o teste de Dahlquist e a amplificação de erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema Teste de Dahlquist",
                                  "subSteps": [
                                    "Estude o problema modelo y' = λy com Re(λ) < 0 e y(0) = 1.",
                                    "Analise a solução exata y(t) = exp(λt), que decai para t → ∞.",
                                    "Discuta por que este problema testa a estabilidade numérica em problemas stiff."
                                  ],
                                  "verification": "Escreva a solução exata e explique verbalmente por que ela decai.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), papel e caneta",
                                  "tips": "Visualize graficamente a decaimento exponencial para fixar a ideia.",
                                  "learningObjective": "Identificar o papel do problema de Dahlquist na análise de estabilidade.",
                                  "commonMistakes": "Confundir com instabilidade condicional; lembre que é para Re(λ) < 0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Fator de Amplificação para Métodos de Um Passo (Runge-Kutta)",
                                  "subSteps": [
                                    "Introduza z = hλ e o polinômio de estabilidade R(z) para métodos RK.",
                                    "Calcule R(z) para métodos simples como Euler forward (R(z) = 1 + z) e backward (R(z) = 1/(1 - z)).",
                                    "Defina estabilidade absoluta: |R(z)| ≤ 1 para z na meia-plano esquerdo."
                                  ],
                                  "verification": "Compute |R(z)| para z = -2i e verifique se ≤1 para Euler backward.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Calculadora ou MATLAB para plots de |R(z)|, notas de aula",
                                  "tips": "Plote a região de estabilidade no plano complexo para visualizar.",
                                  "learningObjective": "Calcular e interpretar o fator de amplificação R(z) em métodos RK.",
                                  "commonMistakes": "Esquecer que estabilidade absoluta requer |R(z)| ≤1 em todo o meia-plano, não só no eixo negativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender para Métodos Lineares Multistep",
                                  "subSteps": [
                                    "Revise a forma geral: ∑ α_k y_{n+k} = h ∑ β_k f_{n+k}.",
                                    "Introduza os polinômios ρ(ζ) e σ(ζ), e R(z) = ρ(ζ)/σ(ζ) com ζ = exp(z).",
                                    "Aplique o teste de Dahlquist: raiz principal de ρ com |ρ'| =1, outras raízes |ζ| <1."
                                  ],
                                  "verification": "Derive R(z) para o método trapezoidal e verifique estabilidade.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "Software como Python/Scipy para simulações, quadro branco",
                                  "tips": "Use a aproximação ζ ≈ 1 + z para pequenas z para validar.",
                                  "learningObjective": "Formular a definição de estabilidade absoluta via polinômios característica.",
                                  "commonMistakes": "Confundir raiz principal com raízes espúrias; foque em Dahlquist."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Amplificação de Erros e Definição Formal",
                                  "subSteps": [
                                    "Explique como erros de arredondamento evoluem como |R(z)|^k.",
                                    "Defina formalmente estabilidade absoluta: lim_{k→∞} |R(z)|^k = 0 para Re(z) < 0.",
                                    "Compare com estabilidade relativa e discuta implicações para problemas stiff."
                                  ],
                                  "verification": "Resuma em um parágrafo a definição completa, incluindo ambos os métodos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos sobre Dahlquist (PDF), resumo pessoal",
                                  "tips": "Ligue à norma A-stabilidade: região inclui meia-plano esquerdo.",
                                  "learningObjective": "Integrar amplificação de erros na definição de estabilidade absoluta.",
                                  "commonMistakes": "Ignorar que para multistep, zero-stability é pré-requisito (Dahlquist barrier)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Exemplificar",
                                  "subSteps": [
                                    "Escreva definições formais para RK e multistep lado a lado.",
                                    "Teste com um exemplo numérico: aplique Euler em y' = -50y.",
                                    "Discuta falhas: oscilações em métodos explícitos."
                                  ],
                                  "verification": "Crie um fluxograma resumindo o teste de Dahlquist e R(z).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Jupyter notebook para simulação rápida",
                                  "tips": "Simule com h pequeno vs grande para ver amplificação.",
                                  "learningObjective": "Aplicar a definição em contextos práticos.",
                                  "commonMistakes": "Generalizar demais; especifique para RK vs multistep."
                                }
                              ],
                              "practicalExample": "Para o método de Euler explícito em y' = -λ y com λ=50, h=0.1 (z=-5), |R(z)| = |1-5|=4 >1, levando a amplificação exponencial de erros e divergência, enquanto Euler implícito tem |R(z)|<1, mantendo estabilidade.",
                              "finalVerifications": [
                                "Explica corretamente o problema teste de Dahlquist.",
                                "Define R(z) e |R(z)| ≤1 para ambos RK e multistep.",
                                "Descreve amplificação de erros via |R(z)|^k.",
                                "Distingue estabilidade absoluta de condicional.",
                                "Aplica a um exemplo numérico simples.",
                                "Menciona barreiras como Dahlquist para multistep."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática de R(z) (80% correto).",
                                "Correta interpretação do teste de Dahlquist (exato vs numérico).",
                                "Exemplo prático demonstra amplificação de erros.",
                                "Distinção clara entre métodos RK e multistep.",
                                "Uso apropriado de terminologia (A-stabilidade, zero-stability).",
                                "Capacidade de plotar ou descrever região de estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos (equações diferenciais stiff).",
                                "Engenharia de Controle: Análise de sistemas lineares discretos.",
                                "Ciência da Computação: Otimização de solvers numéricos em bibliotecas como SciPy.",
                                "Matemática Aplicada: Teoria de perturbações e análise assintótica."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas stiff (ex: combustão), onde passos rápidos e lentos coexistem, métodos com estabilidade absoluta evitam artefatos numéricos e permitem h maiores, acelerando simulações em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Analisar estabilidade em métodos de passo múltiplo",
                            "description": "Aplicar o critério de estabilidade absoluta a métodos como Adams-Bashforth e Adams-Moulton, identificando condições de estabilidade zero e A-estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Formulações dos Métodos de Passo Múltiplo",
                                  "subSteps": [
                                    "Estude a forma geral dos métodos lineares multistep: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}",
                                    "Memorize as fórmulas específicas para Adams-Bashforth (explícito) e Adams-Moulton (implícito)",
                                    "Identifique os coeficientes para ordens comuns (2 a 4)",
                                    "Escreva exemplos numéricos simples para y' = f(y)",
                                    "Compare diferenças entre métodos explícitos e implícitos"
                                  ],
                                  "verification": "Escreva corretamente as fórmulas de Adams-Bashforth e Moulton de ordem 2 e 3 sem consultar notas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Folha de anotações",
                                    "Calculadora simbólica (Mathematica ou SymPy)"
                                  ],
                                  "tips": "Comece com ordens baixas para fixar os padrões de coeficientes.",
                                  "learningObjective": "Compreender a estrutura matemática dos métodos para análise posterior de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir coeficientes de Adams-Bashforth com Moulton",
                                    "Esquecer o passo h nas aproximações de integrais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Critério de Estabilidade Absoluta",
                                  "subSteps": [
                                    "Aprenda o teste do método da raiz característica para y' = λy",
                                    "Defina os polinômios ρ(z) = ∑ α_j z^j e σ(z) = ∑ β_j z^j",
                                    "Estude a equação característica ρ(z) - ζ σ(z) = 0, onde ζ = hλ",
                                    "Entenda que estabilidade absoluta requer |raízes| ≤ 1 para Re(ζ) < 0",
                                    "Diferencie estabilidade absoluta de estabilidade relativa"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o teste de estabilidade absoluta para um método dado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de aula sobre EDOs lineares",
                                    "Software MATLAB ou Python (SciPy)",
                                    "Gráficos de regiões de estabilidade pré-computados"
                                  ],
                                  "tips": "Visualize a região de estabilidade no plano complexo ζ.",
                                  "learningObjective": "Dominar a base teórica para aplicar o critério a métodos específicos.",
                                  "commonMistakes": [
                                    "Confundir ζ = hλ com λh",
                                    "Ignorar raízes múltiplas na análise"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Analisar Polinômios de Estabilidade",
                                  "subSteps": [
                                    "Calcule ρ(z) e σ(z) para Adams-Bashforth de ordem k=2,3",
                                    "Calcule ρ(z) e σ(z) para Adams-Moulton de ordem k=2,3",
                                    "Resolva a equação característica para cada método",
                                    "Plote ou descreva as raízes como função de ζ",
                                    "Identifique condições onde todas as raízes têm |z| ≤ 1"
                                  ],
                                  "verification": "Derive ρ(z) e σ(z) corretamente para AB2 e AM2, e liste as raízes principais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Python com NumPy/SymPy para polinômios",
                                    "Tabela de coeficientes de Adams"
                                  ],
                                  "tips": "Use tabelas padrão de coeficientes para evitar cálculos manuais longos.",
                                  "learningObjective": "Aplicar derivações analíticas para obter funções de estabilidade.",
                                  "commonMistakes": [
                                    "Erro nos coeficientes de integração de Newton-Cotes",
                                    "Esquecer normalização ρ(1)=0, σ(1)=1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Condições de Estabilidade Zero e A-Estabilidade",
                                  "subSteps": [
                                    "Defina estabilidade zero: região de estabilidade inclui o semiplano esquerdo",
                                    "Verifique para Adams-Bashforth: mostre que não são zero-estáveis nem A-estáveis",
                                    "Para Adams-Moulton: analise A-estabilidade (inclui todo Re(ζ)<0)",
                                    "Calcule limites de estabilidade para métodos explícitos",
                                    "Compare com métodos de Runge-Kutta para contexto"
                                  ],
                                  "verification": "Classifique AB3 e AM3 quanto a zero-estabilidade e A-estabilidade com justificativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Gráficos de regiões de estabilidade (online ou MATLAB)",
                                    "Exercícios resolvidos de livros",
                                    "Software para plotar regiões"
                                  ],
                                  "tips": "Use argumento de Nyquist ou teoremas de Dahlquist para insights rápidos.",
                                  "learningObjective": "Discriminar propriedades de estabilidade específicas dos métodos.",
                                  "commonMistakes": [
                                    "Acreditar que métodos explícitos são A-estáveis",
                                    "Confundir estabilidade zero com A-estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar Análise em Exemplos Práticos",
                                  "subSteps": [
                                    "Escolha um problema stiff: y' = -50y + sin(t), teste com AB e AM",
                                    "Simule numericamente e observe blow-up em AB",
                                    "Ajuste h para verificar limites de estabilidade",
                                    "Compare soluções com métodos A-estáveis (ex: BDF)",
                                    "Documente conclusões sobre escolha de método"
                                  ],
                                  "verification": "Produza gráfico mostrando falha de AB e sucesso de AM para h inadequado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Octave ou Python (odeint/solve_ivp)",
                                    "Problemas stiff de exemplo"
                                  ],
                                  "tips": "Use λ com grande |Re(λ)| para testar stiff.",
                                  "learningObjective": "Integrar teoria com prática computacional.",
                                  "commonMistakes": [
                                    "Escolher h muito pequeno ignorando overhead computacional",
                                    "Não normalizar soluções"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Adams-Bashforth de ordem 2 (AB2): ρ(z) = z^2 - z, σ(z) = (3/2)z^2 - (1/2)z. Analise a raiz principal r(ζ) ≈ 1 + ζ + (1/2)ζ^2, mostrando que para ζ = -3 (Re<0), |r|>1, logo não A-estável. Simule y'=-y em [0,5] com h=0.1 e observe oscilações.",
                              "finalVerifications": [
                                "Deriva corretamente ρ(z) e σ(z) para AB3 e AM2",
                                "Identifica que Adams-Bashforth não é A-estável",
                                "Explica por que Adams-Moulton é A-estável para ordens baixas",
                                "Plota região de estabilidade absoluta para AB2",
                                "Aplica critério em um problema stiff numérico",
                                "Compara com métodos de um passo"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de polinômios de estabilidade (90% correto)",
                                "Correta identificação de propriedades (zero-estável, A-estável)",
                                "Análise qualitativa e quantitativa da equação característica",
                                "Uso apropriado de exemplos numéricos com gráficos",
                                "Explicação clara de condições de falha",
                                "Conexão com problemas stiff"
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em simulações de osciladores amortecidos",
                                "Engenharia: Controle de sistemas dinâmicos stiff em aerodinâmica",
                                "Computação: Implementação eficiente de solvers ODE em bibliotecas como SciPy",
                                "Química: Modelagem de reações em regime stiff",
                                "Estatística: Propagação de erros em métodos numéricos"
                              ],
                              "realWorldApplication": "Em simulações de problemas stiff como dinâmica molecular, circuitos elétricos RC com capacitores grandes ou reações químicas rápidas/lentas, onde métodos A-estáveis como Adams-Moulton evitam instabilidades numéricas, permitindo passos h maiores e simulações mais eficientes em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Calcular fator de amplificação",
                            "description": "Computar o fator de amplificação para equações teste lineares y' = λy, demonstrando quando |R(z)| ≤ 1 para estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação teste linear y' = λy e sua solução exata",
                                  "subSteps": [
                                    "Identifique a equação diferencial ordinária (EDO) teste y' = λy, onde λ é um escalar complexo com parte real negativa para modelar decaimento.",
                                    "Resolva analiticamente: y(t) = y(0) e^{λt}, destacando que |e^{λh}| < 1 para estabilidade numérica.",
                                    "Discuta o conceito de estabilidade absoluta: o método numérico deve satisfazer |y_n| → 0 quando |e^{λh}| < 1.",
                                    "Calcule exemplos numéricos para λ = -1, h=0.1, mostrando y(t) decaente.",
                                    "Anote a importância para análise de estabilidade de métodos numéricos."
                                  ],
                                  "verification": "Escreva a solução exata e confirme que para Re(λ)<0, a solução tende a zero.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora para exponenciais complexas",
                                  "tips": "Sempre assuma y(0)=1 para simplificar cálculos iniciais.",
                                  "learningObjective": "Entender o comportamento assintótico da solução exata como benchmark para estabilidade numérica.",
                                  "commonMistakes": "Confundir λ real com complexo; esquecer que estabilidade requer Re(λh)<0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o método de passo múltiplo linear multistep (LMM)",
                                  "subSteps": [
                                    "Escreva a forma geral do LMM: ∑_{k=0}^m α_k y_{n+k} = h ∑_{k=0}^m β_k f_{n+k}, com α_m=1.",
                                    "Identifique os polinômios ρ(ζ) = ∑ α_k ζ^k (polinômio de recorrência) e σ(ζ) = ∑ β_k ζ^k (polinômio de diferença).",
                                    "Explique que para consistência, ordem de ρ e σ devem satisfazer condições específicas.",
                                    "Dê exemplos: Adams-Bashforth (explícito, β_m=0), Backward Differentiation (implícito).",
                                    "Prepare para aplicação: assuma f(y)=λy."
                                  ],
                                  "verification": "Escreva ρ(ζ) e σ(ζ) para um método específico como o trapezoidal (m=1).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de fórmulas de métodos LMM, software como Python/MATLAB para plotar polinômios",
                                  "tips": "Memorize que métodos A-stáveis têm região de estabilidade incluindo o semiplano esquerdo.",
                                  "learningObjective": "Dominar a notação padrão de LMMs e seus componentes polinomiais.",
                                  "commonMistakes": "Confundir índices de k (de 0 a m); errar normalização α_m=1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o LMM à equação teste para obter a equação de recorrência",
                                  "subSteps": [
                                    "Substitua f_{n+k} = λ y_{n+k} na equação LMM, obtendo ∑ α_k y_{n+k} = z ∑ β_k y_{n+k}, onde z = hλ.",
                                    "Reorganize: ∑ (α_k - z β_k) y_{n+k} = 0.",
                                    "Assuma solução y_{n+k} = R(z)^k y_n, levando à equação característica ρ(R) - z σ(R) = 0.",
                                    "Para passos iniciais, discuta valores starting (ex: Runge-Kutta), mas foque na raiz principal R(z).",
                                    "Resolva para um caso m=1 (ex: trapezoidal): ρ(R)=R-1, σ(R)=1/2 (R+1)."
                                  ],
                                  "verification": "Derive a equação característica ρ(R) = z σ(R) corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora simbólica (Wolfram Alpha ou SymPy), papel quadriculado",
                                  "tips": "Fatore z para isolar raízes; verifique consistência expandindo em série de Taylor.",
                                  "learningObjective": "Transformar LMM em equação de recorrência linear para análise de estabilidade.",
                                  "commonMistakes": "Esquecer fator h em z=hλ; não assumir forma geométrica y_{n+k}=R^k."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular R(z) e verificar a condição de estabilidade |R(z)| ≤ 1",
                                  "subSteps": [
                                    "Resolva ρ(R) - z σ(R) = 0 para R(z), selecionando a raiz principal (R(0)=1).",
                                    "Para trapezoidal: R(z) = (1 + z/2)/(1 - z/2), confirme limite z→0 é 1.",
                                    "Plote ou avalie |R(z)| no semiplano esquerdo Re(z)≤0.",
                                    "Verifique estabilidade: |R(z)| ≤1 para Re(z)≤0 (A-estável para este método).",
                                    "Teste pontos: z=-2i, z=-1; compute |R(z)| numericamente."
                                  ],
                                  "verification": "Calcule R(z) para z dado e confirme |R(z)| ≤1 quando Re(z)<0.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software de plotagem (MATLAB/Python com matplotlib), tabela de valores z",
                                  "tips": "Use expansão em fração parcial para análise assintótica em |z| grande.",
                                  "learningObjective": "Computar explicitamente o fator de amplificação e aplicar critério de estabilidade absoluta.",
                                  "commonMistakes": "Escolher raiz errada de σ(R)=0 (parasitas); ignorar singularidades em z=2 para trapezoidal."
                                }
                              ],
                              "practicalExample": "Para o método trapezoidal: y_{n+1} - y_n = (h/2)(λ y_{n+1} + λ y_n). Resolva para R(z) = y_{n+1}/y_n = (1 + z/2)/(1 - z/2), onde z = hλ. Para λ=-1, h=1 (z=-1), R(-1)=(1-0.5)/(1+0.5)=0.5/1.5=1/3, |R|=1/3<1, estável.",
                              "finalVerifications": [
                                "Deriva corretamente R(z) para método dado.",
                                "Confirma R(0)=1 e R'(0)=1 para consistência de ordem 1.",
                                "Avalia |R(z)| ≤1 para pelo menos 3 pontos no semiplano esquerdo.",
                                "Identifica região de estabilidade absoluta.",
                                "Explica impacto de passos iniciais na estabilidade global.",
                                "Compara com solução exata e^{z}."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da equação característica (100% correto).",
                                "Correta resolução de R(z) e seleção da raiz principal.",
                                "Análise qualitativa/quantitativa de |R(z)| no disco unitário.",
                                "Uso apropriado de z=hλ com exemplos numéricos.",
                                "Clareza na verificação de estabilidade absoluta.",
                                "Identificação de limitações (ex: stiff problems)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores harmônicos (λ=iω).",
                                "Engenharia: Modelagem de circuitos RLC com EDOs stiff.",
                                "Computação: Implementação de solvers numéricos em Python (scipy.integrate).",
                                "Química: Cinética reacional com decaimento exponencial.",
                                "Economia: Modelos dinâmicos lineares em finanças."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional) ou previsão meteorológica, calcular R(z) garante que perturbações numéricas não amplifiquem em problemas stiff, evitando crashes em software como ANSYS ou ECMWF models."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Região de Estabilidade",
                        "description": "Região no plano complexo z = hλ onde o método é estável, essencial para métodos de passo múltiplo em problemas com autovalores variados.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Construir a região de estabilidade",
                            "description": "Desenhar e interpretar a região de estabilidade para métodos explícitos e implícitos, como trapezoidal e backward differentiation formulas (BDF).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar a função de amplificação R(z) para métodos específicos",
                                  "subSteps": [
                                    "Revise a fórmula do método trapezoidal: (y_{n+1} - y_n)/h = (f(t_n, y_n) + f(t_{n+1}, y_{n+1}))/2",
                                    "Aplique o teste de estabilidade linear no problema modelo y' = λy, levando a y_{n+1} = R(hλ) y_n",
                                    "Derive R(z) = (1 + z/2)/(1 - z/2) para trapezoidal",
                                    "Derive R(z) = 1/(1 - z) para BDF1 (Backward Euler) e estenda para BDF2: (1 - (4/3)z)^{-1} * (1 + (2/3)z)",
                                    "Verifique linearidade e consistência das derivações"
                                  ],
                                  "verification": "Confirme que R(0) = 1 e R'(0) = 1 para consistência de ordem 1",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora simbólica ou SymPy em Python",
                                    "Referência: Burden & Faires, Numerical Analysis"
                                  ],
                                  "tips": "Comece com métodos de ordem baixa para validar antes de BDFs mais complexos",
                                  "learningObjective": "Entender como a estrutura do método multistep gera R(z)",
                                  "commonMistakes": [
                                    "Esquecer o denominador implícito",
                                    "Confundir z = hλ com λh",
                                    "Ignorar termos de ordem superior"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e analisar a região de estabilidade teoricamente",
                                  "subSteps": [
                                    "Defina a região S = {z ∈ ℂ : |R(z)| ≤ 1, Re(z) ≤ 0}",
                                    "Analise |R(iy)| ≤ 1 para y ∈ ℝ, y ≤ 0 (eixo imaginário negativo)",
                                    "Para trapezoidal, resolva |(1 + i y/2)/(1 - i y/2)| = 1, simplificando para o círculo |z + 1| = 1",
                                    "Para BDF1, mostre que S é o semiplano externo ao círculo |z + 1| = 1",
                                    "Compare com método explícito como Euler forward: R(z) = 1 + z, disco |z| ≤ 1"
                                  ],
                                  "verification": "Esboce analiticamente as fronteiras e verifique pontos teste como z = -2 + 0i",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha quadriculada",
                                    "Software de álgebra como Mathematica ou papel"
                                  ],
                                  "tips": "Use simetria complexa: |R(z)| = |R(\bar{z})| para métodos reais",
                                  "learningObjective": "Identificar diferenças entre regiões A-estável (BDFs) e não A-estável (explícitos)",
                                  "commonMistakes": [
                                    "Confundir região de estabilidade absoluta com relativa",
                                    "Plotar apenas eixo real",
                                    "Ignorar semiplano esquerdo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir numericamente a fronteira da região",
                                  "subSteps": [
                                    "Crie uma grade no semiplano esquerdo: Re(z) de -10 a 0, Im(z) de -10 a 10",
                                    "Compute |R(z)| para cada ponto da grade usando código Python/MATLAB",
                                    "Identifique pontos onde |R(z)| = 1 (fronteira) via contour plot ou interpolação",
                                    "Preencha a região interna |R(z)| ≤ 1",
                                    "Valide com pontos conhecidos, ex: trapezoidal cobre disco unitário à esquerda"
                                  ],
                                  "verification": "Gere plot onde 95% dos pontos de teste atendem |R(z)| ≤ 1 dentro da região",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python (numpy, matplotlib)",
                                    "Ou MATLAB/Octave",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use meshgrid com 200x200 pontos para resolução fina; evite overflow com zclip",
                                  "learningObjective": "Dominar visualização computacional de regiões complexas",
                                  "commonMistakes": [
                                    "Grade muito grosseira levando a fronteiras irregulares",
                                    "Incluir semiplano direito",
                                    "Escala inadequada no plot"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e comparar regiões para métodos explícitos e implícitos",
                                  "subSteps": [
                                    "Sobreponha plots de trapezoidal, BDF1, BDF2 e Euler forward",
                                    "Analise tamanho e formato: explícitos limitados a disco pequeno, implícitos A-estáveis",
                                    "Discuta implicações para problemas stiff (λ com |Re(λ)| grande)",
                                    "Teste estabilidade em exemplo numérico simples y' = -50y",
                                    "Documente vantagens de implícitos em step sizes maiores"
                                  ],
                                  "verification": "Explique verbalmente por que BDFs são preferidos para stiff ODEs",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do step 3 estendido",
                                    "Solver ODE como scipy.integrate.odeint"
                                  ],
                                  "tips": "Use logscale para |λh| grande; compare erros numéricos",
                                  "learningObjective": "Aplicar conceitos de estabilidade a seleção de métodos",
                                  "commonMistakes": [
                                    "Atribuir A-estabilidade a explícitos",
                                    "Ignorar custos computacionais implícitos",
                                    "Não testar numericamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e documentar a construção",
                                  "subSteps": [
                                    "Compile plots em relatório com legendas claras",
                                    "Resuma propriedades: A-estável? L-estável? Ordem?",
                                    "Crie tabela comparativa de regiões (raio, formato)",
                                    "Discuta limitações para métodos de ordem alta (BDF >2 instáveis)",
                                    "Prepare apresentação ou handout"
                                  ],
                                  "verification": "Relatório auto-contido permite reprodução independente",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "LaTeX ou Google Docs",
                                    "Plots salvos em alta resolução"
                                  ],
                                  "tips": "Use cores distintas para cada método; inclua zoom em regiões críticas",
                                  "learningObjective": "Comunicar resultados analíticos e numéricos efetivamente",
                                  "commonMistakes": [
                                    "Plots sem escalas ou legendas",
                                    "Omitir derivações",
                                    "Generalizações sem evidência"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa a região para o método trapezoidal: derive R(z) = (1 + z/2)/(1 - z/2), plote numericamente mostrando o disco |z + 1| ≤ 1 no semiplano esquerdo. Simule y' = -100y + sin(t) com h=0.1 e verifique estabilidade vs Euler forward (instável).",
                              "finalVerifications": [
                                "R(z) derivada corretamente para trapezoidal e BDF1/2",
                                "Plots mostram regiões precisas com fronteiras suaves",
                                "Comparação destaca superioridade de implícitos para stiff",
                                "Teste numérico confirma ausência de oscilações",
                                "Relatório inclui interpretações qualitativas e quantitativas",
                                "Conceitos de A-estabilidade explicados com exemplos"
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação de R(z) (equações corretas, 30%)",
                                "Qualidade dos plots numéricos (resolução, legibilidade, 25%)",
                                "Análise comparativa profunda (stiff vs não-stiff, 20%)",
                                "Validações numéricas e interpretações (20%)",
                                "Clareza e completude do relatório (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos",
                                "Programação: Visualização complexa com numpy/matplotlib",
                                "Engenharia: Solvers em controle de sistemas stiff",
                                "Computação Científica: Otimização de ODE solvers",
                                "Matemática Aplicada: Análise complexa em numerics"
                              ],
                              "realWorldApplication": "Em software como COMSOL ou ANSYS para simulações de dinâmica de fluidos com problemas stiff (reações químicas rápidas), onde BDFs permitem steps maiores sem instabilidade, reduzindo tempo computacional em 10x vs explícitos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Comparar regiões de estabilidade",
                            "description": "Comparar regiões de estabilidade entre métodos de passo simples (ex: Euler) e múltiplo, identificando vantagens para intervalos longos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar regiões de estabilidade para métodos de passo simples (ex: Euler)",
                                  "subSteps": [
                                    "Estude a definição de região de estabilidade para métodos lineares multistep e Runge-Kutta.",
                                    "Derive ou lembre a região de estabilidade do método de Euler explícito usando o teste do método de Dahlquist.",
                                    "Plote a região de estabilidade do Euler no plano complexo hλ.",
                                    "Identifique limitações do Euler para problemas stiff (valores grandes de |λ|).",
                                    "Calcule exemplos numéricos simples para uma EDO y' = -λy com λ > 0 grande."
                                  ],
                                  "verification": "Plotar corretamente a região de estabilidade do Euler e simular uma EDO stiff mostrando instabilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Software MATLAB ou Python (SciPy/NumPy)",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Comece com o teste de estabilidade linear: |R(z)| ≤ 1 onde z = hλ.",
                                  "learningObjective": "Compreender e visualizar a pequena região de estabilidade absoluta do método de Euler.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com relativa",
                                    "Ignorar o semiplano esquerdo no plano complexo",
                                    "Usar passos h muito grandes sem verificar |hλ| < 2"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar regiões de estabilidade para métodos de passo múltiplo (ex: RK4, métodos implicitos)",
                                  "subSteps": [
                                    "Revise a amplificação de estabilidade R(z) para métodos Runge-Kutta de ordem superior.",
                                    "Derive ou consulte as regiões de estabilidade para RK2, RK4 e métodos A-stable como Backward Euler.",
                                    "Plote as regiões no plano complexo, destacando diferenças em tamanho e forma.",
                                    "Compare com métodos multistep lineares como trapezoidal ou BDF.",
                                    "Teste numericamente uma EDO stiff com cada método."
                                  ],
                                  "verification": "Gerar plots comparativos das regiões e demonstrar estabilidade em simulações stiff.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação SciPy odeint/solve_ivp",
                                    "Folhas de fórmulas de estabilidade (Butcher tableau)",
                                    "Computador com Python/MATLAB"
                                  ],
                                  "tips": "Use sympy ou tabelas prontas para R(z) de métodos RK; foque em métodos L-stable para stiff.",
                                  "learningObjective": "Dominar as regiões maiores e mais favoráveis de métodos de passo múltiplo.",
                                  "commonMistakes": [
                                    "Achar que todos RK são A-stable (só RK1 implícito é)",
                                    "Não distinguir ordem de precisão de estabilidade",
                                    "Plotar incorretamente o eixo imaginário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar graficamente e analiticamente as regiões de estabilidade",
                                  "subSteps": [
                                    "Sobreponha plots das regiões de Euler, RK4 e Backward Euler no plano hλ.",
                                    "Calcule raios de inclusão ou área das regiões para quantificação.",
                                    "Analise interseções com o semiplano esquerdo e implicações para h máximo.",
                                    "Discuta trade-offs: precisão vs. estabilidade.",
                                    "Crie uma tabela resumindo tamanhos, A-stabilidade e L-estabilidade."
                                  ],
                                  "verification": "Produzir um gráfico comparativo com legendas e tabela de métricas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com Matplotlib/Plotly para plots complexos",
                                    "Tabelas de referência de Burden",
                                    "Calculadora para raios"
                                  ],
                                  "tips": "Use contour plots para visualizar |R(z)|=1; normalize por ordem do método.",
                                  "learningObjective": "Realizar comparações quantitativas e qualitativas entre regiões.",
                                  "commonMistakes": [
                                    "Escalas erradas nos plots (use log para |z|)",
                                    "Ignorar direção de estabilidade para λ real negativo",
                                    "Confundir estabilidade com consistência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar vantagens para intervalos longos e problemas stiff",
                                  "subSteps": [
                                    "Simule EDOs não-stiff e stiff com diferentes métodos e h fixo longo.",
                                    "Meça erros e tempo de computação para intervalos [0,T] com T grande.",
                                    "Explique por que métodos com regiões maiores permitem h maior sem oscilação.",
                                    "Discuta adaptação adaptativa de h baseada em estabilidade.",
                                    "Conclua com recomendações de escolha de método."
                                  ],
                                  "verification": "Relatório com simulações mostrando divergência de Euler vs. convergência de RK implícito em h longo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Códigos Python de solvers ODE",
                                    "EDOs teste: y'=-50y + sin(t), y'=λ(y-1)^2",
                                    "Gráficos de solução exata vs. numérica"
                                  ],
                                  "tips": "Use problemas stiff padrão como van der Pol com μ grande.",
                                  "learningObjective": "Aplicar comparações para selecionar métodos ótimos em cenários reais.",
                                  "commonMistakes": [
                                    "Não usar solução exata para benchmark",
                                    "Escolher h fixo sem testar limite de estabilidade",
                                    "Subestimar custo computacional de implícitos"
                                  ]
                                }
                              ],
                              "practicalExample": "Compare o método de Euler e RK4 para resolver y' = -100y, y(0)=1 no intervalo [0,1]. Use h=0.05 (longo para Euler). Euler diverge oscilando; RK4 permanece estável mas com erro; Backward Euler é preciso e estável.",
                              "finalVerifications": [
                                "Pode plotar e interpretar regiões de estabilidade de pelo menos 3 métodos.",
                                "Simulações numéricas mostram instabilidade de Euler em hλ > 2.",
                                "Identifica corretamente métodos A-stable para problemas stiff.",
                                "Cria tabela comparativa com vantagens para intervalos longos.",
                                "Explica impacto em tempo de simulação para T grande.",
                                "Recomenda método adequado para EDO stiff dada restrição de h."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos plots de regiões (forma e limites corretos: 90%)",
                                "Análise qualitativa/quantitativa das comparações (80%)",
                                "Simulações numéricas com interpretação de resultados (85%)",
                                "Identificação clara de vantagens para h longo/stiff (90%)",
                                "Uso correto de terminologia (A-stable, L-stable, etc.: 95%)",
                                "Relatório estruturado com tabelas/gráficos (80%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos (equações diferenciais stiff).",
                                "Engenharia: Modelagem de circuitos RLC ou reações químicas com escalas múltiplas.",
                                "Computação: Implementação eficiente de solvers ODE em bibliotecas como SciPy.",
                                "Estatística: Análise de sensibilidade em modelos estocásticos com stiff deterministic part."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, comparar regiões de estabilidade permite escolher solvers para simular trajetórias de foguetes com termos stiff de atrito, permitindo passos h maiores e simulações mais rápidas para missões de longa duração."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Avaliar estabilidade condicional",
                            "description": "Determinar o passo de tempo máximo h para estabilidade em problemas com autovalores reais negativos, usando a interseção da região com o eixo negativo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Região de Estabilidade",
                                  "subSteps": [
                                    "Defina região de estabilidade para métodos numéricos de EDOs.",
                                    "Explique o papel dos autovalores reais negativos no teste de estabilidade.",
                                    "Descreva como a região de estabilidade é plotada no plano complexo z = hλ.",
                                    "Identifique o eixo real negativo como foco para problemas com autovalores reais negativos.",
                                    "Estude o teste de Dahlquist para estabilidade absoluta."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e desenhe um esboço simples da região de estabilidade do método de Euler explícito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de EDOs)",
                                    "Papel e caneta para esboços",
                                    "Gráficos de regiões de estabilidade online"
                                  ],
                                  "tips": "Comece com métodos simples como Euler explícito para visualizar melhor.",
                                  "learningObjective": "Compreender a base teórica da estabilidade condicional em métodos de passo múltiplo.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com relativa",
                                    "Ignorar o fator hλ na transformação z"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Autovalores e Condições do Problema",
                                  "subSteps": [
                                    "Extraia a matriz jacobiana do problema de EDO e compute seus autovalores.",
                                    "Selecione o autovalor real negativo com maior magnitude |λ_max|.",
                                    "Verifique se todos os autovalores relevantes estão no semiplano negativo.",
                                    "Calcule o espectro de λ para o problema stiff.",
                                    "Documente λ_max como o limitante para h."
                                  ],
                                  "verification": "Liste os autovalores computados e destaque λ_max com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software MATLAB/Python (eig() ou numpy.linalg.eig)",
                                    "Problema de EDO exemplo"
                                  ],
                                  "tips": "Use solvers simbólicos se possível para autovalores exatos.",
                                  "learningObjective": "Identificar corretamente o autovalor dominante para restrições de estabilidade.",
                                  "commonMistakes": [
                                    "Escolher autovalor com menor magnitude",
                                    "Não considerar o sinal negativo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Interseção da Região de Estabilidade com o Eixo Negativo",
                                  "subSteps": [
                                    "Obtenha ou plote a região de estabilidade do método específico (ex: Adams-Bashforth).",
                                    "Localize o ponto de interseção mais à esquerda β no eixo real negativo.",
                                    "Determine o comprimento do segmento estável no eixo negativo (de 0 a β).",
                                    "Confirme que z = hλ deve estar dentro dessa interseção para estabilidade.",
                                    "Anote β como o limite intrínseco do método."
                                  ],
                                  "verification": "Desenhe ou descreva a interseção e indique β numericamente para o método.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabelas de regiões de estabilidade (livro ou PDF)",
                                    "Software de plotagem (MATLAB bode ou Python matplotlib)"
                                  ],
                                  "tips": "Memorize β para métodos comuns: Euler explícito β=-2, Trapezoidal ilimitado.",
                                  "learningObjective": "Mapear a geometria da região de estabilidade para o caso real negativo.",
                                  "commonMistakes": [
                                    "Confundir interseção esquerda com direita",
                                    "Usar região A-estável incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e Validar o Passo de Tempo Máximo h_max",
                                  "subSteps": [
                                    "Aplique a fórmula h_max = |β| / |λ_max|.",
                                    "Compute numericamente h_max usando valores de β e λ_max.",
                                    "Teste estabilidade simulando o método com h = 0.9 h_max e h = 1.1 h_max.",
                                    "Ajuste h_max se houver outros autovalores ou modos oscilatórios.",
                                    "Registre h_max final com margem de segurança (ex: 0.8 h_max)."
                                  ],
                                  "verification": "Execute simulação numérica e compare soluções com h variando; mostre gráfico de erro.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para solver numérico",
                                    "Problema teste stiff (ex: y' = -50y)"
                                  ],
                                  "tips": "Sempre inclua fator de segurança para erros de arredondamento.",
                                  "learningObjective": "Derivar e validar h_max de forma precisa e prática.",
                                  "commonMistakes": [
                                    "Esquecer o módulo absoluto",
                                    "Não testar numericamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Documentar em um Caso Completo",
                                  "subSteps": [
                                    "Integre todos os passos em um problema real de EDO stiff.",
                                    "Gere relatório com cálculos, plots e h_max recomendado.",
                                    "Compare com métodos incondicionalmente estáveis.",
                                    "Discuta implicações para problemas stiff.",
                                    "Arquive para reutilização em simulações futuras."
                                  ],
                                  "verification": "Produza um relatório de 1 página com todos os elementos chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Template de relatório",
                                    "Ferramentas de documentação (LaTeX ou Markdown)"
                                  ],
                                  "tips": "Use versionamento de código para reprodutibilidade.",
                                  "learningObjective": "Sintetizar o processo em uma avaliação completa de estabilidade.",
                                  "commonMistakes": [
                                    "Omitir validação numérica",
                                    "Ignorar contexto stiff"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método de Euler explícito aplicado a y' = λy com λ = -50 (problema stiff), a região de estabilidade intersecta o eixo negativo em [-2, 0]. Logo, β = -2, h_max = 2 / 50 = 0.04. Simule com h=0.039 (estável) vs h=0.041 (instável) e observe oscilações.",
                              "finalVerifications": [
                                "Calcule corretamente β para pelo menos 3 métodos comuns.",
                                "Derive h_max exato para um problema dado com λ_max conhecido.",
                                "Simule e identifique instabilidade visualmente em plots.",
                                "Explique o impacto de h > h_max em termos de erro.",
                                "Compare h_max entre métodos explícito e implícito.",
                                "Ajuste h_max para múltiplos autovalores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de β (erro < 5%).",
                                "Correção na fórmula h_max = |β| / |λ_max|.",
                                "Validação numérica com simulações comparativas.",
                                "Clareza na documentação de passos e plots.",
                                "Consideração de fatores stiff e segurança.",
                                "Profundidade na análise de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de decaimento radioativo com EDOs stiff.",
                                "Engenharia: Controle de sistemas dinâmicos (estabilidade em PLCs).",
                                "Computação: Otimização de solvers numéricos em SciPy.",
                                "Química: Modelagem de reações stiff em cinética química."
                              ],
                              "realWorldApplication": "Em simulações de engenharia aeroespacial, avaliar h_max garante estabilidade em modelos de fluidodinâmica stiff, evitando crashes computacionais caros e permitindo previsões precisas de trajetórias de voo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Problemas Stiff e Tratamento",
                        "description": "Equações diferenciais stiff com escalas de tempo díspares, exigindo métodos com regiões de estabilidade amplas, e estratégias de tratamento numérico.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Identificar problemas stiff",
                            "description": "Reconhecer características de sistemas stiff, como rigidez (razão de autovalores) e sintomas em métodos explícitos (passos muito pequenos).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição conceitual de problemas stiff",
                                  "subSteps": [
                                    "Estude a definição: problemas stiff ocorrem em sistemas de EDOs com escalas temporais muito diferentes (componentes rápidos e lentos).",
                                    "Leia sobre a rigidez como a razão entre o maior e o menor autovalor em módulo (λ_max / λ_min >> 1).",
                                    "Analise exemplos iniciais de sistemas lineares onde isso se aplica.",
                                    "Compare com problemas não-stiff, onde a razão é próxima de 1.",
                                    "Anote as implicações para métodos numéricos explícitos."
                                  ],
                                  "verification": "Resuma em 3 frases a definição e causa principal de stiffnes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (cap. EDOs stiff)",
                                    "Notas de aula sobre estabilidade"
                                  ],
                                  "tips": "Use analogias como molas rígidas vs. flexíveis para visualizar escalas.",
                                  "learningObjective": "Definir precisamente o que caracteriza um problema stiff.",
                                  "commonMistakes": "Confundir stiff com instável; stiff é sobre rigidez, não necessariamente instabilidade inerente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a razão de autovalores para sistemas lineares",
                                  "subSteps": [
                                    "Formule o sistema linear y' = Ay e encontre a matriz jacobiana A.",
                                    "Calcule os autovalores de A usando ferramentas como MATLAB ou Python (numpy.linalg.eig).",
                                    "Determine os autovalores reais negativos com maior e menor módulo.",
                                    "Compute a razão |λ_max / λ_min| e classifique: stiff se > 1000.",
                                    "Teste com matrizes de exemplo 2x2."
                                  ],
                                  "verification": "Calcule corretamente a razão para uma matriz dada e classifique o sistema.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/Jupyter com NumPy",
                                    "Matrizes de exemplo de stiff systems"
                                  ],
                                  "tips": "Sempre verifique se autovalores são reais e negativos para estabilidade absoluta.",
                                  "learningObjective": "Quantificar a rigidez via razão de autovalores.",
                                  "commonMistakes": "Ignorar autovalores complexos ou usar módulo incorreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer sintomas em métodos explícitos",
                                  "subSteps": [
                                    "Implemente um método explícito como Euler forward em um sistema stiff.",
                                    "Observe o passo h necessário para estabilidade: h < 2 / |λ_max|.",
                                    "Compare soluções com h pequeno vs. grande: oscilações ou divergência.",
                                    "Registre plots de solução numérica vs. analítica.",
                                    "Identifique sintomas: passos h muito pequenos para precisão."
                                  ],
                                  "verification": "Gere plot mostrando instabilidade com h inadequado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com Matplotlib e SciPy",
                                    "Exemplo stiff: y' = -1000y + sin(t)"
                                  ],
                                  "tips": "Use log-scale no eixo y para visualizar componentes rápidos.",
                                  "learningObjective": "Associar sintomas computacionais à stiffnes.",
                                  "commonMistakes": "Atribuir erro a precisão do método em vez de stiffnes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar problemas stiff de não-stiff e diagnosticar",
                                  "subSteps": [
                                    "Selecione pares de problemas: um stiff e um não-stiff.",
                                    "Aplique critérios: razão autovalores e teste numérico.",
                                    "Crie uma tabela comparativa de características e sintomas.",
                                    "Teste em sistema não-linear linearizando via jacobiano.",
                                    "Pratique diagnóstico em 3 problemas variados."
                                  ],
                                  "verification": "Diagnostique corretamente 3 sistemas como stiff ou não.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de problemas teste",
                                    "Código Python reutilizável"
                                  ],
                                  "tips": "Para não-lineares, avalie jacobiano em equilíbrio.",
                                  "learningObjective": "Diagnosticar stiffnes de forma confiável.",
                                  "commonMistakes": "Classificar como stiff baseado só em erro numérico sem análise."
                                }
                              ],
                              "practicalExample": "Considere o sistema químico stiff: dy1/dt = -1000(y1 - y2), dy2/dt = 0.1(y1 - y2). Calcule autovalores da jacobiana [-1000, 0.1], razão 10^4 >>1 (stiff). Euler explícito requer h<0.002 para estabilidade, confirmando sintomas.",
                              "finalVerifications": [
                                "Calcule razão de autovalores corretamente para sistema dado.",
                                "Identifique sintomas de instabilidade em plot numérico.",
                                "Diferencie stiff de não-stiff em pelo menos 2 exemplos.",
                                "Explique impacto em métodos explícitos.",
                                "Sugira método implícito como solução.",
                                "Diagnostique sistema não-linear via linearização."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e quantificação de stiffnes (razão >1000).",
                                "Correta identificação de sintomas em simulações.",
                                "Uso adequado de ferramentas computacionais.",
                                "Diferenciação clara entre casos stiff e não-stiff.",
                                "Análise qualitativa e quantitativa integrada.",
                                "Comunicação clara de diagnóstico."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de circuitos RC com constantes de tempo díspares.",
                                "Química: Cinética de reações com escalas rápidas/lentas.",
                                "Computação: Otimização de solvers numéricos em SciPy.",
                                "Engenharia: Simulações de controle com polos dominantes."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas industriais, identificar stiffnes permite escolher solvers implícitos como BDF, evitando tempos de computação excessivos e garantindo precisão em processos como combustão ou farmacocinética."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Explicar falha de métodos explícitos em stiff",
                            "description": "Demonstrar por que métodos explícitos como Adams-Bashforth requerem h muito pequeno em problemas stiff devido à região de estabilidade limitada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e características de problemas stiff",
                                  "subSteps": [
                                    "Defina problemas stiff como sistemas de EDOs com escalas temporais muito díspares, onde componentes rápidas decaem rapidamente e componentes lentas evoluem devagar.",
                                    "Identifique indicadores de stiff: razão entre o maior e menor autovalor (em módulo) muito grande, tipicamente >1000.",
                                    "Discuta o modelo teste y' = λ y com Re(λ) < 0 e |λ| grande, representando decaimento exponencial rápido.",
                                    "Compare com problemas não-stiff onde todos os modos decaem em escalas similares.",
                                    "Revise soluções analíticas para ilustrar o comportamento esperado."
                                  ],
                                  "verification": "Escreva uma definição precisa de problema stiff e dê um exemplo simples com λ = -1000.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), software como MATLAB ou Python (NumPy/SciPy).",
                                  "tips": "Use gráficos de solução analítica y(t) = y0 exp(λ t) para visualizar decaimento rápido.",
                                  "learningObjective": "Identificar e caracterizar problemas stiff em EDOs.",
                                  "commonMistakes": "Confundir stiff com não-linearidade; stiff é sobre rigidez linear."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a região de estabilidade de métodos explícitos",
                                  "subSteps": [
                                    "Explique região de estabilidade como o conjunto de hλ no plano complexo onde o método é estável para y' = λ y.",
                                    "Desenhe ou descreva a região de estabilidade para Euler explícito: disco |1 + hλ| < 1.",
                                    "Estenda para métodos multistep explícitos como Adams-Bashforth: regiões limitadas no semiplano esquerdo.",
                                    "Calcule o raio de estabilidade: para AB2, aproximadamente |hλ| < 1 para estabilidade.",
                                    "Compare com métodos implícitos que têm regiões ilimitadas."
                                  ],
                                  "verification": "Plote ou descreva a região de estabilidade de Adams-Bashforth de ordem 2 e identifique seu limite.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel gráfico ou software de plotagem (MATLAB: stability_region), tabelas de regiões de estabilidade.",
                                  "tips": "Lembre-se: estabilidade requer |amplificação| ≤ 1; teste numericamente hλ na fronteira.",
                                  "learningObjective": "Entender limitações geométricas da estabilidade em métodos explícitos.",
                                  "commonMistakes": "Ignorar que região é para hλ, não λ absoluto; h deve se ajustar a λ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar falha de Adams-Bashforth em problemas stiff",
                                  "subSteps": [
                                    "Implemente Adams-Bashforth de ordem 2 para y' = -100 y, y(0)=1.",
                                    "Teste com h = 0.01 (adequado para não-stiff), observe precisão.",
                                    "Aumente h para 0.05; note oscilações ou divergência devido a h|λ| > limite de estabilidade.",
                                    "Calcule limite: para AB2, h < ~1.5/|λ| ≈ 0.015 para λ=-100.",
                                    "Compare passos necessários: para t=1, h pequeno implica milhares de passos."
                                  ],
                                  "verification": "Execute simulação numérica mostrando divergência para h inadequado e convergência para h pequeno.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (SciPy odeint para referência, código custom para AB), Jupyter Notebook.",
                                  "tips": "Use solução exata exp(-100t) como benchmark; plote erro vs. h.",
                                  "learningObjective": "Quantificar por que h deve ser pequeno em stiff.",
                                  "commonMistakes": "Usar h fixo sem escalar com |λ|; confundir erro de truncagem com instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar razões da falha e implicações práticas",
                                  "subSteps": [
                                    "Resuma: região limitada força h << 1/|λ_max| para capturar modos rápidos sem oscilar.",
                                    "Discuta custo computacional: passos excessivos tornam método ineficiente.",
                                    "Contraste com implícitos (ex: BDF) que permitem h maior.",
                                    "Discuta detecção de stiff (norma de autovalores).",
                                    "Conclua necessidade de métodos stiff-adequados."
                                  ],
                                  "verification": "Escreva parágrafo explicando falha com equação h < c / |λ| onde c é constante da região.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas anteriores, exemplos numéricos salvos.",
                                  "tips": "Use analogia: modo rápido como freio de mão; explícito 'patina' se passo grande.",
                                  "learningObjective": "Explicar conceitualmente e quantitativamente a falha.",
                                  "commonMistakes": "Atribuir falha só a precisão, não estabilidade."
                                }
                              ],
                              "practicalExample": "Considere y' = -1000(y - sin(t)), y(0)=1 (stiff com componente parasitária rápida). Usando Adams-Bashforth ordem 2 com h=0.01, solução diverge após t=0.1 devido a h|λ|≈10 > limite (~1.4); reduza h para 0.0005 para estabilidade, exigindo 2000x mais passos que implícito.",
                              "finalVerifications": [
                                "Explica corretamente região de estabilidade limitada de métodos explícitos.",
                                "Demonstra numericamente divergência em exemplo stiff com h inadequado.",
                                "Calcula corretamente limite h < k / |λ_max| para método específico.",
                                "Compara custo computacional com métodos implícitos.",
                                "Identifica quando problema é stiff via autovalores."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição de stiff e estabilidade (30%)",
                                "Análise quantitativa: cálculo de limites e simulações (30%)",
                                "Clareza na demonstração: gráficos e exemplos concretos (20%)",
                                "Implicações práticas: discussão de eficiência (10%)",
                                "Sintese: explicação coesa da falha (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RLC stiff (diferenciais com constantes díspares).",
                                "Engenharia Química: Reações em série com taxas muito diferentes.",
                                "Computação Científica: Otimização de solvers em bibliotecas como SciPy.",
                                "Matemática Aplicada: Análise de autovalores em álgebra linear."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular ou controle de aeronaves, problemas stiff surgem; métodos explícitos falham em tempo real, exigindo solvers implícitos como Gear para eficiência em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Aplicar métodos implícitos para stiff",
                            "description": "Implementar e analisar métodos A-estáveis ou L-estáveis como BDF e Gear para resolver eficientemente problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Problemas Stiff e Selecionar Método Implícito Adequado",
                                  "subSteps": [
                                    "Analise a equação diferencial ordinária (EDO) para identificar rigidez, verificando autovalores com partes reais grandes e negativas.",
                                    "Classifique o problema como stiff com base no índice de rigidez (razão entre |λ_max| e |λ_min| > 1000).",
                                    "Escolha método A-estável (BDF2) ou L-estável (BDF3 ou Gear) com base na ordem desejada e estabilidade.",
                                    "Revise propriedades: A-estabilidade (região de estabilidade inclui meia-esquerda do plano complexo) e L-estabilidade (damping para λh → -∞).",
                                    "Documente justificativa da escolha em um relatório curto."
                                  ],
                                  "verification": "Confirme identificando corretamente rigidez em um exemplo dado e justificando escolha do método.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), software como MATLAB ou Python (SciPy).",
                                  "tips": "Use plot de componentes da solução para visualizar decaimento rápido.",
                                  "learningObjective": "Compreender critérios para detectar stiff e selecionar métodos implícitos apropriados.",
                                  "commonMistakes": "Confundir stiff com oscilatório; ignorar ordem do método para precisão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular e Configurar o Método Implícito (BDF ou Gear)",
                                  "subSteps": [
                                    "Derive a fórmula BDFk: ∑_{j=0}^k α_j y_{n+j} = h β_k f(t_{n+k}, y_{n+k}).",
                                    "Para Gear (multistep implícito), configure polinômio gerador e coeficientes via método de Adams-Moulton adaptado.",
                                    "Escreva o sistema não-linear para y_{n+1}: F(y_{n+1}) = y_{n+1} - y_n - h φ(t_{n+1}, y_{n+1}, y_n) = 0.",
                                    "Prepare condições iniciais usando método explícito de alta ordem para primeiros passos.",
                                    "Teste formulação manualmente em EDO simples não-stiff para validar."
                                  ],
                                  "verification": "Derive corretamente fórmulas para k=2 e k=3 e resolva sistema para passo inicial.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de derivação, calculadora simbólica (SymPy), referências teóricas.",
                                  "tips": "Memorize coeficientes padrão de tabelas BDF para agilizar.",
                                  "learningObjective": "Dominar derivação e setup matemático de métodos implícitos.",
                                  "commonMistakes": "Erro nos coeficientes α e β; esquecer multistep nature (precisa de valores prévios)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Numericamente e Resolver Sistema Não-Linear",
                                  "subSteps": [
                                    "Implemente em código (Python/MATLAB) usando Newton-Raphson para resolver F(y) = 0 em cada passo.",
                                    "Inclua Jacobiano analítico ou numérico para aceleração da convergência.",
                                    "Aplique controle adaptativo de passo: reduza h se ||Δy|| > tol, aumente se convergência rápida.",
                                    "Integre com solver existente (ex: ode15s no MATLAB) para comparação.",
                                    "Execute simulação para intervalo [0, T] e plote solução."
                                  ],
                                  "verification": "Código roda sem erros e converge para solução conhecida em 10 passos.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (NumPy, SciPy), MATLAB, exemplo EDO stiff: y' = -100(y-1) + sin(t), y(0)=1.",
                                  "tips": "Use tolerância 1e-6 para Newton; limite iterações a 20 por passo.",
                                  "learningObjective": "Implementar robustamente métodos implícitos com resolução não-linear.",
                                  "commonMistakes": "Jacobiano incorreto causando não-convergência; passo inicial muito grande."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Estabilidade, Precisão e Eficiência",
                                  "subSteps": [
                                    "Calcule erro global comparando com solução exata ou referência de alta precisão.",
                                    "Avalie estabilidade plotando região no plano complexo e testando com autovalores variados.",
                                    "Meça eficiência: número de passos e função avaliações vs. método explícito (RK4).",
                                    "Analise damping em L-estável: verifique |A(∞)| < 1 para modos rápidos.",
                                    "Gere relatório com gráficos de erro vs. h e custo computacional."
                                  ],
                                  "verification": "Relatório mostra eficiência >10x sobre explícito e erro <1e-4.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (Matplotlib), dados de simulação anterior.",
                                  "tips": "Use logscale para plots de erro; compare com ode45 (explícito).",
                                  "learningObjective": "Avaliar performance de métodos implícitos em contextos stiff.",
                                  "commonMistakes": "Ignorar custo de Jacobiano; confundir erro local com global."
                                }
                              ],
                              "practicalExample": "Resolva y' = -1000(y - cos(t)) + sin(t), y(0)=0 no [0,1]. Use BDF2: compare passos necessários vs. RK4 (milhares vs. ~50), mostrando estabilidade com h=0.1.",
                              "finalVerifications": [
                                "Solução converge com passos razoáveis (h>0.01) onde explícito falha.",
                                "Erro global <1e-5 em solução de referência.",
                                "Número de avaliações de f < 10x passos totais.",
                                "Região de estabilidade inclui Re(z)<0.",
                                "Damping efetivo para componentes rápidos (amortecimento >90%).",
                                "Código reutilizável para outras EDOs stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro <1e-4 em norma L2.",
                                "Eficiência: Passos <20% de explícito equivalente.",
                                "Estabilidade: Sem oscilações espúrias em testes stiff.",
                                "Implementação: Código limpo, comentado, com Jacobiano.",
                                "Análise: Gráficos e métricas quantitativas claras.",
                                "Justificativa: Correta escolha e derivação teórica."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RLC stiff ou reações químicas.",
                                "Computação: Algoritmos numéricos e otimização não-linear (Newton).",
                                "Engenharia: Simulações dinâmicas em controle de sistemas.",
                                "Matemática Aplicada: Análise de estabilidade linearizada."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos (cinética rígida), circuitos elétricos (capacitores/diodos), ou dinâmica molecular (modos vibracionais rápidos), onde métodos implícitos permitem passos maiores, reduzindo tempo computacional em 100x para previsões industriais precisas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.4",
                            "name": "Controlar passo em problemas stiff",
                            "description": "Discutir adaptação de passo e detecção de rigidez em solvers como ODE45/ODE15s, integrando com estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender problemas stiff e a importância do controle de passo",
                                  "subSteps": [
                                    "Definir problema stiff como sistemas com escalas de tempo muito diferentes (rigidez medida pela razão de autovalores).",
                                    "Explicar por que métodos explícitos como Runge-Kutta falham (instabilidade com passos grandes).",
                                    "Introduzir métodos implícitos (ex.: BDF em ODE15s) e adaptativos para lidar com rigidez.",
                                    "Discutir adaptação de passo: redução automática em regiões rígidas para manter estabilidade.",
                                    "Comparar ODE45 (explícito, Dormand-Prince) e ODE15s (implícito, para stiff)."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando quando usar cada solver e por quê.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação MATLAB ODE45/ODE15s",
                                    "Livro 'Análise Numérica' de Burden & Faires",
                                    "Exemplos gráficos de soluções stiff online"
                                  ],
                                  "tips": "Visualize trajetórias de soluções stiff para intuitar a rigidez.",
                                  "learningObjective": "Entender os fundamentos teóricos da rigidez e o papel do controle de passo na estabilidade.",
                                  "commonMistakes": [
                                    "Confundir rigidez com não-linearidade simples.",
                                    "Subestimar o custo computacional de passos muito pequenos.",
                                    "Ignorar análise de autovalores para detecção prévia."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar rigidez em problemas de EDO",
                                  "subSteps": [
                                    "Calcular autovalores da matriz jacobiana para medir razão de rigidez (λ_max / λ_min >> 1).",
                                    "Testar solver explícito (ODE45): observar falhas como passos minúsculos ou divergência.",
                                    "Usar diagnósticos do solver: verificar mensagens de 'stiff' ou número excessivo de passos.",
                                    "Implementar teste simples: plotar h (passo) vs. tempo e identificar reduções abruptas.",
                                    "Analisar estabilidade local via diagrama de Butcher para métodos usados."
                                  ],
                                  "verification": "Aplicar detecção em um EDO de teste e registrar evidências de rigidez.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com toolbox ODE",
                                    "Script exemplo de jacobiana numérica",
                                    "Artigo sobre detecção de stiff"
                                  ],
                                  "tips": "Comece com problemas conhecidos stiff como y' = -1000(y-1) para prática rápida.",
                                  "learningObjective": "Desenvolver habilidades para identificar rigidez antes da simulação.",
                                  "commonMistakes": [
                                    "Não linearizar corretamente para autovalores.",
                                    "Atribuir falhas a ruído em vez de rigidez.",
                                    "Ignorar tolerâncias que mascaram o problema."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e controlar passo em solvers MATLAB",
                                  "subSteps": [
                                    "Definir opções com odeset: RelTol, AbsTol para precisão; InitialStep, MaxStep para controle manual.",
                                    "Ativar Stats para monitorar número de passos, falhas e tempo gasto.",
                                    "Trocar para ODE15s em casos stiff, ajustando MaxOrder para métodos de ordem baixa.",
                                    "Implementar detecção automática via output do solver e adaptação condicional.",
                                    "Integrar com análise de estabilidade: verificar norma do erro local."
                                  ],
                                  "verification": "Executar solver com opções customizadas e comparar outputs com default.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB instalado",
                                    "Documentação odeset e ode15s",
                                    "Templates de scripts de teste"
                                  ],
                                  "tips": "Use Refine=4 para plots mais suaves sem custo extra.",
                                  "learningObjective": "Dominar parâmetros de controle de passo para otimizar solvers.",
                                  "commonMistakes": [
                                    "Definir tolerâncias muito frouxas, perdendo precisão.",
                                    "Não resetar opções entre testes.",
                                    "Esquecer de capturar output [t,y,te,ye,ie] para diagnósticos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e analisar controle de passo em problemas reais",
                                  "subSteps": [
                                    "Implementar exemplo stiff e aplicar controle de passo adaptativo.",
                                    "Comparar desempenho: tempo de CPU, número de passos, erro vs. solução exata.",
                                    "Ajustar passo manualmente em regiões críticas e avaliar estabilidade.",
                                    "Plotar evolução do passo (h) e identificar correlações com rigidez.",
                                    "Documentar trade-offs entre precisão, eficiência e estabilidade."
                                  ],
                                  "verification": "Gerar relatório com gráficos e métricas comparativas de dois solvers.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB",
                                    "Exemplo Van der Pol stiff",
                                    "Ferramentas de plot como plotyy"
                                  ],
                                  "tips": "Salve saídas em struct para análise posterior com fieldnames.",
                                  "learningObjective": "Aplicar conceitos em prática, integrando detecção e controle.",
                                  "commonMistakes": [
                                    "Não normalizar erros para comparação justa.",
                                    "Sobrepor plots sem legendas claras.",
                                    "Ignorar eventos de parada prematura."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o oscilador de Van der Pol μ=1000: dx/dt = y, dy/dt = μ((1-x²)y - x). Use ODE45 (falha esperada) vs. ODE15s com RelTol=1e-6, MaxStep=0.01. Compare tempo, passos e trajetórias de fase; detecte rigidez via picos em h(t).",
                              "finalVerifications": [
                                "Detectar rigidez corretamente em EDO dado via autovalores ou teste ODE45.",
                                "Configurar odeset para controle de passo otimizado em ODE15s.",
                                "Interpretar diagnósticos do solver (Stats, ie) para adaptações.",
                                "Comparar eficiência e precisão entre solvers explícito/implícito.",
                                "Analisar estabilidade integrando controle de passo com teoria.",
                                "Gerar plots de h(t) mostrando adaptação em regiões stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução (erro < 1e-4 vs. referência).",
                                "Eficiência computacional (tempo < 10x default em stiff).",
                                "Correta detecção e adaptação de rigidez (redução h em >50%).",
                                "Interpretação válida de diagnósticos do solver.",
                                "Integração coerente com conceitos de estabilidade.",
                                "Relatório claro com gráficos e conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas dinâmicos rígidos (osciladores, circuitos).",
                                "Engenharia: Simulações em controle de processos químicos ou elétricos.",
                                "Computação Científica: Otimização de algoritmos numéricos paralelizáveis.",
                                "Matemática Aplicada: Análise de autovalores em estabilidade linear."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos stiff (RC com capacitores grandes), reações químicas rápidas/lentas em reatores, ou modelos biológicos de populações com epidemias, onde controle de passo garante simulações estáveis e eficientes para previsão e design."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.6",
                    "name": "Controle de Passo em Métodos Multistep",
                    "description": "Técnicas adaptativas para ajuste do tamanho do passo visando precisão e eficiência.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.6.1",
                        "name": "Estimadores de Erro Local em Métodos Multistep",
                        "description": "Técnicas para estimar o erro local truncado em um passo de integração nos métodos de passo múltiplo, utilizando abordagens como métodos embebidos de ordens diferentes ou diferenças entre soluções aproximadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.1.1",
                            "name": "Derivar o termo de erro principal local",
                            "description": "Derivar a expressão analítica do erro local principal para métodos multistep lineares multilineares, identificando os coeficientes de ordem p e p+1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a forma geral dos métodos multistep lineares e conceitos de ordem",
                                  "subSteps": [
                                    "Escreva a forma geral do método multistep linear (LMM): ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}).",
                                    "Defina os polinômios de característica ρ(ζ) = ∑ α_j ζ^j e σ(ζ) = ∑ β_j ζ^j.",
                                    "Explique consistência (ρ(1)=σ'(1)=0) e ordem p (condições de ordem até p satisfeitas).",
                                    "Discuta o erro local de truncamento (LET) como a diferença entre solução exata e método assumindo valores anteriores exatos.",
                                    "Identifique que para ordem p, LET = O(h^{p+1})."
                                  ],
                                  "verification": "Confirme escrevendo corretamente ρ(ζ) e σ(ζ) para um método exemplo como AB2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta",
                                    "Calculadora simbólica opcional (Mathematica/SymPy)"
                                  ],
                                  "tips": "Comece com k=1 ou 2 para visualizar; memorize as primeiras condições de ordem.",
                                  "learningObjective": "Compreender a estrutura matemática dos LMMs e pré-requisitos para derivação do LET.",
                                  "commonMistakes": [
                                    "Confundir ρ e σ",
                                    "Esquecer normalização ρ(1)=0",
                                    "Ignorar derivadas em consistência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver expansões de Taylor da solução exata",
                                  "subSteps": [
                                    "Assuma y(t) suave e expanda y(t_{n+j}) = y(t_n) + j h y' + (j h)^2 /2! y'' + ... + (j h)^{p+1}/(p+1)! y^{(p+1)} + O(h^{p+2}).",
                                    "Expanda f(t_{n+j}, y(t_{n+j})) similarmente, usando y' = f(t,y) e derivadas superiores via diferenciação de y' = f.",
                                    "Some os termos para o lado esquerdo: ∑ α_j y(t_{n+j}).",
                                    "Some para o lado direito: h ∑ β_j f(t_{n+j}, y(t_{n+j})).",
                                    "Colete termos por potências de h até h^{p+1}."
                                  ],
                                  "verification": "Verifique que as expansões coincidem até ordem p para um método de ordem p conhecido.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel quadriculado para somas",
                                    "Software simbólico para expansões (SymPy)",
                                    "Tabelas de derivadas de f via fa(x) notation"
                                  ],
                                  "tips": "Use notação fa(x) para derivadas de f; agrupe por j e depois por potências de h.",
                                  "learningObjective": "Dominar expansões de Taylor multivariadas para soluções exatas em LMMs.",
                                  "commonMistakes": [
                                    "Erro no sinal nas expansões",
                                    "Esquecer chain rule em derivadas de f",
                                    "Termos de ordem errada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a expressão do erro local de truncamento (LET)",
                                  "subSteps": [
                                    "Substitua expansões no LMM: LET = [∑ α_j y(t_{n+j}) - h ∑ β_j f(t_{n+j}, y(t_{n+j})) ] / α_k (normalizando).",
                                    "Como ordem p, coeficientes de h^0 até h^p são zero pelas condições de ordem.",
                                    "Extraia o termo h^{p+1}: LET = C_{p+1} h^{p+1} y^{(p+1)}(ξ) + O(h^{p+2}).",
                                    "Identifique C_{p+1} = (1/(p+1)!) [ ∑_{j=0}^k α_j j^{p+1} - ∑_{j=0}^k β_j j^{p+1} ].",
                                    "Para ordem p+1, C_{p+2} similar, mas foco em p e p+1."
                                  ],
                                  "verification": "Compute LET para método de Euler (k=1, ordem 1) e confirme C_2 = -1/2.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Folha de fórmulas de condições de ordem",
                                    "SymPy para simplificação simbólica",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Normalize dividindo por α_k h^p; use generating functions para somas Σ j^m.",
                                  "learningObjective": "Derivar analiticamente o LET e isolar o termo principal.",
                                  "commonMistakes": [
                                    "Dividir errado no LET",
                                    "Confundir índices em somas j^{p+1}",
                                    "Ignorar fator 1/(p+1)! "
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e interpretar coeficientes de erro para ordens p e p+1",
                                  "subSteps": [
                                    "Para método de ordem exata p, compute C_{p+1} explicitamente.",
                                    "Derive C_{p+2} para analisar ordem p+1: similar mas com (p+2) potências.",
                                    "Discuta estimadores de erro local usando pares embedded (p e p+1).",
                                    "Exemplo: Para AB3 (ordem 3), encontre C_4.",
                                    "Verifique numericamente com solução exata conhecida."
                                  ],
                                  "verification": "Derive C_{p+1} para AB2 e compare com literatura.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para verificação numérica",
                                    "Tabelas de coeficientes AB/BDF",
                                    "Artigo sobre error estimation"
                                  ],
                                  "tips": "Use método de diferenças finitas para aproximar y^{(p+1)}; teste com y' = -y.",
                                  "learningObjective": "Extrair e aplicar coeficientes de erro principal em contextos de controle de passo.",
                                  "commonMistakes": [
                                    "Erro aritmético em somas",
                                    "Confundir C_{p+1} com global",
                                    "Não normalizar corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Adams-Bashforth de ordem 2 (AB2): y_{n+1} = y_n + (3/2 h f_n - 1/2 h f_{n-1}). Derive LET: expansões mostram C_3 = 5/12, LET ≈ (5/12) h^3 y'''(ξ). Identifique coeficientes para p=2 e cheque ordem 3 falha.",
                              "finalVerifications": [
                                "Expressão LET correta com O(h^{p+1}).",
                                "C_{p+1} = (1/(p+1)!) [∑ α_j j^{p+1} - ∑ β_j j^{p+1}] derivado precisamente.",
                                "Verificação numérica para método simples (ex: AB1) bate com analítico.",
                                "Coeficientes para p+1 identificados e não-zero.",
                                "Explicação clara de uso em estimadores de erro local."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de Taylor (sem erros em coeficientes).",
                                "Correta identificação de condições de ordem p e isolamento de p+1.",
                                "Uso apropriado de notação ρ, σ e fa(x).",
                                "Exemplo prático resolvido com valores numéricos corretos.",
                                "Interpretação física/matemática do termo principal.",
                                "Ausência de erros comuns como confusão de somas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar derivação simbólica em Python (SymPy) ou numérica em SciPy.",
                                "Física: Aplicar LET em simulações de EDOs oscilatórias (ex: pêndulo).",
                                "Estatística: Análise de erro em métodos estocásticos semelhantes.",
                                "Engenharia Computacional: Integração em solvers adaptativos como ODE45."
                              ],
                              "realWorldApplication": "Em modelagem climática e dinâmica de fluidos computacional (CFD), o termo de erro principal local é usado em solvers adaptativos (ex: Runge-Kutta embedded) para ajustar passos h automaticamente, garantindo precisão sem custo computacional excessivo em simulações de longa duração."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.2",
                            "name": "Implementar estimativa via método embebido",
                            "description": "Calcular a estimativa de erro local usando um par de métodos multistep embebidos de ordens consecutivas, como no método de Gear variável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de métodos multistep embebidos",
                                  "subSteps": [
                                    "Estudar a fórmula geral de métodos multistep lineares multitarefa (LMM): ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}.",
                                    "Explicar o papel dos métodos embebidos: usar dois LMM de ordens consecutivas (k e k-1) para estimar o erro local τ_{n+1} ≈ (y_{n+1}^{(k)} - y_{n+1}^{(k-1)}) / (c_k - c_{k-1}).",
                                    "Analisar o método de Gear variável: predictor BDF implícito com corrector ajustável para controle de erro.",
                                    "Derivar a estimativa de erro para pares como Gear4 e Gear3.",
                                    "Revisar estabilidade A(α)-estável dos métodos BDF usados em Gear."
                                  ],
                                  "verification": "Resumir em um diagrama as diferenças entre predictor, corrector e estimativa de erro em um caderno ou slide.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro 'Análise Numérica' de Burden & Faires",
                                    "Artigo sobre método de Gear (PDF)",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Comece com exemplos simples de multistep não embebidos para contrastar.",
                                  "learningObjective": "Entender como pares de métodos de ordens consecutivas permitem estimativa de erro local sem solução exata.",
                                  "commonMistakes": [
                                    "Confundir ordem do método com número de passos históricos.",
                                    "Ignorar a necessidade de consistência e ordem dos coeficientes α e β."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e implementar os coeficientes dos métodos embebidos",
                                  "subSteps": [
                                    "Escolher um par específico, como Gear (BDF) de ordem 4 (α = [1, -2.512, 1.512, 0, 0], β aproximados) e ordem 3.",
                                    "Calcular ou consultar tabelas de coeficientes para predictor (Adams-Bashforth) e corrector (BDF).",
                                    "Implementar funções para avançar um passo com cada método separadamente em pseudocódigo.",
                                    "Verificar a ordem de precisão somando os coeficientes e testando em EDO linear exata.",
                                    "Preparar estrutura de dados para histórico de passos (array de y e f anteriores)."
                                  ],
                                  "verification": "Executar um passo manual em papel para y' = -y, y(0)=1 e comparar y1 de ambos métodos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabelas de coeficientes Gear (online ou livro)",
                                    "Python com NumPy/SciPy",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Use tabelas pré-computadas para evitar erros de derivação manual.",
                                  "learningObjective": "Selecionar coeficientes corretos para um par embebido e implementá-los em código básico.",
                                  "commonMistakes": [
                                    "Usar coeficientes errados de Adams ao invés de BDF.",
                                    "Esquecer normalização dos coeficientes β para h f(t)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o cálculo da estimativa de erro local",
                                  "subSteps": [
                                    "Codificar a fórmula de erro: err = |y_{n+1}^{(k)} - y_{n+1}^{(k-1)}| / |1 - (c_k / c_{k-1})|, onde c é o erro de ordem.",
                                    "Integrar predictor-corrector: prever com ordem alta, corrigir com baixa, estimar erro.",
                                    "Adicionar tolerância: se err > tol, rejeitar passo e reduzir h.",
                                    "Testar em código com controle condicional de aceitação/rejeição.",
                                    "Visualizar erro estimado vs. erro real (comparar com solução exata conhecida)."
                                  ],
                                  "verification": "Rodar simulação e plotar log(err_estimado) vs. log(h) para verificar convergência linear.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python/MATLAB com plotting (Matplotlib)",
                                    "EDO teste: y'=-y",
                                    "Solução exata para benchmark"
                                  ],
                                  "tips": "Implemente uma função modular 'step_embedded(y_hist, f_hist, h)' que retorna y_new, err.",
                                  "learningObjective": "Calcular e usar estimativa de erro local para decisão de passo adaptativo.",
                                  "commonMistakes": [
                                    "Dividir incorretamente pelo fator de ordem (geralmente 1/ln(2) ou específico).",
                                    "Não absolver o erro para comparação com tol."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar em solver completo e validar",
                                  "subSteps": [
                                    "Construir loop principal: inicializar com Runge-Kutta, então multistep até tfinal.",
                                    "Implementar controle de passo: h_new = h * 0.9 * sqrt(tol/err).",
                                    "Testar com EDO não-linear rígida, como y' = -50y + sin(t).",
                                    "Comparar eficiência (passos totais) com método fixo-step.",
                                    "Documentar código com comentários sobre Gear variável."
                                  ],
                                  "verification": "Gerar relatório: passos aceitos/rejeitados, erro global final < 1e-6.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código base de multistep simples",
                                    "EDOs rígidas de teste",
                                    "Profiler de tempo (timeit)"
                                  ],
                                  "tips": "Comece com h inicial pequeno e tol moderada (1e-5) para depuração.",
                                  "learningObjective": "Desenvolver um solver multistep embebido funcional com controle adaptativo.",
                                  "commonMistakes": [
                                    "Perder sincronia no histórico de passos após rejeição.",
                                    "h crescendo explosivamente sem fator de segurança 0.9."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um solver usando método Gear embebido (ordens 4 e 3) para resolver y' = -10*y*(1 - y/2) + cos(t), y(0)=1, no intervalo [0, 5], com tol=1e-6. Compare solução numérica com exata (se conhecida) e plote y(t) vs. t, destacando adaptação de h baseada em erro estimado.",
                              "finalVerifications": [
                                "O código executa sem erros e converge para a solução em tempo finito.",
                                "Erro local estimado é consistente com erro real (ordem 3-4).",
                                "Número de passos é menor que em método de passo fixo equivalente.",
                                "Passos são rejeitados (<20% do total) quando necessário.",
                                "Gráficos mostram h variando inversamente com erro estimado.",
                                "Solução global atende tol em norma máxima."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa de erro (convergência observada).",
                                "Eficiência computacional (passos e tempo vs. fixo-step).",
                                "Correção da implementação de coeficientes Gear.",
                                "Robustez em EDOs rígidas (não diverge).",
                                "Clareza e modularidade do código.",
                                "Validação com múltiplos testes (linear e não-linear)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica eficiente em Python/MATLAB.",
                                "Física: Modelagem de sistemas dinâmicos rígidos (circuitos, mecânica).",
                                "Estatística: Análise de erros e controle de qualidade numérica.",
                                "Engenharia Computacional: Otimização de solvers para simulações reais."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos rígidos (SPICE), previsão meteorológica com modelos diferenciais multistep, ou farmacocinética em softwares como MATLAB SimBiology, onde controle adaptativo de erro garante precisão sem custo excessivo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.3",
                            "name": "Avaliar precisão da estimativa de erro",
                            "description": "Comparar a estimativa de erro local com o erro global acumulado e analisar sua asymptoticidade em termos de h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender definições de erro local e erro global em métodos multistep",
                                  "subSteps": [
                                    "Definir erro local de truncamento como a diferença entre a solução exata de um passo e a numérica, assumindo passos anteriores exatos.",
                                    "Definir erro global como o erro acumulado na solução final após múltiplos passos.",
                                    "Explicar a relação assintótica: erro global ≈ (erro local por passo) / (1 - ordem do método).",
                                    "Estudar fórmulas para métodos lineares multistep (LMM): τ(h) para erro local.",
                                    "Diferenciar erro local de arredondamento de truncamento."
                                  ],
                                  "verification": "Escrever definições próprias e fórmulas em um caderno, comparando com referências.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre métodos multistep",
                                    "Artigo sobre erro em LMM"
                                  ],
                                  "tips": [
                                    "Visualize o erro local como 'erro em um passo isolado' e global como 'soma propagada'. Use diagramas de fluxo."
                                  ],
                                  "learningObjective": "Diferenciar conceitualmente erro local de global e sua relação em métodos multistep.",
                                  "commonMistakes": [
                                    "Confundir erro local com erro de arredondamento",
                                    "Ignorar a acumulação assintótica no erro global"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender técnicas de estimativa de erro local em métodos multistep",
                                  "subSteps": [
                                    "Estudar estimadores baseados em métodos embutidos (ex: diferença entre dois métodos de ordens próximas).",
                                    "Explorar estimativa por extrapolação de Richardson aplicada a multistep.",
                                    "Analisar uso de soluções de ordem superior como referência (ex: predictor-corrector).",
                                    "Implementar fórmula genérica: e_l ≈ (y_{n+1}^{(k+1)} - y_{n+1}^{(k)}) / (C_{k+1} - C_k), onde C é constante de ordem.",
                                    "Discutir limitações em passos variáveis."
                                  ],
                                  "verification": "Calcular manualmente estimativa de erro local para um exemplo simples de Adams-Bashforth.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB/Python com solvers multistep",
                                    "Exemplos resolvidos de Burden",
                                    "Código fonte de ODE solvers"
                                  ],
                                  "tips": [
                                    "Comece com métodos de ordem baixa (2-3) para facilitar cálculos manuais."
                                  ],
                                  "learningObjective": "Dominar métodos práticos para computar estimativa de erro local.",
                                  "commonMistakes": [
                                    "Usar solução exata como proxy, o que não é prático",
                                    "Esquecer fatores de normalização nas diferenças"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar estimativa de erro local com erro global acumulado",
                                  "subSteps": [
                                    "Simular numericamente um problema de EDO com passos fixos e calcular ambos os erros.",
                                    "Plotar gráficos de erro local vs. global ao longo dos passos.",
                                    "Verificar numericamente a relação assintótica: erro global / erro local ≈ 1 / (1 - p), p=ordem.",
                                    "Analisar discrepâncias em regimes não-assintóticos (h grande).",
                                    "Ajustar para passos variáveis usando somas acumuladas."
                                  ],
                                  "verification": "Gerar tabela comparativa para um problema teste, com erros < 1e-6 de precisão relativa.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Python com SciPy (odeint/solve_ivp)",
                                    "MATLAB com ode23s",
                                    "Planilha Excel para tabulação"
                                  ],
                                  "tips": [
                                    "Use problemas lineares como y' = λy para soluções analíticas exatas de referência."
                                  ],
                                  "learningObjective": "Comparar quantitativamente estimativa local com erro global real.",
                                  "commonMistakes": [
                                    "Não normalizar erros por norma adequada (ex: máximo vs. L2)",
                                    "Ignorar efeitos de inicialização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar asymptoticidade em termos de h e avaliar precisão",
                                  "subSteps": [
                                    "Derivar assintoticamente: erro local ~ O(h^{p+1}), global ~ O(h^p).",
                                    "Estimar constante assintótica via regressão log-log: log(erro) vs. log(h).",
                                    "Avaliar precisão: |estimativa local - global| / global < tol.",
                                    "Testar convergência reduzindo h sucessivamente (h, h/2, h/4).",
                                    "Concluir sobre confiabilidade do estimador para controle de passo."
                                  ],
                                  "verification": "Produzir gráfico log-log mostrando inclinação correta e tabela de precisão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/MATLAB para plots log-log",
                                    "Referências teóricas (Hairer et al., Solving ODEs II)"
                                  ],
                                  "tips": [
                                    "Use h pequeno o suficiente para regime assintótico, mas evite underflow."
                                  ],
                                  "learningObjective": "Avaliar precisão da estimativa analisando comportamento assintótico em h.",
                                  "commonMistakes": [
                                    "Escolha inadequada de intervalo de h",
                                    "Confundir inclinação de local/global"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y + sin(t), y(0)=1 no intervalo [0,5] com método Adams-Bashforth ordem 3 (passo h=0.1). Calcule erro local no passo n=10 usando diferença com ordem 4; compare com erro global exato (via série ou solver high-order). Analise: para h/2=0.05, verifique se erro global ≈ 3 * erro local (para p=3) e plote asymptoticidade.",
                              "finalVerifications": [
                                "Calcular corretamente erro local e global para um método multistep dado.",
                                "Comparar quantitativamente com precisão relativa <5%.",
                                "Identificar regime assintótico via gráfico log-log.",
                                "Explicar limitações da estimativa em palavras próprias.",
                                "Avaliar se o estimador é confiável para tol=1e-6."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos cálculos (erro <1e-8).",
                                "Correta interpretação assintótica (inclinação p vs. p+1).",
                                "Uso adequado de normalização e gráficos.",
                                "Justificativa teórica clara.",
                                "Identificação de erros comuns e limitações.",
                                "Aplicação prática em código funcional."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/SciPy para análise de erros.",
                                "Física Computacional: Simulações de dinâmica em mecânica/orbitais.",
                                "Estatística: Modelagem de incertezas e análise de convergência.",
                                "Engenharia de Controle: Otimização de passos em sistemas reais.",
                                "Ciência de Dados: Validação de modelos diferenciais em ML."
                              ],
                              "realWorldApplication": "Em solvers adaptativos como CVODE ou ODE45, essa avaliação garante precisão em simulações climáticas, farmacocinéticas ou circuitos elétricos, ajustando h automaticamente para equilibrar erro e custo computacional em aplicações industriais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.2",
                        "name": "Critérios de Aceitação e Rejeição de Passo",
                        "description": "Regras baseadas na tolerância de erro para aceitar ou rejeitar um passo computado, garantindo que o erro local estimado esteja dentro dos limites especificados.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.2.1",
                            "name": "Aplicar teste de tolerância no erro estimado",
                            "description": "Verificar se o erro local estimado é menor que a tolerância Tol usando normas como ||e||_∞ < Tol ou escalar adaptativo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Erro Local Estimado e Tolerância",
                                  "subSteps": [
                                    "Defina erro local estimado (e) como a diferença entre soluções candidatas em métodos multistep.",
                                    "Explique a tolerância Tol como limite de precisão desejado.",
                                    "Identifique normas comuns: norma infinito (||e||_∞ = max |e_i|) e norma escalar adaptativo.",
                                    "Discuta o propósito: aceitar passo se erro < Tol, rejeitar caso contrário.",
                                    "Revise fórmula geral: teste ||e|| / Tol < 1."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos e forneça um exemplo simples de norma infinito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica",
                                    "Notas de aula",
                                    "Calculadora"
                                  ],
                                  "tips": "Use diagramas para visualizar erro local vs. global.",
                                  "learningObjective": "Entender os fundamentos teóricos do teste de tolerância.",
                                  "commonMistakes": "Confundir erro local com erro global; ignorar normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Norma do Erro Estimado",
                                  "subSteps": [
                                    "Obtenha o vetor de erro estimado e de uma implementação multistep (ex: Adams-Bashforth).",
                                    "Calcule ||e||_∞: encontre o máximo absoluto dos componentes de e.",
                                    "Para norma escalar adaptativo: compute Tol_i local e verifique max(|e_i|/Tol_i).",
                                    "Implemente em pseudocódigo ou software.",
                                    "Teste com dados sintéticos simples."
                                  ],
                                  "verification": "Compute norma para vetor e = [0.01, 0.02, 0.005] e confirme resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software MATLAB/Python (SciPy)",
                                    "Papel e lápis"
                                  ],
                                  "tips": "Sempre normalize por Tol_i para precisão adaptativa.",
                                  "learningObjective": "Dominar o cálculo preciso de normas de erro.",
                                  "commonMistakes": "Usar norma errada (L1 em vez de L∞); esquecer máximo absoluto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Teste de Tolerância e Decidir Aceitação/Rejeição",
                                  "subSteps": [
                                    "Compare norma calculada com Tol (ex: if ||e||_∞ < Tol, aceitar).",
                                    "Implemente lógica condicional: aceita → avance h; rejeita → reduza h.",
                                    "Considere fator de segurança (ex: 0.9 * Tol).",
                                    "Registre decisão e ajuste para próximo passo.",
                                    "Simule 2-3 iterações."
                                  ],
                                  "verification": "Para ||e||_∞ = 1e-5 e Tol=1e-6, decida corretamente e justifique.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código de solver numérico",
                                    "Exemplo de EDO y'=-y"
                                  ],
                                  "tips": "Inclua histérese para evitar oscilações em h.",
                                  "learningObjective": "Executar o teste e tomar decisões de controle de passo.",
                                  "commonMistakes": "Comparar sem normalizar; não ajustar h na rejeição."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar o Teste em Contexto Multistep",
                                  "subSteps": [
                                    "Integre teste em algoritmo completo de método multistep.",
                                    "Execute simulação com Tol variando (1e-3 a 1e-8).",
                                    "Analise convergência e eficiência.",
                                    "Compare com solver built-in (ex: ode45).",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Gere gráfico de solução com passos aceitos/rejeitados marcados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "MATLAB/Octave ou Python (odeint)",
                                    "Gráficos"
                                  ],
                                  "tips": "Monitore número de rejeições para tuning de Tol.",
                                  "learningObjective": "Aplicar teste de forma integrada e iterativa.",
                                  "commonMistakes": "Ignorar overhead computacional; Tol muito rígido."
                                }
                              ],
                              "practicalExample": "Para EDO y' = -y, y(0)=1, método Adams-Bashforth de ordem 2, em t=0.1, h=0.1: erro estimado e=[1.2e-6, 1.1e-6]. Tol=1e-5. Calcule ||e||_∞=1.2e-6 < Tol → aceitar passo.",
                              "finalVerifications": [
                                "Norma do erro calculada corretamente para pelo menos 3 exemplos.",
                                "Decisão de aceitação/rejeição lógica e consistente.",
                                "Integração bem-sucedida em loop de solver multistep.",
                                "Análise de eficiência (tempo de computação vs. precisão).",
                                "Gráfico mostra passos controlados adequadamente.",
                                "Comparação com solver padrão dentro de 1% de erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de normas (erro < 1e-10).",
                                "Correta implementação de lógica condicional.",
                                "Eficiência: <20% rejeições em simulações padrão.",
                                "Documentação clara de passos e decisões.",
                                "Adaptabilidade a Tol variáveis.",
                                "Ausência de erros comuns como confusão de normas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB para solvers ODE.",
                                "Física: Controle de precisão em simulações dinâmicas (ex: movimento orbital).",
                                "Estatística: Análise de erro e intervalos de confiança.",
                                "Engenharia: Otimização numérica em controle de sistemas."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou farmacocinéticas, garante precisão adaptativa em solvers ODE sem desperdício computacional, essencial para previsões em tempo real como em aviões autônomos ou modelagem de epidemias."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.2.2",
                            "name": "Calcular fator de escala inicial para rejeição",
                            "description": "Computar o fator de escala σ = (Tol / ||e||)^{1/p} para ajustar o próximo passo após rejeição, com p a ordem do método.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto e identificar os parâmetros necessários",
                                  "subSteps": [
                                    "Revise o contexto de métodos multistep para problemas de valor inicial (PVI).",
                                    "Identifique Tol como a tolerância desejada para o erro local.",
                                    "Localize o vetor de erro e = y_n - y_{n-1} ou estimativa de erro local.",
                                    "Determine p como a ordem do método multistep (ex: p=2 para Adams-Bashforth de ordem 2).",
                                    "Confirme a norma usada, tipicamente ||.||_2 ou ||.||_∞."
                                  ],
                                  "verification": "Liste corretamente Tol, e, p e norma em um exemplo dado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação do método multistep",
                                    "Exemplo de PVI resolvido",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Sempre anote os valores exatos para evitar confusões posteriores.",
                                  "learningObjective": "Identificar e extrair com precisão os parâmetros Tol, e e p do contexto de rejeição de passo.",
                                  "commonMistakes": [
                                    "Confundir Tol global com local",
                                    "Usar ordem errada do método",
                                    "Ignorar o tipo de norma especificado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a norma do erro ||e||",
                                  "subSteps": [
                                    "Escolha a norma apropriada (ex: norma euclidiana ||e||_2 = sqrt(∑ e_i^2)).",
                                    "Calcule cada componente |e_i| se norma infinita.",
                                    "Some os quadrados dos componentes para norma L2 e tire a raiz quadrada.",
                                    "Verifique dimensionalidade: e é escalar ou vetor?",
                                    "Registre o valor numérico com precisão adequada (ex: 4 casas decimais)."
                                  ],
                                  "verification": "Compare ||e|| calculado com resultado de software (ex: Python numpy.linalg.norm).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Biblioteca NumPy (para verificação)",
                                    "Exemplo numérico de erro"
                                  ],
                                  "tips": "Use funções prontas em software para validar manualmente.",
                                  "learningObjective": "Computar corretamente a norma do vetor de erro para diferentes tipos de norma.",
                                  "commonMistakes": [
                                    "Esquecer raiz quadrada em norma L2",
                                    "Usar norma errada (L1 vs L2)",
                                    "Arredondar prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a razão base Tol / ||e||",
                                  "subSteps": [
                                    "Divida Tol pelo valor de ||e|| obtido no passo anterior.",
                                    "Garanta que Tol e ||e|| estejam na mesma escala (ex: notação científica).",
                                    "Registre a razão r = Tol / ||e||, que deve ser <1 em caso de rejeição.",
                                    "Analise qualitativamente: se r<<1, rejeição severa esperada.",
                                    "Verifique unidades: ambas adimensionais ou consistentes."
                                  ],
                                  "verification": "Confirme que r < 1 e calcule manualmente para um valor conhecido.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para cálculos intermediários"
                                  ],
                                  "tips": "Trabalhe em logaritmo se valores muito pequenos para evitar underflow.",
                                  "learningObjective": "Calcular a razão de tolerância ao erro com precisão numérica.",
                                  "commonMistakes": [
                                    "Inverter numerador e denominador",
                                    "Ignorar escalas (1e-6 / 1e-3)",
                                    "Não notar r>1 (aceitação)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o fator de escala σ = (Tol / ||e||)^{1/p}",
                                  "subSteps": [
                                    "Eleve a razão r à potência 1/p: σ = r^{1/p}.",
                                    "Calcule 1/p exatamente (ex: p=2 → 0.5).",
                                    "Use logaritmos para precisão: ln(σ) = (1/p) * ln(r), σ = exp(ln(σ)).",
                                    "Arredonde σ para 3-4 casas decimais.",
                                    "Interprete: σ <1 indica redução de passo h_next = σ * h."
                                  ],
                                  "verification": "Teste com p=1 (σ=r) e compare; use calculadora para validar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora com funções exp/log",
                                    "Software como MATLAB/Python para checagem"
                                  ],
                                  "tips": "Para r próximo de 0, σ ≈ 0; limite σ ≥ 0.1 para estabilidade prática.",
                                  "learningObjective": "Aplicar corretamente a exponenciação fracionária para obter σ.",
                                  "commonMistakes": [
                                    "Usar p ao invés de 1/p",
                                    "Erro em log/exp com negativos",
                                    "Não limitar σ mínimo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e aplicar σ no ajuste de passo",
                                  "subSteps": [
                                    "Calcule h_next = σ * h_current (com fator de segurança fac=0.9 opcional).",
                                    "Simule próximo passo com h_next reduzido.",
                                    "Verifique se novo erro estimado atende Tol.",
                                    "Documente o processo em um relatório curto.",
                                    "Teste sensibilidade variando Tol ou p."
                                  ],
                                  "verification": "Execute simulação numérica e confirme convergência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Solver numérico (ex: ode45 MATLAB, scipy.integrate)",
                                    "Exemplo de EDO"
                                  ],
                                  "tips": "Sempre aplique limite superior/inferior em σ (0.2 ≤ σ ≤ 2).",
                                  "learningObjective": "Integrar σ no algoritmo de controle de passo e validar eficácia.",
                                  "commonMistakes": [
                                    "Não aplicar fac de segurança",
                                    "Aumentar h em rejeição",
                                    "Ignorar iterações múltiplas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para PVI y' = -y, y(0)=1, Tol=1e-6, após rejeição: e = [5e-4, 3e-4] (norma L2), ||e||_2 ≈ 5.83e-4, p=3 (método de ordem 3). Razão r = 1e-6 / 5.83e-4 ≈ 1.716e-3, σ = (1.716e-3)^{1/3} ≈ 0.119. Assim, h_next = 0.119 * h ≈ 0.012h, reduzindo passo para convergência.",
                              "finalVerifications": [
                                "Calcula σ corretamente para 3 exemplos variados (diferentes normas/p).",
                                "Explica verbalmente o papel de σ em controle de erro local.",
                                "Implementa fórmula em pseudocódigo sem erros.",
                                "Identifica quando σ indica rejeição severa (σ<0.5).",
                                "Valida com solver numérico que h_next melhora precisão.",
                                "Discute impacto de p alto em σ."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro <1% em ||e|| e σ.",
                                "Correta identificação de parâmetros (Tol, e, p, norma).",
                                "Uso apropriado de log/exp para estabilidade numérica.",
                                "Interpretação qualitativa de σ (redução/estabilidade).",
                                "Aplicação prática em ajuste de h com limites.",
                                "Documentação clara de passos intermediários."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (scipy, numpy) para solvers de EDOs.",
                                "Física/Engenharia: Controle de erro em simulações dinâmicas (ex: trajetórias orbitais).",
                                "Estatística: Normas de vetores em análise de resíduos.",
                                "Computação Científica: Otimização adaptativa em bibliotecas como GSL.",
                                "Matemática Aplicada: Teoria de estabilidade em métodos numéricos."
                              ],
                              "realWorldApplication": "Em software de simulação como MATLAB ode45 ou solvers de CFD/Finanças, σ otimiza passos variáveis, reduzindo tempo computacional em 50-90% enquanto mantém precisão em Tol, essencial para modelagem climática, aerodinâmica e precificação de derivativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.2.3",
                            "name": "Gerenciar rejeições consecutivas",
                            "description": "Implementar limites para o número máximo de rejeições consecutivas, reduzindo h agressivamente ou interrompendo a integração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o impacto de rejeições consecutivas em métodos multistep",
                                  "subSteps": [
                                    "Estude o algoritmo de controle de passo em métodos multistep, focando em critérios de aceitação/rejeição baseados no erro local estimado.",
                                    "Analise cenários onde rejeições consecutivas ocorrem, como em soluções com singularidades ou passos iniciais instáveis.",
                                    "Calcule manualmente o efeito de loops de rejeição em eficiência computacional e precisão.",
                                    "Revise literatura ou documentação de solvers como ODE45 ou LSODE sobre limites de rejeição.",
                                    "Identifique métricas de desempenho afetadas, como tempo de CPU e h final."
                                  ],
                                  "verification": "Resuma em um parágrafo os riscos de rejeições ilimitadas e justifique a necessidade de limites.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notebook Jupyter, exemplos de EDOs rígidas.",
                                  "tips": "Use gráficos de h vs. iterações para visualizar loops de rejeição.",
                                  "learningObjective": "Explicar por que rejeições consecutivas degradam performance e justificam intervenções.",
                                  "commonMistakes": "Subestimar impacto em EDOs rígidas; ignorar que h muito pequeno causa underflow."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir parâmetros de limite e estratégias de redução agressiva",
                                  "subSteps": [
                                    "Escolha um valor padrão para max_rejections_consecutivas (ex: 5-10).",
                                    "Defina fator de redução agressiva (ex: h = h * 0.1 ao atingir limite).",
                                    "Especifique condições de interrupção: erro fatal ou fallback para método de passo único.",
                                    "Documente trade-offs: limite baixo causa interrupções prematuras; alto aumenta tempo.",
                                    "Teste valores em EDOs de teste simples como y' = -y."
                                  ],
                                  "verification": "Crie uma tabela comparando diferentes max_rejections e fatores de redução em termos de iterações e precisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Python pandas para tabelas, EDOs de benchmark.",
                                  "tips": "Comece com max=5 para EDOs suaves e aumente para rígidas.",
                                  "learningObjective": "Selecionar parâmetros ótimos baseados em características do problema.",
                                  "commonMistakes": "Fator de redução fixo sem adaptação; limite único para todos os problemas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar lógica de gerenciamento de rejeições no código",
                                  "subSteps": [
                                    "Inicialize contador de rejeições consecutivas (rejected_count = 0).",
                                    "No loop de passo: se rejeitado, incremente contador; se aceito, resete para 0.",
                                    "Se rejected_count >= max_rejections: aplique redução agressiva h *= aggressive_factor e resete contador.",
                                    "Se após redução ainda falhar (ex: h < h_min), interrompa integração com erro.",
                                    "Integre flags de logging para rastrear eventos de limite atingido."
                                  ],
                                  "verification": "Execute código com logging e confirme que contador reseta corretamente e limite aciona.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (Python/MATLAB), biblioteca SciPy odeint ou implementações customizadas.",
                                  "tips": "Use assert para validar h > h_min antes de continuar.",
                                  "learningObjective": "Codificar controle robusto de rejeições com reset e interrupção condicional.",
                                  "commonMistakes": "Não resetar contador após aceitação; redução sem checar h_min."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a implementação em cenários reais",
                                  "subSteps": [
                                    "Teste com EDO suave (y' = y) esperando zero rejeições.",
                                    "Teste com EDO rígida (ex: y'' + y' + y = 0) forçando rejeições.",
                                    "Compare performance com/sem gerenciamento: iterações, tempo, precisão.",
                                    "Simule falha extrema: verifique interrupção graciosa.",
                                    "Otimize parâmetros baseados em resultados empíricos."
                                  ],
                                  "verification": "Gere relatório com métricas: % redução em iterações, casos de interrupção.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Scripts de teste unitário (pytest), plotters (matplotlib).",
                                  "tips": "Automatize testes com diferentes seeds para reprodutibilidade.",
                                  "learningObjective": "Validar que gerenciamento melhora robustez e eficiência.",
                                  "commonMistakes": "Testes só em casos ideais; ignorar overhead de logging."
                                }
                              ],
                              "practicalExample": "Em Python, implemente um solver multistep Adams-Bashforth para y' = -10*y + sin(t), com tol=1e-6. Sem limite, rejeições consecutivas em t~1 causam loop (h->0). Com max_rejections=5 e h*=0.1, reduz h de 0.1 para 0.001 e continua, completando em 200 passos vs. >10000 sem limite.",
                              "finalVerifications": [
                                "Contador de rejeições reseta após aceitação de passo.",
                                "Redução agressiva aplica exatamente quando rejected_count >= max_rejections.",
                                "Integração interrompe se h < h_min após redução.",
                                "Logging registra todos eventos de limite atingido.",
                                "Solução final converge para referência com erro < tol.",
                                "Performance melhora em pelo menos 50% em EDOs propensas a rejeições."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta da lógica de contagem e reset (100% acerto em testes unitários).",
                                "Parâmetros configuráveis e documentados adequadamente.",
                                "Tratamento de borda (h_min, interrupção) sem crashes.",
                                "Eficiência demonstrada: redução mensurável em iterações/tempo.",
                                "Código limpo com comentários e logging informativo.",
                                "Validação em pelo menos 3 EDOs de dificuldades variadas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Controle de exceções e loops preventivos em software numérico.",
                                "Engenharia de Software: Gerenciamento de recursos computacionais e timeouts.",
                                "Física/Engenharia: Estabilidade em simulações dinâmicas (ex: circuitos RLC rígidos).",
                                "Estatística: Análise de desempenho empírico e otimização de hiperparâmetros."
                              ],
                              "realWorldApplication": "Em solvers de EDOs para modelagem climática (ex: NOAA models) ou farmacocinética (MATLAB SimBiology), previne travamentos em regimes rígidos, garantindo simulações completas para previsão de epidemias ou design de drugs."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.3",
                        "name": "Estratégias de Ajuste do Tamanho do Passo",
                        "description": "Algoritmos adaptativos para aumentar ou diminuir o tamanho do passo h com base no erro estimado, equilibrando precisão e eficiência computacional.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.3.1",
                            "name": "Implementar aumento conservador de passo",
                            "description": "Aplicar fator de aumento σ_new = min(σ * f_aum, f_max) * h, com f_aum ≈ 1.2-2.0 e f_max ≈ 10, após aceitação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar condição de aceitação do passo anterior",
                                  "subSteps": [
                                    "Computar o erro local estimado (err) do passo anterior usando estimador embutido",
                                    "Comparar err com a tolerância desejada (tol): se err <= tol, definir accepted = true",
                                    "Registrar h_current e sigma_previous (fator de segurança do passo aceito)",
                                    "Preparar variáveis auxiliares para o cálculo de aumento",
                                    "Logar o status de aceitação para depuração"
                                  ],
                                  "verification": "Variável accepted é true e err <= tol confirmado por log ou teste",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "Código fonte do método multistep",
                                    "Documentação do estimador de erro"
                                  ],
                                  "tips": "Use tolerâncias relativa e absoluta combinadas (max(rel_err, abs_err)) para robustez em escalas variadas.",
                                  "learningObjective": "Identificar com precisão quando um passo numérico é confiável o suficiente para aumento.",
                                  "commonMistakes": [
                                    "Aumentar passo mesmo com rejeição parcial",
                                    "Ignorar sigma_previous ou usar err bruto sem normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir fatores de aumento conservador",
                                  "subSteps": [
                                    "Selecionar f_aum no intervalo 1.2-2.0 (ex: 1.5 para equilíbrio)",
                                    "Definir f_max ≈10 para prevenir passos excessivamente grandes",
                                    "Carregar sigma_previous do passo aceito (tipicamente (tol/err)^{1/ordem})",
                                    "Validar que sigma_previous >= 1.0 (indicando subestimação de erro)",
                                    "Armazenar parâmetros em estrutura ou dicionário para reutilização"
                                  ],
                                  "verification": "f_aum, f_max e sigma_previous têm valores válidos e logados corretamente",
                                  "estimatedTime": "10 minutes",
                                  "materials": [
                                    "Referências como Hairer 'Solving ODEs I'",
                                    "Tabelas de fatores heurísticos"
                                  ],
                                  "tips": "Ajuste f_aum baseado no método (menor para multistep implícitos).",
                                  "learningObjective": "Escolher heurísticas numéricas comprovadas para estabilidade e eficiência.",
                                  "commonMistakes": [
                                    "f_aum >2.0 causando instabilidade oscilatória",
                                    "f_max muito baixo limitando aceleração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o novo tamanho de passo pela fórmula",
                                  "subSteps": [
                                    "Computar sigma_proposed = sigma_previous * f_aum",
                                    "Aplicar limite superior: sigma_new = min(sigma_proposed, f_max)",
                                    "Calcular h_new = sigma_new * h_current",
                                    "Aplicar arredondamento conservador (ex: para múltiplos de 0.1 ou potências de 2)",
                                    "Verificar h_new > h_current para confirmar aumento"
                                  ],
                                  "verification": "h_new == min(sigma_previous * f_aum, f_max) * h_current via teste unitário",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Calculadora simbólica ou Python para protótipo",
                                    "Exemplos numéricos"
                                  ],
                                  "tips": "Implemente como função separada para testes isolados.",
                                  "learningObjective": "Aplicar precisamente a fórmula de aumento conservador em código.",
                                  "commonMistakes": [
                                    "Esquecer min() resultando em overshoot",
                                    "Erro de precedência em sigma * f_aum * h"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Atualizar passo e integrar no loop do solver",
                                  "subSteps": [
                                    "Atualizar variável global h_current = h_new",
                                    "Preparar k (passos históricos) para novo h no multistep",
                                    "Adicionar verificação de h_max global (ex: min(h_new, h_max))",
                                    "Logar mudança: 'Aumento de h: 0.05 -> 0.08125'",
                                    "Executar próximo passo e monitorar estabilidade"
                                  ],
                                  "verification": "Próximo passo usa h_new corretamente e logs confirmam atualização sem NaN",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "Código completo do solver multistep",
                                    "Testador de ODEs padrão"
                                  ],
                                  "tips": "Sempre teste com h_max para evitar dominação numérica.",
                                  "learningObjective": "Integrar controle adaptativo seamless no algoritmo principal.",
                                  "commonMistakes": [
                                    "Não propagar h_new para predictor/corrector",
                                    "Aumento levando a perda de precisão por passos grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1 com método Adams-Bashforth ordem 4, h=0.05 aceito (err=8e-7 < tol=1e-5), sigma_previous=1.25, f_aum=1.3, f_max=8. Então sigma_new = min(1.25*1.3, 8)=1.625, h_new=1.625*0.05=0.08125. Implemente e confirme que o solver avança com h=0.08125, mantendo erro global < tol.",
                              "finalVerifications": [
                                "Passo anterior aceito: err <= tol",
                                "h_new > h_current (aumento efetivo)",
                                "sigma_new <= f_max",
                                "h_new calculado exatamente pela fórmula",
                                "Integração estável: sem rejeições imediatas pós-aumento",
                                "Logs confirmam todos os valores intermediários"
                              ],
                              "assessmentCriteria": [
                                "Fórmula implementada corretamente (testes unitários 100%)",
                                "Eficiência: redução de passos totais em >20% em ODEs rígidos",
                                "Precisão preservada: erro global dentro de tol",
                                "Robustez: funciona em 5+ problemas de teste variados",
                                "Código modular, comentado e com handling de edge cases",
                                "Tempo de execução otimizado sem perda de acurácia"
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Algoritmos adaptativos e controle de erro em software numérico",
                                "Engenharia: Otimização de simulações em tempo real (ex: controle de sistemas)",
                                "Física/Matemática Aplicada: Equilíbrio entre precisão e custo em modelagem dinâmica",
                                "Otimização: Heurísticas para minimizar chamadas a funções caras"
                              ],
                              "realWorldApplication": "Estratégia essencial em solvers como MATLAB ode45/ode15s, SciPy solve_ivp e ODEPACK, acelerando simulações em previsão meteorológica, dinâmica orbital, modelagem epidemiológica e simulações CFD, reduzindo tempo computacional em ordens de magnitude sem sacrificar precisão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.3.2",
                            "name": "Aplicar redução de passo após rejeição",
                            "description": "Usar h_new = max(σ * f_red * h, h_min), com f_red ≈ 0.5-0.9, garantindo h ≥ h_min para evitar passos muito pequenos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a rejeição do passo e avaliar a necessidade de redução",
                                  "subSteps": [
                                    "Analise o erro estimado do passo atual e compare com a tolerância desejada (tol).",
                                    "Confirme se o passo foi rejeitado (erro > tol) e registre o tamanho do passo atual h.",
                                    "Defina os parâmetros globais: fator de segurança σ (tipicamente 0.9), h_min (tamanho mínimo do passo).",
                                    "Documente o estado da solução no ponto t_n para referência futura.",
                                    "Verifique se h atual já é igual a h_min para evitar loops infinitos."
                                  ],
                                  "verification": "Confirme que o erro estimado excede tol e h > h_min foi anotado.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de análise numérica (ex: Python com SciPy)",
                                    "Documentação do método multistep"
                                  ],
                                  "tips": "Sempre anote valores numéricos exatos para rastreabilidade; use logs para depuração em código.",
                                  "learningObjective": "Reconhecer triggers de rejeição e preparar parâmetros para ajuste de h.",
                                  "commonMistakes": [
                                    "Ignorar verificação de h_min prematuramente",
                                    "Confundir erro local com erro global",
                                    "Não registrar estado y_n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e calcular o fator de redução f_red",
                                  "subSteps": [
                                    "Estime a razão de erro r = erro_novo / tol.",
                                    "Calcule f_red = σ * (1 / r)^{1/p}, onde p é a ordem do método (ex: p=4 para Adams-Bashforth).",
                                    "Ajuste f_red para o intervalo [0.5, 0.9] com base em guidelines: f_red ≈ 0.5-0.9.",
                                    "Se r for muito grande (>10), use f_red conservador como 0.5.",
                                    "Registre o valor escolhido de f_red com justificativa."
                                  ],
                                  "verification": "Verifique se 0.5 ≤ f_red ≤ 0.9 e r calculado corretamente.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Calculadora ou Python para cálculos",
                                    "Tabela de ordens de métodos multistep"
                                  ],
                                  "tips": "Use f_red = min(0.9, max(0.5, cálculo)) para bounds automáticos; teste com r=2 e r=10.",
                                  "learningObjective": "Dominar cálculo adaptativo de f_red baseado em erro estimado.",
                                  "commonMistakes": [
                                    "Usar r diretamente sem potência 1/p",
                                    "Escolher f_red >1 (aumenta h indevidamente)",
                                    "Ignorar σ no cálculo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a fórmula de redução de passo h_new",
                                  "subSteps": [
                                    "Compute h_new = σ * f_red * h.",
                                    "Aplique o limite inferior: h_new = max(h_new, h_min).",
                                    "Arredonde h_new para valores 'bons' se necessário (ex: potências de 2 ou 10).",
                                    "Atualize o passo para a próxima tentativa no mesmo t_n.",
                                    "Confirme que h_new < h original para garantir redução efetiva."
                                  ],
                                  "verification": "Calcule h_new manualmente e compare com implementação; assegure h_new ≥ h_min e < h.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Planilha Excel ou Jupyter Notebook",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Implemente como função reutilizável em código: def step_reduction(h, ferr, tol, sigma=0.9, p=4, h_min=1e-6).",
                                  "learningObjective": "Executar fórmula h_new com safeguards corretamente.",
                                  "commonMistakes": [
                                    "Esquecer max() com h_min",
                                    "Usar h_new sem σ",
                                    "Arredondar prematuramente sem limite"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar a redução no método multistep",
                                  "subSteps": [
                                    "Reinicie o passo com h_new no ponto t_n, y_n.",
                                    "Execute o método multistep com h_new e estime novo erro.",
                                    "Se aceito, avance; senão, repita processo.",
                                    "Monitore histórico de h para detecção de estagnação.",
                                    "Salve solução intermediária para análise."
                                  ],
                                  "verification": "Simule 2-3 iterações e confirme convergência ou estabilização de h.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Código Python/MATLAB com solver multistep",
                                    "Gráfico de h vs. t"
                                  ],
                                  "tips": "Plote evolução de h para visualização; limite tentativas a 5 por passo para eficiência.",
                                  "learningObjective": "Integrar redução de passo em fluxo completo de controle adaptativo.",
                                  "commonMistakes": [
                                    "Avançar t sem aceitar passo",
                                    "Não resetar histórico multistep após rejeição",
                                    "Ignorar estagnação em h_min"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, tol=1e-6, h inicial=0.1, ordem p=4. Suponha rejeição com erro=2e-5 (>tol), r=20. Então f_red ≈ 0.9 * (1/20)^{1/4} ≈ 0.7 (ajustado). h_new = max(0.9*0.7*0.1, 1e-8) ≈ 0.063. Reexecute passo em t=1.0 com h_new.",
                              "finalVerifications": [
                                "h_new calculado satisfaz h_min ≤ h_new < h e f_red em [0.5,0.9].",
                                "Nova tentativa aceita ou processo itera corretamente.",
                                "Erro na solução reduz após 2-3 reduções.",
                                "Não há loops infinitos (h estabiliza > h_min).",
                                "Histórico de h mostra tendência decrescente até aceitação.",
                                "Solução y(t) consistente com solução exata em pontos chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na estimativa de r e f_red (erro <5%).",
                                "Correta aplicação de max() e bounds em h_new.",
                                "Integração fluida no algoritmo multistep sem bugs.",
                                "Eficiência: redução converge em ≤3 tentativas.",
                                "Documentação clara de cálculos e decisões.",
                                "Testes com casos extremos (r>>1, h≈h_min)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (SciPy ode) para automação.",
                                "Física: Controle adaptativo em simulações dinâmicas (ex: osciladores).",
                                "Estatística: Análise de erro e tolerâncias probabilísticas.",
                                "Engenharia Computacional: Otimização de solvers em CFD.",
                                "Ciência de Dados: Ajuste adaptativo em ML para treinamento de redes."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais em modelagem climática, finanças (Black-Scholes PDE) ou engenharia aeroespacial, onde passos pequenos evitam instabilidades perto de singularidades, garantindo precisão e eficiência computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.3.3",
                            "name": "Otimizar eficiência com controle global",
                            "description": "Ajustar passos considerando custo computacional por passo multistep (k avaliações de f) e erro global acumulado para problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o custo computacional em métodos multistep",
                                  "subSteps": [
                                    "Identifique os componentes de um método multistep linear (LMM), como Adams-Bashforth ou BDF.",
                                    "Calcule o custo por passo: k avaliações de f para ordem k.",
                                    "Compare com métodos de passo único (Runge-Kutta).",
                                    "Analise impacto em problemas stiff onde k é alto.",
                                    "Registre fórmulas de custo total: N passos × k avaliações."
                                  ],
                                  "verification": "Resuma em tabela o custo por passo para métodos de ordem 2, 4 e 6.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre LMM, calculadora ou Python para simulações simples.",
                                  "tips": "Use diagramas de fluxo para visualizar avaliações de f.",
                                  "learningObjective": "Explicar como o custo computacional escala com a ordem do método multistep.",
                                  "commonMistakes": "Confundir custo por passo com custo total, ignorando overhead de stiff solvers."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar acumulação de erro global em problemas stiff",
                                  "subSteps": [
                                    "Defina problemas stiff: razão de escalas temporais alta (λ grande negativo).",
                                    "Estude truncamento local vs. erro global acumulado.",
                                    "Simule propagação de erro em EDO stiff como y' = -1000(y - sin(t)).",
                                    "Calcule tolerância global de erro (TOL_global) baseada em norma L2 ou máximo.",
                                    "Avalie estabilidade em métodos implícitos (BDF).",
                                    "Compare com não-stiff para destacar acumulação."
                                  ],
                                  "verification": "Gere gráfico de erro global vs. passos para um problema stiff.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software como MATLAB/Octave ou SciPy (Python), exemplo de EDO stiff.",
                                  "tips": "Escolha λ = -10^3 para stiff claro; normalize erros.",
                                  "learningObjective": "Quantificar como erros locais se acumulam em erros globais para stiff ODEs.",
                                  "commonMistakes": "Usar passos fixos, subestimando instabilidade em métodos explícitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular estratégia de controle global de passo",
                                  "subSteps": [
                                    "Defina métrica de eficiência: custo total / precisão global.",
                                    "Integre estimativa de erro local (Richardson ou embedded) com projeção global.",
                                    "Estabeleça regra de ajuste: h_new = h_old * (TOL_global / err_global)^{1/p}.",
                                    "Inclua fator de custo: penalize passos caros (k alto).",
                                    "Defina limites: h_min, h_max e segurança (0.9).",
                                    "Teste heurística em pseudocódigo."
                                  ],
                                  "verification": "Escreva pseudocódigo para ajuste que equilibre custo e erro.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel e lápis para pseudocódigo, referências como Hairer 'Solving ODEs'.",
                                  "tips": "Pense em trade-off: passos grandes baratos mas erro alto; pequenos caros mas precisos.",
                                  "learningObjective": "Desenvolver fórmula de ajuste que minimize custo sujeito a TOL_global.",
                                  "commonMistakes": "Ignorar custo k, focando só em erro local."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar controle global",
                                  "subSteps": [
                                    "Codifique solver multistep com passo adaptativo global (ex: BDF2).",
                                    "Integre monitor de custo: conte avaliações de f.",
                                    "Execute em problema stiff benchmark (ex: van der Pol μ=1000).",
                                    "Compare com controle local: custo e erro final.",
                                    "Otimize hiperparâmetros (segurança, p).",
                                    "Gere relatório: eficiência = 1 / (custo * log(err))."
                                  ],
                                  "verification": "Demonstre redução de 20-50% em custo com erro < TOL.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (SciPy odeint ou custom), Jupyter notebook.",
                                  "tips": "Use profiling para medir avaliações reais de f.",
                                  "learningObjective": "Implementar algoritmo que otimize eficiência computacional global.",
                                  "commonMistakes": "Não resetar histórico de passos em rejeições, causando overhead."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e refinar otimização",
                                  "subSteps": [
                                    "Teste múltiplos problemas stiff (químicos, elétricos).",
                                    "Analise sensibilidade a TOL e k.",
                                    "Compare com solvers comerciais (ODE15s).",
                                    "Identifique gargalos e refine (ex: predictor-corrector eficiente).",
                                    "Documente guidelines para uso em contextos reais."
                                  ],
                                  "verification": "Crie tabela comparativa de eficiência em 3 problemas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Códigos anteriores, benchmarks de ODEs stiff.",
                                  "tips": "Varie TOL de 1e-3 a 1e-9 para ver escalabilidade.",
                                  "learningObjective": "Refinar estratégia baseada em evidências empíricas.",
                                  "commonMistakes": "Overfitting a um problema, generalizando mal."
                                }
                              ],
                              "practicalExample": "Implemente um solver BDF2 para y' = -1000(y - cos(t)), y(0)=1, em [0,10], com TOL_global=1e-6. Monitore custo (avaliações de f) e erro global L2. Ajuste h considerando k=2, reduzindo custo em 40% vs. h fixo.",
                              "finalVerifications": [
                                "Erro global acumulado < TOL especificada.",
                                "Custo total (avaliações de f) minimizado vs. baselines.",
                                "Estabilidade mantida em problemas stiff (sem blow-up).",
                                "Passos adaptativos variam corretamente (aumentam em regiões suaves).",
                                "Relatório inclui gráficos de h(t), erro(t) e custo cumulativo.",
                                "Pseudocódigo ou código roda sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro global ≤ 1.5 × TOL.",
                                "Eficiência: Custo ≤ 70% de solver local-only.",
                                "Correção: Ajustes respeitam custo k e acumulação de erro.",
                                "Robustez: Funciona em 3+ problemas stiff variados.",
                                "Clareza: Documentação explica trade-offs.",
                                "Implementação: Código limpo, modular e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Otimização numérica em Python/MATLAB.",
                                "Física: Modelagem de circuitos RLC stiff ou dinâmica molecular.",
                                "Engenharia: Simulações em controle de sistemas rígidos.",
                                "Estatística: Análise de erro e Monte Carlo para validação."
                              ],
                              "realWorldApplication": "Em simulações químicas de reações rápidas/lentas (stiff), como combustão ou farmacocinética, onde controle global reduz tempo de CPU de horas para minutos, permitindo iterações em design de reatores ou dosagens de drogas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.3.4",
                            "name": "Simular algoritmo completo de controle",
                            "description": "Implementar um ciclo completo de controle de passo em pseudocódigo ou código, testando em EDOs modelo como y' = -y.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema EDO modelo e inicializar parâmetros do algoritmo",
                                  "subSteps": [
                                    "Escolha o EDO modelo: y' = -y com y(0) = 1, solução exata y(t) = e^{-t}.",
                                    "Defina parâmetros iniciais: t0=0, tf=1, h_inicial=0.1, tolerância erro_local=1e-5, fator segurança=0.9, limites h_min=1e-6, h_max=0.5.",
                                    "Implemente funções auxiliares: f(t,y) = -y e solução exata para comparação.",
                                    "Inicialize vetores para armazenar solução aproximada: t_vals=[], y_vals=[].",
                                    "Gere pontos iniciais com método de Runge-Kutta de ordem 4 para os primeiros 2-3 passos (necessário para multistep)."
                                  ],
                                  "verification": "Verifique se f(0,1) == -1 e se os primeiros y0, y1, y2 foram computados corretamente comparando com solução exata.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de código (Python/Jupyter Notebook)",
                                    "Bibliotecas: numpy, matplotlib",
                                    "Documentação de métodos multistep"
                                  ],
                                  "tips": "Use numpy arrays para eficiência; plot os primeiros pontos vs exata para validar.",
                                  "learningObjective": "Compreender configuração inicial para métodos multistep com controle de passo.",
                                  "commonMistakes": [
                                    "Esquecer passos iniciais com RK4",
                                    "Tolerância muito baixa causando lentidão",
                                    "h_inicial maior que h_max"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar predictor (Adams-Bashforth) e corrector (Adams-Moulton) para passo fixo",
                                  "subSteps": [
                                    "Defina coeficientes para AB2: predictor y_{n+1}^p = y_n + (3/2)h f(t_n, y_n) - (1/2)h f(t_{n-1}, y_{n-1}).",
                                    "Defina coeficientes para AM2: corrector y_{n+1} = y_n + (1/2)h [f(t_{n+1}, y_{n+1}^p) + f(t_n, y_n)].",
                                    "Implemente função para um passo fixo: compute predictor, então corrector iterativamente até convergência (2-3 iterações).",
                                    "Atualize vetores t_vals e y_vals após cada passo bem-sucedido.",
                                    "Teste com 5 passos fixos e compare com exata (erro <1e-3)."
                                  ],
                                  "verification": "Execute 10 passos fixos; erro global máximo deve ser <0.01 comparado à solução exata.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com numpy",
                                    "Papel para derivar coeficientes AB2/AM2"
                                  ],
                                  "tips": "Use loop while para iterações do corrector até |y^{k+1} - y^k| < 1e-8.",
                                  "learningObjective": "Dominar predictor-corrector multistep para um passo único.",
                                  "commonMistakes": [
                                    "Coeficientes errados em AB/AM",
                                    "Não iterar corrector o suficiente",
                                    "Índices errados em histórico de f_vals"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular estimativa de erro local usando diferença predictor-corrector",
                                  "subSteps": [
                                    "Após corrector convergido, compute erro_local = |y_{n+1} - y_{n+1}^p| / (1 - |coeficiente de erro estimado|), para AM2 erro ~ (1/12) h^3 y'''.",
                                    "Simplifique para prática: erro_local ≈ |y_{n+1} - y_{n+1}^p|.",
                                    "Armazene histórico de f_vals para reutilização em predictor.",
                                    "Defina função estimate_error_local(t_n, y_n, y_np, h) que retorna erro estimado.",
                                    "Teste em passos fixos: erro deve diminuir com h menor."
                                  ],
                                  "verification": "Reduza h pela metade; erro_local deve cair ~h^2 para método ordem 2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código do passo anterior",
                                    "Referência teórica de análise de erro multistep"
                                  ],
                                  "tips": "Normalize erro por tolerância para decisão de aceitação.",
                                  "learningObjective": "Estimar truncamento local em predictor-corrector.",
                                  "commonMistakes": [
                                    "Usar diferença absoluta sem escalar por h",
                                    "Não armazenar f anteriores corretamente",
                                    "Confundir ordem do método"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar lógica de ajuste adaptativo do tamanho do passo",
                                  "subSteps": [
                                    "Após erro_local, se erro_local < tol, aceite passo, h_next = h * min(1.4, 0.9 * (tol / erro_local)^{1/3}).",
                                    "Se erro_local >= tol, rejeite passo, h_next = h * max(0.5, 0.9 * (tol / erro_local)^{1/3}), repita passo com h_next.",
                                    "Aplique limites: h = max(h_min, min(h_max, h_next)).",
                                    "Mantenha histórico de pelo menos k=2 pontos anteriores.",
                                    "Integre ao ciclo: while t < tf."
                                  ],
                                  "verification": "Simule até t=0.5; conte aceitações/rejeições, h deve variar dinamicamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código integrado",
                                    "Gráficos para h vs t"
                                  ],
                                  "tips": "Expoente 1/(p+1) onde p=2 ordem; 1.4 crescimento conservador evita oscilações.",
                                  "learningObjective": "Controlar precisão adaptando h automaticamente.",
                                  "commonMistakes": [
                                    "h_next sem limites causando overflow",
                                    "Rejeitar mas não retroceder t/y",
                                    "Fator segurança <0.9 levando a muitas rejeições"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar ciclo completo, simular, testar e visualizar resultados",
                                  "subSteps": [
                                    "Estruture loop principal: inicialize, while t_n < tf - eps: passo completo com controle.",
                                    "Ao final, compute erros globais: max |y_num - y_exata|.",
                                    "Plote y_num vs y_exata, h vs t, erros vs t.",
                                    "Teste sensibilidade: varie tol de 1e-3 a 1e-8, observe passos totais.",
                                    "Escreva relatório: passos aceitos, rejeitados, erro final."
                                  ],
                                  "verification": "Simulação completa até t=1 com erro global < tol * 10; gráfico suave.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "matplotlib para plots",
                                    "Jupyter para interatividade"
                                  ],
                                  "tips": "Salve histórico de h e erros para análise.",
                                  "learningObjective": "Executar simulação numérica robusta com controle de passo.",
                                  "commonMistakes": [
                                    "Loop infinito se h->0",
                                    "Não tratar tf não múltiplo de h",
                                    "Plots sem legendas/escalas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python, simule y' = -y, y(0)=1 até t=5. Inicial h=0.2, tol=1e-6. Resultado: ~150 passos aceitos, 20 rejeitados, erro max 5e-7, h varia de 0.001 a 0.3. Plot mostra convergência perfeita à y=e^{-t}.",
                              "finalVerifications": [
                                "Código executa sem erros até tf sem loop infinito.",
                                "Número de passos razoável (100-500 para tol=1e-6).",
                                "Erro global máximo < 10 * tol.",
                                "h adapta: diminui em regiões 'difíceis', aumenta em suaves.",
                                "Gráficos mostram alinhamento com solução exata.",
                                "Teste com tol menor: mais passos, menor erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro global < tol em 90% dos pontos.",
                                "Eficiência: <5% passos rejeitados.",
                                "Robustez: funciona com diferentes EDOs lineares (ex: y'= -2y).",
                                "Clareza código: comentários, funções modulares.",
                                "Análise: relatório com métricas (passos, h_min/max usado).",
                                "Visualização: plots informativos com legendas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: estruturas de loop, vetores, funções numéricas (Python/NumPy).",
                                "Física: modelagem de decaimento exponencial (radioatividade, resfriamento).",
                                "Engenharia Computacional: solvers ODE em SciPy odeint.",
                                "Estatística: análise de erro e convergência numérica.",
                                "Matemática Aplicada: extensão a EDOs não-lineares."
                              ],
                              "realWorldApplication": "Simulações em engenharia (circuitos RC: i' = -i/R), farmacocinética (concentração drogas), previsão climática (modelos diferenciais), finanças (modelos Black-Scholes discretizados), garantindo precisão adaptativa sem passos excessivos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Controle de Passo",
                "description": "Técnicas para ajustar adaptativamente o tamanho do passo na integração numérica.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Motivação para Controle Adaptativo de Passo",
                    "description": "Razões para ajustar dinamicamente o tamanho do passo em métodos de integração numérica de EDOs, visando eficiência e precisão.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Ineficiência Computacional de Passos Fixos Pequenos",
                        "description": "Explicação das limitações dos métodos de passo fixo com h pequeno, que aumentam excessivamente o número de avaliações de função, elevando o custo computacional em regiões onde a solução varia suavemente.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Calcular o custo computacional de passos fixos",
                            "description": "Dado um intervalo de integração [a, b] e tamanho de passo h fixo, determinar o número de passos N = ceil((b - a)/h) e estimar o custo total proporcional a N vezes o custo por passo, ilustrando a ineficiência para h muito pequeno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Integração Numérica com Passos Fixos",
                                  "subSteps": [
                                    "Defina o intervalo de integração [a, b] e o tamanho de passo h fixo.",
                                    "Explique que o método de passos fixos divide o intervalo em subintervalos de largura h.",
                                    "Discuta o conceito de custo computacional como o número de operações por passo multiplicado pelo número de passos.",
                                    "Identifique que o número de passos N é necessário para cobrir todo o intervalo.",
                                    "Revise a fórmula básica N = ceil((b - a)/h)."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos e formule a fórmula de N corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Notebook com exemplos de integração numérica"
                                  ],
                                  "tips": "Use diagramas para visualizar a divisão do intervalo em passos.",
                                  "learningObjective": "Entender os fundamentos do método de passos fixos e sua relação com o custo computacional.",
                                  "commonMistakes": [
                                    "Confundir h com o número de passos",
                                    "Ignorar o uso de ceil na fórmula de N",
                                    "Não considerar que h pequeno aumenta N excessivamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Número de Passos N",
                                  "subSteps": [
                                    "Escolha valores específicos para a, b e h (ex: a=0, b=1, h=0.1).",
                                    "Calcule (b - a)/h.",
                                    "Aplique a função ceil para obter N inteiro.",
                                    "Repita para diferentes h (ex: h=0.01) e registre os valores de N.",
                                    "Verifique se N*h >= (b-a) para garantir cobertura completa do intervalo."
                                  ],
                                  "verification": "Mostre cálculos para pelo menos três valores de h e confirme N correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python para ceil",
                                    "Planilha Excel para tabelas"
                                  ],
                                  "tips": "Use a função math.ceil em Python ou Excel para precisão.",
                                  "learningObjective": "Dominar o cálculo preciso de N usando ceil((b-a)/h).",
                                  "commonMistakes": [
                                    "Usar floor em vez de ceil",
                                    "Arredondar incorretamente (b-a)/h",
                                    "Esquecer de cobrir o último passo parcial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar o Custo Computacional Total",
                                  "subSteps": [
                                    "Defina o custo por passo C (ex: 10 operações por passo).",
                                    "Calcule custo total como N * C.",
                                    "Compare custos para h grande (poucos passos) vs h pequeno (muitos passos).",
                                    "Crie uma tabela comparativa de h, N e custo total.",
                                    "Discuta proporcionalidade: custo ∝ 1/h."
                                  ],
                                  "verification": "Produza uma tabela com custos para h=0.1, 0.01, 0.001 e interprete os resultados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha para tabelas",
                                    "Gráfico de custo vs h (opcional via Python/Matlab)"
                                  ],
                                  "tips": "Plote log(custo) vs log(h) para visualizar a relação linear.",
                                  "learningObjective": "Calcular e interpretar o custo total proporcional a N * C.",
                                  "commonMistakes": [
                                    "Não multiplicar por C",
                                    "Ignorar que custo cresce inversamente com h",
                                    "Confundir custo por passo com custo total"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar a Ineficiência para h Muito Pequeno",
                                  "subSteps": [
                                    "Simule tempos de execução hipotéticos baseados em N (ex: 1ms por passo).",
                                    "Compare precisão vs custo para h decrescente.",
                                    "Argumente por que h muito pequeno é ineficiente (custo explode sem ganho proporcional em precisão).",
                                    "Discuta motivação para métodos adaptativos.",
                                    "Crie um gráfico de custo vs precisão esperada."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a ineficiência com exemplos numéricos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem como Python (matplotlib)",
                                    "Exemplos de erro de truncamento"
                                  ],
                                  "tips": "Use h=10^-1 até 10^-6 para dramatizar o crescimento exponencial de custo.",
                                  "learningObjective": "Reconhecer e quantificar a ineficiência computacional de passos fixos pequenos.",
                                  "commonMistakes": [
                                    "Achar que h menor sempre melhora sem custo",
                                    "Não relacionar com controle adaptativo",
                                    "Ignorar overhead computacional real"
                                  ]
                                }
                              ],
                              "practicalExample": "Para integrar sin(x) de [0, π] com h=0.1: N=ceil(π/0.1)=32 passos. Custo por passo=10 ops → custo total=320 ops. Com h=0.01: N=ceil(π/0.01)=315 passos → custo=3150 ops (quase 10x mais, ilustrando ineficiência).",
                              "finalVerifications": [
                                "Calcule N corretamente para [0,1] com h=0.05 (N=20).",
                                "Estime custo total para C=5 ops e compare com h=0.01.",
                                "Identifique que custo cresce como 1/h.",
                                "Explique por que h=10^-6 é impraticável para intervalos grandes.",
                                "Crie tabela comparativa para dois intervalos diferentes.",
                                "Verifique cobertura: N*h >= b-a."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de N com ceil.",
                                "Correta proporcionalidade custo ∝ N * C.",
                                "Análise qualitativa da ineficiência para h pequeno.",
                                "Uso de exemplos numéricos concretos.",
                                "Interpretação gráfica ou tabular clara.",
                                "Conexão com necessidade de passos adaptativos."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Complexidade algorítmica O(1/h).",
                                "Física: Simulações numéricas em dinâmica (ex: Euler fixo vs adaptativo).",
                                "Engenharia: Otimização de tempo em CFD (Computational Fluid Dynamics).",
                                "Estatística: Monte Carlo com amostragem fixa vs adaptativa."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou financeiras, passos fixos pequenos causam sobrecarga computacional em supercomputadores; métodos adaptativos economizam horas/dias de processamento, permitindo previsões mais rápidas e precisas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Identificar regiões de variação suave na solução",
                            "description": "Analisar uma EDO de exemplo e reconhecer intervalos onde as derivadas são pequenas, justificando que passos pequenos fixos desperdiçam recursos computacionais sem melhorar a precisão local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de variação suave em soluções de EDOs",
                                  "subSteps": [
                                    "Defina variação suave como regiões onde a derivada primeira (ou lipschitz constante pequena) da solução é baixa, resultando em mudanças mínimas.",
                                    "Revise a relação entre a derivada y'(t) e a inclinação da solução y(t).",
                                    "Discuta como |y'(t)| pequeno implica curvatura baixa e estabilidade local.",
                                    "Examine exemplos qualitativos de EDOs lineares com coeficientes pequenos.",
                                    "Compare com regiões de alta variação onde |y'(t)| é grande."
                                  ],
                                  "verification": "Explique em suas palavras o que significa 'variação suave' e dê um exemplo verbal de uma EDO com tal região.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Livro-texto de EDOs, notas de aula sobre análise numérica.",
                                  "tips": "Visualize a solução como uma curva quase reta para intuitivamente captar suavidade.",
                                  "learningObjective": "Entender conceitualmente regiões de baixa derivada em soluções de EDOs.",
                                  "commonMistakes": "Confundir variação suave com solução constante; lembre que suave permite mudança lenta, não zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar graficamente uma solução de EDO exemplo",
                                  "subSteps": [
                                    "Escolha uma EDO simples como y' = -0.1 y, y(0)=1; solução analítica y(t) = e^{-0.1 t}.",
                                    "Plote a solução no intervalo [0, 50] usando software ou papel.",
                                    "Identifique visualmente intervalos iniciais (alta inclinação) vs tardios (quase horizontal).",
                                    "Marque pontos onde a inclinação visualmente diminui para <5% da máxima.",
                                    "Anote os intervalos aproximados de variação suave (ex: t > 20)."
                                  ],
                                  "verification": "Produza um gráfico anotado mostrando regiões de variação suave destacadas.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Python/MATLAB com matplotlib/Octave, ou calculadora gráfica.",
                                  "tips": "Use zoom no gráfico para regiões tardias; amplie eixo y para ver sutilezas.",
                                  "learningObjective": "Desenvolver habilidade em plotar e interpretar soluções graficamente.",
                                  "commonMistakes": "Ignorar escala; sempre normalize ou use log-plot para decaimentos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Quantificar derivadas para confirmar regiões suaves",
                                  "subSteps": [
                                    "Calcule y'(t) = -0.1 e^{-0.1 t} em pontos chave (t=0,10,20,30,...).",
                                    "Defina critério quantitativo: região suave se |y'(t)| < 0.01 * max|y'(t)|.",
                                    "Liste intervalos onde critério é satisfeito (ex: t>25).",
                                    "Compare valores numéricos com observação gráfica.",
                                    "Teste sensibilidade variando o coeficiente da EDO (ex: -0.05 y)."
                                  ],
                                  "verification": "Tabela com t, y(t), y'(t), e classificação suave/não-suave para 10 pontos.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": "Planilha Excel ou Python para cálculos/tabulares.",
                                  "tips": "Automatize cálculos em loop para eficiência; foque em threshold relativo.",
                                  "learningObjective": "Aplicar cálculo de derivadas para validação quantitativa.",
                                  "commonMistakes": "Usar threshold absoluto fixo; adapte ao problema específico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar ineficiência de passos fixos pequenos nessas regiões",
                                  "subSteps": [
                                    "Simule método de Euler com h fixo pequeno (ex: h=0.01) em região suave.",
                                    "Meça erro local: δy ≈ h * y'(t); note que pequeno h reduz δy desnecessariamente se y' já pequeno.",
                                    "Compare custo computacional (N passos) vs ganho de precisão (marginal).",
                                    "Argumente: em suave, h maior mantém erro baixo com menos passos.",
                                    "Conclua motivação para adaptativo: aumentar h em suave para eficiência."
                                  ],
                                  "verification": "Relatório curto com simulação, erro vs h, e justificativa de 2-3 parágrafos.",
                                  "estimatedTime": "40-60 minutos",
                                  "materials": "Código Python para Euler, cronômetro para contar passos.",
                                  "tips": "Rode simulações com h=0.1, 0.01, 0.001 e compare tempo/erro.",
                                  "learningObjective": "Ligar análise qualitativa/quantitativa à motivação computacional.",
                                  "commonMistakes": "Focar só em erro global; enfatize ineficiência local em suave."
                                }
                              ],
                              "practicalExample": "Para y' = -0.1 y, y(0)=1, no intervalo t∈[30,50], |y'(t)|<0.0005. Passos fixos h=0.01 usam 2000 passos, mas h=0.5 usa 40 passos com erro local similar (<10^{-5}), economizando 95% de computação sem perda de precisão.",
                              "finalVerifications": [
                                "Identifica corretamente ≥80% das regiões suaves em gráfico de EDO exemplo.",
                                "Calcula derivadas precisas e aplica threshold relativo adequadamente.",
                                "Justifica ineficiência com números de passos e erros comparados.",
                                "Explica verbalmente motivação para controle adaptativo.",
                                "Aplica conceito a nova EDO não vista (ex: y'=-0.05 sin(y)).",
                                "Discute limitações (ex: previsão de suavidade futura)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação gráfica/numérica de regiões (≥90% acerto).",
                                "Qualidade da justificativa computacional (lógica + evidência quantitativa).",
                                "Profundidade dos subpassos executados e verificações pessoais.",
                                "Clareza em gráficos, tabelas e relatórios.",
                                "Criatividade em exemplos/extensões além do fornecido.",
                                "Integração de conceitos (derivada, erro local, eficiência)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de solvers numéricos em Python/NumPy.",
                                "Física: Modelos de decaimento radioativo ou amortecimento suave.",
                                "Engenharia Computacional: Otimização em simulações CFD/FEM.",
                                "Estatística: Análise de séries temporais com baixa variância."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas, regiões de atmosfera estável (baixa derivada de variáveis) permitem passos maiores em modelos numéricos, reduzindo tempo de computação de horas para minutos em supercomputadores, essencial para previsões em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Comparar custos entre diferentes tamanhos de h fixo",
                            "description": "Comparar o tempo de execução estimado para h = 0.01 versus h = 0.1 em um problema simples, destacando o ganho logarítmico em precisão versus o custo linear em N.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Problema de Teste e Solução Exata",
                                  "subSteps": [
                                    "Escolha um problema ODE simples, como y' = -y com y(0) = 1 no intervalo [0, 5], cuja solução exata é y(x) = e^{-x}.",
                                    "Calcule a solução exata em pelo menos 5 pontos equidistantes no intervalo usando uma calculadora ou fórmula analítica.",
                                    "Defina métricas de precisão: erro máximo absoluto e erro no ponto final.",
                                    "Prepare um esqueleto de código em Python para o método numérico (ex: Euler forward).",
                                    "Documente os parâmetros iniciais: intervalo [a,b], condição inicial."
                                  ],
                                  "verification": "Verifique se a solução exata está corretamente computada e documentada em uma tabela ou lista.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Calculadora ou SymPy para solução exata"
                                  ],
                                  "tips": "Use intervalos onde a solução exata decaia visivelmente para destacar erros de precisão.",
                                  "learningObjective": "Compreender a importância de uma referência exata para medir precisão numérica.",
                                  "commonMistakes": [
                                    "Escolher problema sem solução fechada",
                                    "Intervalo muito curto onde erros são insignificantes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Executar com h = 0.1",
                                  "subSteps": [
                                    "Implemente o método de Euler com passo fixo h = 0.1 (N = (b-a)/h ≈ 50 passos).",
                                    "Meça o tempo de execução usando time.time() ou timeit, executando 100 repetições para precisão.",
                                    "Calcule o erro máximo e no ponto final comparado à solução exata.",
                                    "Plote a solução numérica vs exata usando Matplotlib.",
                                    "Registre tempo médio, número de passos N e erros."
                                  ],
                                  "verification": "Confirme que o código roda sem erros, tempo é medido corretamente e gráfico mostra boa aproximação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy, Matplotlib, time module"
                                  ],
                                  "tips": "Repita execuções para média confiável; evite plotar todos os pontos para h pequeno.",
                                  "learningObjective": "Executar simulação numérica básica e quantificar custo e precisão para h moderado.",
                                  "commonMistakes": [
                                    "Não medir tempo corretamente (incluir plot no timer)",
                                    "Erro de indexação no array de solução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Executar com h = 0.01",
                                  "subSteps": [
                                    "Modifique o código para h = 0.01 (N ≈ 500 passos).",
                                    "Repita as medições de tempo (100 execuções), erro máximo e final.",
                                    "Gere novo gráfico comparando com h=0.1 e exata.",
                                    "Note o aumento em N (10x) e compare tempos esperados (linear em N).",
                                    "Salve resultados em tabela: h, N, tempo médio, erro max."
                                  ],
                                  "verification": "Verifique se tempo é ~10x maior que h=0.1 e erro ~10x menor (para erro O(h)).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo ambiente Python anterior"
                                  ],
                                  "tips": "Aumente repetições se máquina for lenta; use %timeit no Jupyter para simplicidade.",
                                  "learningObjective": "Observar impacto de h menor no custo computacional linear em N.",
                                  "commonMistakes": [
                                    "Overflow ou lentidão excessiva por h muito pequeno",
                                    "Comparar erros sem normalizar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Resultados e Analisar Trade-offs",
                                  "subSteps": [
                                    "Crie tabela comparativa: h, N, tempo, erro max, ganho precisão/tempo.",
                                    "Calcule razão: (erro_h0.1 / erro_h0.01) vs (tempo_h0.01 / tempo_h0.1) ≈ 10x ganho precisão por 10x custo.",
                                    "Discuta ineficiência: para precisão extra, custo linear em N, mas ganho logarítmico efetivo em escalas maiores.",
                                    "Estenda análise: preveja para h=0.001 (100x custo por ~10x precisão).",
                                    "Escreva relatório curto destacando motivação para passos adaptativos."
                                  ],
                                  "verification": "Tabela completa e conclusão escrita reconhecendo custo linear vs ganho em precisão.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Pandas para tabelas",
                                    "Jupyter Notebook para relatório"
                                  ],
                                  "tips": "Use log-log plot de erro vs N para visualizar O(h) linear em log-precisão vs log-N.",
                                  "learningObjective": "Analisar quantitativamente por que passos fixos pequenos são computacionalmente ineficientes.",
                                  "commonMistakes": [
                                    "Ignorar overhead fixo no tempo",
                                    "Confundir ganho linear em precisão com logarítmico"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y + sin(x), y(0)=0 em [0,10] com Euler. Para h=0.1 (N=100), tempo~0.001s, erro~0.05; h=0.01 (N=1000), tempo~0.01s (10x), erro~0.005 (10x melhor), mostrando custo linear para ganho linear em precisão, mas ineficiente para alta precisão.",
                              "finalVerifications": [
                                "Tabela comparativa com h, N, tempo e erros corretos.",
                                "Gráficos mostram convergência com h menor.",
                                "Relatório identifica custo ~10x para precisão ~10x melhor.",
                                "Previsão correta para h=0.001: ~100x custo.",
                                "Conclusão liga à necessidade de controle adaptativo.",
                                "Código reproduzível sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas medições de tempo e erro (erro <5%).",
                                "Análise quantitativa clara do trade-off linear em N.",
                                "Uso correto de solução exata como referência.",
                                "Gráficos e tabelas profissionais e legíveis.",
                                "Relatório explica ganho logarítmico efetivo em precisão vs custo.",
                                "Código eficiente e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação eficiente e profiling de código.",
                                "Física: Simulações dinâmicas onde passos fixos limitam escalabilidade.",
                                "Computação Científica: Análise de complexidade O(N).",
                                "Estatística: Medição de erros e variância em tempos."
                              ],
                              "realWorldApplication": "Em simulações de engenharia (ex: CFD para aerodinâmica), usar h fixo pequeno para precisão alta torna simulações inviáveis em supercomputadores; controle adaptativo equilibra custo e precisão em tempo real."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Riscos de Precisão e Estabilidade com Passos Fixos Grandes",
                        "description": "Razões pelas quais passos fixos grandes levam a erros de truncamento elevados, perda de precisão global e possível instabilidade, especialmente em equações diferenciais ordinárias (EDOs) stiff ou com comportamento oscilatório.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Avaliar erro de truncamento local em métodos explícitos",
                            "description": "Para o método de Euler, estimar o erro local O(h^2) e mostrar como h grande amplifica esse erro, propagando-o para perda de precisão global ao longo do intervalo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Euler e Conceito de Erro de Truncamento Local",
                                  "subSteps": [
                                    "Relembrar a fórmula do método de Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Entender erro de truncamento local como a diferença entre a solução exata em um passo e a aproximação do método.",
                                    "Explicar que para Euler, o erro local é proporcional a h^2 devido à expansão de Taylor da solução exata.",
                                    "Diferenciar erro local (por passo) de erro global (acumulado ao longo do intervalo)."
                                  ],
                                  "verification": "Escrever a fórmula do Euler e definir erro local em suas próprias palavras, com exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica (cap. métodos ODE), caderno de anotações.",
                                  "tips": "Visualize graficamente: desenhe a reta tangente vs. curva real para um passo.",
                                  "learningObjective": "Compreender os fundamentos teóricos do erro local no método de Euler.",
                                  "commonMistakes": "Confundir erro local com global; ignorar que é O(h^2) por passo, não total."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Estimação Analítica do Erro Local O(h^2)",
                                  "subSteps": [
                                    "Expandir a solução exata y(t_n + h) via série de Taylor: y(t_n) + h y'(t_n) + (h^2/2) y''(ξ).",
                                    "Substituir y' = f(t,y) e notar que Euler aproxima apenas até o termo h y'.",
                                    "Concluir que erro local τ = y(t_n + h) - y_{n+1} ≈ (h^2/2) y''(ξ), logo O(h^2).",
                                    "Verificar para y' = f(t,y) suave, assumindo Lipschitz e derivadas contínuas."
                                  ],
                                  "verification": "Derivar a expressão do erro local em papel e confirmar O(h^2).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis, calculadora simbólica (opcional, como SymPy).",
                                  "tips": "Use um exemplo simples como y' = y para y'' = y, facilitando cálculos.",
                                  "learningObjective": "Derivar matematicamente a ordem do erro local para Euler.",
                                  "commonMistakes": "Esquecer o termo ξ na média de Taylor; confundir com erro global O(h)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Numericamente o Erro Local com Diferentes Valores de h",
                                  "subSteps": [
                                    "Escolher EDO teste: y' = -y, y(0)=1, solução y=e^{-t}, em [0,1].",
                                    "Implementar Euler em Python/MATLAB para um único passo com h pequeno (0.01) e grande (0.2).",
                                    "Calcular erro local: |y(h)_exata - y_1_Euler| e comparar com (h^2/2) |y''(ξ)| ≈ (h^2/2).",
                                    "Plotar erro local vs. h em log-log para confirmar inclinação 2 (O(h^2)).",
                                    "Repetir para h grande, notando amplificação relativa."
                                  ],
                                  "verification": "Gerar tabela/plots mostrando erro local ≈ C h^2 para constantes C.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python (NumPy, Matplotlib), Jupyter Notebook.",
                                  "tips": "Use np.logspace para h variando ordens de magnitude.",
                                  "learningObjective": "Validar teoricamente o erro local via simulação computacional.",
                                  "commonMistakes": "Usar erro global em vez de local; escala errada no plot log-log."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Propagação do Erro Local para Perda de Precisão Global",
                                  "subSteps": [
                                    "Executar Euler em todo [0,1] com h fixo grande (ex: h=0.5, N=2 passos).",
                                    "Comparar solução global com exata, mostrando ||erro global|| ≈ N * erro_local ≈ (T/h) * O(h^2) = O(h).",
                                    "Demonstrar instabilidade: para h grande, erro acumula rapidamente, perdendo precisão.",
                                    "Discutir motivação para controle adaptativo: reduzir h onde erro local é alto."
                                  ],
                                  "verification": "Relatório com gráficos de solução Euler vs. exata para h pequeno/grande.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código Python do passo anterior, software de plotagem.",
                                  "tips": "Compute norma L2 ou máximo do erro global para quantificar.",
                                  "learningObjective": "Entender como erro local amplificado por h grande causa falha global.",
                                  "commonMistakes": "Ignorar número de passos N= T/h na propagação; subestimar acumulação."
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1 em [0,1] (exata y=e^{-2t}), com h=0.1: erro local ≈ (0.1)^2 /2 * |y''| ≈ 0.0005; com h=0.5: ≈0.0125, 25x maior. Ao longo de 10 passos (h=0.1), erro global <0.01; com 2 passos (h=0.5), >0.1, mostrando perda de precisão.",
                              "finalVerifications": [
                                "Deriva corretamente o erro local O(h^2) via Taylor.",
                                "Implementa simulação numérica confirmando ordem 2 em log-log.",
                                "Calcula e interpreta propagação para erro global O(h).",
                                "Explica verbalmente riscos de h grande em contexto de estabilidade.",
                                "Propõe adaptação de h baseada em estimativa de erro local."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação analítica (equações corretas, ordem exata).",
                                "Qualidade da simulação (plots claros, convergência verificada).",
                                "Análise quantitativa da amplificação (fatores numéricos corretos).",
                                "Compreensão conceitual (explicação clara de propagação).",
                                "Criatividade em exemplos (aplicação além do fornecido)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python reforça computação científica.",
                                "Física: Modelagem de decaimento radioativo onde precisão afeta previsões.",
                                "Estatística: Análise de erro em simulações Monte Carlo.",
                                "Engenharia: Controle de sistemas dinâmicos com passos adaptativos."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou trajetórias de foguetes, h fixo grande causa erros acumulados, levando a previsões falhas; controle adaptativo baseado em erro local O(h^2) garante precisão eficiente em CFD ou finanças (modelos Black-Scholes)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Reconhecer instabilidade em problemas stiff",
                            "description": "Exemplificar com uma EDO stiff como y' = -1000(y - cos(t)) + sin(t), demonstrando que h fixo grande viola a condição de estabilidade |1 + hλ| < 1 para autovalores λ negativos grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de problemas stiff e estabilidade numérica",
                                  "subSteps": [
                                    "Defina um problema stiff como uma EDO com autovalores da jacobiana com partes reais grandes negativas (ex.: |Re(λ)| >> 1).",
                                    "Explique a condição de estabilidade absoluta para o método de Euler forward: |1 + hλ| < 1 para todos os autovalores λ.",
                                    "Discuta como passos h fixos grandes violam essa condição, levando a oscilações ou divergência.",
                                    "Revise o método de Euler forward: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Identifique escalas de tempo separadas em problemas stiff (rápida e lenta)."
                                  ],
                                  "verification": "Escreva uma definição precisa de problema stiff e a condição |1 + hλ| < 1 em suas próprias palavras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notebook com Python ou MATLAB para anotações",
                                    "Referência: Livro de Análise Numérica (ex. Burden & Faires)"
                                  ],
                                  "tips": "Foquem nos autovalores da linearização; stiff surge de rigidez inerente, não só não-linearidade.",
                                  "learningObjective": "Entender os fundamentos teóricos de estabilidade em EDOs stiff.",
                                  "commonMistakes": [
                                    "Confundir stiff com problemas não-lineares apenas.",
                                    "Ignorar que λ são autovalores da matriz jacobiana f_y.",
                                    "Achar que h pequeno sempre resolve sem controle adaptativo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a EDO exemplo: y' = -1000(y - cos(t)) + sin(t)",
                                  "subSteps": [
                                    "Reescreva a EDO na forma y' = f(t,y): y' = -1000y + 1000 cos(t) + sin(t).",
                                    "Linearize ao redor da solução: jacobiana f_y = -1000, então λ ≈ -1000 (grande negativo).",
                                    "Solucione analiticamente aproximada: equilíbrio em y ≈ cos(t), com decaimento rápido devido a -1000y.",
                                    "Calcule a solução exata ou particular: y(t) = cos(t) + e^{-1000t} c (decaimento rápido).",
                                    "Discuta por que é stiff: termo rápido e^{-1000t} vs oscilação lenta cos(t)."
                                  ],
                                  "verification": "Identifique λ = -1000 e explique por que o problema é stiff com base na magnitude de λ.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou papel)",
                                    "Gráfico mental da solução exata"
                                  ],
                                  "tips": "Aproxime λ da derivada parcial f_y; ignore termos forçantes iniciais para rigidez.",
                                  "learningObjective": "Reconhecer características stiff na forma da EDO.",
                                  "commonMistakes": [
                                    "Esquecer de linearizar para encontrar λ.",
                                    "Confundir o termo sin(t) como causa de stiff.",
                                    "Não notar o decaimento exponencial rápido."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Euler forward com h fixo grande e observar instabilidade",
                                  "subSteps": [
                                    "Implemente Euler forward em código: escolha h = 0.01 (grande para |λ| = 1000, pois h|λ| ≈ 10 > 2).",
                                    "Simule de t=0 a t=1 com y(0)=1, plote y_n vs t_n.",
                                    "Observe oscilações espúrias ou divergência (viola |1 + hλ| = |1 - 10| = 9 > 1).",
                                    "Compare com h pequeno (ex. h=0.0001, h|λ|=0.1 <1): solução estável e precisa.",
                                    "Calcule explicitamente |1 + hλ| para h=0.01 e confirme >1."
                                  ],
                                  "verification": "Gere plots mostrando instabilidade com h grande vs estabilidade com h pequeno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Código template para Euler: def euler(f, y0, tspan, h): ..."
                                  ],
                                  "tips": "Use intervalos pequenos para plot; normalize erro relativo |y_num - cos(t)|.",
                                  "learningObjective": "Demonstrar numericamente a violação da estabilidade.",
                                  "commonMistakes": [
                                    "Escolher h muito pequeno inicialmente sem testar grande.",
                                    "Não plotar solução exata para comparação.",
                                    "Ignorar condição absoluta vs regional."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e concluir reconhecimento de instabilidade em stiff",
                                  "subSteps": [
                                    "Resuma: para λ=-1000, h max estável ≈ 0.002 (de |1 + hλ|<1 → h < 2/1000).",
                                    "Teste h=0.002: borderline estável; h=0.003: instável.",
                                    "Discuta necessidade de controle adaptativo de passo (reduzir h onde necessário).",
                                    "Crie tabela: h | |1+hλ| | Comportamento (estável/instável).",
                                    "Explique riscos: perda de precisão e tempo computacional com h fixo."
                                  ],
                                  "verification": "Preencha tabela de estabilidade e identifique h crítico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou código para tabela",
                                    "Plots anteriores"
                                  ],
                                  "tips": "Regra prática: h < 2 / |Re(λ_max)| para Euler.",
                                  "learningObjective": "Aplicar critério de estabilidade para reconhecer instabilidade.",
                                  "commonMistakes": [
                                    "Calcular |1 + hλ| errado (esquecer sinal negativo).",
                                    "Achar que todos os métodos explícitos falham igualmente.",
                                    "Não ligar à motivação para passos adaptativos."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule y' = -1000(y - cos(t)) + sin(t), y(0)=0 em [0,5] com Euler e h=0.01: solução numérica explode em oscilações selvagens em vez de seguir cos(t) suavemente após decaimento inicial rápido. Com h=10^{-4}, aproxima cos(t) bem.",
                              "finalVerifications": [
                                "Identifica corretamente λ ≈ -1000 como causa de stiff.",
                                "Calcula |1 + hλ| para h dado e determina se <1.",
                                "Gera plot numérico mostrando instabilidade com h grande.",
                                "Explica ligação entre violação de estabilidade e comportamento observado.",
                                "Compara h grande vs pequeno, reconhecendo necessidade adaptativa.",
                                "Resume riscos de precisão/estabilidade com passos fixos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de λ e classificação como stiff (exato).",
                                "Correta derivação e cálculo da condição |1 + hλ| < 1.",
                                "Qualidade dos plots/simulações: clara demonstração de instabilidade.",
                                "Explicação coerente ligando teoria à prática numérica.",
                                "Análise de h crítico e implicações para controle de passo.",
                                "Clareza na tabela de verificação de estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores amortecidos com atrito forte (rigidez).",
                                "Computação: Implementação de solvers ODE em bibliotecas como SciPy (odeint vs solve_ivp).",
                                "Engenharia Química: Simulações de reações com cinéticas rápidas/lentas.",
                                "Engenharia Elétrica: Análise de circuitos RC com constantes de tempo díspares."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas (ex. combustão), onde escalas rápidas (radicais livres) e lentas (produtos) causam stiff; h fixo grande leva a instabilidade, desperdiçando tempo ou crashando simulações em software como COMSOL ou CFD."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Diferenciar erro global de erro local",
                            "description": "Explicar como erros locais se acumulam em erros globais O(h) para métodos de ordem 1, justificando a necessidade de h pequeno para precisão, mas conflitando com eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de erro local em métodos numéricos",
                                  "subSteps": [
                                    "Defina erro local como o erro introduzido em uma única iteração de um método numérico, como o método de Euler.",
                                    "Estude a fórmula do erro local para métodos de ordem p: O(h^{p+1}), onde h é o tamanho do passo.",
                                    "Exemplo: No método de Euler (ordem 1), erro local é O(h^2).",
                                    "Derive qualitativamente por que o erro local surge da aproximação linear da solução exata.",
                                    "Calcule um erro local simples para uma EDO y' = f(x,y) em um passo."
                                  ],
                                  "verification": "Capacidade de calcular e explicar o erro local em um exemplo numérico simples com precisão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Livro de Análise Numérica (cap. métodos para EDOs)"
                                  ],
                                  "tips": "Visualize o erro local como a diferença entre a tangente e a curva real em um ponto.",
                                  "learningObjective": "Identificar e quantificar o erro introduzido por um único passo numérico.",
                                  "commonMistakes": "Confundir erro local com truncamento global; ignorar dependência em h^{p+1}."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de erro global e sua acumulação",
                                  "subSteps": [
                                    "Defina erro global como o erro total acumulado do início ao fim do intervalo de integração.",
                                    "Explique que erros locais se somam telescopicamente ao longo de N = T/h passos.",
                                    "Para métodos de ordem 1, mostre que erro global ≈ (T/h) * O(h^2) = O(h).",
                                    "Discuta estabilidade e como erros podem crescer exponencialmente em problemas rígidos.",
                                    "Compare com métodos de ordem superior, onde erro global é O(h^p)."
                                  ],
                                  "verification": "Derivar a relação qualitativa entre erro local e global para um método de ordem 1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Software como Python/MATLAB para plotar erros",
                                    "Notas de aula sobre EDOs"
                                  ],
                                  "tips": "Pense na soma telescópica: cada erro local contribui additivamente ao total.",
                                  "learningObjective": "Explicar a acumulação de erros locais em erro global O(h) para ordem 1.",
                                  "commonMistakes": "Achar que erros se cancelam; esquecer fator 1/h no número de passos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o trade-off entre precisão (h pequeno) e eficiência computacional",
                                  "subSteps": [
                                    "Mostre que para precisão (erro global pequeno), h deve ser pequeno, mas N = T/h aumenta.",
                                    "Calcule custo computacional: tempo ∝ N ∝ 1/h.",
                                    "Exemplo numérico: compare tempo e erro para h=0.1 vs h=0.01 em uma EDO simples.",
                                    "Discuta conflito: h pequeno → precisão boa, mas custo alto; h grande → eficiente, mas impreciso.",
                                    "Introduza motivação para h adaptativo: variar h localmente."
                                  ],
                                  "verification": "Quantificar em uma tabela o erro e número de passos para diferentes h.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python ou Octave para simulação rápida",
                                    "Planilha Excel para tabelas de erro"
                                  ],
                                  "tips": "Sempre normalize pelo intervalo total T para generalizar.",
                                  "learningObjective": "Justificar necessidade de h pequeno para precisão apesar do custo.",
                                  "commonMistakes": "Ignorar custo em flops; superestimar cancelamento de erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar erro local de global em contexto de controle adaptativo",
                                  "subSteps": [
                                    "Resuma diferenças: local (por passo, O(h^{p+1})), global (total, O(h^p)).",
                                    "Aplique a uma EDO exemplo: y' = -y, y(0)=1, até x=1.",
                                    "Estime erros locais e some para global com h fixo grande/pequeno.",
                                    "Conclua riscos de passos fixos grandes: instabilidade e baixa precisão.",
                                    "Relacione com necessidade de controle adaptativo para equilibrar."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferenciação com exemplo concreto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Gráfico da solução exata y=e^{-x}",
                                    "Código pronto de Euler em Python"
                                  ],
                                  "tips": "Use exemplos lineares simples primeiro para isolar o efeito.",
                                  "learningObjective": "Diferenciar conceitual e quantitativamente os dois tipos de erro.",
                                  "commonMistakes": "Trocar ordens: confundir O(h) local com global."
                                }
                              ],
                              "practicalExample": "Considere y' = -y, y(0)=1 (solução exata y=e^{-x}). Use Euler com h=0.5 até x=1 (2 passos): y1≈0.75 (exata≈0.607), erro local≈0.143 no 1º passo; global≈0.143. Com h=0.1 (10 passos), erro global≈0.031. Note: h menor reduz erro de O(h)=0.5 para 0.1, mas 5x mais passos.",
                              "finalVerifications": [
                                "Calcular corretamente erro local O(h^2) e global O(h) para ordem 1.",
                                "Explicar acumulação via soma telescópica.",
                                "Identificar trade-off h pequeno (precisão) vs grande (eficiência).",
                                "Aplicar a exemplo numérico com valores corretos.",
                                "Relacionar com motivação para passos adaptativos.",
                                "Diferenciar qualitativamente em parágrafo coeso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da ordem dos erros (local vs global).",
                                "Clareza na explicação da acumulação e trade-off.",
                                "Correção em cálculos numéricos de exemplo.",
                                "Uso adequado de notação O(h) e dependências.",
                                "Profundidade na justificativa para controle adaptativo.",
                                "Capacidade de generalizar para outros métodos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Euler em Python para visualizar erros.",
                                "Física: Simulações de movimento com métodos numéricos (ex: osciladores).",
                                "Estatística: Análise de erro e convergência em modelagem estocástica.",
                                "Engenharia: Otimização de passos em simulações CFD."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou dinâmicas de voo (ex: NASA), h fixo grande causa erros globais acumulados levando a previsões erradas; controle adaptativo equilibra precisão e tempo de CPU em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Vantagens do Controle Adaptativo de Passo",
                        "description": "Motivação para ajustes dinâmicos de h baseados em estimativas de erro local, equilibrando eficiência computacional com precisão desejada e lidando com variações na solução.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Entender estimativa de erro local em passos duplos",
                            "description": "Descrever o uso de métodos de passo simples (ex: Runge-Kutta 4) e múltiplo para estimar erro local como |y_{n+1}^{(1)} - y_{n+1}^{(2)}|, motivando aceitação/rejeição de passos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método Runge-Kutta de Ordem 4 (RK4) para Passo Simples",
                                  "subSteps": [
                                    "Lembre a fórmula do RK4: k1 = f(t_n, y_n), k2 = f(t_n + h/2, y_n + h k1/2), k3 = f(t_n + h/2, y_n + h k2/2), k4 = f(t_n + h, y_n + h k3), y_{n+1} = y_n + (h/6)(k1 + 2k2 + 2k3 + k4).",
                                    "Implemente RK4 em um exemplo simples: y' = -y, y(0)=1, h=0.1.",
                                    "Calcule manualmente um passo para entender a precisão local O(h^5).",
                                    "Compare com solução exata para visualizar erro.",
                                    "Discuta truncamento local vs global."
                                  ],
                                  "verification": "Calcule y(0.1) com RK4 e compare com exata e=exp(-0.1)≈0.9048; erro <0.001 confirma compreensão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, calculadora, software como Python/MATLAB para verificação.",
                                  "tips": "Use função f(t,y) simbólica para evitar erros aritméticos.",
                                  "learningObjective": "Dominar aplicação de RK4 em passo único e seu erro de truncamento local.",
                                  "commonMistakes": "Confundir k_i com médias erradas; esquecer fator h/6."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceito de Passos Duplos: h vs. 2*(h/2)",
                                  "subSteps": [
                                    "Explique passo duplo: Solução com h (y_{n+1}^{(1)}) vs. dois passos de h/2 (y_{n+1}^{(2)}).",
                                    "Mostre que para método ordem p, y^{(1)} = y_exata + C h^{p+1} + O(h^{p+2}), y^{(2)} = y_exata + (C/2^{p+1}) h^{p+1} + O(h^{p+2}).",
                                    "Derive estimativa de erro local: |y^{(1)} - y^{(2)}| ≈ |1 - 1/2^{p+1}| |erro|. Para p=4, fator ≈15/16.",
                                    "Calcule para exemplo y'=-y, h=0.1: dois passos h/2=0.05.",
                                    "Verifique consistência com erro de passo simples."
                                  ],
                                  "verification": "Para h=0.1, |y^{(1)}-y^{(2)}| ≈ 1.25e-5, escalando com h^5.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou script Python para automação de passos duplos.",
                                  "tips": "Automatize iterações para evitar cálculos manuais tediosos.",
                                  "learningObjective": "Compreender por que passos duplos estimam erro sem solução exata.",
                                  "commonMistakes": "Usar um passo h/2 em vez de dois; ignorar fator de escala 1-2^{-5}."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Interpretar Estimativa de Erro Local",
                                  "subSteps": [
                                    "Defina erro local estimado: err = |y_{n+1}^{(1)} - y_{n+1}^{(2)}|.",
                                    "Ajuste para ordem exata: est_err = |y^{(1)} - y^{(2)}| / (1 - 1/2^5) ≈ 1.04167 * diff.",
                                    "Teste em EDO não-linear: y'=y(1-y), y(0)=0.5, h=0.1.",
                                    "Plote err vs h para várias h, confirmando O(h^5).",
                                    "Discuta quando estimativa falha (ex: h muito grande)."
                                  ],
                                  "verification": "Gráfico log-log de err vs h tem inclinação ≈5.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NumPy/Matplotlib para plotagem.",
                                  "tips": "Use tol=1e-6 para comparar diffs numéricas.",
                                  "learningObjective": "Calcular e escalar estimativa de erro local precisamente.",
                                  "commonMistakes": "Não escalar pelo fator 15/16; confundir local com global."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Critério de Aceitação/Rejeição de Passos",
                                  "subSteps": [
                                    "Defina tolerância atol, rtol; aceita se est_err <= max(atol, rtol * |y_{n+1}|).",
                                    "Se rejeitado, reduza h = h * 0.8 * sqrt(tol/est_err).",
                                    "Se aceito, ajuste próximo h = h * 1.2 * sqrt(tol/est_err), cap h_max.",
                                    "Simule trajetória completa com controle para y'=-y.",
                                    "Compare eficiência vs passo fixo."
                                  ],
                                  "verification": "Trajetória controlada converge à exata com menos passos rejeitados que fixo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python implementando solver adaptativo.",
                                  "tips": "Limite fator h entre 0.3-2 para estabilidade.",
                                  "learningObjective": "Implementar decisão aceita/rejeita baseada em erro estimado.",
                                  "commonMistakes": "Não normalizar por rtol; h explode por fator >1.5."
                                }
                              ],
                              "practicalExample": "Para EDO y' = -2y, y(0)=1 (exata y=exp(-2t)), em t=0, h=0.2: RK4 h dá y1≈0.6065; dois h/2=0.1 dá y2≈0.6069; err=|0.6065-0.6069|≈4e-5 < tol=1e-3, aceita e reduz h próximo.",
                              "finalVerifications": [
                                "Calcule corretamente y^{(1)} e y^{(2)} para RK4 em EDO linear.",
                                "Estime err escalado e compare com exata.",
                                "Implemente aceita/rejeita em código simples.",
                                "Explique motivação: eficiência sem solução exata.",
                                "Identifique O(h^5) em gráfico.",
                                "Ajuste h corretamente em rejeição."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivacão do fator de escala (15/16 para ordem 4).",
                                "Cálculos numéricos sem erros aritméticos >1e-6.",
                                "Implementação funcional de passos duplos.",
                                "Explicação clara de aceitação/rejeição.",
                                "Análise de eficiência vs passo fixo.",
                                "Identificação de pitfalls como h grande."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/SciPy (odeint usa similar).",
                                "Física: Simulações dinâmicas (órbitas, circuitos).",
                                "Estatística: Controle de erro em Monte Carlo.",
                                "Engenharia: Otimização numérica em CAD/CAE."
                              ],
                              "realWorldApplication": "Em solvers de EDOs como MATLAB ode45 ou SciPy solve_ivp, controla precisão adaptativa em simulações climáticas, farmacocinética e trajetórias espaciais, economizando tempo computacional."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Definir tolerância de erro para adaptação",
                            "description": "Explicar como definir tol = 10^{-p} e ajustar h novo = h * (tol / erro_est)^{1/(p+1)} para manter erro local abaixo de tol, otimizando o processo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de tolerância de erro e ordem do método",
                                  "subSteps": [
                                    "Revise a definição de erro local em métodos numéricos de integração de EDOs.",
                                    "Identifique a ordem p do método (ex: p=1 para Euler, p=4 para RK4).",
                                    "Explique por que tol controla a precisão global aproximada.",
                                    "Discuta o trade-off entre tol pequeno (precisão alta, custo computacional alto) e tol grande.",
                                    "Calcule exemplos manuais de erro local para um método simples."
                                  ],
                                  "verification": "Resuma em 3 frases o papel de tol e p no controle de erro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica, caderno, calculadora.",
                                  "tips": "Use diagramas de erro vs. h para visualizar dependência O(h^{p+1}).",
                                  "learningObjective": "Entender como tol = 10^{-p} equilibra precisão local e global.",
                                  "commonMistakes": "Confundir erro local com global; ignorar que tol é para erro local."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a tolerância de erro tol",
                                  "subSteps": [
                                    "Escolha p baseado no método (ex: p=1 para forward Euler).",
                                    "Defina tol = 10^{-p}, ajustando para precisão desejada (ex: tol=10^{-6} para p=5).",
                                    "Justifique a escolha de tol em termos de dígitos significativos.",
                                    "Compare tol com epsilon da máquina para evitar underflow.",
                                    "Registre tol e p em um log de simulação."
                                  ],
                                  "verification": "Calcule tol para p=2 e p=4, justificando valores.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora científica, tabela de ordens de métodos.",
                                  "tips": "Escolha tol ~ 10^{-d} onde d é dígitos desejados, escalonado por p.",
                                  "learningObjective": "Selecionar tol apropriado para método e precisão alvo.",
                                  "commonMistakes": "Usar tol fixo independente de p; tol muito pequeno causando rejeições infinitas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar o erro local e calcular novo h",
                                  "subSteps": [
                                    "Implemente estimativa de erro local (ex: diferença entre soluções de ordens diferentes).",
                                    "Calcule erro_est do passo atual.",
                                    "Aplique fórmula: h_novo = h * (tol / erro_est)^{1/(p+1)}",
                                    "Aplique fator de segurança (ex: 0.9) para evitar oscilações.",
                                    "Decida aceitar/rejeitar passo baseado em erro_est < tol."
                                  ],
                                  "verification": "Resolva exemplo numérico com h=0.1, erro_est=1e-3, p=1, tol=1e-2; calcule h_novo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel milimetrado, software como Python/MATLAB para teste.",
                                  "tips": "Use estimativa embutida como em RK adaptativo para precisão.",
                                  "learningObjective": "Aplicar fórmula de ajuste de h para controlar erro abaixo de tol.",
                                  "commonMistakes": "Esquecer expoente 1/(p+1); não limitar h_novo (min/max)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e otimizar o loop de adaptação",
                                  "subSteps": [
                                    "Escreva pseudocódigo para loop: estime erro, ajuste h, avance se aceito.",
                                    "Inclua limites: h_min, h_max para estabilidade.",
                                    "Teste com EDO simples (ex: y' = -y, y(0)=1).",
                                    "Monitore número de passos e tempo total vs. h fixo.",
                                    "Ajuste tol dinamicamente se necessário para eficiência."
                                  ],
                                  "verification": "Simule 5 passos e verifique se todos erros < tol.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python/Jupyter), EDO de teste.",
                                  "tips": "Comece com h inicial conservador (pequeno) para boa estimativa inicial.",
                                  "learningObjective": "Integrar controle adaptativo em algoritmo numérico completo.",
                                  "commonMistakes": "Loop infinito por h->0; ignorar rejeições excessivas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e refinar o processo de adaptação",
                                  "subSteps": [
                                    "Compare solução adaptativa com solução exata/referência.",
                                    "Calcule custo (nº passos) vs. precisão alcançada.",
                                    "Analise gráfico de h vs. t e erro vs. t.",
                                    "Otimize fatores (segurança, expoentes) baseado em testes.",
                                    "Documente vantagens sobre h fixo."
                                  ],
                                  "verification": "Gere relatório com métricas: erro global < tol * sqrt(N), N passos reduzido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos (Matplotlib), solução analítica.",
                                  "tips": "Use log-plot para erros em escalas variadas.",
                                  "learningObjective": "Validar eficácia do controle adaptativo de passo.",
                                  "commonMistakes": "Atribuir erro global diretamente a tol local sem escalonamento."
                                }
                              ],
                              "practicalExample": "Ao resolver y' = y, y(0)=1 até t=1 com Euler (p=1), tol=1e-3: inicie h=0.1, estime erro_est=0.005 > tol, calcule h_novo=0.1*(0.001/0.005)^{1/2} ≈ 0.0447, avance e repita até solução precisa com menos passos que h fixo.",
                              "finalVerifications": [
                                "Todos passos têm erro_est < tol.",
                                "h ajusta dinamicamente sem exceder h_min/h_max.",
                                "Erro global ≈ tol.",
                                "Número de passos otimizado vs. h fixo equivalente.",
                                "Solução converge para referência exata.",
                                "Log registra tol, p, erros e hs."
                              ],
                              "assessmentCriteria": [
                                "Correta definição de tol = 10^{-p} com justificativa.",
                                "Fórmula de h_novo aplicada precisamente em exemplos.",
                                "Pseudocódigo funcional simula adaptação corretamente.",
                                "Análise quantitativa mostra otimização (precisão/custo).",
                                "Identificação de erros comuns e correções.",
                                "Explicação clara de trade-offs em relatórios."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/NumPy para solvers ODE.",
                                "Física: Simulações dinâmicas (ex: movimento planetário).",
                                "Estatística: Controle de precisão em Monte Carlo.",
                                "Engenharia: Otimização em controle de sistemas.",
                                "Ciência de Dados: Ajuste adaptativo em ML training."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou farmacocinéticas, controle adaptativo de passo permite precisão alta em regiões críticas (ex: singularidades) com eficiência computacional, reduzindo tempo de simulação de horas para minutos em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Comparar desempenho adaptativo vs fixo",
                            "description": "Em um exemplo numérico, contrastar o número total de passos e tempo computacional de um solver adaptativo versus fixo, destacando reduções significativas em problemas com escalas variáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema numérico de teste",
                                  "subSteps": [
                                    "Escolha uma EDO de primeira ordem com comportamento de escala variável, como y' = -10 y (1 - y), y(0) = 0.1, integrada de t=0 a t=5.",
                                    "Identifique regiões de mudança rápida (início) e suave (fim) para demonstrar necessidade de adaptação.",
                                    "Defina tolerância de erro global (ex: 1e-4) e intervalo de confiança para comparação.",
                                    "Calcule a solução analítica aproximada ou referenciada para validação.",
                                    "Documente parâmetros iniciais: h_inicial = 0.1 para fixo, h_inicial = 0.05 para adaptativo."
                                  ],
                                  "verification": "Verifique se o problema está documentado com solução referenciada e parâmetros claros; compare com solução exata em pontos chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, Python ou MATLAB para protótipo rápido, tabela de valores analíticos.",
                                  "tips": "Escolha lambda=-10 para stiff inicial; teste com plot da solução para visualizar escalas.",
                                  "learningObjective": "Compreender como problemas com escalas variáveis motivam controle adaptativo.",
                                  "commonMistakes": "Ignorar solução analítica, levando a comparações inválidas; escolher problema sem variação de escala."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e executar solver com passo fixo",
                                  "subSteps": [
                                    "Implemente o método de Euler ou RK4 com h fixo = 0.05 em pseudocódigo ou código.",
                                    "Execute a integração até t=5, contando o número total de passos (N_fix = 5 / 0.05 = 100).",
                                    "Meça tempo computacional (use timer em código).",
                                    "Calcule erro global máximo vs solução referenciada.",
                                    "Registre métricas: passos, tempo, erro."
                                  ],
                                  "verification": "Confirme N_fix correto e erro < 1e-3; visualize solução plotada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python/Jupyter), biblioteca NumPy/MATLAB.",
                                  "tips": "Use h pequeno o suficiente para precisão, mas fixo causa ineficiência em regiões suaves.",
                                  "learningObjective": "Executar solver fixo e quantificar sua ineficiência em problemas não-uniformes.",
                                  "commonMistakes": "Não medir tempo real (use timeit); confundir passos com iterações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e executar solver adaptativo",
                                  "subSteps": [
                                    "Implemente controle adaptativo: estime erro local com 2 passos (h e h/2), ajuste h = h * (tol/err)^{1/2}.",
                                    "Inicie com h=0.05, min_h=1e-4, max_h=0.2; pare se err > tol ou h < min_h.",
                                    "Execute até t=5, contando passos (N_adapt esperado ~40-60).",
                                    "Meça tempo computacional e erro global.",
                                    "Registre métricas comparáveis."
                                  ],
                                  "verification": "Verifique redução em passos (>30%) e erro similar ao fixo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo código do step 2, adicionar funções de erro local (RK embedded opcional).",
                                  "tips": "Implemente fator de segurança 0.9 no ajuste de h para estabilidade.",
                                  "learningObjective": "Dominar algoritmo adaptativo básico e sua eficiência.",
                                  "commonMistakes": "Ajuste de h muito agressivo causando oscilações; não tratar rejeições de passo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Coletar e tabular métricas de desempenho",
                                  "subSteps": [
                                    "Crie tabela: colunas para Método, Passos Totais, Tempo (s), Erro Máx, Eficiência (passos/precisão).",
                                    "Execute múltiplas runs (média de 5) para estatísticas.",
                                    "Calcule reduções: %redução_passos = (1 - N_adapt/N_fix)*100.",
                                    "Gere gráficos: passos vs t, solução vs t para ambos.",
                                    "Anote observações qualitativas (ex: passos pequenos no início)."
                                  ],
                                  "verification": "Tabela completa com reduções >30% em passos e tempo similar erro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel/Google Sheets ou Pandas para tabela, Matplotlib para plots.",
                                  "tips": "Normalize tempo por precisão para comparação justa.",
                                  "learningObjective": "Quantificar vantagens numéricas do adaptativo.",
                                  "commonMistakes": "Comparar sem normalizar erro; ignorar overhead do adaptativo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e contrastar resultados",
                                  "subSteps": [
                                    "Discuta reduções: ex N_fix=100, tempo=0.01s vs N_adapt=45, tempo=0.008s.",
                                    "Explique por quê: adaptativo usa h grande onde preciso, pequeno onde necessário.",
                                    "Teste sensibilidade: varie lambda ou tolerância.",
                                    "Conclua vantagens em problemas reais com escalas variáveis.",
                                    "Resuma em relatório de 1 página."
                                  ],
                                  "verification": "Relatório destaca reduções significativas (>30%) com evidências.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documento Word/LaTeX, gráficos do step 4.",
                                  "tips": "Use bullet points para clareza; inclua equações de ajuste de h.",
                                  "learningObjective": "Interpretar resultados para justificar controle adaptativo.",
                                  "commonMistakes": "Atribuir redução só a sorte; não generalizar para stiff problems."
                                }
                              ],
                              "practicalExample": "Para y' = -10 y (1 - y), y(0)=0.1, t=[0,5]: Solver fixo h=0.05 usa 100 passos, tempo ~0.012s, erro max=8e-4. Adaptativo usa 52 passos (48% menos), tempo ~0.009s (25% menos), erro max=7e-4. Redução drástica no início rápido, h cresce para ~0.15 no final suave.",
                              "finalVerifications": [
                                "Tabela de métricas mostra redução >30% em passos para adaptativo.",
                                "Gráficos confirmam h variável no adaptativo.",
                                "Erro global similar (<1e-3) entre métodos.",
                                "Relatório explica mecanismo de redução.",
                                "Teste com variação de parâmetros reproduz resultados.",
                                "Solução plotada converge à analítica."
                              ],
                              "assessmentCriteria": [
                                "Precisão das implementações (código executável, erro <1e-3): 25%",
                                "Quantificação correta de métricas e reduções: 25%",
                                "Análise qualitativa profunda (explicação de escalas): 20%",
                                "Qualidade de visualizações e tabela: 15%",
                                "Relatório claro e conciso: 10%",
                                "Testes de sensibilidade incluídos: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Modelagem de decaimento populacional ou reações químicas stiff.",
                                "Estatística: Análise de erro e confiança em simulações.",
                                "Computação Científica: Otimização de solvers em HPC."
                              ],
                              "realWorldApplication": "Em simulações CFD ou farmacocinética, solvers adaptativos reduzem tempo de computação em 50-80% para meshes não-uniformes, permitindo simulações em tempo real em engenharia aeroespacial e design de medicamentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Estimativa de Erro Local",
                    "description": "Técnicas para calcular o erro aproximado em um passo único, como em métodos Runge-Kutta embeddeds.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Definição de Erro Local",
                        "description": "Conceito fundamental do erro local como a diferença entre a solução exata e a aproximada após um único passo de integração numérica em métodos para equações diferenciais ordinárias (EDOs).",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar o erro local truncado",
                            "description": "Diferenciar o erro local truncado do erro global, explicando como ele surge da expansão em série de Taylor da solução exata em um passo h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Expansão em Série de Taylor para Funções Diferenciáveis",
                                  "subSteps": [
                                    "Lembre a definição de função suave e derivadas sucessivas.",
                                    "Escreva a expansão de Taylor de ordem n para f(x) ao redor de x0: f(x) = sum_{k=0}^n f^{(k)}(x0)/k! (x-x0)^k + R_{n+1}.",
                                    "Explique o resto de Lagrange: R_{n+1} = f^{(n+1)}(ξ)/(n+1)! (x-x0)^{n+1} para ξ entre x0 e x.",
                                    "Discuta convergência para funções analíticas.",
                                    "Pratique com exemplo simples: exp(x) ao redor de 0."
                                  ],
                                  "verification": "Construa corretamente a expansão de Taylor de ordem 3 para sin(x) em x=0 e identifique o resto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Caderno, calculadora, tabela de derivadas de funções básicas.",
                                  "tips": "Sempre normalize os termos fatorando (x-x0)^k para visualizar ordens.",
                                  "learningObjective": "Compreender a base teórica da aproximação local via Taylor.",
                                  "commonMistakes": "Confundir ordem da expansão com o expoente no resto; esquecer fatoriais nos denominadores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Expansão de Taylor à Solução Exata de uma EDO",
                                  "subSteps": [
                                    "Considere uma EDO y' = f(t,y), y(t0)=y0.",
                                    "Expanda y(t0 + h) em Taylor ao redor de t0: y(t0+h) = y(t0) + h y'(t0) + (h^2)/2 y''(t0) + ... + resto.",
                                    "Expresse derivadas superiores usando a EDO: y'' = df/dt + df/dy * y' = ∂f/∂t + ∂f/∂y * f, e assim por diante.",
                                    "Identifique os termos até a ordem desejada para um método de ordem p.",
                                    "Calcule para EDO linear simples como y' = λy."
                                  ],
                                  "verification": "Derive a expansão de Taylor de y(t0+h) até ordem 2 para y' = -y, y(0)=1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha com EDO exemplo, software simbólico como SymPy (opcional).",
                                  "tips": "Use notação de jato (jet) para derivadas sucessivas para evitar cálculos manuais longos.",
                                  "learningObjective": "Saber expandir soluções exatas de EDOs localmente.",
                                  "commonMistakes": "Não substituir corretamente derivadas via chain rule na EDO; ignorar dependência em t."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar com Aproximação Numérica e Identificar Erro Local Truncado",
                                  "subSteps": [
                                    "Escolha um método numérico, ex: Euler forward: y1 = y0 + h f(t0,y0).",
                                    "Compare com Taylor exata: diferença é [h^2/2 y''(ξ)] para algum ξ.",
                                    "Generalize: para método de ordem p, erro local truncado τ(h) = O(h^{p+1}).",
                                    "Escreva expressão exata: τ(h) = y(t0+h) - y_num(t0+h).",
                                    "Estime magnitude usando resto de Taylor."
                                  ],
                                  "verification": "Para Euler em y'=y, mostre que erro local é (h^2/2) e^{ξ} para ξ em [0,h].",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos de métodos numéricos anotados, papel quadriculado.",
                                  "tips": "Lembre que erro local é por passo, assumindo y0 exato.",
                                  "learningObjective": "Identificar precisamente o erro local truncado como resto da Taylor.",
                                  "commonMistakes": "Confundir com erro de arredondamento; assumir h pequeno sem justificar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Erro Local Truncado do Erro Global",
                                  "subSteps": [
                                    "Defina erro global: e_n = |y(t_n) - y_num(t_n)| após n passos para tf = n h.",
                                    "Explique acumulação: erro global ≈ (erro local / h) * tf para ordem 1.",
                                    "Mostre que para método ordem p, erro global O(h^p).",
                                    "Ilustre com gráfico: erro local constante por passo, global cresce linearmente.",
                                    "Discuta controle de passo: refinar h reduz ambos, mas local guia adaptativo."
                                  ],
                                  "verification": "Explique por que erro global em Euler é O(h), enquanto local O(h^2).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráficos de erro de livros-texto ou simulados em Python/MATLAB.",
                                  "tips": "Pense em erro local como 'erro por passo', global como 'soma propagada'.",
                                  "learningObjective": "Distinguir conceitualmente e quantitativamente os dois erros.",
                                  "commonMistakes": "Achar que local é sempre maior; ignorar propagação de estabilidade."
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1, h=0.1, Euler: y1 ≈ 1 + 0.1*1 = 1.1. Exata: y(0.1)=e^{0.1}≈1.10517. Erro local truncado: ≈0.00517, próximo a (0.1)^2 /2 * e^ξ ≈0.005.",
                              "finalVerifications": [
                                "Deriva corretamente o resto de Taylor para solução de EDO em um passo h.",
                                "Identifica o erro local truncado como O(h^{p+1}) para método ordem p.",
                                "Diferencia erro local (por passo) de global (acumulado).",
                                "Calcula numericamente erro local em exemplo simples e compara com teoria.",
                                "Explica origem do erro na truncação da série de Taylor.",
                                "Propõe refinamento de h para reduzir erro local."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da expansão de Taylor (sem erros algébricos).",
                                "Correta identificação do termo de erro local truncado.",
                                "Clareza na distinção conceitual entre erros local e global.",
                                "Uso apropriado de notação O(h^k) com justificativa.",
                                "Exemplo prático resolvido com cálculo numérico exato.",
                                "Compreensão de implicações para controle de passo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de trajetórias em simulações dinâmicas (ex: movimento orbital).",
                                "Computação: Implementação de solvers numéricos em Python (SciPy ODEINT).",
                                "Engenharia: Análise de estabilidade em controle de sistemas.",
                                "Estatística: Propagação de erros em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou previsão de epidemias (modelos SIR), identificar erro local truncado permite adaptadores de passo para precisão eficiente sem passos excessivos, otimizando tempo computacional em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Calcular ordem de precisão do erro local",
                            "description": "Determinar a ordem p do erro local em métodos explícitos, usando a fórmula |e(h)| ≈ C h^{p+1}, e relacionar com condições de consistência dos métodos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de erro local e a fórmula de ordem de precisão",
                                  "subSteps": [
                                    "Revise a definição de erro local em métodos numéricos explícitos para EDOs: e(h) = y(t + h) - y_n, onde y_n é a aproximação após um passo.",
                                    "Estude a fórmula |e(h)| ≈ C h^{p+1}, onde p é a ordem de precisão e C é uma constante.",
                                    "Identifique que p relaciona-se à ordem de truncamento do método (ex: Euler tem p=1).",
                                    "Discuta consistência: método consistente se p ≥ 1."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula e dê um exemplo simples para Euler.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Análise Numérica, notas de aula, calculadora.",
                                  "tips": "Desenhe um diagrama do passo de h para visualizar o erro local.",
                                  "learningObjective": "Dominar a interpretação teórica da ordem de precisão do erro local.",
                                  "commonMistakes": "Confundir erro local com erro global; ignorar o expoente p+1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar dados numéricos para estimativa da ordem p",
                                  "subSteps": [
                                    "Escolha uma EDO simples, como y' = -y, y(0)=1 (solução exata y=e^{-t}).",
                                    "Implemente o método numérico (ex: Euler) para passos h, h/2, h/4.",
                                    "Calcule aproximações y_n(h), y_n(h/2), etc., e erros locais |e(h)| = |y(t+h) - y_n|.",
                                    "Registre valores de |e(h)| para diferentes h em uma tabela.",
                                    "Use software para precisão (Python/MATLAB)."
                                  ],
                                  "verification": "Tabela completa com h, y_n, y_exata e |e(h)| para pelo menos 3 valores de h.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python ou MATLAB com bibliotecas numpy/scipy, papel para tabela.",
                                  "tips": "Comece com h pequeno para evitar erros de arredondamento dominantes.",
                                  "learningObjective": "Coletar dados empíricos precisos para análise de convergência.",
                                  "commonMistakes": "Usar passos h muito grandes, levando a erros não proporcionais a h^{p+1}."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular numericamente a ordem p usando log-log",
                                  "subSteps": [
                                    "Aplique log na fórmula: log|e(h)| ≈ log C + (p+1) log h.",
                                    "Plote log|e(h)| vs log h; inclinação da reta é p+1.",
                                    "Calcule p ≈ (log|e(h/2)| - log|e(h)|) / (log(h/2) - log h) - 1.",
                                    "Repita para pares consecutivos h/2^k e verifique consistência do valor de p.",
                                    "Estime C como |e(h)| / h^{p+1}."
                                  ],
                                  "verification": "Gráfico log-log com reta ajustada e valor computado de p próximo ao teórico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel ou Python (matplotlib para plot), dados da tabela anterior.",
                                  "tips": "Use regressão linear para melhor precisão em múltiplos pontos.",
                                  "learningObjective": "Aplicar análise logarítmica para estimar ordem de precisão empiricamente.",
                                  "commonMistakes": "Esquecer de subtrair 1 para obter p; plotar sem logaritmo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar ordem p com condições de consistência e validar",
                                  "subSteps": [
                                    "Verifique se p ≥ 1 implica consistência local (lim_{h→0} |e(h)|/h = 0).",
                                    "Compare p computado com ordem teórica do método (ex: p=1 para Euler).",
                                    "Teste sensibilidade variando EDO ou método (ex: Runge-Kutta ordem 4).",
                                    "Documente conclusões sobre precisão e estabilidade.",
                                    "Discuta limitações: erro de arredondamento para h muito pequeno."
                                  ],
                                  "verification": "Relatório curto confirmando relação p-consistência com evidências numéricas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Resultados anteriores, software para testes adicionais.",
                                  "tips": "Sempre valide com solução exata conhecida para EDOs teste.",
                                  "learningObjective": "Conectar teoria de ordem com propriedades de consistência dos métodos.",
                                  "commonMistakes": "Ignorar que consistência requer p≥0, mas precisão alta precisa p≥1."
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, método de Euler com h=0.1, 0.05, 0.025 em t=0.1: |e(0.1)|≈0.00498, |e(0.05)|≈0.00124, |e(0.025)|≈0.00031. Então p ≈ (log(0.00124/0.00498)/log(0.5)) -1 ≈1, confirmando ordem 1.",
                              "finalVerifications": [
                                "Cálculo de p coincide com ordem teórica do método (±0.1 de tolerância).",
                                "Gráfico log-log mostra reta com inclinação p+1.",
                                "Estimativa de C é consistente entre diferentes h.",
                                "Verificação de consistência: |e(h)|/h → 0 quando h→0.",
                                "Teste com outro h ou EDO reproduz p similar.",
                                "Relatório explica limitações observadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo de p (erro <5%).",
                                "Correta aplicação da fórmula logarítmica e interpretação.",
                                "Qualidade da tabela de dados e gráfico (clareza, precisão).",
                                "Conexão explícita entre p e consistência.",
                                "Identificação de erros comuns e limitações.",
                                "Documentação completa e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/MATLAB para simulações.",
                                "Física: Modelagem de decaimento exponencial em cinemática.",
                                "Estatística: Regressão linear para ajuste de log-log.",
                                "Engenharia: Análise de erro em simulações CFD ou controle.",
                                "Computação Científica: Otimização de passos em solvers de EDOs."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica ou dinâmica de fluidos, calcular a ordem de erro local garante precisão em solvers numéricos, permitindo adaptação de passos h para equilíbrio entre precisão e custo computacional em supercomputadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Exemplificar com método de Euler",
                            "description": "Derivar analiticamente o erro local do método de Euler para uma EDO y' = f(t,y), mostrando que é O(h^2).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Expandir a solução exata y(t_n + h) usando série de Taylor",
                                  "subSteps": [
                                    "Lembre a equação diferencial ordinária (EDO): y' = f(t, y), com y(t_0) conhecido.",
                                    "Considere o ponto t_{n+1} = t_n + h, onde h é o passo de integração.",
                                    "Aplique a expansão de Taylor para y(t_{n+1}) em torno de t_n: y(t_n + h) = y(t_n) + h y'(t_n) + (h^2 / 2) y''(ξ) para algum ξ ∈ (t_n, t_{n+1}).",
                                    "Substitua y'(t_n) = f(t_n, y(t_n)).",
                                    "Mantenha o resto do remanescente como O(h^2), destacando que y''(ξ) é limitado assumindo f suave."
                                  ],
                                  "verification": "Escreva a expansão de Taylor completa com o termo de erro explícito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica ou notas de aula"
                                  ],
                                  "tips": "Assuma que y é suficientemente diferenciável (duas vezes) para justificar a expansão.",
                                  "learningObjective": "Compreender como a série de Taylor modela a solução exata localmente.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/2 no termo h^2",
                                    "Confundir y(t_n) com a aproximação numérica y_n"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a expressão para a segunda derivada y'' em termos de f",
                                  "subSteps": [
                                    "Diferencie y' = f(t, y) em relação a t: y'' = ∂f/∂t + ∂f/∂y * y' = f_t + f_y f.",
                                    "Avalie em (t_n, y(t_n)): y''(t_n) = f_t(t_n, y(t_n)) + f_y(t_n, y(t_n)) f(t_n, y(t_n)).",
                                    "Note que no remanescente da Taylor, y''(ξ) segue a mesma forma, mas em ξ.",
                                    "Verifique com um exemplo simples, como y' = y (f(t,y)=y), onde y'' = y.",
                                    "Confirme que y'' é contínua se f e suas parciais forem contínuas."
                                  ],
                                  "verification": "Escreva y''(t_n) explicitamente em termos de f, f_t e f_y.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora simbólica opcional (ex: SymPy)"
                                  ],
                                  "tips": "Use a regra da cadeia cuidadosamente para ∂f/∂t.",
                                  "learningObjective": "Expressar derivadas superiores da solução em termos da função f.",
                                  "commonMistakes": [
                                    "Esquecer de multiplicar f_y por y' = f",
                                    "Tratar f como função apenas de y"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Apresentar a iteração do método de Euler",
                                  "subSteps": [
                                    "Defina a aproximação numérica: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Note que y_n aproxima y(t_n), mas para erro local, assuma y_n = y(t_n) (erro de propagação zero no início).",
                                    "Compare com o primeiro termo da Taylor: y(t_n) + h y'(t_n) = y(t_n) + h f(t_n, y(t_n)).",
                                    "Identifique que Euler ignora termos de ordem h^2 e superiores.",
                                    "Escreva y_{n+1} = y(t_n + h) - (h^2 / 2) y''(ξ) + o(h^2)."
                                  ],
                                  "verification": "Mostre que y_{n+1} coincide com os dois primeiros termos da expansão de Taylor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta"
                                  ],
                                  "tips": "Assuma inicial y_0 = y(t_0) exata para focar no erro local de um passo.",
                                  "learningObjective": "Reconhecer a truncagem do método de Euler na expansão de Taylor.",
                                  "commonMistakes": [
                                    "Usar y_n em vez de y(t_n) prematuramente",
                                    "Ignorar o pressuposto de y_n exato"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e analisar o erro local",
                                  "subSteps": [
                                    "Defina erro local: e_{n+1} = y(t_{n+1}) - y_{n+1}.",
                                    "Substitua: e_{n+1} = [y(t_n) + h f(t_n, y(t_n)) + (h^2 / 2) y''(ξ)] - [y_n + h f(t_n, y_n)].",
                                    "Com y_n = y(t_n), simplifica para e_{n+1} = (h^2 / 2) y''(ξ).",
                                    "Conclua que |e_{n+1}| ≤ (h^2 / 2) max |y''| , que é O(h^2) à medida que h → 0.",
                                    "Discuta Lipschitz e suavidade para garantir a ordem."
                                  ],
                                  "verification": "Derive explicitamente e_{n+1} = O(h^2) com notação big-O.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo numérico opcional para ilustração"
                                  ],
                                  "tips": "Use |e| ≤ K h^2 para quantificar, com K = (1/2) sup |y''|.",
                                  "learningObjective": "Derivar analiticamente a ordem de truncagem do erro local.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Esquecer o 1/2 ou sinal no erro"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1 (solução y=e^t), em t_n=0, h=0.1: Expansão Taylor y(0.1) ≈ 1 + 0.1*1 + (0.1)^2/2 *1 = 1.105, Euler: y1=1+0.1*1=1.1, erro local ≈0.005 = O(0.01). y''=y confirma O(h^2).",
                              "finalVerifications": [
                                "Pode escrever a expansão de Taylor de y(t_n + h) com remanescente O(h^2)?",
                                "Consegue derivar y'' = f_t + f_y f corretamente?",
                                "Identifica que Euler matches os termos até O(h)?",
                                "Calcula e_{n+1} = (h^2/2) y''(ξ) assumindo y_n exato?",
                                "Explica por que isso implica ordem O(h^2) para erro local?",
                                "Aplica a um exemplo concreto como y'=y?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da Taylor (pontos completos se remanescente correto).",
                                "Correção na expressão de y'' via diferenciação total.",
                                "Clareza na comparação Euler vs. Taylor.",
                                "Derivação rigorosa do erro local com big-O.",
                                "Uso correto de suposições (suavidade de f).",
                                "Exemplo prático ilustrativo e numérico."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Euler em Python para verificar erro numericamente.",
                                "Física: Simulações de movimento (ex: queda livre com atrito).",
                                "Engenharia: Modelagem de circuitos RC via EDOs.",
                                "Estatística: Métodos numéricos em processos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias de foguetes (NASA), previsão de epidemias (modelos SIR) ou precificação de opções financeiras (equação de Black-Scholes), onde o método de Euler é usado para protótipos rápidos, e entender O(h^2) guia escolha de h para precisão aceitável sem custo computacional excessivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Métodos Runge-Kutta Embedded",
                        "description": "Família de métodos Runge-Kutta que computam duas aproximações de ordens diferentes no mesmo passo, permitindo estimativa de erro sem custo adicional significativo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Entender estrutura de métodos embedded",
                            "description": "Descrever a tabela de Butcher para pares RK(p)(p+1), como o par (4,5) de Dormand-Prince, destacando coeficientes compartilhados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Métodos Runge-Kutta e Introduzir Conceito Embedded",
                                  "subSteps": [
                                    "Estude a fórmula geral de um método Runge-Kutta de ordem p: y_{n+1} = y_n + h ∑ b_i k_i.",
                                    "Identifique os estágios intermediários k_i = f(t_n + c_i h, y_n + h ∑ a_{ij} k_j).",
                                    "Aprenda que métodos embedded calculam duas aproximações de ordens diferentes (p e p+1) simultaneamente para estimar erro local.",
                                    "Discuta o propósito: controle adaptativo de passo via |y_{p+1} - y_p| ≈ erro.",
                                    "Compare com métodos fixos: eficiência computacional por compartilhamento de k_i."
                                  ],
                                  "verification": "Resuma em um parágrafo os benefícios dos métodos embedded sobre os explícitos fixos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notas de aula sobre RK, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Desenhe fluxogramas para visualizar os estágios compartilhados.",
                                  "learningObjective": "Compreender a motivação e estrutura básica de métodos RK embedded.",
                                  "commonMistakes": "Confundir ordem de consistência com ordem de precisão; ignorar o papel do erro local no adaptativo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Tabela de Butcher para Pares RK(p)(p+1)",
                                  "subSteps": [
                                    "Analise a estrutura da tabela de Butcher: matriz A (a_{ij}), vetores c e pares b^{(p)}, b^{(p+1)}.",
                                    "Note que para embedded, usa-se uma única matriz A e c, mas dois vetores de pesos b.",
                                    "Estude condições de ordem: ∑ b^{(p)}_i = 1, ∑ b^{(p+1)}_i = 1, e condições de Butcher para ordem p e p+1.",
                                    "Identifique que coeficientes são escolhidos para minimizar erro e custo computacional.",
                                    "Pratique lendo tabelas: interprete entradas como frações exatas."
                                  ],
                                  "verification": "Desenhe uma tabela de Butcher genérica para RK(4)(5) e rotule todos os componentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabelas de Butcher de referência (Dormand-Prince), papel quadriculado, software LaTeX para tabelas.",
                                  "tips": "Use cores diferentes para b^{(4)} e b^{(5)} para visualizar diferenças.",
                                  "learningObjective": "Dominar a representação matricial e condições de ordem em tabelas de Butcher.",
                                  "commonMistakes": "Esquecer que c_i são nós de abscissa; confundir A com pesos b."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Par Específico (4,5) de Dormand-Prince",
                                  "subSteps": [
                                    "Memorize ou copie a tabela de Butcher DOPRI5: c = [0, 1/5, 3/10, 4/5, 8/9, 1, 1], A com 7 estágios.",
                                    "Calcule manualmente os k_i para uma EDO simples como y' = -y, y(0)=1.",
                                    "Compute y_4 e y_5 usando os pesos b^{(4)} e b^{(5)} para h fixo.",
                                    "Verifique a ordem: erro deve ser O(h^5) para y_5 e O(h^4) para y_4.",
                                    "Implemente em pseudocódigo o algoritmo de um passo."
                                  ],
                                  "verification": "Reproduza a tabela DOPRI5 de memória ou derive um k_i específico.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código fonte DOPRI5 (MATLAB/Python), EDO teste y'=λy, planilha Excel para cálculos.",
                                  "tips": "Comece com h pequeno para validar numericamente a ordem.",
                                  "learningObjective": "Aplicar a tabela DOPRI5 em um exemplo concreto.",
                                  "commonMistakes": "Erros de transcrição nos coeficientes fracionários; não normalizar pesos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Coeficientes Compartilhados e Benefícios",
                                  "subSteps": [
                                    "Identifique compartilhamento: mesma A, c para ambos métodos, apenas b difere.",
                                    "Compare custo: 7 avaliações f() para ordens 4 e 5 vs. métodos separados (s~10).",
                                    "Discuta otimização: Dormand-Prince minimiza coeficiente de erro principal.",
                                    "Analise impacto no controle de passo: erro_local = |y_5 - y_4| / (tol * estimativa).",
                                    "Explore variantes FSAL (First Same As Last) para eficiência em passos adaptativos."
                                  ],
                                  "verification": "Explique em 3 frases por que os coeficientes compartilhados economizam computação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigo original Dormand-Prince (1980), simulador ODE online (ex: DESOLVE).",
                                  "tips": "Compare flops: conte operações para embedded vs. não-embedded.",
                                  "learningObjective": "Explicar eficiência e design dos coeficientes compartilhados.",
                                  "commonMistakes": "Superestimar custo ignorando FSAL; confundir erro local com global."
                                }
                              ],
                              "practicalExample": "Implemente o método DOPRI5 em Python para resolver y' = y(1 - y), y(0)=0.5 (modelo logístico), com h inicial 0.1, tol=1e-6. Observe adaptação de h e compare solução com exata.",
                              "finalVerifications": [
                                "Desenhar corretamente a tabela de Butcher DOPRI5 com todos coeficientes.",
                                "Calcular manualmente um passo para EDO linear simples.",
                                "Explicar como o erro local é estimado e usado no controle de passo.",
                                "Identificar 3 coeficientes compartilhados e seu impacto na eficiência.",
                                "Simular numericamente e validar ordem de convergência.",
                                "Discutir limitações (ex: stiff problems)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na reprodução da tabela de Butcher (90% dos coeficientes corretos).",
                                "Compreensão conceitual: explicar embedded vs. fixo em termos de custo/precisão.",
                                "Habilidade prática: código ou cálculo manual sem erros aritméticos.",
                                "Análise qualitativa: identificar benefícios dos compartilhados corretamente.",
                                "Aplicação: resolver EDO com adaptativo e interpretar resultados.",
                                "Profundidade: mencionar condições de ordem e FSAL."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em NumPy/SciPy para solvers ODE.",
                                "Física: Simulações dinâmicas (ex: osciladores em mecânica).",
                                "Engenharia: Controle de sistemas (ex: MATLAB Simulink).",
                                "Estatística: Modelagem estocástica com SDEs aproximadas."
                              ],
                              "realWorldApplication": "Usado em solvers como ODE45 (MATLAB), LSODA (R), para simulações precisas em previsão meteorológica, farmacocinética e trajetórias espaciais, onde passos adaptativos evitam erros acumulados e otimizam tempo de CPU."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Implementar um par embedded simples",
                            "description": "Codificar em pseudocódigo ou linguagem de programação um método RK(4,5) embedded, computando y_{n+1}^low e y_{n+1}^high.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de métodos Runge-Kutta embedded RK(4,5)",
                                  "subSteps": [
                                    "Estude a tabela Butcher para um par RK(4,5) padrão, como o esquema de Dormand-Prince (DOPRI5).",
                                    "Identifique os 7 estágios k1 a k7 e os coeficientes a_ij, b_i^low (ordem 4) e b_i^high (ordem 5).",
                                    "Entenda como y_{n+1}^low = y_n + h * sum(b_i^low * k_i) e y_{n+1}^high = y_n + h * sum(b_i^high * k_i).",
                                    "Revise a estimativa de erro local: err = |y_high - y_low| / (1 - tol), onde tol é tolerância.",
                                    "Anote as fórmulas principais em pseudocódigo inicial."
                                  ],
                                  "verification": "Pode recitar os coeficientes principais e explicar a diferença entre low e high.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de papel, tabela Butcher DOPRI5 impressa ou online, calculadora.",
                                  "tips": "Use uma tabela Butcher verificada de fontes confiáveis como Wikipedia ou livros de análise numérica.",
                                  "learningObjective": "Compreender a estrutura matemática de um par embedded RK(4,5).",
                                  "commonMistakes": "Confundir coeficientes de low e high; ignorar o fator de escala na estimativa de erro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir coeficientes e preparar pseudocódigo base",
                                  "subSteps": [
                                    "Liste os coeficientes exatos: c = [0, 0.25, 0.375, 0.5, 0.75]; b_low e b_high para cada estágio.",
                                    "Escreva a função assinatura: funcao RK45_embedded(y_n, t_n, h, f).",
                                    "Inicialize arrays para k[1..7] e defina os valores fixos de a_ij em matrizes.",
                                    "Implemente o loop para calcular k_i = f(t_n + c_i*h, y_n + h*sum(a_ij*k_j)).",
                                    "Teste manualmente o primeiro estágio k1 = f(t_n, y_n)."
                                  ],
                                  "verification": "Pseudocódigo compila conceitualmente e k1 é calculado corretamente à mão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto (VS Code ou similar), referência Butcher DOPRI5.",
                                  "tips": "Copie coeficientes com precisão; use notação matricial para clareza.",
                                  "learningObjective": "Preparar a estrutura algorítmica com coeficientes corretos.",
                                  "commonMistakes": "Erros de transcrição nos coeficientes a_ij; esquecer dependências sequenciais nos k_i."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculo dos estágios e aproximações finais",
                                  "subSteps": [
                                    "Codifique o cálculo sequencial de k2 a k7 usando os somatórios parciais.",
                                    "Calcule y_low = y_n + h * (b1_low*k1 + ... + b7_low*k7).",
                                    "Calcule y_high = y_n + h * (b1_high*k1 + ... + b7_high*k7).",
                                    "Adicione estimativa de erro: err = |y_high - y_low|. Para escalar: err = max(|err_i| / tol).",
                                    "Inclua retorno: {y_low, y_high, err}."
                                  ],
                                  "verification": "Execute com exemplo simples e verifique se y_low e y_high diferem ligeiramente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Linguagem de programação (Python/MATLAB), debugger.",
                                  "tips": "Use vetores para sistemas de EDOs; teste com dimensão 1 primeiro.",
                                  "learningObjective": "Codificar os computations principais do método.",
                                  "commonMistakes": "Índices off-by-one em arrays; multiplicar h incorretamente nos somatórios."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar a implementação",
                                  "subSteps": [
                                    "Escolha EDO teste: y' = -y, y(0)=1, t=0 to 0.2, h=0.2, solução exata e^{-t}.",
                                    "Execute um passo e compare y_high com solução exata.",
                                    "Verifique se err ≈ |y_high - y_low| é pequeno.",
                                    "Teste com sistema 2D simples e ajuste tol.",
                                    "Documente o código com comentários."
                                  ],
                                  "verification": "Código produz y_low ≈ 0.8187, y_high ≈ 0.8195, err < 1e-3 para exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ambiente de execução (Jupyter Notebook), solução exata plotada.",
                                  "tips": "Use print statements para inspecionar k_i intermediários.",
                                  "learningObjective": "Validar funcionalidade através de testes.",
                                  "commonMistakes": "Não normalizar erro para sistemas multi-dimensionais; ignorar tolerância."
                                }
                              ],
                              "practicalExample": "Implemente RK(4,5) para resolver y' = y*(1-y), y(0)=0.5 (modelo logístico), h=0.1, um passo: compute k1..k7, y_low ≈ 0.525, y_high ≈ 0.5253, err ≈ 1.2e-6.",
                              "finalVerifications": [
                                "Código executa sem erros para EDO escalar e vetorial.",
                                "y_low e y_high são computados corretamente com coeficientes DOPRI5.",
                                "Estimativa de erro local coincide com |y_high - y_low| escalada.",
                                "Teste com h=0.1 em y'=-y produz err < 1e-4.",
                                "Pseudocódigo é legível e comentado.",
                                "Função retorna y_low, y_high e err explicitamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes Butcher (100% match).",
                                "Correta implementação sequencial dos estágios k_i.",
                                "Cálculo exato de y_low/y_high e erro.",
                                "Clareza e modularidade do código/pseudocódigo.",
                                "Validação com exemplo numérico (erro < 1e-3).",
                                "Tratamento de sistemas de EDOs (vetores)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos numéricos e estruturas de dados (arrays/matrizes).",
                                "Física: Simulações de movimento (EDOs em mecânica).",
                                "Engenharia: Controle de sistemas dinâmicos com adaptação de passo.",
                                "Ciência de Dados: Integração numérica em machine learning (redes neurais recorrentes)."
                              ],
                              "realWorldApplication": "Usado em solvers ODE como ode45 no MATLAB para simular trajetórias de satélites, previsão de epidemias (SIR models) e simulações climáticas, onde controle de erro garante precisão adaptativa sem passos excessivos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Analisar eficiência computacional",
                            "description": "Comparar o custo de função f por passo em métodos embedded versus métodos separados, enfatizando economia de avaliações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Métodos Runge-Kutta Separados e Embedded",
                                  "subSteps": [
                                    "Estudar a estrutura geral de métodos Runge-Kutta (RK) de ordem fixa, incluindo o tableau de Butcher.",
                                    "Explicar como métodos RK separados executam independentemente um método de ordem p e outro de ordem q para estimar erro local.",
                                    "Introduzir métodos RK embedded, como RK5(4), que usam um único conjunto de estágios para gerar aproximações de duas ordens diferentes.",
                                    "Identificar que o custo computacional é dominado pelo número de avaliações da função f por passo.",
                                    "Comparar visualmente tableaux de Butcher para métodos separados vs. embedded."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras diferenciando os dois tipos de métodos, incluindo exemplos de ordens.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires, capítulo de métodos RK)",
                                    "Notas de aula sobre Métodos Runge-Kutta Embedded",
                                    "Software como MATLAB ou Python (SymPy para tableaux)"
                                  ],
                                  "tips": [
                                    "Desenhe os tableaux de Butcher à mão para fixar a estrutura.",
                                    "Foquem no compartilhamento de k_i (avaliações de f)."
                                  ],
                                  "learningObjective": "Diferenciar métodos RK separados de embedded em termos de estrutura algorítmica e custo de avaliações de f.",
                                  "commonMistakes": [
                                    "Confundir número de estágios com ordem de precisão.",
                                    "Ignorar que métodos embedded reutilizam as mesmas avaliações de f."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Custo Computacional de Métodos RK Separados",
                                  "subSteps": [
                                    "Para um método RK de ordem p com s estágios, registrar s avaliações de f.",
                                    "Para estimativa de erro com método de ordem q com t estágios, adicionar t avaliações independentes.",
                                    "Calcular custo total por passo: s + t avaliações de f.",
                                    "Exemplo prático: RK4 (s=4) + RK3 (t=3) resulta em 7 avaliações.",
                                    "Generalizar para qualquer par de métodos separados."
                                  ],
                                  "verification": "Calcular e documentar o custo para dois pares de métodos separados específicos (ex: RK4+RK2 e RK5+RK4).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabelas de métodos RK padrão (ex: Heun, Ralston)",
                                    "Planilha ou caderno para cálculos",
                                    "Referência online de coeficientes Butcher"
                                  ],
                                  "tips": [
                                    "Conte apenas avaliações de f; ignore custos menores como adições.",
                                    "Use uma tabela para organizar s e t por método."
                                  ],
                                  "learningObjective": "Quantificar precisamente o custo de avaliações de f em métodos RK separados para estimativa de erro.",
                                  "commonMistakes": [
                                    "Subestimar avaliações por esquecer estágios extras.",
                                    "Não considerar que métodos separados não compartilham computações."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Custo Computacional de Métodos RK Embedded",
                                  "subSteps": [
                                    "Analisar o tableau de Butcher de métodos embedded, com s estágios gerando y_p e y_q simultaneamente.",
                                    "Verificar que apenas s avaliações de f são necessárias para ambas as aproximações.",
                                    "Exemplo: Dormand-Prince RK5(4) com s=7 avaliações para ordens 5 e 4.",
                                    "Comparar com equivalentes separados (ex: RK5 + RK4 ≈ 11-12 evals vs. 7).",
                                    "Listar métodos comuns embedded e seus custos (RK2(1), RK4(3), etc.)."
                                  ],
                                  "verification": "Listar custos de 3 métodos embedded populares e confirmar com fórmula geral.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabelas de métodos embedded RK (ex: DOPRI5)",
                                    "Python/MATLAB para visualizar tableaux",
                                    "Artigo de Hairer sobre métodos RK"
                                  ],
                                  "tips": [
                                    "Memorize: custo embedded = número de linhas no tableau (s).",
                                    "Verifique implementações em bibliotecas como SciPy odeint."
                                  ],
                                  "learningObjective": "Determinar o custo reduzido de avaliações em métodos RK embedded devido ao compartilhamento de estágios.",
                                  "commonMistakes": [
                                    "Contar avaliações duplicadas em embedded.",
                                    "Confundir ordem principal com ordem secundária."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Eficiências e Analisar Economia de Avaliações",
                                  "subSteps": [
                                    "Criar tabela comparativa: custo separado vs. embedded para pares equivalentes de ordens.",
                                    "Calcular economia relativa: ((custo_sep - custo_emb) / custo_sep) * 100%.",
                                    "Discutir cenários onde f é computacionalmente cara (ex: stiff ODEs, PDEs).",
                                    "Analisar trade-offs: custo vs. precisão e adaptatividade.",
                                    "Concluir com justificativa para preferir embedded em solvers adaptativos."
                                  ],
                                  "verification": "Produzir tabela comparativa com pelo menos 3 exemplos e análise de economia >30%.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabelas",
                                    "Exemplos numéricos de ODEs simples",
                                    "Gráficos de custo vs. passos"
                                  ],
                                  "tips": [
                                    "Use exemplos reais: economia de 30-50% típica.",
                                    "Enfatize impacto em tempo total de simulação."
                                  ],
                                  "learningObjective": "Avaliar quantitativa e qualitativamente a superioridade de métodos embedded em eficiência computacional.",
                                  "commonMistakes": [
                                    "Ignorar custo acumulado sobre múltiplos passos.",
                                    "Superestimar economia sem exemplos numéricos."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y + sin(t), y(0)=1, no intervalo [0,1]. Use métodos separados RK4+RK3 (7 evals/passo) vs. embedded RK4(3) (4 evals/passo). Simule com 100 passos adaptativos e compare total de avaliações de f: ~700 vs. ~400, demonstrando ~43% economia.",
                              "finalVerifications": [
                                "Calcula corretamente custos de avaliações para métodos separados e embedded.",
                                "Identifica economia percentual em exemplos numéricos.",
                                "Explica o papel do compartilhamento de estágios na eficiência.",
                                "Aplica análise a um problema ODE real.",
                                "Discute limitações em problemas stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de custo e economia (20 pontos).",
                                "Clareza e completude da tabela comparativa (20 pontos).",
                                "Uso correto de terminologia RK (15 pontos).",
                                "Análise qualitativa profunda de implicações (25 pontos).",
                                "Exemplo prático implementado e verificado (20 pontos)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar solvers RK em Python (SciPy, NumPy).",
                                "Física: Aplicar em modelagem de osciladores ou circuitos RLC.",
                                "Otimização: Minimizar custo em algoritmos adaptativos.",
                                "Engenharia Computacional: Eficiência em simulações CFD/FEM."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais ou climáticas, onde cada avaliação de f resolve um sistema linear grande (ex: Navier-Stokes), métodos embedded reduzem avaliações em 40%, cortando tempo de simulação de semanas para dias em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Cálculo e Uso da Estimativa de Erro",
                        "description": "Técnicas para estimar o erro local como |y_high - y_low| / (2^p - 1), e sua aplicação no controle adaptativo de passo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Estimar erro local via diferença embedded",
                            "description": "Calcular a estimativa de erro local usando err = |y_{p+1} - y_p| / (2^p - 1), onde p é a ordem baixa, e normalizar pelo vetor solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais da estimativa de erro embedded",
                                  "subSteps": [
                                    "Defina erro local em métodos de Runge-Kutta embedded: diferença entre soluções de ordens p (baixa) e p+1 (alta).",
                                    "Explique o papel do denominador (2^p - 1): fator de normalização derivado da análise de erro assintótico.",
                                    "Identifique y_p e y_{p+1} como aproximações computadas simultaneamente no mesmo passo.",
                                    "Revise o contexto de controle de passo adaptativo em solvers ODE."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a origem da fórmula err = |y_{p+1} - y_p| / (2^p - 1).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de métodos RK embedded (ex: Dormand-Prince).",
                                    "Artigo ou livro de Análise Numérica (ex: Burden & Faires)."
                                  ],
                                  "tips": "Lembre-se: métodos embedded economizam computação ao calcular ambas as ordens no mesmo passo.",
                                  "learningObjective": "Entender a base teórica da estimativa de erro local via diferença embedded.",
                                  "commonMistakes": [
                                    "Confundir ordem baixa (p) com alta (p+1).",
                                    "Ignorar que o denominador é específico para métodos RK de ordem p."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar as aproximações y_p e y_{p+1} para um passo dado",
                                  "subSteps": [
                                    "Selecione um problema ODE modelo: ex. y' = -y, y(0)=1, h=0.1, x=0.",
                                    "Implemente ou extraia coeficientes de um método embedded (ex: RK4(5) com Butcher tableau).",
                                    "Calcule y_p usando estágios do método de ordem baixa.",
                                    "Calcule y_{p+1} usando estágios adicionais ou combinados do método de ordem alta."
                                  ],
                                  "verification": "Verifique se |y_{p+1} - y_p| é pequeno comparado à solução exata parcial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/Scipy ou MATLAB.",
                                    "Tabela de coeficientes RK embedded (DOPRI5)."
                                  ],
                                  "tips": "Use soluções exatas conhecidas para validação inicial.",
                                  "learningObjective": "Obter pares de aproximações consistentes para o cálculo de erro.",
                                  "commonMistakes": [
                                    "Erro nos coeficientes Butcher.",
                                    "Não usar o mesmo h para ambas as ordens."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a estimativa de erro local bruta",
                                  "subSteps": [
                                    "Compute a diferença absoluta: diff = |y_{p+1} - y_p|.",
                                    "Determine p (ordem baixa, ex: p=4 para DOPRI5).",
                                    "Calcule o denominador: denom = 2^p - 1.",
                                    "Aplique a fórmula: err = diff / denom."
                                  ],
                                  "verification": "Confirme que err ≈ erro real comparando com solução exata no ponto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis ou script computacional simples.",
                                    "Exemplo numérico pré-calculado."
                                  ],
                                  "tips": "Para vetores, use norma adequada (ex: norma máxima ou L2).",
                                  "learningObjective": "Executar o cálculo central da fórmula de erro embedded.",
                                  "commonMistakes": [
                                    "Usar 2^{p+1} em vez de 2^p -1.",
                                    "Aplicar | | componente-sábia sem norma global."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Normalizar a estimativa pelo vetor solução e interpretar",
                                  "subSteps": [
                                    "Normalize: err_norm = err / |y| (ou norma do vetor solução acumulado).",
                                    "Compare err_norm com tolerância desejada (ex: tol=1e-6).",
                                    "Decida ação de controle de passo: aceitar/rejeitar, ajustar h.",
                                    "Documente o impacto na precisão global."
                                  ],
                                  "verification": "Simule 2-3 passos e verifique convergência à solução exata.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Solver numérico com controle de erro (ex: ode45 MATLAB).",
                                    "Gráficos de erro vs. h."
                                  ],
                                  "tips": "Normalização evita problemas em soluções com magnitudes variadas.",
                                  "learningObjective": "Aplicar e interpretar a estimativa normalizada em contexto adaptativo.",
                                  "commonMistakes": [
                                    "Normalizar por y_p em vez de solução referencial.",
                                    "Ignorar rejeição de passos com err > tol."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e praticar com exemplo completo",
                                  "subSteps": [
                                    "Resolva ODE completa com método embedded manualmente para 5 passos.",
                                    "Registre erros estimados e compare com erros verdadeiros.",
                                    "Ajuste h baseado em err_norm e reexecute.",
                                    "Analise eficiência (aceitações/rejeições)."
                                  ],
                                  "verification": "Erro global < 1e-3 após passos adaptativos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software: Python (scipy.integrate), MATLAB ou Octave.",
                                    "Solução exata para benchmark."
                                  ],
                                  "tips": "Comece com h grande para observar rejeições.",
                                  "learningObjective": "Integrar estimativa em fluxo de solver adaptativo.",
                                  "commonMistakes": [
                                    "Não rejeitar passos com erro alto.",
                                    "Subestimar custo computacional de rejeições."
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1 (sol. exata y=e^{-2x}), h=0.25, x=0 to 0.25, usando RK4(5) embedded: y4 ≈ 0.7788, y5 ≈ 0.7780, p=4, diff=|0.7780-0.7788|=0.0008, denom=15, err=0.0008/15≈5.33e-5. Normalizado por |y5|≈5.33e-5 / 0.7780 ≈ 6.85e-5 (erro real ~6.9e-5).",
                              "finalVerifications": [
                                "Calcula corretamente diff, denom e err para exemplo dado.",
                                "Normaliza adequadamente pelo vetor solução.",
                                "Explica decisão de aceitação/rejeição baseada em tol.",
                                "Compara estimativa com erro verdadeiro em pelo menos 2 casos.",
                                "Implementa em código simples e valida.",
                                "Identifica quando normalização é crítica (sol. oscilante)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da fórmula (erro <1%).",
                                "Compreensão conceitual (derivação qualitativa).",
                                "Aplicação correta em vetores/multidimensão.",
                                "Eficiência em controle adaptativo demonstrada.",
                                "Correção de erros comuns identificados.",
                                "Uso apropriado de normas para normalização."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB para solvers ODE.",
                                "Física: Simulações dinâmicas (ex: movimento orbital).",
                                "Engenharia: Controle adaptativo em sistemas embarcados.",
                                "Estatística: Análise de incerteza em modelos preditivos.",
                                "Computação Científica: Otimização de precisão vs. custo."
                              ],
                              "realWorldApplication": "Usado em solvers como ode45 (MATLAB), DOP853 (SciPy) para simulações precisas em engenharia aeroespacial, modelagem climática e farmacocinética, ajustando automaticamente o passo h para equilibrar precisão e eficiência computacional em problemas stiff ou não-lineares."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Aplicar tolerância de erro no controle de passo",
                            "description": "Implementar lógica de aceitação/rejeição de passo: se err < tol, aceitar e sugerir h_new = h * (tol/err)^{1/(p+1)}; senão, rejeitar e reduzir h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os parâmetros para controle de tolerância de erro",
                                  "subSteps": [
                                    "Definir a tolerância de erro desejada (tol), tipicamente um valor pequeno como 1e-6, baseado no problema.",
                                    "Obter a estimativa de erro local (err) do passo anterior, calculada via método embutido (ex: RK adaptativo).",
                                    "Identificar a ordem de precisão do método (p), como p=4 para RK4.",
                                    "Registrar o tamanho de passo atual (h).",
                                    "Verificar unidades e consistência numérica dos valores."
                                  ],
                                  "verification": "Lista de parâmetros com valores anotados e explicação de cada um está completa e correta.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de código (Python/MATLAB)",
                                    "Documentação do método numérico"
                                  ],
                                  "tips": "Sempre use notação científica para tol e err para evitar erros de escala.",
                                  "learningObjective": "Entender o papel de tol, err, p e h na lógica de controle de passo.",
                                  "commonMistakes": [
                                    "Confundir tol com err",
                                    "Usar p incorreto para o método",
                                    "Ignorar precisão de ponto flutuante"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a condição de aceitação do passo",
                                  "subSteps": [
                                    "Comparar numericamente err < tol usando operador de comparação.",
                                    "Considerar uma margem de segurança, como err <= 1.2 * tol, para estabilidade.",
                                    "Registrar o resultado da comparação (True/False).",
                                    "Preparar estruturas condicionais (if-else) para ramificação.",
                                    "Testar com valores de exemplo para validar a lógica."
                                  ],
                                  "verification": "Implementação da condição if (err < tol) funciona corretamente em testes unitários.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou interpretador Python/MATLAB",
                                    "Exemplos numéricos simples"
                                  ],
                                  "tips": "Use abs(err) se erro for assinado, mas geralmente é norma.",
                                  "learningObjective": "Implementar corretamente a decisão binária baseada em tolerância.",
                                  "commonMistakes": [
                                    "Usar >= em vez de <",
                                    "Esquecer parênteses na condição composta",
                                    "Comparar strings em vez de floats"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar lógica de aceitação e sugestão de h_new",
                                  "subSteps": [
                                    "Aceitar a solução do passo atual como válida.",
                                    "Calcular o fator de ajuste: safety * (tol / err)^{1/(p+1)}, onde safety≈0.9 para conservadorismo.",
                                    "Computar h_new = h * fator, limitando crescimento (ex: h_new <= 2*h).",
                                    "Armazenar ou retornar h_new para o próximo passo.",
                                    "Atualizar o histórico de passos aceitos."
                                  ],
                                  "verification": "Para err=5e-7, tol=1e-6, p=4, h=0.1, h_new ≈0.115 calculado corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de programação (Python com NumPy)",
                                    "Função pow ou ** para exponenciação"
                                  ],
                                  "tips": "Aplique logaritmo para evitar overflow em (tol/err) muito grande.",
                                  "learningObjective": "Dominar a fórmula de ajuste de passo para aceitação eficiente.",
                                  "commonMistakes": [
                                    "Exponte 1/p em vez de 1/(p+1)",
                                    "Esquecer fator de segurança",
                                    "Permitir h_new ilimitado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar lógica de rejeição e redução de h",
                                  "subSteps": [
                                    "Rejeitar a solução atual e descartá-la.",
                                    "Calcular h_new reduzido: h * 0.5 * (tol / err)^{1/(p+1)} ou simplesmente 0.5 * h.",
                                    "Reiniciar o cálculo do passo com o novo h menor.",
                                    "Incrementar contador de rejeições para monitoramento.",
                                    "Definir limite máximo de rejeições para evitar loop infinito (ex: abortar após 5)."
                                  ],
                                  "verification": "Para err=2e-6, tol=1e-6, p=4, h=0.1, passo rejeitado e h_new=0.05 usado corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código com loop while para repetição",
                                    "Debugger para simular rejeições"
                                  ],
                                  "tips": "Use fator 0.5-0.8 para redução agressiva mas estável.",
                                  "learningObjective": "Gerenciar rejeições para convergência sem estagnação.",
                                  "commonMistakes": [
                                    "Não reduzir h o suficiente",
                                    "Loop infinito sem contador",
                                    "Aceitar erroneamente após rejeição"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um resolvedor RK45 para y' = -y, t de 0 a 1, h=0.1 inicial, tol=1e-6. No passo t=0.1, err=5e-7 < tol → aceitar, h_new=0.1 * (1e-6/5e-7)^{1/5} ≈0.115. Próximo passo t=0.2, err=2e-6 > tol → rejeitar, h_new=0.05, recalcular.",
                              "finalVerifications": [
                                "Condição err < tol implementada sem erros lógicos.",
                                "Fórmula h_new = h * (tol/err)^{1/(p+1)} computada precisamente.",
                                "Lógica de rejeição reduz h e repete passo corretamente.",
                                "Código roda sem loops infinitos e converge para solução precisa.",
                                "Testes com múltiplos cenários (aceito/rejeitado) passam.",
                                "Histórico de h mostra adaptação dinâmica."
                              ],
                              "assessmentCriteria": [
                                "Preparação de parâmetros: 20% (completude e precisão).",
                                "Implementação da condição if: 20% (correção lógica).",
                                "Cálculo de h_new em aceitação: 25% (fórmula exata).",
                                "Gerenciamento de rejeição: 20% (redução e loop).",
                                "Integração geral e testes: 15% (estabilidade e eficiência)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas condicionais e loops em Python/MATLAB.",
                                "Física/Engenharia: Controle de precisão em simulações dinâmicas (ex: trajetórias).",
                                "Computação Científica: Bibliotecas como SciPy solve_ivp.",
                                "Estatística: Análise de erro e convergência numérica."
                              ],
                              "realWorldApplication": "Usado em solvers de EDOs para simulações precisas em previsão meteorológica, dinâmica de voo de aeronaves e modelagem molecular, garantindo eficiência computacional sem perda de acurácia."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Resolver exemplo numérico completo",
                            "description": "Aplicar método RK embedded a y' = -y, y(0)=1, com tol=1e-6, demonstrando adaptação de h e passos aceitos/rejeitados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema EDO e parâmetros iniciais do método RK embedded",
                                  "subSteps": [
                                    "Identifique a equação diferencial y' = f(t,y) onde f(t,y) = -y.",
                                    "Defina condições iniciais: y(0) = 1, intervalo [0, 1] (ou até convergência).",
                                    "Escolha tolerância tol = 1e-6, h inicial = 0.2, fator de segurança β = 0.9, fatores de adaptação h_new = h_old * β * (tol/err)^{1/4}.",
                                    "Selecione método RK embedded, e.g., Dormand-Prince 4(5) com coeficientes padrão (a_ij, b_i, b^*_i).",
                                    "Prepare tabela para registrar t_n, h_n, y_n, passos aceitos/rejeitados."
                                  ],
                                  "verification": "Confirme que f(t,y), condições iniciais e parâmetros estão corretamente anotados sem erros aritméticos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, calculadora científica, tabela de coeficientes RK45 impressa.",
                                  "tips": "Use h inicial conservador (0.1-0.2) para evitar muitas rejeições iniciais.",
                                  "learningObjective": "Entender a preparação necessária para aplicação de métodos adaptativos em EDOs.",
                                  "commonMistakes": "Esquecer dependência de t em f (aqui autônoma), escolher h muito grande."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar um passo completo RK embedded e estimar erro local",
                                  "subSteps": [
                                    "Calcule os estágios k1 a k7 usando y_{n+1}^* = y_n + h * Σ a_{i1} k1 + ... (ordem 5).",
                                    "Calcule y_{n+1} = y_n + h * Σ b_i k_i (ordem 4).",
                                    "Estime erro local err = |y_{n+1}^* - y_{n+1}| / tol.",
                                    "Registre valores de todos k_i, y_{n+1}, err.",
                                    "Para exemplo: com t=0, h=0.2, y=1, compute k1 = -1, etc. (verificar manualmente primeiros)."
                                  ],
                                  "verification": "Verifique se err está calculado corretamente comparando y4 e y5 em pelo menos um estágio.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora com funções trigonométricas (se necessário), software auxiliar como Python para verificação opcional.",
                                  "tips": "Mantenha precisão em 8 casas decimais para evitar acúmulo de erros.",
                                  "learningObjective": "Dominar o cálculo dos estágios RK e estimativa de erro embedded.",
                                  "commonMistakes": "Índices errados nos coeficientes a_ij, soma incorreta dos b_i."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar controle de passo: aceitar/rejeitar e adaptar h",
                                  "subSteps": [
                                    "Se err < 1, aceite passo: atualize t_{n+1} = t_n + h, y_{n+1} = y_n + h Σ b_i k_i, marque 'aceito'.",
                                    "Se err >=1, rejeite: reduza h = h * β * (1/err)^{1/4}, marque 'rejeitado', repita passo.",
                                    "Limite rejeições por passo (max 5), ajuste h_min=1e-8, h_max=0.5.",
                                    "Registre h_novo, número de rejeições.",
                                    "Continue até t >=1 ou critério de parada."
                                  ],
                                  "verification": "Confirme que h diminui quando err>1 e aumenta quando err<<1, com pelo menos 1 aceito/1 rejeitado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Excel ou papel para tracking de h, t, y, status.",
                                  "tips": "Use expoente 1/(p+1) onde p=4 para ordem, monitore para estabilidade.",
                                  "learningObjective": "Implementar lógica de adaptação de passo baseada em erro local.",
                                  "commonMistakes": "Não dividir err por tol, fator de adaptação sem potência correta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Iterar até solução completa e analisar trajetória",
                                  "subSteps": [
                                    "Repita passos 2-3 até t_final=1.",
                                    "Registre tabela final: n, t_n, h_n, y_n, err_n, status (aceito/rejeitado).",
                                    "Compare com solução exata y=e^{-t} em pontos chave (erro global < tol * (1-t0)).",
                                    "Conte total passos aceitos/rejeitados, evolução de h.",
                                    "Plote y_num vs y_exata (gráfico manual ou software)."
                                  ],
                                  "verification": "Solução numérica coincide com e^{-1} ≈0.3679 dentro de tol acumulada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfica para plot, tabela de e^{-t} pré-calculada.",
                                  "tips": "Salve checkpoints a cada 10 passos para evitar perda de progresso.",
                                  "learningObjective": "Completar integração adaptativa e validar precisão.",
                                  "commonMistakes": "Parar cedo sem atingir t_final, ignorar rejeições excessivas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e documentar resultados finais",
                                  "subSteps": [
                                    "Calcule erro global max |y_num - y_exata|.",
                                    "Analise eficiência: passos totais vs fixed-step.",
                                    "Discuta adaptação: h inicial/final, % rejeitados.",
                                    "Documente lições: quando h foi rejeitado e por quê.",
                                    "Prepare relatório com tabela e gráfico."
                                  ],
                                  "verification": "Relatório mostra err_global <1e-5, pelo menos 2 rejeições demonstradas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software plot (Matplotlib/Python) ou papel milimetrado.",
                                  "tips": "Compare com método fixo para destacar vantagens.",
                                  "learningObjective": "Avaliar performance do método adaptativo.",
                                  "commonMistakes": "Erro na solução exata, não quantificar rejeições."
                                }
                              ],
                              "practicalExample": "Para y' = -y, y(0)=1, tol=1e-6, h_init=0.2: Primeiro passo gera err=1.2e-3>1 (rejeitar, h->0.18), segundo aceito; ao final t=1, y≈0.367879, 15 aceitos/3 rejeitados, h_final≈0.05.",
                              "finalVerifications": [
                                "Tabela completa com t, h, y, err, status para todo intervalo.",
                                "Pelo menos 1-5 passos rejeitados demonstrados.",
                                "h adapta corretamente: diminui em regiões 'difíceis', aumenta em suaves.",
                                "Erro global < tol * sqrt(N_passos).",
                                "Comparação visual y_num vs e^{-t}.",
                                "Total passos < 50 para eficiência."
                              ],
                              "assessmentCriteria": [
                                "Cálculos de k_i precisos (erro <1e-8 por estágio).",
                                "Lógica de aceitação/rejeição implementada corretamente.",
                                "Adaptação de h segue fórmula exata.",
                                "Registro completo de aceitos/rejeitados.",
                                "Análise de erro global e eficiência.",
                                "Documentação clara e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (scipy.integrate.odeint).",
                                "Física: Modelagem de decaimento radioativo (dy/dt=-ky).",
                                "Estatística: Análise de erro e controle de qualidade numérica.",
                                "Engenharia: Simulações dinâmicas em controle de sistemas."
                              ],
                              "realWorldApplication": "Usado em solvers de EDOs como MATLAB ode45 ou SciPy solve_ivp para simular trajetórias de mísseis, populações biológicas, circuitos RC e previsões financeiras com decaimento exponencial, garantindo precisão adaptativa sem passos excessivos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.4",
                            "name": "Discutir limitações da estimativa",
                            "description": "Explicar que a estimativa é assintótica para h pequeno e pode falhar em problemas stiff ou com singularidades locais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de estimativa assintótica",
                                  "subSteps": [
                                    "Revise a definição de convergência assintótica para métodos numéricos de resolução de EDOs.",
                                    "Analise a dependência da estimativa de erro local em relação ao tamanho do passo h.",
                                    "Estude exemplos teóricos onde o erro é O(h^{p+1}) para h → 0.",
                                    "Compare com comportamentos para h não pequeno usando gráficos ou tabelas.",
                                    "Discuta o papel da análise de Taylor na derivação da estimativa."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que a estimativa é válida apenas para h pequeno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), calculadora simbólica (Mathematica/MATLAB), notas de aula sobre truncamento local.",
                                  "tips": "Use expansões de Taylor para visualizar o comportamento assintótico.",
                                  "learningObjective": "Identificar que a estimativa de erro é uma aproximação assintótica válida para passos pequenos.",
                                  "commonMistakes": "Confundir assintótico com exato; ignorar termos de ordem superior."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar falhas em problemas stiff",
                                  "subSteps": [
                                    "Defina o que são problemas stiff (escalas de tempo muito diferentes nos autovalores).",
                                    "Implemente um exemplo clássico como y' = -1000(y-1) + sin(t) em código numérico.",
                                    "Compare estimativas de erro para h pequeno vs. h adaptativo em solvers explícitos vs. implícitos.",
                                    "Observe instabilidade numérica e superestima/subestima do erro.",
                                    "Discuta necessidade de métodos implicitos como BDF para stiff."
                                  ],
                                  "verification": "Gere plots mostrando divergência da estimativa em regime stiff.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python (Scipy odeint), exemplo de EDO stiff (Van der Pol com μ grande).",
                                  "tips": "Teste com h fixo pequeno e observe se o erro real explode apesar da estimativa.",
                                  "learningObjective": "Explicar por que a estimativa falha em problemas stiff devido a instabilidade.",
                                  "commonMistakes": "Usar solvers explícitos sem reconhecer rigidez; ignorar autovalores da Jacobiana."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar impactos de singularidades locais",
                                  "subSteps": [
                                    "Identifique singularidades em EDOs, como polos próximos ou coeficientes descontinuos.",
                                    "Escolha exemplo: y' = 1/(t-1) + y perto de t=1.",
                                    "Calcule estimativa de erro local em pontos próximos à singularidade.",
                                    "Compare com solução exata ou refinamento adaptativo.",
                                    "Analise como h pequeno não resolve picos locais de erro."
                                  ],
                                  "verification": "Demonstre numericamente que a estimativa subestima erro perto da singularidade.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Solver numérico com controle de passo (ode45 em MATLAB), gráficos de erro vs. h.",
                                  "tips": "Monitore o resíduo local perto de pontos críticos.",
                                  "learningObjective": "Reconhecer que singularidades locais invalidam a assunção de suavidade.",
                                  "commonMistakes": "Assumir suavidade global; não detectar singularidades na função f(t,y)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar limitações e estratégias de mitigação",
                                  "subSteps": [
                                    "Resuma as três limitações principais: assintótica, stiff, singularidades.",
                                    "Discuta heurísticas como detecção de rigidez (norma da Jacobiana).",
                                    "Explore uso de estimativas de erro global ou a posteriori.",
                                    "Proponha quando confiar na estimativa (problemas não-stiff, suaves).",
                                    "Crie um fluxograma para decisão de uso."
                                  ],
                                  "verification": "Escreva um parágrafo sintetizando limitações com exemplos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel/caneta para fluxograma, resumo de artigos sobre controle de erro adaptativo.",
                                  "tips": "Ligue limitações a falhas reais em simulações.",
                                  "learningObjective": "Formular guidelines para uso cauteloso da estimativa de erro local.",
                                  "commonMistakes": "Generalizar falhas sem contexto; omitir mitigações."
                                }
                              ],
                              "practicalExample": "Em um problema stiff como y' = -λ(y - sin(t)), com λ=1000, usando Runge-Kutta de ordem 4 com h=0.01: a estimativa de erro local sugere precisão, mas a solução diverge rapidamente devido à instabilidade, enquanto um método implícito como trapezoidal converge.",
                              "finalVerifications": [
                                "Explica corretamente o caráter assintótico da estimativa para h→0.",
                                "Identifica e exemplifica falha em problemas stiff com instabilidade.",
                                "Demonstra impacto de singularidades locais via contraexemplo numérico.",
                                "Propõe pelo menos duas estratégias para mitigar limitações.",
                                "Sintetiza limitações em um contexto de controle de passo adaptativo.",
                                "Discute validade em problemas não-stiff e suaves."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (assintótico vs. exato): 25%",
                                "Uso de exemplos numéricos concretos: 20%",
                                "Análise de falhas em stiff e singularidades: 25%",
                                "Clareza na síntese e mitigações: 15%",
                                "Profundidade de substeps e verificações: 10%",
                                "Conexão com teoria de truncamento local: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Física/Engenharia: Simulações de circuitos RLC stiff.",
                                "Programação: Implementação de solvers em Python (SciPy).",
                                "Estatística: Análise de incerteza em aproximações numéricas.",
                                "Ciências Computacionais: Otimização adaptativa de passos."
                              ],
                              "realWorldApplication": "Em modelagem climática ou farmacocinética, onde EDOs stiff surgem (ex: reações químicas rápidas/lentas), entender limitações evita erros em previsões, guiando escolha de solvers robustos como CVODE em simulações industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Algoritmos de Ajuste do Tamanho do Passo",
                    "description": "Fórmulas e estratégias para modificar o passo h com base na estimativa de erro, incluindo fatores de escala.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Estimativa de Erro Local",
                        "description": "Conceitos fundamentais para estimar o erro local truncado em métodos numéricos para EDOs, utilizando abordagens embutidas como em pares de Runge-Kutta de ordens diferentes.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Calcular erro local com métodos embutidos",
                            "description": "Dado um par de métodos Runge-Kutta embutidos (ex: Dormand-Prince), calcular a estimativa de erro local como a norma da diferença entre as soluções de ordem p e p+1, escalada pelo tamanho do passo h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes do método Runge-Kutta embutido",
                                  "subSteps": [
                                    "Estude a definição de um par Runge-Kutta embutido, como Dormand-Prince (RK45).",
                                    "Identifique as ordens de precisão p (menor) e p+1 (maior).",
                                    "Revise os coeficientes Butcher a, b_p e b_{p+1} para o método específico.",
                                    "Entenda que y_p e y_{p+1} são soluções candidatas computadas simultaneamente.",
                                    "Note que o erro local é estimado pela diferença entre essas soluções."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre y_p e y_{p+1} e seu papel na estimativa de erro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de coeficientes Butcher para Dormand-Prince",
                                    "Notas de aula sobre Runge-Kutta",
                                    "Calculadora ou software como Python/Octave"
                                  ],
                                  "tips": "Comece com um método simples como RK34 para praticar antes do Dormand-Prince.",
                                  "learningObjective": "Dominar a estrutura teórica dos métodos embutidos e sua estimativa de erro.",
                                  "commonMistakes": [
                                    "Confundir os vetores b_p e b_{p+1}",
                                    "Ignorar que ambos usam os mesmos estágios k_i",
                                    "Achar que p+1 é sempre exato"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar as soluções aproximadas y_p e y_{p+1}",
                                  "subSteps": [
                                    "Defina a EDO y' = f(t,y), condições iniciais e tamanho de passo h.",
                                    "Calcule os estágios intermediários k_1 a k_s usando os coeficientes a_ij.",
                                    "Aplique os pesos b_p para obter y_p = y_n + h * sum(b_pj * k_j).",
                                    "Aplique os pesos b_{p+1} para obter y_{p+1} = y_n + h * sum(b_{p+1j} * k_j).",
                                    "Armazene y_n, y_p e y_{p+1} para o próximo passo."
                                  ],
                                  "verification": "Verifique se y_p e y_{p+1} foram computados corretamente comparando com valores conhecidos de uma EDO teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Implementação em Python (scipy.integrate.rk45 como referência)",
                                    "Papel e lápis para cálculo manual",
                                    "EDO de teste: y' = -y, y(0)=1"
                                  ],
                                  "tips": "Implemente em código para evitar erros aritméticos manuais.",
                                  "learningObjective": "Executar o algoritmo RK embutido para gerar as duas estimativas de solução.",
                                  "commonMistakes": [
                                    "Erro nos índices dos coeficientes a_ij",
                                    "Esquecer o fator h na soma ponderada",
                                    "Usar pesos errados para y_p vs y_{p+1}"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a diferença e sua norma",
                                  "subSteps": [
                                    "Compute a diferença delta = y_p - y_{p+1} (vetorial).",
                                    "Escolha a norma apropriada (ex: norma L2 ||delta||_2 = sqrt(sum(delta_i^2))).",
                                    "Calcule a norma escalar do erro estimado: err = ||delta||.",
                                    "Para sistemas, aplique norma componente-wise se necessário.",
                                    "Registre o valor numérico de err."
                                  ],
                                  "verification": "Confirme que ||y_p - y_{p+1}|| é pequeno para h pequeno e consistente com teoria.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python com numpy para normas",
                                    "EDO teste com solução exata para validação"
                                  ],
                                  "tips": "Use norma L-infinito para erros máximos em componentes críticos.",
                                  "learningObjective": "Aplicar normas vetoriais para quantificar o erro local.",
                                  "commonMistakes": [
                                    "Usar norma errada (ex: L1 em vez de L2)",
                                    "Esquecer raiz quadrada na L2",
                                    "Inverter y_p e y_{p+1}"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escalar pelo tamanho do passo h e interpretar o erro local",
                                  "subSteps": [
                                    "Divida a norma pela potência de h: erro_local = ||delta|| / h (para ordem p).",
                                    "Ajuste o expoente se o método especifica (geralmente ~h^p).",
                                    "Interprete: se erro_local < tol, aceite o passo; senão, rejeite.",
                                    "Atualize y_{n+1} = y_{p+1} se aceito.",
                                    "Documente o valor final e decisão de aceitação."
                                  ],
                                  "verification": "Simule um passo e verifique se a decisão de aceitação/rejeição é coerente com tolerância dada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código completo de um passo RK embutido",
                                    "Tolerância de erro tol=1e-6"
                                  ],
                                  "tips": "Lembre-se: escalar por h normaliza para taxa de erro assintótica.",
                                  "learningObjective": "Finalizar a estimativa de erro local e integrá-la ao controle de passo.",
                                  "commonMistakes": [
                                    "Esquecer a divisão por h",
                                    "Usar h^{p} incorreto",
                                    "Confundir erro local com global"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1, h=0.1, usando par RK34 simples: k1= -0.2, k2≈-0.201, k3≈-0.202, k4≈-0.203. y_p ≈ 0.8187, y_{p+1} ≈ 0.8185. delta ≈ 0.0002, ||delta||_2 ≈ 0.0002, erro_local ≈ 0.0002 / 0.1 = 0.002 (aceito se tol>0.002).",
                              "finalVerifications": [
                                "Soluções y_p e y_{p+1} diferem por ordem de h^{p+1}.",
                                "Norma da diferença é positiva e diminui com h menor.",
                                "Escalamento por h produz estimativa consistente com ordem p.",
                                "Decisão de aceitação baseada em tol é lógica.",
                                "Código ou cálculo manual reproduz valores conhecidos.",
                                "Nenhum overflow ou NaN em computações numéricas."
                              ],
                              "assessmentCriteria": [
                                "Correção na implementação dos coeficientes Butcher (100% match).",
                                "Cálculo preciso de y_p e y_{p+1} (erro <1e-10).",
                                "Norma aplicada corretamente (L2 ou especificada).",
                                "Escalamento por h exato e interpretação adequada.",
                                "Tratamento de sistemas vetoriais sem erros.",
                                "Eficiência computacional (reuso de k_i)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica: Implementação em Python/Scipy.",
                                "Física Computacional: Simulações de dinâmica orbital.",
                                "Engenharia de Controle: Estabilidade em sistemas embarcados.",
                                "Estatística: Análise de erro em Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias de foguetes (NASA), onde o controle adaptativo de passo via erro local garante precisão sem desperdício computacional em missões espaciais reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Comparar erro estimado com tolerância",
                            "description": "Avaliar se o erro local estimado atende a uma tolerância absoluta ou relativa (tol), utilizando normas como máximo ou L2, e decidir aceitação ou rejeição do passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o tipo de tolerância e norma apropriada",
                                  "subSteps": [
                                    "Revise a especificação do problema para determinar se a tolerância é absoluta (tol_abs) ou relativa (tol_rel).",
                                    "Selecione a norma do erro: norma máxima (||e||_∞ = max |e_i|) ou norma L2 (||e||_2 = sqrt(∑ e_i²)).",
                                    "Defina os valores numéricos de tol_abs e tol_rel baseados no contexto do algoritmo.",
                                    "Anote a fórmula exata para o critério de comparação: para absoluta, ||e|| ≤ tol_abs; para relativa, ||e|| / ||y|| ≤ tol_rel.",
                                    "Verifique consistência com o método numérico (ex: Runge-Kutta)."
                                  ],
                                  "verification": "Confirme que a norma e tolerância selecionadas estão documentadas corretamente e coincidem com o problema.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Especificação do problema, notas de aula sobre normas e tolerâncias.",
                                  "tips": "Sempre priorize tolerância relativa em problemas com soluções de grande magnitude para evitar falsos rejeições.",
                                  "learningObjective": "Compreender e selecionar critérios de tolerância adequados para controle de erro em métodos numéricos.",
                                  "commonMistakes": "Confundir tolerância absoluta com relativa; ignorar a norma especificada no algoritmo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a norma do erro local estimado",
                                  "subSteps": [
                                    "Obtenha os vetores de erro estimado e solução aproximada (e e y).",
                                    "Para norma máxima: compute max(|e_i|) para todos componentes i.",
                                    "Para norma L2: compute sqrt(∑ e_i² / n) ou versão não-normalizada conforme definição.",
                                    "Use software ou calculadora para precisão numérica.",
                                    "Registre o valor exato da norma calculada (||e||)."
                                  ],
                                  "verification": "Valide o cálculo comparando com um exemplo manual simples ou função de verificação em código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica, MATLAB/Python com NumPy, dados de erro do passo anterior.",
                                  "tips": "Implemente uma função reutilizável para cálculo de normas para eficiência em iterações múltiplas.",
                                  "learningObjective": "Dominar o cálculo preciso de normas de vetores de erro em contextos numéricos.",
                                  "commonMistakes": "Esquecer de tirar raiz quadrada na norma L2; usar norma errada (ex: L1 em vez de L2)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a comparação com a tolerância",
                                  "subSteps": [
                                    "Para tolerância absoluta: verifique se ||e|| ≤ tol_abs.",
                                    "Para tolerância relativa: compute ||e|| / ||y|| e verifique se ≤ tol_rel.",
                                    "Registre o resultado booleano: aceito (true) ou rejeitado (false).",
                                    "Se misto, aplique o mais restritivo: min(tol_abs, tol_rel * ||y||).",
                                    "Documente o valor comparado e o threshold usado."
                                  ],
                                  "verification": "Confirme que o resultado booleano é consistente com os valores numéricos calculados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Valores de ||e||, tol_abs, tol_rel e ||y|| do passo anterior.",
                                  "tips": "Use operadores lógicos em código (if ||e|| <= tol) para automação e redução de erros manuais.",
                                  "learningObjective": "Aplicar corretamente critérios de comparação para decisão de aceitação em algoritmos adaptativos.",
                                  "commonMistakes": "Comparar ||e|| diretamente com tol_rel sem normalizar por ||y||; arredondamentos que alteram o booleano."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Decidir aceitação/rejeição e planejar próximo passo",
                                  "subSteps": [
                                    "Se aceito: avance para o próximo passo do algoritmo com h atual.",
                                    "Se rejeitado: ative mecanismo de rejeição (ex: reduzir h por fator 0.5).",
                                    "Registre logs: 'Passo aceito/rejeitado: ||e||=X vs tol=Y'.",
                                    "Atualize contador de rejeições se aplicável (ex: rejeitar >3 vezes falha).",
                                    "Planeje iteração subsequente com h ajustado."
                                  ],
                                  "verification": "Simule o próximo passo ou verifique se o log reflete decisão correta.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Algoritmo completo de ajuste de passo, diário de iterações.",
                                  "tips": "Mantenha um histórico de decisões para análise posterior de eficiência do controle de erro.",
                                  "learningObjective": "Integrar decisão de comparação em fluxos de controle de passo adaptativo.",
                                  "commonMistakes": "Não ajustar h após rejeição; ignorar loops de rejeição infinita."
                                }
                              ],
                              "practicalExample": "Em um solucionador de EDOs com Runge-Kutta de ordem 4/5, para y' = -y, y(0)=1, h=0.1, erro estimado e=[0.001, 0.0005], y=[0.9, 0.85]. Norma L2 de e=0.0008, ||y||_L2=1.23. Tol_rel=1e-3: 0.0008/1.23 ≈ 6.5e-4 ≤ 1e-3 → aceito. Avance com h=0.1.",
                              "finalVerifications": [
                                "Cálculo da norma ||e|| é preciso e matches com verificação manual.",
                                "Comparação booleana é correta para ambos tipos de tolerância.",
                                "Decisão de aceitação/rejeição leva a ajuste apropriado de h.",
                                "Logs documentam todos valores chave (||e||, tol, resultado).",
                                "Simulação de 5 passos consecutivos mantém erro global < tol.",
                                "Ausência de loops infinitos de rejeição."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de normas (erro < 1e-10).",
                                "Correta distinção e aplicação de tol_abs vs tol_rel.",
                                "Decisões consistentes em exemplos variados (aceito/rejeitado).",
                                "Documentação completa e clara de cada comparação.",
                                "Eficiência: <5 rejeições em 100 passos simulados.",
                                "Capacidade de debugar erros comuns em cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB com funções de norma (numpy.linalg.norm).",
                                "Física/Engenharia: Controle de precisão em simulações de dinâmica (ex: trajetórias orbitais).",
                                "Estatística: Análise de erro em métodos Monte Carlo.",
                                "Ciência da Computação: Otimização adaptativa em ML (learning rate scheduling)."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional), compara erro local em malhas adaptativas com tol=1e-6 para decidir refinar malha ou prosseguir, otimizando tempo de computação em projetos de engenharia aeroespacial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Escalonamento do erro para problemas escalares e vetoriais",
                            "description": "Aplicar escalonamento do erro local para sistemas de EDOs, considerando pesos como 1 + |y|/atol para tolerância relativa e absoluta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o erro local em métodos numéricos para EDOs",
                                  "subSteps": [
                                    "Revise os métodos explícitos de Runge-Kutta (ex: RK4) e como o erro local é estimado.",
                                    "Identifique a fórmula geral do erro local: err = |y_{n+1} - \tilde{y}_{n+1}| onde \tilde{y} é aproximação de ordem superior.",
                                    "Discuta a importância do controle de erro para estabilidade e precisão.",
                                    "Estude exemplos simples de EDO escalar como y' = -y.",
                                    "Analise como erros acumulam sem escalonamento."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a origem do erro local em um método RK e calcule para um passo simples.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notebook com Python/MATLAB para simulações básicas",
                                    "Slides ou vídeo sobre Runge-Kutta"
                                  ],
                                  "tips": "Comece com EDOs lineares simples para visualizar o erro graficamente.",
                                  "learningObjective": "Entender a estimativa e impacto do erro local truncamento em solvers de EDOs.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Ignorar termos de ordem superior na estimativa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escalonamento do erro para problemas escalares",
                                  "subSteps": [
                                    "Defina escalonamento escalar: scal = 1 + |y_n| / atol.",
                                    "Calcule o erro escalonado: err_scal = |err| / scal.",
                                    "Compare err_scal com rtol para decisão de aceitação/rejeição de passo.",
                                    "Implemente fórmula em pseudocódigo: if err_scal > 1, rejeitar h.",
                                    "Teste com EDO y' = y, y(0)=1, variando atol e rtol."
                                  ],
                                  "verification": "Calcule manualmente err_scal para um passo h=0.1 em y'=-y e verifique se <1.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Calculadora ou spreadsheet",
                                    "Código Python simples para EDO escalar",
                                    "Folha de exercícios com valores numéricos"
                                  ],
                                  "tips": "Use valores pequenos para atol (1e-6) para ver efeito relativo.",
                                  "learningObjective": "Aplicar escalonamento escalar para normalizar erro em problemas unidimensionais.",
                                  "commonMistakes": [
                                    "Esquecer o '1 +' no escalar",
                                    "Usar rtol em vez de atol no denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Generalização para problemas vetoriais",
                                  "subSteps": [
                                    "Defina vetor de escalares: scal_i = 1 + |y_i| / atol para cada componente i.",
                                    "Calcule erro escalonado por componente: err_scal_i = |err_i| / scal_i.",
                                    "Use norma máxima: err_vec = max(err_scal_i) ou norma euclidiana.",
                                    "Adapte para sistemas: y' = A y, com y vetor.",
                                    "Implemente em código vetorizado (NumPy)."
                                  ],
                                  "verification": "Para sistema 2D, compute err_vec e confirme norma <1 para aceitação.",
                                  "estimatedTime": "75 min",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Exemplos de sistemas lineares acoplados",
                                    "Gráficos de trajetórias para visualização"
                                  ],
                                  "tips": "Sempre vetorize operações para eficiência computacional.",
                                  "learningObjective": "Estender escalonamento a sistemas multivariáveis mantendo tolerâncias.",
                                  "commonMistakes": [
                                    "Aplicar escalar médio em vez de por componente",
                                    "Usar norma L1 em vez de L-inf para controle rigoroso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração de tolerâncias relativa e absoluta",
                                  "subSteps": [
                                    "Combine rtol e atol: scal = atol + rtol * |y| (forma comum).",
                                    "Ajuste h_new = h * (tol / err_scal)^{1/(p+1)} onde p=ordem.",
                                    "Teste sensibilidade variando rtol/atol em solver adaptativo.",
                                    "Valide com solução exata para medir erro global.",
                                    "Discuta trade-offs: precisão vs custo computacional."
                                  ],
                                  "verification": "Implemente solver completo e compare erro global com solver fixo.",
                                  "estimatedTime": "90 min",
                                  "materials": [
                                    "SciPy odeint/solve_ivp para benchmark",
                                    "Notebook Jupyter",
                                    "EDOs não-lineares como Lotka-Volterra"
                                  ],
                                  "tips": "Monitore fator de segurança (0.9) no ajuste de h para evitar oscilações.",
                                  "learningObjective": "Implementar controle de passo robusto com escalonamento híbrido.",
                                  "commonMistakes": [
                                    "Confundir rtol com atol",
                                    "Não limitar redução/aumento de h (ex: 0.2-5)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para EDO escalar y' = -2y, y(0)=1 (sol exata y=e^{-2t}), com h=0.1, atol=1e-6, rtol=1e-3. Estime err_local ≈ 1.2e-5 com RK4. scal = 1e-6 + 1e-3*|1| ≈ 0.001001, err_scal ≈ 1.2e-2 <1 → aceitar. Para vetor [y1,y2] em sistema rígido, compute max(err_scal_i).",
                              "finalVerifications": [
                                "Calcule corretamente scal para escalar e vetor com dados numéricos fornecidos.",
                                "Implemente função de escalonamento em Python que retorne err_scal <1.",
                                "Ajuste h em um solver adaptativo e obtenha erro global < rtol.",
                                "Explique diferenças entre escalar e vetorial em relatório curto.",
                                "Compare com solver built-in (SciPy) em gráfico de solução.",
                                "Identifique e corrija erros em código com bugs intencionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de scal e err_scal (erro <1e-10).",
                                "Correta generalização vetorial com norma apropriada.",
                                "Implementação funcional de ajuste de h com fatores de segurança.",
                                "Análise de trade-offs em tempo vs precisão.",
                                "Clareza na explicação de pesos relativos/absolutos.",
                                "Uso eficiente de vetorização em código."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/Octave para solvers adaptativos.",
                                "Física Computacional: Simulações de osciladores ou dinâmica molecular.",
                                "Engenharia de Controle: Ajuste de passo em simulações de sistemas dinâmicos.",
                                "Estatística: Controle de erro em métodos Monte Carlo para EDOs estocásticas."
                              ],
                              "realWorldApplication": "Em software como MATLAB ode45 ou SciPy solve_ivp, usado em modelagem climática (previsão de furacões), farmacocinética (simulação de drogas) e finanças (modelos Black-Scholes numéricos), garantindo precisão adaptativa sem passos excessivos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Algoritmos de Ajuste de Passo Simples",
                        "description": "Estratégias básicas para modificar o tamanho do passo h baseado na estimativa de erro, incluindo fórmulas de rejeição e aceitação sem previsão sofisticada.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Implementar ajuste proporcional ao erro",
                            "description": "Derivar e aplicar a fórmula h_new = h_old * (tol / err)^{1/p}, onde p é a ordem do método, para aumentar ou diminuir o passo após aceitação ou rejeição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de controle de passo e estimativa de erro",
                                  "subSteps": [
                                    "Estude o conceito de erro local em métodos numéricos de integração de EDOs, como o erro de truncamento em Runge-Kutta.",
                                    "Revise a definição de tolerância (tol) como limite aceitável para o erro estimado (err).",
                                    "Entenda o papel da ordem p do método (ex: p=4 para RK4) na escala do erro, que varia como O(h^p).",
                                    "Analise cenários de aceitação (err ≤ tol) e rejeição (err > tol) no algoritmo de passo adaptativo.",
                                    "Discuta fatores de segurança (tipicamente 0.9 ou 0.5) para evitar oscilações."
                                  ],
                                  "verification": "Resuma em um diagrama os fluxos de aceitação e rejeição, identificando onde o ajuste ocorre.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta para diagrama",
                                    "Notas de aula sobre Runge-Kutta"
                                  ],
                                  "tips": "Use analogias como ajustar a velocidade de um carro baseado no erro de navegação para fixar conceitos.",
                                  "learningObjective": "Dominar os princípios teóricos que justificam o ajuste proporcional ao erro.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Ignorar o impacto da ordem p no expoente",
                                    "Não considerar fatores de segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a fórmula de ajuste proporcional ao erro",
                                  "subSteps": [
                                    "Parta do erro estimado err ≈ C * h_old^p, onde C é uma constante desconhecida.",
                                    "Para atingir err_new ≈ tol, defina h_new^p ≈ (tol / C), logo h_new ≈ h_old * (tol / err)^{1/p}.",
                                    "Derive matematicamente assumindo que C é aproximadamente constante entre passos sucessivos.",
                                    "Inclua fatores de segurança: h_new = h_old * 0.9 * (tol / err)^{1/p} para aceitação e 0.5 para rejeição.",
                                    "Verifique dimensionalmente e limite casos (err << tol → aumento; err >> tol → redução)."
                                  ],
                                  "verification": "Escreva a derivação passo a passo e compute um exemplo numérico simples.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (SymPy/Python)",
                                    "Papel quadriculado",
                                    "Referência teórica de métodos adaptativos"
                                  ],
                                  "tips": "Anote a derivação em LaTeX para clareza e reutilização em relatórios.",
                                  "learningObjective": "Capacitar-se a derivar fórmulas de ajuste de forma independente.",
                                  "commonMistakes": [
                                    "Esquecer o expoente 1/p",
                                    "Usar err/tol em vez de tol/err",
                                    "Não diferenciar aceitação/rejeição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o cálculo do novo passo em código",
                                  "subSteps": [
                                    "Defina uma função calc_h_new(h_old, tol, err, p, safety_accept=0.9, safety_reject=0.5, is_accepted=True).",
                                    "Implemente a lógica condicional: se aceito, use safety_accept; senão, safety_reject.",
                                    "Adicione clamps: h_new min=1e-12, max=1.0 para estabilidade.",
                                    "Teste unitário com inputs fixos e compare saídas esperadas.",
                                    "Inclua logs para depuração: print(h_old, err, h_new)."
                                  ],
                                  "verification": "Execute testes unitários e confirme que h_new diminui quando err > tol e aumenta quando err < tol.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Editor de código (Python/Jupyter ou MATLAB)",
                                    "Biblioteca NumPy para cálculos",
                                    "Framework de testes (pytest)"
                                  ],
                                  "tips": "Use funções puras sem side-effects para facilitar testes.",
                                  "learningObjective": "Codificar a fórmula de forma robusta e reutilizável.",
                                  "commonMistakes": [
                                    "Divisão por zero se err=0",
                                    "Expoente incorreto (use ** (1/p))",
                                    "Ignorar NaN/Inf em flutuantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar o ajuste em um solver de EDO e validar",
                                  "subSteps": [
                                    "Integre a função em um loop de Runge-Kutta adaptativo simples para y' = -y, y(0)=1.",
                                    "No loop: estime err, aplique ajuste, aceite/rejeite passo.",
                                    "Monitore h ao longo da integração até t=5.",
                                    "Compare solução adaptativa com solução exata e fixa-passo.",
                                    "Analise eficiência: número de passos vs. precisão."
                                  ],
                                  "verification": "Plote h(t), err(t) e solução; confirme convergência e estabilidade.",
                                  "estimatedTime": "40-60 minutos",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Matplotlib/Plots para visualização",
                                    "Solução analítica conhecida"
                                  ],
                                  "tips": "Comece com tol=1e-6 e ajuste parâmetros para observar comportamento.",
                                  "learningObjective": "Aplicar o ajuste em contexto real de solver numérico.",
                                  "commonMistakes": [
                                    "Loop infinito por oscilações de h",
                                    "Não resetar h após rejeição",
                                    "Erro na estimativa de err"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver y' = y, y(0)=1 até t=1 com tol=1e-6, p=4. Em t=0.1, h_old=0.1, err=2e-5 (>tol). h_new = 0.1 * 0.5 * (1e-6 / 2e-5)^{1/4} ≈ 0.1 * 0.5 * (0.05)^{0.25} ≈ 0.1 * 0.5 * 0.473 ≈ 0.0237. Próximo passo usa h=0.0237, err cai para ~5e-7 (aceito), então h_new ≈ 0.0237 * 0.9 * (1e-6 / 5e-7)^{1/4} ≈ 0.0237 * 0.9 * (2)^{0.25} ≈ 0.0237 * 0.9 * 1.189 ≈ 0.0254.",
                              "finalVerifications": [
                                "Fórmula derivada corretamente com fatores de segurança.",
                                "Função calc_h_new passa em 5+ testes unitários variados.",
                                "Solver adaptativo converge com <10% mais passos que teórico.",
                                "Plot de h(t) mostra aumento gradual e estabilidade sem oscilações.",
                                "Erro global < tol em toda a integração.",
                                "Código comentado e modular para reutilização."
                              ],
                              "assessmentCriteria": [
                                "Precisão: h_new ajusta err para próximo de tol em 1-2 iterações.",
                                "Eficiência: Redução de passos totais em 20-50% vs. passo fixo.",
                                "Robustez: Trata casos extremos (err=0, h muito pequeno/grande).",
                                "Clareza: Código legível com comentários e derivação anexada.",
                                "Validação: Comparação quantitativa com solução exata (erro <1e-5).",
                                "Escalabilidade: Funciona para diferentes p e EDOs não-lineares."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB para computação científica.",
                                "Física: Simulações de osciladores harmônicos ou trajetórias.",
                                "Engenharia: Controle adaptativo em sistemas dinâmicos.",
                                "Estatística: Otimização de precisão em Monte Carlo numérico."
                              ],
                              "realWorldApplication": "Usado em solvers como ODE45 (MATLAB) ou SciPy.solve_ivp para simulações precisas e eficientes em modelagem climática, dinâmica de fluidos, finanças (equações de Black-Scholes) e bioengenharia (modelos populacionais), reduzindo tempo computacional em ordens de magnitude sem perda de acurácia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Aplicar fator de segurança",
                            "description": "Incorporar um fator de segurança (tipicamente 0.9) na fórmula de ajuste para evitar oscilações, calculando h_new = 0.9 * h_old * (tol / err)^{1/(p+1)}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito e propósito do fator de segurança",
                                  "subSteps": [
                                    "Estude a definição de fator de segurança em algoritmos de ajuste de passo: um multiplicador conservador (tipicamente 0.9) para evitar oscilações no tamanho do passo.",
                                    "Analise por que oscilações ocorrem sem ele: ajustes muito agressivos podem alternar h muito grande e muito pequeno.",
                                    "Compare fórmulas com e sem fator: h_new = h_old * (tol / err)^{1/(p+1)} vs. h_new = 0.9 * h_old * (tol / err)^{1/(p+1)}",
                                    "Leia exemplos em livros de análise numérica sobre métodos adaptativos para EDOs.",
                                    "Anote os benefícios: estabilidade, convergência mais suave e prevenção de rejeições de passos."
                                  ],
                                  "verification": "Explique em suas palavras o papel do fator 0.9 e dê um exemplo hipotético de oscilação sem ele.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Visualize graficamente: plote h vs. iterações com e sem fator para ver a diferença.",
                                  "learningObjective": "Entender o motivo matemático e numérico do fator de segurança na estabilidade de algoritmos adaptativos.",
                                  "commonMistakes": "Confundir com fator de segurança em engenharia estrutural; ignorar que é específico para controle numérico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e calcular os componentes da fórmula",
                                  "subSteps": [
                                    "Identifique os parâmetros: h_old (passo anterior), tol (tolerância desejada), err (erro estimado), p (ordem do método).",
                                    "Calcule o expoente: 1/(p+1), ex: para p=1 (Euler), é 1/2 = 0.5.",
                                    "Compute a razão tol/err e eleve à potência: (tol / err)^{1/(p+1)}.",
                                    "Multiplique pelo fator de segurança: 0.9 * resultado anterior.",
                                    "Registre valores intermediários em uma tabela para rastreamento."
                                  ],
                                  "verification": "Monte uma tabela com valores de entrada e saídas intermediárias para um conjunto dado de parâmetros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou papel quadriculado"
                                  ],
                                  "tips": "Use logaritmos para potências: log((tol/err)^{1/(p+1)}) = [1/(p+1)] * log(tol/err) para precisão numérica.",
                                  "learningObjective": "Dominar o cálculo preciso dos termos intermediários da fórmula de ajuste.",
                                  "commonMistakes": "Esquecer de dividir tol/err corretamente ou inverter err/tol; usar p em vez de p+1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a fórmula completa em um exemplo numérico",
                                  "subSteps": [
                                    "Escolha valores exemplo: h_old=0.1, tol=1e-6, err=2e-5, p=1.",
                                    "Calcule passo a passo: razão = 1e-6 / 2e-5 = 0.05; expoente=0.5; (0.05)^0.5 ≈ 0.2236; h_new = 0.9 * 0.1 * 0.2236 ≈ 0.0201.",
                                    "Repita para outro conjunto: h_old=0.05, tol=1e-6, err=5e-7, p=2 (expoente=1/3≈0.333).",
                                    "Compare h_new com h_old e interprete: redução ou aumento do passo.",
                                    "Implemente em pseudocódigo simples."
                                  ],
                                  "verification": "Obtenha h_new correto até 4 casas decimais e explique se o passo aumentou ou diminuiu.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para verificação",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Sempre arredonde conservadoramente para baixo se necessário, simulando o fator extra.",
                                  "learningObjective": "Executar a fórmula de ajuste com fator de segurança de forma precisa e autônoma.",
                                  "commonMistakes": "Omitir o 0.9; calcular potência errada (ex: usar p ao invés de p+1); erros de ordem de magnitude em tol/err."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e verificar em um contexto iterativo",
                                  "subSteps": [
                                    "Simule 3-5 iterações de um algoritmo de ajuste: comece com h=0.1, varie err aleatoriamente dentro de tol.",
                                    "Aplique a fórmula sequencialmente e plote a evolução de h.",
                                    "Verifique estabilidade: h não deve oscilar mais que 20% entre iterações.",
                                    "Ajuste tol ou p e observe impacto do fator 0.9.",
                                    "Documente o processo em um relatório curto com gráfico."
                                  ],
                                  "verification": "Gere um gráfico ou tabela mostrando h estável ao longo de iterações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (Excel, Python matplotlib ou papel gráfico)",
                                    "Caderno"
                                  ],
                                  "tips": "Teste sem 0.9 para contrastar: veja oscilações para reforçar importância.",
                                  "learningObjective": "Aplicar o fator em loops iterativos, garantindo estabilidade numérica.",
                                  "commonMistakes": "Não limitar h_new (ex: impor h_min e h_max); ignorar dependência de p."
                                }
                              ],
                              "practicalExample": "Em um solver de EDO y'=y, com método de Euler (p=1), h_old=0.1, tol=1e-6, err=3e-5: razão=tol/err=0.0333, (0.0333)^{0.5}≈0.1826, h_new=0.9*0.1*0.1826≈0.0164. Próxima iteração com err=8e-7: razão=1.25, (1.25)^{0.5}≈1.118, h_new=0.9*0.0164*1.118≈0.0165 (estável).",
                              "finalVerifications": [
                                "Fórmula aplicada corretamente: h_new = 0.9 * h_old * (tol / err)^{1/(p+1)} em pelo menos 3 exemplos.",
                                "Cálculos intermediários documentados e precisos até 4 decimais.",
                                "Evolução de h em iterações mostra ausência de oscilações (>20% de variação).",
                                "Explicação escrita do impacto do fator 0.9 na estabilidade.",
                                "Pseudocódigo ou implementação simples testada sem erros.",
                                "Comparação com versão sem fator demonstra redução de oscilações."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos (erro <1e-4).",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Número e qualidade de subpassos executados (mínimo 4 por step).",
                                "Uso correto de materiais e verificações em cada step.",
                                "Criatividade em exemplos e conexões práticas.",
                                "Ausência de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (biblioteca scipy.integrate) para solvers adaptativos.",
                                "Física: Aplicar em simulações de movimento (ex: osciladores harmônicos com Runge-Kutta).",
                                "Engenharia: Controle de passos em simulações CFD ou circuitos elétricos.",
                                "Estatística: Fatores de correção em métodos Monte Carlo adaptativos."
                              ],
                              "realWorldApplication": "Em softwares de simulação como MATLAB ODE45 ou COMSOL, o fator de segurança previne falhas em simulações de engenharia aeroespacial (tra jetórias de foguetes) ou biomedicina (modelos de difusão de fármacos), garantindo precisão sem desperdício computacional excessivo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Gerenciar rejeições sucessivas",
                            "description": "Implementar lógica para reduzir h drasticamente (ex: h_new = 0.5 * h_old) após múltiplas rejeições, evitando loops infinitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema de rejeições sucessivas",
                                  "subSteps": [
                                    "Estude o conceito de rejeição em algoritmos de passo adaptativo, como quando o erro local excede o tolerância.",
                                    "Analise cenários onde rejeições ocorrem repetidamente, levando a loops infinitos.",
                                    "Identifique impactos: perda de eficiência computacional e possível divergência.",
                                    "Revise exemplos em métodos como Runge-Kutta de ordem 4 com controle de passo.",
                                    "Discuta com pseudocódigo o fluxo normal vs. rejeição múltipla."
                                  ],
                                  "verification": "Resuma em 3 frases os riscos de loops infinitos e forneça um diagrama de fluxo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta para diagrama",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar o ciclo de aceitação/rejeição.",
                                  "learningObjective": "Entender as causas e consequências de rejeições sucessivas em métodos numéricos adaptativos.",
                                  "commonMistakes": [
                                    "Confundir rejeição com falha de convergência",
                                    "Ignorar o custo computacional acumulado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir critérios para detecção de rejeições múltiplas",
                                  "subSteps": [
                                    "Estabeleça um contador de rejeições consecutivas (ex: rejeicoes_consec = 0).",
                                    "Defina limiar para 'sucessivas', como 3 rejeições seguidas.",
                                    "Atualize o contador: incremente em rejeição, resete em aceitação.",
                                    "Documente o limiar como parâmetro configurável para flexibilidade.",
                                    "Teste logicamente com cenários: 2 rejeições (normal), 3+ (redução drástica)."
                                  ],
                                  "verification": "Implemente pseudocódigo para o contador e simule 5 cenários manuais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Documentação de métodos numéricos"
                                  ],
                                  "tips": "Comece com limiar baixo (2-3) para testes iniciais.",
                                  "learningObjective": "Criar lógica robusta para rastrear rejeições consecutivas.",
                                  "commonMistakes": [
                                    "Não resetar contador após aceitação",
                                    "Usar contagem total em vez de consecutivas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar redução drástica do tamanho do passo",
                                  "subSteps": [
                                    "Ao atingir o limiar, aplique redução: h_new = fator * h_old, onde fator = 0.5 ou 0.25.",
                                    "Escolha fator baseado em literatura (ex: 0.5 para conservadorismo).",
                                    "Integre no loop principal: após redução, reset contador e tente novo passo.",
                                    "Adicione log para rastrear reduções (print ou log).",
                                    "Garanta h mínima para evitar zero: if h_new < h_min, pare o algoritmo."
                                  ],
                                  "verification": "Codifique em Python uma função standalone e teste com h inicial variando.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Jupyter Notebook",
                                    "Exemplos de código de RK4"
                                  ],
                                  "tips": "Use fator < 0.5 para casos severos; teste sensibilidade.",
                                  "learningObjective": "Implementar mecanismo de redução que previne loops infinitos.",
                                  "commonMistakes": [
                                    "Redução muito agressiva causando h=0",
                                    "Esquecer reset do contador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a implementação integrada",
                                  "subSteps": [
                                    "Integre a lógica em um solver completo (ex: RK4 adaptativo para EDO).",
                                    "Crie teste com EDO conhecida que causa rejeições (ex: y' = y^2, y(0)=1).",
                                    "Monitore: número de rejeições, h final, tempo de execução.",
                                    "Compare com versão sem gerenciamento: verifique término sem loop.",
                                    "Ajuste parâmetros e documente resultados em tabela."
                                  ],
                                  "verification": "Execute simulação, confirme <5 rejeições sucessivas e solução convergente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python completo",
                                    "Matplotlib para plots",
                                    "EDOs teste"
                                  ],
                                  "tips": "Plot h vs. passos para visualizar reduções.",
                                  "learningObjective": "Validar que a lógica evita loops e mantém precisão.",
                                  "commonMistakes": [
                                    "Testes só com casos fáceis",
                                    "Ignorar h_min levando a overflow"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um solver RK4 para y' = -y, y(0)=1, com tol=1e-6 e h_init=0.1. Após 3 rejeições seguidas (devido a h grande perto de singularidade simulada), aplica h = 0.5 * h, reset contador. Código: if rejeicoes_consec >= 3: h *= 0.5; rejeicoes_consec = 0; logger.info('Redução drástica!'). Resultado: integra até t=5 sem loop infinito.",
                              "finalVerifications": [
                                "O contador reseta corretamente após aceitação de passo.",
                                "Redução ocorre exatamente após 3 rejeições consecutivas.",
                                "h não cai abaixo de mínimo configurado.",
                                "Algoritmo termina em tempo finito para EDOs problemáticas.",
                                "Número total de rejeições é reduzido em >50% vs. sem gerenciamento.",
                                "Logs mostram reduções drásticas quando apropriado."
                              ],
                              "assessmentCriteria": [
                                "Precisão da lógica de contagem (100% cenários corretos).",
                                "Eficiência: tempo de execução < 2x versão sem rejeições.",
                                "Robustez: previne loops em 5+ testes estressantes.",
                                "Documentação clara de parâmetros e logs.",
                                "Flexibilidade: limiar e fator configuráveis.",
                                "Integração seamless em solver existente."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação de loops e condicionais em Python.",
                                "Engenharia de Software: Gerenciamento de exceções e logs em algoritmos numéricos.",
                                "Física Computacional: Aplicação em simulações dinâmicas adaptativas.",
                                "Otimização: Estratégias de busca heurística para parâmetros adaptativos."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional), onde rejeições sucessivas ocorrem em regiões turbulentas; a redução drástica garante estabilidade sem travar simulações de horas, permitindo previsão precisa em aviação e previsão climática."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Algoritmos de Passo Múltiplo e Fatores de Escala",
                        "description": "Técnicas avançadas usando múltiplos passos de teste para prever o erro e ajustar h, incluindo limites e estratégias para estabilidade em problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Usar previsão com passo duplo",
                            "description": "Calcular um passo com 2h para estimar erro global e ajustar h_new baseado na relação err(2h)/err(h) ≈ 2^p, otimizando para eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema numérico e calcular aproximação com passo h",
                                  "subSteps": [
                                    "Defina a equação diferencial ou integral a ser resolvida, incluindo condições iniciais e intervalo [a,b].",
                                    "Escolha o método numérico (ex: Euler, Runge-Kutta) e defina o passo inicial h.",
                                    "Implemente o algoritmo para calcular a solução aproximada y_h no passo h, gerando os pontos da malha.",
                                    "Registre os valores finais ou a solução completa em uma tabela ou array.",
                                    "Calcule métricas básicas como número de passos N = (b-a)/h."
                                  ],
                                  "verification": "Verifique se a solução y_h foi computada sem erros de implementação e se todos os pontos da malha foram gerados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora científica ou software como Python (NumPy/SciPy) ou MATLAB.",
                                  "tips": "Comece com um h pequeno para testes iniciais, mas não muito pequeno para evitar tempo excessivo.",
                                  "learningObjective": "Compreender a configuração inicial de um solver numérico e executar uma iteração básica com passo h.",
                                  "commonMistakes": "Esquecer condições iniciais; usar fórmula errada do método; arredondamentos prematuros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular aproximação com passo duplo 2h",
                                  "subSteps": [
                                    "Mantenha o mesmo método numérico e problema, mas use h_duplo = 2h.",
                                    "Implemente o algoritmo para gerar y_{2h}, notando que o número de passos é N/2.",
                                    "Alinhe as malhas se necessário (interpole y_{2h} para coincidir com pontos de y_h).",
                                    "Registre y_{2h} nos mesmos pontos de avaliação que y_h para comparação direta.",
                                    "Compare visualmente ou tabule os resultados preliminares."
                                  ],
                                  "verification": "Confirme que y_{2h} requer aproximadamente metade dos passos de y_h e que as malhas estão alinhadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo software ou calculadora do Step 1; planilha para tabulação.",
                                  "tips": "Reutilize código do Step 1 alterando apenas h para eficiência.",
                                  "learningObjective": "Executar computação com passo maior para gerar baseline de erro grosseiro.",
                                  "commonMistakes": "Não alinhar malhas corretamente; confundir h com 2h na implementação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar o erro global usando as duas aproximações",
                                  "subSteps": [
                                    "Calcule a diferença δ = |y_h - y_{2h}| nos pontos alinhados.",
                                    "Estime o erro global err(h) ≈ δ / (2^p - 1), onde p é a ordem do método (ex: p=1 para Euler).",
                                    "Compute err(2h) ≈ δ / (2^p - 1) ajustado, mas foque na relação err(2h)/err(h) ≈ 2^p.",
                                    "Verifique se a relação empírica δ(2h)/δ(h) ≈ 2^p confirma a ordem esperada.",
                                    "Defina tolerância global tol para comparação futura."
                                  ],
                                  "verification": "A relação err(2h)/err(h) deve aproximar 2^p (ex: 2 para Euler); plote δ vs. h para visualização.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software com plotting (Matplotlib/Python ou MATLAB); tabela de erros.",
                                  "tips": "Use norma máxima ou L2 para δ; assuma p conhecida do método.",
                                  "learningObjective": "Aplicar fórmula de erro de passo duplo para quantificar truncamento.",
                                  "commonMistakes": "Usar δ bruta como erro sem fator (2^p -1); ignorar p do método."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar o novo passo h_new baseado na estimativa de erro",
                                  "subSteps": [
                                    "Calcule o fator de segurança s ≈ 0.9 (típico para estabilidade).",
                                    "Use h_new = h * (tol / err(h))^{1/p} * s, derivado da relação err ∝ h^p.",
                                    "Ajuste para eficiência: se err(2h)/err(h) ≠ 2^p, refine p empírico como log2(err(2h)/err(h)).",
                                    "Garanta h_new > h_min e < h_max para evitar loops ou imprecisão.",
                                    "Atualize h para próxima iteração."
                                  ],
                                  "verification": "Simule uma iteração: err estimado com h_new deve satisfazer tol.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora ou script para fórmula; log de h's anteriores.",
                                  "tips": "Inclua fator s <1 para conservadorismo; teste com p empírico se necessário.",
                                  "learningObjective": "Otimizar tamanho de passo dinamicamente para eficiência computacional.",
                                  "commonMistakes": "Exponenciar errado (1/p); h_new negativo ou zero; ignorar bounds."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar convergência e eficiência do ajuste",
                                  "subSteps": [
                                    "Reexecute passos 1-4 com h_new e compare erros.",
                                    "Meça custo total: (passos_h + passos_2h) vs. passos fixos para mesma tol.",
                                    "Confirme redução de erro sem aumento excessivo de custo.",
                                    "Documente ciclo completo em um relatório ou log.",
                                    "Itere se necessário até convergência."
                                  ],
                                  "verification": "Erro final < tol e custo < 1.5x método fixo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Script completo; timer para custo computacional.",
                                  "tips": "Monitore razão custo/precisão; pare em critério de convergência.",
                                  "learningObjective": "Avaliar trade-off entre precisão e eficiência em controle de passo.",
                                  "commonMistakes": "Não medir custo; continuar iterando indefinidamente."
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y, y(0)=1, t de 0 a 1 (exata: y=e^{-2t}). Use Euler (p=1), h=0.1: y_h(1)≈0.1353; 2h=0.2: y_{2h}(1)≈0.1225. δ≈0.0128, err(h)≈δ/(2-1)=0.0128. Relação err(2h)/err(h)≈2. h_new=0.1*(0.001/0.0128)^1 *0.9≈0.07, reduzindo passos eficientemente.",
                              "finalVerifications": [
                                "Relação err(2h)/err(h) ≈ 2^p confirmada numericamente.",
                                "h_new resulta em erro estimado < tolerância desejada.",
                                "Custo computacional (avaliações de f) é otimizado vs. passo fixo.",
                                "Solução final converge para valor exato conhecido.",
                                "Log de h's mostra adaptação estável sem oscilações.",
                                "Nenhum overflow/underflow em cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na estimativa de erro (erro < 10% do verdadeiro).",
                                "Correta aplicação da fórmula h_new com fator de segurança.",
                                "Eficiência: redução de passos >20% para mesma tol.",
                                "Implementação livre de bugs em sub-passos.",
                                "Explicação clara da relação 2^p.",
                                "Uso apropriado de p empírico se ordem incerta."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB para solvers adaptativos.",
                                "Física: Simulações de movimento (ex: osciladores em mecânica).",
                                "Engenharia: Otimização em CFD ou circuitos elétricos.",
                                "Estatística: Análise de erro em Monte Carlo numérico."
                              ],
                              "realWorldApplication": "Em simulações de engenharia como previsão de clima (modelos ODEs), onde passos adaptativos reduzem tempo de CPU em supercomputadores, permitindo runs mais longos com precisão controlada, otimizando eficiência em aplicações como controle de aviões ou modelagem financeira de risco."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Aplicar fatores de escala limitados",
                            "description": "Limitar o fator de ajuste entre 0.2 e 5 (ou similares), aplicando h_new = max(h_min, min(h_max, h_old * factor)), para estabilidade e prevenção de passos extremos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Necessidade de Fatores de Escala Limitados",
                                  "subSteps": [
                                    "Estude o problema de passos extremos em algoritmos numéricos de integração, como explosão ou colapso do tamanho de passo h.",
                                    "Analise exemplos onde fatores de escala irrestritos (ex: factor > 10 ou < 0.1) causam instabilidade.",
                                    "Discuta o papel da fórmula h_new = max(h_min, min(h_max, h_old * factor)) para clamping.",
                                    "Identifique cenários típicos em métodos de Runge-Kutta adaptativos.",
                                    "Compare simulações com e sem limites para visualizar a diferença."
                                  ],
                                  "verification": "Resuma em um parágrafo por que limites são essenciais, citando um exemplo numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notebook Jupyter para plots simples",
                                    "Exemplos de códigos em Python/MATLAB"
                                  ],
                                  "tips": "Visualize com gráficos de h vs. iterações para intuitividade.",
                                  "learningObjective": "Explicar o impacto de fatores irrestritos na estabilidade numérica.",
                                  "commonMistakes": [
                                    "Ignorar o contexto de erro local na escolha do factor",
                                    "Confundir h_min/h_max com bounds do factor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Parâmetros de Limitação",
                                  "subSteps": [
                                    "Escolha valores típicos: factor entre 0.2 e 5, h_min = 1e-12, h_max = 1e2 (ajustar ao problema).",
                                    "Calcule h_min e h_max baseados na escala da solução (ex: norma da derivada).",
                                    "Documente os parâmetros em uma tabela: nome, valor, justificativa.",
                                    "Teste variações: o que acontece se factor_max=10?",
                                    "Crie uma função auxiliar para validar bounds."
                                  ],
                                  "verification": "Crie uma tabela com parâmetros e justifique cada escolha com uma equação ou exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Documentação de solvers como SciPy odeint"
                                  ],
                                  "tips": "Use escalas logarítmicas para h_min/h_max em problemas stiff.",
                                  "learningObjective": "Selecionar bounds apropriados para estabilidade sem sacrificar eficiência.",
                                  "commonMistakes": [
                                    "Definir h_max muito pequeno, limitando precisão global",
                                    "Usar bounds fixos sem considerar a equação diferencial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Fórmula de Ajuste Limitado",
                                  "subSteps": [
                                    "Escreva a função: def adjust_step(h_old, factor, h_min, h_max): return max(h_min, min(h_max, h_old * factor))",
                                    "Integre em um loop de solver: calcule factor baseado em erro local (ex: factor = 0.9 * (tol/err)^{1/(2p)}).",
                                    "Codifique em Python ou pseudocódigo, com logs de h_new.",
                                    "Adicione safeguards: se h_new == h_old, pare ou ajuste.",
                                    "Debugue com asserts: assert h_min <= h_new <= h_max."
                                  ],
                                  "verification": "Execute o código em um problema teste e verifique se todos h_new respeitam os bounds.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Editor de código (VSCode/Jupyter)",
                                    "Problema teste: y' = -y, y(0)=1"
                                  ],
                                  "tips": "Use np.clip para implementação vetorizada e eficiente.",
                                  "learningObjective": "Codificar corretamente o clamping para prevenção de overflows.",
                                  "commonMistakes": [
                                    "Esquecer max/min na ordem (max antes de min)",
                                    "Aplicar factor antes de bounds sem clamp"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Analisar Estabilidade",
                                  "subSteps": [
                                    "Simule uma EDO stiff (ex: y' = -50y + sin(t)) com e sem limites.",
                                    "Plote trajetórias de h(t), erro global e solução.",
                                    "Meça métricas: número de passos, tempo CPU, precisão final.",
                                    "Compare falhas: sem limites, h explode em <10 passos?",
                                    "Otimize bounds iterativamente para melhor performance."
                                  ],
                                  "verification": "Gere gráficos comparativos mostrando estabilidade com limites.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Biblioteca SciPy.integrate",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Monitore cond_number da Jacobiana para problemas stiff.",
                                  "learningObjective": "Avaliar empiricamente a melhoria na robustez do algoritmo.",
                                  "commonMistakes": [
                                    "Testar só em problemas easy, ignorando stiff",
                                    "Não logar h para diagnóstico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um solver RK4 adaptativo para y' = λy com λ=-100 (stiff), sem limites factor=0.01 leva h<1e-20 (underflow). Com limites [0.2,5], h estabiliza em 1e-3, completando simulação em 100 passos vs. falha.",
                              "finalVerifications": [
                                "Todos h_new satisfazem h_min ≤ h_new ≤ h_max em 100% das iterações.",
                                "Número de passos reduzido em >20% comparado a irrestrito sem perda de precisão.",
                                "Erro global < 1e-6 em problema teste padrão.",
                                "Código passa asserts para bounds e não under/overflow.",
                                "Gráficos mostram h oscilando suavemente sem extremos.",
                                "Simulação completa problemas stiff sem crash."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação da fórmula clamp (100% correto).",
                                "Escolha justificada de bounds (alinhada a escalas do problema).",
                                "Evidências empíricas de estabilidade via simulações comparativas.",
                                "Análise qualitativa/quantitativa de métricas (passos, erro, tempo).",
                                "Código limpo, comentado e reproduzível.",
                                "Identificação correta de erros comuns em testes."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/NumPy.",
                                "Física: Simulações de dinâmica (ex: osciladores amortecidos).",
                                "Engenharia Computacional: CFD e solvers finitos.",
                                "Estatística: Controle de variância em Monte Carlo.",
                                "Ciência de Dados: Otimização adaptativa em ML gradients."
                              ],
                              "realWorldApplication": "Em software como MATLAB ode45 ou SciPy solve_ivp, previne crashes em simulações industriais de reações químicas, aerodinâmica ou finanças (modelos Black-Scholes sensíveis), garantindo soluções robustas 24/7."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Estratégias para detecção de stiff",
                            "description": "Identificar problemas stiff pelo crescimento excessivo de rejeições e ajustar h com fatores conservadores ou alternar para métodos implícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Problemas Stiff em EDOs",
                                  "subSteps": [
                                    "Estude a definição de problemas stiff: sistemas de EDOs com escalas de tempo muito diferentes, onde componentes rápidos decaem rapidamente.",
                                    "Analise exemplos clássicos, como o oscilador amortecido com amortecimento alto (ex: y'' + 1000 y' + y = 0).",
                                    "Compare estabilidade de métodos explícitos (ex: RK4) vs. implícitos (ex: Backward Euler) em problemas stiff.",
                                    "Revise a condição de estabilidade A-stability para métodos implícitos.",
                                    "Identifique por que passos h pequenos são necessários em explícitos para stiff."
                                  ],
                                  "verification": "Resuma em um parágrafo as características de um problema stiff e dê um exemplo numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), notebook Jupyter com Python/Scipy.",
                                  "tips": "Visualize com plots de solução exata vs. numérica para diferentes h.",
                                  "learningObjective": "Definir e exemplificar problemas stiff e suas implicações em métodos numéricos.",
                                  "commonMistakes": "Confundir stiff com não-linearidade; ignorar análise de estabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Problemas Stiff pelo Crescimento Excessivo de Rejeições",
                                  "subSteps": [
                                    "Implemente um solver adaptativo simples (ex: RK4 com controle de erro local).",
                                    "Monitore métricas: número de rejeições de passo, fator de redução de h médio.",
                                    "Defina thresholds: >20% rejeições ou h reduzido abaixo de 1% do inicial como sinal de stiff.",
                                    "Teste em EDOs não-stiff vs. stiff e compare gráficos de h vs. t.",
                                    "Registre logs de rejeições durante a integração."
                                  ],
                                  "verification": "Execute simulação em EDO stiff e produza gráfico mostrando pico de rejeições.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy/Matplotlib, EDO de teste stiff (ex: van der Pol com μ=1000).",
                                  "tips": "Use contadores de rejeições no loop do solver para automação.",
                                  "learningObjective": "Implementar detecção quantitativa de stiff via monitoramento de rejeições.",
                                  "commonMistakes": "Definir thresholds muito rígidos; não normalizar rejeições por tempo de integração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar o Tamanho do Passo h com Fatores Conservadores",
                                  "subSteps": [
                                    "Implemente fatores de escala conservadores: reduza h por φ = 0.5-0.8 em rejeições consecutivas.",
                                    "Aplique escalonamento múltiplo: h_new = h_old * φ^k onde k é número de rejeições seguidas.",
                                    "Teste em solver adaptativo: integre até convergência ou limite de rejeições.",
                                    "Avalie eficiência: compare tempo computacional com detecção precoce.",
                                    "Ajuste φ baseado em testes empíricos para diferentes graus de stiff."
                                  ],
                                  "verification": "Simule EDO stiff, aplique ajuste e verifique redução de rejeições em >50%.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python customizado para solver com logs de h e rejeições.",
                                  "tips": "Comece com φ=0.7 e refine iterativamente.",
                                  "learningObjective": "Desenvolver estratégias de ajuste conservador para mitigar stiff temporariamente.",
                                  "commonMistakes": "Usar fatores muito agressivos levando a h=0; ignorar recuperação após estabilização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Alternar para Métodos Implícitos em Casos Persistentes",
                                  "subSteps": [
                                    "Implemente um método implícito simples (ex: Backward Euler ou Trapezoidal).",
                                    "Defina critério de switch: >50 rejeições ou h < 0.01*h_initial.",
                                    "Resolva sistemas lineares por Jacobiano aproximado ou fixed-point iteration.",
                                    "Compare soluções e eficiência entre explícito ajustado vs. implícito.",
                                    "Documente o switch em logs e valide com solução de referência."
                                  ],
                                  "verification": "Execute hibrido solver em EDO stiff e confirme solução precisa com tempo razoável.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "SciPy solve_ivp com method='BDF', código custom para hibrido.",
                                  "tips": "Use fsolve ou Newton para não-linearidades implícitas.",
                                  "learningObjective": "Implementar transição suave para métodos implícitos em stiff detectado.",
                                  "commonMistakes": "Não convergência em iterações implícitas; switch prematuro em não-stiff."
                                }
                              ],
                              "practicalExample": "Considere a EDO stiff y' = -1000(y - sin(t)) + cos(t), y(0)=1. Use RK45 adaptativo: observe rejeições explodindo após t=0.1 com h caindo para 1e-5. Aplique detecção (>30 rejeições), ajuste h com φ=0.6^3, reduza rejeições temporariamente, mas switch para BDF após 50 rejeições, obtendo solução precisa em 10x menos passos.",
                              "finalVerifications": [
                                "O solver detecta stiff com acurácia >90% em 5 EDOs teste.",
                                "Ajustes conservadores reduzem rejeições em pelo menos 40% antes do switch.",
                                "Solução implícita converge com erro <1e-6 vs. referência.",
                                "Tempo total de integração <2x o de solver fixo não-stiff.",
                                "Logs mostram thresholds acionados corretamente.",
                                "Gráficos de h(t) e rejeições(t) exibem padrões stiff claros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: thresholds bem calibrados e sem falsos positivos.",
                                "Eficiência do ajuste: redução mensurável de rejeições sem perda de precisão.",
                                "Implementação correta de implícitos: convergência em <10 iterações por passo.",
                                "Análise comparativa: métricas de erro e CPU vs. baselines.",
                                "Documentação: código comentado e relatório com plots.",
                                "Generalização: funciona em 3+ EDOs stiff variados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RC stiff em eletrônica.",
                                "Química: Simulação de reações em série com escalas rápidas/lentas.",
                                "Programação: Otimização numérica em SciPy e controle de exceções.",
                                "Engenharia: Controle de sistemas dinâmicos com amortecimento alto."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica veicular (freios ABS com stiff devido a atrito), detecção de stiff permite switch para implícitos, evitando crashes numéricos e permitindo previsões precisas de estabilidade em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Critérios de Aceitação e Rejeição de Passos",
                    "description": "Condições para aceitar ou rejeitar um passo e retomar com novo h, considerando tolerâncias locais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Tolerâncias Locais",
                        "description": "Definição e cálculo das tolerâncias locais usadas para avaliar a precisão de um passo em métodos numéricos de solução de problemas de valor inicial, considerando normas como escalar ou vetor de erros.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Definir tolerância local",
                            "description": "Explicar o conceito de tolerância local (tol) como um limite de erro admissível para cada passo, diferenciando de tolerâncias globais, e sua relação com a precisão desejada no método de Runge-Kutta ou similar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito geral de tolerância em métodos numéricos",
                                  "subSteps": [
                                    "Estude a definição de erro numérico em métodos de integração de EDOs.",
                                    "Identifique por que limites de erro são necessários para controlar a precisão.",
                                    "Revise exemplos de erros locais e globais em métodos iterativos.",
                                    "Analise como a tolerância afeta o custo computacional.",
                                    "Discuta a importância da tolerância para estabilidade numérica."
                                  ],
                                  "verification": "Explique em suas palavras o papel da tolerância em análise numérica e liste dois exemplos de consequências de tolerâncias inadequadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (capítulo de métodos de Runge-Kutta)",
                                    "Notas de aula sobre erros numéricos",
                                    "Calculadora ou software como Python/MATLAB"
                                  ],
                                  "tips": "Comece com exemplos simples de EDOs lineares para visualizar o impacto do erro.",
                                  "learningObjective": "Entender o conceito fundamental de tolerância como limite de erro admissível em computação numérica.",
                                  "commonMistakes": [
                                    "Confundir tolerância com precisão absoluta da máquina",
                                    "Ignorar o trade-off entre precisão e tempo de computação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e caracterizar a tolerância local (tol)",
                                  "subSteps": [
                                    "Defina tolerância local como o limite de erro admissível para cada passo individual de integração.",
                                    "Descreva como tol é aplicada no teste de aceitação de um passo em métodos adaptativos.",
                                    "Estude a fórmula típica: |y_{n+1} - y_n^{pred}| ≤ tol * (1 + |y_n|).",
                                    "Explique que tol controla o erro incremental por passo.",
                                    "Pratique calculando tol para um passo hipotético."
                                  ],
                                  "verification": "Escreva a definição de tol local e compute um exemplo simples de verificação de erro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de fórmulas de Runge-Kutta",
                                    "Exemplos resolvidos de EDOs",
                                    "Planilha Excel ou Python para cálculos"
                                  ],
                                  "tips": "Use a norma escalar ou vetorial adequada dependendo se y é escalar ou vetor.",
                                  "learningObjective": "Saber definir precisamente a tolerância local e sua aplicação em um passo de integração.",
                                  "commonMistakes": [
                                    "Usar tol absoluta sem normalização relativa",
                                    "Aplicar tol ao erro global em vez de local"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar tolerância local de tolerância global",
                                  "subSteps": [
                                    "Defina tolerância global como limite para o erro total acumulado ao final da integração.",
                                    "Compare: tol local controla por passo, tol global controla o resultado final.",
                                    "Discuta relações empíricas: tol_local ≈ tol_global / sqrt(N), onde N é número de passos.",
                                    "Analise cenários onde tol local frouxa leva a erro global grande.",
                                    "Crie uma tabela comparativa de características."
                                  ],
                                  "verification": "Crie uma tabela ou diagrama destacando 4 diferenças chave entre tol local e global.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigos ou slides sobre controle de erro em ODE solvers",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Pense em tol local como 'micro-erros' que somam para o 'macro-erro' global.",
                                  "learningObjective": "Distinguir claramente tolerâncias local e global, com exemplos de impactos.",
                                  "commonMistakes": [
                                    "Achar que tol local e global são intercambiáveis",
                                    "Subestimar acumulação de erros locais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar tolerância local com precisão desejada em Runge-Kutta",
                                  "subSteps": [
                                    "Revise o algoritmo de Runge-Kutta de ordem 4 com controle de passo.",
                                    "Explique como tol local é usada no estimador de erro embutido (ex: RK45).",
                                    "Discuta escolha de tol baseada na precisão desejada: tol_local < tol_global / N.",
                                    "Simule ajuste de tol para alcançar precisão alvo em uma EDO teste.",
                                    "Avalie impacto no número de passos e tempo de CPU."
                                  ],
                                  "verification": "Implemente um pseudocódigo ou código simples mostrando uso de tol em Runge-Kutta e teste com valores variados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código-fonte de solvers ODE em Python (scipy.integrate)",
                                    "EDO teste: y' = -y, y(0)=1"
                                  ],
                                  "tips": "Comece com tol = 1e-6 e ajuste iterativamente para observar efeitos.",
                                  "learningObjective": "Aplicar tol local para controlar precisão em métodos como Runge-Kutta.",
                                  "commonMistakes": [
                                    "Definir tol muito pequena levando a lentidão excessiva",
                                    "Ignorar dependência em h (passo inicial)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a EDO y' = y, y(0)=1, resolvida por Runge-Kutta 4 até t=1. Defina tol_local = 1e-6. No passo n=1, com h=0.1, compute y1 ≈ 1.105170918. Estimador de erro local: |erro| ≈ 1.2e-7 > tol? Não, aceite passo. Se tol=1e-8, rejeite e reduza h, ilustrando controle local para precisão global.",
                              "finalVerifications": [
                                "Explicar tol local em termos de limite por passo.",
                                "Diferenciar tol local de global com pelo menos 3 pontos.",
                                "Relacionar tol com precisão em Runge-Kutta via exemplo numérico.",
                                "Calcular corretamente verificação de erro local em um passo dado.",
                                "Discutir trade-offs de tol pequena vs grande.",
                                "Identificar quando ajustar tol baseado em N passos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de tol local (sem confusão com global).",
                                "Clareza na diferenciação local vs global, com fórmulas ou exemplos.",
                                "Correta relação com métodos adaptativos como Runge-Kutta.",
                                "Uso apropriado de normalização relativa/absoluta.",
                                "Demonstração de impacto prático via simulação ou cálculo.",
                                "Profundidade em trade-offs computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar controle de tol em solvers ODE com Python/Scipy.",
                                "Física: Aplicar em simulações de movimento orbital com erros controlados.",
                                "Engenharia: Otimização de precisão em simulações CFD ou controle de sistemas.",
                                "Estatística: Análise de incerteza em métodos Monte Carlo numéricos."
                              ],
                              "realWorldApplication": "Em simulações de previsão meteorológica ou trajetórias de foguetes, definir tol local garante precisão global sem computação excessiva, evitando erros catastróficos como desvios em lançamentos espaciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Calcular norma do erro estimado",
                            "description": "Computar a norma do erro local estimado (ex: ||e|| = max(|e_i| / tol_i) ou RMS) comparando solução com passo h e estimativa de erro via fórmula de Richardson ou embedded methods.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Soluções Numéricas e Estimativas de Erro",
                                  "subSteps": [
                                    "Obtenha a solução aproximada y_h usando passo h com método numérico (ex: Runge-Kutta).",
                                    "Calcule a solução y_{2h} com passo dobrado h*2 ou use solução de ordem inferior em métodos embedded.",
                                    "Identifique os componentes locais de erro e_i para cada variável ou ponto no tempo.",
                                    "Registre tolerâncias locais tol_i fornecidas ou derivadas do usuário (ex: tol_i = tol * scale_i).",
                                    "Verifique consistência das soluções obtidas."
                                  ],
                                  "verification": "Confirme que y_h, y_{2h} (ou y_low) e tol_i estão corretamente computados e documentados.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta para cálculos manuais",
                                    "Software como Python (SciPy odeint) ou MATLAB",
                                    "Exemplo de EDO simples como y' = -y"
                                  ],
                                  "tips": [
                                    "Use passos pequenos iniciais para precisão; armazene soluções em tabela para comparação fácil."
                                  ],
                                  "learningObjective": "Compreender como obter candidatas a soluções para estimativa de erro via extrapolação ou embedded.",
                                  "commonMistakes": [
                                    "Confundir y_h com y_{2h}",
                                    "Ignorar escalas relativas nas tolerâncias",
                                    "Usar passos muito grandes levando a instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Fórmula de Estimativa de Erro Local",
                                  "subSteps": [
                                    "Para fórmula de Richardson (ordem p): calcule e = (y_h - y_{2h}) / (2^p - 1).",
                                    "Para métodos embedded (ex: RK45): e_i = |y_h,i - y_low,i| para cada componente i.",
                                    "Aplique a fórmula componente a componente para sistemas de EDOs.",
                                    "Considere erros absolutos ou relativos baseados no contexto.",
                                    "Salve os valores e_i em uma lista ou vetor."
                                  ],
                                  "verification": "Reproduza o cálculo manualmente e compare com implementação numérica; erro deve coincidir em 3 casas decimais.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou Jupyter Notebook para vetores",
                                    "Documentação do método numérico usado"
                                  ],
                                  "tips": [
                                    "Lembre-se: p=4 para RK4 clássico; ajuste para ordem do método.",
                                    "Para sistemas, vetorize os cálculos."
                                  ],
                                  "learningObjective": "Dominar a aplicação precisa da fórmula de Richardson ou embedded para erro local.",
                                  "commonMistakes": [
                                    "Esquecer o denominador (2^p -1)",
                                    "Usar ordem errada p",
                                    "Aplicar fórmula escalar a vetores sem componente"
                                  ]
                                },
                                {
                                  "stepNumber": "3",
                                  "title": "Definir e Normalizar Erros pelas Tolerâncias Locais",
                                  "subSteps": [
                                    "Liste todas as tolerâncias locais tol_i para cada variável ou grau de liberdade.",
                                    "Calcule os erros normalizados: e_norm_i = |e_i| / tol_i para cada i.",
                                    "Identifique o máximo e_norm_i se usando norma infinito, ou prepare para RMS.",
                                    "Verifique se tol_i são consistentes (ex: tol_abs + tol_rel * |y_i|).",
                                    "Documente todos e_norm_i em tabela."
                                  ],
                                  "verification": "Todos e_norm_i devem ser positivos e dimensionados corretamente; some-os para checagem.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Tabela em papel ou Google Sheets",
                                    "Valores de y_h e e_i do passo anterior"
                                  ],
                                  "tips": [
                                    "Tolerâncias muito pequenas causam rejeições excessivas; equilibre com precisão desejada."
                                  ],
                                  "learningObjective": "Saber normalizar erros locais considerando tolerâncias específicas por componente.",
                                  "commonMistakes": [
                                    "Dividir por tol global em vez de local",
                                    "Usar e_i sem módulo absoluto",
                                    "Ignorar componentes zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar a Norma do Erro Estimado e Interpretar",
                                  "subSteps": [
                                    "Para norma infinito: ||e|| = max(e_norm_i) sobre todos i.",
                                    "Para RMS: ||e|| = sqrt( (1/n) * sum(e_norm_i^2) ).",
                                    "Compare ||e|| com 1: se <1 aceitar passo, senão rejeitar e reduzir h.",
                                    "Registre a norma final e decisão de aceitação/rejeição.",
                                    "Teste sensibilidade variando tol_i."
                                  ],
                                  "verification": "Implemente em código simples e rode exemplo; norma deve matching cálculo manual.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Python/MATLAB para função max/sqrt/mean",
                                    "Exemplo completo de passos anteriores"
                                  ],
                                  "tips": [
                                    "Norma infinito é conservadora; RMS tolera erros localizados.",
                                    "Log sempre ||e|| para análise de convergência."
                                  ],
                                  "learningObjective": "Calcular corretamente normas comuns de erro e usá-las em critérios de controle de passo.",
                                  "commonMistakes": [
                                    "Confundir max com média",
                                    "Esquecer raiz em RMS",
                                    "Aceitar ||e|| >1 sem reduzir h"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = y*(1-y), y(0)=0.5 (equação logística) com RK4, h=0.1 e h=0.2 até t=1. Use p=4 na Richardson: e ≈ (y_{0.1} - y_{0.2}) / 15. Tol_i=1e-6. Calcule e_i em t=1, e_norm_i = |e_i|/1e-6, ||e||_∞ = max(e_norm_i) ≈ 0.8 <1 → aceitar.",
                              "finalVerifications": [
                                "Explica diferença entre Richardson e embedded.",
                                "Calcula ||e|| corretamente para exemplo dado.",
                                "Implementa norma em pseudocódigo.",
                                "Identifica quando usar max vs RMS.",
                                "Aplica critério de aceitação em novo problema.",
                                "Discute impacto de tol_i erradas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na estimativa de e_i (erro <1%).",
                                "Correta normalização por tol_i locais.",
                                "Escolha apropriada de norma (∞ ou RMS).",
                                "Interpretação correta para aceitação/rejeição.",
                                "Documentação clara de cálculos.",
                                "Tratamento robusto de sistemas multi-componente."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (scipy.integrate) com controle adaptativo.",
                                "Física: Erro em simulações de dinâmica (ex: osciladores).",
                                "Estatística: Métricas de erro e normas L2/L∞.",
                                "Engenharia: Otimização de solvers em CFD ou circuitos."
                              ],
                              "realWorldApplication": "Em solvers adaptativos como MATLAB ode45 ou SciPy solve_ivp, controla precisão em simulações de trajetórias espaciais, previsão climática ou modelagem farmacocinética, evitando desperdício computacional e garantindo resultados confiáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Aplicar tolerâncias em métodos embedded",
                            "description": "Utilizar pares de métodos Runge-Kutta embedded (ex: Dormand-Prince) para estimar erro local e compará-lo diretamente com a tolerância local escalar ou por componente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura de métodos Runge-Kutta embedded",
                                  "subSteps": [
                                    "Estude a Butcher tableau para o método Dormand-Prince (RK45), identificando os coeficientes a_ij, b_i^{(4)} e b_i^{(5)} para ordens 4 e 5.",
                                    "Explique como o método computa duas aproximações y_n^{(4)} e y_n^{(5)} simultaneamente com k estágios.",
                                    "Identifique a fórmula de estimativa de erro local: e_n = |y_n^{(5)} - y_n^{(4)}| / (ordem superior - 1), tipicamente e_n ≈ |y_n^{(5)} - y_n^{(4)}|.",
                                    "Revise conceitos de tolerância local: escalar (atol + rtol * |y|) vs. por componente.",
                                    "Anote diferenças entre métodos embedded e não-embedded."
                                  ],
                                  "verification": "Resuma em um diagrama ou tabela os coeficientes chave do Dormand-Prince e formule a estimativa de erro corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação do método Dormand-Prince (ex: PDF de Numerical Recipes ou SciPy source), caderno para anotações.",
                                  "tips": "Use visualizações de Butcher tableau online para fixar os coeficientes.",
                                  "learningObjective": "Dominar a mecânica interna de métodos RK embedded para estimativa de erro.",
                                  "commonMistakes": "Confundir ordens das aproximações (5 é mais precisa que 4); ignorar normalização na estimativa de erro."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o cálculo das aproximações candidatas",
                                  "subSteps": [
                                    "Escreva código para computar os k_i increments usando y_{n+1}^{(p)} = y_n + h * sum b_i^{(p)} k_i para p=4,5.",
                                    "Inicialize k_1 = f(t_n, y_n), e itere k_i = f(t_n + c_i h, y_n + h sum a_{ij} k_j).",
                                    "Calcule y_n^{(5)} como solução candidata principal e y_n^{(4)} para erro.",
                                    "Teste com EDO simples: y' = -y, y(0)=1, h inicial=0.1.",
                                    "Valide saídas numéricas contra solução exata."
                                  ],
                                  "verification": "Execute código e confirme que y_n^{(5)} e y_n^{(4)} convergem para solução conhecida em poucos passos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy, editor de código (Jupyter Notebook), EDO teste y'=-y.",
                                  "tips": "Implemente Butcher tableau como arrays 2D para reutilização.",
                                  "learningObjective": "Implementar eficientemente os estágios RK para embedded methods.",
                                  "commonMistakes": "Erros de indexação em Butcher tableau; usar h errado em k_i."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar e normalizar o erro local",
                                  "subSteps": [
                                    "Calcule erro bruto: err = |y_n^{(5)} - y_n^{(4)}| componente a componente.",
                                    "Defina tolerância local: tol_i = atol + rtol * max(|y_n^{(5)}_i|, |y_n^{(4)}_i|) para cada componente i.",
                                    "Para escalar: tol = atol + rtol * ||y|| (norma L2 ou inf).",
                                    "Compute erro escalar: sc_err = ||err|| / tol.",
                                    "Registre valores para análise."
                                  ],
                                  "verification": "Para EDO teste, confirme sc_err < 1 quando passo é aceitável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código do Step 2 estendido, parâmetros atol=1e-6, rtol=1e-3.",
                                  "tips": "Use np.maximum para tol por componente eficientemente.",
                                  "learningObjective": "Calcular estimativas de erro normalizadas corretamente.",
                                  "commonMistakes": "Usar y_n em vez de y_n^{(5)} para tol; esquecer normalização por componente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar critério de aceitação/rejeição e ajustar passo",
                                  "subSteps": [
                                    "Aceite passo se sc_err <= 1 (ou max(err_i / tol_i) <=1 para componente).",
                                    "Se rejeitado, reduza h_new = 0.8 * h * (1/sc_err)^{1/(ordem+1)}, ordem=5.",
                                    "Se aceito, aumente h_new = 0.9 * h * (1/sc_err)^{1/(ordem+1)}, capado em 5x.",
                                    "Atualize t_n += h, y_n = y_n^{(5)}, repita.",
                                    "Simule até t_final e plote solução vs. exata."
                                  ],
                                  "verification": "Solução numérica converge com erro global ~1e-6; h adapta dinamicamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código completo em loop adaptativo, plotador (Matplotlib).",
                                  "tips": "Implemente safety factor 0.9 para evitar oscilações em h.",
                                  "learningObjective": "Integrar controle de tolerância em solver adaptativo.",
                                  "commonMistakes": "Exponte errada no ajuste de h; não capar aumento de h."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar a implementação",
                                  "subSteps": [
                                    "Teste com EDO rígida: y' = -100y + sin(t), compare com solver fixo.",
                                    "Meça eficiência: número de passos vs. erro global.",
                                    "Ajuste atol/rtol e observe impacto em precisão vs. custo.",
                                    "Profile código para gargalos (ex: função f).",
                                    "Documente thresholds para rejeição múltipla (ex: rejeitar 3x -> falha)."
                                  ],
                                  "verification": "Erro global < tol * (t_final/t0)^{1/2}; runtime razoável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "EDOs teste variadas, timer Python (timeit).",
                                  "tips": "Vectorize f se possível para speed-up.",
                                  "learningObjective": "Avaliar robustez do controle de tolerância em cenários reais.",
                                  "commonMistakes": "Ignorar rigidez levando a muitos passos pequenos; atol muito pequeno."
                                }
                              ],
                              "practicalExample": "Resolva y' = y*(1-y), y(0)=0.1 até t=5 com atol=1e-8, rtol=1e-6 usando Dormand-Prince. Observe h crescendo de 0.01 para ~0.5, erro estimado sempre <1, solução convergindo para sigmoid logística exata.",
                              "finalVerifications": [
                                "Estimativa de erro local sc_err <=1 para todos passos aceitos.",
                                "Ajuste de h resulta em passos eficientes (nem muito pequenos nem grandes).",
                                "Erro global na solução final < rtol * escala da solução.",
                                "Código roda sem rejeições excessivas (>50% rejeitadas sinaliza problema).",
                                "Comparação com SciPy.solve_ivp(method='DOP853') mostra concordância.",
                                "Tolerância por componente detecta erros seletivos em sistemas multi-D."
                              ],
                              "assessmentCriteria": [
                                "Corretude da Butcher tableau e estimativa de erro (teste unitário passa).",
                                "Implementação eficiente de tol escalar/componente (erro <1e-10 em casos teste).",
                                "Ajuste adaptativo de h segue fórmula padrão com factors de segurança.",
                                "Robustez em EDOs não-lineares/rígidas (convergência em <1000 passos).",
                                "Documentação clara no código com comentários em fórmulas chave.",
                                "Uso apropriado de normas (L2 ou inf) para escalar."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Otimização numérica e profiling em Python/NumPy.",
                                "Física: Simulações dinâmicas (ex: movimento orbital com perturbações).",
                                "Engenharia: Controle de processos (ODEs em termodinâmica).",
                                "Estatística: Análise de erro em modelagem probabilística."
                              ],
                              "realWorldApplication": "Em simulações climáticas (ODEs para fluidos), farmacocinética (modelos PK/PD com tolerâncias para precisão em picos), ou controle de voo em aviões (garantir estabilidade numérica em tempo real)."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Critérios de Aceitação de Passos",
                        "description": "Condições sob as quais um passo com tamanho h é considerado aceitável, permitindo avançar para o próximo ponto e possivelmente aumentar h para eficiência computacional.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Verificar condição de aceitação",
                            "description": "Determinar se um passo é aceito quando a norma do erro estimado é menor que 1 (||e|| < 1), avançando y_{n+1} = y_h e registrando sucesso para ajuste futuro de h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recuperar a norma do erro estimado do passo atual",
                                  "subSteps": [
                                    "Identifique o valor de y_h calculado pelo método de passo (ex: Runge-Kutta de ordem alta).",
                                    "Obtenha y_l do método de ordem baixa ou estimativa de erro.",
                                    "Calcule a norma do erro estimado ||e|| = ||y_h - y_l|| / tol ou fórmula específica do método.",
                                    "Armazene ||e|| em uma variável ou registro temporário.",
                                    "Confirme que a norma está na escala correta (ex: norma euclidiana ou máxima)."
                                  ],
                                  "verification": "Verifique se ||e|| foi calculado corretamente comparando com valor manual ou output de software.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código ou planilha com y_h e y_l",
                                    "Calculadora científica",
                                    "Documentação do método numérico"
                                  ],
                                  "tips": "Use funções prontas em MATLAB/Python (ex: ode45) para validar manualmente.",
                                  "learningObjective": "Compreender como extrair e interpretar a norma do erro em métodos adaptativos.",
                                  "commonMistakes": [
                                    "Confundir y_h com y_l",
                                    "Usar norma errada (L1 vs L2)",
                                    "Ignorar tolerância de escala"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a condição de aceitação ||e|| < 1",
                                  "subSteps": [
                                    "Compare o valor numérico de ||e|| com o limiar 1.",
                                    "Se ||e|| < 1, marque como 'aceito'; caso contrário, prepare para rejeição (próximo contexto).",
                                    "Registre o resultado booleano (true/false) em log ou variável.",
                                    "Considere tolerâncias numéricas mínimas (ex: 1e-12) para evitar falsos negativos.",
                                    "Documente o valor exato de ||e|| para análise posterior."
                                  ],
                                  "verification": "Teste com valores conhecidos: ||e||=0.5 (aceito), ||e||=1.2 (rejeitado).",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e caneta para comparação manual",
                                    "Software de programação (Python/MATLAB)"
                                  ],
                                  "tips": "Implemente como if-statement simples: if norm_e < 1: accept = True.",
                                  "learningObjective": "Dominar a lógica condicional para critérios de aceitação em análise numérica.",
                                  "commonMistakes": [
                                    "Usar >1 em vez de <1",
                                    "Arredondar prematuramente ||e||",
                                    "Ignorar precisão de ponto flutuante"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar ações de aceitação do passo",
                                  "subSteps": [
                                    "Atribua y_{n+1} = y_h como aproximação aceita.",
                                    "Avance o índice n para n+1.",
                                    "Atualize o passo h para o próximo (preparar ajuste futuro).",
                                    "Salve y_{n+1} em array de solução.",
                                    "Confirme integração com rotina de controle de passo."
                                  ],
                                  "verification": "Verifique se y_{n+1} equals y_h e n incrementou corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplo de EDO como y' = -y, y(0)=1"
                                  ],
                                  "tips": "Use print/debug para rastrear atribuições.",
                                  "learningObjective": "Aplicar atualização de solução quando critério é satisfeito.",
                                  "commonMistakes": [
                                    "Atribuir y_l em vez de y_h",
                                    "Não avançar n",
                                    "Perder dados em loop"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Registrar sucesso para ajuste futuro de h",
                                  "subSteps": [
                                    "Incremente contador de sucessos (ex: success_count += 1).",
                                    "Calcule fator de ajuste de h (ex: h_next = h * min(1.2, 1/||e||^0.2)).",
                                    "Armazene em estrutura de controle (flags, logs).",
                                    "Prepare para decisão de próximo h baseado em histórico.",
                                    "Teste o registro em iterações múltiplas."
                                  ],
                                  "verification": "Simule 3 passos: contador deve aumentar apenas em aceitos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo de solver adaptativo",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Mantenha contadores separados para aceito/rejeitado.",
                                  "learningObjective": "Integrar registro para controle adaptativo de tamanho de passo.",
                                  "commonMistakes": [
                                    "Incrementar em rejeições",
                                    "Fórmula errada de ajuste",
                                    "Overflow em contadores"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um solver para y' = y, y(0)=1 com h=0.1: Após passo, y_h=1.10517, y_l=1.10000, ||e||=0.00517 <1 → Aceitar y_1=1.10517, success_count=1, h_next=0.12.",
                              "finalVerifications": [
                                "||e|| corretamente comparado com 1 e condição avaliada.",
                                "y_{n+1} definido como y_h apenas se aceito.",
                                "Contador de sucessos incrementado.",
                                "Ajuste de h preparado corretamente.",
                                "Solução avançada sem perda de dados.",
                                "Log registra aceitação explicitamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na avaliação booleana (100% correto em 5 testes).",
                                "Correta atribuição de y_{n+1} em cenários aceitos.",
                                "Implementação de registro de sucesso sem erros.",
                                "Integração fluida em loop de solver.",
                                "Explicação verbal do processo.",
                                "Tratamento de casos limite (||e||≈1)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de condicionais e loops em Python/MATLAB.",
                                "Estatística: Interpretação de normas de erro como medidas de incerteza.",
                                "Física: Controle de precisão em simulações dinâmicas (ex: trajetórias).",
                                "Ciência da Computação: Algoritmos adaptativos e eficiência computacional."
                              ],
                              "realWorldApplication": "Em solvers numéricos de EDOs para modelagem climática ou farmacocinética, garante precisão adaptativa sem desperdício computacional, ajustando h automaticamente para equilibrar erro e velocidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Ajustar h após aceitação",
                            "description": "Calcular novo h aceito usando fórmula h_new = h * (tol / ||e||)^{1/(p+1)} * f_segurança, onde p é a ordem do método, limitando crescimento para estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os componentes da fórmula de ajuste de h",
                                  "subSteps": [
                                    "Identifique tol como a tolerância desejada para o erro.",
                                    "Revise ||e|| como a norma do erro estimado no passo atual.",
                                    "Defina p como a ordem do método numérico (ex: p=4 para RK4).",
                                    "Explique f_segurança como fator típico de 0.9 para conservadorismo.",
                                    "Discuta limites de crescimento, como máximo 5x h atual."
                                  ],
                                  "verification": "Liste corretamente todos os componentes com definições precisas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Folha de papel, calculadora, notas de aula sobre métodos numéricos.",
                                  "tips": "Memorize a fórmula anotando-a com símbolos explicados.",
                                  "learningObjective": "Compreender o significado e papel de cada parâmetro na fórmula.",
                                  "commonMistakes": "Confundir p com a ordem global vs local do método."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o fator de ampliação (tol / ||e||)^{1/(p+1)}",
                                  "subSteps": [
                                    "Calcule a razão tol / ||e||.",
                                    "Eleve a razão à potência 1/(p+1).",
                                    "Use logaritmos se necessário para evitar underflow em calculadoras.",
                                    "Arredonde para precisão numérica adequada (ex: 4 casas decimais).",
                                    "Interprete: >1 indica h pode crescer, <1 indica redução."
                                  ],
                                  "verification": "Resultado do fator bate com cálculo manual ou software.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora científica ou Python/MATLAB para potência.",
                                  "tips": "Teste com valores extremos: ||e|| muito pequeno ou grande.",
                                  "learningObjective": "Dominar o cálculo do fator de escalonamento do passo.",
                                  "commonMistakes": "Erro na potência: usar p ao invés de p+1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a fórmula completa para h_new",
                                  "subSteps": [
                                    "Multiplique h atual pelo fator calculado.",
                                    "Incorpore f_segurança multiplicando por 0.9 (ou valor similar).",
                                    "Aplique limite superior: h_new = min(h_new, 5*h).",
                                    "Aplique limite inferior: h_new = max(h_new, 0.1*h).",
                                    "Registre h_new e compare com h original."
                                  ],
                                  "verification": "h_new satisfaz tol e limites de estabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha Excel ou script Python simples.",
                                  "tips": "Sempre aplique f_segurança para evitar oscilações.",
                                  "learningObjective": "Executar o ajuste completo mantendo estabilidade.",
                                  "commonMistakes": "Esquecer limites, causando passos explosivos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar o ajuste em um contexto de integração numérica",
                                  "subSteps": [
                                    "Integre um passo teste com h e h_new.",
                                    "Compare erros estimados nos dois passos.",
                                    "Confirme que erro com h_new está dentro de tol.",
                                    "Ajuste iterativamente se necessário.",
                                    "Documente o processo em um relatório curto."
                                  ],
                                  "verification": "Erro no novo passo < tol e h_new é estável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software numérico (Python com SciPy ou MATLAB).",
                                  "tips": "Use EDO simples como y' = -y para testes rápidos.",
                                  "learningObjective": "Aplicar o ajuste em simulação real e validar.",
                                  "commonMistakes": "Não testar o novo h, assumindo fórmula perfeita."
                                }
                              ],
                              "practicalExample": "Para y' = y, y(0)=1, h=0.1, ||e||=1e-4, tol=1e-6, p=4, f_segurança=0.9: fator=(1e-6/1e-4)^{1/5}=0.1^{0.2}≈0.631, h_new=0.1*0.631*0.9≈0.0568 (limitado <0.5).",
                              "finalVerifications": [
                                "h_new calculado corretamente pela fórmula.",
                                "Fator de segurança aplicado (ex: 0.9).",
                                "Limites de crescimento respeitados (máx 5x).",
                                "Erro estimado com h_new dentro de tol.",
                                "h_new promove convergência estável.",
                                "Documentação inclui todos os valores intermediários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula: erro <1% no h_new.",
                                "Correta interpretação de ||e|| e tol.",
                                "Aplicação consistente de limites e f_segurança.",
                                "Validação prática com exemplo numérico.",
                                "Explicação clara de estabilidade.",
                                "Eficiência: tempo de computação reduzido."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em algoritmos adaptativos (Python/NumPy).",
                                "Física: Simulações dinâmicas (ex: movimento orbital).",
                                "Engenharia: Otimização em CFD (dinâmica de fluidos).",
                                "Estatística: Controle de erro em Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas, ajusta h para balancear precisão e velocidade em previsões de tempestades, evitando instabilidades em modelos de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Critérios de Rejeição e Retomada",
                        "description": "Condições para rejeitar um passo com h atual, recalculando com h reduzido, garantindo que o erro local não exceda a tolerância.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Identificar rejeição de passo",
                            "description": "Reconhecer rejeição quando ||e|| >= 1, descartando y_h e mantendo y_n para recomputar o passo com h reduzido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Aproximação e Erro Estimado",
                                  "subSteps": [
                                    "Lembre-se da notação: y_n é a aproximação no passo n, y_h é a solução tentada com passo h.",
                                    "Entenda o erro estimado ||e|| como a norma do erro local, calculado via métodos embedded (ex: RK4(5)).",
                                    "Revise como ||e|| é computado: ||e|| = ||y_h - y_{h/2}|| ou fórmula específica do método.",
                                    "Pratique calcular ||e|| para um exemplo simples: y' = -y, y(0)=1, h=0.1.",
                                    "Discuta tolerância: tipicamente ||e|| < 1 para aceitação (unidade normalizada)."
                                  ],
                                  "verification": "Calcule ||e|| corretamente para um problema dado e compare com valor esperado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e calculadora",
                                    "Software como Python com SciPy para verificação opcional"
                                  ],
                                  "tips": "Sempre normalize o erro pela escala da solução para interpretação consistente.",
                                  "learningObjective": "Compreender os componentes que levam ao cálculo de ||e|| e sua interpretação.",
                                  "commonMistakes": [
                                    "Confundir y_h com y_n",
                                    "Esquecer de usar norma vetorial para sistemas",
                                    "Ignorar normalização do erro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Condição de Rejeição",
                                  "subSteps": [
                                    "Estude a regra: rejeição ocorre quando ||e|| >= 1.",
                                    "Compare com aceitação: ||e|| < 1 aceita y_h como y_{n+1}.",
                                    "Analise por que >=1: garante precisão mínima, evita acúmulo de erro.",
                                    "Pratique com tabela: liste ||e|| valores e classifique aceita/rejeita.",
                                    "Discuta impacto: rejeição previne passos ruins em regiões instáveis."
                                  ],
                                  "verification": "Classifique corretamente 5 casos de ||e|| como rejeitados ou aceitos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de exemplos impressa ou digital"
                                  ],
                                  "tips": "Lembre: 1 é o limiar normalizado; ajuste tol se necessário em contextos reais.",
                                  "learningObjective": "Reconhecer precisamente quando ||e|| >=1 sinaliza rejeição.",
                                  "commonMistakes": [
                                    "Usar >1 em vez de >=1",
                                    "Confundir com critério global de erro",
                                    "Ignorar dependência do método numérico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Procedimentos de Rejeição",
                                  "subSteps": [
                                    "Ao detectar ||e|| >=1: descarte y_h completamente.",
                                    "Mantenha y_n como ponto de partida válido.",
                                    "Reduza h: tipicamente h_new = h * 0.5 ou h * (tol/||e||)^{1/p} onde p=ordem.",
                                    "Recompute o passo com h reduzido a partir de y_n.",
                                    "Registre rejeições para monitoramento (ex: contador para falhas excessivas)."
                                  ],
                                  "verification": "Simule uma rejeição: mostre y_n mantido e novo y_h com h menor.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou Python/Jupyter notebook"
                                  ],
                                  "tips": "Não reuse partes de y_h rejeitado; recompute fresco para precisão.",
                                  "learningObjective": "Aplicar ações corretas: descartar, manter, reduzir e recomputar.",
                                  "commonMistakes": [
                                    "Atualizar y_{n+1} com y_h rejeitado",
                                    "Não reduzir h o suficiente",
                                    "Perder y_n e reiniciar do zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar em Exemplo Completo",
                                  "subSteps": [
                                    "Escolha problema: y' = y, y(0)=1, h_inicial=0.2.",
                                    "Compute y_{0.2} e ||e||=1.5 >=1 → rejeite.",
                                    "Mantenha y_0=1, h=0.1, recompute y_{0.1}.",
                                    "Verifique ||e|| novo <1 e aceite.",
                                    "Compare soluções e discuta eficiência."
                                  ],
                                  "verification": "Resolva exemplo end-to-end sem erros na rejeição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notebook Jupyter com numpy/scipy",
                                    "Solução analítica para validação"
                                  ],
                                  "tips": "Automatize em código para múltiplos passos e visualize trajetória de h.",
                                  "learningObjective": "Integrar identificação e procedimentos em fluxo completo.",
                                  "commonMistakes": [
                                    "Erro aritmético em recomputação",
                                    "Não validar com solução exata",
                                    "Ignorar redução adaptativa de h"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolvendo y' = -2y, y(0)=1 com RK4(5) embedded, h=0.1: ||e||=1.3 >=1. Descarte y_h=0.8187, mantenha y_n=1, reduza h=0.05, recompute y_{0.05}=0.9048 com ||e||=0.4 <1, aceite.",
                              "finalVerifications": [
                                "Explica corretamente quando ||e|| >=1 indica rejeição.",
                                "Lista ações: descartar y_h, manter y_n, reduzir h.",
                                "Aplica em exemplo numérico sem erros.",
                                "Identifica impacto em eficiência computacional.",
                                "Diferencia rejeição de aceitação.",
                                "Sugere ajustes para h_new."
                              ],
                              "assessmentCriteria": [
                                "Precisão na condição ||e|| >=1 (100% correto).",
                                "Correta sequência de ações pós-rejeição.",
                                "Cálculos numéricos exatos em exemplos.",
                                "Compreensão de normalização de erro.",
                                "Explicação clara de por quê rejeitar.",
                                "Aplicação adaptativa de redução de h."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (controle de loop com if ||e|| >=1).",
                                "Física: Simulações dinâmicas com passos adaptativos (ex: trajetórias).",
                                "Engenharia: Otimização numérica em controle de sistemas.",
                                "Estatística: Controle de erro em Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD), rejeita passos em regiões turbulentas para precisão, usado em design de aviões pela NASA; ou em finanças para solvers de EDOs em precificação de opções."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Calcular h reduzido após rejeição",
                            "description": "Determinar h_new = h * (tol / ||e||)^{1/(p+1)} * f_segurança, com fator de redução mais conservador (ex: 0.5 * fórmula) para evitar loops de rejeição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e coletar os parâmetros necessários para o cálculo",
                                  "subSteps": [
                                    "Revise o contexto do método numérico: identifique a ordem p do método (ex: p=4 para Runge-Kutta ordem 4).",
                                    "Obtenha o tamanho do passo atual h.",
                                    "Recupere a tolerância desejada tol.",
                                    "Calcule ou obtenha a norma do erro estimado ||e|| do último passo rejeitado.",
                                    "Defina o fator de segurança f_segurança (tipicamente 0.8-0.9)."
                                  ],
                                  "verification": "Crie uma tabela listando todos os parâmetros com seus valores numéricos exatos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Exemplo de problema numérico com valores conhecidos"
                                  ],
                                  "tips": "Sempre anote unidades ou escalas para evitar erros de magnitude.",
                                  "learningObjective": "Compreender e listar corretamente todos os inputs requeridos para a fórmula de redução de passo.",
                                  "commonMistakes": [
                                    "Confundir p com a ordem do erro local",
                                    "Usar ||e|| do passo aceito em vez do rejeitado",
                                    "Esquecer de definir f_segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a razão de tolerância ao erro: tol / ||e||",
                                  "subSteps": [
                                    "Verifique se ||e|| > tol; se não, não há necessidade de redução.",
                                    "Divida tol por ||e|| usando uma calculadora de alta precisão.",
                                    "Registre o resultado como ratio = tol / ||e|| (esperado <1 para rejeição).",
                                    "Arredonde para 4-6 casas decimais para precisão.",
                                    "Confirme que ratio está entre 0 e 1 para casos de rejeição."
                                  ],
                                  "verification": "O valor de ratio deve ser menor que 1 e consistente com a magnitude do erro.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Calculadora científica ou software como Python/MATLAB"
                                  ],
                                  "tips": "Use logaritmos para ratios muito pequenos para evitar underflow.",
                                  "learningObjective": "Dominar o cálculo inicial da razão que quantifica o excesso de erro.",
                                  "commonMistakes": [
                                    "Inverter tol e ||e||",
                                    "Usar norma errada (L1 vs L2)",
                                    "Ignorar se ||e|| ≈ 0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o fator de redução básico: (tol / ||e||)^{1/(p+1)}",
                                  "subSteps": [
                                    "Calcule o expoente: exp = 1 / (p + 1).",
                                    "Eleve ratio à potência exp usando função pow() ou log(exp*log(ratio)).",
                                    "Registre o fator_reducao como resultado (tipicamente 0.1-0.9).",
                                    "Verifique se fator_reducao < 1.",
                                    "Ajuste para mínimo h_min se fator for muito pequeno."
                                  ],
                                  "verification": "fator_reducao deve diminuir com erros maiores, testado com valores conhecidos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora com funções exponenciais",
                                    "Tabela de valores teste"
                                  ],
                                  "tips": "Para p=1, exp=0.5 (raiz quadrada); memorize para ordens comuns.",
                                  "learningObjective": "Aplicar corretamente a potência fracionária derivada da análise de erro local.",
                                  "commonMistakes": [
                                    "Usar p em vez de p+1",
                                    "Calcular (1/(p+1))^ratio em vez de ratio^{1/(p+1)}",
                                    "Perder precisão em potências próximas de 0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar fatores conservadores e calcular h_new final",
                                  "subSteps": [
                                    "Multiplique fator_reducao por f_segurança (ex: 0.9).",
                                    "Aplique o fator conservador: multiplique por 0.5 ou similar para evitar loops.",
                                    "Multiplique o resultado por h atual: h_new = h * fator_final.",
                                    "Garanta h_new >= h_min (ex: 1e-12) para estabilidade.",
                                    "Registre h_new e compare com h original."
                                  ],
                                  "verification": "h_new < h e redução coerente com erro (teste com exemplo numérico).",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha para anotações sequenciais"
                                  ],
                                  "tips": "Fator conservador de 0.5 é crucial após múltiplas rejeições.",
                                  "learningObjective": "Integrar todos os componentes na fórmula final com ajustes de segurança.",
                                  "commonMistakes": [
                                    "Esquecer multiplicação por h",
                                    "Aplicar conservador antes da potência",
                                    "h_new > h"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar condições para evitar loops de rejeição",
                                  "subSteps": [
                                    "Conte rejeições consecutivas; se >3, aplique redução extra (ex: *0.1).",
                                    "Teste h_new em uma iteração simulada.",
                                    "Confirme ||e|| estimado para novo passo seria aceitável.",
                                    "Documente decisão: aceitar h_new ou abortar.",
                                    "Planeje retomada com h_new."
                                  ],
                                  "verification": "Simule 2-3 iterações sem loop infinito.",
                                  "estimatedTime": "7 minutos",
                                  "materials": [
                                    "Código simples ou papel para simulação manual"
                                  ],
                                  "tips": "Monitore contador de rejeições no algoritmo completo.",
                                  "learningObjective": "Implementar salvaguardas práticas contra instabilidade numérica.",
                                  "commonMistakes": [
                                    "Ignorar contador de rejeições",
                                    "h_new muito pequeno causando underflow",
                                    "Não testar pós-cálculo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um solver Runge-Kutta ordem 4 (p=4), com h=0.1, tol=1e-6, ||e||=5e-4 (L2 norma), f_segurança=0.9. ratio=1e-6/5e-4=0.002. exp=1/5=0.2. fator_reducao=0.002^0.2 ≈ 0.258. fator_final=0.258*0.9*0.5 ≈ 0.116. h_new=0.1*0.116 ≈ 0.0116. Verifique: redução conservadora evita loops.",
                              "finalVerifications": [
                                "h_new é menor que h original e positivo.",
                                "Fator de redução <1 quando ||e|| > tol.",
                                "Aplicação correta do expoente 1/(p+1).",
                                "Inclusão de f_segurança e conservador (ex: 0.5).",
                                "Simulação de uma iteração com h_new passa critério de aceitação.",
                                "Sem underflow ou h_new < h_min."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da razão tol/||e|| (erro <1%).",
                                "Correta elevação à potência 1/(p+1) com precisão numérica.",
                                "Aplicação consistente de fatores de segurança e conservador.",
                                "Verificação de condições anti-loop implementada.",
                                "Explicação clara da derivação da fórmula.",
                                "Uso apropriado de normas de erro."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (scipy.integrate) ou MATLAB ode45.",
                                "Física: Ajuste adaptativo em simulações de dinâmica orbital.",
                                "Estatística: Controle de erro em métodos Monte Carlo para integrais.",
                                "Engenharia: Otimização de passos em CFD (dinâmica de fluidos computacional)."
                              ],
                              "realWorldApplication": "Em solvers numéricos de EDOs como ode45 no MATLAB ou solve_ivp no SciPy, essa redução de h previne loops de rejeição em simulações críticas como previsão meteorológica, modelagem farmacocinética ou controle de robôs, garantindo precisão e eficiência computacional."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Implementar limite de rejeições",
                            "description": "Estabelecer mecanismo de parada ou alerta se o número de rejeições consecutivas exceder um limite (ex: 10), indicando possível stiff problem ou tol muito restritiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o limite máximo de rejeições consecutivas",
                                  "subSteps": [
                                    "Pesquisar na literatura valores típicos para limites de rejeições em métodos adaptativos (ex: 5-20 rejeições)",
                                    "Escolher um valor apropriado baseado no contexto do solver (ex: 10 para problemas gerais)",
                                    "Documentar a escolha no código com comentários explicando razões (stiff problems, tol restritiva)",
                                    "Definir variáveis associadas, como mensagem de alerta personalizada",
                                    "Considerar integração com detecção de rigidez (stiff) se aplicável"
                                  ],
                                  "verification": "Parâmetro maxRejections está definido como constante ou variável configurável e comentado no código fonte",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de métodos numéricos (livros como Burden & Faires)",
                                    "Editor de código (VS Code, Jupyter)"
                                  ],
                                  "tips": "Inicie com limite de 10; teste e ajuste para o problema específico para equilibrar robustez e eficiência",
                                  "learningObjective": "Compreender a importância do limite para evitar loops infinitos e diagnosticar problemas numéricos",
                                  "commonMistakes": "Definir limite muito baixo (interrompe prematuramente) ou muito alto (permite desperdício computacional excessivo)"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar o contador de rejeições",
                                  "subSteps": [
                                    "Declarar a variável rejectionCount como inteiro inicializado em 0",
                                    "Posicionar a inicialização no início do loop principal de integração ou solver",
                                    "Garantir que o escopo da variável seja local ao processo de controle de passo",
                                    "Integrar com outros contadores existentes (ex: stepCount, acceptCount)",
                                    "Verificar compatibilidade com linguagem de programação (ex: int em C++, contador em Python)"
                                  ],
                                  "verification": "Ao inspecionar o código, rejectionCount = 0 antes da primeira iteração do loop",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ambiente de desenvolvimento (Python com NumPy/SciPy, MATLAB)",
                                    "Template do solver numérico"
                                  ],
                                  "tips": "Use nomes descritivos como consecutiveRejections para clareza no código",
                                  "learningObjective": "Aprender a gerenciar estado de contadores em algoritmos iterativos",
                                  "commonMistakes": "Inicializar fora do escopo correto, causando reinicializações indesejadas ou erros de escopo"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar atualização do contador no ciclo de aceitação/rejeição",
                                  "subSteps": [
                                    "No bloco de aceitação de passo: definir rejectionCount = 0",
                                    "No bloco de rejeição de passo: rejectionCount += 1",
                                    "Posicionar as atualizações imediatamente após a decisão de aceitação/rejeição",
                                    "Adicionar logs opcionais para debug (ex: print(rejectionCount))",
                                    "Testar logicamente com fluxogramas antes de codificar"
                                  ],
                                  "verification": "Simular manualmente: após aceitação, contador zera; após rejeição, incrementa",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código base do solver adaptativo (ex: RK45)",
                                    "Debugger integrado (pdb em Python)"
                                  ],
                                  "tips": "Sempre resete apenas em aceitações para contar apenas sequências consecutivas",
                                  "learningObjective": "Dominar controle de fluxo condicional para gerenciamento de estado em loops numéricos",
                                  "commonMistakes": "Incrementar em aceitações ou resetar em rejeições, invalidando a contagem consecutiva"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar verificação do limite e mecanismo de parada/alerta",
                                  "subSteps": [
                                    "Após incremento do contador: if rejectionCount > maxRejections, acionar alerta",
                                    "Emitir mensagem de alerta (print, log, raise Exception com detalhes)",
                                    "Parar a execução (break do loop, return early ou sys.exit em casos extremos)",
                                    "Opcionalmente, salvar estado atual (h, y, t) para diagnóstico",
                                    "Tornar o alerta configurável (ex: warning vs error)"
                                  ],
                                  "verification": "Executar com tol restritiva: alerta emitido e solver interrompido após exatamente 11 rejeições",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Bibliotecas de logging (logging em Python)",
                                    "Exemplos de exceções em solvers numéricos"
                                  ],
                                  "tips": "Use warnings em vez de crashes para produção, permitindo continuação opcional",
                                  "learningObjective": "Implementar mecanismos de segurança e diagnóstico em software numérico",
                                  "commonMistakes": "Verificar antes do incremento (perde uma rejeição) ou sem parada efetiva (loop continua)"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e validar a implementação completa",
                                  "subSteps": [
                                    "Criar teste unitário com EDO simples e tol=1e-10 para forçar rejeições",
                                    "Verificar reset após sequência de aceitações intercaladas",
                                    "Testar com problema stiff (ex: y' = -1000y) para simular caso real",
                                    "Mensurar tempo de execução e comparar com versão sem limite",
                                    "Executar cobertura de testes (ex: pytest) para edge cases (0 rejeições)"
                                  ],
                                  "verification": "Todos os testes passam: sem loops infinitos, alertas corretos, resets funcionais",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Framework de testes (unittest/pytest)",
                                    "EDOs de teste padrão (Van der Pol stiff)"
                                  ],
                                  "tips": "Use asserts para verificar valores exatos do contador em pontos chave",
                                  "learningObjective": "Validar robustez e corretude através de testes automatizados",
                                  "commonMistakes": "Testes insuficientes, ignorando casos de poucas rejeições ou stiff problems"
                                }
                              ],
                              "practicalExample": "Em um solver Runge-Kutta de ordem 4/5 para a EDO y' = -50*y com y(0)=1 e tol=1e-12, o passo inicial h=0.1 será rejeitado repetidamente devido ao erro estimado alto. Após 10 rejeições consecutivas, o solver deve imprimir 'ALERTA: Limite de 10 rejeições excedido - possível problema stiff ou tolerância muito restritiva' e interromper a integração em t≈0.01, salvando o estado para análise.",
                              "finalVerifications": [
                                "Contador rejectionCount reseta corretamente para 0 após qualquer aceitação de passo",
                                "Contador incrementa exatamente uma vez por rejeição consecutiva",
                                "Alerta é emitido precisamente quando rejectionCount > maxRejections",
                                "Execução do solver é interrompida sem continuação automática",
                                "Implementação não afeta performance em casos sem rejeições excessivas",
                                "Mensagem de alerta inclui diagnóstico útil (stiff ou tol)"
                              ],
                              "assessmentCriteria": [
                                "Código é limpo, modular e bem comentado em português/inglês",
                                "Lógica de contagem consecutiva está 100% correta sem exceções",
                                "Eficiência mantida (overhead <1% em execuções normais)",
                                "Parâmetros (limite, mensagem) são facilmente configuráveis",
                                "Tratamento robusto de edge cases: 0 rejeições, reset múltiplos",
                                "Testes unitários cobrem >90% do código relacionado"
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Estruturas de controle, exceções e logging em programação",
                                "Engenharia de Software: Design de mecanismos de falha e robustez em algoritmos",
                                "Física Computacional: Detecção de problemas stiff em simulações dinâmicas",
                                "Análise de Algoritmos: Otimização de loops iterativos e detecção de divergência"
                              ],
                              "realWorldApplication": "Em simulações de engenharia como dinâmica de veículos autônomos ou modelagem climática, previne travamentos em problemas mal-condicionados (stiff ODEs), economizando recursos computacionais e permitindo ajustes rápidos de tolerância ou escolha de solver implícito, essencial em aplicações industriais como CFD (Computational Fluid Dynamics)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Controle de Passo em Métodos Multietapa",
                    "description": "Adaptação específica para métodos de passo múltiplo, integrando estabilidade e detecção de problemas stiff.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Adaptação do Controle de Passo para Métodos Multietapa",
                        "description": "Modificação dos algoritmos de controle de passo tradicionais, usados em métodos de passo simples como Runge-Kutta, para lidar com a dependência de múltiplos passos anteriores nos métodos multietapa, garantindo precisão e eficiência.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Calcular o tamanho de passo ótimo em métodos multietapa",
                            "description": "Determinar o h ótimo considerando os erros locais de truncamento de k passos anteriores, utilizando estimadores de erro baseados em métodos embutidos como os de ordem variável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender erros locais de truncamento em métodos multietapa",
                                  "subSteps": [
                                    "Revise a definição de erro local de truncamento (LET) para métodos de Runge-Kutta multietapa.",
                                    "Estude como o LET acumula sobre k passos anteriores devido à dependência em valores prévios.",
                                    "Analise a ordem de precisão p e q do método e como afetam o LET.",
                                    "Derive a expressão aproximada do LET total considerando k passos.",
                                    "Compare com métodos monoetapa para destacar diferenças."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o LET se propaga em k passos e forneça uma fórmula simplificada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre métodos multietapa",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Comece com métodos de ordem baixa (ex: Adams-Bashforth de 2 passos) para visualizar a propagação.",
                                  "learningObjective": "Identificar e quantificar o impacto dos erros locais acumulados em métodos multietapa.",
                                  "commonMistakes": [
                                    "Ignorar a dependência em passos anteriores",
                                    "Confundir LET com erro global",
                                    "Não considerar a ordem variável do método"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar estimadores de erro com métodos embutidos",
                                  "subSteps": [
                                    "Aprenda sobre métodos Runge-Kutta embutidos (ex: Dormand-Prince de ordens p e p-1).",
                                    "Configure pares de métodos de ordens variável para estimar LET em cada passo.",
                                    "Calcule o estimador de erro como |y_{n+1}^{(p)} - y_{n+1}^{(p-1)}| / (2^p - 1).",
                                    "Adapte para métodos multietapa, somando estimadores de k passos recentes.",
                                    "Teste em uma EDO simples como y' = -y."
                                  ],
                                  "verification": "Implemente um código simples que outputa estimadores de erro para 5 passos consecutivos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com SciPy (solve_ivp)",
                                    "Documentação de métodos RK embutidos",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use tol = 1e-6 inicialmente para calibrar o estimador.",
                                  "learningObjective": "Construir e validar estimadores de erro locais usando métodos embutidos de ordem variável.",
                                  "commonMistakes": [
                                    "Usar ordens erradas no denominador do estimador",
                                    "Não normalizar o erro por norma adequada",
                                    "Acumular erros sem ponderação por h"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e calcular o tamanho de passo ótimo h*",
                                  "subSteps": [
                                    "Estabeleça o critério de erro: média ponderada dos LETs dos k passos ≤ tol.",
                                    "Derive h* ≈ h_atual * (tol / erro_estimado)^{1/p}, ajustado para multietapa.",
                                    "Inclua fator de segurança γ ≈ 0.9 e limite para rejeição/aceitação.",
                                    "Some contribuições de k LETs: erro_total ≈ Σ (LET_i * h_i^{p_i}).",
                                    "Implemente a fórmula em pseudocódigo."
                                  ],
                                  "verification": "Resolva manualmente h* para um caso com LETs dados e tol=1e-3.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Papel e lápis para derivação",
                                    "Artigo sobre controle de passo (ex: Hairer et al.)",
                                    "Software como MATLAB/Octave"
                                  ],
                                  "tips": "Use p efetiva como média das ordens nos k passos.",
                                  "learningObjective": "Formular matematicamente e computar o h ótimo baseado em erros acumulados.",
                                  "commonMistakes": [
                                    "Esquecer fator de segurança",
                                    "Não ajustar para ordens variáveis",
                                    "Usar h global em vez de local"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e validar o controle de passo em simulação",
                                  "subSteps": [
                                    "Escolha uma EDO não-linear (ex: y' = y(1-y), y(0)=0.5).",
                                    "Implemente um solver com controle de passo usando h* derivado.",
                                    "Compare soluções com h fixo vs adaptativo em termos de erro e eficiência.",
                                    "Ajuste parâmetros (tol, k=5) e registre histórico de h.",
                                    "Analise convergência e eficiência computacional."
                                  ],
                                  "verification": "Gere gráfico mostrando h variando e erro < tol em todos os passos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python/NumPy/SciPy/Matplotlib",
                                    "EDOs de teste padronizadas"
                                  ],
                                  "tips": "Monitore eficiência como número de passos / precisão.",
                                  "learningObjective": "Integrar cálculo de h* em um algoritmo completo e validar numericamente.",
                                  "commonMistakes": [
                                    "Rejeitar passos sem backtrack",
                                    "Permitir h muito pequeno levando a stiff",
                                    "Ignorar overhead computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y + sin(t), y(0)=1 no intervalo [0,10] usando método Adams-Bashforth de 4 passos com RK4 embutido. Inicie com h=0.1; em t=2, LETs dos 4 passos anteriores são [1.2e-4, 1.5e-4, 1.1e-4, 1.3e-4]. Com tol=1e-3 e p=4, calcule h* ≈ 0.1 * (1e-3 / 1.3e-4)^{1/4} * 0.9 ≈ 0.15. Aplique e verifique erro médio < tol.",
                              "finalVerifications": [
                                "Derivar corretamente h* para LETs dados com erro <5%.",
                                "Implementar código que ajusta h automaticamente mantendo erro < tol.",
                                "Comparar eficiência: passos adaptativos ≤ 1.5x passos fixos para mesma precisão.",
                                "Identificar e corrigir caso de rejeição de passo.",
                                "Explicar impacto de k em precisão do h*."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação de h* (fórmula exata com fatores).",
                                "Correção do estimador de erro em simulação (erro real vs estimado < fator 2).",
                                "Eficiência do algoritmo (número de f-evals otimizado).",
                                "Tratamento de casos edge (h min/max, stiff).",
                                "Clareza na documentação do código e análise.",
                                "Validação com múltiplas EDOs."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/SciPy para solvers ODE.",
                                "Física: Simulações dinâmicas em mecânica orbital.",
                                "Engenharia: Controle adaptativo em simulações CFD.",
                                "Estatística: Análise de erro e tolerâncias probabilísticas."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou aeroespaciais, otimiza solvers ODE para equilibrar precisão e tempo computacional, permitindo previsões rápidas e confiáveis em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Implementar aceitação e rejeição de passos",
                            "description": "Aplicar critérios de aceitação baseados em tolerâncias relativas e absolutas, ajustando h para o próximo passo e descartando histórico quando necessário em métodos como Adams-Bashforth-Moulton.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Critérios de Tolerância e Preparar Passo Candidato",
                                  "subSteps": [
                                    "Estabeleça tolerâncias absoluta (atol) e relativa (rtol) com base no problema, tipicamente atol = 1e-6 e rtol = 1e-3.",
                                    "Compute o passo candidato y_{n+1}^* usando predictor-corrector (Adams-Bashforth para predição, Adams-Moulton para correção).",
                                    "Calcule o erro estimado local inicial como |y_{n+1}^* - y_n| / h.",
                                    "Prepare o histórico de passos anteriores (k valores para método de ordem k)."
                                  ],
                                  "verification": "Verifique se tolerâncias estão definidas numericamente e se y_{n+1}^* foi computado corretamente comparando com solução analítica aproximada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de código (Python/MATLAB), equação diferencial de teste como y' = -y.",
                                  "tips": "Escolha atol e rtol proporcionais à escala da solução para evitar rejeições excessivas.",
                                  "learningObjective": "Compreender como tolerâncias guiam a precisão adaptativa em métodos multietapa.",
                                  "commonMistakes": "Confundir tolerância relativa com absoluta, levando a passos muito pequenos ou grandes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estimar Erro Local e Comparar com Critérios",
                                  "subSteps": [
                                    "Aplique a fórmula de erro: err = |y_{n+1}^{corrector} - y_{n+1}^{predictor}| / scal, onde scal = atol + rtol * |y_{n+1}|.",
                                    "Compare err com 1: se err < 1, aceitação provisória; senão, rejeição.",
                                    "Calcule fator de segurança safety = 0.9 * (1/err)^{1/(order+1)} para ajuste futuro.",
                                    "Registre o erro para análise posterior."
                                  ],
                                  "verification": "Confirme que err está abaixo de 1 para aceitação e acima para rejeição em um teste manual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica ou script Python com numpy/scipy.",
                                  "tips": "Use norma máxima ou L2 para err em problemas vetoriais para robustez.",
                                  "learningObjective": "Dominar o cálculo de erro local em predictor-corrector para decisão de aceitação.",
                                  "commonMistakes": "Esquecer de normalizar por scal, causando decisões inconsistentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Decisão de Aceitação/Rejeição e Ajuste de h",
                                  "subSteps": [
                                    "Se aceito: defina y_{n+1} = y_{n+1}^{corrector}, avance n e atualize histórico.",
                                    "Se rejeitado: rejeite y_{n+1}, reduza h_new = h * min(0.9, safety), tente novamente.",
                                    "Aplique limites: h_new entre h_min e h_max (ex: h_min=1e-8, h_max=1).",
                                    "Conte número de rejeições consecutivas; se >3, reduza ordem do método."
                                  ],
                                  "verification": "Simule 5 passos e verifique se h ajusta corretamente e histórico é mantido/atualizado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ambiente de programação (Jupyter Notebook recomendado).",
                                  "tips": "Implemente um loop while para tentativas de rejeição até aceitação ou falha.",
                                  "learningObjective": "Aplicar lógica condicional para controle adaptativo de passo em código.",
                                  "commonMistakes": "Não limitar h_min/max, levando a overflow/underflow."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar Histórico e Iterar Processo",
                                  "subSteps": [
                                    "Ao aceitar: shift histórico (descartar y_{n-k} mais antigo, adicionar y_{n+1}).",
                                    "Ao rejeitar múltiplas vezes: limpe histórico parcial e recomece com ordem menor.",
                                    "Integre em solver completo: repita até tfinal ou erro de convergência.",
                                    "Logue estatísticas: aceitações/rejeições, h médio, tempo total."
                                  ],
                                  "verification": "Execute simulação completa e cheque se histórico tem tamanho correto e solução converge.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código fonte do solver, gráfico de h vs. t para visualização.",
                                  "tips": "Use deque em Python para histórico eficiente (O(1) shift).",
                                  "learningObjective": "Gerenciar estado multietapa de forma estável durante adaptações.",
                                  "commonMistakes": "Manter histórico corrompido após rejeições, propagando erros."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar Implementação Completa",
                                  "subSteps": [
                                    "Teste com EDO conhecida (ex: y' = y, y(0)=1, solução exata e^t).",
                                    "Compare erro global com solução exata em vários h iniciais.",
                                    "Analise eficiência: número de f-evals vs. precisão.",
                                    "Debug rejeições excessivas ajustando safety ou tolerâncias."
                                  ],
                                  "verification": "Erro global < 1e-4 em [0,1] e pelo menos 80% aceitações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Solver implementado, plotador (matplotlib).",
                                  "tips": "Grave h(t) para diagnosticar problemas de estabilidade.",
                                  "learningObjective": "Validar robustez do controle de passo em cenários reais.",
                                  "commonMistakes": "Ignorar estagnação (h muito pequeno sem progresso)."
                                }
                              ],
                              "practicalExample": "Para y' = -2y, y(0)=1 (solução y=e^{-2t}), use Adams-Bashforth ordem 2 predictor e Adams-Moulton ordem 2 corrector. Inicie h=0.1, rtol=1e-3. No t=0.2, predictor dá y=0.6703, corrector 0.6704, err=0.0001/scal<1 → aceito, h_next=0.105. No t=0.5, err=1.2>1 → rejeite, h=0.09, histórico shift após aceitação.",
                              "finalVerifications": [
                                "O algoritmo aceita passos com err <1 e rejeita corretamente >1.",
                                "h é ajustado dinamicamente dentro de limites sem overflow.",
                                "Histórico mantém k valores válidos após shifts.",
                                "Solução global converge para exata com erro < rtol * escala.",
                                "Número de rejeições <20% do total de passos.",
                                "Logs mostram eficiência (f-evals razoáveis para precisão)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro local sempre normalizado corretamente por scal.",
                                "Eficiência: Ajuste de h usa safety factor apropriado (0.7-0.9).",
                                "Robustez: Lida com rejeições consecutivas reduzindo ordem/h.",
                                "Corretude: Histórico descartado apenas quando necessário.",
                                "Implementação: Código limpo com funções modulares para predictor/corrector.",
                                "Validação: Testes unitários para aceitação/rejeição em casos edge."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de controle (loops condicionais) e gerenciamento de arrays.",
                                "Física: Simulações dinâmicas em mecânica/orbitais onde estabilidade é crítica.",
                                "Engenharia: Controle adaptativo em CFD ou circuitos elétricos.",
                                "Estatística: Análise de erro e confiabilidade numérica."
                              ],
                              "realWorldApplication": "Em modelagem climática (ODEs para previsão do tempo), finanças (simulação de Black-Scholes adaptativa) ou farmacocinética (equações para liberação de drogas), onde eficiência computacional é essencial para resolver EDOs rígidas sem perda de precisão."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Gerenciar o histórico de passos iniciais",
                            "description": "Usar métodos de partida (startup) para inicializar os k primeiros passos com métodos de Runge-Kutta, integrando ao controle de passo contínuo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a necessidade de histórico inicial em métodos multietapa",
                                  "subSteps": [
                                    "Estudar a estrutura de métodos multietapa lineares implícitos (multistep), que dependem de k valores anteriores y_{n-1}, ..., y_{n-k} para avançar.",
                                    "Analisar por que métodos multietapa não podem iniciar sozinhos, necessitando de k passos iniciais precisos.",
                                    "Revisar o impacto de passos iniciais imprecisos na estabilidade e precisão global da solução.",
                                    "Comparar com métodos one-step como Runge-Kutta, que servem como base para startup.",
                                    "Identificar o papel do controle de passo contínuo na transição suave após os passos iniciais."
                                  ],
                                  "verification": "Resumir em um parágrafo os motivos e consequências, com diagrama esquemático do processo.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Slides do curso sobre métodos multietapa",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Desenhe um fluxograma mostrando a sequência: startup → multietapa → controle de passo.",
                                  "learningObjective": "Entender conceitualmente a dependência de histórico inicial e sua integração ao esquema geral.",
                                  "commonMistakes": [
                                    "Confundir ordem do método multietapa com passos iniciais necessários",
                                    "Ignorar efeitos de propagação de erro dos passos iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e estudar métodos de partida (startup)",
                                  "subSteps": [
                                    "Listar métodos comuns de startup: Runge-Kutta de ordem k ou superior, extrapolação polinomial.",
                                    "Focar em Runge-Kutta de ordem 4 (RK4) para gerar passos iniciais precisos e eficientes.",
                                    "Analisar Butcher tableau do RK4 e fórmulas para um passo: k1 = f(t_n, y_n), etc.",
                                    "Calcular manualmente 1-2 passos de RK4 em uma EDO simples para familiarizar.",
                                    "Discutir adaptação do tamanho de passo inicial compatível com o controle contínuo."
                                  ],
                                  "verification": "Implementar RK4 em pseudocódigo e testar em EDO y' = -y, y(0)=1, para h=0.1.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software Python/MATLAB com bibliotecas numéricas (numpy/scipy)",
                                    "Tabela de Butcher para RK4",
                                    "Exemplos resolvidos de EDOs"
                                  ],
                                  "tips": "Escolha ordem de RK pelo menos igual à do método multietapa para consistência local.",
                                  "learningObjective": "Dominar a escolha e mecânica de métodos Runge-Kutta para inicialização.",
                                  "commonMistakes": [
                                    "Usar RK de ordem baixa, causando perda de precisão global",
                                    "Não alinhar h inicial com tolerâncias do controle de passo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar geração do histórico de k passos iniciais",
                                  "subSteps": [
                                    "Definir parâmetros: EDO f(t,y), condições iniciais, k (ordem do multietapa), h inicial.",
                                    "Codificar loop para gerar y1, y2, ..., yk usando RK4 com passo fixo ou adaptativo.",
                                    "Armazenar histórico em array ou lista: [t0,y0, t1,y1, ..., tk,yk].",
                                    "Verificar precisão local comparando com solução exata ou método de alta ordem.",
                                    "Ajustar h inicial baseado em estimativa de erro local."
                                  ],
                                  "verification": "Gerar histórico para EDO dada e comparar norma do erro com solução analítica nos k pontos.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Ambiente de programação (Python com scipy.integrate.odeint para referência)",
                                    "EDOs de teste com soluções conhecidas"
                                  ],
                                  "tips": "Use passo h pequeno nos primeiros passos para alta precisão, depois transite para controle.",
                                  "learningObjective": "Implementar computacionalmente o startup procedure de forma robusta.",
                                  "commonMistakes": [
                                    "Erro de indexação no array de histórico",
                                    "Não salvar tempos t junto com y"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar histórico ao controle de passo contínuo em métodos multietapa",
                                  "subSteps": [
                                    "Configurar esquema multietapa (ex: BDF ou Adams) com histórico inicial pronto.",
                                    "Implementar controlador de passo: estimar erro local, ajustar h_{n+1} = h_n * (tol/err)^{1/p}.",
                                    "Iniciar integração do passo k+1 usando histórico y_{k}, ..., y_1, y0.",
                                    "Gerenciar buffer deslizante do histórico: adicionar novos y, descartar antigos.",
                                    "Tratar condições especiais: reinício se h muito pequeno ou falha de convergência."
                                  ],
                                  "verification": "Executar simulação completa e plotar solução vs. referência, checando erro global < 1e-6.",
                                  "estimatedTime": "4-5 horas",
                                  "materials": [
                                    "Código base de métodos multietapa",
                                    "Ferramentas de plotagem (matplotlib)"
                                  ],
                                  "tips": "Mantenha histórico em deque para eficiência O(1) em atualizações.",
                                  "learningObjective": "Integrar seamless o startup ao solver com controle adaptativo.",
                                  "commonMistakes": [
                                    "Perda de sincronia entre histórico e passos atuais",
                                    "Ignorar rejeição de passos no controlador afetando histórico"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar a gestão do histórico",
                                  "subSteps": [
                                    "Testar com EDOs rígidas e não-rígidas para verificar estabilidade.",
                                    "Analisar convergência: reduzir tolerância e observar ordem de precisão.",
                                    "Otimizar: escolha dinâmica de método startup baseado em rigidez.",
                                    "Documentar código com comentários sobre gestão de histórico.",
                                    "Comparar performance com solvers prontos (ex: ode15s no MATLAB)."
                                  ],
                                  "verification": "Relatório com gráficos de erro vs. h e tempo de CPU para diferentes configurações.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Solvers de referência (scipy.integrate.solve_ivp)",
                                    "EDOs teste variadas"
                                  ],
                                  "tips": "Profile o código para gargalos na gestão de histórico.",
                                  "learningObjective": "Garantir robustez e eficiência na implementação completa.",
                                  "commonMistakes": [
                                    "Testar só EDOs lineares simples",
                                    "Não considerar overhead do startup em problemas longos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDO y' = y(1 - y), y(0) = 0.5 (modelo logístico), use método BDF2 (k=2). Gere 2 passos iniciais com RK4 e h=0.01: y1 ≈ 0.522, y2 ≈ 0.546. Integre até t=5 com controle de passo (tol=1e-6), plotando vs. solução exata y(t)=1/(1+exp(-t)).",
                              "finalVerifications": [
                                "Histórico inicial gerado com erro local < 1e-8 em todos k pontos.",
                                "Transição suave: erro no passo k+1 compatível com tolerância global.",
                                "Buffer de histórico atualizado corretamente durante 100+ passos.",
                                "Solução final converge à ordem esperada do método multietapa.",
                                "Sem crashes ou rejeições excessivas (>20%) devido a histórico ruim.",
                                "Tempo de computação razoável (<2x solver de referência)."
                              ],
                              "assessmentCriteria": [
                                "Correção conceitual: explicação precisa da necessidade e integração.",
                                "Implementação funcional: código roda sem erros em EDOs teste.",
                                "Precisão numérica: erro global < tol em múltiplos problemas.",
                                "Eficiência: gestão de histórico O(1) por passo.",
                                "Robustez: lida com rigidez e passos rejeitados.",
                                "Documentação: código comentado e relatório claro."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação em Python/MATLAB de algoritmos numéricos.",
                                "Física Computacional: Simulações de sistemas dinâmicos (ex: osciladores).",
                                "Engenharia de Controle: Solvers para EDOs em automação e robótica.",
                                "Ciência de Dados: Integração numérica em machine learning (redes neurais recorrentes)."
                              ],
                              "realWorldApplication": "Em software de simulação como COMSOL ou ANSYS para modelagem de fluidos e estruturas, onde solvers adaptativos (ex: ode45/ode15s) usam startup Runge-Kutta para inicializar métodos multietapa em previsões meteorológicas, trajetórias espaciais e farmacocinética."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Integração de Estabilidade no Controle de Passo",
                        "description": "Incorporação da análise de estabilidade regional e absoluta nos métodos multietapa ao mecanismo de controle de passo, evitando oscilações ou divergência em equações com autovalores variados.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Avaliar a estabilidade A em métodos multietapa",
                            "description": "Verificar se o método é A-estável ou L-estável analisando o polinômio de estabilidade e ajustando h para permanecer na região de estabilidade absoluta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de estabilidade A e L-estável",
                                  "subSteps": [
                                    "Revise o teste do problema modelo y' = λy com Re(λ) < 0.",
                                    "Defina a região de estabilidade absoluta (RSA) como {z ∈ ℂ : |R(z)| ≤ 1}, onde R(z) é a função de amplificação.",
                                    "Explique A-estabilidade: RSA contém todo o semiplano esquerdo (verificar |R(iy)| ≤ 1 para todo y ∈ ℝ).",
                                    "Diferencie L-estabilidade: A-estável e |R(z)| → 0 quando |z| → ∞ com Re(z) < 0.",
                                    "Discuta implicações para problemas stiff em métodos multietapa."
                                  ],
                                  "verification": "Escreva definições precisas e dê um exemplo de método A-estável (ex: trapezoidal).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (Hairer et al.), notas de aula sobre EDOs"
                                  ],
                                  "tips": [
                                    "Use diagramas de regiões de estabilidade para visualização.",
                                    "Lembre-se: A-estabilidade é crucial para h grande em problemas stiff."
                                  ],
                                  "learningObjective": "Dominar definições e diferenças entre A e L-estabilidade.",
                                  "commonMistakes": [
                                    "Confundir RSA com RLS (estabilidade linear).",
                                    "Ignorar o comportamento assintótico em L-estabilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar os polinômios de estabilidade ρ(z) e σ(z) para um método multietapa",
                                  "subSteps": [
                                    "Identifique o esquema linear multietapa: ∑_{k=0}^q a_k y_{n+k} = h ∑_{k=0}^q b_k f_{n+k}.",
                                    "Defina ρ(z) = ∑_{k=0}^q a_k z^k e σ(z) = ∑_{k=0}^q b_k z^k.",
                                    "Calcule explicitamente para um método dado, ex: BDF2 (a0=3/2, a1=-2, a2=1/2; b2=1).",
                                    "Verifique consistência: ρ(1)=0, ρ'(1)=σ(1).",
                                    "Teste neutralidade: ρ(-1) = (-1)^q σ(-1) para preservação de simetria."
                                  ],
                                  "verification": "Escreva ρ(z) e σ(z) corretos para BDF2 e verifique consistência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis ou software simbólico como SymPy",
                                    "Tabela de métodos multietapa"
                                  ],
                                  "tips": [
                                    "Padronize z^k com k crescente para y_{n+k}.",
                                    "Use expansão binomial para simplificar."
                                  ],
                                  "learningObjective": "Calcular polinômios de estabilidade com precisão.",
                                  "commonMistakes": [
                                    "Índices errados nos coeficientes a_k/b_k.",
                                    "Esquecer fator h na definição de σ."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a função de estabilidade R(z) no eixo imaginário para A-estabilidade",
                                  "subSteps": [
                                    "Defina R(z) = ρ(z)/σ(z) e considere z = iy com y ∈ ℝ.",
                                    "Calcule |R(iy)|^2 = R(iy) \bar{R(iy)} e verifique se ≤ 1 para todo y.",
                                    "Para métodos de ordem baixa, plote |R(iy)| vs y ou analise analiticamente.",
                                    "Identifique se o método é A-estável (ex: BDF1 sim, Adams-Bashforth não).",
                                    "Para L-estabilidade, examine limite |z|→∞ em semiplano esquerdo."
                                  ],
                                  "verification": "Prove que BDF2 é A-estável mostrando |R(iy)| ≤ 1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB/Python para plotar |R(iy)|",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": [
                                    "Use desigualdade triangular para bounds.",
                                    "Plots ajudam a visualizar violações."
                                  ],
                                  "learningObjective": "Avaliar A/L-estabilidade via análise de R(iy).",
                                  "commonMistakes": [
                                    "Calcular R(z) em vez de |R(iy)|.",
                                    "Limitar y a intervalo finito."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar o passo h no controle de passo baseado na estabilidade absoluta",
                                  "subSteps": [
                                    "Para problema y' = λy + ..., estime |λ|_{max} do Jacobiano.",
                                    "Determine h_max tal que h |λ|_{max} ∈ RSA.",
                                    "Integre em algoritmo de controle: se h |λ| ∉ RSA, reduza h por fator de segurança (ex: 0.9).",
                                    "Simule numericamente para validar: compare soluções com h fixo vs adaptativo.",
                                    "Considere custos computacionais de métodos multietapa (q passos)."
                                  ],
                                  "verification": "Implemente ajuste de h em código simples e verifique estabilidade em oscilador rígido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com SciPy (odeint ou solve_ivp)",
                                    "Exemplo de EDO stiff: y' = -1000(y - cos(t))"
                                  ],
                                  "tips": [
                                    "Fator de segurança 0.8-0.9 evita saídas da RSA.",
                                    "Monitore ||erro local|| junto com estabilidade."
                                  ],
                                  "learningObjective": "Aplicar análise de estabilidade em controle adaptativo de passo.",
                                  "commonMistakes": [
                                    "Subestimar |λ|_{max} do problema.",
                                    "Ignorar dependência de h em estimativas de erro."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método BDF2 em y' = -50y + sin(t), y(0)=1: Calcule ρ(z)= (3/2)z^2 - 2z + 1/2, σ(z)=z^2. Verifique A-estabilidade plotando |R(iy)|<1. Ajuste h < 0.04/50 para λ=-50 em RSA.",
                              "finalVerifications": [
                                "Defina corretamente A-estabilidade e dê contraexemplo não A-estável.",
                                "Derive ρ(z), σ(z) para método multietapa arbitrário.",
                                "Analise |R(iy)| ≤1 para BDF2.",
                                "Calcule h_max para λ dado e método.",
                                "Explique integração em controle de passo.",
                                "Simule EDO stiff com/ sem controle de estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática em derivações de ρ/σ/R (100% correto).",
                                "Análise qualitativa/quantitativa de |R(iy)| com plots ou provas.",
                                "Correção no cálculo de h_max e fator de segurança.",
                                "Clareza na explicação de implicações para problemas stiff.",
                                "Validação numérica com simulações convergentes.",
                                "Identificação de erros comuns em análise."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementar análise de estabilidade em Python/MATLAB.",
                                "Física Computacional: Simulações de sistemas dinâmicos rígidos (circuitos RLC).",
                                "Engenharia de Controle: Estabilidade em simulações de sistemas lineares.",
                                "Estatística Computacional: Integração em MCMC para processos stiff."
                              ],
                              "realWorldApplication": "Em modelagem climática ou dinâmica de fluidos (EDOs stiff), garante simulações estáveis com h grande, reduzindo tempo computacional em supercomputadores sem oscilações numéricas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Ajustar passo baseado em restrições de estabilidade",
                            "description": "Calcular h máximo imposto pela estabilidade para equações lineares teste, integrando ao estimador de erro de truncamento no controle de passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar região de estabilidade para métodos multietapa",
                                  "subSteps": [
                                    "Estude a definição de estabilidade absoluta para métodos lineares multietapa.",
                                    "Analise o polinômio de estabilidade R(z) para o método específico (ex: Adams-Bashforth ou BDF).",
                                    "Identifique a região de estabilidade no plano complexo z = hλ.",
                                    "Determine os limites reais negativos para equações de teste y' = λy com Re(λ) < 0.",
                                    "Compare estabilidade A-stável vs. não rígida."
                                  ],
                                  "verification": "Desenhe ou descreva corretamente a região de estabilidade e cite |R(z)| ≤ 1 para z na região.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), software MATLAB/Octave para plotar regiões.",
                                  "tips": "Use ferramentas como StabilityPolygon para visualizar regiões.",
                                  "learningObjective": "Compreender como a região de estabilidade limita h para equações rígidas.",
                                  "commonMistakes": "Confundir estabilidade local com global; ignorar parte imaginária de λ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular h máximo imposto pela estabilidade para equações lineares de teste",
                                  "subSteps": [
                                    "Selecione equação teste y' = λy com λ real negativo conhecido.",
                                    "Calcule z_max = h_max * λ tal que |R(z_max)| = 1 no eixo real negativo.",
                                    "Resolva h_max = z_max / λ (considerando |λ| grande para rigidez).",
                                    "Estime λ aproximado via eigenvalues da matriz jacobiana do sistema.",
                                    "Calcule h_stab = min(h_max sobre autovalores com maior |Re(λ)|)."
                                  ],
                                  "verification": "Para λ = -100, método AB2, compute h_max ≈ 1.5 e verifique |R(-1.5)| ≤ 1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e calculadora; código Python/MATLAB para polinômio R(z).",
                                  "tips": "Use aproximação linear para regiões grandes; teste múltiplos λ.",
                                  "learningObjective": "Calcular quantitativamente o limite de estabilidade h_max.",
                                  "commonMistakes": "Usar h_min em vez de h_max; esquecer sinal negativo de λ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar restrição de estabilidade ao estimador de erro de truncamento",
                                  "subSteps": [
                                    "Revise estimador de erro local (LTE) de Runge-Kutta embedded (ex: Dormand-Prince).",
                                    "Defina h_new = min(h_err, h_stab), onde h_err de tol * (LTE).",
                                    "Implemente lógica: se h_stab < h_err, use h_stab e monitore crescimento de erro.",
                                    "Ajuste fator de segurança (0.9) para ambos os critérios.",
                                    "Teste em EDO rígida como y' = -100y + sin(t)."
                                  ],
                                  "verification": "Simule passo: h_err=0.1, h_stab=0.05 → h_new=0.05; erro permanece estável.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software numérico (SciPy odeint, MATLAB ode45), notebook Jupyter.",
                                  "tips": "Logaritme o erro para detectar instabilidade.",
                                  "learningObjective": "Combinar controle de precisão e estabilidade em um h adaptativo.",
                                  "commonMistakes": "Priorizar apenas erro sem checar estabilidade; overflow numérico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar algoritmo de controle de passo integrado",
                                  "subSteps": [
                                    "Escreva pseudocódigo: compute jacobiano, eigenvalues → h_stab; LTE → h_err; h = min/max.",
                                    "Codifique em Python/MATLAB com solver multietapa.",
                                    "Teste em problema rígido (ex: van der Pol com μ=1000).",
                                    "Compare soluções com h fixo vs. adaptativo.",
                                    "Analise eficiência (passos totais, tempo CPU)."
                                  ],
                                  "verification": "Solução converge sem oscilações; h adaptado respeita ambos limites.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (NumPy, SciPy), MATLAB; problemas teste padrão.",
                                  "tips": "Use sparse jacobiano para sistemas grandes.",
                                  "learningObjective": "Desenvolver algoritmo robusto de controle de passo.",
                                  "commonMistakes": "Erro na estimação de eigenvalues; rejeitar passos sem backtrack."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e otimizar o controle de passo",
                                  "subSteps": [
                                    "Meça erro global vs. passos para vários tol.",
                                    "Identifique casos onde estabilidade domina erro.",
                                    "Ajuste thresholds (ex: se h_stab < 0.1 h_err, flag 'rígido').",
                                    "Documente trade-offs precisão vs. eficiência.",
                                    "Simule falhas e corrija (switch para método implícito)."
                                  ],
                                  "verification": "Gráficos mostram h estável, erro < tol; eficiência > 20% melhor que fixo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Plots em Matplotlib; benchmarks.",
                                  "tips": "Automatize testes com grid de parâmetros.",
                                  "learningObjective": "Otimizar e validar integração em cenários reais.",
                                  "commonMistakes": "Ignorar custo computacional de eigenvalues."
                                }
                              ],
                              "practicalExample": "Para método Adams-Bashforth ordem 2 (R(z)=1+z+0.5z²), λ=-50 (y'=λy), z_max≈-2.8 → h_max=2.8/50=0.056. Com tol=1e-6 dando h_err=0.08, use h=0.056. Integre y(0)=1 até t=1; solução adaptativa mantém |y| estável sem blow-up.",
                              "finalVerifications": [
                                "h_new sempre ≤ h_stab para todos autovalores.",
                                "Erro local < tol em 95% dos passos.",
                                "Solução global converge com ordem do método.",
                                "Número de passos reduzido em problemas rígidos.",
                                "Sem instabilidade detectada (erro crescente).",
                                "Eficiência computacional melhorada vs. h fixo."
                              ],
                              "assessmentCriteria": [
                                "Cálculo preciso de h_stab (erro <5%).",
                                "Implementação correta da min(h_err, h_stab).",
                                "Testes em EDOs rígidas e não-rígidas passam.",
                                "Documentação clara de algoritmo e resultados.",
                                "Análise de trade-offs incluída.",
                                "Código limpo e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Simulações de osciladores rígidos (ex: circuitos RLC).",
                                "Engenharia: Controle de sistemas dinâmicos em aeronáutica.",
                                "Computação Científica: Otimização de solvers ODE."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional), onde rigidez surge de escalas múltiplas, ajusta h para estabilidade em turbulência, evitando crash de simulações em aviões ou previsão climática."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Detectar perda de estabilidade monotônica",
                            "description": "Monitorar o crescimento da solução numérica comparado à analítica em problemas modelo para reduzir h proativamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de estabilidade monotônica",
                                  "subSteps": [
                                    "Defina estabilidade monotônica como a propriedade onde a solução numérica mantém o comportamento não oscilatório e decrescente da solução analítica em problemas modelo com autovalores negativos.",
                                    "Estude exemplos clássicos, como a EDO y' = -y, cuja solução analítica é y(t) = y0 * e^{-t}.",
                                    "Analise gráficos de soluções numéricas instáveis que exibem crescimento exponencial ou overshoot.",
                                    "Compare com estabilidade absoluta e relativa para diferenciar os conceitos.",
                                    "Revise literatura sobre métodos multietapa (ex: Adams-Bashforth) e suas regiões de estabilidade."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre estabilidade monotônica e oscilatória, com um esboço gráfico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Artigos sobre estabilidade em EDOs",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Use animações online de soluções numéricas para visualizar perdas de estabilidade.",
                                  "learningObjective": "Compreender os fundamentos teóricos da estabilidade monotônica em métodos numéricos.",
                                  "commonMistakes": "Confundir monotônica com estabilidade A-estável; ignorar o papel do passo h na ampliação de erros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar problema modelo e solução analítica",
                                  "subSteps": [
                                    "Escolha um problema modelo simples: y' = λ y, com λ real negativo (ex: λ = -1), condição inicial y(0) = 1.",
                                    "Derive a solução analítica exata: y(t) = e^{λ t}.",
                                    "Calcule valores analíticos em pontos discretos t_n = n h para vários h iniciais.",
                                    "Implemente uma função em Python/MATLAB para gerar a solução analítica em uma grade temporal.",
                                    "Valide a implementação comparando com soluções conhecidas."
                                  ],
                                  "verification": "Gere uma tabela com 10 pontos de y_analítica e confirme que decresce monotonicamente para 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "MATLAB ou Octave",
                                    "Planilha Excel para validação"
                                  ],
                                  "tips": "Comece com h pequeno (0.01) para garantir precisão inicial.",
                                  "learningObjective": "Preparar referências analíticas precisas para comparação com soluções numéricas.",
                                  "commonMistakes": "Escolher λ complexo prematuramente; erros de arredondamento na exponencial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar monitoramento da solução numérica",
                                  "subSteps": [
                                    "Implemente um método multietapa (ex: Adams-Bashforth de ordem 2) para resolver o problema modelo.",
                                    "Monitore a norma ||y_n|| ou |y_n| em cada passo n.",
                                    "Compare |y_num_n| com |y_anal_n| calculando o ratio r_n = |y_num_n| / |y_anal_n|.",
                                    "Registre o crescimento: detecte se r_n > 1 + ε (ε=0.01) ou se Δ|y_num| > 0 em regiões decrescentes.",
                                    "Plote y_num vs t e y_anal vs t para visualização."
                                  ],
                                  "verification": "Execute simulação com h=0.5 e observe gráfico mostrando crescimento anormal em y_num.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python (NumPy, Matplotlib)",
                                    "Código-fonte de métodos multietapa",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use logs para ||y|| em problemas com decaimento rápido.",
                                  "learningObjective": "Desenvolver código para monitorar discrepâncias entre numérico e analítico.",
                                  "commonMistakes": "Não inicializar corretamente os passos iniciais do método multietapa; escalas erradas nos gráficos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar perda e ajustar h proativamente",
                                  "subSteps": [
                                    "Defina critérios de detecção: se r_n > 1.05 ou |y_num_n| > |y_num_{n-1}| em 3 passos consecutivos.",
                                    "Implemente lógica de redução: h_new = 0.8 * h_old se perda detectada.",
                                    "Reinicie a integração com h reduzido a partir do último passo estável.",
                                    "Teste iterativamente com h inicial variando de 0.1 a 2.0.",
                                    "Documente logs de detecções e ajustes."
                                  ],
                                  "verification": "Simule até t=5; confirme que h foi reduzido pelo menos uma vez e y_num segue y_anal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código do passo 3 estendido",
                                    "Debugger (pdb ou VSCode)"
                                  ],
                                  "tips": "Adicione tolerância adaptativa baseada no histórico de ratios.",
                                  "learningObjective": "Automatizar detecção e correção de perda de estabilidade monotônica.",
                                  "commonMistakes": "Reduzir h excessivamente causando rigidez; ignorar reinicialização de histórico multietapa."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e analisar o processo completo",
                                  "subSteps": [
                                    "Compare erro global ||y_num - y_anal||_∞ antes/depois dos ajustes.",
                                    "Teste com problemas modelo variados (ex: λ=-10 para rigidez).",
                                    "Analise eficiência: número total de passos vs precisão.",
                                    "Gere relatório com gráficos de h(t), r_n(t) e erros.",
                                    "Discuta limitações para métodos multietapa específicos."
                                  ],
                                  "verification": "Erro final < 1e-3 e sem crescimento observado em plots.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código completo",
                                    "Ferramentas de plotagem avançada (ex: Plotly)"
                                  ],
                                  "tips": "Automatize testes com loop sobre múltiplos λ.",
                                  "learningObjective": "Avaliar a eficácia do monitoramento proativo na manutenção da estabilidade.",
                                  "commonMistakes": "Focar só em um h; não considerar custo computacional dos ajustes."
                                }
                              ],
                              "practicalExample": "Resolva y' = -y, y(0)=1 até t=5 com Adams-Bashforth ordem 2, h inicial=1.0. Monitore |y_num|: em n=3, |y_num|≈0.72 > |y_anal|≈0.67 (r>1.07), reduza h para 0.8, reinicie; continue até erro<1e-3 sem crescimento.",
                              "finalVerifications": [
                                "Solução numérica decai monotonicamente como analítica em todos os plots.",
                                "Pelo menos uma redução de h foi acionada proativamente.",
                                "Erro global < 1% da norma analítica.",
                                "Logs mostram ratios r_n ≤ 1.05 após ajustes.",
                                "Eficiência: passos totais < 2x sem controle.",
                                "Teste passou para dois problemas modelo diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: falsos positivos/negativos <5%.",
                                "Correção do código: simulação roda sem erros numéricos.",
                                "Eficiência do ajuste: redução de h restaura monotonia em ≤2 iterações.",
                                "Análise qualitativa: explicação clara de causas da perda.",
                                "Visualizações: gráficos legíveis com anotações de eventos.",
                                "Generalização: funciona para λ variando em [-1,-10]."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de decaimento radioativo ou amortecimento.",
                                "Computação: Algoritmos adaptativos em SciPy ODE solvers.",
                                "Engenharia: Controle de estabilidade em simulações CFD.",
                                "Estatística: Monitoramento de resíduos em séries temporais."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou farmacocinéticas, detecta instabilidades em solvers multietapa para EDOs rígidas, ajustando h automaticamente para previsões precisas sem crashes, economizando tempo computacional em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Detecção e Tratamento de Problemas Stiff em Métodos Multietapa",
                        "description": "Estratégias específicas para identificar rigidez em equações diferenciais e adaptar o controle de passo, frequentemente alternando para métodos implicitos multietapa como BDF.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Identificar rigidez via controle de passo",
                            "description": "Detectar quando o h é drasticamente reduzido apesar de erro pequeno, indicando escalas temporais rígidas em problemas com autovalores reais negativos grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Controle de Passo e Problemas Stiff",
                                  "subSteps": [
                                    "Estude a fórmula de controle de passo em métodos Runge-Kutta ou multietapa: h_new = h_old * (tol / err)^{1/(p+1)} onde err é o erro local estimado.",
                                    "Defina rigidez: presença de escalas temporais muito diferentes, caracterizada por autovalores reais negativos grandes em magnitude no espectro de Jacobiano.",
                                    "Compare problemas stiff vs non-stiff: em non-stiff, h varia suavemente; em stiff, h diminui abruptamente.",
                                    "Analise o papel do erro local truncado (err) no ajuste de h.",
                                    "Liste indicadores iniciais de rigidez: número de passos explode ou h < 1e-6 apesar de tol moderada."
                                  ],
                                  "verification": "Resuma em um parágrafo os mecanismos de controle de passo e defina rigidez com exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)",
                                    "Notebook com Python (biblioteca scipy.integrate)"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar o algoritmo de controle de passo.",
                                  "learningObjective": "Compreender como o controle de passo detecta implicitamente rigidez via redução excessiva de h.",
                                  "commonMistakes": "Confundir erro local com erro global; ignorar que rigidez surge de autovalores, não só de h pequeno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Observar Comportamento do Controle de Passo em Problemas Numéricos",
                                  "subSteps": [
                                    "Implemente um solver adaptativo simples (ex: RK45) em Python ou MATLAB para um problema non-stiff como y' = -y.",
                                    "Execute para um problema potencialmente stiff: y' = -1000 y, y(0)=1, no intervalo [0,1].",
                                    "Registre e plote h vs t e err vs t, usando solve_ivp com eventos para logar passos.",
                                    "Identifique padrões: se h cai para <1e-8 apesar de err << tol (ex: tol=1e-6), suspeite de rigidez.",
                                    "Repita com problema non-stiff para contraste: h deve estabilizar em valor razoável."
                                  ],
                                  "verification": "Gere plots de h(t) e err(t); confirme redução drástica de h com err pequeno em stiff.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com scipy e matplotlib",
                                    "Ou MATLAB com ode45 e outputfcn"
                                  ],
                                  "tips": "Ative logging detalhado no solver para capturar h e err a cada passo.",
                                  "learningObjective": "Observar empiricamente o sinal diagnóstico: h drasticamente reduzido apesar de err pequeno.",
                                  "commonMistakes": "Não normalizar err corretamente; usar tol muito pequena mascarando o problema."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Espectro de Autovalores para Confirmar Rigidez",
                                  "subSteps": [
                                    "Compute o Jacobiano f_y do sistema (para escalar, df/dy).",
                                    "Para problema linear y'=A y, liste autovalores de A; foque em Re(λ) << -1/Lipschitz.",
                                    "Para não-linear, linearize em pontos chave e estime autovalores via eigenvalue decomposition.",
                                    "Calcule razão de rigidez ρ = |λ_max / λ_min| onde λ reais negativos; se ρ >>1, confirma stiff.",
                                    "Compare com observação de h: se min(h) << 1/|λ_max|, rigidez detectada."
                                  ],
                                  "verification": "Calcule autovalores e razão de rigidez; relacione com min(h) observado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com numpy.linalg.eig",
                                    "Papel para linearização manual"
                                  ],
                                  "tips": "Para sistemas lineares constantes, use diretamente A; senão, avalie em equilíbrio.",
                                  "learningObjective": "Vincular observação prática (controle de passo) à teoria espectral de rigidez.",
                                  "commonMistakes": "Esquecer autovalores complexos; confundir autovalores de A vs A transpose."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Detecção em Exemplos Mistos e Sintetizar Critérios",
                                  "subSteps": [
                                    "Teste 3 problemas: um non-stiff, um stiff linear, um stiff não-linear (ex: y'=-1000(y-sin(t))).",
                                    "Para cada, rode solver, log h/err, compute espectro, classifique como rígido ou não.",
                                    "Crie tabela comparativa: min(h), max(|Re(λ)|), decisão de rigidez.",
                                    "Discuta falsos positivos: oscilações vs rigidez verdadeira.",
                                    "Documente protocolo de detecção: 'Se h reduz >10x apesar err<0.1 tol, cheque espectro.'"
                                  ],
                                  "verification": "Classifique corretamente 3 exemplos com tabela e justificativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Códigos dos steps anteriores",
                                    "Planilha para tabela"
                                  ],
                                  "tips": "Varie tol para ver robustez da detecção.",
                                  "learningObjective": "Desenvolver protocolo acionável para identificar rigidez via controle de passo.",
                                  "commonMistakes": "Atribuir rigidez a ruído numérico; não testar múltiplos intervalos de tempo."
                                }
                              ],
                              "practicalExample": "Resolva y' = -1000*(y - sin(t)), y(0)=1 em [0, 5] com RK45 e tol=1e-6. Observe h inicial ~0.01 cai para ~1e-10 em t~0.001 apesar de err~1e-8 << tol, confirmando rigidez pelo autovalor ~ -1000.",
                              "finalVerifications": [
                                "Explica corretamente o mecanismo: h_new ~ tol^{1/p} / |λ|^{1/p} para stiff.",
                                "Identifica rigidez em plots de h(t) com redução abrupta e err pequeno.",
                                "Calcula autovalores corretamente e interpreta razão de rigidez.",
                                "Classifica exemplos mistos com acurácia >90%.",
                                "Propõe tratamento: alternar para método implícito como BDF.",
                                "Documenta protocolo pessoal de detecção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de logs de solver (h vs err).",
                                "Correção no cálculo e análise espectral.",
                                "Capacidade de distinguir stiff de non-stiff em exemplos.",
                                "Clareza na tabela comparativa e conclusões.",
                                "Profundidade das justificativas teóricas.",
                                "Eficiência no tempo de execução e logging."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de EDOs em dinâmica molecular stiff.",
                                "Engenharia de Controle: detecção de modos rápidos em sistemas lineares.",
                                "Ciência da Computação: otimização de solvers adaptativos.",
                                "Química Computacional: reações com escalas rápidas/lentas."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos com capacitores/indutores (EDOs stiff por constantes de tempo díspares), detecta necessidade de solvers implícitos como Radau, evitando explosão de custo computacional em design de chips ou redes elétricas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Alternar para métodos implicitos multietapa",
                            "description": "Implementar troca dinâmica de métodos explícitos (Adams-Bashforth) para implícitos (Adams-Moulton ou BDF) com solucionadores lineares como GMRES para problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Detectar Problemas Stiff e Definir Critérios de Alternância",
                                  "subSteps": [
                                    "Estude as características de problemas stiff em EDOs, como razão de escalas de tempo e Lipschitz constante elevada.",
                                    "Implemente testes de detecção: Lipschitz estimado via diferenças finitas e análise de erro local em passos explícitos.",
                                    "Defina critérios de alternância: se erro local > tolerância ou passos rejeitados > threshold, sinalize para implícito.",
                                    "Codifique uma função de diagnóstico que monitore resíduos e rigidez em tempo real.",
                                    "Teste com EDO não-stiff vs. stiff (ex: y' = -1000y + sin(t))."
                                  ],
                                  "verification": "Função detecta corretamente stiff em benchmark, gerando log com métricas de rigidez.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Python/NumPy/SciPy",
                                    "Documentação SciPy.integrate",
                                    "Exemplos de EDOs stiff (van der Pol)"
                                  ],
                                  "tips": "Use logs em escala para visualizar razões de eigenvalues; inicie com métodos simples como backward Euler para validação.",
                                  "learningObjective": "Identificar e quantificar rigidez para decisões adaptativas em solucionadores.",
                                  "commonMistakes": [
                                    "Subestimar Lipschitz sem diferenças finitas",
                                    "Ignorar rejeições de passo como sinal",
                                    "Não normalizar resíduos por escala da solução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Método Implícito Multietapa (Adams-Moulton ou BDF)",
                                  "subSteps": [
                                    "Revise fórmulas: Adams-Moulton de ordem k usa predictor (Adams-Bashforth) e corretor implícito.",
                                    "Codifique predictor-corrector: compute y_pred, resolva sistema linear para y_new.",
                                    "Para BDF: implemente fórmula implícita γ y_n - α y_{n-1} + ... = h f(t_n, y_n).",
                                    "Estruture como função reutilizável com ordem variável (2-5).",
                                    "Integre histórico de passos para coeficientes multistep."
                                  ],
                                  "verification": "Método converge monotonicamente em EDO linear stiff simples (y' = -λ y, λ>>1).",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Código base de Adams-Bashforth",
                                    "Livro 'Numerical Methods for ODEs' (Hairer)",
                                    "MATLAB/Python solver para referência"
                                  ],
                                  "tips": "Comece com ordem baixa (k=2) para debug; use Jacobiano aproximado se analítico indisponível.",
                                  "learningObjective": "Construir esquemas implícitos estáveis para rigidez sem resolver Jacobiano completo.",
                                  "commonMistakes": [
                                    "Erro no sinal dos coeficientes multistep",
                                    "Não iterar corretor até convergência",
                                    "Perder histórico ao rejeitar passos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Solucionador Linear Iterativo (GMRES)",
                                  "subSteps": [
                                    "Configure sistema linear: J Δy = r, onde J é Jacobiano implícito, r resíduo do predictor.",
                                    "Implemente GMRES from scratch ou use SciPy.sparse.linalg.gmres.",
                                    "Estime Jacobiano via finite differences: J ≈ (f(t,y+εe_i) - f(t,y))/ε.",
                                    "Defina tolerâncias: atol, rtol para GMRES, pré-condicionador diagonal simples.",
                                    "Monitore iterações GMRES e fallback para método direto se > max_iter."
                                  ],
                                  "verification": "GMRES resolve sistema com <50 iterações e resíduo <1e-10 em teste stiff.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "SciPy.sparse.linalg",
                                    "Tutorial GMRES (Saad)",
                                    "Benchmark matrices stiff (ex: Robertson chemical)"
                                  ],
                                  "tips": "Escolha ε ~ sqrt(eps) * norm(y); teste pré-condicionadores ILU se disponível.",
                                  "learningObjective": "Aplicar métodos Krylov eficientes para sistemas lineares grandes oriundos de métodos implícitos.",
                                  "commonMistakes": [
                                    "Jacobiano impreciso por ε inadequado",
                                    "Não reiniciar GMRES em passos aceitos",
                                    "Ignorar breakdown numérico em ortogonalização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Troca Dinâmica e Controle de Passo Integrado",
                                  "subSteps": [
                                    "Crie lógica condicional: se stiff detectado, mude para implícito e ajuste ordem/h.",
                                    "Implemente controle de passo adaptativo: h_new = h * (tol/err)^{1/(k+1)}, com segurança 0.9.",
                                    "Gerencie estado: salve histórico explícito/implícito separadamente, reconverta se necessário.",
                                    "Adicione hysteresis: permaneça implícito até não-stiff por N passos.",
                                    "Teste ciclo completo: start explícito -> stiff -> implícito -> resolve."
                                  ],
                                  "verification": "Simulação completa alterna corretamente, com passos eficientes e erro global <1e-6.",
                                  "estimatedTime": "2-4 hours",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Test suite ODE stiff (SuiteTest)",
                                    "Profiler (timeit)"
                                  ],
                                  "tips": "Logue switches e iterações GMRES; otimize para overhead mínimo em não-stiff.",
                                  "learningObjective": "Desenvolver solucionador adaptativo robusto para regimes mistos stiff/non-stiff.",
                                  "commonMistakes": [
                                    "h muito agressivo pós-switch",
                                    "Perda de precisão em histórico misto",
                                    "Loop infinito em alternâncias"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um solucionador para o problema químico de Robertson: y1' = -0.04 y1 + 1e4 y2 y3, y2' = 0.04 y1 - 1e4 y2 y3 - 3e7 y2^2, y3' = 3e7 y2^2. Inicie com Adams-Bashforth ordem 4; ao detectar stiff (após t~1e-3), alterne para BDF2 com GMRES, resolvendo com Jacobiano FD e tol=1e-8. Compare solução com ode15s (MATLAB) ou solve_ivp(method='BDF').",
                              "finalVerifications": [
                                "Código detecta stiff e alterna sem crash em benchmarks.",
                                "Número total de f-evals < 2x de solver referência.",
                                "Erro global L2 < 1e-5 vs. solução exata/referência.",
                                "GMRES converge em <100 iterações médios.",
                                "Passos h adaptam corretamente (pequenos em stiff, grandes em smooth).",
                                "Logs mostram switches apropriados sem oscilação excessiva."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro <1e-6 em solução final.",
                                "Eficiência: f-evals e tempo <150% de método fixo implícito.",
                                "Robustez: sem falhas em 5 problemas stiff variados.",
                                "Adaptatividade: switches ocorrem no momento correto (±10% t_detect).",
                                "Escalabilidade: GMRES eficiente para dim(y)>100.",
                                "Clareza: código modular com comentários e testes unitários."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Algoritmos iterativos e programação científica.",
                                "Física: Simulações dinâmicas stiff (eletromagnetismo, mecânica quântica).",
                                "Engenharia Química: Modelos cinéticos reacionais stiff.",
                                "Matemática Aplicada: Análise de estabilidade e erro em ODEs."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular (rigidez por escalas atômicas), controle de processos industriais (reatores químicos), ou previsão meteorológica (equações Navier-Stokes discretizadas), onde alternância dinâmica permite eficiência computacional em problemas com regimes transitórios stiff."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Aplicar critérios de detecção de stiff",
                            "description": "Usar testes baseados na razão de h rejeitados/aceitos ou na rigidez estimada pelo espectro aproximado para ativar modos anti-stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de problemas stiff e critérios de detecção",
                                  "subSteps": [
                                    "Revise a definição de equações diferenciais stiff: sistemas com escalas de tempo muito díspares (componentes rápidos e lentos).",
                                    "Estude a razão de passos rejeitados/aceitos (h-rejected/accepted ratio): valores altos (> 0.5) indicam possível stiff.",
                                    "Aprenda sobre estimativa do espectro aproximado: usar autovalores de Jacobiana ou análise de erro local para rigidez (max(Re(λ)) * Δt >> 1).",
                                    "Identifique modos anti-stiff: switching para métodos implicitos como BDF ou redução de ordem.",
                                    "Compare critérios qualitativamente com exemplos teóricos simples."
                                  ],
                                  "verification": "Resuma em um parágrafo os critérios e dê um exemplo onde stiff ocorre.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notas de aula sobre ODEs stiff.",
                                  "tips": "Use diagramas de fase para visualizar comportamentos stiff vs non-stiff.",
                                  "learningObjective": "Dominar definições e thresholds típicos para detecção de stiff.",
                                  "commonMistakes": "Confundir stiff com oscilações normais ou ignorar dependência no método multietapa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o teste da razão de passos rejeitados/aceitos",
                                  "subSteps": [
                                    "No código do solver multietapa, adicione contadores para passos aceitos e rejeitados durante o controle de passo.",
                                    "Calcule a razão r = rejeitados / (aceitos + rejeitados) a cada N passos (N=10).",
                                    "Defina threshold: se r > 0.5 por 3 iterações consecutivas, sinalize stiff.",
                                    "Registre logs ou plots da razão ao longo da integração.",
                                    "Teste com um problema não-stiff para validar baseline (r < 0.1)."
                                  ],
                                  "verification": "Execute simulação e confirme que razão é computada corretamente em log/output.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/MATLAB com solver ODE (scipy.integrate, ode45), problema teste como y' = -1000y + sin(t).",
                                  "tips": "Use janela móvel para razão para suavizar flutuações.",
                                  "learningObjective": "Implementar quantitativamente o primeiro critério de detecção.",
                                  "commonMistakes": "Não resetar contadores após switch de método ou dividir por zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar estimativa do espectro aproximado para rigidez",
                                  "subSteps": [
                                    "Aproxime a Jacobiana numérica do sistema f(y,t) via diferenças finitas.",
                                    "Compute autovalores da Jacobiana usando eigendecomposição.",
                                    "Estime rigidez como ρ = Δt * max(|Re(λ_i)|) onde λ_i são autovalores.",
                                    "Defina threshold: se ρ > 10, sinalize stiff (ajustar por método).",
                                    "Integre com o teste anterior: sinalize se qualquer critério falha."
                                  ],
                                  "verification": "Compare autovalores com valores analíticos conhecidos e verifique ρ.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Bibliotecas numpy/scipy para Jacobiana e eigvals, mesmo problema teste.",
                                  "tips": "Use Jacobiana esparsa se sistema grande para eficiência.",
                                  "learningObjective": "Aplicar análise espectral para detecção quantitativa de stiff.",
                                  "commonMistakes": "Erro numérico em Jacobiana fina ou ignorar parte imaginária em oscilações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ativar modos anti-stiff baseado nos critérios e validar",
                                  "subSteps": [
                                    "Se qualquer teste positivo, switch para método implícito (ex: de Adams explícito para BDF).",
                                    "Monitore razão pós-switch: deve cair < 0.1.",
                                    "Implemente fallback: se persistir, reduza tolerância ou ordem.",
                                    "Compare soluções com solver de referência (ex: ode15s).",
                                    "Documente decisão em relatório com métricas pré/pós-detecção."
                                  ],
                                  "verification": "Solução converge sem crashes e matches referência (erro < 1e-3).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Solver adaptável como CVODE ou MATLAB ode23s.",
                                  "tips": "Teste com problema clássico stiff como van der Pol μ=1000.",
                                  "learningObjective": "Integrar detecção com adaptação automática do solver.",
                                  "commonMistakes": "Switch prematuro em problemas borderline ou não reverter se falso positivo."
                                }
                              ],
                              "practicalExample": "Em um sistema químico de reação rígida y' = -1000(y-1) + exp(-t), usando Adams-Bashforth ordem 4: após 20 passos, razão rejeitada=15/20=0.75 e ρ=50 >10. Ative BDF ordem 2: razão cai para 0.05, solução estável.",
                              "finalVerifications": [
                                "Razão rejeitada/aceita corretamente computada e threshold respeitado.",
                                "Espectro aproximado matches analítico dentro de 10%.",
                                "Switch anti-stiff ativa apenas quando necessário, sem falsos positivos.",
                                "Solução final converge com erro relativo <1e-4 vs referência.",
                                "Logs mostram monitoramento contínuo durante toda integração.",
                                "Código modular permite fácil teste em novos problemas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação dos dois critérios (razão e espectro).",
                                "Eficiência: detecção em <5% do tempo total de simulação.",
                                "Robustez: funciona em 3 problemas stiff de tamanhos variados.",
                                "Documentação clara de thresholds e decisões.",
                                "Análise de sensibilidade a parâmetros como Δt inicial.",
                                "Comparação quantitativa pré/pós-detecção (estabilidade, custo computacional)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RLC stiff em eletrônica.",
                                "Química: Simulações de cinética de reações com escalas rápidas/lentas.",
                                "Computação: Otimização numérica e análise de autovalores em ML.",
                                "Engenharia: Controle de sistemas dinâmicos com rigidez (ex: aerodinâmica)."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos GCM com atmosferas stiff), detecção automática previne crashes em previsões de furacões; ou em farmacocinética para modelar drogas com decaimento rápido, garantindo precisão em dosagens."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.4",
                            "name": "Simular problemas stiff com controle adaptativo",
                            "description": "Resolver numericamente EDOs stiff como y' = -1000(y-1) + sin(t), demonstrando eficiência do controle de passo adaptado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Configurar o Problema Stiff",
                                  "subSteps": [
                                    "Defina um problema EDO stiff clássico, como y' = -1000(y - 1) + sin(t), com y(0) = 0.",
                                    "Analise a rigidez: calcule autovalores da Jacobiana para confirmar escalas de tempo díspares.",
                                    "Escolha intervalo de simulação, ex: t de 0 a 10.",
                                    "Implemente a função f(t,y) em código.",
                                    "Teste com método explícito simples (ex: Euler) para observar instabilidade."
                                  ],
                                  "verification": "O método explícito falha (explosão ou NaN) enquanto solução analítica aproximada é estável.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com NumPy, SciPy; editor de código (Jupyter Notebook).",
                                  "tips": "Plote soluções em log-scale para visualizar rigidez.",
                                  "learningObjective": "Identificar características de problemas stiff e preparar setup inicial.",
                                  "commonMistakes": "Ignorar condição inicial ou usar passos fixos grandes demais inicialmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Método Multietapa sem Controle Adaptativo",
                                  "subSteps": [
                                    "Escolha um método implícito multietapa para stiff, ex: Backward Differentiation Formula (BDF2).",
                                    "Derive a fórmula: y_{n+1} = y_n + h*( (3/2)y'_{n+1} - 2y'_n + (1/2)y'_{n-1} ).",
                                    "Resolva sistema linear por Newton-Raphson ou fsolve.",
                                    "Aplique com passo fixo h=0.01 em todo intervalo.",
                                    "Gere gráfico da solução."
                                  ],
                                  "verification": "Solução converge sem oscilações, mas eficiência baixa (muitos passos necessários).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com NumPy, SciPy (solve_ivp para baseline), Matplotlib.",
                                  "tips": "Use Jacobiana analítica para acelerar Newton.",
                                  "learningObjective": "Dominar implementação básica de métodos multietapa para stiff.",
                                  "commonMistakes": "Erro na linearização ou não inicializar iterações de Newton adequadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar Detecção de Stiffness e Controle de Passo Adaptativo",
                                  "subSteps": [
                                    "Implemente estimador de erro local usando solução embedded (ex: BDF2 com BDF1).",
                                    "Defina tolerância: erro < tol (1e-6), fator de segurança 0.9.",
                                    "Crie rotina de controle: se erro > tol, rejeite e reduza h *= 0.5; senão aceite e h *= 1.2 (limitado).",
                                    "Inclua detecção de stiff: monitore razão de rejeições ou ||J||.",
                                    "Integre ao solver multietapa."
                                  ],
                                  "verification": "Número de passos reduzido em comparação ao fixo, com erro global < 1e-4.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Mesmo que anterior; adicione logging para passos rejeitados.",
                                  "tips": "Limite redução/aumento de h para evitar loops (ex: h_min=1e-6).",
                                  "learningObjective": "Desenvolver controle adaptativo para eficiência em stiff.",
                                  "commonMistakes": "Fator de segurança muito agressivo causando rejeições excessivas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, Comparar e Analisar Eficiência",
                                  "subSteps": [
                                    "Execute simulação adaptativa no exemplo y' = -1000(y-1)+sin(t).",
                                    "Compare com passo fixo: plote soluções, erros, número de passos e CPU time.",
                                    "Calcule eficiência: passos totais e tempo vs. precisão.",
                                    "Teste sensibilidade variando lambda (-1000 para -10000).",
                                    "Documente observações em relatório."
                                  ],
                                  "verification": "Adaptativo usa <50% dos passos do fixo com precisão similar.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Matplotlib para plots comparativos; pandas para tabela de métricas.",
                                  "tips": "Use %timeit para medir tempo real.",
                                  "learningObjective": "Demonstrar superioridade do controle adaptativo quantitativamente.",
                                  "commonMistakes": "Comparação injusta sem normalizar precisão."
                                }
                              ],
                              "practicalExample": "Implemente em Python o solver adaptativo BDF2 para y' = -1000(y - sin(t)) + cos(t), y(0)=0, t∈[0,5]. Compare com solve_ivp('BDF') do SciPy: adaptativo deve resolver em ~100 passos vs. 500 fixos, capturando oscilação suave em y≈sin(t).",
                              "finalVerifications": [
                                "Solução numérica converge para y(t) ≈ sin(t) no steady-state.",
                                "Número de passos adaptativos < 60% do fixo para tol=1e-6.",
                                "Taxa de rejeição < 20%, sem blow-up.",
                                "Erro global L2 < 1e-4 em [0,10].",
                                "Gráficos mostram eficiência em stiff crescente (lambda=-5000).",
                                "Código roda sem erros em <10s."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação do método multietapa (correção da fórmula).",
                                "Efetividade do controle adaptativo (redução de passos comprovada).",
                                "Análise quantitativa de eficiência (tabelas/plots).",
                                "Tratamento robusto de stiff (testes variados).",
                                "Clareza do código e documentação.",
                                "Identificação correta de erros comuns em stiff."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de reações químicas stiff (equações de Van der Pol).",
                                "Computação: Otimização numérica e solvers em bibliotecas como SciPy.",
                                "Engenharia: Simulações em circuitos elétricos com parasitas.",
                                "Estatística: Análise de erro em métodos adaptativos."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular ou circuitos integrados, onde escalas rígidas (ex: difusão vs. reações rápidas) exigem solvers adaptativos para eficiência computacional em larga escala, como em software COMSOL ou ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Estabilidade",
                "description": "Análise da estabilidade dos métodos numéricos aplicados a equações diferenciais.",
                "totalSkills": 44,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Definição de Estabilidade Numérica",
                    "description": "Conceito formal de estabilidade para métodos numéricos aplicados a equações diferenciais ordinárias.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Problema Modelo para Análise de Estabilidade",
                        "description": "O problema de valor inicial y' = λ y com y(0) = 1 serve como modelo canônico para investigar o comportamento assintótico de métodos numéricos aplicados a equações diferenciais ordinárias lineares, revelando modos de crescimento ou decaimento exponencial.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Entender a Solução Exata do Problema Modelo",
                            "description": "Derivar e interpretar a solução analítica y(t) = exp(λ t), destacando o papel do valor próprio complexo λ no crescimento ou decaimento da solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema Modelo y' = λ y",
                                  "subSteps": [
                                    "Identifique o problema diferencial linear de primeira ordem: y' = λ y, onde λ é uma constante complexa.",
                                    "Reconheça que este é o problema modelo para análise de estabilidade em métodos numéricos.",
                                    "Defina as condições iniciais y(0) = 1 para simplificar a solução para y(t) = exp(λ t).",
                                    "Explique verbalmente o que representa o crescimento ou decaimento da solução.",
                                    "Esboce graficamente o comportamento qualitativo para λ positivo e negativo."
                                  ],
                                  "verification": "Escreva a equação do problema e descreva seu significado em um parágrafo curto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora científica, livro-texto de equações diferenciais.",
                                  "tips": "Sempre normalize y(0)=1 para focar na dinâmica exponencial pura.",
                                  "learningObjective": "Entender a formulação exata do problema modelo e seu contexto em estabilidade numérica.",
                                  "commonMistakes": "Confundir com problemas não lineares ou ignorar o papel de λ como autovalor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Solução Analítica y(t) = exp(λ t)",
                                  "subSteps": [
                                    "Separe variáveis: dy/y = λ dt.",
                                    "Integre ambos os lados: ∫(1/y) dy = λ ∫ dt.",
                                    "Aplique a condição inicial y(0)=1 para obter ln|y| = λ t + C, logo y(t) = exp(λ t).",
                                    "Verifique diferenciando: confirme que y'(t) = λ exp(λ t) = λ y(t).",
                                    "Expresse exp(λ t) em termos reais se λ complexo: exp((a+bi)t) = e^{a t} (cos(b t) + i sin(b t))."
                                  ],
                                  "verification": "Derive a solução passo a passo e verifique por diferenciação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, software simbólico como Mathematica ou SymPy (opcional).",
                                  "tips": "Use a definição de exponencial como série de Taylor para intuição: exp(z) = Σ z^k / k!.",
                                  "learningObjective": "Dominar a derivação analítica da solução exata.",
                                  "commonMistakes": "Esquecer a constante de integração ou aplicar incorretamente a condição inicial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o Papel de λ Real no Crescimento/Decaimento",
                                  "subSteps": [
                                    "Para λ > 0 real: y(t) cresce exponencialmente (instável).",
                                    "Para λ < 0 real: y(t) decai para 0 (estável).",
                                    "Calcule exemplos numéricos: plote y(t) para λ=1 e λ=-1 em t=0 a 5.",
                                    "Discuta o fator de amplificação |y(t)/y(0)| = exp(λ t).",
                                    "Relacione com estabilidade numérica: solução exata dita o benchmark para métodos aproximados."
                                  ],
                                  "verification": "Gere gráficos ou tabela de valores mostrando crescimento/decaimento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfica online (Desmos/GeoGebra), Excel para tabelas.",
                                  "tips": "Pense em termos de taxa de crescimento: λ é a taxa instantânea.",
                                  "learningObjective": "Analisar qualitativa e quantitativamente o impacto de λ real.",
                                  "commonMistakes": "Ignorar o sinal de λ ou confundir com o módulo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar λ Complexo e Oscilações Amortecidas",
                                  "subSteps": [
                                    "Decomponha λ = a + b i, onde a = Re(λ), b = Im(λ).",
                                    "Mostre que |y(t)| = exp(a t), determinando crescimento (a>0), decaimento (a<0) ou persistência (a=0).",
                                    "Descreva oscilações via cos(b t) e sin(b t) se b ≠ 0.",
                                    "Exemplo: λ = -0.1 + 2i → amortecimento oscilatório.",
                                    "Conclua: estabilidade depende apenas de Re(λ) < 0."
                                  ],
                                  "verification": "Escreva a forma polar de y(t) para um λ complexo dado e interprete.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora complexa, software de plotagem 2D.",
                                  "tips": "Visualize no plano complexo: espiral para fora (instável) ou para dentro (estável).",
                                  "learningObjective": "Compreender o papel dominante da parte real de λ em soluções complexas.",
                                  "commonMistakes": "Atribuir estabilidade à parte imaginária em vez da real."
                                }
                              ],
                              "practicalExample": "Considere λ = -0.5 + 3i. Derive y(t) = exp((-0.5 + 3i)t) = e^{-0.5 t} [cos(3t) + i sin(3t)]. Plote |y(t)| decaindo e fase oscilando, simulando um oscilador amortecido como um circuito RLC.",
                              "finalVerifications": [
                                "Derivação correta de y(t) = exp(λ t) a partir de y' = λ y.",
                                "Interpretação precisa: Re(λ) < 0 implica decaimento, >0 crescimento.",
                                "Exemplo numérico com λ complexo mostrando amortecimento oscilatório.",
                                "Verificação por diferenciação: y'(t) = λ y(t).",
                                "Conexão explícita com estabilidade numérica do problema modelo.",
                                "Gráfico qualitativo ou tabela confirmando comportamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação analítica (sem erros algébricos).",
                                "Correta interpretação do papel de Re(λ) vs. Im(λ).",
                                "Uso de exemplos concretos com cálculos numéricos.",
                                "Clareza na explicação verbal do crescimento/decaimento.",
                                "Aplicação ao contexto de análise de estabilidade numérica.",
                                "Qualidade de visualizações (gráficos/tabelas)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de decaimento radioativo (λ real negativo) ou osciladores harmônicos (λ imaginário puro).",
                                "Engenharia: Análise de estabilidade em sistemas de controle lineares.",
                                "Biologia: Crescimento populacional exponencial com taxa λ.",
                                "Computação: Compreensão de autovalores em análise numérica de EDOs."
                              ],
                              "realWorldApplication": "Em simulações numéricas de epidemias (SIR models), entender exp(λ t) ajuda a prever se uma doença explode (Re(λ)>0) ou desaparece (Re(λ)<0), guiando políticas públicas; em finanças, modela crescimento composto de investimentos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Identificar Modos Instáveis no Problema Modelo",
                            "description": "Reconhecer que para Re(λ) < 0, a solução tende a zero, mas componentes numéricos parasitas podem crescer se o método não for estável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Problema Modelo e o Comportamento da Solução Exata",
                                  "subSteps": [
                                    "Revise o problema modelo: y' = λ y, com y(0) = 1, onde λ é um escalar complexo.",
                                    "Calcule a solução exata: y(t) = e^{λ t}.",
                                    "Analise o comportamento para Re(λ) < 0: a solução tende a zero à medida que t → ∞.",
                                    "Discuta a importância da estabilidade: soluções devem imitar o comportamento exato.",
                                    "Identifique que instabilidades numéricas surgem de componentes parasitas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que a solução exata decai para Re(λ) < 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de estabilidade)",
                                    "Papel e caneta para cálculos"
                                  ],
                                  "tips": "Sempre comece com a solução exata para estabelecer o benchmark de estabilidade.",
                                  "learningObjective": "Compreender o decaimento natural da solução exata no problema modelo.",
                                  "commonMistakes": [
                                    "Confundir Re(λ) < 0 com crescimento da solução exata",
                                    "Ignorar o papel do tempo t → ∞"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Aproximações Numéricas e Componentes Parasitas",
                                  "subSteps": [
                                    "Estude métodos numéricos lineares, como o método de Euler forward: y_{n+1} = y_n + h λ y_n = (1 + h λ) y_n.",
                                    "Identifique modos parasitas: componentes na solução numérica não presentes na exata, como erros de arredondamento ou truncamento.",
                                    "Analise o fator de amplificação: |1 + h λ| para Euler forward.",
                                    "Observe que para Re(λ) < 0, se |1 + h λ| > 1, parasitas crescem.",
                                    "Compare com solução exata: |e^{h λ}| < 1 para estabilidade."
                                  ],
                                  "verification": "Calcule o fator de amplificação para h λ = -1 + i e verifique se |1 + h λ| > 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/MATLAB para computar módulo complexo",
                                    "Notas de aula sobre métodos de Euler"
                                  ],
                                  "tips": "Use o plano complexo para visualizar regiões de estabilidade.",
                                  "learningObjective": "Reconhecer origens de componentes numéricos parasitas em aproximações.",
                                  "commonMistakes": [
                                    "Assumir que Re(λ) < 0 garante estabilidade numérica",
                                    "Não calcular o módulo do fator de amplificação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Condições para Modos Instáveis",
                                  "subSteps": [
                                    "Defina modo instável: componente parasita cujo fator de amplificação tem módulo > 1.",
                                    "Para Re(λ) < 0, verifique se o método numérico satisfaz |g(h λ)| ≤ 1, onde g é o fator de amplificação.",
                                    "Examine exemplos: Euler forward é instável para Re(λ) < 0 se h |λ| > 2.",
                                    "Discuta von Neumann analysis para métodos lineares multi-step.",
                                    "Classifique: instável se parasitas crescem apesar de solução exata decaindo."
                                  ],
                                  "verification": "Dada uma λ com Re(λ) = -1 e h=1, determine se o modo é instável para Euler forward.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de fatores de amplificação de métodos comuns",
                                    "Gráfico da região de estabilidade de Euler"
                                  ],
                                  "tips": "Lembre-se: estabilidade numérica requer imitação do decaimento exato.",
                                  "learningObjective": "Identificar precisamente quando um modo é instável no problema modelo.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com estabilidade para Re(λ) < 0",
                                    "Ignorar efeitos de h pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Exemplos Simples",
                                  "subSteps": [
                                    "Resolva numericamente y' = -y com y(0)=1 usando Euler forward com h=0.1 e h=2.",
                                    "Plote soluções e observe crescimento parasita para h grande.",
                                    "Identifique o modo instável: componente com |1 + h λ| > 1.",
                                    "Compare com método estável como backward Euler.",
                                    "Registre condições para instabilidade."
                                  ],
                                  "verification": "Gere gráfico mostrando crescimento parasita e explique o modo instável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Código template para simulação"
                                  ],
                                  "tips": "Use logs para visualizar crescimento exponencial de parasitas.",
                                  "learningObjective": "Aplicar identificação de modos instáveis em simulações práticas.",
                                  "commonMistakes": [
                                    "Não inicializar com ruído para excitar parasitas",
                                    "Escolher h muito pequeno, mascarando instabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema y' = -y + ε (ruído parasita inicial pequeno), usando Euler forward com h=2, λ=-1: fator 1 + hλ = -1, | -1 | =1 (marginal), mas com Im(λ) pequeno, |1 + hλ| >1 leva a oscilações crescentes, identificando modo instável.",
                              "finalVerifications": [
                                "Explicar por que Re(λ)<0 não garante estabilidade numérica.",
                                "Calcular fator de amplificação para dado hλ e classificar estabilidade.",
                                "Identificar parasitas em solução numérica plotada.",
                                "Diferenciar solução exata de componentes instáveis.",
                                "Propor ajuste de h para estabilizar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de modo instável (100% match com conceito).",
                                "Cálculos corretos de |g(hλ)| (erro <1%).",
                                "Análise qualitativa de plots numéricos.",
                                "Identificação correta de parasitas vs. solução exata.",
                                "Explicação clara de condições Re(λ)<0 vs. instabilidade.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em equações diferenciais de difusão/reação.",
                                "Engenharia: Análise de controle e simulações CFD.",
                                "Computação: Análise de erros em algoritmos numéricos.",
                                "Estatística: Propagação de erros de arredondamento."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou previsão do tempo, métodos instáveis amplificam erros de arredondamento, levando a previsões divergentes; identificar modos instáveis garante simulações confiáveis em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Relacionar o Problema Modelo com EDOs Gerais",
                            "description": "Explicar como o problema linear local y' = λ y aproxima equações diferenciais lineares não homogêneas via linearização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema Modelo y' = λ y",
                                  "subSteps": [
                                    "Estude a solução exata do problema modelo: y(t) = y(0) e^{λ t}.",
                                    "Analise o comportamento assintótico dependendo do sinal de Re(λ).",
                                    "Discuta o papel do problema modelo na análise local de estabilidade de métodos numéricos.",
                                    "Resolva numericamente o problema modelo com um método simples (ex: Euler) e compare com a solução exata.",
                                    "Identifique condições de estabilidade para o método aplicado ao modelo."
                                  ],
                                  "verification": "Resolva o problema modelo analiticamente e numéricamente, plotando gráficos que mostrem convergência ou divergência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno, calculadora ou software como Python/MATLAB com bibliotecas numpy/scipy.",
                                  "tips": "Sempre normalize a solução inicial para y(0)=1 para facilitar comparações.",
                                  "learningObjective": "Compreender a dinâmica básica do problema modelo e sua relevância para estabilidade.",
                                  "commonMistakes": "Confundir estabilidade do método com estabilidade da EDO; ignorar o papel do passo h."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Linearização de EDOs",
                                  "subSteps": [
                                    "Defina linearização para funções não-lineares: f(y) ≈ f(y*) + f'(y*)(y - y*).",
                                    "Aplique à EDO geral y' = f(t,y): linearização local ao redor de uma solução y*(t).",
                                    "Derive a equação para o erro e(t) = y(t) - y*(t): e' ≈ f_y(t, y*)(e).",
                                    "Explique por que isso reduz a uma aproximação pelo problema modelo com λ = f_y(t*, y*).",
                                    "Verifique com um exemplo não-linear simples, como y' = y(1 - y)."
                                  ],
                                  "verification": "Escreva a linearização para uma EDO dada e mostre que o erro satisfaz aproximadamente y' = λ y.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livro de EDOs (ex: Boyce-DiPrima), papel e lápis, software de plotagem.",
                                  "tips": "Escolha y* como equilíbrio estacionário para simplificar (λ constante).",
                                  "learningObjective": "Dominar a técnica de linearização e sua justificativa matemática.",
                                  "commonMistakes": "Linearizar incorretamente o termo f(t,y); esquecer a dependência em t."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Linearização a EDOs Lineares Não-Homogêneas",
                                  "subSteps": [
                                    "Considere y' = A(t) y + g(t); encontre uma solução particular yp(t).",
                                    "Defina o erro e = y - yp; derive e' = A(t) e.",
                                    "Aproxime localmente A(t) ≈ A(t*) constante, reduzindo a y' = λ y para autovalor λ.",
                                    "Discuta casos escalares: y' = a(t) y + g(t) ≈ λ y para o erro.",
                                    "Resolva um exemplo numérico e compare comportamentos."
                                  ],
                                  "verification": "Para uma EDO linear não-homogênea dada, derive a equação de erro e mostre a aproximação pelo modelo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software numérico (MATLAB/Python), exemplos de EDOs lineares.",
                                  "tips": "Use variação de parâmetros para yp se necessário, mas foque no erro homogêneo.",
                                  "learningObjective": "Relacionar EDOs lineares não-homogêneas ao problema modelo via análise de erro.",
                                  "commonMistakes": "Confundir solução total com equação de erro; assumir A constante globalmente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com Análise de Estabilidade Numérica",
                                  "subSteps": [
                                    "Explique que a estabilidade local truncada usa o problema modelo para testar métodos.",
                                    "Aplique um método numérico (ex: Runge-Kutta) à linearização e verifique região de estabilidade.",
                                    "Compare estabilidade para EDO geral vs. modelo linearizado.",
                                    "Discuta limitações: validade local e para soluções não próximas de y*.",
                                    "Conclua com teorema de estabilidade local truncada."
                                  ],
                                  "verification": "Teste um método numérico em uma EDO linearizada e confirme que se comporta como no modelo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código pronto para métodos numéricos, gráficos de regiões de estabilidade.",
                                  "tips": "Use λ com parte real negativa para simular estabilidade inata.",
                                  "learningObjective": "Integrar linearização à análise de estabilidade numérica.",
                                  "commonMistakes": "Ignorar o fator hλ na condição de estabilidade; generalizar local para global."
                                }
                              ],
                              "practicalExample": "Considere a EDO linear não-homogênea y' = -2y + sin(t). Encontre yp(t) = (1/5) sin(t) - (2/5) cos(t). O erro e = y - yp satisfaz e' = -2e. Linearize localmente em t*=0, y*(0)=0: λ = -2. Aplique Euler com h=0.1 e verifique estabilidade comparando com solução exata.",
                              "finalVerifications": [
                                "Derive corretamente a linearização para uma EDO linear não-homogênea arbitrária.",
                                "Explique verbalmente como o problema modelo aproxima o comportamento local.",
                                "Resolva numericamente um exemplo e plote erros para diferentes h.",
                                "Identifique quando a aproximação falha (ex: solução longe de y*).",
                                "Relacione com definição de estabilidade numérica A.",
                                "Discuta impacto de autovalores complexos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da linearização (100% correta).",
                                "Clareza na explicação da relação com o problema modelo.",
                                "Correção nos testes numéricos e interpretação de resultados.",
                                "Identificação de limitações e erros comuns.",
                                "Capacidade de generalizar para sistemas lineares.",
                                "Uso adequado de notação matemática."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RLC lineares e análise de estabilidade.",
                                "Engenharia: Simulações em controle de sistemas dinâmicos.",
                                "Computação: Implementação de solvers numéricos em Python/Octave.",
                                "Biologia: Modelos populacionais lineares com forçantes externas."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou financeiras, lineariza-se EDOs não-lineares ao redor de trajetórias previstas para testar estabilidade de integradores numéricos, evitando explosões numéricas em previsões de longo prazo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Aplicação de Métodos de Passo Único ao Problema Modelo",
                        "description": "Análise da recursão numérica gerada por métodos explícitos e implícitos, como Euler forward e backward, aplicada ao problema y' = λ y.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Derivar a Recursão para o Método de Euler Explícito",
                            "description": "Obter a relação y_{n+1} = y_n + h λ y_n = (1 + h λ) y_n e analisar seu fator de amplificação |1 + h λ|.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema Modelo e o Método de Euler Explícito",
                                  "subSteps": [
                                    "Lembre-se do problema teste y' = λ y, com condição inicial y(0) = y₀, onde λ é um escalar complexo.",
                                    "Escreva a solução exata: y(t) = y₀ e^{λ t}.",
                                    "Descreva o método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n), onde h é o passo de tempo.",
                                    "Identifique f(t, y) = λ y para este problema modelo.",
                                    "Discuta o propósito: analisar estabilidade numérica."
                                  ],
                                  "verification": "Escreva corretamente o problema modelo e a fórmula geral de Euler em um papel.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, lápis, livro de análise numérica ou notas de aula",
                                  "tips": "Use notação consistente para y_n e t_n = n h.",
                                  "learningObjective": "Compreender o contexto do problema modelo e a aplicação inicial do método de Euler.",
                                  "commonMistakes": "Confundir Euler explícito com implícito; esquecer que f é independente de t aqui."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o Método de Euler ao Problema Modelo",
                                  "subSteps": [
                                    "Substitua f(t_n, y_n) = λ y_n na fórmula de Euler.",
                                    "Escreva y_{n+1} = y_n + h λ y_n.",
                                    "Fatore o termo comum: y_{n+1} = y_n (1 + h λ).",
                                    "Verifique a derivação algebricamente expandindo ambos os lados.",
                                    "Confirme que t_n não aparece explicitamente na recursão."
                                  ],
                                  "verification": "Derive e escreva y_{n+1} = y_n + h λ y_n sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, calculadora para testes numéricos simples",
                                  "tips": "Destaque o fator (1 + h λ) imediatamente após a substituição.",
                                  "learningObjective": "Aplicar corretamente o esquema de Euler explícito ao problema linear y' = λ y.",
                                  "commonMistakes": "Esquecer o h na aproximação; fatorar incorretamente como y_n + h λ em vez de multiplicativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Solução Iterativa da Recursão",
                                  "subSteps": [
                                    "Reconheça a recursão como y_{n+1} = R y_n, onde R = 1 + h λ.",
                                    "Itere: y_1 = R y_0, y_2 = R^2 y_0, ..., y_n = R^n y_0.",
                                    "Compare com a solução exata y(t_n) = e^{λ t_n} y_0 = e^{λ n h} y_0.",
                                    "Identifique R^n como aproximação numérica de e^{λ n h}.",
                                    "Anote que a estabilidade depende de |R| ≤ 1."
                                  ],
                                  "verification": "Escreva y_n = (1 + h λ)^n y_0 corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, lápis, software como Mathematica ou Python para verificação opcional",
                                  "tips": "Use indução para provar a iteração: assuma para n, prove para n+1.",
                                  "learningObjective": "Obter a forma fechada da recursão e ligá-la à solução exata.",
                                  "commonMistakes": "Confundir o expoente n com t_n; ignorar que λ pode ser complexo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Fator de Amplificação |1 + h λ|",
                                  "subSteps": [
                                    "Defina o fator de amplificação ρ = |1 + h λ|.",
                                    "Discuta estabilidade: ρ ≤ 1 para não amplificar erros.",
                                    "Para λ real negativo (rigidez), encontre condição h |λ| ≤ 1.",
                                    "Plote no plano complexo z = h λ: região |1 + z| ≤ 1.",
                                    "Conclua que Euler explícito é condicionalmente estável."
                                  ],
                                  "verification": "Calcule ρ para um valor exemplo e interprete se estável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para gráfico, GeoGebra ou Python para plotar região de estabilidade",
                                  "tips": "Visualize o disco unitário no plano h λ para intuição.",
                                  "learningObjective": "Analisar o fator de amplificação e suas implicações para estabilidade.",
                                  "commonMistakes": "Usar |1 + h λ| em vez de módulo absoluto corretamente; ignorar parte imaginária de λ."
                                }
                              ],
                              "practicalExample": "Para y' = -10 y, y(0)=1, h=0.05: y_{n+1} = (1 - 0.5) y_n = 0.5 y_n, ρ = 0.5 <1 (estável); se h=0.2, ρ=1.0 (marginal). Compute y_5 e compare com exata e^{-0.5}.",
                              "finalVerifications": [
                                "Escreve y_{n+1} = (1 + h λ) y_n sem erros.",
                                "Deriva y_n = (1 + h λ)^n y_0 corretamente.",
                                "Calcula |1 + h λ| para λ=-1, h=0.1 (resultado: 0.9).",
                                "Explica verbalmente o papel do fator de amplificação na estabilidade.",
                                "Identifica condição de estabilidade h < 2/|λ| para λ real negativo.",
                                "Compara recursão numérica com solução exata e^{λ n h}."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da recursão (100% correto).",
                                "Correta identificação e cálculo do fator |1 + h λ|.",
                                "Compreensão conceitual da relação com estabilidade (explicação clara).",
                                "Uso correto de notação matemática e iteração.",
                                "Análise qualitativa da região de estabilidade.",
                                "Aplicação em exemplo numérico sem erros aritméticos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Euler em Python para simular y' = λ y.",
                                "Física: Modelagem de decaimento radioativo ou circuitos RC.",
                                "Engenharia: Análise de estabilidade em simulações CFD.",
                                "Computação Científica: Comparação com métodos implícitos."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais em engenharia (ex: propagação de ondas, dinâmica de fluidos), derivar e analisar fatores de amplificação garante estabilidade, evitando explosões numéricas em previsões climáticas ou modelagem financeira de processos estocásticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Analisar a Recursão para Métodos Implícitos",
                            "description": "Derivar y_{n+1} = y_n + h λ y_{n+1} para Euler implícito, resultando em y_{n+1} = y_n / (1 - h λ), e discutir sua estabilidade incondicional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema Modelo e Formulação do Euler Implícito",
                                  "subSteps": [
                                    "Relembre o problema teste y' = λ y com y(0) = 1, onde λ é complexo com parte real negativa.",
                                    "Descreva o método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n) = (1 + h λ) y_n.",
                                    "Introduza o Euler implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}) = y_n + h λ y_{n+1}.",
                                    "Explique por que é implícito: requer solução de equação em y_{n+1}.",
                                    "Discuta o contexto de estabilidade para EDOs rígidas."
                                  ],
                                  "verification": "Escreva corretamente a equação implícita y_{n+1} = y_n + h λ y_{n+1} e explique sua natureza implícita.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Livro-texto de Análise Numérica (cap. estabilidade)",
                                    "Calculadora"
                                  ],
                                  "tips": "Desenhe o passo no plano complexo para visualizar o fator de amplificação.",
                                  "learningObjective": "Compreender a formulação matemática do método de Euler implícito para o problema modelo.",
                                  "commonMistakes": [
                                    "Confundir com Euler explícito (usar f(t_n, y_n) em vez de f(t_{n+1}, y_{n+1})",
                                    "Esquecer que λ pode ser complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Recursão Explícita para y_{n+1}",
                                  "subSteps": [
                                    "Parta da equação: y_{n+1} = y_n + h λ y_{n+1}.",
                                    "Isole termos com y_{n+1}: y_{n+1} - h λ y_{n+1} = y_n.",
                                    "Fatore y_{n+1}: y_{n+1} (1 - h λ) = y_n.",
                                    "Resolva para y_{n+1}: y_{n+1} = y_n / (1 - h λ).",
                                    "Verifique algebricamente substituindo de volta na equação original."
                                  ],
                                  "verification": "Derive e escreva y_{n+1} = y_n / (1 - h λ) sem erros algébricos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora simbólica ou software como SymPy (opcional)"
                                  ],
                                  "tips": "Trate h λ como uma variável única (z = h λ) para simplificar a álgebra.",
                                  "learningObjective": "Dominar a resolução algébrica da recursão implícita para obter a forma explícita.",
                                  "commonMistakes": [
                                    "Erro de sinal: escrever 1 + h λ em vez de 1 - h λ",
                                    "Dividir incorretamente pelo denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Fator de Amplificação e Estabilidade",
                                  "subSteps": [
                                    "Identifique o fator de amplificação R(h λ) = 1 / (1 - h λ).",
                                    "Calcule |R(z)| onde z = h λ, para Re(λ) < 0.",
                                    "Mostre que |1 / (1 - z)| ≤ 1 para Re(z) > 0 (pois |1 - z| ≥ 1 - Re(z) > 1? Ajuste: para Re(λ)<0, z no semiplano esquerdo).",
                                    "Prove que |R(z)| < 1 se Re(z) < 0, e =1 apenas se Im(z)=0 e z=0.",
                                    "Conclua que a região de estabilidade é o semiplano esquerdo inteiro."
                                  ],
                                  "verification": "Esboce a região de estabilidade no plano complexo e justifique |R(z)| ≤ 1 para todo h > 0 quando Re(λ) < 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para gráfico no plano z",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)"
                                  ],
                                  "tips": "Use o triângulo de Moulton ou argumento geométrico: distância de z a 1 é maior que 1 para Re(z)<0.",
                                  "learningObjective": "Analisar matematicamente a estabilidade absoluta do método.",
                                  "commonMistakes": [
                                    "Confundir com Euler explícito (disco unitário)",
                                    "Ignorar parte imaginária de λ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Estabilidade Incondicional e Comparações",
                                  "subSteps": [
                                    "Defina estabilidade incondicional: estável para qualquer h > 0 quando Re(λ) < 0.",
                                    "Compare com Euler explícito: restrito a |1 + z| ≤ 1 (disco esquerdo).",
                                    "Discuta vantagens: permite passos maiores em problemas rígidos.",
                                    "Mencione desvantagens: requer solução linear/implícita por passo.",
                                    "Exemplo numérico: simule com λ = -100, h=0.1 vs h=1."
                                  ],
                                  "verification": "Explique em parágrafo por que é incondicionalmente estável e dê um exemplo numérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Computador com Python/Octave para simulação simples",
                                    "Tabela de valores"
                                  ],
                                  "tips": "Implemente uma iteração rápida em código para testar.",
                                  "learningObjective": "Interpretar implicações práticas da estabilidade incondicional.",
                                  "commonMistakes": [
                                    "Achar que é sempre estável, ignorando λ com Re>0",
                                    "Não comparar com métodos explícitos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere y' = -50 y, y(0)=1, h=0.1. Para Euler implícito: y1 = 1 / (1 - 0.1*(-50)) = 1/6 ≈0.1667 (exato ~0.1649). Repita para 10 passos: solução permanece estável e decai, enquanto Euler explícito com h=0.05 oscila e explode para h maiores.",
                              "finalVerifications": [
                                "Deriva corretamente y_{n+1} = y_n / (1 - h λ).",
                                "Identifica R(z) = 1/(1-z) e sua região de estabilidade.",
                                "Explica estabilidade incondicional para Re(λ)<0.",
                                "Compara com Euler explícito.",
                                "Fornece exemplo numérico sem erros.",
                                "Discute limitações práticas."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação (100% correta).",
                                "Correta análise do módulo |R(z)| e prova geométrica/analítica.",
                                "Clareza na discussão de estabilidade incondicional vs condicional.",
                                "Exemplo prático com cálculos numéricos exatos.",
                                "Conexões com aplicações reais e comparações.",
                                "Ausência de erros comuns como confusão explícito/implícito."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (NumPy/SciPy) para simulações de EDOs.",
                                "Física: Modelagem de decaimento radioativo ou circuitos RC rígidos.",
                                "Engenharia Computacional: Otimização de passos em solvers de PDEs.",
                                "Estatística: Análise de estabilidade em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações de sistemas rígidos como reações químicas em cinética (e.g., modelos Michaelis-Menten estendidos) ou dinâmica de circuitos elétricos, onde escalas de tempo variam muito; permite passos h grandes sem instabilidade, acelerando computações em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Comparar Comportamento Assintótico dos Métodos",
                            "description": "Comparar o decaimento da solução numérica com a exata, identificando condições sob as quais a solução numérica diverge.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema Modelo e Solução Exata",
                                  "subSteps": [
                                    "Defina o problema de teste y' = λ y com Re(λ) < 0 e y(0) = y0.",
                                    "Derive a solução exata y(t) = y0 exp(λ t), destacando o decaimento exponencial para t → ∞.",
                                    "Discuta o comportamento assintótico: |y(t)| → 0 à medida que t aumenta.",
                                    "Calcule exemplos numéricos para λ = -1 e t = [0,1,2,5] para visualizar o decaimento.",
                                    "Identifique o papel do passo h no contexto numérico."
                                  ],
                                  "verification": "Escreva a solução exata e plote manualmente ou graficamente o decaimento para confirmar compreensão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora ou planilha (Excel/Google Sheets)",
                                  "tips": "Use λ real negativo inicialmente para simplificar; expanda para complexo depois.",
                                  "learningObjective": "Compreender o decaimento assintótico da solução exata como benchmark.",
                                  "commonMistakes": "Confundir crescimento com decaimento; ignorar parte imaginária de λ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Recursões Numéricas para Métodos de Passo Único",
                                  "subSteps": [
                                    "Escreva a recursão para Euler Explícito: y_{n+1} = y_n + h λ y_n = (1 + h λ) y_n.",
                                    "Derive para Euler Implícito: y_{n+1} = y_n + h λ y_{n+1}, resolvendo para y_{n+1} = y_n / (1 - h λ).",
                                    "Inclua método de Heun ou Runge-Kutta de ordem 2 para comparação.",
                                    "Identifique o fator de amplificação r = 1 + h λ (explícito) e r = 1 / (1 - h λ) (implícito).",
                                    "Analise |r| < 1 para decaimento assintótico."
                                  ],
                                  "verification": "Escreva as recursões corretas e compute |r| para h λ = -0.5 e -2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, software simbólico como SymPy ou MATLAB",
                                  "tips": "Fatore h λ como z para generalizar; foque em |z| pequeno ou grande.",
                                  "learningObjective": "Derivar recursões e identificar fatores de amplificação.",
                                  "commonMistakes": "Erro de sinal no Euler Implícito; esquecer de resolver para y_{n+1}."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Comportamento Assintótico Analiticamente",
                                  "subSteps": [
                                    "Para Euler Explícito, mostre que se |1 + z| > 1 (z = h λ), y_n diverge oscilatoriamente.",
                                    "Para Euler Implícito, prove que |r| ≤ 1 para Re(z) < 0, garantindo decaimento.",
                                    "Compare com solução exata: exp(z) ≈ 1 + z para z pequeno.",
                                    "Identifique condições: Explícito estável só se |1 + z| ≤ 1 (região |z| ≤ 2 para λ real).",
                                    "Discuta divergência: quando |r| > 1, ||y_n|| → ∞ apesar de solução exata → 0."
                                  ],
                                  "verification": "Desenhe o plano complexo z e regiões onde |r| > 1 para cada método.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel quadriculado, software de plotagem (Python Matplotlib ou Desmos)",
                                  "tips": "Use desigualdades triangulares para bounds em |r|.",
                                  "learningObjective": "Identificar condições analíticas de divergência assintótica.",
                                  "commonMistakes": "Confundir estabilidade A-estável (implícito) com condicional (explícito)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Numericamente e Comparar Comportamentos",
                                  "subSteps": [
                                    "Implemente as recursões em código para T=10, n=1000 passos (h=T/n).",
                                    "Teste para z = h λ = -0.1 (estável explícito), -1.5 (estável), -3 (divergente explícito).",
                                    "Plote y_num vs y_exata vs n ou t para ambos métodos.",
                                    "Meça erro relativo ||y_n|| / |y_exata| e observe divergência.",
                                    "Varie λ ou h para confirmar condições teóricas."
                                  ],
                                  "verification": "Gere plots mostrando decaimento exato vs divergência numérica em casos instáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (NumPy, Matplotlib) ou MATLAB/Octave",
                                  "tips": "Use loop simples; logscale para y pequeno; fixe y0=1.",
                                  "learningObjective": "Validar análise teórica via simulação e visualização.",
                                  "commonMistakes": "Overflow numérico; h muito pequeno causando underflow."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Condições de Divergência e Conclusões",
                                  "subSteps": [
                                    "Compile tabela: Método | z estável | Comportamento assintótico.",
                                    "Explique por que explícito diverge para |z| > 2 mesmo h→0 se λ fixo grande.",
                                    "Discuta trade-offs: Explícito simples mas instável; Implícito A-estável mas implícito.",
                                    "Relacione com definição de estabilidade numérica de Dahlquist.",
                                    "Proponha método adaptativo (diminuir h se |r|>1)."
                                  ],
                                  "verification": "Escreva relatório de 1 página resumindo comparações e condições.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Processador de texto ou notebook Jupyter",
                                  "tips": "Use |r| >1 como critério prático de instabilidade.",
                                  "learningObjective": "Sintetizar insights sobre quando soluções numéricas divergem.",
                                  "commonMistakes": "Ignorar que h→0 não salva se z fixo fora da região."
                                }
                              ],
                              "practicalExample": "Para y' = -10 y, y(0)=1 (λ=-10, decaimento rápido). Use Euler Explícito com h=0.3 (z=-3): |1+z|=2>1, y_n cresce para ∞. Euler Implícito: |r|=1/|1-(-3)|=0.25<1, decai como exata. Plote até t=2 mostrando divergência explícita vs convergência implícita.",
                              "finalVerifications": [
                                "Pode derivar recursão e fator r para qualquer método de passo único.",
                                "Identifica corretamente regiões de estabilidade no plano z.",
                                "Simulações mostram divergência numérica vs decaimento exato.",
                                "Explica condições sob as quais numérico diverge apesar de exato decaindo.",
                                "Compara comportamentos assintóticos para pelo menos 3 valores de z.",
                                "Propõe soluções práticas para instabilidade (ex: método diferente)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de recursões e fatores de amplificação (20%).",
                                "Correta identificação de condições de |r|>1 e divergência (25%).",
                                "Qualidade de plots/simulações comparando numérico vs exato (20%).",
                                "Análise assintótica clara e quantitativa (15%).",
                                "Síntese de insights e conexões com estabilidade numérica (10%).",
                                "Uso apropriado de ferramentas e verificações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Física: Modelagem de decaimento radioativo ou amortecimento onde estabilidade afeta simulações longas.",
                                "Engenharia: Simulações CFD ou circuitos onde h grande causa instabilidade.",
                                "Estatística: Análise de erros em métodos Monte Carlo aproximados."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou financeiras (ex: modelos de Black-Scholes), métodos instáveis como Euler explícito divergem em horizontes longos, levando a previsões errôneas; usar implícito garante estabilidade para decaimentos reais como atenuação de ondas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1",
                              "10.1.4.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Definição Formal de Estabilidade Numérica",
                        "description": "Conceito de estabilidade absoluta para métodos de um passo: um método é estável se, para h λ no semiplano esquerdo estável, o fator de amplificação satisfaz |R(h λ)| ≤ 1, onde R(z) é o polinômio de estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Definir o Polinômio de Estabilidade R(z)",
                            "description": "Introduzir R(z) como a função que gera a recursão y_{n+1} = R(h λ) y_n para métodos lineares, com base no teorema de Dahlquist.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Problema Modelo para Estabilidade",
                                  "subSteps": [
                                    "Estude a equação diferencial ordinária (EDO) teste y' = λ y, onde λ é um escalar complexo.",
                                    "Analise a solução exata y(t) = y(0) exp(λ t), destacando o comportamento exponencial.",
                                    "Discuta por que este modelo é usado para testar estabilidade em métodos numéricos.",
                                    "Identifique condições de estabilidade absoluta (Re(λ) < 0 implica |y_n| → 0).",
                                    "Anote as implicações para passos de tempo h em simulações numéricas."
                                  ],
                                  "verification": "Escreva a solução exata e explique verbalmente por que ela é o benchmark para estabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno e caneta",
                                  "tips": "Visualize graficamente o decaimento exponencial para λ com parte real negativa.",
                                  "learningObjective": "Compreender o papel do problema modelo y' = λ y na análise de estabilidade.",
                                  "commonMistakes": "Confundir estabilidade absoluta com estabilidade relativa; assumir λ sempre real."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Recursão Numérica Linear",
                                  "subSteps": [
                                    "Considere métodos numéricos lineares aplicados a y' = λ y, resultando em y_{n+1} = R(h λ) y_n.",
                                    "Explique que R(z) é uma função racional ou polinomial derivada do método (z = h λ).",
                                    "Derive explicitamente para o método de Euler forward: R(z) = 1 + z.",
                                    "Calcule alguns passos manualmente para um λ exemplo e observe o crescimento ou decaimento.",
                                    "Compare com a solução exata exp(z) ≈ R(z) para pequenos z."
                                  ],
                                  "verification": "Compute y_1, y_2 para hλ = -1 usando Euler e verifique se |y_n| diminui.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou software como Python/MATLAB, exemplos impressos",
                                  "tips": "Use z complexo para capturar oscilações; teste com |R(z)| >1 para instabilidade.",
                                  "learningObjective": "Reconhecer a recursão y_{n+1} = R(hλ) y_n como base para definição de R(z).",
                                  "commonMistakes": "Esquecer que hλ = z é adimensional; confundir R com a solução exata."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente o Polinômio de Estabilidade R(z)",
                                  "subSteps": [
                                    "Defina R(z) como o polinômio (ou função de amplificação) tal que y_{n+1} = R(z) y_n satisfaz a recursão local do método.",
                                    "Estabeleça que para métodos multistep lineares, R(z) vem da equação característica.",
                                    "Discuta propriedades: R(0) = 1 (consistência), grau relacionado à ordem do método.",
                                    "Ilustre com Euler backward: R(z) = 1 / (1 - z).",
                                    "Verifique estabilidade: região {z : |R(z)| ≤ 1} no plano complexo."
                                  ],
                                  "verification": "Escreva a definição formal de R(z) e dê exemplos para dois métodos simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado para plano z, referências teóricas",
                                  "tips": "Desenhe o plano z e sombreie a região de estabilidade preliminarmente.",
                                  "learningObjective": "Definir precisamente R(z) como gerador da recursão numérica.",
                                  "commonMistakes": "Chamar R(z) de 'polinômio' sem notar que pode ser racional em métodos implícitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar com o Teorema de Dahlquist",
                                  "subSteps": [
                                    "Enuncie o teorema de Dahlquist: ordem p implica R(z) = 1 + z + O(z^{p+1}).",
                                    "Explique implicações para estabilidade: métodos explícitos têm região limitada.",
                                    "Compare R(z) para métodos explícito vs. implícito.",
                                    "Discuta A-stabilidade: |R(z)| ≤ 1 para Re(z) ≤ 0.",
                                    "Resuma como R(z) determina a estabilidade global via Dahlquist."
                                  ],
                                  "verification": "Prove para Euler forward que ordem 1 satisfaz Dahlquist e tem instabilidade para z reais negativos grandes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Notas de aula, teorema impresso",
                                  "tips": "Lembre: Dahlquist liga consistência e estabilidade via R(z).",
                                  "learningObjective": "Integrar a definição de R(z) ao framework teórico de Dahlquist.",
                                  "commonMistakes": "Ignorar que Dahlquist é para métodos lineares multistep; confundir ordem com estabilidade."
                                }
                              ],
                              "practicalExample": "Para o método de Euler forward em y' = -y (λ=-1), com h=0.5 (z=-0.5), R(z)=1-0.5=0.5. Então y1=0.5 y0, y2=0.25 y0, simulando decaimento estável; para h=2 (z=-2), R(z)=-1, oscilações instáveis.",
                              "finalVerifications": [
                                "Defina R(z) corretamente para Euler forward e backward.",
                                "Calcule |R(z)| para z=-2+i e interprete estabilidade.",
                                "Enuncie ligação com recursão y_{n+1}=R(z)y_n.",
                                "Explique papel no teorema de Dahlquist.",
                                "Desenhe região de estabilidade aproximada para Euler.",
                                "Compare R(z) com exp(z) para z pequeno."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de R(z) e recursão.",
                                "Correção em derivações para métodos exemplo.",
                                "Compreensão de |R(z)| ≤1 como critério de estabilidade.",
                                "Integração correta com teorema de Dahlquist.",
                                "Capacidade de gerar exemplos numéricos acionáveis.",
                                "Identificação de regiões de instabilidade no plano z."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar simulações em Python para plotar |R(z)|.",
                                "Física: Aplicar em equações de difusão/reação com λ complexo.",
                                "Engenharia: Análise de estabilidade em controle de sistemas dinâmicos.",
                                "Computação Científica: Bibliotecas como SciPy para validar R(z)."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional), R(z) garante que perturbações numéricas não amplifiquem em problemas rígidos, evitando crashes em previsões meteorológicas ou design aeroespacial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Estabelecer Critério de Estabilidade Absoluta",
                            "description": "Definir que o método é absolutamente estável para z = h λ se |R(z)| ≤ 1, e estável se isso vale para todo z no semiplano Re(z) ≤ 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de estabilidade em métodos numéricos para EDOs",
                                  "subSteps": [
                                    "Recordar o problema modelo y' = λ y, com solução exata y_n = y_0 e^{z n}, onde z = h λ.",
                                    "Explicar por que a estabilidade é crucial para passos de tempo h grandes em problemas rígidos.",
                                    "Discutir a diferença entre estabilidade absoluta e estabilidade relativa.",
                                    "Analisar numericamente um exemplo simples com λ real negativo para ilustrar instabilidade.",
                                    "Derivar a recursão numérica geral para métodos lineares: y_{n+1} = R(z) y_n."
                                  ],
                                  "verification": "Capacidade de derivar a recursão y_{n+1} = R(z) y_n a partir do método numérico e explicar seu significado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), caderno de anotações, calculadora.",
                                  "tips": "Comece com o método de Euler explícito para visualizar instabilidade rapidamente.",
                                  "learningObjective": "Compreender o papel da estabilidade na precisão de soluções numéricas de longo prazo.",
                                  "commonMistakes": "Confundir estabilidade com consistência ou confundir λ com h."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir e calcular a função de amplificação R(z)",
                                  "subSteps": [
                                    "Definir R(z) como o fator de amplificação na recursão linear y_{n+1} = R(z) y_n.",
                                    "Calcular R(z) para métodos simples: Euler forward R(z) = 1 + z; Euler backward R(z) = 1 / (1 - z).",
                                    "Plotar |R(z)| no plano complexo usando software como Python/Matplotlib ou papel.",
                                    "Analisar o comportamento de |R(z)| para z com Re(z) < 0.",
                                    "Verificar que para estabilidade, precisamos |R(z)| ≤ 1 para evitar crescimento exponencial."
                                  ],
                                  "verification": "Computar R(z) corretamente para pelo menos dois métodos e esboçar a região |R(z)| ≤ 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software Python com NumPy/Matplotlib, exemplos de métodos numéricos impressos.",
                                  "tips": "Use z = x + i y para visualizar a região de estabilidade no plano complexo.",
                                  "learningObjective": "Dominar o cálculo e interpretação da função de amplificação R(z).",
                                  "commonMistakes": "Esquecer o denominador em métodos implícitos ou plotar Re(R(z)) em vez de |R(z)|."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e aplicar o critério de estabilidade absoluta para z fixo",
                                  "subSteps": [
                                    "Estabelecer formalmente: o método é absolutamente estável para z se |R(z)| ≤ 1.",
                                    "Testar o critério em exemplos: para Euler forward, instável se |1 + z| > 1.",
                                    "Demonstrar com z = -2 (Re(z)<0): calcular |R(z)| para diferentes métodos.",
                                    "Explicar implicações: se |R(z)| > 1, solução numérica explode mesmo se exata decai.",
                                    "Resolver exercício: determinar valores de h para os quais um método é estável para λ dado."
                                  ],
                                  "verification": "Aplicar o critério corretamente em um z específico e justificar estabilidade/instabilidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exercícios impressos, calculadora científica, plano complexo desenhado.",
                                  "tips": "Sempre compute |R(z)|^2 = R(z) \bar{R(\bar{z})} para precisão numérica.",
                                  "learningObjective": "Aplicar o critério de estabilidade absoluta de forma precisa para pontos isolados.",
                                  "commonMistakes": "Confundir estabilidade absoluta com A-estabilidade ou ignorar parte imaginária de z."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender para definição de estabilidade no semiplano esquerdo",
                                  "subSteps": [
                                    "Definir método estável se |R(z)| ≤ 1 para todo z com Re(z) ≤ 0.",
                                    "Exemplificar: Euler backward é A-estável (região inclui semiplano esquerdo).",
                                    "Discutir região de estabilidade absoluta: conjunto {z : |R(z)| ≤ 1}.",
                                    "Analisar implicações para problemas rígidos (λ com Re(λ) << 0).",
                                    "Comparar métodos: Trapezoidal é A-estável, mas não L-estável."
                                  ],
                                  "verification": "Descrever verbalmente a definição e identificar métodos A-estáveis em uma lista.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Tabela de regiões de estabilidade de métodos comuns, software para plots.",
                                  "tips": "Lembre-se: estabilidade no semiplano esquerdo garante h arbitrariamente grande para rigidez.",
                                  "learningObjective": "Formular e diferenciar estabilidade absoluta pontual de estabilidade global no semiplano.",
                                  "commonMistakes": "Pensar que |R(z)| ≤ 1 em Re(z)≤0 implica estabilidade para todos h, ignorando consistência."
                                }
                              ],
                              "practicalExample": "Para o método de Euler backward aplicado a y' = -100 y, com h=0.1, z = hλ = -10. Calcule R(z) = 1/(1 - (-10)) = 1/11 ≈ 0.0909, |R(z)| <1 → estável. Simule 100 passos: solução numérica decai sem oscilações, ao contrário do Euler forward onde explode.",
                              "finalVerifications": [
                                "Explique a definição de estabilidade absoluta para z fixo.",
                                "Calcule |R(z)| para z=-2+i no método trapezoidal.",
                                "Identifique se Euler forward é estável no semiplano Re(z)≤0.",
                                "Descreva a região de estabilidade no plano z.",
                                "Justifique por que A-estabilidade é vital para EDOs rígidos.",
                                "Compare estabilidade de dois métodos em um exemplo numérico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de |R(z)| ≤1.",
                                "Correção nos cálculos de R(z) e |R(z)|.",
                                "Compreensão clara da extensão ao semiplano esquerdo.",
                                "Uso adequado de exemplos e plots para ilustração.",
                                "Identificação correta de erros comuns em estabilidade.",
                                "Capacidade de relacionar com aplicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos.",
                                "Computação: Implementação de solvers numéricos em Python/Scipy.",
                                "Engenharia: Análise de controle e sistemas dinâmicos rígidos.",
                                "Estatística: Modelos estocásticos com componentes rígidos."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas rígidas (ex: cinética em reatores nucleares), onde eigenvalues têm partes reais grandes negativas, métodos A-estáveis como BDF garantem simulações estáveis com h grandes, reduzindo tempo computacional em previsões industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Desenhar a Região de Estabilidade",
                            "description": "Construir no plano complexo a região {z ∈ ℂ : |R(z)| ≤ 1}, ilustrando para Euler explícito (círculo unitário deslocado) e implícito (exterior do círculo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de estabilidade numérica",
                                  "subSteps": [
                                    "Lembre-se da definição de estabilidade para métodos de Runge-Kutta lineares: |R(z)| ≤ 1 para z no eixo negativo imaginário.",
                                    "Identifique a função de amplificação R(z) para Euler explícito: R(z) = 1 + z.",
                                    "Identifique R(z) para Euler implícito: R(z) = 1 / (1 - z).",
                                    "Entenda o plano complexo: eixo real (hλ) e imaginário.",
                                    "Pratique traçando o eixo negativo imaginário no plano."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as funções R(z) para ambos os métodos e o que significa |R(z)| ≤ 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de plotagem (GeoGebra, Desmos, Python/Matplotlib)",
                                    "Livro de Análise Numérica ou notas de aula"
                                  ],
                                  "tips": "Comece sempre pelo eixo imaginário negativo para contextualizar a estabilidade A.",
                                  "learningObjective": "Compreender as bases teóricas da região de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir plano complexo com plano real",
                                    "Esquecer que z = hλ com λ ≤ 0",
                                    "Invertar as funções R(z)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e delinear a região para Euler explícito",
                                  "subSteps": [
                                    "Escreva a desigualdade |1 + z| ≤ 1.",
                                    "Expanda: |z - (-1)| ≤ 1, identificando centro em -1 + 0i e raio 1.",
                                    "Trace o círculo: interseções com eixo real em 0 e -2, tangente ao eixo imaginário.",
                                    "Sombreie o interior do círculo como região de estabilidade.",
                                    "Marque pontos teste: z=-1 (centro, |R|=0), z=0 (|R|=1)."
                                  ],
                                  "verification": "Verifique se o círculo inclui o segmento [-2,0] no eixo real e toca i=0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Plano complexo impresso ou digital",
                                    "Régua e compasso para precisão"
                                  ],
                                  "tips": "Use compasso para desenhar círculos precisos; teste |R(z)| em pontos de fronteira.",
                                  "learningObjective": "Construir geometricamente a região |1 + z| ≤ 1.",
                                  "commonMistakes": [
                                    "Desenhar círculo centrado em 0",
                                    "Sombrear o exterior",
                                    "Erro no raio ou centro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e delinear a região para Euler implícito",
                                  "subSteps": [
                                    "Escreva |1 / (1 - z)| ≤ 1, equivalente a |1 - z| ≥ 1.",
                                    "Interprete como exterior do círculo |z - 1| ≥ 1 (centro 1+0i, raio 1).",
                                    "Trace o círculo: interseções com eixo real em 0 e 2.",
                                    "Sombreie o exterior, incluindo todo o semiplano esquerdo.",
                                    "Marque pontos: z=1 (fronteira, indefinido mas limite |R|=1), z=-1 (|R|=0.5)."
                                  ],
                                  "verification": "Confirme que o eixo negativo imaginário inteiro está na região (exceto origem).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo plano complexo do passo anterior",
                                    "Calculadora para verificar |R(z)|"
                                  ],
                                  "tips": "Lembre-se: implícito é incondicionalmente estável no semiplano esquerdo.",
                                  "learningObjective": "Construir geometricamente a região |1/(1-z)| ≤ 1.",
                                  "commonMistakes": [
                                    "Confundir com interior do círculo",
                                    "Centro errado em -1",
                                    "Esquecer exterior"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar, rotular e finalizar o diagrama",
                                  "subSteps": [
                                    "Desenhe ambos os diagramas no mesmo plano complexo.",
                                    "Rotule: 'Euler Explícito: disco |1+z|≤1', 'Euler Implícito: exterior |1-z|≥1'.",
                                    "Indique o eixo negativo imaginário e destaque diferenças.",
                                    "Adicione legendas e escala.",
                                    "Compare: explícito limitado, implícito amplo."
                                  ],
                                  "verification": "O diagrama final mostra ambas regiões corretas, rotuladas e comparadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Canetas coloridas para distinção",
                                    "Software para exportar imagem"
                                  ],
                                  "tips": "Use cores diferentes: azul para explícito, vermelho para implícito.",
                                  "learningObjective": "Integrar e visualizar as regiões de estabilidade comparativamente.",
                                  "commonMistakes": [
                                    "Escala inconsistente",
                                    "Rótulos trocados",
                                    "Falta de sombreamento claro"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver y' = -y com h=0.1, compute z = hλ = -0.1 (dentro de ambos). Desenhe regiões e confirme estabilidade: explícito ok para |z| pequeno, implícito sempre.",
                              "finalVerifications": [
                                "Disco explícito centrado em -1+0i, raio 1, contém [-2,0] real.",
                                "Região implícita é exterior de círculo centrado em +1+0i, raio 1.",
                                "Eixo imaginário negativo coberto integralmente pelo implícito.",
                                "Fronteiras testadas: |R(z)|=1 nos limites.",
                                "Diagrama rotulado corretamente com funções R(z).",
                                "Comparação visual clara das diferenças."
                              ],
                              "assessmentCriteria": [
                                "Precisão geométrica das regiões (centro, raio, sombreamento).",
                                "Correção das desigualdades |R(z)| ≤ 1.",
                                "Clareza de rótulos e legendas.",
                                "Inclusão do eixo negativo imaginário e marcações.",
                                "Comparação explícita entre métodos.",
                                "Criatividade na visualização (cores, escala)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Plotar regiões com Python (Matplotlib, complex plot).",
                                "Física: Estabilidade em simulações de osciladores harmônicos.",
                                "Engenharia: Análise de métodos numéricos em controle de sistemas.",
                                "Computação Gráfica: Representação de regiões no plano complexo."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais (ex.: modelagem climática, circuitos elétricos, epidemias), escolher método baseado na região de estabilidade garante precisão sem oscilações artificiais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.4",
                            "name": "Diferenciar Estabilidade Absoluta e Condicional",
                            "description": "Explicar estabilidade condicional (ex: Euler explícito requer |h λ| < 2) versus incondicional (métodos implícitos A-estáveis).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Estabilidade Numérica",
                                  "subSteps": [
                                    "Revise a definição de estabilidade em métodos numéricos para EDOs lineares: solução numérica permanece limitada quando a solução exata é estável.",
                                    "Estude o teste de estabilidade de von Neumann para equações de teste y' = λ y.",
                                    "Identifique a região de estabilidade no plano complexo hλ.",
                                    "Discuta a importância da escolha do passo h em relação a λ.",
                                    "Anote as diferenças entre estabilidade local e global."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos fundamentais e desenhe o plano hλ com a região de estabilidade genérica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), papel e caneta, calculadora.",
                                  "tips": "Use diagramas do plano complexo para visualizar melhor as regiões.",
                                  "learningObjective": "Dominar a base teórica necessária para diferenciar tipos de estabilidade.",
                                  "commonMistakes": "Confundir estabilidade numérica com estabilidade da solução exata; ignorar o papel do passo h."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estabilidade Condicional com Exemplo do Método de Euler Explícito",
                                  "subSteps": [
                                    "Derive a condição de estabilidade para Euler explícito: |1 + hλ| ≤ 1, implicando |hλ| < 2 para λ real negativo.",
                                    "Calcule a amplificação fator g(hλ) = 1 + hλ.",
                                    "Plote a região de estabilidade no plano hλ (disco unitário centrado em -1).",
                                    "Teste numericamente com y' = -y, h variando para demonstrar instabilidade.",
                                    "Registre como violações da condição levam a oscilações ou divergência."
                                  ],
                                  "verification": "Implemente um código simples em Python/MATLAB mostrando instabilidade para hλ > 2 e estabilidade para hλ < 2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/MATLAB, exemplos de EDOs lineares.",
                                  "tips": "Comece com λ = -1 e varie h de 0.1 a 3.0 para observar o comportamento.",
                                  "learningObjective": "Entender e aplicar a condição |hλ| < 2 para estabilidade condicional.",
                                  "commonMistakes": "Esquecer que a condição é restritiva para λ com parte real negativa grande; confundir com métodos implícitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Estabilidade Absoluta (Incondicional) em Métodos Implícitos A-Estáveis",
                                  "subSteps": [
                                    "Defina A-estabilidade: região de estabilidade inclui todo o semiplano esquerdo (Re(hλ) < 0).",
                                    "Analise o método de Euler implícito: g(hλ) = 1 / (1 - hλ), estável para todo h > 0 quando Re(λ) < 0.",
                                    "Estude métodos como Backward Differentiation Formula (BDF) ou Trapezoidal, confirmando A-estabilidade.",
                                    "Compare numericamente com Euler explícito na mesma EDO y' = -y.",
                                    "Desenhe regiões de estabilidade para ilustrar a diferença."
                                  ],
                                  "verification": "Compare gráficos de soluções numéricas de Euler implícito vs. explícito para h grande, confirmando estabilidade incondicional.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software numérico (Python SciPy odeint ou MATLAB ode45/ode23s), gráficos prontos de regiões.",
                                  "tips": "Use h = 10 para λ = -1 no implícito para ver estabilidade vs. explosão no explícito.",
                                  "learningObjective": "Reconhecer métodos A-estáveis e sua independência do passo h.",
                                  "commonMistakes": "Achar que todos os métodos implícitos são A-estáveis (nem todos são); ignorar custo computacional maior."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar e Comparar Estabilidade Absoluta versus Condicional",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: condições, exemplos de métodos, prós/contras, regiões de estabilidade.",
                                    "Discuta trade-offs: explícito (rápido, condicional) vs. implícito (lento, incondicional).",
                                    "Aplique a problemas stiff (λ com |Im(λ)| grande), justificando escolha.",
                                    "Resolva um exercício misto: classifique métodos como RK4 (condicional) vs. BDF2 (A-estável).",
                                    "Formule regras para seleção baseada no problema."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença para um 'aluno' fictício, usando exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela em Excel ou papel, resumo de métodos numéricos.",
                                  "tips": "Use mnemônicos: 'Condicional = cauteloso com h', 'Absoluta = aventureiro com h grande'.",
                                  "learningObjective": "Capacitar diferenciação clara e aplicação contextual.",
                                  "commonMistakes": "Generalizar Euler explícito como 'ruim'; subestimar necessidade de solvers não-lineares em implícitos."
                                }
                              ],
                              "practicalExample": "Resolva y' = -50y + sin(t), y(0)=1, com h=0.1 (explícito explode) vs. h=0.5 (implícito converge), plotando soluções para visualizar estabilidade condicional vs. absoluta.",
                              "finalVerifications": [
                                "Pode derivar a condição |hλ| < 2 para Euler explícito?",
                                "Desenha corretamente as regiões de estabilidade para explícito e implícito?",
                                "Explica por que métodos A-estáveis são preferidos em problemas stiff?",
                                "Classifica corretamente 3 métodos numéricos como condicional ou incondicional?",
                                "Identifica instabilidade em uma simulação numérica simples?",
                                "Compara prós/contras em uma tabela?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de fatores de amplificação (90% correto).",
                                "Visualizações claras de regiões de estabilidade (sem erros geométricos).",
                                "Exemplos numéricos reproduzíveis mostrando diferenças.",
                                "Compreensão de trade-offs computacionais e de precisão.",
                                "Aplicação correta a problemas stiff vs. não-stiff.",
                                "Comunicação clara da diferenciação em resumo escrito."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de dinâmica molecular ou fluidos (CFD).",
                                "Engenharia: Controle de sistemas stiff em aeroespacial.",
                                "Computação: Otimização de solvers em bibliotecas como SciPy ou PETSc.",
                                "Finanças: Modelagem de processos estocásticos com estabilidade numérica."
                              ],
                              "realWorldApplication": "Em simulações climáticas (modelos stiff de oceanos), usa-se métodos implícitos A-estáveis para passos h grandes sem instabilidade, economizando tempo computacional em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Equação Teste de Dahlquist",
                    "description": "Análise de estabilidade usando a equação modelo y' = λy para métodos de um passo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Equação Teste de Dahlquist",
                        "description": "A equação diferencial linear y' = λ y, com λ ∈ ℂ, serve como modelo canônico para analisar a estabilidade numérica de métodos de um passo na resolução de problemas de valor inicial.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Compreender a solução exata da equação teste",
                            "description": "Derivar a solução analítica y(t) = y(0) exp(λ t) e analisar seu comportamento para Re(λ) < 0, destacando a necessidade de decaimento exponencial na aproximação numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Equação Teste de Dahlquist",
                                  "subSteps": [
                                    "Recordar que a equação teste é y' = λ y, onde λ é um escalar complexo com parte real negativa.",
                                    "Identificar y(0) como condição inicial.",
                                    "Explicar o propósito: testar estabilidade de métodos numéricos lineares.",
                                    "Discutir por que Re(λ) < 0 implica solução que tende a zero.",
                                    "Esboçar graficamente o comportamento esperado para λ real negativo."
                                  ],
                                  "verification": "Escrever a equação e explicar verbalmente seu significado em 1 minuto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Caderno, lápis, calculadora científica.",
                                  "tips": "Visualize a equação como crescimento/decaimento proporcional à própria função.",
                                  "learningObjective": "Compreender o modelo matemático da equação teste e sua relevância em análise numérica.",
                                  "commonMistakes": "Confundir com equações de segunda ordem ou ignorar o caráter complexo de λ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Solução Analítica",
                                  "subSteps": [
                                    "Separar variáveis: dy/y = λ dt.",
                                    "Integrar ambos os lados: ∫ dy/y = λ ∫ dt.",
                                    "Aplicar logaritmo natural: ln|y| = λ t + C.",
                                    "Exponentiar: y(t) = y(0) exp(λ t), usando y(0) = e^C.",
                                    "Verificar por substituição na EDO original."
                                  ],
                                  "verification": "Derivar y(t) do zero e confirmar que satisfaz y' = λ y.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel para derivação, tabela de integrais.",
                                  "tips": "Mantenha y(0) explícito desde o início para evitar erros na constante.",
                                  "learningObjective": "Derivar com precisão a solução exata y(t) = y(0) exp(λ t).",
                                  "commonMistakes": "Esquecer o fator y(0) ou errar o sinal na integração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Comportamento para Re(λ) < 0",
                                  "subSteps": [
                                    "Decompor λ = a + bi, com a = Re(λ) < 0.",
                                    "Escrever exp(λ t) = exp(a t) exp(i b t) = exp(a t) [cos(b t) + i sin(b t)].",
                                    "Concluir que |y(t)| = |y(0)| exp(a t) → 0 quando t → ∞, pois exp(a t) decai exponencialmente.",
                                    "Discutir oscilações se Im(λ) ≠ 0, mas amplitude decaindo.",
                                    "Plotar |y(t)| vs t para ilustrar decaimento."
                                  ],
                                  "verification": "Calcular limite de |y(t)| para t → ∞ e graficar para λ = -1 + i.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (Desmos ou Python/Matplotlib), régua.",
                                  "tips": "Use módulo complexo para amplitude: |exp(λ t)| = exp(Re(λ) t).",
                                  "learningObjective": "Analisar assintoticamente o decaimento exponencial da solução.",
                                  "commonMistakes": "Ignorar a parte imaginária ou afirmar decaimento sem considerar o módulo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com Aproximações Numéricas",
                                  "subSteps": [
                                    "Explicar que métodos numéricos devem reproduzir decaimento: |y_{n+1}| < |y_n| se Re(λ) < 0.",
                                    "Destacar que solução exata define critério de estabilidade A-stável.",
                                    "Comparar com solução numérica simples (ex: Euler forward).",
                                    "Identificar necessidade de decaimento na discretização.",
                                    "Resumir implicações para escolha de métodos em EDOs rígidas."
                                  ],
                                  "verification": "Escrever por que métodos numéricos falham se não decaem como a exata.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplos de métodos numéricos anotados, calculadora.",
                                  "tips": "Pense em estabilidade como 'imitar' o decaimento exato.",
                                  "learningObjective": "Conectar solução exata à exigência de estabilidade numérica.",
                                  "commonMistakes": "Confundir estabilidade com precisão ou ignorar rigidez."
                                }
                              ],
                              "practicalExample": "Para λ = -2 + 3i e y(0) = 1, a solução é y(t) = exp((-2 + 3i)t). Plote |y(t)| de t=0 a 5: decai de 1 para ~0.0067, oscilando com frequência 3 rad/unidade.",
                              "finalVerifications": [
                                "Deriva corretamente y(t) = y(0) exp(λ t) em menos de 2 minutos.",
                                "Explica por que |y(t)| → 0 para Re(λ) < 0 com gráfico mental.",
                                "Identifica papel na estabilidade numérica.",
                                "Calcula y(1) para λ = -1, y(0)=1 (resposta: 1/e).",
                                "Diferencia comportamento para Re(λ) > 0 (crescimento).",
                                "Resume necessidade de decaimento em métodos numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação analítica (fórmula exata).",
                                "Correta análise assintótica do decaimento exponencial.",
                                "Uso apropriado de números complexos e módulo.",
                                "Conexão clara com estabilidade numérica.",
                                "Explicação verbal fluida e sem hesitações.",
                                "Gráficos ou cálculos numéricos corretos no exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Decaimento radioativo (λ real negativo).",
                                "Engenharia: Resposta transitória em circuitos RC/RL.",
                                "Biologia: Modelos de populações com mortalidade proporcional.",
                                "Computação: Implementação de solvers ODE em Python (scipy.integrate)."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas rígidas ou controle de sistemas dinâmicos, onde métodos numéricos devem preservar o decaimento exponencial para evitar instabilidades numéricas artificiais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Identificar o papel da equação na análise de estabilidade",
                            "description": "Explicar por que y' = λ y é usada como teste padrão para estabilidade, relacionando λ com autovalores de sistemas lineares e o parâmetro z = h λ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação modelo y' = λ y e sua solução exata",
                                  "subSteps": [
                                    "Escreva a equação diferencial y' = λ y e identifique λ como constante complexa.",
                                    "Resolva analiticamente: y(t) = y(0) e^{λ t}.",
                                    "Analise o comportamento: se Re(λ) < 0, solução decai (estável); se Re(λ) > 0, cresce (instável).",
                                    "Discuta o semiplano estável no plano complexo (Re(λ) ≤ 0).",
                                    "Verifique com exemplos numéricos simples para λ real e imaginário."
                                  ],
                                  "verification": "Derive corretamente a solução exata e classifique a estabilidade para pelo menos dois valores de λ (um estável, um instável).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora gráfica ou Python/Jupyter para plotar soluções.",
                                  "tips": "Sempre normalize y(0)=1 para simplificar comparações.",
                                  "learningObjective": "Dominar a dinâmica exata da equação teste e seu critério de estabilidade contínua.",
                                  "commonMistakes": "Confundir λ complexo com crescimento oscilatório sem considerar parte real."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar a equação modelo com autovalores de sistemas lineares",
                                  "subSteps": [
                                    "Lembre o sistema linear y' = A y, onde A é matriz com autovalores λ_i.",
                                    "Explique que modos independentes são y' = λ_i y.",
                                    "Discuta linearização de sistemas não-lineares via Jacobiana em equilíbrio.",
                                    "Mostre que estabilidade do sistema segue a do autovalor com maior parte real.",
                                    "Calcule autovalores de uma matriz 2x2 simples e relacione."
                                  ],
                                  "verification": "Para uma matriz A dada, identifique autovalores e determine estabilidade do sistema associado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software como MATLAB/Octave ou SymPy no Python para autovalores, notas de aula sobre EDOs lineares.",
                                  "tips": "Use decomposição espectral para visualizar modos independentes.",
                                  "learningObjective": "Conectar a equação escalar simples à análise de estabilidade de sistemas multivariáveis.",
                                  "commonMistakes": "Ignorar autovalores complexos conjugados e seu impacto em oscilações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a discretização numérica e o parâmetro z = h λ",
                                  "subSteps": [
                                    "Escolha um método numérico (ex: Euler forward: y_{n+1} = y_n + h f(y_n)).",
                                    "Aplique à equação teste: y_{n+1} = R(z) y_n, onde z = h λ.",
                                    "Derive a função de amplificação R(z) para o método escolhido.",
                                    "Analise |R(z)| para z no semiplano estável (Re(z) ≤ 0).",
                                    "Compare com solução exata e^{λ t} ≈ e^{z n}."
                                  ],
                                  "verification": "Derive R(z) para Euler forward e Backward, e plote a região de estabilidade.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python com NumPy/Matplotlib para plotar |R(z)| no plano z, tabela de métodos numéricos.",
                                  "tips": "Comece com h pequeno para aproximar o contínuo.",
                                  "learningObjective": "Entender como o passo h transforma λ em z e afeta a recursão numérica.",
                                  "commonMistakes": "Confundir estabilidade absoluta com relativa ou ignorar o papel de h."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o papel da equação na análise de estabilidade geral",
                                  "subSteps": [
                                    "Resuma: equação teste modela o pior caso via autovalores.",
                                    "Defina estabilidade: solução numérica imita a exata para Re(λ) < 0.",
                                    "Discuta região de estabilidade: conjunto {z : |R(z)| ≤ 1, Re(z) ≤ 0}.",
                                    "Compare métodos: explicito vs implícito.",
                                    "Aplique a um problema real linearizado."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que y' = λ y é padrão e dê exemplo de falha sem análise.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos de regiões de estabilidade de livros-texto, exemplos computacionais.",
                                  "tips": "Pense em termos de 'amplificação por passo': |R(z)| <1 garante decaimento.",
                                  "learningObjective": "Sintetizar o papel da equação como benchmark para métodos numéricos.",
                                  "commonMistakes": "Achar que estabilidade é só precisão; é sobre não explodir."
                                }
                              ],
                              "practicalExample": "Considere y' = -y (λ = -1, estável). Use Euler forward com h=2: z=-2, R(z)=1-2=-1, |R|=1 (marginal), mas para h=3, z=-3, R=-2, |R|=2>1 (instável, solução explode apesar do contínuo estável). Plote y_n vs y exata para visualizar.",
                              "finalVerifications": [
                                "Derivar solução exata y(t)=y0 e^{λ t} e classificar estabilidade por Re(λ).",
                                "Relacionar λ a autovalores de A em y'=A y.",
                                "Calcular z=h λ e R(z) para Euler forward em λ=-1+i.",
                                "Explicar verbalmente por que Dahlquist é teste padrão.",
                                "Plotar região de estabilidade e identificar se hλ está nela.",
                                "Comparar estabilidade de dois métodos para mesmo problema."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da solução exata e análise qualitativa (30%).",
                                "Correta conexão com autovalores e linearização (25%).",
                                "Domínio de z=hλ e função R(z) com exemplos numéricos (20%).",
                                "Explicação clara do papel na análise de estabilidade (15%).",
                                "Uso de gráficos/plots para ilustrar conceitos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de decaimento radioativo ou circuitos RC (λ negativo real).",
                                "Engenharia de Controle: Análise de estabilidade de sistemas lineares via autovalores.",
                                "Computação Científica: Implementação e teste de solvers ODE em Python/SciPy.",
                                "Finanças: Simulações de processos estocásticos lineares."
                              ],
                              "realWorldApplication": "Em simulações numéricas de dinâmica de fluidos (CFD) ou previsão climática, a análise de Dahlquist garante que erros de truncamento não causem instabilidade explosiva, permitindo simulações confiáveis de longo prazo em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Interpretar condições de estabilidade física",
                            "description": "Analisar como a solução exata satisfaz |y(t)| ≤ |y(0)| para Re(λ) ≤ 0, definindo o critério de estabilidade absoluta para métodos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Equação Teste de Dahlquist e sua Solução Exata",
                                  "subSteps": [
                                    "Revise a equação diferencial y' = λ y, onde λ é um escalar complexo.",
                                    "Derive a solução exata: y(t) = y(0) * exp(λ t).",
                                    "Explique o papel dessa equação como modelo teste para estabilidade em métodos numéricos.",
                                    "Discuta por que ela captura modos oscilatórios e dissipativos.",
                                    "Esboce gráficos qualitativos para λ real negativo e complexo."
                                  ],
                                  "verification": "Escreva a solução exata e justifique sua validade para qualquer λ ∈ ℂ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (cap. estabilidade)",
                                    "Papel e lápis para derivação",
                                    "Software como Python/MATLAB para plotar exp(λ t)"
                                  ],
                                  "tips": "Lembre-se que exp(λ t) = exp((a+bi)t) = exp(a t) * (cos(b t) + i sin(b t)), separando parte real e imaginária.",
                                  "learningObjective": "Dominar a forma analítica da solução da equação teste.",
                                  "commonMistakes": "Confundir y(t) com y(n Δt) em contexto discreto; ignorar que λ pode ser complexo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Módulo da Solução |y(t)|",
                                  "subSteps": [
                                    "Calcule |y(t)| = |y(0)| * |exp(λ t)|.",
                                    "Expresse |exp(λ t)| = exp(Re(λ) t), já que |exp(z)| = exp(Re(z)) para z complexo.",
                                    "Compare com |y(0)| para diferentes regiões do plano complexo de λ.",
                                    "Identifique que para Re(λ) > 0, |y(t)| cresce exponencialmente.",
                                    "Verifique para Re(λ) = 0 (eixo imaginário puro), |y(t)| = |y(0)| constante."
                                  ],
                                  "verification": "Mostre matematicamente que |y(t)| ≤ |y(0)| se e só se Re(λ) ≤ 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora complexa ou Python (numpy.exp)",
                                    "Plano complexo impresso",
                                    "Notas de aula sobre módulo complexo"
                                  ],
                                  "tips": "Use a propriedade |exp(a + bi)| = exp(a), focando na parte real de λ.",
                                  "learningObjective": "Entender o crescimento/decrescimento da norma da solução.",
                                  "commonMistakes": "Esquecer o fator |y(0)| ou confundir |exp(λ t)| com exp(|λ| t)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Interpretar o Critério de Estabilidade Absoluta Física",
                                  "subSteps": [
                                    "Estabeleça a condição: um método é absolutamente estável se |y(n Δt)| ≤ |y(0)| para Re(λ) ≤ 0.",
                                    "Relacione com a solução exata: a discretização deve preservar |y(t)| ≤ |y(0)|.",
                                    "Discuta 'estabilidade física' como imitar o comportamento contínuo estável.",
                                    "Exemplifique com método de Euler: fator de amplificação R(z) = 1 + z, z = λ Δt.",
                                    "Compare regiões de estabilidade absoluta (meio-plano esquerdo mapeado)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como a solução exata define o critério.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabela de fatores de amplificação de métodos comuns",
                                    "Software para plotar regiões de estabilidade (ex: shampine plots)"
                                  ],
                                  "tips": "Pense em estabilidade física como 'não explodir soluções que não deveriam'.",
                                  "learningObjective": "Conectar análise contínua com requisitos para métodos numéricos.",
                                  "commonMistakes": "Confundir estabilidade absoluta com estabilidade von Neumann (frequências altas)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar o Critério em Exemplos Simples",
                                  "subSteps": [
                                    "Escolha λ = -1 (dissipativo): verifique |y(t)| ≤ |y(0)|.",
                                    "Escolha λ = -1 + i (oscilatório amortecido): confirme decay.",
                                    "Teste λ = i (oscilatório puro): |y(t)| = |y(0)|.",
                                    "Discuta implicações para Δt pequeno em métodos explícitos.",
                                    "Resuma o critério: região de estabilidade deve conter {z = λ Δt | Re(λ) ≤ 0}."
                                  ],
                                  "verification": "Resolva numericamente um caso e confirme que |y_n| respeita a condição.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python ou MATLAB para simulação numérica",
                                    "Exemplos de código prontos para Dahlquist"
                                  ],
                                  "tips": "Sempre normalize por |y(0)| para comparar normas.",
                                  "learningObjective": "Aplicar o critério para validar compreensão.",
                                  "commonMistakes": "Usar Δt grande sem checar se z está na região de estabilidade."
                                }
                              ],
                              "practicalExample": "Considere y' = (-1 + i) y, y(0)=1. A solução exata tem |y(t)| = exp(-t) ≤ 1. Para método de Euler com Δt=0.1, z ≈ -0.1 + 0.1i, |1+z| ≈ 0.995 <1, preservando estabilidade; com Δt=2, z≈-2+2i, |1+z|≈2.8>1, instável.",
                              "finalVerifications": [
                                "Derive corretamente |y(t)| = |y(0)| exp(Re(λ) t).",
                                "Identifique que Re(λ) ≤ 0 implica |y(t)| ≤ |y(0)| para todo t ≥ 0.",
                                "Explique o critério de estabilidade absoluta para métodos numéricos.",
                                "Dê um exemplo onde Re(λ)>0 causa explosão.",
                                "Compare solução exata com aproximação numérica estável.",
                                "Descreva o meio-plano esquerdo no plano z = λ Δt."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da solução exata e seu módulo (80% peso).",
                                "Correta interpretação da condição Re(λ) ≤ 0 (15% peso).",
                                "Aplicação clara ao critério de estabilidade numérica (5% peso).",
                                "Uso apropriado de notação complexa e gráficos.",
                                "Identificação de erros comuns em exemplos.",
                                "Conexão lógica entre contínuo e discreto."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de osciladores amortecidos (ex: pêndulo com fricção).",
                                "Engenharia: Simulações de controle de sistemas dinâmicos estáveis.",
                                "Computação: Análise de estabilidade em solvers ODE (SciPy, MATLAB ode45).",
                                "Física Computacional: Propagação de ondas em meios dissipativos."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou aerodinâmicas, métodos numéricos devem preservar estabilidade física para modos dissipativos (Re(λ)<0), evitando amplificação artificial de erros em previsões de longo prazo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Função de Amplificação para Métodos de Um Passo",
                        "description": "A função R(z) = y_{n+1}/y_n, com z = h λ, determina o fator de amplificação por passo em métodos de um passo aplicados à equação teste.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Calcular R(z) para o método de Euler explícito",
                            "description": "Derivar R(z) = 1 + z para o método forward Euler e verificar |R(z)| ≤ 1 para estabilidade condicional no disco |z + 1/2| ≤ 1/2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Equação Teste de Dahlquist e o Método de Euler Explícito",
                                  "subSteps": [
                                    "Lembre-se da equação teste y' = λ y, com solução exata y(t) = y(0) e^{λ t}.",
                                    "Defina z = λ h, onde h é o passo de tempo, e note que a solução numérica busca aproximar e^z.",
                                    "Escreva a iteração do método forward Euler: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Substitua f(t,y) = λ y para obter y_{n+1} = y_n + z y_n.",
                                    "Identifique a forma recorrente y_{n+1} = R(z) y_n."
                                  ],
                                  "verification": "Confirme que você pode escrever corretamente a iteração do Euler com z = λ h.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Análise Numérica (capítulo de estabilidade)"
                                  ],
                                  "tips": "Visualize z como um número complexo no plano z para entender regiões de estabilidade.",
                                  "learningObjective": "Compreender o setup da equação teste e como aplicar o método de Euler nela.",
                                  "commonMistakes": [
                                    "Confundir forward Euler com backward Euler",
                                    "Esquecer que z = λ h é complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Função de Amplificação R(z)",
                                  "subSteps": [
                                    "Da iteração y_{n+1} = y_n + z y_n, fatorize para y_{n+1} = (1 + z) y_n.",
                                    "Identifique R(z) = 1 + z como a função de amplificação.",
                                    "Verifique que y_n = [R(z)]^n y_0, aproximando e^{z n}.",
                                    "Compare com a solução exata e^{z n} y_0 para ver a aproximação local.",
                                    "Anote R(z) explicitamente e sua dependência em z."
                                  ],
                                  "verification": "Escreva R(z) = 1 + z e mostre a recorrência y_{n+1} = R(z) y_n.",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para valores numéricos opcionais"
                                  ],
                                  "tips": "Sempre fatorize a recorrência para isolar o fator multiplicativo R(z).",
                                  "learningObjective": "Derivar corretamente R(z) para métodos de um passo lineares.",
                                  "commonMistakes": [
                                    "Escrever R(z) = 1 + h λ em vez de 1 + z",
                                    "Confundir com métodos implícitos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Condição de Estabilidade |R(z)| ≤ 1",
                                  "subSteps": [
                                    "Calcule |R(z)| = |1 + z| para z complexo.",
                                    "Determine a região onde |1 + z| ≤ 1, que é o disco |z + 1/2| ≤ 1/2 no plano complexo.",
                                    "Desenhe o disco centrado em -1/2 com raio 1/2.",
                                    "Verifique pontos de fronteira: para z = -1 (centro), |1-1|=0 ≤1; para z=0, |1|=1.",
                                    "Confirme que é estabilidade condicional, pois requer |z + 1/2| ≤ 1/2."
                                  ],
                                  "verification": "Plote ou descreva o disco de estabilidade e confirme |R(z)| ≤1 nele.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Papel e caneta para esboço do plano complexo",
                                    "Software como GeoGebra ou Python/Matplotlib para plot opcional"
                                  ],
                                  "tips": "Use a desigualdade triangular para estimar |1 + z|, mas resolva exatamente |1 + x + i y|^2 = (1+x)^2 + y^2 ≤1.",
                                  "learningObjective": "Analisar a região de estabilidade absoluta para o método de Euler.",
                                  "commonMistakes": [
                                    "Confundir o centro do disco (-1/2) com -1",
                                    "Pensar que é incondicionalmente estável"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Estabilidade Condicional e Conclusões",
                                  "subSteps": [
                                    "Teste um z dentro do disco, ex: z=-0.5, |1-0.5|=0.5≤1.",
                                    "Teste z fora, ex: z=-1.1, |1-1.1|=0.1≤1? Não, espere | -0.1 |=0.1≤1 sim, mas verifique corretamente: z=-1 está dentro.",
                                    "Explique por que é condicional: h deve satisfazer |λ h +1/2|≤1/2 para λ com parte real negativa.",
                                    "Discuta implicações: para stiff problems, Euler falha se h grande.",
                                    "Resuma: R(z)=1+z, estável no disco |z+1/2|≤1/2."
                                  ],
                                  "verification": "Forneça pelo menos dois exemplos numéricos confirmando |R(z)|≤1 dentro/fora do disco.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para cálculos numéricos"
                                  ],
                                  "tips": "Sempre teste pontos na fronteira para validar a região.",
                                  "learningObjective": "Verificar e interpretar a estabilidade condicional no contexto prático.",
                                  "commonMistakes": [
                                    "Ignorar parte imaginária de z",
                                    "Confundir estabilidade absoluta com relativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere λ = -1 (decaimento exponencial), h=0.4, então z=-0.4. R(z)=1-0.4=0.6, |0.6|<1, estável. Se h=1, z=-1, R=0, ainda estável (fronteira). Simule 10 passos: y_n = (0.6)^n y0, converge para 0 como exata e^{-t}.",
                              "finalVerifications": [
                                "R(z) derivado corretamente como 1 + z.",
                                "Região de estabilidade identificada como disco |z + 1/2| ≤ 1/2.",
                                "Verificação numérica de |R(z)| ≤ 1 em pelo menos 3 pontos dentro do disco.",
                                "Explicação clara de estabilidade condicional.",
                                "Diagrama do plano z com disco esboçado.",
                                "Comparação com solução exata e^{z}."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de R(z) (100% correto).",
                                "Correta identificação e descrição do disco de estabilidade.",
                                "Análise qualitativa e quantitativa de |1 + z| ≤ 1.",
                                "Uso correto de conceitos de equação teste e métodos de um passo.",
                                "Clareza nas verificações e exemplos numéricos.",
                                "Ausência de erros comuns como confusão com métodos implícitos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Euler em Python/MATLAB para testar estabilidade numericamente.",
                                "Física: Estabilidade em simulações de equações diferenciais de difusão/reação.",
                                "Engenharia Computacional: Escolha de h em solvers de ODEs para problemas stiff.",
                                "Matemática Complexa: Análise de funções analíticas e regiões no plano complexo."
                              ],
                              "realWorldApplication": "Em simulações numéricas de sistemas dinâmicos como propagação de calor (equação do calor, λ negativo), o método Euler explícito requer h pequeno o suficiente para |z + 1/2| ≤ 1/2, evitando oscilações ou blow-up; usado em modelagem climática, finanças (modelos Black-Scholes discretizados) e controle de processos industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Derivar R(z) para métodos implícitos",
                            "description": "Obter R(z) = 1 / (1 - z) para Euler implícito e analisar sua estabilidade incondicional para Re(z) ≤ 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação Teste de Dahlquist e o Método Euler Implícito",
                                  "subSteps": [
                                    "Lembre-se da equação teste y' = λ y, onde λ é um escalar complexo com Re(λ) ≤ 0.",
                                    "Defina z = h λ, com h > 0 o passo de tempo.",
                                    "Escreva a fórmula do método Euler implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Para f(y) = λ y, substitua: y_{n+1} = y_n + z y_{n+1}.",
                                    "Identifique as variáveis principais: y_n, y_{n+1}, z."
                                  ],
                                  "verification": "Confirme que a equação y_{n+1} = y_n + z y_{n+1} está corretamente escrita e compreendida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de papel, calculadora, notas de aula sobre análise numérica.",
                                  "tips": "Desenhe um diagrama temporal mostrando y_n e y_{n+1} para visualizar a dependência implícita.",
                                  "learningObjective": "Entender a formulação do problema de estabilidade para métodos implícitos.",
                                  "commonMistakes": "Confundir Euler explícito (y_{n+1} = y_n + z y_n) com implícito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Relação Explícita entre y_{n+1} e y_n",
                                  "subSteps": [
                                    "Parta de y_{n+1} = y_n + z y_{n+1}.",
                                    "Isole termos com y_{n+1}: y_{n+1} - z y_{n+1} = y_n.",
                                    "Fatore y_{n+1}: y_{n+1} (1 - z) = y_n.",
                                    "Resolva para y_{n+1}: y_{n+1} = y_n / (1 - z).",
                                    "Verifique manipulando algebricamente de volta à equação original."
                                  ],
                                  "verification": "Substitua a solução de volta na equação original e confirme que satisfaz.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e lápis para álgebra.",
                                  "tips": "Trate z como uma variável simbólica para evitar erros numéricos.",
                                  "learningObjective": "Dominar a resolução algébrica da recursão implícita.",
                                  "commonMistakes": "Esquecer o sinal negativo em (1 - z) ou inverter a fração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Calcular a Função de Amplificação R(z)",
                                  "subSteps": [
                                    "Defina R(z) = y_{n+1} / y_n pela definição padrão.",
                                    "Substitua a expressão derivada: R(z) = 1 / (1 - z).",
                                    "Simplifique ou reescreva R(z) em forma alternativa se necessário.",
                                    "Calcule R(z) para valores teste, ex: z = -1, R(-1) = 1/2.",
                                    "Registre a expressão final R(z) = 1 / (1 - z)."
                                  ],
                                  "verification": "Compute R(z) para z = i (parte imaginária) e confirme |R(i)| ≈ 0.5 < 1.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora complexa ou software como Python/MATLAB.",
                                  "tips": "Use frações simbólicas para precisão.",
                                  "learningObjective": "Identificar corretamente a função de amplificação para Euler implícito.",
                                  "commonMistakes": "Escrever R(z) = 1 + z (que é para explícito) em vez de 1/(1-z)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a Estabilidade Incondicional para Re(z) ≤ 0",
                                  "subSteps": [
                                    "Lembre que estabilidade requer |R(z)| ≤ 1 para Re(z) ≤ 0.",
                                    "Compute |R(z)|^2 = |1|^2 / |1 - z|^2 = 1 / (|1 - Re(z)|^2 + Im(z)^2).",
                                    "Mostre que para Re(z) ≤ 0, |1 - Re(z)| ≥ 1 e Im(z)^2 ≥ 0, então denominador ≥ 1, |R(z)| ≤ 1.",
                                    "Verifique casos limite: z real negativo (decadência), z = 0 (|R|=1), z puramente imaginário.",
                                    "Conclua estabilidade incondicional na meia-esquerda do plano complexo."
                                  ],
                                  "verification": "Plote |R(z)| no plano z para Re(z) ≤ 0 e confirme sempre ≤1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de plotagem (MATLAB, Python com matplotlib) ou papel quadriculado.",
                                  "tips": "Use desigualdade triangular: |1 - z| ≥ 1 - Re(z) ≥ 1 para Re(z) ≤ 0.",
                                  "learningObjective": "Provar analiticamente a propriedade de estabilidade A-estável do Euler implícito.",
                                  "commonMistakes": "Afirmar estabilidade para todo plano complexo (não é, polo em z=1)."
                                }
                              ],
                              "practicalExample": "Considere resolver y' = -y com h=2 (z=-2). Euler explícito explode, mas implícito dá y1 = y0 / (1 - (-2)) = y0/3 ≈0.333 y0, estável e aproximando y exata →0.",
                              "finalVerifications": [
                                "R(z) = 1/(1-z) está corretamente derivado.",
                                "|R(z)| ≤1 para todo Re(z) ≤0.",
                                "Casos limite como z→ -∞ (|R|→0) e z=0 (|R|=1) verificados.",
                                "Comparação com Euler explícito R(z)=1+z destaca diferença.",
                                "Gráfico de |R(z)| na meia-esquerda confirma estabilidade.",
                                "Prova algébrica de |R(z)| ≤1 sem falhas lógicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica de R(z) (sem erros de sinal).",
                                "Correta interpretação de z = hλ com Re(λ)≤0.",
                                "Prova rigorosa de |R(z)|≤1 usando módulo complexo.",
                                "Identificação de estabilidade incondicional vs condicional.",
                                "Uso apropriado de exemplos numéricos para validação.",
                                "Clareza na explicação de substeps e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de equações diferenciais rígidas (ex: difusão térmica).",
                                "Programação: Implementação numérica em Python (scipy.integrate) comparando explícito/implícito.",
                                "Engenharia: Análise de controle e sistemas dinâmicos discretos.",
                                "Estatística: Modelos estocásticos com passos implícitos para variância controlada."
                              ],
                              "realWorldApplication": "Em simulações de problemas rígidos como reações químicas rápidas ou circuitos elétricos, o Euler implícito permite passos h grandes sem oscilações, economizando tempo computacional em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Comparar R(z) entre métodos explícito e implícito",
                            "description": "Contrastar as funções de amplificação de Euler forward e backward, destacando vantagens para problemas stiff onde |λ| é grande.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar as Funções de Amplificação R(z) para Euler Forward e Backward",
                                  "subSteps": [
                                    "Lembre a equação teste de Dahlquist: y' = λ y, com solução exata y_n = R^n y_0.",
                                    "Para Euler forward (explícito): derive R(z) = 1 + z, onde z = hλ.",
                                    "Para Euler backward (implícito): derive R(z) = 1 / (1 - z).",
                                    "Simplifique e verifique as expressões algebricamente.",
                                    "Esboce graficamente |R(z)| no plano complexo para |z| pequeno."
                                  ],
                                  "verification": "Escreva as fórmulas corretas de R(z) para ambos os métodos e confirme com um professor ou software simbólico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno, calculadora, software como SymPy ou Mathematica para verificação simbólica.",
                                  "tips": "Use z = hλ com λ real negativo para simular problemas de decaimento.",
                                  "learningObjective": "Entender a origem matemática das funções de amplificação.",
                                  "commonMistakes": "Confundir o sinal em z para o método implícito; esquecer que z = hλ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Comportamento de |R(z)| para |z| Pequeno e Grande",
                                  "subSteps": [
                                    "Calcule |R(z)| para Euler forward: |1 + z| ≈ 1 + Re(z) para |z| << 1.",
                                    "Para Euler backward: |R(z)| ≈ 1 + Re(z) para |z| << 1 (aproximação similar).",
                                    "Para |z| grande (z real negativo): mostre que |R_forward| explode enquanto |R_backward| → 0.",
                                    "Plote |R(z)| vs. Re(z) para z no eixo negativo.",
                                    "Compare estabilidade: região onde |R(z)| ≤ 1."
                                  ],
                                  "verification": "Gere gráficos mostrando |R(z)| > 1 para forward em |z| > 1 e |R(z)| < 1 para backward.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com Matplotlib/NumPy ou MATLAB para plotar curvas de |R(z)|.",
                                  "tips": "Use z = x + 0i com x de -10 a 0 para visualizar stiff cases.",
                                  "learningObjective": "Identificar regimes onde cada método é estável.",
                                  "commonMistakes": "Ignorar o módulo |R(z)| e focar só em R(z) real; plots incorretos no plano complexo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar Vantagens em Problemas Stiff",
                                  "subSteps": [
                                    "Defina problemas stiff: eigenvalues com |λ| grande negativo, exigindo h pequeno para estabilidade explícita.",
                                    "Para Euler forward: mostre que h < 2/|λ| para estabilidade, limitando passos grandes.",
                                    "Para Euler backward: A0-estável, |R(z)| < 1 para Re(z) < 0, permitindo h maior.",
                                    "Calcule erro de truncamento: ambos O(h), mas estabilidade domina em stiff.",
                                    "Discuta custo computacional: implícito requer resolver sistema linear."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que backward é preferido em stiff problems.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigos sobre Dahlquist ou livro de análise numérica (ex: Burden & Faires).",
                                  "tips": "Pense em λ = -1000; calcule h_max para forward vs. backward.",
                                  "learningObjective": "Compreender implicações práticas para seleção de métodos.",
                                  "commonMistakes": "Confundir estabilidade com precisão; subestimar custo do implícito."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Comparação Numérica Simples",
                                  "subSteps": [
                                    "Implemente ambos métodos para y' = -100 y, y(0)=1, até t=1.",
                                    "Use h=0.01 para forward (estável) e h=0.1 para ambos.",
                                    "Compare soluções numéricas com exata y=exp(-100t).",
                                    "Meça erro e número de passos.",
                                    "Registre observações sobre oscilações ou divergência."
                                  ],
                                  "verification": "Execute código e mostre que forward diverge com h grande, backward converge.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python/Jupyter com NumPy/SciPy para simulação.",
                                  "tips": "Vectorize o código para eficiência; plote y_n vs. t.",
                                  "learningObjective": "Validar teoria com experimento computacional.",
                                  "commonMistakes": "Erros de indexação no loop; h muito pequeno mascarando instabilidade."
                                }
                              ],
                              "practicalExample": "Em modelagem de reações químicas stiff (ex: y' = -1000 y + 999 z, z' = -z), use Euler backward para h=0.1 sem oscilações, enquanto forward requer h=0.001 e explode.",
                              "finalVerifications": [
                                "Deriva corretamente R(z) para ambos métodos.",
                                "Desenha e interpreta gráficos de |R(z)| no semiplano esquerdo.",
                                "Explica por que backward é A-estável e forward não.",
                                "Identifica condições stiff e impacto em h.",
                                "Implementa simulação numérica comparativa sem erros.",
                                "Discute trade-offs computacionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de R(z) (20%)",
                                "Qualidade e interpretação de análises/gráficos (25%)",
                                "Compreensão conceitual de estabilidade stiff (25%)",
                                "Correção da implementação numérica (20%)",
                                "Clareza na discussão de vantagens/desvantagens (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em EDOs de dinâmica molecular stiff.",
                                "Engenharia: Simulações CFD com escalas múltiplas.",
                                "Computação: Algoritmos numéricos e análise de complexidade.",
                                "Química: Cinética de reações com timescales díspares."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de populações ecológicas ou circuitos elétricos RC stiff, Euler implícito permite passos de tempo maiores, reduzindo tempo de computação em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.1",
                              "10.1.4.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Região de Estabilidade",
                        "description": "Conjunto {z ∈ ℂ : |R(z)| ≤ 1} no plano z complexo, essencial para determinar o passo h admissível em função de λ.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Definir e delinear a região de estabilidade",
                            "description": "Desenhar no plano complexo a região de estabilidade absoluta para Euler explícito (disco unitário à esquerda) e interpretá-la graficamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Equação Teste de Dahlquist e o Método de Euler Explícito",
                                  "subSteps": [
                                    "Estudar a equação diferencial y' = λ y, onde λ é um número complexo com Re(λ) < 0 para simular decaimento.",
                                    "Explicar o propósito da equação teste: analisar estabilidade linear de métodos numéricos.",
                                    "Derivar a iteração do método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n) = (1 + h λ) y_n.",
                                    "Introduzir a variável z = h λ no plano complexo, representando o produto passo-tamanho por autovalor.",
                                    "Comparar com a solução exata y(t) = y_0 exp(λ t), destacando a necessidade de |R(z)| ≤ 1 para estabilidade."
                                  ],
                                  "verification": "Escrever corretamente a recursão de Euler e identificar z = h λ como ponto no plano complexo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno e lápis",
                                    "Livro-texto de Análise Numérica (capítulo de estabilidade)",
                                    "Software de desenho vetorial opcional (GeoGebra)"
                                  ],
                                  "tips": "Sempre associe z = h λ, com h > 0 e Re(λ) < 0, para visualizar restrições no semiplano esquerdo.",
                                  "learningObjective": "Dominar os fundamentos da equação teste e a formulação de Euler explícito no contexto de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir Euler explícito (R(z) = 1 + z) com implícito (R(z) = 1/(1 - z))",
                                    "Ignorar que λ pode ser complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o Fator de Amplificação e a Condição de Estabilidade Absoluta",
                                  "subSteps": [
                                    "Identificar o fator de amplificação R(z) = 1 + z para Euler explícito.",
                                    "Estabelecer a condição de estabilidade absoluta: |R(z)| = |1 + z| ≤ 1 para todos os z no espectro.",
                                    "Reescrever a desigualdade: |z - (-1)| ≤ 1, reconhecendo um disco de raio 1 centrado em -1 + 0i.",
                                    "Analisar geometricamente: o disco está no semiplano esquerdo, tocando a origem.",
                                    "Discutir implicações: métodos explícitos têm regiões de estabilidade limitadas."
                                  ],
                                  "verification": "Escrever |1 + z| ≤ 1 e convertê-la para |z + 1| ≤ 1, descrevendo o disco unitário centrado em -1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Calculadora para verificar |1 + z| em pontos teste"
                                  ],
                                  "tips": "Teste pontos: z=0 (|1|=1, limite), z=-2 (|-1|=1, limite), z=-1+i (verificar módulo).",
                                  "learningObjective": "Derivar e interpretar analiticamente a condição |R(z)| ≤ 1 para Euler explícito.",
                                  "commonMistakes": [
                                    "Escrever incorretamente R(z) como 1 - z",
                                    "Confundir raio 1 com centro em 0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Delinear Graficamente a Região de Estabilidade no Plano Complexo",
                                  "subSteps": [
                                    "Desenhar os eixos reais (Re(z)) e imaginários (Im(z)) no plano complexo.",
                                    "Marcar o centro do disco em z = -1 + 0i e plotar o círculo de raio 1.",
                                    "Preencher o disco fechado (incluindo borda) e sombrear para indicar a região |z + 1| ≤ 1.",
                                    "Rotular pontos chave: origem (0,0), centro (-1,0), interseções com eixo real (-2,0) e imaginário (altura ±1 em Re=-1).",
                                    "Adicionar setas indicando semiplano esquerdo Re(z) < 0."
                                  ],
                                  "verification": "O desenho mostra círculo centrado em -1 com raio 1, preenchido à esquerda, passando por 0 e -2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software (GeoGebra, Desmos, Python com matplotlib)",
                                    "Régua e compasso"
                                  ],
                                  "tips": "Use escala uniforme; verifique distância do centro a pontos na borda =1.",
                                  "learningObjective": "Produzir um gráfico preciso da região de estabilidade de Euler explícito.",
                                  "commonMistakes": [
                                    "Desenhar disco centrado em 0 (círculo unitário)",
                                    "Esquecer de preencher o interior"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a Região de Estabilidade e Suas Implicações",
                                  "subSteps": [
                                    "Explicar: para estabilidade, h λ deve cair dentro do disco para todos autovalores λ do problema.",
                                    "Discutir limitação: Euler explícito requer h pequeno para problemas rígidos (λ com |Im(λ)| grande).",
                                    "Comparar com métodos implícitos (região maior, ex: disco infinito à esquerda).",
                                    "Aplicar a exemplo: dado λ, encontrar h_max tal que z = h λ na borda.",
                                    "Resumir: região visualiza restrições em h para precisão e estabilidade."
                                  ],
                                  "verification": "Descrever verbalmente ou por escrito por que o disco é 'à esquerda' e suas restrições em h.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico do passo 3",
                                    "Exemplos numéricos de problemas de EDOs"
                                  ],
                                  "tips": "Pense em rigidez: problemas com autovalores de magnitudes variadas demandam h minúsculo.",
                                  "learningObjective": "Interpretar graficamente a região e relacioná-la a escolhas práticas de h.",
                                  "commonMistakes": [
                                    "Achar que região é semiplano inteiro Re(z) ≤ 0",
                                    "Ignorar parte imaginária"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDO y' = (-1 + 2i) y (λ = -1 + 2i, rígida), z = h λ deve satisfazer |1 + z| ≤ 1. Centro em -1, raio 1: h_max ≈ 0.35 (calcule |z +1| =1 na direção de λ). Desenhe z para h=0.2 (dentro) vs h=0.5 (fora), simulando oscilação crescente.",
                              "finalVerifications": [
                                "Desenho correto do disco |z + 1| ≤ 1 centrado em -1 + 0i com raio 1.",
                                "Identificação precisa do fator R(z) = 1 + z e condição |R(z)| ≤ 1.",
                                "Explicação de que a região está à esquerda, limitando h para Re(λ) < 0.",
                                "Verificação com ponto teste: z = -0.5 + 0.5i dentro (|1 + z| ≈ 0.707 <1).",
                                "Interpretação: para λ real negativo grande, h < 2/|λ|.",
                                "Comparação textual com região de Runge-Kutta (diferente disco)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: derivação correta de |1 + z| ≤ 1 como disco unitário em -1.",
                                "Qualidade gráfica: eixos rotulados, centro/raio exatos, preenchimento correto.",
                                "Profundidade de interpretação: ligação clara com escolha de h e rigidez.",
                                "Completude: todos substeps executados com verificações.",
                                "Originalidade: exemplo prático personalizado e conexões implícitas.",
                                "Clareza: títulos, dicas e erros comuns bem articulados."
                              ],
                              "crossCurricularConnections": [
                                "Física/Engenharia: Estabilidade em simulações de osciladores harmônicos amortecidos (autovalores complexos).",
                                "Programação/Computação: Implementar plot de regiões em Python (numpy, matplotlib) ou MATLAB.",
                                "Controle de Sistemas: Análise de estabilidade em discretização de sistemas lineares.",
                                "Física Computacional: Escolha de h em modelagem de ondas ou difusão numérica."
                              ],
                              "realWorldApplication": "Na engenharia aeroespacial e modelagem climática, define limites de passo h para simular EDOs rígidas sem instabilidade numérica, evitando explosões em previsões de turbulência ou dinâmica de fluidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Analisar estabilidade para problemas stiff",
                            "description": "Explicar limitações de métodos explícitos em problemas stiff (Re(λ) << 0), justificando necessidade de métodos A-estáveis como backward Euler.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de problemas stiff",
                                  "subSteps": [
                                    "Defina problemas stiff como sistemas de EDOs onde os autovalores têm partes reais muito negativas (Re(λ) << 0).",
                                    "Explique as escalas de tempo muito diferentes entre componentes da solução.",
                                    "Discuta o passo de tempo h necessário para estabilidade em métodos explícitos: h << 1/|λ_max|.",
                                    "Compare com problemas não-stiff onde h pode ser maior."
                                  ],
                                  "verification": "Escreva uma definição precisa e dê um exemplo numérico de λ com Re(λ) = -1000.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (cap. Estabilidade)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Use analogia com molas rígidas vs flexíveis para visualizar rigidez.",
                                  "learningObjective": "Identificar características de problemas stiff e suas implicações numéricas.",
                                  "commonMistakes": [
                                    "Confundir stiff com não-linearidade.",
                                    "Ignorar o impacto no tamanho do passo h."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar limitações de métodos explícitos",
                                  "subSteps": [
                                    "Revise a equação teste de Dahlquist: y' = λy.",
                                    "Derive a condição de estabilidade para Euler forward: |1 + hλ| ≤ 1.",
                                    "Plote a região de estabilidade no plano complexo hλ (círculo unitário no esquerdo).",
                                    "Mostre que para Re(λ) << 0, h deve ser minúsculo para h|λ| < 2."
                                  ],
                                  "verification": "Calcule h_max para λ = -1000 e verifique instabilidade com h=0.01.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como Python/MATLAB para plotar região de estabilidade",
                                    "Folha de derivadas da estabilidade"
                                  ],
                                  "tips": "Desenhe o plano hλ à mão para fixar a região circular.",
                                  "learningObjective": "Explicar por que métodos explícitos são ineficientes em stiff.",
                                  "commonMistakes": [
                                    "Esquecer que região é |1 + z| ≤ 1 com z = hλ.",
                                    "Confundir estabilidade com precisão."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir conceito de A-estabilidade",
                                  "subSteps": [
                                    "Defina A-estabilidade: método estável para todo Re(z) < 0 no plano z = hλ.",
                                    "Discuta métodos L-estáveis (A-estável + |R(∞)|=0).",
                                    "Apresente Backward Euler: y_{n+1} = y_n + h f(y_{n+1}).",
                                    "Derive função de amplificação R(z) = 1/(1 - z), estável para Re(z)<0."
                                  ],
                                  "verification": "Verifique graficamente que Backward Euler cobre todo semiplano esquerdo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de regiões de estabilidade pré-prontos",
                                    "Calculadora simbólica (SymPy)"
                                  ],
                                  "tips": "Lembre: implícito requer resolver equação não-linear por iteração.",
                                  "learningObjective": "Compreender propriedades de métodos A-estáveis.",
                                  "commonMistakes": [
                                    "Pensar que todos implícitos são A-estáveis (nem todos são).",
                                    "Ignorar custo computacional extra."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar necessidade de métodos A-estáveis em stiff",
                                  "subSteps": [
                                    "Compare eficiência: explícito precisa milhares de passos, implícito poucos.",
                                    "Simule numericamente um problema stiff com ambos métodos.",
                                    "Discuta trade-offs: precisão vs custo em backward Euler (damping).",
                                    "Conclua quando usar cada um: stiff → A-estável."
                                  ],
                                  "verification": "Implemente simulação simples e compare número de passos/tempo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Python pronto para Euler forward/backward",
                                    "Exemplo stiff: y' = -1000y"
                                  ],
                                  "tips": "Use h fixo grande para stiff e observe oscilações no explícito.",
                                  "learningObjective": "Justificar escolha de método baseada em estabilidade.",
                                  "commonMistakes": [
                                    "Subestimar overhead de solve implícito em sistemas grandes.",
                                    "Generalizar sem testar numericamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere modelar uma reação química stiff: y' = -1000(y - 1) para y próximo de 1 (equilíbrio rígido). Euler forward com h=0.01 explode; Backward Euler converge suavemente.",
                              "finalVerifications": [
                                "Explicar corretamente limitações explícitas em Re(λ)<<0.",
                                "Desenhar regiões de estabilidade de Euler forward e backward.",
                                "Calcular h_max para λ=-1000 em forward Euler.",
                                "Definir A-estabilidade e citar exemplo.",
                                "Simular stiff problem e concluir necessidade de implícito."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de stiff (90% match com referência).",
                                "Correção matemática de R(z) para backward Euler.",
                                "Análise qualitativa/quantitativa de eficiência.",
                                "Uso correto de terminologia (A-estável, Dahlquist).",
                                "Exemplo prático relevante e simulação funcional."
                              ],
                              "crossCurricularConnections": [
                                "Física: Circuitos RC/RLL com parasitas (stiff).",
                                "Química: Cinética de reações em cascata.",
                                "Engenharia: Controle de sistemas dinâmicos rígidos.",
                                "Computação: Otimização de solvers ODE em SciPy/ODEPACK."
                              ],
                              "realWorldApplication": "Simulação de circuitos elétricos em SPICE (stiff devido capacitores pequenos), permitindo passos maiores com backward Euler para eficiência em design de chips."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Verificar estabilidade numérica via Dahlquist",
                            "description": "Aplicar o teste para prever comportamento de métodos em EDOs lineares, calculando h máximo tal que z = h λ ∈ região de estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Teste de Dahlquist e a Equação Modelo",
                                  "subSteps": [
                                    "Recordar a equação teste y' = λ y, onde λ é um escalar com parte real negativa (Re(λ) < 0).",
                                    "Derivar a solução exata: y_n = y_0 exp(λ t_n), que decai para zero se Re(λ) < 0.",
                                    "Introduzir o parâmetro de estabilidade z = h λ, onde h é o passo de tempo.",
                                    "Definir a região de estabilidade absoluta S do método: conjunto de z ∈ ℂ tal que |R(z)| ≤ 1, onde R(z) é a função de amplificação.",
                                    "Visualizar a região S no plano complexo para o método específico (ex: disco unitário para métodos A-estáveis)."
                                  ],
                                  "verification": "Explicar em palavras próprias o propósito do teste de Dahlquist e esboçar a região S para um método dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de anotações sobre EDOs lineares",
                                    "Gráficos de regiões de estabilidade de métodos comuns (Euler, Trapezoidal)",
                                    "Calculadora ou software como Python/MATLAB para plotar S"
                                  ],
                                  "tips": "Comece sempre pela solução exata para intuitar o comportamento esperado de decaimento.",
                                  "learningObjective": "Dominar os fundamentos conceituais do teste de Dahlquist para análise de estabilidade em EDOs lineares.",
                                  "commonMistakes": [
                                    "Confundir λ (autovalor) com z (parâmetro escalado)",
                                    "Ignorar que o teste é local e linearizado",
                                    "Assumir λ sempre real sem verificar o contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Parâmetros e Calcular z = h λ",
                                  "subSteps": [
                                    "Extrair λ do problema (ex: autovalor da matriz jacobiana linearizada).",
                                    "Escolher ou fornecer um h inicial e computar z = h * λ.",
                                    "Verificar se λ tem parte real negativa (condição para stiff ou decaimento).",
                                    "Representar z no plano complexo (eixo real negativo para Dahlquist clássico).",
                                    "Calcular múltiplos z para diferentes h, plotando-os."
                                  ],
                                  "verification": "Computar z para pelo menos 3 valores de h dados e plotar no plano z.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Problema modelo com λ específico",
                                    "Planilha Excel ou Python (NumPy) para cálculos",
                                    "Papel milimetrado para esboço manual"
                                  ],
                                  "tips": "Use notação complexa se λ ∈ ℂ; para Dahlquist puro, foque no eixo real negativo.",
                                  "learningObjective": "Calcular com precisão o parâmetro z e sua posição relativa à região S.",
                                  "commonMistakes": [
                                    "Erro aritmético em h * λ",
                                    "Usar |λ| em vez de λ",
                                    "Esquecer o sinal negativo de Re(λ)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Função de Amplificação R(z) e Verificar Estabilidade",
                                  "subSteps": [
                                    "Recordar R(z) para o método (ex: Euler explícito R(z) = 1 + z; implícito R(z) = 1 / (1 - z)).",
                                    "Computar |R(z)| para o z calculado.",
                                    "Comparar |R(z)| ≤ 1: se sim, estável; senão, instável.",
                                    "Analisar o comportamento assintótico: lim h→0 |R(z)| →1.",
                                    "Testar numericamente com iterações: y_{n+1} = R(z) y_n."
                                  ],
                                  "verification": "Calcular |R(z)| e afirmar se o método é estável para o h dado, com justificativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fórmulas de R(z) para métodos padrão",
                                    "Calculadora gráfica ou script Python para |R(z)|",
                                    "Tabela de regiões S conhecidas"
                                  ],
                                  "tips": "Para métodos explícitos, S é limitada; implícitos têm S maior no semiplano esquerdo.",
                                  "learningObjective": "Aplicar R(z) para determinar estabilidade pontual de z.",
                                  "commonMistakes": [
                                    "Usar R(z) errado para o método",
                                    "Confundir |R(z)| com R(z)",
                                    "Ignorar iterações múltiplas para oscilações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar h Máximo e Interpretar Resultados",
                                  "subSteps": [
                                    "Resolver para h_max tal que z = h λ está na fronteira de S (ex: para Euler expl., h ≤ 2 / |λ|).",
                                    "Considerar restrições práticas (erro de truncamento vs. estabilidade).",
                                    "Analisar sensibilidade: como h_max varia com |λ| (stiff problems exigem h pequeno).",
                                    "Recomendar método alternativo se h_max muito restritivo.",
                                    "Documentar o laudo: 'Estável para h ≤ h_max'."
                                  ],
                                  "verification": "Calcular h_max corretamente e propor intervalo de h seguro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos resolvidos de h_max",
                                    "Software para resolver inequações como |1 + hλ| ≤ 1"
                                  ],
                                  "tips": "h_max = min{ -2/λ para Euler expl. se λ<0}; generalize para ℂ.",
                                  "learningObjective": "Prever comportamento prático e limitar h para estabilidade numérica.",
                                  "commonMistakes": [
                                    "Resolver |R(z)| <1 em vez de ≤1",
                                    "Não considerar Re(λ)<0",
                                    "Ignorar trade-off com precisão"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Euler explícito aplicado a y' = -50 y (λ = -50), R(z) = 1 + z com z = h*(-50). Estabilidade requer |1 - 50h| ≤ 1, resolvendo: h ≤ 2/50 = 0.04. Teste: para h=0.03, z=-1.5, |1-1.5|=0.5≤1 (estável); h=0.05, z=-2.5, |1-2.5|=1.5>1 (instável).",
                              "finalVerifications": [
                                "Calcula z = h λ corretamente para λ dado e múltiplos h.",
                                "Identifica posição de z na região S com justificativa via |R(z)|.",
                                "Determina h_max preciso e explica seu significado físico.",
                                "Simula 10 passos numéricos e verifica decaimento sem blow-up.",
                                "Compara estabilidade entre dois métodos (explícito vs. implícito).",
                                "Interpreta resultados para um problema stiff real."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de z, R(z) e h_max (erro <1%).",
                                "Compreensão conceitual: explica ligação entre estabilidade numérica e solução exata.",
                                "Profundidade na análise: considera casos complexos e stiff.",
                                "Clareza na comunicação: diagramas, tabelas e conclusões lógicas.",
                                "Criatividade: propõe adaptações para problemas não-lineares.",
                                "Eficiência: escolhe h ótimo balançando estabilidade e custo computacional."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em equações de decaimento radioativo ou amortecimento.",
                                "Computação: Implementação de solvers numéricos em Python (SciPy) com teste de Dahlquist.",
                                "Engenharia: Simulações de circuitos RLC ou controle de sistemas dinâmicos.",
                                "Estatística: Modelos estocásticos lineares e estabilidade de Monte Carlo.",
                                "Economia: Previsão em modelos AR(1) com autovalores negativos."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou farmacocinéticas, verifica-se estabilidade para evitar explosões numéricas em problemas stiff (ex: reação química rápida), garantindo previsões confiáveis em software como MATLAB Simulink ou CFD codes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Região de Estabilidade",
                    "description": "Conjunto de valores hλ no plano complexo para os quais o método numérico é estável.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Problema Teste de Estabilidade Absoluta",
                        "description": "O problema modelo y' = λ y, onde λ é um número complexo, utilizado para analisar a estabilidade absoluta de métodos numéricos de integração de EDOs de primeira ordem.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Definir o problema teste",
                            "description": "Explicar o problema y' = λ y com condição inicial y(0) = 1 e sua solução exata y(t) = e^{λ t}, destacando o papel de λ no plano complexo para simular comportamentos oscilatórios ou dissipativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introduzir a equação diferencial linear de primeira ordem",
                                  "subSteps": [
                                    "Escreva a forma geral da equação diferencial y' = λ y, onde y é a função desconhecida e λ é uma constante complexa.",
                                    "Explique que este é um problema de teste padrão em análise numérica para estudar métodos de integração.",
                                    "Discuta verbalmente o que y' representa: a derivada temporal de y em relação a t.",
                                    "Derive intuitivamente que a solução deve ser exponencial, comparando com crescimento populacional.",
                                    "Anote a equação em um papel, destacando o papel multiplicativo de λ."
                                  ],
                                  "verification": "Consegue escrever corretamente y' = λ y e explicar seu significado em uma frase?",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Visualize λ como uma taxa de crescimento ou decaimento para fixar o conceito.",
                                  "learningObjective": "Compreender a estrutura básica do problema teste de estabilidade absoluta.",
                                  "commonMistakes": [
                                    "Confundir y' com y(t)",
                                    "Esquecer que λ pode ser complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar a condição inicial e derivar a solução exata",
                                  "subSteps": [
                                    "Defina a condição inicial y(0) = 1, justificando que ela normaliza a solução para análise de erro relativo.",
                                    "Resolva analiticamente: separe variáveis dy/y = λ dt, integre ln|y| = λ t + C, aplique y(0)=1 para obter y(t) = e^{λ t}.",
                                    "Verifique a solução diferenciando: d/dt [e^{λ t}] = λ e^{λ t}, que satisfaz a ODE.",
                                    "Calcule y(t) para t pequeno, como t=0.1, assumindo λ conhecido.",
                                    "Compare com solução numérica trivial (Euler com passo zero) para validar."
                                  ],
                                  "verification": "Deriva corretamente y(t) = e^{λ t} a partir de y(0)=1 e verifica por diferenciação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de integrais básicas"
                                  ],
                                  "tips": "Use a propriedade exp(λ t) = exp((a+bi)t) = e^{a t} (cos(b t) + i sin(b t)) para complexos.",
                                  "learningObjective": "Derivar e validar a solução analítica exata do problema teste.",
                                  "commonMistakes": [
                                    "Erro no cálculo da constante C",
                                    "Esquecer a condição inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o papel de λ no plano complexo",
                                  "subSteps": [
                                    "Desenhe o plano complexo com eixo real (Re(λ)) horizontal e imaginário (Im(λ)) vertical.",
                                    "Classifique regiões: Re(λ) > 0 (crescimento instável), Re(λ) < 0 (decaimento estável), Im(λ) ≠ 0 (oscilações).",
                                    "Para λ real positivo, mostre y(t) → ∞; negativo, y(t) → 0.",
                                    "Para λ = i ω (puro imaginário), y(t) = cos(ω t) + i sin(ω t), oscilatório.",
                                    "Para λ = -a + i ω (a>0), y(t) = e^{-a t} (cos(ω t) + i sin(ω t)), dissipativo oscilatório."
                                  ],
                                  "verification": "Desenha o plano complexo corretamente e classifica 3 exemplos de λ com comportamentos associados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de plotagem como GeoGebra (opcional)"
                                  ],
                                  "tips": "Pense em λ como vetor: parte real dita amplitude, imaginária dita frequência.",
                                  "learningObjective": "Interpretar λ no plano complexo para prever dinâmica da solução.",
                                  "commonMistakes": [
                                    "Confundir eixos real/imaginário",
                                    "Ignorar parte real em oscilações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar o problema teste à análise de estabilidade numérica",
                                  "subSteps": [
                                    "Explique que métodos numéricos aproximam y(t_n) ≈ y_n, e estabilidade requer |amplificação| ≤1 para Re(λ)<0.",
                                    "Defina região de estabilidade absoluta: conjunto de λ h (h=passo) onde erro não cresce.",
                                    "Discuta por que y(0)=1 permite medir erro relativo |y_n - y(t_n)| / |y(t_n)|.",
                                    "Simule mentalmente: para λ com Re(λ)h >0, solução numérica diverge mesmo se exata converge.",
                                    "Resuma: este teste universaliza análise de estabilidade para ODEs lineares."
                                  ],
                                  "verification": "Explica como o problema testa estabilidade de um método numérico com exemplo qualitativo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência rápida a métodos de Runge-Kutta"
                                  ],
                                  "tips": "Lembre: h λ determina se o método é estável para aquele λ.",
                                  "learningObjective": "Ligar definição do problema à motivação em análise numérica.",
                                  "commonMistakes": [
                                    "Confundir estabilidade analítica com numérica",
                                    "Esquecer fator h no plano complexo"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere λ = -1 + 2i (dissipativo oscilatório). A solução exata é y(t) = e^{-t} (cos(2t) + i sin(2t)), que oscila com amplitude decaindo. Em simulação numérica com método de Euler (h=0.1), verifique se y_n permanece estável ou explode, plotando |y_n| vs n.",
                              "finalVerifications": [
                                "Escreve corretamente y' = λ y com y(0)=1.",
                                "Deriva y(t) = e^{λ t} e verifica.",
                                "Classifica comportamentos para λ real positivo, negativo e imaginário.",
                                "Desenha plano complexo com regiões de estabilidade.",
                                "Explica papel na análise numérica de métodos.",
                                "Calcula y(1) para λ=-1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na equação e solução exata (20%)",
                                "Compreensão correta de λ complexo e plano (30%)",
                                "Explicação clara de comportamentos dinâmicos (20%)",
                                "Conexão precisa com estabilidade numérica (20%)",
                                "Uso correto de notação matemática (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Equações diferenciais em osciladores harmônicos forçados.",
                                "Engenharia: Análise de estabilidade em sistemas de controle.",
                                "Computação: Implementação de solvers ODE em Python (SciPy).",
                                "Química: Cinética de reações com decaimento exponencial."
                              ],
                              "realWorldApplication": "Este problema modelo é usado para validar solvers numéricos em simulações de epidemias (λ crescimento populacional), circuitos RLC (oscilações dissipativas) e finanças (juros compostos com flutuações), garantindo que aproximações numéricas não amplifiquem erros artificiais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Analisar a solução exata",
                            "description": "Derivar e interpretar a solução exata no plano complexo, identificando regiões onde |e^{λ t}| < 1 (dissipativo) ou |λ| imaginário (oscilatório).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar a solução exata do problema teste de estabilidade",
                                  "subSteps": [
                                    "Recordar o problema modelo y' = λ y com condição inicial y(0) = 1.",
                                    "Aplicar o método de separação de variáveis ou teorema de existência para obter y(t) = e^{λ t}.",
                                    "Verificar a solução substituindo na EDO original.",
                                    "Expressar λ como λ = α + i β, onde α = Re(λ) e β = Im(λ).",
                                    "Escrever e^{λ t} = e^{α t} (cos(β t) + i sin(β t)) usando fórmula de Euler."
                                  ],
                                  "verification": "A solução derivada satisfaz y'(t) = λ y(t) e y(0) = 1.",
                                  "estimatedTime": "20-30 minutes",
                                  "materials": [
                                    "Papel e caneta ou software como Mathematica/MATLAB",
                                    "Referência ao teorema fundamental de EDOs"
                                  ],
                                  "tips": "Sempre normalize y(0)=1 para simplificar análise de magnitude.",
                                  "learningObjective": "Compreender a origem analítica da solução exata para o teste de estabilidade.",
                                  "commonMistakes": [
                                    "Esquecer a condição inicial",
                                    "Confundir e^{λ t} com solução numérica",
                                    "Ignorar a parte imaginária de λ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar a solução no plano complexo λ",
                                  "subSteps": [
                                    "Plotar o plano complexo com eixo real (α) horizontal e imaginário (β) vertical.",
                                    "Expressar |y(t)| = |e^{λ t}| = e^{Re(λ) t} = e^{α t}.",
                                    "Analisar o comportamento assintótico para t → ∞.",
                                    "Identificar que |y(t)| → 0 se α < 0, |y(t)| → ∞ se α > 0, e oscilação limitada se α = 0.",
                                    "Marcar o semiplano esquerdo (α < 0) como região de estabilidade absoluta."
                                  ],
                                  "verification": "Diagrama do plano complexo corretamente rotulado com regiões de α < 0 destacadas.",
                                  "estimatedTime": "15-25 minutes",
                                  "materials": [
                                    "Gráficos em GeoGebra ou Python (matplotlib)",
                                    "Tabela de valores de λ teste"
                                  ],
                                  "tips": "Use cores diferentes para regiões: azul para dissipativo, vermelho para instável.",
                                  "learningObjective": "Visualizar geometricamente a dependência da estabilidade em Re(λ).",
                                  "commonMistakes": [
                                    "Confundir |λ| com Re(λ)",
                                    "Pensar que magnitude total |λ| determina estabilidade",
                                    "Ignorar t > 0 na análise"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar regiões dissipativas onde |e^{λ t}| < 1",
                                  "subSteps": [
                                    "Calcular |e^{λ t}| = e^{α t} e verificar e^{α t} < 1 para t > 0.",
                                    "Concluir que isso ocorre iff α < 0 (dissipativo).",
                                    "Testar numericamente com λ exemplo: α = -0.5, β = 1, plotar |y(t)| decrescendo.",
                                    "Delimitar a região: todo o semiplano esquerdo do plano complexo.",
                                    "Discutir implicações para passos de tempo h em métodos numéricos (z = hλ)."
                                  ],
                                  "verification": "Para λ com Re(λ) < 0, demonstrar |e^{λ t}| → 0 numericamente ou analiticamente.",
                                  "estimatedTime": "20-30 minutes",
                                  "materials": [
                                    "Calculadora ou script Python para plotar e^{α t}",
                                    "Exemplos de λ dissipativos"
                                  ],
                                  "tips": "Fixe t=1 inicialmente para comparar |e^λ| <1.",
                                  "learningObjective": "Dominar a condição matemática para comportamento dissipativo.",
                                  "commonMistakes": [
                                    "Usar |λ| em vez de Re(λ)",
                                    "Confundir <1 com =1",
                                    "Não considerar t→∞"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar regiões oscilatórias onde λ é puramente imaginário",
                                  "subSteps": [
                                    "Definir λ imaginário puro: α = 0, β ≠ 0 (eixo imaginário).",
                                    "Analisar y(t) = cos(β t) + i sin(β t), |y(t)| = 1 (oscilação unitária).",
                                    "Plotar trajetórias no plano complexo: círculos unitários.",
                                    "Comparar com regiões próximas: α ligeiramente negativo (amortecido), positivo (crescente).",
                                    "Interpretar fronteira da estabilidade: eixo imaginário como limite."
                                  ],
                                  "verification": "Para λ = i β, |y(t)| =1 para todo t, com oscilação periódica.",
                                  "estimatedTime": "15-25 minutes",
                                  "materials": [
                                    "Software de plotagem (Desmos ou MATLAB)",
                                    "Exemplos λ = ± i"
                                  ],
                                  "tips": "Anime o gráfico de y(t) para visualizar oscilação.",
                                  "learningObjective": "Reconhecer padrões oscilatórios na fronteira da estabilidade.",
                                  "commonMistakes": [
                                    "Confundir oscilatório com instável",
                                    "Pensar |λ| imaginário em vez de λ puramente imaginário",
                                    "Ignorar periodicidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o problema y' = λ y com λ = -0.2 + 3i, derive y(t) = e^{-0.2 t} (cos(3t) + i sin(3t)). Então |y(t)| = e^{-0.2 t} <1 para t>0 (dissipativo com oscilação amortecida). Plote no plano λ e marque a região. Para λ = 2i, |y(t)|=1, oscilatório puro.",
                              "finalVerifications": [
                                "Deriva corretamente y(t) = e^{λ t} e identifica |y(t)| = e^{Re(λ) t}.",
                                "Desenha o plano complexo com semiplano esquerdo como dissipativo.",
                                "Explica por que eixo imaginário é oscilatório: Re(λ)=0 implica |y(t)|=1.",
                                "Testa com 2 valores de λ: um dissipativo e um oscilatório.",
                                "Discute transformação z = hλ para métodos numéricos.",
                                "Identifica corretamente regiões onde |e^{λ t}| <1 para t→∞."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da solução exata (100% correto).",
                                "Correta interpretação de |e^{λ t}| em termos de Re(λ).",
                                "Visualização clara do plano complexo com regiões rotuladas.",
                                "Análise qualitativa e quantitativa de exemplos.",
                                "Compreensão de implicações para estabilidade numérica.",
                                "Identificação precisa de comportamentos dissipativo/oscilatório."
                              ],
                              "crossCurricularConnections": [
                                "Física: Osciladores harmônicos amortecidos (equações diferenciais em mecânica).",
                                "Engenharia de Controle: Análise de polos no plano s (estabilidade de sistemas lineares).",
                                "Computação Científica: Simulações numéricas de PDEs (difusão/reação).",
                                "Física Computacional: Modelagem de ondas e amortecimento.",
                                "Economia: Modelos dinâmicos lineares e convergência."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais (ex: previsão climática, circuitos elétricos, epidemias), analisar a região de estabilidade garante que soluções numéricas mimetizem o comportamento exato dissipativo ou oscilatório, evitando explosões artificiais em modelos reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Relacionar com estabilidade numérica",
                            "description": "Explicar por que a estabilidade numérica requer que a solução aproximada não cresça quando a exata decai, para Re(λ) < 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Problema Teste de Estabilidade Absoluta",
                                  "subSteps": [
                                    "Defina o problema modelo y' = λ y, onde λ é um escalar complexo com Re(λ) < 0.",
                                    "Explique que este é o problema teste padrão para analisar estabilidade em métodos numéricos para EDOs.",
                                    "Discuta por que Re(λ) < 0 implica decaimento exponencial da solução exata.",
                                    "Identifique o papel deste problema em determinar a região de estabilidade de um método.",
                                    "Esboce graficamente a solução exata y(t) = y(0) exp(λ t) tendendo a zero."
                                  ],
                                  "verification": "Resuma em uma frase o propósito do problema teste e confirme que Re(λ) < 0 causa decaimento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), papel e caneta para esboços.",
                                  "tips": "Sempre associe Re(λ) < 0 visualmente a uma seta apontando para o eixo negativo no plano complexo.",
                                  "learningObjective": "Compreender o problema teste como benchmark para estabilidade numérica.",
                                  "commonMistakes": "Confundir com problemas instáveis (Re(λ) > 0) ou ignorar a parte imaginária de λ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Comportamento da Solução Exata",
                                  "subSteps": [
                                    "Resolva analiticamente: y(t) = y(0) e^{λ t}.",
                                    "Mostre que |y(t)| → 0 quando t → ∞, pois |e^{λ t}| = e^{Re(λ) t} → 0.",
                                    "Discuta implicações: solução exata é assintoticamente estável e decai.",
                                    "Compare com solução instável (Re(λ) ≥ 0), onde cresce ou oscila.",
                                    "Calcule numericamente para λ = -1 + i, confirmando decaimento."
                                  ],
                                  "verification": "Plote ou calcule y(t) para t=0 a 10 e verifique decaimento para zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou Python/MATLAB para exponenciais complexas, gráfico de |y(t)|.",
                                  "tips": "Use log(|y(t)|) para visualizar linearmente o decaimento exponencial.",
                                  "learningObjective": "Reconhecer que a estabilidade exata requer decaimento para Re(λ) < 0.",
                                  "commonMistakes": "Esquecer que λ complexo ainda decai se Re(λ) < 0, focando só no módulo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar um Método Numérico e Observar o Comportamento Aproximado",
                                  "subSteps": [
                                    "Escolha o método de Euler explícito: y_{n+1} = y_n + h λ y_n = (1 + h λ) y_n.",
                                    "Analise o fator de amplificação |1 + h λ|: deve ter |1 + h λ| < 1 para decaimento.",
                                    "Simule para h pequeno (ex: h=0.1, λ=-1): y_n decai; para h grande (h=2): cresce.",
                                    "Repita com outro método, como Euler implícito, notando diferenças.",
                                    "Identifique a condição |R(h λ)| ≤ 1, onde R(z) é a função de estabilidade."
                                  ],
                                  "verification": "Implemente simulação e confirme que para h grande, y_n explode apesar de solução exata decaindo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB para simulações iterativas.",
                                  "tips": "Comece com λ real negativo para simplicidade antes de complexo.",
                                  "learningObjective": "Observar empiricamente a necessidade de não crescimento na aproximação.",
                                  "commonMistakes": "Usar h fixo sem variar para ver instabilidade, ou confundir erro de truncagem com instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar ao Conceito Geral de Estabilidade Numérica",
                                  "subSteps": [
                                    "Defina estabilidade numérica: solução numérica imita qualitativamente a exata (decaimento quando exata decai).",
                                    "Explique que para Re(λ) < 0, requer |R(h λ)| ≤ 1 para todo h>0 pequeno.",
                                    "Discuta região de estabilidade: {z ∈ ℂ | |R(z)| ≤ 1}, deve conter o eixo negativo.",
                                    "Generalize para sistemas lineares e EDOs não-lineares próximas.",
                                    "Conclua que crescimento da aproximação viola estabilidade numérica."
                                  ],
                                  "verification": "Escreva uma definição precisa e dê exemplo de método estável vs instável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas anteriores, diagrama da região de estabilidade no plano z = h λ.",
                                  "tips": "Memorize: 'Exata decai → Aproximada não cresce' como regra de ouro.",
                                  "learningObjective": "Estabelecer a ligação conceitual entre problema teste e estabilidade numérica.",
                                  "commonMistakes": "Confundir estabilidade numérica com consistência ou convergência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Sintetizar o Conceito",
                                  "subSteps": [
                                    "Resolva exercícios: para dado método, encontre h max para estabilidade com λ=-1.",
                                    "Compare estabilidade absoluta vs relativa (para solução limitada).",
                                    "Crie um fluxograma: Re(λ)<0 → Exata decai → Numérica |R|≤1 → Estável.",
                                    "Discuta limitações: A-stabilidade para métodos implícitos.",
                                    "Autoavalie com perguntas: Por que Euler explícito falha para h grande?"
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas de autoavaliação sobre o tópico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Lista de exercícios de livro ou online (ex: problemas de Dahlby).",
                                  "tips": "Use cores no fluxograma: verde para estável, vermelho para instável.",
                                  "learningObjective": "Sintetizar e aplicar o conceito de forma independente.",
                                  "commonMistakes": "Ignorar que estabilidade é qualitativa, não só precisão quantitativa."
                                }
                              ],
                              "practicalExample": "Considere y' = -1 y, y(0)=1 (solução exata y(t)=e^{-t} →0). Com Euler explícito e h=1.5: y1=(1-1.5)*1=-0.5, y2=(1-1.5)*(-0.5)=0.75, y3=-1.125, ... oscila e cresce em magnitude, enquanto exata decai. Para h=0.5: decai corretamente.",
                              "finalVerifications": [
                                "Explica corretamente por que |y_n| cresce quando |1 + h λ| >1 apesar de Re(λ)<0.",
                                "Desenha a região de estabilidade do Euler explícito (disco |1+z|≤1).",
                                "Identifica que métodos A-estáveis têm região incluindo todo eixo negativo.",
                                "Distingue estabilidade numérica de convergência.",
                                "Resolve um problema numérico simples confirmando decaimento ou crescimento.",
                                "Relaciona corretamente ao teorema de Lax-Wendroff para consistência + estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação do decaimento exato vs possível crescimento numérico (80%).",
                                "Correta identificação da condição |R(z)| ≤1 para z=hλ com Re(λ)<0 (90%).",
                                "Uso apropriado de exemplos numéricos/simulações para ilustrar (85%).",
                                "Clareza na distinção entre estabilidade absoluta e outros conceitos (75%).",
                                "Capacidade de generalizar para outros métodos numéricos (80%).",
                                "Profundidade nas conexões com região de estabilidade (85%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Decaimento radioativo modelado por y' = -λ y, simulando numericamente.",
                                "Computação: Implementação de solvers em Python/SciPy, analisando estabilidade.",
                                "Engenharia: Simulações de circuitos RLC onde amortecimento requer estabilidade numérica.",
                                "Estatística: Modelos estocásticos com ruído, preservando decaimento médio."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD) ou finanças (modelos Black-Scholes com decaimento), métodos numéricos instáveis causam explosões artificiais, levando a previsões erradas; entender isso garante simulações confiáveis em engenharia aeroespacial e previsão climática."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Função de Amplificação R(z)",
                        "description": "Função racional R(z) associada a um método numérico linear, onde z = h λ, tal que a iteração é y_{n+1} = R(z) y_n.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Derivar R(z) para métodos explícitos",
                            "description": "Calcular a função de amplificação R(z) = 1 + z para o método de Euler forward e R(z) para trapezoidal explícito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a equação teste escalar e a definição da função de amplificação R(z)",
                                  "subSteps": [
                                    "Escreva a equação diferencial teste y' = λ y, onde λ é um escalar complexo.",
                                    "Explique que métodos numéricos produzem esquemas de recorrência y_{n+1} = R(hλ) y_n.",
                                    "Defina z = h λ, onde h é o passo de tempo.",
                                    "Defina formalmente R(z) como o fator de amplificação tal que |R(z)| ≤ 1 garante estabilidade absoluta.",
                                    "Discuta a importância para análise de estabilidade em métodos lineares."
                                  ],
                                  "verification": "Capacidade de escrever corretamente y_{n+1} = R(z) y_n e definir z = h λ.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Notas de análise numérica ou livro-texto (cap. estabilidade)"
                                  ],
                                  "tips": "Lembre-se que λ pode ser complexo para capturar oscilações; z herda isso.",
                                  "learningObjective": "Compreender o modelo teste e o papel de R(z) na estabilidade.",
                                  "commonMistakes": "Confundir z = λ h com h λ (ordem não importa, mas consistência sim); ignorar natureza complexa de z."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar R(z) para o método de Euler Forward",
                                  "subSteps": [
                                    "Escreva o esquema do Euler forward: y_{n+1} = y_n + h f(t_n, y_n) = y_n + h λ y_n.",
                                    "Simplifique a expressão: y_{n+1} = y_n (1 + h λ) = y_n (1 + z).",
                                    "Identifique explicitamente R(z) = 1 + z.",
                                    "Verifique para z=0: R(0)=1, preservando solução constante.",
                                    "Discuta estabilidade condicional: |1 + z| ≤ 1."
                                  ],
                                  "verification": "Obter e escrever R(z) = 1 + z corretamente, com passos algébricos mostrados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Calculadora para testes numéricos opcionais"
                                  ],
                                  "tips": "Sempre isole o fator multiplicativo de y_n para identificar R(z) diretamente.",
                                  "learningObjective": "Derivar analiticamente R(z) para Euler forward a partir do esquema numérico.",
                                  "commonMistakes": "Esquecer de fatorar y_n; confundir com Euler backward (R(z)=1/(1-z))."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar R(z) para o método trapezoidal explícito (Heun)",
                                  "subSteps": [
                                    "Descreva o método: predictor y* = y_n + h λ y_n = (1 + z) y_n.",
                                    "Corrector: y_{n+1} = y_n + (h/2) (λ y_n + λ y*) = y_n + (z/2) (y_n + y*).",
                                    "Substitua y*: y_{n+1} = y_n + (z/2) (y_n + (1 + z) y_n) = y_n [1 + (z/2)(1 + 1 + z)].",
                                    "Simplifique: 1 + (z/2)(2 + z) = 1 + z + (1/2) z^2.",
                                    "Confirme R(z) = 1 + z + (1/2) z^2 e verifique consistência de ordem 2."
                                  ],
                                  "verification": "Derivação completa levando a R(z) = 1 + z + 0.5 z^2, sem erros algébricos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Referência ao esquema do método de Heun"
                                  ],
                                  "tips": "Expanda todos os termos antes de fatorar y_n para evitar erros de álgebra.",
                                  "learningObjective": "Derivar R(z) para método de dois estágios explícito.",
                                  "commonMistakes": "Usar trapezoidal implícito por engano (R(z)= (1 + z/2)/(1 - z/2)); errar substituição de y*."
                                }
                              ],
                              "practicalExample": "Para z = 0.1i (simulando oscilador), compute R(z) no Euler forward: 1 + 0.1i, |R| ≈ 1.005 >1 (instável). Para trapezoidal: 1 + 0.1i - 0.005 = 0.995 + 0.1i, |R| ≈ 1.0002 ≈1 (melhor).",
                              "finalVerifications": [
                                "R(z) = 1 + z para Euler forward derivado corretamente.",
                                "R(z) = 1 + z + (1/2) z^2 para trapezoidal explícito obtido.",
                                "Verificação em z=0: R(0)=1 para ambos.",
                                "Expansão em série de Taylor consistente com ordem do método.",
                                "Entendimento de que ambos são explícitos (polinômios em z)."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação (sem erros de simplificação).",
                                "Clareza nos passos, com fatoração explícita de y_n.",
                                "Correta identificação de z = h λ.",
                                "Verificação de casos especiais (z=0, consistência).",
                                "Comparação qualitativa de estabilidade.",
                                "Apresentação organizada com equações numeradas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/MATLAB para plotar região |R(z)|≤1.",
                                "Física: Análise de estabilidade em equações de movimento harmônico.",
                                "Engenharia de Controle: Estabilidade de sistemas discretos.",
                                "Ciências Computacionais: Desenvolvimento de solvers ODE estáveis."
                              ],
                              "realWorldApplication": "Na simulação numérica de equações diferenciais em engenharia (ex.: propagação de ondas sísmicas, modelagem climática), derivar R(z) permite selecionar h para estabilidade, evitando explosões numéricas em previsões de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Derivar R(z) para métodos implícitos",
                            "description": "Obter R(z) = 1 / (1 - z) para Euler backward e analisar sua propriedade |R(z)| ≤ 1 para Re(z) < 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Euler Backward Implícito",
                                  "subSteps": [
                                    "Recordar a equação teste de Dahlquist: y' = λ y, onde λ é complexo e z = h λ",
                                    "Escrever a discretização implícita: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}) = y_n + z y_{n+1}",
                                    "Rearranjar para y_{n+1} - z y_{n+1} = y_n",
                                    "Identificar a natureza implícita que requer resolução iterativa ou exata para o teste linear",
                                    "Verificar consistência: para h→0 (z→0), y_{n+1} ≈ y_n"
                                  ],
                                  "verification": "Escrever corretamente a fórmula implícita y_{n+1} (1 - z) = y_n e explicar por que é implícito.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas de análise numérica",
                                    "Quadro ou papel para equações",
                                    "Referência: Burden & Faires 'Análise Numérica' capítulo de ODEs"
                                  ],
                                  "tips": "Comece sempre pela equação diferencial linear para simplificar a derivação.",
                                  "learningObjective": "Compreender a formulação implícita do Euler backward e sua relação com o parâmetro z.",
                                  "commonMistakes": [
                                    "Confundir com Euler forward: y_{n+1} = y_n + z y_n",
                                    "Esquecer o argumento t_{n+1} na função f"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Função de Amplificação R(z)",
                                  "subSteps": [
                                    "Definir R(z) tal que y_{n+1} = R(z) y_n para o teste de estabilidade",
                                    "Substituir na equação implícita: R(z) y_n = y_n + z R(z) y_n",
                                    "Dividir por y_n (assumindo y_n ≠ 0): R(z) = 1 + z R(z)",
                                    "Isolar R(z): R(z) - z R(z) = 1 → R(z) (1 - z) = 1",
                                    "Resolver: R(z) = 1 / (1 - z)"
                                  ],
                                  "verification": "Obter explicitamente R(z) = 1 / (1 - z) e verificar R(0) = 1 (consistência).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como SymPy/MATLAB",
                                    "Papel para álgebra complexa"
                                  ],
                                  "tips": "Trate z como variável complexa desde o início para evitar erros em análises posteriores.",
                                  "learningObjective": "Derivar a função de amplificação R(z) a partir da recursão implícita.",
                                  "commonMistakes": [
                                    "Erro algébrico: escrever R(z) = 1 / (1 + z) como no Euler forward",
                                    "Ignorar o denominador corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Magnitude |R(z)| para Re(z) < 0",
                                  "subSteps": [
                                    "Escrever |R(z)| = 1 / |1 - z| onde z = x + i y com x = Re(z) < 0",
                                    "Calcular |1 - z|^2 = (1 - x)^2 + (-y)^2 = (1 - x)^2 + y^2",
                                    "Mostrar que para x ≤ 0, (1 - x) ≥ 1 e y^2 ≥ 0, logo |1 - z|^2 ≥ 1",
                                    "Concluir |1 - z| ≥ 1, portanto |R(z)| = 1 / |1 - z| ≤ 1",
                                    "Verificar igualdade: |R(z)| = 1 apenas em z=0; <1 em região estável"
                                  ],
                                  "verification": "Provar matematicamente |R(z)| ≤ 1 para todo z com Re(z) ≤ 0, com gráfico mental da meia-esquerda do plano complexo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Plano complexo desenhado",
                                    "Software de plotagem como Python matplotlib para |R(z)|"
                                  ],
                                  "tips": "Use desigualdade triangular ou geometria: distância de 1 a z é ≥1 quando z está na meia-esquerda.",
                                  "learningObjective": "Demonstrar a propriedade de estabilidade A do método Euler backward.",
                                  "commonMistakes": [
                                    "Afirmar |R(z)| <1 sempre, ignorando =1 em z=0",
                                    "Confundir Re(z)<0 com |z|<1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Interpretar a Estabilidade",
                                  "subSteps": [
                                    "Plotar ou esboçar a região de estabilidade {z : |R(z)| ≤ 1}, que é o semiplano Re(z) ≤ 0",
                                    "Comparar com Euler forward (círculo unitário)",
                                    "Discutir implicações: método implicitamente estável para passos h arbitrariamente grandes (se λ<0)",
                                    "Testar numericamente: para z=-2, R(-2)=1/3 ≈0.333, |R|<1",
                                    "Concluir que Euler backward é adequado para problemas rígidos"
                                  ],
                                  "verification": "Esboçar a região de estabilidade e confirmar que inclui toda a meia-esquerda do plano z.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software numérico (Python/Octave para contour plot de |R(z)|)",
                                    "Exemplos de EDOs rígidas"
                                  ],
                                  "tips": "Implemente uma plotagem rápida de |R(z)| para visualização intuitiva.",
                                  "learningObjective": "Interpretar a análise de |R(z)| em termos de estabilidade numérica prática.",
                                  "commonMistakes": [
                                    "Pensar que é instável por ser implícito",
                                    "Limitar análise a z real negativo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -y (λ=-1), h=2 (z=-2), Euler backward: y_{n+1} = y_n / (1 - (-2)) = y_n / 3 → R(-2)=1/3, |R|=1/3<1, solução numérica decai estável mesmo com h grande, ao contrário do Euler forward que explode.",
                              "finalVerifications": [
                                "Derivação correta de R(z) = 1/(1-z)",
                                "Prova completa de |R(z)| ≤ 1 para Re(z) ≤ 0",
                                "Verificação limite z→0: R(z)→1",
                                "Exemplo numérico com |R(z)| calculado",
                                "Esboço da região de estabilidade",
                                "Comparação qualitativa com métodos explícitos"
                              ],
                              "assessmentCriteria": [
                                "Correção algébrica na derivação de R(z) (100%)",
                                "Rigor na prova de |R(z)| ≤1 usando módulo complexo (90-100%)",
                                "Profundidade dos substeps e avoidance de erros comuns (80-90%)",
                                "Clareza na interpretação da estabilidade incondicional (70-80%)",
                                "Uso de exemplo prático e verificações (60-70%)",
                                "Visualização ou plot da região (bônus)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos ou decaimento exponencial",
                                "Computação: Implementação de solvers implícitos em SciPy (solve_ivp com method='BDF')",
                                "Engenharia: Análise de sistemas lineares em controle automático (polos no semiplano esquerdo)",
                                "Matemática Aplicada: Teoria de perturbação em métodos numéricos para EDOs rígidas"
                              ],
                              "realWorldApplication": "Em modelagem de reações químicas rígidas ou circuitos elétricos RC em engenharia, permite passos de tempo grandes sem instabilidade numérica, otimizando simulações em software como COMSOL ou MATLAB Simulink para designs industriais eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Generalizar para métodos multistep",
                            "description": "Derivar R(z) para métodos lineares multistep, como Adams-Bashforth e Adams-Moulton, usando a forma polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a forma geral dos métodos lineares multistep (LMM)",
                                  "subSteps": [
                                    "Estude a equação geral dos LMM: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f(t_{n+j}, y_{n+j}).",
                                    "Identifique os polinômios ρ(ξ) = ∑_{j=0}^k α_j ξ^j e σ(ξ) = ∑_{j=0}^k β_j ξ^j.",
                                    "Classifique métodos explícitos (β_k = 0) e implícitos (β_k ≠ 0), com exemplos como Adams-Bashforth e Adams-Moulton.",
                                    "Verifique consistência: ρ(1) = ρ'(1) = 0 e σ(1) = 1.",
                                    "Anote os coeficientes para AB e AM de ordens baixas (ex: AB2, AM2)."
                                  ],
                                  "verification": "Liste corretamente ρ(ξ) e σ(ξ) para pelo menos dois métodos multistep.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta",
                                    "Notas de aula sobre estabilidade"
                                  ],
                                  "tips": "Comece com k=1 (método de Euler) para conectar com métodos one-step.",
                                  "learningObjective": "Compreender a representação polinomial dos LMM e seus polinômios associados.",
                                  "commonMistakes": [
                                    "Confundir índices j em ρ e σ",
                                    "Esquecer normalização σ(1)=1",
                                    "Ignorar diferença explícito/implícito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o método multistep à equação teste y' = λ y",
                                  "subSteps": [
                                    "Substitua f(t_{n+j}, y_{n+j}) = λ y_{n+j} na equação LMM.",
                                    "Obtenha a relação recorrente: ∑_{j=0}^k α_j y_{n+j} = h λ ∑_{j=0}^k β_j y_{n+j}.",
                                    "Reescreva como ∑_{j=0}^k (α_j - z β_j) y_{n+j} = 0, onde z = h λ.",
                                    "Expresse em termos do operador de avanço E: ρ(E) y_n - z σ(E) y_n = 0.",
                                    "Confirme que y_n = R(z)^n y_0 é solução exata para a recorrente."
                                  ],
                                  "verification": "Derive corretamente a equação ∑ (α_j - z β_j) y_{n+j} = 0 a partir da substituição.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Caderno de exercícios",
                                    "Software simbólico como SymPy ou Mathematica",
                                    "Tabela de coeficientes AB/AM"
                                  ],
                                  "tips": "Use y_{n+j} = E^j y_n para simplificar a notação.",
                                  "learningObjective": "Transformar o LMM na equação modelo para obter a dependência em z = h λ.",
                                  "commonMistakes": [
                                    "Substituir f incorretamente",
                                    "Esquecer o fator h em z",
                                    "Confundir y_{n+j} com y_n"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a equação característica ρ(ζ) - z σ(ζ) = 0",
                                  "subSteps": [
                                    "Da recorrente [ρ(E) - z σ(E)] y_n = 0, assuma y_n = ζ^n y_0, levando a ρ(ζ) - z σ(ζ) = 0.",
                                    "Identifique que ζ satisfaz essa equação polinomial de grau k.",
                                    "Defina R(z) como as raízes ζ de ρ(ζ) = z σ(ζ).",
                                    "Discuta o polinômio característico p(ζ; z) = ρ(ζ) - z σ(ζ) = 0.",
                                    "Verifique para método one-step (k=1): recupera R(z) = 1 + z para Euler forward."
                                  ],
                                  "verification": "Escreva explicitamente p(ζ; z) = 0 e identifique R(z) como suas raízes.",
                                  "estimatedTime": "50 minutes",
                                  "materials": [
                                    "Calculadora simbólica",
                                    "Exemplos resolvidos de livros",
                                    "Planilha para polinômios"
                                  ],
                                  "tips": "Normalize dividindo por α_k se necessário para monico.",
                                  "learningObjective": "Estabelecer a conexão entre a recorrente e o polinômio característico para R(z).",
                                  "commonMistakes": [
                                    "Escrever ρ(ζ) - z σ(ζ) ao invés de =0",
                                    "Confundir ζ com z",
                                    "Ignorar múltiplas raízes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar R(z) para Adams-Bashforth e Adams-Moulton",
                                  "subSteps": [
                                    "Para AB2: ρ(ξ)= ξ^2 - ξ, σ(ξ)= (3/2)ξ^2 - (1/2)ξ; resolva ρ(ζ)=z σ(ζ).",
                                    "Para AM2 (trapezoidal): ρ(ξ)= ξ^2 - ξ, σ(ξ)= (1/2)ξ^2 + (1/2)ξ; derive R(z).",
                                    "Plote |R(z)| no plano complexo para z com Re(z)<0.",
                                    "Compare estabilidade: AB explícito vs AM implícito.",
                                    "Generalize: R(z) aproxima e^{z} para ordem alta."
                                  ],
                                  "verification": "Compute R(z) explicitamente para AB2 e verifique |R(i y)| ≈1 para y real.",
                                  "estimatedTime": "75 minutes",
                                  "materials": [
                                    "MATLAB ou Python (NumPy/SymPy)",
                                    "Gráficos de região de estabilidade",
                                    "Tabelas de coeficientes AB/AM"
                                  ],
                                  "tips": "Use expansão em série para verificar ordem: R(z) = 1 + z + O(z^{k+1}).",
                                  "learningObjective": "Aplicar a derivação a métodos específicos e interpretar R(z) para estabilidade.",
                                  "commonMistakes": [
                                    "Coeficientes errados de AB/AM",
                                    "Não resolver o polinômio corretamente",
                                    "Ignorar principal raiz |R|<1"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e generalizar para métodos multistep arbitrários",
                                  "subSteps": [
                                    "Escolha um LMM genérico de ordem 3 e derive R(z).",
                                    "Analise condições de estabilidade A-stabilidade (para implícitos).",
                                    "Discuta ordem de precisão via derivadas de ρ e σ.",
                                    "Compare com métodos one-step via Dahlquist.",
                                    "Resuma: R(z) define a região de estabilidade {z : max |R(z)| ≤ 1}."
                                  ],
                                  "verification": "Derive R(z) para um método de ordem 3 e descreva sua região de estabilidade.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Software de plotting (Matplotlib)",
                                    "Referências acadêmicas sobre LMM",
                                    "Exercícios propostos"
                                  ],
                                  "tips": "Foco na raiz principal R_0(z) ≈ e^z; ignore raízes espúrias se |R_p| <1.",
                                  "learningObjective": "Generalizar a derivação e conectar com análise de estabilidade avançada.",
                                  "commonMistakes": [
                                    "Confundir raízes principais e espúrias",
                                    "Não considerar |R(z)| ≤1 no semiplano esquerdo",
                                    "Esquecer A-contratatividade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para Adams-Bashforth de ordem 2 (AB2): ρ(ζ) = ζ^2 - ζ, σ(ζ) = (3/2)ζ^2 - (1/2)ζ. Resolva ζ^2 - ζ = z [(3/2)ζ^2 - (1/2)ζ], levando ao polinômio quadrático (1 - 3z/2) ζ^2 + (z/2 - 1) ζ = 0. As raízes R(z) são calculadas via fórmula quadrática, com R_0(z) ≈ 1 + z + (1/2)z^2 para pequena z.",
                              "finalVerifications": [
                                "Deriva corretamente ρ(ζ) - z σ(ζ) = 0 para AB2 e AM2.",
                                "Identifica a raiz principal R_0(z) ≈ e^z.",
                                "Verifica |R(z)| ≤ 1 para z no semiplano esquerdo em métodos A-estáveis.",
                                "Compara regiões de estabilidade de métodos explícitos vs implícitos.",
                                "Explica impacto de raízes espúrias na estabilidade.",
                                "Aplica a generalização a um LMM de ordem arbitrária."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação de R(z) (peso 30%).",
                                "Precisão nos polinômios ρ e σ para exemplos dados (20%).",
                                "Interpretação qualitativa de estabilidade via |R(z)| (20%).",
                                "Uso correto de ferramentas simbólicas/numéricas (15%).",
                                "Conexão com conceitos prévios (one-step) e generalização (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação de solvers multistep em Python (SciPy odeint).",
                                "Física: Análise de estabilidade em simulações dinâmicas (ex: osciladores).",
                                "Engenharia: Otimização de integradores em controle de sistemas.",
                                "Estatística: Modelos estocásticos e barulho numérico."
                              ],
                              "realWorldApplication": "Em software de simulação como MATLAB ODE solvers ou previsão numérica do tempo (modelos ECMWF), onde métodos multistep como Adams são usados para EDOs rígidas, garantindo estabilidade em escalas longas sem amortecimento artificial via análise de R(z)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Definição e Análise da Região de Estabilidade",
                        "description": "Conjunto S = { z ∈ ℂ : |R(z)| ≤ 1 }, região no plano complexo z = h λ para a qual o método é estável absoluto.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Definir e representar a região S",
                            "description": "Definir formalmente a região de estabilidade S e descrever como plotá-la no plano complexo para métodos de Euler forward (disco unitário) e backward (meio-plano esquerdo).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição geral da região de estabilidade S",
                                  "subSteps": [
                                    "Estude a definição formal: S = {z ∈ ℂ | |R(z)| ≤ 1}, onde R(z) é a função de amplificação do método numérico.",
                                    "Revise o teste de estabilidade para EDOs lineares y' = λy, com λ ∈ ℂ.",
                                    "Analise como z = hλ representa o produto passo-tamanho × autovalor."
                                  ],
                                  "verification": "Escreva a definição de S em suas palavras e identifique z = hλ corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Lembre-se que S garante que a solução numérica não cresça mais que a exata para passos pequenos.",
                                  "learningObjective": "Dominar o conceito fundamental de região de estabilidade no plano complexo.",
                                  "commonMistakes": "Confundir S com o plano de estabilidade absoluto; S é relativa ao método."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a região S para o método Euler forward",
                                  "subSteps": [
                                    "Derive a função de amplificação R(z) = 1 + z para Euler forward: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Determine S_forward = {z ∈ ℂ | |1 + z| ≤ 1}, que é o disco unitário centrado em -1 com raio 1.",
                                    "Verifique com exemplos: para z reais negativos, |1 + z| ≤ 1 implica z ≥ -2."
                                  ],
                                  "verification": "Calcule |1 + z| ≤ 1 e confirme que é o disco |z + 1| ≤ 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (ex: SymPy)",
                                    "Papel milimetrado para esboço inicial"
                                  ],
                                  "tips": "Use desigualdade triangular para bounding: |1 + z| ≤ 1 + |z| não é suficiente; resolva rigorosamente.",
                                  "learningObjective": "Derivar e caracterizar analiticamente S para Euler explícito.",
                                  "commonMistakes": "Esquecer que é disco centrado em -1, não originado; confundir com |z| ≤ 1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a região S para o método Euler backward",
                                  "subSteps": [
                                    "Derive R(z) = 1 / (1 - z) para Euler backward: y_{n+1} - y_n = h f(t_{n+1}, y_{n+1}).",
                                    "Determine S_backward = {z ∈ ℂ | |1 / (1 - z)| ≤ 1}, equivalente a Re(z) ≤ 0 (meio-plano esquerdo).",
                                    "Prove: |1 - z| ≥ 1 para Re(z) ≤ 0, usando geometria complexa."
                                  ],
                                  "verification": "Mostre que para Re(z) > 0, existe amplificação >1 em iterações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (ex: MATLAB, Python/Matplotlib)",
                                    "Notas da aula sobre métodos implícitos"
                                  ],
                                  "tips": "Pense em termos de autovalores: método A-estável para semi-plano esquerdo.",
                                  "learningObjective": "Entender a superioridade do backward para problemas rígidos.",
                                  "commonMistakes": "Confundir com plano direito; ignorar que backward é incondicionalmente estável para Re(λ)<0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Representar graficamente as regiões S no plano complexo",
                                  "subSteps": [
                                    "Plote S_forward: círculo |z + 1| = 1 no plano complexo.",
                                    "Plote S_backward: linha Re(z) = 0 e sombreie o lado esquerdo.",
                                    "Compare as duas regiões, destacando diferenças (ex: forward condicional)."
                                  ],
                                  "verification": "Gere um gráfico com ambas regiões sobrepostas e legendas corretas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com Matplotlib ou GeoGebra",
                                    "Papel e lápis para rascunho"
                                  ],
                                  "tips": "Use eixos Re(z) horizontal, Im(z) vertical; marque origem e pontos teste (ex: z=-1).",
                                  "learningObjective": "Visualizar e contrastar regiões de estabilidade.",
                                  "commonMistakes": "Invertar eixos; não sombrear corretamente o semi-plano; escala inadequada."
                                }
                              ],
                              "practicalExample": "Para resolver y' = -10y + sin(t) com h=0.1, verifique se z = hλ = -1 está em S_forward (| -1 +1 | =0 ≤1, ok) mas para λ=-100, z=-10 fora do disco, instável; para backward, Re(z)<0 sempre ok.",
                              "finalVerifications": [
                                "Define corretamente S = {z | |R(z)| ≤1} ?",
                                "Identifica S_forward como disco unitário centrado em -1?",
                                "Descreve S_backward como {Re(z) ≤ 0}?",
                                "Plota ambas regiões com precisão no plano complexo?",
                                "Explica diferenças em estabilidade condicional vs incondicional?",
                                "Verifica pontos teste corretamente?"
                              ],
                              "assessmentCriteria": [
                                "Precisão da definição formal de S (20%)",
                                "Corretude da derivação de R(z) para ambos métodos (25%)",
                                "Qualidade e acurácia do plot gráfico (25%)",
                                "Compreensão das implicações para EDOs rígidas (15%)",
                                "Uso correto de terminologia complexa (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e análise espectral de matrizes Jacobianas.",
                                "Programação Computacional: implementação de plots em Python/MATLAB para visualização numérica.",
                                "Física: estabilidade em simulações de osciladores harmônicos dissipativos.",
                                "Engenharia: análise de sistemas de controle lineares discretos."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais rígidas, como modelos de circuitos elétricos (R-C), dinâmica de fluidos ou finanças (modelos Black-Scholes), escolher Euler backward garante estabilidade sem restringir h, evitando explosões numéricas em previsões de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1",
                              "10.1.4.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Verificar estabilidade para dado hλ",
                            "description": "Dado um método e um valor z = h λ, determinar se z ∈ S calculando |R(z)| e relacionar com restrições em h para problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o método numérico e sua região de estabilidade S",
                                  "subSteps": [
                                    "Identificar o método de integração dado (ex.: Euler explícito, Runge-Kutta).",
                                    "Recordar a função de amplificação R(z) associada ao método.",
                                    "Definir a região de estabilidade S como {z ∈ ℂ | |R(z)| ≤ 1}.",
                                    "Descrever as propriedades de S, como disco no semiplano esquerdo para métodos explícitos.",
                                    "Esboçar qualitativamente a região S no plano complexo."
                                  ],
                                  "verification": "Capacidade de enunciar corretamente R(z) e definir S com precisão, confirmada por descrição escrita ou esboço.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Anotações de análise numérica",
                                    "Papel milimetrado ou software de plotagem (ex.: GeoGebra)",
                                    "Tabela de regiões de estabilidade comuns"
                                  ],
                                  "tips": "Memorize R(z) para métodos padrão: Euler explícito R(z) = 1 + z; Trapezoidal R(z) = (1 + z/2)/(1 - z/2).",
                                  "learningObjective": "Compreender a definição formal da região de estabilidade absoluta.",
                                  "commonMistakes": [
                                    "Confundir região de estabilidade com ordem de precisão.",
                                    "Esquecer que S é definida por |R(z)| ≤ 1 para um passo de tempo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o valor z = h λ",
                                  "subSteps": [
                                    "Obter os valores de h (passo de tempo) e λ (autovalor ou taxa de crescimento, geralmente complexo com Re(λ) < 0).",
                                    "Realizar a multiplicação z = h * λ, considerando partes real e imaginária.",
                                    "Verificar unidades e sinal: h > 0, Re(λ) < 0 para problemas dissipativos.",
                                    "Plotar z no plano complexo para visualização intuitiva.",
                                    "Confirmar se |z| é pequeno, típico para problemas stiff."
                                  ],
                                  "verification": "Cálculo aritmético exato de z, com partes real e imaginária corretas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/MATLAB",
                                    "Plano complexo impresso"
                                  ],
                                  "tips": "Use números complexos em notação retangular: z = a + bi.",
                                  "learningObjective": "Dominar o mapeamento do problema físico (λ) para o parâmetro de estabilidade z.",
                                  "commonMistakes": [
                                    "Inverter h e λ.",
                                    "Ignorar a parte imaginária de λ em oscilações."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar se z ∈ S computando |R(z)|",
                                  "subSteps": [
                                    "Substituir z na fórmula R(z) do método identificado.",
                                    "Calcular R(z), que resulta em um número complexo.",
                                    "Computar o módulo |R(z)| = √(Re(R)^2 + Im(R)^2).",
                                    "Comparar |R(z)| com 1: se ≤ 1, z ∈ S (estável); senão, instável.",
                                    "Analisar numericamente com aproximações se z complexo."
                                  ],
                                  "verification": "Resultado correto de |R(z)| e decisão booleana (estável/instável).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software numérico (ex.: Python com cmath)",
                                    "Folha de cálculos"
                                  ],
                                  "tips": "Para métodos lineares, R(z) é polinomial; use expansões de Taylor se necessário.",
                                  "learningObjective": "Aplicar a função de amplificação para teste de estabilidade.",
                                  "commonMistakes": [
                                    "Calcular R(|z|) em vez de |R(z)|.",
                                    "Usar norma L1 ou L∞ em vez de módulo euclidiano."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar o resultado com restrições em h para problemas stiff",
                                  "subSteps": [
                                    "Interpretar: se z ∉ S, reduzir h até |R(z)| ≤ 1.",
                                    "Derivar restrição aproximada: para Re(λ) << 0 (stiff), h < c / |λ| onde c depende de S.",
                                    "Explicar implicações: métodos explícitos exigem h muito pequeno em stiff.",
                                    "Comparar com métodos implícitos (A-estáveis, S = semiplano esquerdo).",
                                    "Documentar a condição de estabilidade final para o problema."
                                  ],
                                  "verification": "Enunciação correta da restrição h_max e justificativa para stiff.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos de problemas stiff",
                                    "Gráficos de regiões S"
                                  ],
                                  "tips": "Para Euler explícito, h < 2 / |λ| aproximadamente.",
                                  "learningObjective": "Conectar estabilidade local com escolha prática de h em ODEs stiff.",
                                  "commonMistakes": [
                                    "Ignorar rigidez: assumir h livre.",
                                    "Confundir estabilidade com precisão truncada."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o método de Euler explícito (R(z) = 1 + z) e um problema stiff com λ = -100, h = 0.01. Calcule z = -1, |R(z)| = |1 - 1| = 0 < 1 → estável. Se h = 0.03, z = -3, |R(z)| = |1 - 3| = 2 > 1 → instável, restringindo h < 0.02.",
                              "finalVerifications": [
                                "Cálculo correto de z = h λ.",
                                "Computação precisa de R(z) e |R(z)|.",
                                "Decisão correta de z ∈ S.",
                                "Restrição em h explicitada para stiff.",
                                "Interpretação qualitativa da rigidez.",
                                "Esboço ou plot de z vs. S."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (100% correto).",
                                "Compreensão conceitual de S e R(z) demonstrada.",
                                "Capacidade de generalizar restrições para h.",
                                "Identificação de implicações para métodos explícitos/implícitos.",
                                "Clareza na documentação e visualizações.",
                                "Tratamento adequado de λ complexo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de equações diferenciais de movimento rígido.",
                                "Computação: Implementação de testes de estabilidade em código Python/MATLAB.",
                                "Engenharia: Análise de rigidez em modelos de controle e CFD.",
                                "Estatística: Análise de erro em métodos Monte Carlo para ODEs."
                              ],
                              "realWorldApplication": "Em simulações numéricas de reações químicas stiff (ex.: cinética em reatores), verificar estabilidade garante que o solucionador não diverge, permitindo h otimizado para eficiência computacional em softwares como COMSOL ou ODE solvers em SciPy."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Comparar regiões para métodos explícitos e implícitos",
                            "description": "Comparar regiões de estabilidade de métodos de Runge-Kutta explícitos (limitadas) versus implícitos (A-estáveis, como TR-BDF2), e discutir implicações para problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar regiões de estabilidade de métodos Runge-Kutta explícitos",
                                  "subSteps": [
                                    "Recordar a definição de região de estabilidade para métodos lineares multistep e Runge-Kutta.",
                                    "Analisar exemplos clássicos como RK2 e RK4, calculando seus polinômios de estabilidade.",
                                    "Esboçar ou plotar graficamente a região de estabilidade no plano complexo z = hλ.",
                                    "Identificar limitações: regiões finitas e restritas ao semiplano direito e parte esquerda."
                                  ],
                                  "verification": "Esboço ou gráfico correto da região de estabilidade do RK4, mostrando interseção limitada com o semiplano esquerdo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de plotagem (Python com Matplotlib ou MATLAB)",
                                    "Notas de aula sobre polinômios de estabilidade"
                                  ],
                                  "tips": "Comece com o teste de Dahlquist para equações modelo y' = λy, focando em |R(z)| ≤ 1.",
                                  "learningObjective": "Compreender as características limitadas das regiões de estabilidade explícitas.",
                                  "commonMistakes": [
                                    "Confundir região de consistência com estabilidade",
                                    "Ignorar a dependência do passo h na forma z = hλ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar regiões de estabilidade de métodos implícitos, com foco em A-estabilidade",
                                  "subSteps": [
                                    "Definir A-estabilidade: região inclui todo o semiplano esquerdo Re(z) < 0.",
                                    "Analisar métodos implícitos Runge-Kutta, como Backward Euler e Radau IIA.",
                                    "Explorar o método TR-BDF2: combinação de trapezoidal e BDF2, com propriedades A(α)-estáveis.",
                                    "Plotar ou descrever graficamente a região de estabilidade ilimitada no semiplano esquerdo."
                                  ],
                                  "verification": "Descrição precisa da A-estabilidade do TR-BDF2 e esboço de sua região abrangente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Referências bibliográficas (ex: Hairer 'Solving ODEs'), software para plotar regiões",
                                    "Calculadora ou Python para computar polinômios"
                                  ],
                                  "tips": "Verifique a propriedade L-estável para métodos com |R(iy)| → 0 quando |y| → ∞.",
                                  "learningObjective": "Reconhecer vantagens dos métodos implícitos para estabilidade incondicional.",
                                  "commonMistakes": [
                                    "Achar que todos implícitos são A-estáveis (nem DIRK nem SDIRK sempre são)",
                                    "Subestimar custo computacional dos implícitos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar graficamente e analiticamente as regiões de estabilidade",
                                  "subSteps": [
                                    "Superpor gráficos de regiões explícitas (RK4) e implícitas (TR-BDF2) no plano complexo.",
                                    "Comparar tamanhos: explícitos limitados vs. implícitos ilimitados no semiplano esquerdo.",
                                    "Analisar interseções e diferenças quantitativas (ex: raio máximo no eixo real negativo).",
                                    "Discutir trade-offs: precisão vs. estabilidade e custo por passo."
                                  ],
                                  "verification": "Gráfico comparativo com legendas corretas e tabela de métricas (ex: área da região).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de visualização (Desmos, GeoGebra ou Python)",
                                    "Modelos prontos de regiões de estabilidade"
                                  ],
                                  "tips": "Use escalas logarítmicas para visualizar melhor o semiplano esquerdo amplo.",
                                  "learningObjective": "Visualizar e quantificar diferenças entre regiões explícitas e implícitas.",
                                  "commonMistakes": [
                                    "Plotar incorretamente o eixo imaginário",
                                    "Ignorar que explícitos podem ser melhores para não-stiff"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir implicações para problemas stiff",
                                  "subSteps": [
                                    "Definir problemas stiff: autovalores com partes reais negativas grandes em magnitude.",
                                    "Explicar por que explícitos falham (passo h restrito por estabilidade, não precisão).",
                                    "Mostrar como implícitos permitem h maior, reduzindo custo total para stiff.",
                                    "Analisar cenários: não-stiff (explícitos preferíveis) vs. stiff (implícitos essenciais)."
                                  ],
                                  "verification": "Relatório curto justificando escolha de método para um problema stiff exemplo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos numéricos de problemas stiff (ex: van der Pol com μ grande)",
                                    "Artigos ou livros sobre ODEs stiff"
                                  ],
                                  "tips": "Considere solvers adaptativos que alternam métodos baseado em rigidez detectada.",
                                  "learningObjective": "Aplicar comparação à seleção de métodos para classes de problemas específicos.",
                                  "commonMistakes": [
                                    "Confundir stiff com não-linear",
                                    "Achar que implícitos são sempre melhores (custo por passo maior)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o problema stiff y' = -1000(y - cos(t)) + sin(t), y(0)=1: compare simulações com RK4 (h max ~0.001 para estabilidade) vs. TR-BDF2 (h~0.1 estável), plotando trajetórias e tempos de CPU.",
                              "finalVerifications": [
                                "Esboça corretamente regiões de RK4 (limitada) e TR-BDF2 (A-estável).",
                                "Identifica que implícitos lidam melhor com semiplano esquerdo amplo.",
                                "Explica implicações para stiff: h maior com implícitos.",
                                "Compara trade-offs de custo/precisão verbalmente.",
                                "Sugere método adequado para um problema dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de regiões (90% correto).",
                                "Qualidade dos gráficos comparativos (clareza e legendas).",
                                "Profundidade na discussão de stiff (exemplos concretos).",
                                "Correção nas implicações práticas (sem generalizações erradas).",
                                "Criatividade em conexões com aplicações reais.",
                                "Uso correto de terminologia técnica.",
                                "Capacidade de sintetizar trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de dinâmica molecular stiff.",
                                "Engenharia: controle de sistemas (ex: circuitos RLC stiff).",
                                "Ciência da Computação: implementação de solvers em bibliotecas como SciPy.",
                                "Química: cinética reacional com escalas rápidas/lentas."
                              ],
                              "realWorldApplication": "Em modelagem de reações químicas stiff (ex: combustão), métodos implícitos como TR-BDF2 permitem simulações eficientes de redes com milhares de equações, usadas em design de catalisadores e previsão climática."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.4",
                            "name": "Analisar controle de passo via região S",
                            "description": "Explicar como o controle adaptativo de h garante h λ ∈ S, integrando com conceitos de estabilidade para métodos de passo variável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição e Propriedades da Região de Estabilidade S",
                                  "subSteps": [
                                    "Defina a região de estabilidade S para um método numérico explícito ou implícito.",
                                    "Desenhe graficamente a região S no plano complexo para métodos como Euler ou Runge-Kutta.",
                                    "Identifique os componentes rígidos da equação diferencial que determinam λ (autovalores).",
                                    "Explique o papel de h (passo de tempo) na ampliação hλ para verificar inclusão em S.",
                                    "Discuta como S varia com ordens de métodos multistep ou Runge-Kutta."
                                  ],
                                  "verification": "Construa e rotule corretamente um diagrama da região S para um método RK4, confirmando inclusão de pontos hλ estáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), papel graficada, software como MATLAB ou Python (NumPy/Matplotlib).",
                                  "tips": "Use o plano complexo com eixo real horizontal e imaginário vertical para visualização intuitiva.",
                                  "learningObjective": "Compreender a geometria e significado da região S para estabilidade A-estável.",
                                  "commonMistakes": "Confundir região de estabilidade absoluta com relativa; ignorar o semiplano esquerdo para problemas rígidos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Controle Adaptativo de Passo h em Solvers ODE",
                                  "subSteps": [
                                    "Descreva o algoritmo de controle de passo baseado em estimadores de erro local (ex: embedded RK).",
                                    "Explique o cálculo de h_new = h * (tol / err)^{1/(p+1)}, onde p é a ordem.",
                                    "Integre o conceito de rejeição/aceitação de passos para convergência.",
                                    "Discuta trade-offs entre precisão e eficiência computacional.",
                                    "Implemente um pseudocódigo simples para ajuste de h."
                                  ],
                                  "verification": "Simule um passo adaptativo em uma ODE simples e verifique se h é ajustado corretamente para erro < tol.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python (SciPy odeint ou solve_ivp), notebook Jupyter, exemplos de ODEs rígidas como y' = -1000y.",
                                  "tips": "Comece com tolerâncias conservadoras (tol=1e-6) para observar rejeições iniciais.",
                                  "learningObjective": "Dominar o mecanismo de ajuste dinâmico de h para balancear erro e custo.",
                                  "commonMistakes": "Usar expoente errado no fator de escala; não lidar com rejeições múltiplas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Garantia de hλ ∈ S no Controle Adaptativo",
                                  "subSteps": [
                                    "Derive a condição hλ ∈ S como critério de estabilidade local para componentes rígidos.",
                                    "Explique como estimar λ via autovalores da Jacobiana da ODE.",
                                    "Integre verificação explícita: compute |R(hλ)| < 1 para polinômio de estabilidade R(z).",
                                    "Descreva ajustes de h para forçar inclusão em S durante refinamento adaptativo.",
                                    "Compare com métodos sem controle de estabilidade (apenas erro local)."
                                  ],
                                  "verification": "Para uma ODE dada, calcule h tal que hλ ∈ S e simule para confirmar ausência de oscilações.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB Symbolic Toolbox ou SymPy para autovalores, gráficos de regiões S pré-computados.",
                                  "tips": "Priorize componentes rígidos (λ com Re(λ) << 0) para determinar h máximo.",
                                  "learningObjective": "Explicar matematicamente como o controle garante estabilidade via inclusão em S.",
                                  "commonMistakes": "Negligenciar parte imaginária de λ; assumir S infinita para métodos explícitos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar com Estabilidade em Métodos de Passo Variável",
                                  "subSteps": [
                                    "Analise impacto de passos variáveis na estabilidade global usando Dahlquist.",
                                    "Discuta detecção de rigidez via razão |λ_rígido / λ_suave| e ajuste h accordingly.",
                                    "Compare solvers explícitos vs. implícitos (BDF) em termos de S.",
                                    "Implemente um solver híbrido com cheque hλ ∈ S.",
                                    "Avalie convergência em problemas stiff como Van der Pol."
                                  ],
                                  "verification": "Resolva uma ODE stiff com passo variável, plotando h(t) e confirmando estabilidade sem blow-up.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "SciPy solve_ivp com method='RK45' e 'BDF', benchmarks de problemas stiff.",
                                  "tips": "Monitore norma do resíduo para validar estabilidade prática.",
                                  "learningObjective": "Integrar controle de passo com análise de estabilidade para solvers robustos.",
                                  "commonMistakes": "Subestimar overhead de Jacobianas; ignorar ordem de consistência em passos variáveis."
                                }
                              ],
                              "practicalExample": "Considere a ODE y' = -100y + sin(t), com λ ≈ -100 (rígido). Para RK4, S é disco |z| < 2√2. Controle adaptativo inicia h=0.1, verifica hλ ≈ -10 ∈ S (ok), mas se err > tol, reduz h para garantir inclusão e estabilidade sem oscilações.",
                              "finalVerifications": [
                                "Derivar corretamente h_max = min(|S|/|λ|) para inclusão.",
                                "Simular ODE stiff sem blow-up usando controle hλ ∈ S.",
                                "Explicar verbalmente integração com erro local em 2 minutos.",
                                "Plotar trajetória h(t) mostrando adaptação à rigidez.",
                                "Comparar eficiência com solver fixo-h.",
                                "Identificar falha em método sem cheque S."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de S e hλ ∈ S (80% peso).",
                                "Correção matemática em derivações e pseudocódigo (15%).",
                                "Qualidade de simulações e gráficos (5%).",
                                "Integração conceitual com estabilidade passo-variável.",
                                "Identificação de erros comuns e soluções.",
                                "Aplicação em exemplo stiff realista."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de osciladores amortecidos rígidos.",
                                "Computação: Otimização de algoritmos ODE em SciPy/MATLAB.",
                                "Engenharia: Controle de sistemas dinâmicos em tempo real.",
                                "Estatística: Análise de incerteza em modelos estocásticos stiff."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional) para previsão meteorológica, controle adaptativo via região S previne instabilidades em escalas rígidas multiescala, permitindo passos eficientes em turbulência sem crash do solver."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "A-estabilidade",
                    "description": "Propriedade de métodos cuja região de estabilidade inclui o semiplano esquerdo do plano complexo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Definição de A-estabilidade",
                        "description": "Propriedade fundamental de métodos numéricos para equações diferenciais ordinárias (EDOs) que garante estabilidade absoluta para todo o semiplano esquerdo do plano complexo, essencial para problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Definir A-estabilidade formalmente",
                            "description": "Explicar que um método é A-estável se a região de estabilidade absoluta contém o semiplano {z ∈ ℂ | Re(z) ≤ 0}, ou seja, |R(z)| ≤ 1 para todo z com parte real não positiva, onde R(z) é a função de amplificação do método linear de teste y' = λy.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema de teste linear y' = λy",
                                  "subSteps": [
                                    "Lembre-se da solução exata: y(t) = y(0) e^{λt}.",
                                    "Explique por que λ ∈ ℂ com Re(λ) < 0 representa decaimento.",
                                    "Discuta a discretização numérica: y_{n+1} = R(hλ) y_n, onde h é o passo.",
                                    "Identifique z = hλ como a variável complexa de estabilidade.",
                                    "Esboce exemplos de λ reais negativos e complexos no semiplano esquerdo."
                                  ],
                                  "verification": "Escrever a relação de recursão y_{n+1} = R(z) y_n e identificar z = hλ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (cap. estabilidade)",
                                    "Caderno para anotações",
                                    "Calculadora ou Wolfram Alpha"
                                  ],
                                  "tips": "Visualize o semiplano esquerdo no plano complexo para intuitar a estabilidade.",
                                  "learningObjective": "Entender o modelo linear de teste e sua discretização numérica.",
                                  "commonMistakes": [
                                    "Confundir λ com hλ",
                                    "Ignorar que λ pode ser complexo",
                                    "Esquecer a solução exata exponencial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a função de amplificação R(z)",
                                  "subSteps": [
                                    "Derive R(z) para métodos Runge-Kutta lineares a partir da relação de recursão.",
                                    "Explique que R(z) é um polinômio racional: R(z) = P(z)/Q(z).",
                                    "Verifique que R(0) = 1 para consistência de ordem 1.",
                                    "Calcule exemplos simples: Forward Euler R(z) = 1 + z; Backward Euler R(z) = 1/(1 - z).",
                                    "Discuta o papel de |R(z)| na amplificação de erros."
                                  ],
                                  "verification": "Calcular R(z) para Euler forward e backward, confirmando R(0)=1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha com fórmulas de métodos numéricos",
                                    "Software como MATLAB ou Python (opcional)",
                                    "Quadro branco"
                                  ],
                                  "tips": "Sempre verifique o grau dos numerador e denominador para ordem do método.",
                                  "learningObjective": "Saber derivar e interpretar a função de amplificação R(z).",
                                  "commonMistakes": [
                                    "Esquecer o denominador em métodos implícitos",
                                    "Confundir R(z) com a solução exata e^{z}",
                                    "Não testar R(0)=1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a região de estabilidade absoluta",
                                  "subSteps": [
                                    "Defina S = {z ∈ ℂ | |R(z)| ≤ 1}.",
                                    "Desenhe S no plano complexo para métodos conhecidos (ex: Euler forward é disco).",
                                    "Explique que para estabilidade, z = hλ deve estar em S quando Re(λh) ≤ 0.",
                                    "Discuta iterações: |y_n| ≤ |y_0| se z ∈ S.",
                                    "Compare com estabilidade relativa (incluindo |R(z)|=1 na fronteira)."
                                  ],
                                  "verification": "Desenhar S para Backward Euler e confirmar que inclui o semiplano esquerdo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos de regiões de estabilidade impressos",
                                    "Software GeoGebra para plotar",
                                    "Caderno"
                                  ],
                                  "tips": "Use polar plots para visualizar |R(z)| no plano z.",
                                  "learningObjective": "Dominar a definição e visualização da região de estabilidade absoluta.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com relativa",
                                    "Desenhar S fora do semiplano esquerdo para métodos A-estáveis",
                                    "Ignorar singularidades de R(z)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a definição de A-estabilidade",
                                  "subSteps": [
                                    "Enuncie: Um método é A-estável se {z | Re(z) ≤ 0} ⊆ S.",
                                    "Equivalente: |R(z)| ≤ 1 ∀ z com Re(z) ≤ 0.",
                                    "Prove para Backward Euler: |1/(1 - z)| ≤ 1 quando Re(z) ≤ 0.",
                                    "Cite teorema de Dahlby: métodos A-estáveis implicam ordem ≤2 para RK explícitos.",
                                    "Diferencie de L-estabilidade (lim_{z→-∞} R(z)=0)."
                                  ],
                                  "verification": "Escrever a definição formal e provar para um método A-estável simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência: Hairer 'Solving ODEs I'",
                                    "Papel para provas",
                                    "Calculadora complexa"
                                  ],
                                  "tips": "Use desigualdade triangular para provar |R(z)| ≤1.",
                                  "learningObjective": "Definir precisamente A-estabilidade e verificá-la.",
                                  "commonMistakes": [
                                    "Definir como S = semiplano esquerdo (é contenção)",
                                    "Confundir com A(α)-estabilidade",
                                    "Esquecer a condição para todo z, não só reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Backward Euler: R(z) = 1/(1 - z). Prove A-estabilidade mostrando que para Re(z) ≤ 0, |1 - z| ≥ 1, logo |R(z)| ≤ 1. Teste z = -1 + 0i (|R|=0.5), z = 0 - i (|R|≈0.5), z → -∞ (|R|→0).",
                              "finalVerifications": [
                                "Escrever a definição exata de A-estabilidade verbalmente e matematicamente.",
                                "Identificar corretamente o semiplano {z | Re(z) ≤ 0}.",
                                "Calcular |R(z)| para z no semiplano e confirmar ≤1 para método A-estável.",
                                "Diferenciar A-estabilidade de estabilidade absoluta geral.",
                                "Explicar o impacto em problemas com Re(λ) < 0.",
                                "Dar exemplo de método A-estável (Backward Euler) e não A-estável (Forward Euler)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de R(z) e S (100% correto).",
                                "Compreensão do semiplano esquerdo e contenção.",
                                "Capacidade de provar A-estabilidade para método simples.",
                                "Visualização correta da região S.",
                                "Uso correto de notação complexa e |R(z)|.",
                                "Diferenciação de conceitos relacionados (L-estabilidade, A(α))."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de equações diferenciais rígidas (ex: osciladores com atrito).",
                                "Computação: Implementação de solvers ODE em Python/SciPy com métodos A-estáveis.",
                                "Engenharia Química: Modelagem de reações com escalas rígidas.",
                                "Matemática Aplicada: Análise de autovalores em sistemas lineares."
                              ],
                              "realWorldApplication": "Em simulações de problemas DAE/ODE rígidos, como cinética química ou circuitos elétricos, A-estabilidade permite passos h grandes sem oscilações, reduzindo tempo computacional em softwares como COMSOL ou MATLAB ODE solvers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Diferenciar A-estabilidade de estabilidade absoluta",
                            "description": "Comparar a estabilidade absoluta geral (região onde |R(z)| ≤ 1) com a A-estabilidade, destacando que esta última exige inclusão específica do semiplano esquerdo para lidar com autovalores com partes reais negativas grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição de estabilidade absoluta",
                                  "subSteps": [
                                    "Lembre-se do teste de estabilidade para métodos de Runge-Kutta lineares: considere o polinômio de estabilidade R(z).",
                                    "Identifique a região de estabilidade absoluta como o conjunto {z ∈ ℂ | |R(z)| ≤ 1}.",
                                    "Discuta que essa região é tipicamente um disco unitário centrado na origem para métodos explícitos.",
                                    "Analise exemplos como o método de Euler explícito, onde a região é |z| ≤ 1.",
                                    "Desenhe ou esboce o disco unitário no plano complexo."
                                  ],
                                  "verification": "Esboce o plano complexo e sombreie corretamente a região |R(z)| ≤ 1 para um método simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis ou software como GeoGebra/Mathematica",
                                    "Notas de aula sobre polinômio de estabilidade R(z)"
                                  ],
                                  "tips": "Comece sempre pelo método de Euler para fixar a ideia do disco unitário.",
                                  "learningObjective": "Compreender a definição formal e geométrica da estabilidade absoluta.",
                                  "commonMistakes": [
                                    "Confundir com estabilidade no semiplano esquerdo",
                                    "Ignorar que é |R(z)| ≤ 1, não <1",
                                    "Pensar que todos os métodos têm o mesmo disco"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a definição de A-estabilidade",
                                  "subSteps": [
                                    "Defina A-estabilidade: um método é A-estável se a região de estabilidade contém todo o semiplano esquerdo {z ∈ ℂ | Re(z) < 0}.",
                                    "Explique o contexto: necessário para problemas rígidos com autovalores de partes reais grandes negativas.",
                                    "Cite o teorema de Dahlquist: métodos A-estáveis são implicitamente estáveis.",
                                    "Diferencie de estabilidade absoluta destacando que A-estabilidade é uma propriedade mais forte para semiplano esquerdo.",
                                    "Esboce o semiplano esquerdo no plano complexo."
                                  ],
                                  "verification": "Descreva verbalmente ou escreva a definição exata de A-estabilidade e desenhe o semiplano.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Plano complexo impresso ou digital",
                                    "Referência: Hairer et al., Solving ODEs I"
                                  ],
                                  "tips": "Lembre-se: A-estabilidade lida com rigidez, não com oscilações.",
                                  "learningObjective": "Dominar a definição precisa de A-estabilidade e seu propósito.",
                                  "commonMistakes": [
                                    "Confundir semiplano esquerdo com disco unitário",
                                    "Achar que A-estabilidade é só para métodos implícitos",
                                    "Ignorar a inclusão estrita de Re(z) ≤ 0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar estabilidade absoluta e A-estabilidade",
                                  "subSteps": [
                                    "Sobreponha as regiões no plano complexo: disco unitário vs. semiplano esquerdo.",
                                    "Observe que o disco unitário é finito e simétrico, enquanto o semiplano é infinito à esquerda.",
                                    "Discuta limitações: estabilidade absoluta falha para |λh| >>1 com Re(λ)<0, mas A-estabilidade não.",
                                    "Classifique métodos: Euler explícito (não A-estável), Euler implícito (A-estável).",
                                    "Crie uma tabela comparativa: definição, região, métodos exemplos, aplicações."
                                  ],
                                  "verification": "Crie uma tabela ou diagrama destacando pelo menos 3 diferenças chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem como Python (matplotlib) ou MATLAB",
                                    "Tabela em branco"
                                  ],
                                  "tips": "Use cores diferentes para regiões sobrepostas para visualizar inclusões.",
                                  "learningObjective": "Identificar diferenças conceituais, geométricas e práticas entre as duas.",
                                  "commonMistakes": [
                                    "Achar que A-estabilidade é um subconjunto do disco",
                                    "Ignorar que A-estabilidade requer inclusão total do semiplano",
                                    "Confundir com B-estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar implicações e exemplos práticos",
                                  "subSteps": [
                                    "Calcule R(z) para Euler implícito: R(z) = 1/(1-z), verifique |R(z)|<1 para Re(z)<0.",
                                    "Compare com Euler explícito: R(z)=1+z, instável fora do disco.",
                                    "Simule numericamente um problema rígido (ex: y' = -1000y) com passos grandes.",
                                    "Analise resultados: instabilidade no explícito vs. estabilidade no implícito.",
                                    "Conclua por que A-estabilidade é crucial para autovalores com |Re(λ)| grande."
                                  ],
                                  "verification": "Execute uma simulação simples e explique os resultados em termos de estabilidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python/Jupyter com numpy/scipy",
                                    "Exemplo de EDO rígida"
                                  ],
                                  "tips": "Use h grande (ex: h=0.1 para λ=-1000) para evidenciar rigidez.",
                                  "learningObjective": "Aplicar o conhecimento para diferenciar comportamentos em cenários reais.",
                                  "commonMistakes": [
                                    "Escolher h pequeno demais, mascarando instabilidade",
                                    "Não normalizar por |λh|",
                                    "Confundir erro de truncamento com instabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere resolver y' = -1000(y - sin(t)) com y(0)=1. Para h=0.05, Euler explícito explode devido a |λh|=50 >1, enquanto Euler implícito permanece estável pois é A-estável, cobrindo todo Re(z)<0 incluindo z=-50.",
                              "finalVerifications": [
                                "Pode esboçar e rotular ambas as regiões de estabilidade corretamente.",
                                "Explica verbalmente a diferença chave: disco finito vs. semiplano infinito esquerdo.",
                                "Identifica métodos A-estáveis vs. não A-estáveis com exemplos.",
                                "Reconhece quando usar cada uma em problemas rígidos.",
                                "Calcula |R(z)| para z no semiplano esquerdo em um método implícito."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ambas as estabilidades (100% match com formal).",
                                "Qualidade do diagrama comparativo (regiões corretas e sobrepostas).",
                                "Correta classificação de 3 métodos numéricos.",
                                "Explicação clara das implicações para rigidez.",
                                "Análise correta de um exemplo numérico simples."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos rígidos.",
                                "Engenharia de Controle: Análise de autovalores em sistemas lineares discretos.",
                                "Ciência da Computação: Otimização de solvers numéricos em bibliotecas como SciPy.",
                                "Matemática Aplicada: Teoria de perturbação para EDOs stiff."
                              ],
                              "realWorldApplication": "Em modelagem de circuitos elétricos RC grandes ou reações químicas stiff, onde autovalores têm Re(λ) <<0, métodos A-estáveis como trapezoidal ou BDF permitem passos de tempo maiores, reduzindo custo computacional em simulações industriais como SPICE ou CFD."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Relacionar A-estabilidade a problemas stiff",
                            "description": "Identificar como a A-estabilidade permite passos de tempo grandes em problemas stiff, onde autovalores têm partes reais negativas de magnitudes muito diferentes, evitando restrições do passo h|λ| << 1 impostas por métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de problemas stiff em EDOs",
                                  "subSteps": [
                                    "Defina problemas stiff: sistemas de EDOs onde autovalores têm partes reais negativas com magnitudes muito diferentes.",
                                    "Identifique componentes rápidos (autovalores com |Re(λ)| grande) e lentos (pequeno |Re(λ)|).",
                                    "Discuta o comportamento da solução: decaimento rápido inicial seguido de evolução lenta.",
                                    "Analise um exemplo simples: y' = -λy com λ grande vs pequeno.",
                                    "Compare com problemas não-stiff onde escalas são similares."
                                  ],
                                  "verification": "Escreva uma definição precisa e identifique componentes em um exemplo dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), software MATLAB ou Python (SciPy).",
                                  "tips": "Visualize autovalores no plano complexo para entender escalas.",
                                  "learningObjective": "Reconhecer características de problemas stiff via autovalores.",
                                  "commonMistakes": "Confundir stiff com não-linearidade; stiff é sobre rigidez linear."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar limitações de métodos explícitos em problemas stiff",
                                  "subSteps": [
                                    "Revise o método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Derive a condição de estabilidade: |1 + hλ| ≤ 1 para autovalores λ.",
                                    "Mostre que para Re(λ) < 0, h < 2/|λ| para estabilidade.",
                                    "Explique restrição h|λ| << 1 para componentes rígidos (λ grande).",
                                    "Simule numericamente: compare passos grandes vs pequenos em stiff problem."
                                  ],
                                  "verification": "Plote solução instável com h grande e estável com h pequeno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/Jupyter com odeint ou MATLAB ode45, exemplo stiff como y' = -100y + sin(t).",
                                  "tips": "Use gráfico de estabilidade para métodos explícitos (círculo unitário).",
                                  "learningObjective": "Quantificar por que métodos explícitos falham em stiff problems.",
                                  "commonMistakes": "Ignorar que instabilidade surge só para modos rígidos, não todos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e interpretar A-estabilidade",
                                  "subSteps": [
                                    "Defina A-estabilidade: região de estabilidade absoluta inclui todo semiplano esquerdo {z | Re(z) ≤ 0}.",
                                    "Explique teste: aplicar método a y' = λy, λ com Re(λ)<0; solução numérica deve decair.",
                                    "Compare com B-estabilidade ou L-estabilidade.",
                                    "Analise métodos implícitos como Backward Euler: estabilidade incondicional para h qualquer.",
                                    "Verifique graficamente: região de estabilidade cobre semiplano esquerdo."
                                  ],
                                  "verification": "Desenhe região de estabilidade e confirme inclusão do semiplano esquerdo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel gráfico ou software Desmos/GeoGebra para regiões de estabilidade.",
                                  "tips": "Lembre: A-estabilidade é para linear test equation y' = λy.",
                                  "learningObjective": "Entender A-estabilidade como propriedade para passos h arbitrariamente grandes.",
                                  "commonMistakes": "Confundir A-estabilidade com consistência ou convergência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar A-estabilidade diretamente a problemas stiff",
                                  "subSteps": [
                                    "Em stiff problems, modos rígidos impõem h << 1/|λ_max| em explícitos.",
                                    "Com A-estabilidade, h pode ser escolhido baseado em componentes não-rígidos (precisão).",
                                    "Discuta eficiência: passos maiores reduzem custo computacional.",
                                    "Exemplo: decomposição modal, modos rígidos decaem rápido independentemente de h.",
                                    "Conclua: A-estabilidade remove restrição h|λ| << 1 para todos λ."
                                  ],
                                  "verification": "Explique em 3 frases como A-estabilidade resolve stiff issues; simule comparação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Código Python para simular stiff ODE com Euler explícito vs implícito.",
                                  "tips": "Pense em escalas: h limitada pelo modo mais rígido em explícitos.",
                                  "learningObjective": "Articular ligação precisa entre A-estabilidade e eficiência em stiff.",
                                  "commonMistakes": "Achar que A-estabilidade resolve todos problemas; ainda precisa de precisão."
                                }
                              ],
                              "practicalExample": "Considere o problema stiff y' = -99(y - sin(t)) + cos(t), com autovalores ~ -99 (rígido) e ~0 (lento). Euler explícito requer h < 0.01 para estabilidade, enquanto Backward Euler (A-estável) permite h=0.1 com passos 10x maiores, capturando oscilação lenta sem oscilação numérica.",
                              "finalVerifications": [
                                "Explique em palavras próprias por que explícitos falham em stiff.",
                                "Identifique autovalores rígidos em um sistema dado.",
                                "Descreva como A-estabilidade permite h grande.",
                                "Simule e compare curvas explícita vs implícita.",
                                "Discuta trade-off precisão vs estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de stiff e A-estabilidade (exata).",
                                "Correta derivação da condição h|λ| << 1.",
                                "Uso apropriado de exemplos numéricos/simulações.",
                                "Clareza na ligação estabilidade-problema stiff.",
                                "Identificação correta de regiões de estabilidade.",
                                "Análise de eficiência computacional."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RC com parasitas (stiff).",
                                "Engenharia Química: Reatores com cinéticas rápidas/lentas.",
                                "Computação Científica: Implementação de solvers ODE em bibliotecas.",
                                "Física Computacional: Simulações de fluidos com escalas múltiplas."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas em reatores (ex: combustão), problemas stiff surgem de espécies intermediárias rápidas; métodos A-estáveis como implicitos permitem simular horas de reação com passos de segundos, viabilizando otimização industrial em software como COMSOL ou Cantera."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Região de estabilidade e semiplano esquerdo",
                        "description": "Análise da região de estabilidade no plano complexo z = hλ, com ênfase no semiplano esquerdo Re(z) ≤ 0 como critério para A-estabilidade em métodos de passo simples e múltiplo.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Construir a região de estabilidade para métodos lineares",
                            "description": "Calcular e plotar a região {z ∈ ℂ | |R(z)| ≤ 1} para métodos como Forward Euler (círculo unitário tangente à imaginária) e Backward Euler (exterior do círculo unitário), verificando inclusão do semiplano esquerdo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de região de estabilidade para métodos lineares",
                                  "subSteps": [
                                    "Defina a região de estabilidade como {z ∈ ℂ | |R(z)| ≤ 1}, onde R(z) é o polinômio de amplificação para o teste modelo y' = λy.",
                                    "Explique o papel do semiplano esquerdo Re(z) ≤ 0 para estabilidade incondicional em problemas dissipativos.",
                                    "Identifique métodos lineares de Runge-Kutta ou Euler como exemplos: Forward Euler (explícito) e Backward Euler (implícito).",
                                    "Revise como z = hλ, com h passo de tempo e λ autovalor.",
                                    "Discuta a importância da inclusão do semiplano esquerdo na região de estabilidade."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e liste 3 exemplos de R(z) para métodos simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (cap. Estabilidade)",
                                    "Notas de aula sobre EDOs",
                                    "Calculadora complexa ou software como Python (NumPy)"
                                  ],
                                  "tips": "Use diagramas no plano complexo para visualizar o semiplano esquerdo imediatamente.",
                                  "learningObjective": "Compreender a definição matemática e o contexto físico da região de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir R(z) com o operador de amplificação",
                                    "Ignorar que z = hλ escala com h",
                                    "Esquecer o teste modelo y' = λy"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e calcular a região de estabilidade para Forward Euler",
                                  "subSteps": [
                                    "Escreva a iteração do Forward Euler: y_{n+1} = y_n + h f(y_n) → R(z) = 1 + z.",
                                    "Resolva |1 + z| ≤ 1 para z ∈ ℂ, identificando o disco unitário centrado em -1 + 0i.",
                                    "Desenhe o círculo |z + 1| ≤ 1 no plano complexo, tangente ao eixo imaginário em 0.",
                                    "Verifique graficamente se o semiplano esquerdo Re(z) ≤ 0 está parcialmente incluído (apenas até Re(z) = -2).",
                                    "Calcule pontos boundary: z = -1 + i, z = -1 - i, etc."
                                  ],
                                  "verification": "Plote o círculo e confirme que o raio é 1 e centro em -1; liste 3 pontos dentro/fora da região.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de plotagem (Matplotlib/Python, MATLAB)",
                                    "Folha de exercícios com z complexos"
                                  ],
                                  "tips": "Comece plotando o centro em -1 e raio 1; teste pontos como z=-0.5 (dentro) e z=-1.5 (fora).",
                                  "learningObjective": "Derivar R(z) e delinear geometricamente a região para método explícito.",
                                  "commonMistakes": [
                                    "Erro na inequação: |1 + z| ≤ 1 é disco centrado em -1, não unitário",
                                    "Confundir tangência com inclusão total do semiplano"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e calcular a região de estabilidade para Backward Euler",
                                  "subSteps": [
                                    "Escreva a iteração do Backward Euler: y_{n+1} = y_n + h f(y_{n+1}) → R(z) = 1 / (1 - z).",
                                    "Resolva |1 / (1 - z)| ≤ 1 → |1| ≤ |1 - z| → exterior do disco unitário |z| ≥ 1 centrado em 0.",
                                    "Desenhe o círculo unitário |z| = 1 e sombreie o exterior (incluindo todo semiplano esquerdo).",
                                    "Verifique analiticamente: para Re(z) ≤ 0, |1 - z| ≥ 1 sempre verdadeiro.",
                                    "Compare com Forward Euler destacando A-estabilidade (Backward inclui todo semiplano esquerdo)."
                                  ],
                                  "verification": "Confirme que para z = -10 (Re<0), |R(z)| <1; plote e anote inclusão total do semiplano.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesmo software de plotagem",
                                    "Tabela de valores |R(z)| para z teste"
                                  ],
                                  "tips": "Transforme a inequação: |1 - z| ≥ 1 é tudo fora do círculo unitário; prove para semiplano.",
                                  "learningObjective": "Dominar derivação para método implícito e reconhecer A-estabilidade.",
                                  "commonMistakes": [
                                    "R(z) = 1/(1 + z) em vez de 1/(1 - z)",
                                    "Confundir interior/exterior do círculo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar regiões comparativas e verificar inclusão do semiplano esquerdo",
                                  "subSteps": [
                                    "Plote ambas regiões no mesmo plano complexo: Forward (disco em -1) vs Backward (exterior unitário).",
                                    "Sobreponha o semiplano esquerdo (linha vertical Re(z)=0) e destaque inclusões.",
                                    "Calcule interseção: Forward cobre parte, Backward cobre todo.",
                                    "Gere gráfico final com legendas, eixos rotulados (Re(z), Im(z)) e cores distintas.",
                                    "Discuta implicações: escolha de método baseado em rigidez do problema."
                                  ],
                                  "verification": "Gráfico mostra disco Forward tangente à imaginária e exterior Backward contendo semiplano; exporte imagem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/MATLAB script para plotar círculos: circle = plt.Circle((-1,0),1)",
                                    "Template de código pronto"
                                  ],
                                  "tips": "Use polar plots se necessário; teste com z = -0.5 + 0.5i para verificar.",
                                  "learningObjective": "Visualizar e comparar regiões, confirmando propriedades de estabilidade.",
                                  "commonMistakes": [
                                    "Escala errada no plot (z não dimensionado)",
                                    "Esquecer de sombrear regiões corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o problema y' = -y (λ=-1, semiplano esquerdo), com h=1.5: Forward Euler |R(z= -1.5)| = |1-1.5|=0.5≤1 (estável), mas para h=3, z=-3, |1-3|=2>1 (instável). Backward: sempre |1/(1 - (-3))| =1/4<1 (A-estável). Plote regiões e simule numericamente 10 passos.",
                              "finalVerifications": [
                                "Região Forward: disco |z+1|≤1, tangente à imaginária em 0.",
                                "Região Backward: |z|≥1 (exterior unitário), inclui todo Re(z)≤0.",
                                "Semiplano esquerdo parcialmente em Forward, totalmente em Backward.",
                                "Gráficos plotados corretamente com sombreamento e legendas.",
                                "Cálculos de |R(z)| confirmados para 5 pontos teste no semiplano.",
                                "Comparação escrita: Backward é A-estável, Forward não."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de R(z) para ambos métodos (100% correto).",
                                "Qualidade gráfica: regiões precisas, escalas adequadas, legendas claras (nota 1-5).",
                                "Verificação analítica da inclusão do semiplano esquerdo.",
                                "Identificação correta de A-estabilidade para Backward Euler.",
                                "Explicação coerente das implicações para escolha de métodos.",
                                "Uso apropriado de ferramentas (plots sem erros numéricos)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar plots em Python (Matplotlib/NumPy) ou MATLAB.",
                                "Física: Aplicar em simulações de osciladores amortecidos (equações diferenciais).",
                                "Engenharia: Análise de estabilidade em controle de sistemas dinâmicos.",
                                "Computação Científica: Integração com solvers ODE como SciPy odeint."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais rígidas na engenharia aeroespacial (órbitas), finanças (modelos Black-Scholes) e biologia (populações), escolher Backward Euler garante estabilidade para h grandes no semiplano esquerdo, evitando explosões numéricas em problemas dissipativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Verificar A-estabilidade via função de amplificação",
                            "description": "Aplicar o teste |R(z)| ≤ 1 + O(|z|^2) para Re(z) ≤ 0 em métodos implícitos, demonstrando que métodos como Backward Euler (R(z) = 1/(1 - z)) satisfazem a condição em todo o semiplano esquerdo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de A-estabilidade e função de amplificação",
                                  "subSteps": [
                                    "Defina A-estabilidade: um método é A-estável se sua região de estabilidade contém o semiplano esquerdo Re(z) ≤ 0.",
                                    "Explique a função de amplificação R(z) para o teste de um passo: solução exata y_{n+1} = R(z) y_n para y' = λ y, com z = h λ.",
                                    "Discuta a importância da condição |R(z)| ≤ 1 + O(|z|^2) para Re(z) ≤ 0, que garante estabilidade assintótica sem amplificação espúria.",
                                    "Revise o semiplano esquerdo no plano complexo e sua relevância para autovalores com parte real negativa.",
                                    "Estude exemplos de métodos explícitos (como Forward Euler) que falham nesse teste."
                                  ],
                                  "verification": "Escreva definições precisas e esboce o semiplano esquerdo, confirmando com uma referência do livro-texto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e lápis para diagramas",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use diagramas no plano z para visualizar o semiplano; memorize a forma geral de R(z) para métodos lineares.",
                                  "learningObjective": "Compreender os fundamentos teóricos de A-estabilidade e o papel da função R(z).",
                                  "commonMistakes": [
                                    "Confundir região de estabilidade absoluta com A-estabilidade.",
                                    "Ignorar o termo O(|z|^2) na condição de boundedness."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a função de amplificação R(z) para o método Backward Euler",
                                  "subSteps": [
                                    "Escreva a equação do Backward Euler: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Para y' = λ y, substitua: y_{n+1} = y_n + h λ y_{n+1}, resolvendo para y_{n+1}/y_n = R(z) com z = h λ.",
                                    "Simplifique: R(z) = 1 / (1 - z).",
                                    "Verifique o limite |z| → 0: R(z) ≈ 1 + z + O(z^2), compatível com a solução exata e^{z} ≈ 1 + z + O(z^2).",
                                    "Analise o módulo |R(z)| para Re(z) = 0 (eixo imaginário puro)."
                                  ],
                                  "verification": "Derive R(z) = 1/(1 - z) passo a passo e compute |R(i y)| para y real, mostrando ≤ 1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de exercícios em branco",
                                    "Software simbólico como Mathematica ou SymPy (opcional)",
                                    "Referência: notas de aula sobre Runge-Kutta"
                                  ],
                                  "tips": "Resolva algebricamente com cuidado; teste com z pequeno numérico para validar.",
                                  "learningObjective": "Derivar corretamente R(z) para Backward Euler e entender sua forma racional.",
                                  "commonMistakes": [
                                    "Erro na algebra: confundir y_{n+1} - h λ y_{n+1} = y_n como R(z) = 1 + z.",
                                    "Esquecer de definir z = h λ."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o teste |R(z)| ≤ 1 + O(|z|^2) para Re(z) ≤ 0",
                                  "subSteps": [
                                    "Prove que para Re(z) ≤ 0, |1 - z| ≥ 1, implicando |R(z)| = 1 / |1 - z| ≤ 1.",
                                    "Mostre que a desigualdade é estrita exceto em z=0, e verifique o comportamento assintótico |R(z)| ~ 1/|z| → 0 quando |z| → ∞.",
                                    "Analise o termo O(|z|^2): expanda R(z) em série de Taylor ao redor de z=0 e compare com e^z.",
                                    "Teste numericamente pontos no semiplano: z = -1, z = -1 + i, z = i.",
                                    "Discuta por que isso satisfaz A-estabilidade em todo o semiplano esquerdo."
                                  ],
                                  "verification": "Escreva a prova formal de |R(z)| ≤ 1 e compute 5 pontos numéricos com |R(z)| < 1 + |z|^2/2.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para valores complexos",
                                    "Gráficos de |R(z)| no plano complexo (usar contour plot se possível)"
                                  ],
                                  "tips": "Use desigualdade triangular: |1 - z| ≥ 1 - Re(z) ≥ 1 para Re(z) ≤ 0; plote |R(z)| para visualização.",
                                  "learningObjective": "Aplicar e provar a condição de A-estabilidade usando análise complexa básica.",
                                  "commonMistakes": [
                                    "Achar que |R(z)| ≤ 1 é suficiente sem O(|z|^2).",
                                    "Erro em módulo complexo: |a/b| = |a|/|b|."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e generalizar para outros métodos implícitos",
                                  "subSteps": [
                                    "Compare com Trapezoidal Rule: R(z) = (1 + z/2)/(1 - z/2), prove |R(z)| ≤ 1 similarmente.",
                                    "Teste falha de Forward Euler: R(z) = 1 + z, |R(i y)| = |1 + i y| > 1 para y ≠ 0.",
                                    "Implemente um gráfico simples da região de estabilidade usando software.",
                                    "Discuta implicações para problemas rígidos (autovalores grandes negativos).",
                                    "Resuma critérios para A-estabilidade em métodos lineares implícitos."
                                  ],
                                  "verification": "Gere gráfico ou tabela comparando |R(z)| para 3 métodos em 4 pontos do semiplano.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Templates de código para plot de estabilidade"
                                  ],
                                  "tips": "Comece com código pronto para contourf de |R(z)|; foque em Re(z) ≤ 0.",
                                  "learningObjective": "Generalizar o teste e contrastar com métodos não A-estáveis.",
                                  "commonMistakes": [
                                    "Confundir A-estabilidade com L-estabilidade (|R(z)| → 0 quando |z|→∞).",
                                    "Plots incorretos no plano z."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Backward Euler aplicado a y' = -100 y (λ = -100, rígido), com h=0.1, z=-10: R(-10)=1/(1+10)=1/11≈0.0909, |R(z)|<1, garantindo decaimento sem oscilações, ao contrário de métodos explícitos que divergem.",
                              "finalVerifications": [
                                "Derivação correta de R(z) = 1/(1 - z) para Backward Euler.",
                                "Prova analítica de |R(z)| ≤ 1 para todo Re(z) ≤ 0.",
                                "Expansão em série confirmando O(|z|^2) perto de z=0.",
                                "Cálculos numéricos em pelo menos 5 pontos do semiplano esquerdo.",
                                "Gráfico qualitativo da região de estabilidade cobrindo o semiplano.",
                                "Comparação com um método explícito mostrando falha."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação e prova (sem erros algébricos).",
                                "Compreensão conceitual: explica por que a condição garante estabilidade.",
                                "Habilidade analítica: manipula números complexos e módulos corretamente.",
                                "Visualização: produz gráficos ou tabelas claras de |R(z)|.",
                                "Generalização: aplica o teste a outro método implícito.",
                                "Clareza na comunicação: prova escrita de forma lógica e concisa."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas dissipativos (ex: amortecedores em dinâmica).",
                                "Programação: Implementação numérica em Python para simulações de EDOs rígidas.",
                                "Engenharia: Análise de estabilidade em controle de processos industriais.",
                                "Estatística: Estimação em modelos estocásticos com autovalores negativos."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos RC ou reações químicas rígidas, onde autovalores têm Re(λ) << 0, Backward Euler permite passos de tempo maiores sem instabilidade, otimizando simulações em software como COMSOL ou SPICE."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Analisar limites da A-estabilidade em métodos explícitos",
                            "description": "Explicar por que métodos explícitos de Runge-Kutta, como Forward Euler ou RK4, não são A-estáveis, pois sua região de estabilidade é finita e não cobre o semiplano esquerdo ilimitado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Estabilidade e A-Estabilidade",
                                  "subSteps": [
                                    "Definir estabilidade absoluta para métodos de Runge-Kutta usando a equação teste y' = λy com Re(λ) < 0.",
                                    "Explicar a região de estabilidade como o conjunto de hλ no plano complexo onde |R(hλ)| ≤ 1, com R o polinômio de estabilidade.",
                                    "Descrever A-estabilidade: a região de estabilidade inclui todo o semiplano esquerdo {z | Re(z) ≤ 0}.",
                                    "Discutir a importância para problemas stiff, onde |λ| é grande negativo.",
                                    "Comparar estabilidade absoluta com consistência e convergência."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando A-estabilidade e listar 3 exemplos de problemas stiff.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Burden & Faires 'Análise Numérica'",
                                    "Notas de aula sobre EDOs",
                                    "Software MATLAB ou Python com NumPy"
                                  ],
                                  "tips": "Visualize o semiplano esquerdo como uma half-plane infinita no plano complexo para intuitivamente entender o limite.",
                                  "learningObjective": "Compreender definições precisas e motivação para A-estabilidade em métodos numéricos.",
                                  "commonMistakes": [
                                    "Confundir região de estabilidade com ordem do método.",
                                    "Ignorar que A-estabilidade requer cobertura ilimitada do semiplano esquerdo.",
                                    "Esquecer que vale para h > 0 arbitrariamente grande."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Analisar Região de Estabilidade do Forward Euler",
                                  "subSteps": [
                                    "Aplicar Forward Euler à equação teste: y_{n+1} = y_n + h λ y_n = (1 + hλ) y_n.",
                                    "Determinar polinômio de estabilidade R(z) = 1 + z, onde z = hλ.",
                                    "Encontrar |1 + z| ≤ 1, que descreve um disco de raio 1 centrado em -1.",
                                    "Plotar a região no plano complexo e observar que é finita e não cobre o semiplano esquerdo.",
                                    "Testar numericamente com λ = -100, variando h para mostrar divergência para h > 0.02."
                                  ],
                                  "verification": "Gerar gráfico da região de estabilidade e confirmar que pontos como z = -10 + 0i estão fora.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com Matplotlib e SymPy",
                                    "Papel e lápis para derivação",
                                    "Exemplos computacionais de EDOs stiff"
                                  ],
                                  "tips": "Use contour plots para visualizar |R(z)| = 1; foque em como o disco é limitado.",
                                  "learningObjective": "Derivar explicitamente por que Forward Euler tem região finita.",
                                  "commonMistakes": [
                                    "Erro no cálculo de |1 + z| ≤ 1, confundindo com círculo centrado em 0.",
                                    "Não testar hλ com grande |λ|h.",
                                    "Achar que o disco cobre semiplano por ser 'grande'."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Analisar Região de Estabilidade do RK4",
                                  "subSteps": [
                                    "Recordar Butcher tableau para RK4 s=4 estágios explícito.",
                                    "Calcular polinômio de estabilidade R(z) via soma de série ou fórmula conhecida: R(z) ≈ exp(z) para z pequeno, mas finito.",
                                    "Descrever região como lobulado, aproximando um setor do semiplano esquerdo até ~2.78i a -2.78i.",
                                    "Plotar e destacar que não é ilimitada: falha para Re(z) < -2.785 ou Im(z) grande.",
                                    "Comparar computacionalmente com Euler em problema stiff como y' = -50y."
                                  ],
                                  "verification": "Implementar código para aproximar R(z) em grade complexa e plotar onde |R(z)| ≤ 1.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB para Butcher e estabilidade",
                                    "Referência Hairer 'Solving ODEs I'",
                                    "Ferramenta de plotting como Desmos ou GeoGebra"
                                  ],
                                  "tips": "RK4 melhora área mas permanece finita; use z = -3 para testar falha.",
                                  "learningObjective": "Reconhecer que mesmo métodos de alta ordem explícitos não alcançam A-estabilidade.",
                                  "commonMistakes": [
                                    "Supor RK4 A-estável por precisão local.",
                                    "Erro na Butcher tableau.",
                                    "Ignorar que região é simétrica mas limitada em magnitude."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Limites e Concluir sobre Métodos Explícitos",
                                  "subSteps": [
                                    "Superpor regiões de Euler e RK4 no semiplano esquerdo.",
                                    "Explicar teorema: métodos explícitos Runge-Kutta não são A-estáveis (região finita por polinômio R(z)).",
                                    "Discutir implicações: para stiff, h deve ser < 2/|λ|, ineficiente.",
                                    "Contrastar com métodos implícitos como Backward Euler (A-estável).",
                                    "Resolver numericamente um stiff ODE mostrando falha explícita vs. sucesso implícito."
                                  ],
                                  "verification": "Escrever relatório de 1 página com gráficos e conclusão sobre limites.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SciPy odeint/solve_ivp",
                                    "Problemas stiff exemplo como van der Pol rígido",
                                    "Artigo sobre estabilidade RK"
                                  ],
                                  "tips": "Lembre: explícitos requerem CFL-like condition; implícitos relaxam.",
                                  "learningObjective": "Analisar rigorosamente por que explícitos falham em A-estabilidade.",
                                  "commonMistakes": [
                                    "Achar RK4 'quase A-estável' sem quantificar limites.",
                                    "Não contrastar com implícitos.",
                                    "Confundir ordem com tamanho da região."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a EDO stiff y' = -1000(y - sin(t)) + cos(t), y(0)=0. Com Forward Euler, h deve ser <0.002 para estabilidade, resultando em milhares de passos; RK4 permite h~0.01 mas ainda ineficiente, enquanto Backward Euler converge para h=1.",
                              "finalVerifications": [
                                "Derivar corretamente R(z) para Euler e RK4.",
                                "Plotar regiões mostrando não cobertura do semiplano esquerdo.",
                                "Explicar com exemplo numérico por que explícitos falham em stiff problems.",
                                "Identificar limite de RK4 (~2.78 no eixo real negativo).",
                                "Comparar com método A-estável como Trapezoidal.",
                                "Discutir trade-off precisão vs. estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de R(z) e região.",
                                "Qualidade dos gráficos e visualizações da região de estabilidade.",
                                "Correta interpretação de limites para problemas stiff.",
                                "Uso apropriado de exemplos numéricos para validação.",
                                "Clareza na explicação verbal dos conceitos.",
                                "Identificação de teoremas relevantes (e.g., não A-estabilidade de explícitos)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar solvers em Python (SciPy) e analisar estabilidade.",
                                "Física: Modelagem de circuitos RC ou reações químicas stiff.",
                                "Engenharia de Controle: Estabilidade em sistemas lineares discretizados.",
                                "Computação Científica: Otimização de solvers para PDEs parabólicas rígidas."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos ou circuitos integrados (SPICE), onde ODEs stiff surgem de escalas múltiplas, métodos explícitos como RK4 exigem passos minúsculos, tornando-os computacionalmente caros; entender limites impulsiona uso de implícitos para eficiência em engenharia aeroespacial e eletrônica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Exemplos e aplicações de métodos A-estáveis",
                        "description": "Métodos implícitos A-estáveis como Backward Euler e Trapezoidal Rule, sua implementação com controle de passo e relevância para problemas stiff em métodos de passo simples e múltiplo.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Identificar métodos A-estáveis clássicos",
                            "description": "Listar e caracterizar métodos como Backward Euler (A-estável, ordem 1), Trapezoidal (A-estável, ordem 2) e BDFs de ordem baixa, contrastando com métodos não A-estáveis como Forward Euler.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito de A-estabilidade",
                                  "subSteps": [
                                    "Defina A-estabilidade: região de estabilidade inclui todo o semiplano esquerdo (Re(z) ≤ 0).",
                                    "Lembre a importância para EDOs rígidas (stiff ODEs).",
                                    "Estude o teste de Dahlquist para métodos lineares multistep.",
                                    "Analise o polinômio de estabilidade ρ(z) e σ(z).",
                                    "Pratique com gráfico da região de estabilidade no plano complexo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é A-estabilidade e desenhe a região no plano complexo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula, livro de análise numérica (ex: Burden & Faires), papel e caneta para gráficos.",
                                  "tips": "Use o plano complexo com eixo real horizontal (negativo à esquerda) para visualizar claramente.",
                                  "learningObjective": "Compreender a definição e relevância de A-estabilidade para métodos numéricos.",
                                  "commonMistakes": "Confundir A-estabilidade com estabilidade absoluta; lembrar que é específica para semiplano esquerdo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Caracterizar o método Backward Euler",
                                  "subSteps": [
                                    "Escreva a fórmula: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Determine ordem: 1 (erro local O(h^2)).",
                                    "Analise estabilidade: resolva |1 - z| < 1 para Re(z) ≤ 0 (sempre verdadeiro).",
                                    "Calcule região de estabilidade: disco unitário centrado em 1.",
                                    "Compare com Forward Euler: y_{n+1} = y_n + h f(t_n, y_n) (não A-estável)."
                                  ],
                                  "verification": "Derive a condição de estabilidade e confirme que Backward Euler é A-estável de ordem 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB ou Python (SciPy) para plotar regiões, quadro branco.",
                                  "tips": "Teste com λ negativo grande (stiff) para ver por que Forward Euler falha.",
                                  "learningObjective": "Identificar e provar A-estabilidade do Backward Euler, contrastando com Forward Euler.",
                                  "commonMistakes": "Esquecer que Backward Euler é implícito e requer solução iterativa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o método Trapezoidal e BDFs de ordem baixa",
                                  "subSteps": [
                                    "Trapezoidal: y_{n+1} = y_n + (h/2)(f(t_n, y_n) + f(t_{n+1}, y_{n+1})), ordem 2.",
                                    "Estabilidade Trapezoidal: região externa do círculo |z+1|/|z-1| ≤ 1 (A-estável).",
                                    "BDF1: igual a Backward Euler (ordem 1).",
                                    "BDF2: y_{n+1} - (4/3)y_n + (1/3)y_{n-1} = (2/3) h f(t_{n+1}, y_{n+1}), ordem 2, A-estável.",
                                    "Liste BDFs até ordem 2 como A-estáveis; note que ordem >2 perdem A-estabilidade."
                                  ],
                                  "verification": "Escreva fórmulas, ordens e confirme A-estabilidade para Trapezoidal e BDF1/2.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabelas de métodos BDF de livro-texto, calculadora simbólica (SymPy).",
                                  "tips": "Use aproximação linear y' = λy para testar estabilidade em cada método.",
                                  "learningObjective": "Listar e caracterizar Trapezoidal e BDFs baixas como A-estáveis.",
                                  "commonMistakes": "Confundir ordem de precisão com ordem de estabilidade; BDF2 é A-estável, mas BDF6 não."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar métodos A-estáveis com não A-estáveis e sintetizar",
                                  "subSteps": [
                                    "Liste: A-estáveis (Backward Euler ord1, Trapezoidal ord2, BDF1/2); não (Forward Euler).",
                                    "Compare custos: implícitos vs explícitos.",
                                    "Crie tabela: método, ordem, A-estável (sim/não), implícito/explícito.",
                                    "Discuta aplicações: A-estáveis para rígidas.",
                                    "Resolva exemplo numérico simples com h grande."
                                  ],
                                  "verification": "Preencha tabela corretamente e explique contraste em parágrafo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Planilha Excel ou LaTeX para tabela, exemplos de EDOs rígidas.",
                                  "tips": "Sempre teste com equação modelo y' = -50y para stiff.",
                                  "learningObjective": "Sintetizar lista de métodos clássicos A-estáveis e contrastes.",
                                  "commonMistakes": "Omitir que Trapezoidal é A(α)-estável com α=90° (A-estável)."
                                }
                              ],
                              "practicalExample": "Resolva y' = -50(y - sin(t)) com y(0)=0 usando Forward Euler, Backward Euler e Trapezoidal com h=0.2. Observe oscilações no Forward Euler vs estabilidade nos A-estáveis.",
                              "finalVerifications": [
                                "Liste corretamente Backward Euler (A-estável, ord1), Trapezoidal (A-estável, ord2), BDF1/2.",
                                "Explique por que Forward Euler não é A-estável.",
                                "Desenhe regiões de estabilidade aproximadas.",
                                "Compare ordens e tipos (implícito/explícito).",
                                "Aplique a um exemplo stiff simples sem instabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e lista de métodos A-estáveis clássicos (80% peso).",
                                "Correta caracterização de ordem e estabilidade (com provas ou gráficos).",
                                "Contraste claro com métodos não A-estáveis.",
                                "Uso de exemplos numéricos ou tabelas.",
                                "Clareza na explicação de aplicações para EDOs rígidas.",
                                "Ausência de erros comuns como confundir BDF ordens."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulação de circuitos RLC rígidos ou reações químicas.",
                                "Ciência da Computação: Implementação em bibliotecas como ODEPACK ou SciPy.",
                                "Engenharia: Modelagem de sistemas dinâmicos stiff em controle.",
                                "Matemática Aplicada: Análise de erro em métodos multistep."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas em farmacêutica, onde escalas de tempo rígidas exigem métodos A-estáveis como Backward Euler para evitar instabilidade numérica e prever concentrações precisas sem passos de tempo minúsculos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Implementar verificação numérica de A-estabilidade",
                            "description": "Usar software numérico para plotar curvas de |R(z)| = 1 e confirmar que para Re(z) ≤ 0, |R(z)| ≤ 1 em métodos implícitos, aplicando a problemas modelo y' = λy com λ real negativo grande.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de software e definir função de amplificação R(z)",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias: NumPy, Matplotlib e SciPy via pip.",
                                    "Definir a função R(z) para um método implícito A-estável, como Backward Euler: R(z) = 1 / (1 - z).",
                                    "Criar uma grade de pontos z no semiplano complexo esquerdo (Re(z) ≤ 0).",
                                    "Implementar função para calcular |R(z)|.",
                                    "Testar R(z) em pontos simples como z = -1 + 0j."
                                  ],
                                  "verification": "Executar código e confirmar que |R(-1)| ≈ 0.5 < 1 e R(0) = 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Jupyter Notebook ou IDE",
                                    "Bibliotecas: numpy, matplotlib"
                                  ],
                                  "tips": "Use complex numbers com np.meshgrid para eficiência em grids.",
                                  "learningObjective": "Configurar ambiente computacional e codificar corretamente a função de amplificação de métodos implícitos.",
                                  "commonMistakes": [
                                    "Esquecer de usar números complexos (z = complex(re, im))",
                                    "Erro na fórmula de R(z) para Backward Euler",
                                    "Não importar bibliotecas corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar plot da curva de estabilidade |R(z)| = 1",
                                  "subSteps": [
                                    "Gerar uma grade densa de z no semiplano esquerdo: Re(z) de -10 a 0, Im(z) de -10 a 10.",
                                    "Calcular |R(z)| para cada ponto da grade.",
                                    "Plotar contour lines onde |R(z)| = 1 usando plt.contour.",
                                    "Preencher região onde |R(z)| ≤ 1 com cor (ex: plt.contourf).",
                                    "Adicionar eixos reais/imaginários e legenda."
                                  ],
                                  "verification": "Visualizar plot e confirmar que a curva |R(z)|=1 envolve todo o semiplano esquerdo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python do Step 1",
                                    "Matplotlib para plotting"
                                  ],
                                  "tips": "Use níveis [0.99, 1.01] no contour para precisão na curva |R(z)|=1.",
                                  "learningObjective": "Visualizar numericamente a região de estabilidade absoluta de métodos implícitos.",
                                  "commonMistakes": [
                                    "Grid muito grosseira levando a plots imprecisos",
                                    "Confundir |R(z)| com Re(R(z))",
                                    "Não limitar ao semiplano esquerdo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar condição de A-estabilidade no semiplano esquerdo",
                                  "subSteps": [
                                    "Selecionar pontos teste no semiplano: ex. z = -5 + 3j, z = -100 + 0j.",
                                    "Calcular |R(z)| para cada ponto e imprimir valores.",
                                    "Comparar com threshold: assert |R(z)| <= 1 + epsilon para Re(z) <= 0.",
                                    "Testar em uma linha radial: z = r * exp(i*theta) com r grande negativo.",
                                    "Gerar relatório de máximos |R(z)| em sub-regiões."
                                  ],
                                  "verification": "Todos os pontos testados satisfazem |R(z)| ≤ 1 para Re(z) ≤ 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Pontos teste pré-definidos"
                                  ],
                                  "tips": "Use np.max(np.abs(R_grid[Re_grid <= 0])) para verificação global.",
                                  "learningObjective": "Confirmar numericamente a propriedade de A-estabilidade via amostragem.",
                                  "commonMistakes": [
                                    "Testar apenas eixo real, ignorando imaginário",
                                    "Usar epsilon muito grande (>1e-10)",
                                    "Não checar pontos com |Im(z)| grande"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a problemas modelo y' = λy com λ real negativo grande",
                                  "subSteps": [
                                    "Implementar solver numérico para y' = λy usando método implícito (ex: Backward Euler).",
                                    "Escolher λ = -1000 (rígido), h = 0.1, simular N=100 passos.",
                                    "Comparar solução numérica com exata y(t) = y0 * exp(λ t).",
                                    "Plotar erro |y_num - y_exact| vs tempo.",
                                    "Repetir para método explícito (Forward Euler) para contraste."
                                  ],
                                  "verification": "Erro numérico pequeno (<1e-5) e decay correto, ao contrário do explícito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "SciPy para solvers opcionais"
                                  ],
                                  "tips": "Vetorize computações para eficiência em loops temporais.",
                                  "learningObjective": "Demonstrar superioridade de métodos A-estáveis em problemas rígidos.",
                                  "commonMistakes": [
                                    "Passo h muito grande causando instabilidade mesmo implícito",
                                    "Erro na solução exata exp(λ t)",
                                    "Não normalizar erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Para Backward Euler em y' = -1000 y, y(0)=1, h=0.01, T=0.1: solução exata ~1e-434, numérica converge corretamente sem oscilações, plot de |R(z)|=1 mostra semiplano coberto.",
                              "finalVerifications": [
                                "Plot da curva |R(z)|=1 envolve todo semiplano Re(z)≤0.",
                                "Máximo |R(z)| no semiplano esquerdo ≤1 (com epsilon=1e-12).",
                                "Simulação com λ=-1000, h=0.1: erro relativo <1e-6 após 100 passos.",
                                "Comparação com Forward Euler mostra instabilidade explícita.",
                                "Código reproduzível gera plots idênticos.",
                                "Relatório lista 10+ pontos teste com |R(z)|≤1."
                              ],
                              "assessmentCriteria": [
                                "Precisão do plot: curva |R(z)|=1 corretamente delineada (90% cobertura visual).",
                                "Correção numérica: todos testes |R(z)|≤1 no semiplano.",
                                "Eficiência código: grids >100x100 pontos, tempo <5s.",
                                "Análise qualitativa: discussão de rigidez em problemas modelo.",
                                "Documentação: comentários em código e README com resultados.",
                                "Robustez: funciona para outros métodos implícitos como Trapezoidal."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso avançado de NumPy arrays e Matplotlib para visualização científica.",
                                "Física/Engenharia: Modelagem de ODEs rígidas em dinâmica de sistemas e controle.",
                                "Computação Científica: Técnicas de análise de estabilidade em simulações CFD.",
                                "Estatística: Verificação numérica e análise de erro em métodos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas rígidas (ex: cinética enzimática) ou circuitos elétricos RC com escalas rápidas, métodos A-estáveis como Backward Euler permitem passos h maiores sem instabilidade, reduzindo tempo computacional em solvers como MATLAB ode15s ou FEniCS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Estabilidade em Métodos Multistep",
                    "description": "Zero-estabilidade e condições de estabilidade para métodos de passo múltiplo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Zero-estabilidade em Métodos Multistep",
                        "description": "Conceito fundamental de zero-estabilidade para métodos lineares de passo múltiplo (multistep), definido pela análise do polinômio característico ρ(ζ), garantindo que o método não amplifique erros de arredondamento à medida que o passo h tende a zero.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Identificar o polinômio característico ρ(ζ)",
                            "description": "Dado um método linear multistep na forma ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}, derivar o polinômio característico ρ(ζ) = ∑_{j=0}^k α_j ζ^j e explicá-lo como a condição limite para h→0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a forma geral do método linear multistep",
                                  "subSteps": [
                                    "Leia a definição do método linear multistep: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}.",
                                    "Identifique os índices j de 0 a k, representando passos passados e futuros.",
                                    "Note que o lado esquerdo envolve aproximações y, e o direito envolve derivadas f escaladas por h.",
                                    "Explique verbalmente o que cada termo representa em termos de aproximação numérica.",
                                    "Esboce um exemplo simples com k=1 para visualizar."
                                  ],
                                  "verification": "Escreva a forma geral de memória e explique seu propósito em uma frase.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de papel, livro de análise numérica ou notas de aula sobre métodos multistep.",
                                  "tips": "Visualize o método como uma relação linear entre valores consecutivos de y e suas derivadas.",
                                  "learningObjective": "Entender a estrutura fundamental do método linear multistep.",
                                  "commonMistakes": "Confundir α_j com β_j ou ignorar o papel de h no lado direito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair os coeficientes α_j da equação do método",
                                  "subSteps": [
                                    "Reescreva a equação dada, destacando todos os termos com α_j multiplicando y_{n+j}.",
                                    "Liste explicitamente α_0, α_1, ..., α_k comparando com a forma padrão.",
                                    "Verifique se a soma dos α_j é zero para consistência de ordem 1 (regra de Dahlquist).",
                                    "Anote os valores numéricos ou simbólicos de cada α_j.",
                                    "Confirme que os coeficientes estão corretamente associados aos índices j."
                                  ],
                                  "verification": "Crie uma tabela com j e α_j correspondentes e some-os para checar consistência.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Equação do método específica, calculadora ou software simbólico como SymPy.",
                                  "tips": "Sempre normalize a equação para que o coeficiente de y_{n+k} seja 1, se necessário.",
                                  "learningObjective": "Identificar precisamente os coeficientes α_j na forma dada.",
                                  "commonMistakes": "Invertar sinais dos α_j ou associar errado aos índices n+j."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o polinômio característico ρ(ζ)",
                                  "subSteps": [
                                    "Defina ρ(ζ) = ∑_{j=0}^k α_j ζ^j, usando os α_j extraídos.",
                                    "Expanda o polinômio termo a termo: α_0 + α_1 ζ + ... + α_k ζ^k.",
                                    "Escreva-o em forma expandida e, se possível, fatorada.",
                                    "Substitua ζ=1 e verifique se ρ(1)=0 (condição de consistência).",
                                    "Teste com um valor simples de ζ para validar a expressão."
                                  ],
                                  "verification": "Derive ρ(ζ) para o método dado e compute ρ(1)=0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis, software como Mathematica ou Python para polinômios.",
                                  "tips": "Comece pelo termo de maior grau para evitar erros de indexação.",
                                  "learningObjective": "Formar corretamente o polinômio ρ(ζ) a partir dos α_j.",
                                  "commonMistakes": "Usar β_j em vez de α_j ou errar o expoente de ζ (deve ser j, não n+j)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar ρ(ζ) como condição limite para h→0 (zero-estabilidade)",
                                  "subSteps": [
                                    "Lembre que zero-estabilidade requer que as raízes de ρ(ζ)=0 tenham |ζ|≤1, com raízes simples em |ζ|=1.",
                                    "Discuta o limite h→0: o método aproxima a solução exata y' = f(y), implicando ρ(1)=0.",
                                    "Explique que ρ(ζ) surge da análise da solução homogênea no limite h=0.",
                                    "Ilustre com o teorema de Dahlquist: ordem máxima p≤k para zero-estável.",
                                    "Conclua ligando ρ(ζ) à estabilidade absoluta quando h é pequeno."
                                  ],
                                  "verification": "Explique em 3-5 frases o papel de ρ(ζ) na zero-estabilidade e dê um contraexemplo instável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas sobre teorema de estabilidade, gráficos de métodos estáveis/instáveis.",
                                  "tips": "Pense em ρ(ζ) como o 'denominador' na recursão característica.",
                                  "learningObjective": "Interpretar ρ(ζ) no contexto de zero-estabilidade para h→0.",
                                  "commonMistakes": "Confundir zero-estabilidade com estabilidade absoluta ou ignorar multiplicidade de raízes."
                                }
                              ],
                              "practicalExample": "Para o método trapezoidal: y_{n+1} - y_n = (h/2)(f_{n+1} + f_n). Aqui, α_0 = -1, α_1 = 1, então ρ(ζ) = ζ - 1. Raiz ζ=1 simples, |ζ|=1, logo zero-estável. No limite h→0, recupera y' = f(y).",
                              "finalVerifications": [
                                "Derive ρ(ζ) corretamente para um método dado e verifique ρ(1)=0.",
                                "Identifique todas as raízes de ρ(ζ) e confirme critérios de zero-estabilidade.",
                                "Explique verbalmente o significado de ρ(ζ) no limite h→0.",
                                "Compare ρ(ζ) de dois métodos: um estável e um instável.",
                                "Resolva um exercício similar sem consultar notas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de α_j (100% correto).",
                                "Correta formação de ρ(ζ) com expansão exata.",
                                "Explicação clara da relação com zero-estabilidade e h→0.",
                                "Uso correto de terminologia (ex: polinômio característico, Dahlquist).",
                                "Aplicação em exemplo prático sem erros.",
                                "Profundidade na interpretação das raízes."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar métodos multistep em Python (NumPy/SciPy) e testar estabilidade.",
                                "Física: Aplicar em simulações de EDOs em mecânica (ex: oscilador harmônico).",
                                "Engenharia: Análise de estabilidade em controle de sistemas dinâmicos.",
                                "Estatística: Estabilidade em métodos de Monte Carlo para EDOs estocásticas."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais em engenharia aeroespacial (órbitas), finanças (modelos Black-Scholes) e biologia (dinâmica populacional), identificar ρ(ζ) garante que erros não amplifiquem no limite de passos pequenos, evitando instabilidades em previsões de longo prazo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Verificar a condição da raiz principal",
                            "description": "Aplicar o teorema de zero-estabilidade de Dahlquist: ρ(1)=0 com multiplicidade simples (ρ'(1)≠0) e todas as outras raízes de ρ(ζ)=0 satisfazem |ζ| ≤ 1, demonstrando estabilidade para sequências constantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o polinômio de característica ρ(ζ) em métodos multistep",
                                  "subSteps": [
                                    "Revise a forma geral de um método multistep linear: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}.",
                                    "Identifique o polinômio de característica ρ(ζ) = ∑_{j=0}^k α_j ζ^j.",
                                    "Explique o papel de ρ(ζ) na análise de zero-estabilidade para sequências constantes (f=0).",
                                    "Associe ρ(ζ) à solução da recursão homogênea y_{n+k} = soma termos.",
                                    "Diferencie ρ(ζ) de σ(ζ), o polinômio de diferença."
                                  ],
                                  "verification": "Escreva ρ(ζ) para um método multistep dado (ex: Backward Euler) e confirme que representa a recursão para constantes.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Papel e lápis ou SymPy/MATLAB"
                                  ],
                                  "tips": "Sempre normalize ρ(ζ) com α_k = 1 para consistência.",
                                  "learningObjective": "Compreender a origem e significado de ρ(ζ) na zero-estabilidade.",
                                  "commonMistakes": [
                                    "Confundir ρ(ζ) com σ(ζ)",
                                    "Esquecer normalização α_k=1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a condição ρ(1) = 0",
                                  "subSteps": [
                                    "Substitua ζ=1 em ρ(ζ) e compute ∑ α_j.",
                                    "Interprete ρ(1)=0 como consistência para constantes (método preserva y_n = c).",
                                    "Teste com exemplo: ρ(ζ)=ζ-1 → ρ(1)=0.",
                                    "Identifique métodos que falham: ex ρ(ζ)=ζ^2 → ρ(1)=1 ≠0.",
                                    "Prove que ρ(1)=0 é necessário para ordem pelo menos 1."
                                  ],
                                  "verification": "Para ρ(ζ) dado, calcule ρ(1) e confirme =0; caso contrário, explique falha.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Calculadora simbólica",
                                    "Exemplos de polinômios multistep"
                                  ],
                                  "tips": "ρ(1)= ∑ α_j =0 garante preservação de constantes.",
                                  "learningObjective": "Aplicar e interpretar a condição de consistência básica ρ(1)=0.",
                                  "commonMistakes": [
                                    "Erro aritmético na soma",
                                    "Ignorar sinal dos coeficientes α_j"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar multiplicidade simples da raiz ζ=1: ρ'(1) ≠ 0",
                                  "subSteps": [
                                    "Compute a derivada ρ'(ζ) = ∑ j α_j ζ^{j-1}.",
                                    "Avalie ρ'(1) = ∑ j α_j e confirme ≠0.",
                                    "Interprete: multiplicidade simples garante crescimento linear, não exponencial.",
                                    "Exemplo bom: ρ(ζ)=ζ^2 -3ζ +2? Não, ρ'(ζ)=2ζ-3, ρ'(1)=-1≠0? Espera, ρ(1)=0 mas cheque.",
                                    "Para ρ(ζ)=(ζ-1)^2, ρ'(1)=0 → instável."
                                  ],
                                  "verification": "Calcule ρ'(1) para polinômio dado e afirme se multiplicidade é simples.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "SymPy para derivadas",
                                    "Lista de métodos multistep"
                                  ],
                                  "tips": "Use regra da derivada polinomial; verifique ρ(1)=0 primeiro.",
                                  "learningObjective": "Determinar se a raiz principal tem multiplicidade simples.",
                                  "commonMistakes": [
                                    "Erro na derivada (esquecer fator j)",
                                    "Confundir ρ'(1)=0 com instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar raízes espúrias: |ζ| ≤ 1 para todas as outras raízes",
                                  "subSteps": [
                                    "Encontre todas as raízes de ρ(ζ)=0 usando fatoração ou solver numérico.",
                                    "Identifique a raiz ζ=1 e isole as demais.",
                                    "Para cada raiz ζ_i ≠1, compute |ζ_i| e confirme ≤1.",
                                    "Exemplo: ρ(ζ)=ζ^2 - ζ = ζ(ζ-1), raízes 0 e 1; |0|<1 OK.",
                                    "Falha: ρ(ζ)=ζ^2 -0.5ζ, raízes 0 e 0.5? ρ(1)=0.5≠0, mas ajuste."
                                  ],
                                  "verification": "Liste todas raízes, marque ζ=1, e verifique |ζ_i|≤1 para restantes.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Solver polinomial (MATLAB roots() ou SymPy)",
                                    "Gráfico de ρ(ζ)"
                                  ],
                                  "tips": "Raízes no círculo unitário OK se |ζ|=1, mas monitore crescimento.",
                                  "learningObjective": "Garantir ausência de raízes espúrias causadoras de instabilidade.",
                                  "commonMistakes": [
                                    "Raiz dupla em 1 contada como espúria",
                                    "Erro numérico em raízes complexas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o método Leapfrog: ρ(ζ) = ζ^2 - ζ, compute: ρ(1)=0, ρ'(ζ)=2ζ-1 → ρ'(1)=1≠0, raízes ζ=0 (|0|<1) e ζ=1. Condição satisfeita: zero-estável.",
                              "finalVerifications": [
                                "ρ(1) = 0 confirmado?",
                                "ρ'(1) ≠ 0 calculado corretamente?",
                                "Todas raízes listadas e |ζ| ≤1 para ζ≠1?",
                                "Multiplicidade de ζ=1 é exatamente 1?",
                                "Interpretação física: preserva constantes sem oscilações?",
                                "Teste com h→0: consistência ordem 1?"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de ρ(1) e ρ'(1) (exato simbólico).",
                                "Correta identificação e verificação de todas as raízes.",
                                "Interpretação correta do teorema de Dahlquist.",
                                "Uso de exemplos para ilustrar sucesso/falha.",
                                "Ausência de erros comuns como derivada errada.",
                                "Clareza na explicação da estabilidade para sequências constantes."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar solver de raízes em Python (NumPy).",
                                "Física Computacional: Estabilidade em simulações de EDOs (ex: osciladores).",
                                "Álgebra Linear: Autovalores análogos a raízes de ρ(ζ).",
                                "Engenharia: Análise de estabilidade em controle numérico."
                              ],
                              "realWorldApplication": "Em simulações CFD ou previsão meteorológica, verificar zero-estabilidade garante que erros de arredondamento não amplifiquem em soluções constantes, essencial para precisão em modelos climáticos ou aerodinâmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Analisar exemplos de métodos zero-estáveis",
                            "description": "Classificar métodos multistep comuns, como o método de diferença finita backward (zero-estável) versus métodos não zero-estáveis (ex.: ρ(ζ) com raízes |ζ|>1), usando cálculos explícitos de raízes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição de zero-estabilidade em métodos multistep",
                                  "subSteps": [
                                    "Estude a forma geral de métodos multistep lineares: ∑_{k=0}^m α_k y_{n+k} = h ∑_{k=0}^m β_k f_{n+k}.",
                                    "Identifique o polinômio de característica ρ(ζ) = ∑_{k=0}^m α_k ζ^k.",
                                    "Aprenda o critério de zero-estabilidade: todas as raízes de ρ(ζ)=0 devem satisfazer |ζ| ≤ 1, com raízes |ζ|=1 simples.",
                                    "Discuta implicações: métodos não zero-estáveis amplificam erros de arredondamento.",
                                    "Anote exemplos iniciais de métodos comuns como BDF (zero-estáveis) vs. explícitos instáveis."
                                  ],
                                  "verification": "Escreva a definição de zero-estabilidade e o critério de raízes em suas próprias palavras, sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Caderno e caneta",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Foquem em visualizar o polinômio ρ(ζ) como o numerador da solução característica.",
                                  "learningObjective": "Compreender conceitualmente zero-estabilidade e seu critério via polinômio ρ(ζ).",
                                  "commonMistakes": [
                                    "Confundir ρ(ζ) com σ(ζ) (polinômio de f)",
                                    "Ignorar multiplicidade de raízes |ζ|=1."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o polinômio ρ(ζ) para métodos multistep específicos",
                                  "subSteps": [
                                    "Selecione o método backward difference simples: y_{n+1} - y_n = h f_{n+1}, derive ρ(ζ) = ζ - 1.",
                                    "Para um método multistep não zero-estável: considere y_{n+1} - 2 y_n = h f_n, derive ρ(ζ) = ζ - 2.",
                                    "Escreva a forma geral para BDF2: y_{n+2} - (4/3) y_{n+1} + (1/3) y_n = (2/3) h f_{n+2}, compute ρ(ζ).",
                                    "Verifique normalização: α_m = 1.",
                                    "Tabule os coeficientes α_k para cada método."
                                  ],
                                  "verification": "Liste ρ(ζ) corretamente para 3 métodos e confirme α_m=1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de fórmulas de métodos multistep",
                                    "Software simbólico como SymPy (opcional)",
                                    "Caderno"
                                  ],
                                  "tips": "Sempre normalize dividindo pela α_m para ρ(1)=0.",
                                  "learningObjective": "Derivar com precisão o polinômio ρ(ζ) a partir da esquematização do método.",
                                  "commonMistakes": [
                                    "Erro nos coeficientes α_k ao copiar a fórmula",
                                    "Esquecer de normalizar ρ(ζ)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular raízes de ρ(ζ) e analisar magnitudes",
                                  "subSteps": [
                                    "Para ρ(ζ) = ζ - 1, resolva ζ=1, verifique |ζ|=1.",
                                    "Para ρ(ζ) = ζ - 2, resolva ζ=2, note |ζ|=2 >1.",
                                    "Para BDF2 ρ(ζ) ≈ ζ^2 - (4/3)ζ + 1/3, use fórmula quadrática para raízes e compute módulos.",
                                    "Calcule numericamente |ζ_i| para cada raiz usando calculadora.",
                                    "Plote ou tabule as raízes no plano complexo."
                                  ],
                                  "verification": "Tabela com raízes, |ζ| e classificação (estável ou não) para 3 exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou Python/MATLAB para raízes",
                                    "Papel milimetrado para plano complexo"
                                  ],
                                  "tips": "Use comando roots() em MATLAB ou numpy.roots() para polinômios de grau >2.",
                                  "learningObjective": "Calcular raízes e avaliar critério de estabilidade numericamente.",
                                  "commonMistakes": [
                                    "Erro aritmético em raízes quadráticas",
                                    "Confundir módulo |ζ| com valor real."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar métodos e comparar zero-estáveis vs. não zero-estáveis",
                                  "subSteps": [
                                    "Classifique: backward (zero-estável) vs. ρ(ζ)=ζ-2 (não zero-estável).",
                                    "Compare crescimento de erros: solucione y_h = ρ(1/h)^n para h→0.",
                                    "Discuta exemplos reais: BDF usados em stiff ODEs por zero-estabilidade.",
                                    "Crie um fluxograma para análise: derivar ρ → raízes → |ζ|≤1? → simples?.",
                                    "Resuma diferenças em uma tabela comparativa."
                                  ],
                                  "verification": "Classifique corretamente 4 métodos e explique por quê em parágrafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código para testar estabilidade (opcional)",
                                    "Tabela comparativa template"
                                  ],
                                  "tips": "Teste estabilidade simulando y' =0 com ruído inicial.",
                                  "learningObjective": "Classificar métodos multistep baseados em análise explícita de ρ(ζ).",
                                  "commonMistakes": [
                                    "Classificar erroneamente raízes |ζ|=1 múltiplas como instáveis",
                                    "Ignorar contexto stiff vs. non-stiff."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o método backward: y_{n+1} - y_n = h f_{n+1}, ρ(ζ)=ζ-1, raiz ζ=1 (|ζ|=1, simples) → zero-estável. Vs. método instável y_{n+1} = 2 y_n - y_{n-1} + h (f_n - f_{n-2}), ajuste para ρ(ζ)=(ζ-1)(ζ-2), raízes 1 e 2 → não zero-estável, pois |2|>1 amplifica erros.",
                              "finalVerifications": [
                                "Deriva ρ(ζ) corretamente para métodos dados.",
                                "Calcula todas as raízes e seus módulos com precisão.",
                                "Classifica zero-estável vs. não zero-estável justificando.",
                                "Identifica raízes |ζ|=1 múltiplas como problema.",
                                "Compara pelo menos dois exemplos com cálculos explícitos.",
                                "Explica implicações para solução numérica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de ρ(ζ) (30%)",
                                "Correção nos cálculos de raízes e |ζ| (25%)",
                                "Classificação e justificativa lógica (20%)",
                                "Uso de exemplos explícitos e comparações (15%)",
                                "Clareza na explicação de implicações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar análise de raízes em Python (NumPy/SciPy).",
                                "Física: Estabilidade em simulações de EDOs dinâmicas (ex: osciladores).",
                                "Engenharia Computacional: Escolha de solvers em CFD para estabilidade.",
                                "Estatística: Análise de erro de propagação em séries temporais."
                              ],
                              "realWorldApplication": "Em simulações numéricas de equações diferenciais rígidas (ex: previsão meteorológica, circuitos elétricos), métodos zero-estáveis como BDF previnem explosão de erros de arredondamento, garantindo soluções confiáveis em software como MATLAB ODE solvers ou COMSOL."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Condições de Estabilidade para Métodos Multistep",
                        "description": "Condições adicionais de estabilidade além da zero-estabilidade, incluindo estabilidade absoluta, região de estabilidade no plano complexo e requisitos para problemas stiff, garantindo convergência e comportamento assintótico correto.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Definir estabilidade absoluta e região de estabilidade",
                            "description": "Explicar a estabilidade absoluta via |R(ζ, z)| ≤ 1 para z = hλ no semiplano esquerdo, onde R é a função de amplificação do método multistep, e esboçar a região de estabilidade para métodos como Adams e BDF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Métodos Multistep e Estabilidade",
                                  "subSteps": [
                                    "Recordar a forma geral de métodos multistep lineares: ∑_{j=0}^k α_j y_{n+j} = h ∑_{j=0}^k β_j f_{n+j}.",
                                    "Explicar o teste do modo próprio único para estabilidade local.",
                                    "Introduzir o semiplano esquerdo do plano complexo: Re(λ) < 0 para eigenvalues de sistemas rígidos.",
                                    "Discutir por que a estabilidade absoluta é crucial para passos de tempo variáveis.",
                                    "Derivar brevemente a recursão característica para o método multistep aplicado a y' = λy."
                                  ],
                                  "verification": "Escrever a equação característica ρ(ζ)/ζ = σ(ζ) e confirmar que z = hλ aparece corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), caderno, calculadora científica.",
                                  "tips": "Use notação consistente para polinômios ρ e σ desde o início para evitar confusão.",
                                  "learningObjective": "Compreender os pré-requisitos de estabilidade em métodos multistep.",
                                  "commonMistakes": "Confundir estabilidade local (zero-stability) com absoluta; ignorar o papel de h variável."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Estabilidade Absoluta Formalmente",
                                  "subSteps": [
                                    "Definir a função de amplificação R(ζ, z) como a solução da equação ρ(ζ) - z σ(ζ) = 0, com |ζ| ≤ 1 + O(|z|).",
                                    "Estabelecer a condição de estabilidade absoluta: sup_{Re(z)≤0} |R(ζ, z)| ≤ 1 para a raiz principal ζ.",
                                    "Explicar que isso garante que erros não amplifiquem no semiplano esquerdo.",
                                    "Discutir a raiz espúria e por que ela deve satisfazer |ζ| ≤ 1.",
                                    "Verificar a definição para o método de Euler backward (BDF1)."
                                  ],
                                  "verification": "Escrever a definição exata de estabilidade absoluta e aplicar a um método simples como trapezoidal.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, software simbólico como Mathematica ou SymPy para resolver equações polinomiais.",
                                  "tips": "Foque na raiz principal (a de maior módulo para z=0); isole-a graficamente se possível.",
                                  "learningObjective": "Definir precisamente estabilidade absoluta usando a norma da função de amplificação.",
                                  "commonMistakes": "Esquecer a expansão assintótica O(|z|) ou confundir com estabilidade A(α)-estável."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Analisar a Função de Amplificação R(ζ, z)",
                                  "subSteps": [
                                    "Derivar R(ζ, z) explicitamente para métodos multistep genéricos.",
                                    "Calcular |R(ζ, z)| para z no semiplano esquerdo e verificar |R| ≤ 1.",
                                    "Explorar o comportamento assintótico para |z| grande: R ≈ ρ(ζ)/σ(ζ).",
                                    "Comparar com métodos Runge-Kutta para contextualizar.",
                                    "Resolver numericamente raízes para um exemplo com k=2."
                                  ],
                                  "verification": "Plotar |R(ζ, z)| para z = -10 + 0i e confirmar que está abaixo de 1.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB ou Python (NumPy/SciPy) para plots complexos, quadro branco.",
                                  "tips": "Use o método de Newton para encontrar raízes ζ(z) iterativamente.",
                                  "learningObjective": "Manipular e avaliar a função de amplificação para verificar estabilidade.",
                                  "commonMistakes": "Não considerar todas as raízes ζ; assumir linearidade sem verificar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Esboçar Regiões de Estabilidade para Adams e BDF",
                                  "subSteps": [
                                    "Definir a região de estabilidade S = {z ∈ ℂ : |R(ζ, z)| ≤ 1, Re(z) ≤ 0}.",
                                    "Para métodos Adams (explícitos): esboçar o círculo unitário limitado.",
                                    "Para BDF (implícitos): destacar a inclusão do semiplano esquerdo para ordens baixas.",
                                    "Comparar tamanhos: Adams pequenos, BDF grandes para rigidez.",
                                    "Plotar manualmente ou via software para AB2, BDF2."
                                  ],
                                  "verification": "Desenhar as regiões e identificar se iℝ está incluída (A-estável).",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software de plotagem (MATLAB stability region toolbox ou Python), papel para esboços.",
                                  "tips": "Comece com métodos de ordem 1-2; use simetria no plano complexo.",
                                  "learningObjective": "Visualizar e esboçar regiões de estabilidade específicas de Adams e BDF.",
                                  "commonMistakes": "Confundir região absoluta com relativa; exagerar o tamanho para Adams explícitos."
                                }
                              ],
                              "practicalExample": "Para o método BDF2: α = [3, -4, 1], β = [2/3, 0, -1/3]. Calcule R(ζ, z) para z = -5i, resolva ρ(ζ) = z σ(ζ), verifique |ζ_principal| ≈ 1 e plote a região mostrando cobertura do eixo imaginário.",
                              "finalVerifications": [
                                "Definir corretamente estabilidade absoluta com |R(ζ, z)| ≤ 1 para Re(z) ≤ 0.",
                                "Derivar R(ζ, z) para um método multistep específico.",
                                "Esboçar região de estabilidade para Adams de ordem 2.",
                                "Esboçar região para BDF de ordem 2 e notar A-estabilidade.",
                                "Explicar limitação de Adams explícitos em problemas rígidos.",
                                "Verificar numericamente |R| ≤ 1 para z no semiplano esquerdo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de estabilidade absoluta (20%)",
                                "Correta derivação da função de amplificação (25%)",
                                "Qualidade e acurácia dos esboços de regiões (25%)",
                                "Análise comparativa Adams vs BDF (15%)",
                                "Uso correto de conceitos assintóticos e raízes (10%)",
                                "Clareza em verificações numéricas/exemplos (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores rígidos (equações diferenciais).",
                                "Engenharia: Análise de controle e sistemas dinâmicos rígidos.",
                                "Computação: Implementação em solvers ODE como ODE45/ODE15s no MATLAB.",
                                "Matemática Aplicada: Teoria de perturbações em análise complexa."
                              ],
                              "realWorldApplication": "Em simulações de engenharia química (reatores rígidos) ou previsão numérica do tempo, onde BDF permite passos maiores em regiões rígidas sem perda de estabilidade, otimizando tempo de computação em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Aplicar condições de convergência",
                            "description": "Usar o teorema de equivalência de Lax adaptado: zero-estabilidade + consistência implica convergência para métodos multistep consistentes de ordem p ≥ 1, verificando em problemas de valor inicial y' = f(t,y).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Estabilidade e Consistência",
                                  "subSteps": [
                                    "Defina zero-estabilidade para métodos multistep usando a polinomial característica ρ(ζ) = 0 tendo apenas raiz ζ=1 simples.",
                                    "Explique consistência: método de ordem p ≥ 1 satisfaz ∑_{j=0}^k α_j = 0, ∑_{j=0}^k j α_j = 1, e condições para σ_j.",
                                    "Recapitule convergência: ||y_n - y(t_n)|| → 0 quando h → 0.",
                                    "Estude problemas de valor inicial y' = f(t,y), y(t_0)=y_0.",
                                    "Compare com métodos de Runge-Kutta para multistep."
                                  ],
                                  "verification": "Resuma em um parágrafo cada conceito e dê um exemplo simples de não zero-estável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), notas de aula, calculadora simbólica (Mathematica ou SymPy).",
                                  "tips": "Use diagramas de raiz da polinomial ρ para visualizar estabilidade.",
                                  "learningObjective": "Compreender pré-requisitos para o teorema de Lax.",
                                  "commonMistakes": "Confundir zero-estabilidade com estabilidade absoluta; ignorar ordem p ≥ 1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Teorema de Equivalência de Lax Adaptado",
                                  "subSteps": [
                                    "Leia a enunciação: Para métodos multistep consistentes de ordem p ≥ 1, zero-estabilidade + consistência ⇒ convergência.",
                                    "Analise a prova esquemática: consistência garante erro local O(h^{p+1}), zero-estabilidade propaga erros.",
                                    "Identifique condições: linear multistep y_{n+1} = ∑ α_j y_{n+j} + h ∑ β_j f(t_{n+j}, y_{n+j}).",
                                    "Discuta limitações: não vale para p=0 ou métodos inconsistentes.",
                                    "Anote teorema original de Lax para métodos de diferença finita."
                                  ],
                                  "verification": "Escreva o teorema e prove intuitivamente em 5 linhas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigo ou capítulo sobre teorema de Lax, quadro branco para anotações.",
                                  "tips": "Associe zero-estabilidade à região |ζ| ≤ 1 + O(h) na análise de Dahlquist.",
                                  "learningObjective": "Memorizar e internalizar o teorema adaptado.",
                                  "commonMistakes": "Omitir 'consistentes de ordem p ≥ 1'; confundir com teorema de Stolz."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Zero-Estabilidade em um Método Multistep",
                                  "subSteps": [
                                    "Escolha método exemplo: Adams-Moulton de ordem 2 (α_0=-1, α_1=1, β_0=5/12, β_1=2/3? Ajuste).",
                                    "Forme ρ(ζ) = ∑ α_j ζ^j.",
                                    "Resolva raízes de ρ(ζ)=0; verifique apenas ζ=1 simples, outras |ζ|<1.",
                                    "Use teste de Jury ou Routh-Hurwitz para estabilidade.",
                                    "Compare com método instável como y_{n+1} - 2 y_n + y_{n-1} = 0."
                                  ],
                                  "verification": "Calcule raízes e confirme zero-estável com plot.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python (numpy.polyroots), papel para cálculos.",
                                  "tips": "Normalize ρ(1)=0 e ρ'(1)=1 para multistep padrão.",
                                  "learningObjective": "Aplicar teste de zero-estabilidade.",
                                  "commonMistakes": "Raízes múltiplas em ζ=1; ignorar raízes complexas com |ζ|>1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Consistência e Aplicar Teorema para Convergência",
                                  "subSteps": [
                                    "Para o método, verifique ∑ α_j =0, ∑ j α_j =1, condições em β_j via expansão de Taylor.",
                                    "Confirme ordem p ≥1 calculando C_p ≠0.",
                                    "Aplique teorema: zero-estável + consistente ⇒ convergente.",
                                    "Simule numericamente em y'= -y, y(0)=1; compare com solução exata.",
                                    "Analise erro global O(h^p)."
                                  ],
                                  "verification": "Gere tabela de erros para h=0.1, 0.05, 0.01; confirme redução.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (scipy.integrate para baseline), código para multistep.",
                                  "tips": "Implemente método em loop simples; use h adaptativo se possível.",
                                  "learningObjective": "Concluir convergência via teorema.",
                                  "commonMistakes": "Erro na ordem p; não normalizar polinômios."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar em Problema Não Linear e Generalizar",
                                  "subSteps": [
                                    "Escolha y' = y(1-t), y(0)=1; verifique Lipschitz.",
                                    "Aplique método multistep com predictor-corrector.",
                                    "Confirme zero-estabilidade e consistência independem de f.",
                                    "Meça convergência empírica.",
                                    "Discuta falhas: rigidez ou não linearidade forte."
                                  ],
                                  "verification": "Plot erro vs h log-log; inclinação ≈p.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python reutilizado, gráfico matplotlib.",
                                  "tips": "Use Adams-Bashforth como predictor para implícitos.",
                                  "learningObjective": "Generalizar teorema para IVPs reais.",
                                  "commonMistakes": "Assumir convergência sem consistência; problemas rígidos."
                                }
                              ],
                              "practicalExample": "Para o método trapezoidal (α_0=-1, α_1=1, β_0=1/2, β_1=1/2), verifique ρ(ζ)=ζ-1 (zero-estável), ordem p=2 consistente, logo convergente em y'=-λy com λ>0, simulando com h decrescente e erro caindo como O(h^2).",
                              "finalVerifications": [
                                "Explicar verbalmente o teorema de Lax adaptado sem consultar notas.",
                                "Verificar zero-estabilidade de um novo método multistep dado.",
                                "Calcular ordem de consistência para método arbitrário.",
                                "Simular convergência em IVP modelo com código funcional.",
                                "Identificar por que método inconsistente falha.",
                                "Comparar com método single-step."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e aplicação do teorema (90% correto).",
                                "Cálculos de raízes e ordem sem erros aritméticos.",
                                "Simulações numéricas com erros <10^{-4} para h=0.01.",
                                "Análise qualitativa de falhas potenciais.",
                                "Generalização para classes de problemas IVP.",
                                "Clareza em relatórios/plots."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar solvers em Python/ MATLAB.",
                                "Física: Simulações de EDOs em dinâmica (ex: osciladores).",
                                "Engenharia: Modelagem em controle automático.",
                                "Computação Científica: Otimização de h em HPC."
                              ],
                              "realWorldApplication": "Em simulações meteorológicas ou financeiras, garante que métodos multistep como Gear convergem para previsões precisas em EDOs grandes, evitando instabilidades numéricas em previsões de longo prazo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Avaliar estabilidade em problemas stiff",
                            "description": "Discutir limitações de métodos explícitos multistep em problemas stiff (autovalores com partes reais grandes negativas), destacando métodos implícitos como BDF (Backward Differentiation Formulas) que satisfazem A-estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de problemas stiff",
                                  "subSteps": [
                                    "Definir problemas stiff como sistemas de EDOs onde os autovalores têm partes reais grandes negativas, exigindo passos de tempo muito pequenos para estabilidade.",
                                    "Identificar características: escalas de tempo díspares, rigidez em soluções numéricas.",
                                    "Analisar o papel dos autovalores na matriz jacobiana do sistema.",
                                    "Estudar exemplos clássicos como o modelo de Van der Pol com parâmetro μ grande.",
                                    "Discutir impacto na escolha de métodos numéricos."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o que é um problema stiff e fornecer um exemplo com autovalores.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Software Python com NumPy/SciPy",
                                    "Artigo sobre problemas stiff"
                                  ],
                                  "tips": "Visualize autovalores no plano complexo para intuitividade.",
                                  "learningObjective": "Identificar e caracterizar problemas stiff com base em autovalores.",
                                  "commonMistakes": [
                                    "Confundir stiff com não-linearidade.",
                                    "Ignorar a parte real negativa dos autovalores.",
                                    "Achar que todos os problemas grandes são stiff."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar limitações de métodos explícitos multistep",
                                  "subSteps": [
                                    "Revisar métodos explícitos multistep como Adams-Bashforth e sua região de estabilidade limitada.",
                                    "Demonstrar que para autovalores λ com Re(λ) << 0, o passo h deve satisfazer |R(∞)| < 1, mas explícitos têm R(∞) ≠ 0.",
                                    "Simular numericamente um problema stiff com método explícito e observar instabilidade.",
                                    "Calcular o raio espectral e mostrar necessidade de h muito pequeno.",
                                    "Comparar com problemas não-stiff para contraste."
                                  ],
                                  "verification": "Gerar gráfico de solução instável com método explícito em problema stiff.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python/MATLAB para simulações",
                                    "Tabelas de métodos multistep",
                                    "Gráficos de regiões de estabilidade"
                                  ],
                                  "tips": "Use h = 0.001 inicialmente para ver falha e reduza para confirmar.",
                                  "learningObjective": "Explicar por que métodos explícitos falham em problemas stiff.",
                                  "commonMistakes": [
                                    "Assumir que reduzir h resolve sempre sem custo computacional.",
                                    "Confundir estabilidade com precisão.",
                                    "Não plotar soluções para visualização."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir métodos implícitos e conceito de A-estabilidade",
                                  "subSteps": [
                                    "Definir métodos implícitos multistep e equações como y_{n+1} = y_n + h ∑ β_k f(t_{n+k}, y_{n+k}).",
                                    "Explicar A-estabilidade: região de estabilidade inclui todo o semiplano esquerdo Re(z) ≤ 0.",
                                    "Derivar critério de A-estabilidade para multistep lineares.",
                                    "Discutir trade-offs: custo computacional maior devido a sistemas lineares por passo.",
                                    "Comparar regiões de estabilidade de explícitos vs implícitos."
                                  ],
                                  "verification": "Desenhar e rotular regiões de estabilidade, marcando semiplano esquerdo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folhas com fórmulas de estabilidade",
                                    "Software de plotagem (Matplotlib)",
                                    "Referência: Hairer et al. Solving ODEs"
                                  ],
                                  "tips": "Lembre que Dahlquist barrier impede A-estabilidade em métodos explícitos de ordem >2.",
                                  "learningObjective": "Distinguir A-estabilidade e justificar sua necessidade em stiff problems.",
                                  "commonMistakes": [
                                    "Confundir A-estabilidade com incondicional.",
                                    "Ignorar L-estabilidade para problemas com autovalores reais grandes.",
                                    "Achar implícitos sempre melhores sem contexto."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar BDF e avaliar estabilidade em problemas stiff",
                                  "subSteps": [
                                    "Apresentar fórmulas BDF (Backward Differentiation Formulas) de ordem 1 a 6.",
                                    "Verificar A-estabilidade de BDF até ordem 2 (BDF1, BDF2 são A-estáveis; ordem 3-6 são L-estáveis).",
                                    "Implementar BDF2 em um problema stiff e comparar com explícito.",
                                    "Avaliar estabilidade usando teste de autovalores e passos h razoáveis.",
                                    "Discutir implementação prática com solvers como CVODE ou ode15s."
                                  ],
                                  "verification": "Resolver problema stiff com BDF estável e h=0.1, confirmando convergência.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python SciPy (solve_ivp com method='BDF')",
                                    "Tabela de coeficientes BDF",
                                    "Problema teste stiff"
                                  ],
                                  "tips": "Use jacobiano aproximado para eficiência em implícitos.",
                                  "learningObjective": "Aplicar BDF para avaliar e resolver estabilidade em stiff problems.",
                                  "commonMistakes": [
                                    "Usar ordem alta BDF sem verificar L-estabilidade.",
                                    "Não linearizar corretamente o sistema implícito.",
                                    "Comparar tempos sem normalizar precisão."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o problema stiff y' = -1001 y + 1000 e^{-t}, y(0)=1. Com método Adams-Bashforth de ordem 4 (explícito), a solução explode para h>0.001. Usando BDF2 (implícito), solução estável e precisa para h=0.1, aproximando a solução exata y(t) = e^{-t}.",
                              "finalVerifications": [
                                "Explicar limitações de explícitos em stiff via autovalores.",
                                "Desenhar região de estabilidade de BDF2 incluindo semiplano esquerdo.",
                                "Simular stiff problem com explícito (instável) vs BDF (estável).",
                                "Definir A-estabilidade e listar BDF A-estáveis.",
                                "Identificar quando usar implícitos em contexto real.",
                                "Calcular passo h máximo para estabilidade em dado λ."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de stiff e autovalores (90% correto).",
                                "Correta identificação de falhas explícitas e vantagens BDF.",
                                "Qualidade de simulações e gráficos (estável vs instável).",
                                "Compreensão de A-estabilidade com prova ou diagrama.",
                                "Aplicação prática em exemplo numérico.",
                                "Análise de trade-offs computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de circuitos RC stiff.",
                                "Engenharia Química: Modelos de reatores com escalas rápidas/lentas.",
                                "Programação Científica: Implementação em SciPy/MATLAB ode solvers.",
                                "Análise de Sistemas Dinâmicos: Estabilidade em controle.",
                                "Matemática Aplicada: Regiões de estabilidade em Runge-Kutta."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular ou circuitos elétricos integrados, onde componentes têm constantes de tempo variando de microssegundos a segundos, métodos BDF permitem passos eficientes sem instabilidade, acelerando simulações industriais em software como COMSOL ou SPICE."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.4",
                            "name": "Comparar estabilidade multistep versus métodos de passo simples",
                            "description": "Comparar regiões de estabilidade de métodos multistep (ex.: Adams-Bashforth explícito, limitado) com Runge-Kutta (mais flexíveis), justificando uso de controle de passo variável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais dos métodos multistep e Runge-Kutta",
                                  "subSteps": [
                                    "Estude a formulação geral dos métodos multistep lineares, como Adams-Bashforth explícito.",
                                    "Revise os métodos de Runge-Kutta de ordem fixa, como RK4, e sua abordagem de passo único.",
                                    "Identifique as características de estabilidade: A-estabilidade, L-estabilidade e regiões no plano complexo.",
                                    "Anote as limitações inerentes: multistep requer passos iniciais e é sensível a passos fixos.",
                                    "Compare formalmente o uso de histórico de passos em multistep vs. avaliações locais em RK."
                                  ],
                                  "verification": "Resuma em um quadro comparativo as diferenças conceituais entre os métodos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex.: Burden & Faires), notas de aula, software como MATLAB ou Python (SymPy/NumPy).",
                                  "tips": "Use diagramas de fluxo para visualizar como cada método avança a solução.",
                                  "learningObjective": "Compreender as bases teóricas que afetam a estabilidade de cada família de métodos.",
                                  "commonMistakes": "Confundir multistep implícitos com explícitos ou ignorar a necessidade de passos iniciais em multistep."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar e plotar regiões de estabilidade",
                                  "subSteps": [
                                    "Calcule a função de amplificação para Adams-Bashforth de ordem 2: ρ(z) e σ(z).",
                                    "Derive a região de estabilidade absoluta para RK4 no plano z = hλ.",
                                    "Use software para plotar as regiões: multistep (limitada, alongada) vs. RK (maior, mais circular).",
                                    "Analise o comportamento para λ real negativo (rigidez) e imaginário (oscilações).",
                                    "Teste numericamente com y' = λy para validar os plots."
                                  ],
                                  "verification": "Gere plots corretos das regiões e identifique pontos dentro/fora delas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (Matplotlib, SciPy), MATLAB, papel quadriculado para esboços manuais.",
                                  "tips": "Normalize z = hλ e foque no semicírculo unitário para estabilidade condicional.",
                                  "learningObjective": "Visualizar graficamente as regiões de estabilidade para análise qualitativa.",
                                  "commonMistakes": "Escalar incorretamente o eixo z ou confundir estabilidade absoluta com relativa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar as regiões de estabilidade quantitativamente",
                                  "subSteps": [
                                    "Meça o raio de estabilidade ao longo do eixo real negativo para ambos os métodos.",
                                    "Compare a extensão no eixo imaginário: multistep limitado vs. RK mais flexível.",
                                    "Quantifique vantagens: RK permite passos maiores em problemas rígidos.",
                                    "Discuta trade-offs: custo computacional (multistep mais eficiente por passo, mas menos flexível).",
                                    "Crie uma tabela com métricas: diâmetro real, altura imaginária, área aproximada."
                                  ],
                                  "verification": "Elabore uma tabela comparativa com valores numéricos e conclusões qualitativas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel/Google Sheets para tabelas, plots do passo anterior.",
                                  "tips": "Use |R| > 2 para multistep como benchmark contra RK4 (|R| ≈ 2.78).",
                                  "learningObjective": "Realizar comparação precisa destacando limitações do multistep explícito.",
                                  "commonMistakes": "Ignorar que multistep explícito é condicionalmente estável, superestimando sua robustez."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar o uso de controle de passo variável",
                                  "subSteps": [
                                    "Explique como regiões limitadas de multistep causam instabilidade em passos fixos grandes.",
                                    "Descreva controle de passo em RK: erro local estimado para ajustar h dinamicamente.",
                                    "Simule um problema rígido (ex.: y' = -100y) com passo fixo vs. variável.",
                                    "Argumente economicamente: RK adaptativo mantém estabilidade sem subpassos excessivos.",
                                    "Conclua com cenários onde multistep falha e RK succeeds."
                                  ],
                                  "verification": "Escreva um parágrafo justificando a preferência por RK em problemas gerais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código Python/MATLAB para simulações, exemplos de EDOs rígidas.",
                                  "tips": "Teste com h inicial grande para demonstrar blow-up em multistep.",
                                  "learningObjective": "Justificar escolhas metodológicas baseadas em análise de estabilidade.",
                                  "commonMistakes": "Subestimar overhead do controle de passo, focando só em eficiência por passo."
                                }
                              ],
                              "practicalExample": "Resolva numericamente y' = -50y + sin(t), y(0)=1, com h=0.1 fixo usando Adams-Bashforth ordem 2 (instável, oscilações) vs. RK4 com controle de passo (estável, converge). Plote soluções e erros para visualizar superioridade da flexibilidade RK.",
                              "finalVerifications": [
                                "Pode plotar corretamente regiões de estabilidade de Adams-Bashforth e RK4.",
                                "Identifica limitações do multistep explícito em problemas rígidos.",
                                "Justifica uso de controle de passo com exemplos numéricos.",
                                "Compara quantitativamente raios de estabilidade.",
                                "Explica trade-offs computacionais entre métodos.",
                                "Aplica conceitos em simulação prática de EDO."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos plots e cálculos de regiões de estabilidade (80% correto).",
                                "Profundidade na comparação qualitativa e quantitativa.",
                                "Correção na justificativa para controle de passo variável.",
                                "Uso adequado de exemplos numéricos e simulações.",
                                "Clareza na tabela comparativa e conclusões.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em equações diferenciais de osciladores amortecidos.",
                                "Computação: Implementação de solvers adaptativos em bibliotecas como SciPy.",
                                "Engenharia: Simulações em controle de sistemas dinâmicos rígidos.",
                                "Estatística: Modelagem estocástica onde estabilidade afeta precisão de Monte Carlo."
                              ],
                              "realWorldApplication": "Em modelagem climática ou simulações financeiras (ex.: Black-Scholes PDEs), métodos multistep com passo fixo falham em regimes rígidos, enquanto RK com controle de passo variável garante estabilidade e precisão em previsões de longo prazo, otimizando tempo de computação em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Problemas Stiff",
                "description": "Abordagens para equações diferenciais rígidas que demandam métodos com alta estabilidade.",
                "totalSkills": 58,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Definição de Problemas Stiff",
                    "description": "Conceito de equações diferenciais rígidas com componentes de decaimento rápido que exigem alta estabilidade em métodos numéricos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Conceito Básico de Problemas Stiff",
                        "description": "Definição formal de problemas stiff em equações diferenciais ordinárias (EDOs), caracterizados por escalas temporais muito diferentes entre componentes da solução.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Definir um problema stiff",
                            "description": "Explicar que um problema stiff é um sistema de EDOs onde a solução tem componentes que decaem rapidamente, exigindo passos de tempo muito pequenos em métodos explícitos para manter a estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Equações Diferenciais Ordinárias (EDOs)",
                                  "subSteps": [
                                    "Estude a forma geral de um sistema de EDOs: dy/dt = f(t, y).",
                                    "Revise soluções analíticas simples, como exponenciais decrescentes: y' = -λy.",
                                    "Identifique escalas de tempo em soluções: componentes com diferentes taxas de decaimento.",
                                    "Pratique plotando soluções com eigenvalues positivos e negativos grandes.",
                                    "Discuta o papel dos métodos numéricos quando soluções analíticas não são viáveis."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave de EDOs e envie para revisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo EDOs)",
                                    "Software como Python/MATLAB para plotar soluções"
                                  ],
                                  "tips": "Use gráficos para visualizar decaimentos rápidos vs lentos.",
                                  "learningObjective": "Compreender a estrutura básica de sistemas de EDOs e suas soluções.",
                                  "commonMistakes": "Confundir EDOs com EDP; ignorar dependência em t."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Estabilidade em Métodos Numéricos Explícitos",
                                  "subSteps": [
                                    "Implemente o método de Euler explícito para y' = -λy com λ grande.",
                                    "Teste com passos de tempo h variando e observe instabilidade (oscilações).",
                                    "Calcule o número de Lipschitz e região de estabilidade absoluta.",
                                    "Compare com λ pequeno: passos maiores são estáveis.",
                                    "Analise por que h deve ser << 1/λ para estabilidade."
                                  ],
                                  "verification": "Gere plots mostrando instabilidade para h inadequado e explique.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Comece com λ=100 para ver decaimento rápido claramente.",
                                  "learningObjective": "Identificar limitações de métodos explícitos em decaimentos rápidos.",
                                  "commonMistakes": "Usar h fixo sem testar estabilidade; confundir erro de truncagem com instabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Características de um Problema Stiff",
                                  "subSteps": [
                                    "Defina stiff: sistema onde max|Re(λ_i)| >> 1/h para estabilidade em explícitos.",
                                    "Descreva componentes: rápidos (λ grande negativo) e lentos (λ pequeno).",
                                    "Escreva formalmente: rigidez quando razão das escalas de tempo é alta.",
                                    "Diferencie de não-stiff: ausência de discrepância nas taxas.",
                                    "Exemplifique com y' = [-100y + z; y - z] (componentes desacoplados)."
                                  ],
                                  "verification": "Escreva definição própria e aplique a um exemplo dado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Notas de aula sobre stiff ODEs",
                                    "Referência: Hairer et al. 'Solving ODEs I'"
                                  ],
                                  "tips": "Lembre: stiff é sobre estabilidade numérica, não rigidez analítica.",
                                  "learningObjective": "Formular definição precisa de problema stiff.",
                                  "commonMistakes": "Confundir com não-linearidade; achar que só lineares são stiff."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Métodos Implícitos e Sintetizar",
                                  "subSteps": [
                                    "Implemente Euler implícito e compare estabilidade com explícito.",
                                    "Discuta por que implícitos permitem h maior em stiff problems.",
                                    "Identifique problema stiff clássico: reação química A -> B (rápida), B -> C (lenta).",
                                    "Crie fluxograma para diagnosticar se um problema é stiff.",
                                    "Resuma diferenças chave em um quadro comparativo."
                                  ],
                                  "verification": "Produza código e relatório comparando métodos em exemplo stiff.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python/MATLAB",
                                    "Exemplos de problemas stiff online"
                                  ],
                                  "tips": "Use solve_ivp no SciPy com method='BDF' para implícito.",
                                  "learningObjective": "Diferenciar tratamentos numéricos para stiff vs não-stiff.",
                                  "commonMistakes": "Ignorar custo computacional de implícitos; superestimar simplicidade."
                                }
                              ],
                              "practicalExample": "Considere o sistema y' = [-99y + 99z; -y + z + sin(t)], onde y decai rapidamente (λ≈-100) e z varia lentamente. Métodos explícitos falham com h=0.1 (oscilam), mas implícitos mantêm estabilidade.",
                              "finalVerifications": [
                                "Explique em palavras próprias o que é um problema stiff.",
                                "Identifique se y' = -100y + sin(t) é stiff e por quê.",
                                "Compare estabilidade de Euler explícito vs implícito em exemplo dado.",
                                "Descreva impacto de componentes rápidos/lentos.",
                                "Crie definição formal com notação matemática.",
                                "Diagnostique um novo sistema como stiff ou não."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (inclui estabilidade e escalas de tempo).",
                                "Uso correto de terminologia (Lipschitz, eigenvalues).",
                                "Exemplos relevantes e plots de suporte.",
                                "Diferenciação clara de não-stiff.",
                                "Análise de implicações numéricas.",
                                "Clareza e estrutura na explicação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de circuitos RLC com capacitores rápidos.",
                                "Química: Cinética de reações em série com taxas díspares.",
                                "Engenharia: Sistemas de controle com polos dominantes rápidos.",
                                "Computação: Algoritmos de integração numérica em simulações."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos, problemas stiff modelam reações rápidas de intermediários e lentas de produtos finais, exigindo solvers implícitos para eficiência em previsões industriais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Identificar rigidez qualitativa",
                            "description": "Reconhecer qualitativamente um problema stiff pela presença de autovalores do Jacobiano com partes reais grandes e negativas, levando a decaimento exponencial rápido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Problemas Stiff em EDOs",
                                  "subSteps": [
                                    "Revise o conceito de Equações Diferenciais Ordinárias (EDOs) e seus tipos: lineares vs. não-lineares.",
                                    "Estude escalas de tempo em sistemas dinâmicos, identificando componentes rápidos e lentos.",
                                    "Aprenda definições qualitativas de rigidez: discrepância nas taxas de variação das variáveis.",
                                    "Analise exemplos simples de EDOs não-stiff vs. stiff.",
                                    "Discuta implicações numéricas: por que métodos explícitos falham em problemas stiff."
                                  ],
                                  "verification": "Explique em suas palavras o que torna um problema stiff e dê um exemplo não-stiff.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Numérica (capítulo de EDOs), vídeo introdutório sobre stiff ODEs (Khan Academy ou YouTube).",
                                  "tips": "Use analogias como tráfego: carros rápidos (componentes lentos) e freadas bruscas (rápidos).",
                                  "learningObjective": "Reconhecer as características qualitativas de problemas stiff baseadas em escalas temporais.",
                                  "commonMistakes": "Confundir rigidez com não-linearidade; assumir que todos os sistemas lineares são não-stiff."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Jacobiano em Sistemas de EDOs Não-Lineares",
                                  "subSteps": [
                                    "Defina o Jacobiano como a matriz das derivadas parciais da função vetorial f em um sistema y' = f(y).",
                                    "Calcule o Jacobiano para um sistema simples de 2 EDOs não-lineares.",
                                    "Discuta a linearização local ao redor de um ponto de equilíbrio usando o Jacobiano.",
                                    "Relacione o Jacobiano à análise de estabilidade linearizada.",
                                    "Pratique computação simbólica do Jacobiano com ferramentas como SymPy ou MATLAB."
                                  ],
                                  "verification": "Compute o Jacobiano de um sistema dado e verifique com software.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software simbólico (SymPy, Mathematica), exemplos de EDOs não-lineares impressos.",
                                  "tips": "Lembre-se: Jacobiano em equilíbrio é como a matriz A em y' = Ay linear.",
                                  "learningObjective": "Calcular e interpretar o Jacobiano como aproximação linear local.",
                                  "commonMistakes": "Esquecer de avaliar no ponto de interesse; confundir com Hessiano (segunda derivada)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Autovalores do Jacobiano",
                                  "subSteps": [
                                    "Revise autovalores e autovetores: solução de det(J - λI) = 0.",
                                    "Calcule autovalores para Jacobianos de exemplos stiff e não-stiff.",
                                    "Interprete partes reais: Re(λ) < 0 indica estabilidade; |Re(λ)| grande indica decaimento rápido.",
                                    "Identifique rigidez: espectro de autovalores com Re(λ) muito negativos vs. próximos de zero.",
                                    "Visualize com gráficos de autovalores no plano complexo."
                                  ],
                                  "verification": "Para um Jacobiano dado, liste autovalores e classifique como stiff ou não.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Calculadora matricial ou Python (NumPy para eigvals), planilha de exemplos.",
                                  "tips": "Ordene autovalores por magnitude de Re(λ): rigidez se max|Re(λ)| / min|Re(λ)| >> 1.",
                                  "learningObjective": "Extrair e analisar autovalores para prever comportamento dinâmico.",
                                  "commonMistakes": "Ignorar parte imaginária (oscilações); calcular autovalores errados por erro numérico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer Rigidez Qualitativa em Problemas",
                                  "subSteps": [
                                    "Aplique critérios: rigidez se há autovalores com Re(λ) << -1 e outros ~0.",
                                    "Teste em exemplos reais: reator químico, modelo Lotka-Volterra com parasitas.",
                                    "Simule numericamente com método explícito (Euler) para observar instabilidade em stiff.",
                                    "Compare com autovalores: confirme decaimento exponencial rápido e'^{λt} com λ grande negativo.",
                                    "Pratique identificação sem cálculo completo, só qualitativa."
                                  ],
                                  "verification": "Classifique 3 problemas como stiff ou não-stiff justificando com autovalores qualitativos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python/MATLAB para simulações, banco de problemas stiff.",
                                  "tips": "Pense em 'stiffness ratio' = |λ_max| / |λ_min| > 1000 tipicamente.",
                                  "learningObjective": "Identificar rigidez qualitativamente pela análise espectral do Jacobiano.",
                                  "commonMistakes": "Superestimar rigidez em sistemas oscilatórios; ignorar contexto não-linear."
                                }
                              ],
                              "practicalExample": "Considere o sistema químico de reação A -> B -> C com taxas k1=1, k2=1000. O Jacobiano no equilíbrio tem autovalores ≈ -1 e -1000. Parte real grande negativa (-1000) causa decaimento exponencial rápido de intermediários, tornando-o stiff: métodos explícitos exigem passos minúsculos dt<0.001.",
                              "finalVerifications": [
                                "Explica corretamente o papel dos autovalores do Jacobiano na rigidez.",
                                "Identifica rigidez em um exemplo novo sem cálculo numérico completo.",
                                "Descreve o decaimento exponencial rápido associado a Re(λ) grandes negativos.",
                                "Distingue stiff de não-stiff em simulações numéricas.",
                                "Justifica por que problemas stiff requerem métodos implícitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e cálculo do Jacobiano (30%).",
                                "Correta análise qualitativa de autovalores e rigidez (30%).",
                                "Capacidade de aplicação em exemplos concretos (20%).",
                                "Clareza na explicação do decaimento exponencial (10%).",
                                "Identificação de erros comuns e evitações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em sistemas dinâmicos (e.g., circuitos RLC stiff).",
                                "Química: Cinética de reações com escalas rápidas/lentas.",
                                "Engenharia: Controle de sistemas com atuadores rápidos e plantas lentas.",
                                "Computação: Algoritmos numéricos para solvers de EDOs (ODEPACK)."
                              ],
                              "realWorldApplication": "Em simulações de engenharia química, identificar rigidez qualitativa permite escolher solvers implícitos como BDF, otimizando simulações de reatores onde reações rápidas (combustão) e lentas (difusão) coexistem, evitando crashes numéricos e economizando tempo computacional."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Diferenciar stiff de não-stiff",
                            "description": "Comparar problemas stiff com não-stiff, destacando que em não-stiff os passos de tempo são determinados pela precisão, enquanto em stiff pela estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Problemas Não-Stiff",
                                  "subSteps": [
                                    "Revise a definição de EDOs não-stiff: problemas onde os autovalores têm partes reais negativas moderadas.",
                                    "Estude como o h (passo de tempo) é escolhido baseado na precisão: h ≈ ε / L, onde ε é tolerância e L é Lipschitz.",
                                    "Analise exemplos simples como y' = -y, resolvido com Euler explícito estável para h razoáveis.",
                                    "Simule numericamente um problema não-stiff e observe convergência com h variando.",
                                    "Registre observações sobre estabilidade e precisão."
                                  ],
                                  "verification": "Capacidade de simular um problema não-stiff com diferentes h e plotar erro vs. h, mostrando que precisão domina.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), Python com NumPy/SciPy/Matplotlib, notebook Jupyter.",
                                  "tips": "Comece com λ pequeno (ex: -1) para ver comportamento suave.",
                                  "learningObjective": "Identificar características de EDOs não-stiff e como h é determinado por precisão.",
                                  "commonMistakes": "Confundir estabilidade com precisão; assumir que todos os problemas são não-stiff."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Problemas Stiff",
                                  "subSteps": [
                                    "Defina problemas stiff: EDOs com escalas de tempo muito diferentes (autovalores com partes reais muito negativas).",
                                    "Explique que métodos explícitos requerem h < 2/|λ_max| para estabilidade.",
                                    "Examine exemplo stiff: y' = -1000y, onde Euler explícito falha para h > 0.002.",
                                    "Simule com h inadequado e observe oscilações ou divergência.",
                                    "Compare com solução exata e veja necessidade de h minúsculo."
                                  ],
                                  "verification": "Simulação de problema stiff com Euler explícito mostrando instabilidade para h moderado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo que Step 1, mais código para stiff ODE como scipy.integrate.odeint.",
                                  "tips": "Use λ = -1000 para stiff claro; teste h = 0.01 vs. 0.001.",
                                  "learningObjective": "Reconhecer rigidez por exigência de h pequeno para estabilidade.",
                                  "commonMistakes": "Escolher h baseado só em precisão, ignorando estabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Stiff vs. Não-Stiff",
                                  "subSteps": [
                                    "Crie tabela comparativa: critério de h (precisão vs. estabilidade), autovalores, métodos adequados.",
                                    "Resolva mesmo problema com λ variando de -1 a -1000 e compare comportamentos.",
                                    "Discuta razão: em stiff, componente rápida decai rápido, requer h pequeno para não oscilar.",
                                    "Teste com método implícito (ex: Backward Euler) em stiff para ver h maior possível.",
                                    "Documente diferenças chave em relatório curto."
                                  ],
                                  "verification": "Tabela ou gráfico mostrando h ótimo vs. λ para ambos tipos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo que anterior, adicionar implementação de Backward Euler.",
                                  "tips": "Plote regiões de estabilidade no plano complexo para visualização.",
                                  "learningObjective": "Diferenciar explicitamente como h é determinado em cada caso.",
                                  "commonMistakes": "Ignorar que stiff pode ser preciso com h pequeno, mas computacionalmente caro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Testar Diferenciação",
                                  "subSteps": [
                                    "Pegue EDO desconhecida (ex: y' = -50y + sin(t)) e classifique como stiff/não-stiff testando estabilidade.",
                                    "Meça razão de decaimento vs. precisão para decidir.",
                                    "Resolva com explícito/implícito e compare eficiência.",
                                    "Crie fluxograma para diferenciar problemas futuros.",
                                    "Avalie com problema real de literatura."
                                  ],
                                  "verification": "Classificação correta de 3 EDOs teste com justificativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplos de livros, SciPy solve_ivp com métodos diferentes.",
                                  "tips": "Use |Re(λ)| > 100 como heurística inicial para stiff.",
                                  "learningObjective": "Aplicar diferenciação prática em novos problemas.",
                                  "commonMistakes": "Classificar baseado só em autovalores sem testar numericamente."
                                }
                              ],
                              "practicalExample": "Considere y' = λy, y(0)=1. Para λ=-1 (não-stiff): Euler explícito com h=0.1 converge bem (erro ~0.01). Para λ=-1000 (stiff): h=0.1 diverge; precisa h=0.001 para estabilidade, mesmo com precisão alta.",
                              "finalVerifications": [
                                "Explicar verbalmente diferença em determinação de h.",
                                "Classificar corretamente 3 EDOs como stiff/não-stiff.",
                                "Simular stiff com explícito falhando e implícito sucedendo.",
                                "Plotar erro vs. h para ambos tipos.",
                                "Identificar stiff em exemplo real (ex: reação química)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de stiff (escalas múltiplas).",
                                "Correta ênfase em estabilidade vs. precisão para h.",
                                "Exemplos numéricos válidos com simulações.",
                                "Tabela comparativa clara e completa.",
                                "Aplicação correta em problema novo.",
                                "Ausência de confusões comuns (ex: stiff sempre preciso)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de difusão/reação com escalas rápidas/lentas.",
                                "Engenharia: Simulações de circuitos RLC stiff.",
                                "Computação: Otimização de solvers numéricos (SciPy, MATLAB ode45).",
                                "Química: Cinética de reações com componentes rápidas."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular ou circuitos elétricos, diferenciar stiff evita crashes em solvers explícitos, permitindo uso de métodos implícitos como BDF para eficiência em modelagem de baterias ou epidemias com compartimentos rápidos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Componentes de Decaimento Rápido",
                        "description": "Análise das componentes da solução que decaem rapidamente em problemas stiff, responsáveis pela rigidez.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Explicar decaimento rápido",
                            "description": "Descrever como componentes com autovalores λ com Re(λ) << 0 causam decaimento exponencial e^λt, tornando o problema rígido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender autovalores em sistemas de EDOs lineares",
                                  "subSteps": [
                                    "Revise a forma matricial de EDOs lineares: y' = A y.",
                                    "Explique que as soluções gerais envolvem e^{λ t} v, onde λ são autovalores e v autovetores de A.",
                                    "Classifique autovalores pela parte real: Re(λ) > 0 (crescimento), Re(λ) = 0 (oscilação), Re(λ) < 0 (decaimento).",
                                    "Discuta magnitudes: |Re(λ)| pequeno vs. grande.",
                                    "Pratique decompondo uma matriz 2x2 simples em autovalores."
                                  ],
                                  "verification": "Resolva y' = [[-1,0],[0,-100]] y e identifique autovalores corretamente.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Folha de derivadas matriciais",
                                    "Exemplos de matrizes companion"
                                  ],
                                  "tips": "Sempre verifique se a matriz é diagonalizável antes de prosseguir.",
                                  "learningObjective": "Identificar e interpretar autovalores em contextos de estabilidade de EDOs.",
                                  "commonMistakes": [
                                    "Confundir autovalores com autovetores",
                                    "Ignorar a parte imaginária em autovalores complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar decaimento exponencial para Re(λ) << 0",
                                  "subSteps": [
                                    "Derive a solução componente: y_i(t) ≈ c e^{λ t} com Re(λ) << 0.",
                                    "Plote e^{λ t} para λ = -10, -100, -1000 em t de 0 a 0.1.",
                                    "Explique que para t pequeno, e^{λ t} ≈ 1 + λ t, mas decai abruptamente logo após.",
                                    "Compare escalas de tempo: τ = 1/|Re(λ)| é o tempo de decaimento.",
                                    "Calcule numericamente e^{ -1000 * 0.001 } vs. e^{ -1 * 0.001 }."
                                  ],
                                  "verification": "Desenhe gráficos mostrando decaimento rápido para |λ| grande e confirme τ pequeno.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Software de plotagem (Python/MATLAB)",
                                    "Tabela de valores exponenciais",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Use logaritmo para visualizar decaimentos extremos: log(|e^{λ t}|) = Re(λ) t.",
                                  "learningObjective": "Quantificar o decaimento exponencial e sua dependência em |Re(λ)|.",
                                  "commonMistakes": [
                                    "Achar que decaimento rápido significa solução zero imediata",
                                    "Esquecer que t deve ser pequeno para observação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar rigidez causada por componentes de decaimento rápido",
                                  "subSteps": [
                                    "Defina rigidez: razão entre escalas de tempo lenta e rápida > 1000.",
                                    "Discuta métodos explícitos (ex: Euler): h < 2/|λ_max| para estabilidade.",
                                    "Mostre que h pequeno para componente rápida força h pequeno para toda simulação.",
                                    "Compare com métodos implícitos que permitem h maior.",
                                    "Simule um problema stiff simples e observe instabilidade em Euler explícito."
                                  ],
                                  "verification": "Execute simulação com h inadequado e observe oscilações ou divergência.",
                                  "estimatedTime": "75 min",
                                  "materials": [
                                    "Código Python para Euler explícito/implícito",
                                    "Exemplo stiff: y' = -1000(y-1) + sin(t)",
                                    "Gráficos de estabilidade"
                                  ],
                                  "tips": "Regra prática: se max|λ| / min|λ| > 10^3, problema é stiff.",
                                  "learningObjective": "Relacionar decaimento rápido com restrições numéricas em solvers.",
                                  "commonMistakes": [
                                    "Confundir rigidez com não-linearidade",
                                    "Usar h fixo sem analisar espectro de A"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e ilustrar com exemplo completo",
                                  "subSteps": [
                                    "Monte matriz A = diag(-1, -1000) e resolva analiticamente.",
                                    "Simule numericamente com Euler explícito (h=0.01) e implícito.",
                                    "Explique por que explícito falha para h>0.002 mas implícito succeeds.",
                                    "Generalize para sistemas reais com modos rápidos e lentos.",
                                    "Escreva um parágrafo explicando o conceito."
                                  ],
                                  "verification": "Produza relatório com gráficos e conclusão sobre rigidez.",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "Notebook Jupyter",
                                    "Biblioteca SciPy para solve_ivp",
                                    "Template de relatório"
                                  ],
                                  "tips": "Sempre normalize soluções para comparar comportamentos.",
                                  "learningObjective": "Integrar conceitos em uma explicação coerente de decaimento rápido e rigidez.",
                                  "commonMistakes": [
                                    "Ignorar componente lenta no exemplo",
                                    "Não comparar métodos explícito vs. implícito"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere y' = [[-1, 0], [0, -1000]] y, y(0)=[1,1]. A componente lenta decai com τ=1, a rápida com τ=0.001. Euler explícito requer h<0.002 para estabilidade, forçando 500 passos para t=1, enquanto implícito permite h=0.1.",
                              "finalVerifications": [
                                "Deriva corretamente e^{λ t} para autovalor λ com Re(λ)<<0.",
                                "Calcula tempo de decaimento τ=1/|Re(λ)| e identifica rigidez.",
                                "Simula exemplo stiff e demonstra falha de método explícito.",
                                "Explica verbalmente por que decaimento rápido causa rigidez.",
                                "Compara escalas em gráfico logarítmico.",
                                "Gera solução analítica e numérica coincidente para h adequado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de soluções exponenciais (90% correto).",
                                "Identificação correta de autovalores e suas implicações (completa).",
                                "Demonstração prática via simulação sem erros de implementação.",
                                "Explicação clara de rigidez com quantificação (razão de escalas).",
                                "Uso adequado de gráficos e visualizações.",
                                "Síntese em parágrafo coeso e sem jargões desnecessários."
                              ],
                              "crossCurricularConnections": [
                                "Física: Decaimento radioativo ou amortecimento em osciladores.",
                                "Química: Cinética de reações com intermediários rápidos.",
                                "Engenharia: Modelos de circuitos RLC com constantes de tempo díspares.",
                                "Computação: Algoritmos de integração numérica em simulações.",
                                "Biologia: Dinâmica populacional com mortalidade alta em predadores."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos, componentes com resistores altos causam decaimento rápido de correntes transitórias, exigindo solvers implícitos como Backward Euler para eficiência computacional em CAD tools como SPICE."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Relacionar com o Jacobiano",
                            "description": "Associar a rigidez ao espectro do Jacobiano da função f em y' = f(y), onde a razão entre o maior e menor |Re(λ)| define o índice de rigidez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Jacobiano de uma função vetorial f em y' = f(y)",
                                  "subSteps": [
                                    "Defina y como um vetor em R^n e f: R^n → R^n como função diferenciável.",
                                    "Escreva a matriz Jacobiana J(y) = ∂f_i/∂y_j para i,j=1 a n.",
                                    "Explique que o Jacobiano lineariza o sistema não-linear ao redor de um ponto y.",
                                    "Discuta como o Jacobiano captura o comportamento local da dinâmica.",
                                    "Identifique pontos de equilíbrio onde f(y*)=0 e analise J(y*)"
                                  ],
                                  "verification": "Escreva a matriz Jacobiana para um sistema simples de 2 equações e verifique se ela está correta comparando com a definição.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), calculadora simbólica (SymPy ou Mathematica), caderno para derivações.",
                                  "tips": "Comece com sistemas lineares onde J é constante para intuitar.",
                                  "learningObjective": "Compreender o papel do Jacobiano na linearização de EDOs não-lineares.",
                                  "commonMistakes": "Confundir Jacobiano com Hessiana; esquecer que é avaliado em pontos específicos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o espectro de autovalores do Jacobiano",
                                  "subSteps": [
                                    "Calcule os autovalores λ do Jacobiano J(y) resolvendo det(J - λI)=0.",
                                    "Identifique as partes real e imaginária: Re(λ) e Im(λ).",
                                    "Classifique autovalores: negativos (decaimento), positivos (crescimento), complexos (oscilações).",
                                    "Plote os autovalores no plano complexo para visualizar o espectro.",
                                    "Discuta a estabilidade: todos Re(λ) < 0 implicam estabilidade assintótica local."
                                  ],
                                  "verification": "Para uma matriz Jacobiana 2x2 dada, liste autovalores e suas partes reais; confirme com software.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de álgebra linear (MATLAB, Python NumPy/SciPy), exemplos de Jacobianos de problemas stiff.",
                                  "tips": "Use decomposição em valores singulares se n grande para aproximação.",
                                  "learningObjective": "Dominar o cálculo e interpretação do espectro de autovalores do Jacobiano.",
                                  "commonMistakes": "Ignorar autovalores complexos; confundir módulo |λ| com |Re(λ)|."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e calcular o índice de rigidez usando o espectro",
                                  "subSteps": [
                                    "Defina o índice de rigidez μ = max|Re(λ)| / min|Re(λ)| onde λ no espectro de J, assumindo Re(λ)<0.",
                                    "Identifique componentes de decaimento rápido (λ com |Re(λ)| grande) e lento (pequeno).",
                                    "Explique que μ >>1 indica problema stiff devido a escalas temporais díspares.",
                                    "Calcule μ para um Jacobiano exemplo com autovalores conhecidos.",
                                    "Relacione μ com o passo de tempo necessário em métodos numéricos explícitos."
                                  ],
                                  "verification": "Compute μ para um espectro dado (ex: Re(λ) = -1, -1000) e explique implicações para rigidez.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha ou script Python para autovalores, artigos sobre stiff ODEs.",
                                  "tips": "Considere o Jacobiano congelado (constante) para simplificação inicial.",
                                  "learningObjective": "Associar rigidez quantitativamente ao espectro do Jacobiano.",
                                  "commonMistakes": "Usar |λ| total em vez de |Re(λ)|; inverter max/min no índice."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conceito em um exemplo stiff e verificar",
                                  "subSteps": [
                                    "Escolha um sistema stiff clássico, como y' = -1000y + z, z' = y - z.",
                                    "Compute J e seus autovalores em equilíbrio.",
                                    "Calcule μ e classifique como stiff se μ > 100.",
                                    "Simule numericamente com método explícito vs implícito para observar.",
                                    "Conclua relacionando rigidez ao espectro."
                                  ],
                                  "verification": "Gere gráfico de solução numérica mostrando instabilidade em explícito devido a rigidez.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python (SciPy odeint/solve_ivp), Jupyter Notebook, exemplos de código para stiff problems.",
                                  "tips": "Use λ = -1 e -1000 para μ=1000, típico de stiff.",
                                  "learningObjective": "Aplicar o conceito de rigidez via Jacobiano em prática.",
                                  "commonMistakes": "Escolher sistema não-stiff; ignorar dependência não-linear do J."
                                }
                              ],
                              "practicalExample": "Considere o sistema químico de decaimento: y' = -λ1 y + k z, z' = λ1 y - k z com λ1=1000, k=1. O Jacobiano em equilíbrio tem autovalores ≈ -1000 e -1, μ=1000, indicando rigidez devido a reação rápida (λ1) e lenta (k).",
                              "finalVerifications": [
                                "Pode derivar corretamente o Jacobiano de um sistema dado?",
                                "Calcula autovalores e identifica max/min |Re(λ)|?",
                                "Computa índice de rigidez μ e classifica corretamente?",
                                "Explica verbalmente a relação entre espectro e rigidez?",
                                "Aplica em exemplo numérico e observa efeitos em solvers?",
                                "Distingue rigidez de instabilidade?"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo do Jacobiano (100% correto).",
                                "Correta identificação de autovalores e partes reais.",
                                "Cálculo exato de μ com justificativa.",
                                "Interpretação qualitativa e quantitativa da rigidez.",
                                "Uso apropriado de exemplos e simulações.",
                                "Clareza na conexão com métodos numéricos stiff."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RC com constantes de tempo díspares.",
                                "Química: Cinética de reações com escalas rápidas/lentas.",
                                "Engenharia: Controle de sistemas dinâmicos com modos rápidos/lentos.",
                                "Computação: Otimização de solvers ODE em SciPy/MATLAB."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas (ex: combustão), onde espécies intermediárias decaem rapidamente (Re(λ) grande negativo), enquanto produtos finais evoluem lentamente, exigindo métodos implícitos como BDF para eficiência computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Exemplo clássico de decaimento",
                            "description": "Analisar o exemplo y' = -λy com λ grande, mostrando como a solução decai rapidamente após um curto intervalo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar a solução analítica da equação diferencial",
                                  "subSteps": [
                                    "Escreva a equação diferencial y' = -λy com condição inicial y(0) = 1.",
                                    "Separe variáveis: dy/y = -λ dt.",
                                    "Integre ambos os lados: ∫(1/y) dy = -λ ∫ dt.",
                                    "Resolva para y(t): y(t) = y(0) e^{-λt} = e^{-λt}.",
                                    "Verifique a solução substituindo de volta na EDO."
                                  ],
                                  "verification": "A solução derivada satisfaz y' = -λy e y(0)=1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software como Mathematica/MATLAB para verificação",
                                    "Calculadora para integrais básicas"
                                  ],
                                  "tips": "Lembre-se de que a constante de integração é determinada pela condição inicial.",
                                  "learningObjective": "Compreender a solução exata de uma EDO linear de primeira ordem simples.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo na integração",
                                    "Não aplicar corretamente a condição inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o comportamento da solução para λ grande",
                                  "subSteps": [
                                    "Escolha um valor grande para λ, como λ=100.",
                                    "Plote ou calcule y(t) para t de 0 a 0.1.",
                                    "Observe que y(t) ≈ 1 para t<<1/λ, mas decai para ≈0 quando t>1/λ.",
                                    "Calcule o tempo de decaimento: t_half ≈ ln(2)/λ ≈ 0.00693 para λ=100.",
                                    "Descreva verbalmente: 'Decaimento rápido após intervalo curto ~1/λ'."
                                  ],
                                  "verification": "Gráfico ou tabela mostra decaimento de y(0.01)≈0.37 para λ=100, quase 0 em t=0.05.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem como Desmos, Python (matplotlib) ou Excel"
                                  ],
                                  "tips": "Use escala logarítmica no eixo y para visualizar melhor o decaimento exponencial.",
                                  "learningObjective": "Identificar o regime transitório rápido e o decaimento subsequente.",
                                  "commonMistakes": [
                                    "Confundir λ grande com decaimento lento",
                                    "Ignorar o papel de 1/λ como escala temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar numericamente a rigidez com método explícito",
                                  "subSteps": [
                                    "Implemente o método de Euler explícito: y_{n+1} = y_n + h (-λ y_n).",
                                    "Teste com h=0.01 e λ=100; observe oscilações ou instabilidade.",
                                    "Reduza h para h=0.001 até estabilizar, notando passos minúsculos necessários.",
                                    "Compare com solução exata em pontos chave.",
                                    "Explique: fator de amplificação |1 - λh| >1 leva a instabilidade se λh>2."
                                  ],
                                  "verification": "Solução numérica coincide com exata apenas para h<<1/λ; senão diverge.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB para simulação numérica"
                                  ],
                                  "tips": "Comece com λh=2 para ver instabilidade clara, depois ajuste.",
                                  "learningObjective": "Reconhecer por que problemas stiff exigem h pequeno em métodos explícitos.",
                                  "commonMistakes": [
                                    "Escolher h fixo grande sem testar estabilidade",
                                    "Não comparar com solução exata"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com método implícito e concluir sobre problemas stiff",
                                  "subSteps": [
                                    "Implemente Euler implícito: y_{n+1} = y_n / (1 + λh).",
                                    "Use mesmo h=0.01 com λ=100; observe estabilidade incondicional.",
                                    "Compare precisão e eficiência com explícito.",
                                    "Defina problema stiff: escalas temporais muito diferentes (rápida e lenta).",
                                    "Conclua: exemplo ilustra componente de decaimento rápido em stiff problems."
                                  ],
                                  "verification": "Método implícito permanece estável e preciso para h razoável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo software do passo 3, com código para Euler implícito"
                                  ],
                                  "tips": "Resolva equação implícita linear explicitamente para este caso simples.",
                                  "learningObjective": "Entender a necessidade de métodos implícitos para stiff ODEs.",
                                  "commonMistakes": [
                                    "Confundir estabilidade explícita/implícita",
                                    "Não quantificar 'rigidez' via Lipschitz constante λ"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere λ=1000 modelando um capacitor descarregando rapidamente em um circuito RC. A tensão y(t) cai de 1V para <0.01V em milissegundos, exigindo passos numéricos <10^{-4}s em Euler explícito para precisão.",
                              "finalVerifications": [
                                "Deriva corretamente y(t)=e^{-λt}.",
                                "Identifica escala temporal 1/λ como intervalo de decaimento rápido.",
                                "Demonstra instabilidade numérica com Euler explícito para λh>2.",
                                "Mostra estabilidade com Euler implícito.",
                                "Explica verbalmente por que é um exemplo clássico de stiff problem.",
                                "Compara solução numérica com exata em gráfico."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução analítica (100% correta).",
                                "Correta identificação do comportamento assintótico (decaimento rápido).",
                                "Análise qualitativa/quantitativa da rigidez (estabilidade vs. h).",
                                "Uso adequado de ferramentas numéricas sem erros de implementação.",
                                "Clareza na explicação do 'curto intervalo' de decaimento.",
                                "Conexão explícita com definição de problemas stiff."
                              ],
                              "crossCurricularConnections": [
                                "Física: Decaimento radioativo (λ=constante de decaimento).",
                                "Química: Cinética de reações rápidas de primeira ordem.",
                                "Engenharia: Modelagem de circuitos RC/RL com constantes de tempo pequenas.",
                                "Computação Científica: Algoritmos numéricos para ODEs stiff (ex: ode15s no MATLAB)."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos, onde espécies intermediárias decaem rapidamente (λ grande), métodos explícitos falham sem passos minúsculos, desperdiçando tempo computacional; implícitos permitem simulações eficientes de processos industriais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Exigência de Estabilidade Numérica",
                        "description": "Necessidade de métodos numéricos com alta estabilidade para resolver problemas stiff sem passos de tempo excessivamente pequenos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Entender falha de métodos explícitos",
                            "description": "Explicar por que métodos de passo simples explícitos, como Euler forward, requerem h < 2/|λ_max| para estabilidade em problemas stiff, limitando a eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Método de Euler Forward e Condições de Estabilidade Básicas",
                                  "subSteps": [
                                    "Implemente o método de Euler forward para a EDO y' = λy, com solução y(t) = y0 e^{λt}.",
                                    "Calcule a iteração: y_{n+1} = y_n + h λ y_n = (1 + hλ) y_n.",
                                    "Analise a condição de estabilidade: |1 + hλ| ≤ 1 para convergência.",
                                    "Plote a região de estabilidade no plano hλ (círculo unitário à esquerda).",
                                    "Teste com λ negativo pequeno (não-stiff) para verificar estabilidade com h razoável."
                                  ],
                                  "verification": "Confirme que para λ = -1, h=1.5 produz |1 + hλ| = 0.5 <1 (estável) e simulação converge para 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis ou software como Python/MATLAB para plotar região de estabilidade.",
                                  "tips": "Sempre normalize hλ para visualizar a região de estabilidade independentemente de unidades.",
                                  "learningObjective": "Compreender a amplificação local de erro no método explícito de Euler.",
                                  "commonMistakes": "Confundir estabilidade com precisão; estabilidade é necessária mas não suficiente para acurácia."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Problemas Stiff e o Papel de Autovalores Extremos",
                                  "subSteps": [
                                    "Defina problemas stiff: EDOs lineares y' = Ay com autovalores λ_i onde max|Re(λ_i)| >> min|Re(λ_i)|.",
                                    "Identifique λ_max como o autovalor com maior |Re(λ)| negativo em sistemas lineares.",
                                    "Exemplo: y' = [-1 0; 0 -1000] y, onde λ_max = -1000.",
                                    "Explique escalas de tempo: componente lenta (λ=-1) vs. rápida (λ=-1000).",
                                    "Calcule o passo h típico para componente não-stiff: h ~ 0.1."
                                  ],
                                  "verification": "Liste autovalores de uma matriz stiff exemplo e identifique λ_max corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou Python (numpy.linalg.eig) para autovalores.",
                                  "tips": "Pense em stiff como 'rigidez' física: precisa de passos minúsculos para não oscilar.",
                                  "learningObjective": "Reconhecer características espectrais que definem problemas stiff.",
                                  "commonMistakes": "Ignorar autovalores complexos; foque em Re(λ) para estabilidade absoluta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Condição de Estabilidade para Métodos Explícitos em Stiff Problems",
                                  "subSteps": [
                                    "Para Euler: estabilidade requer |1 + hλ| ≤ 1 para todos λ, especialmente λ_max.",
                                    "Para λ real negativo, h < 2 / |λ_max| (limite do círculo unitário).",
                                    "Exemplo: λ_max = -1000, h < 0.002; compare com h não-stiff ~0.1.",
                                    "Simule com h = 0.003 > 0.002: observe oscilações e divergência.",
                                    "Generalize para Runge-Kutta explícitos: regiões de estabilidade finitas semelhantes."
                                  ],
                                  "verification": "Calcule h_max = 2/|λ_max| para λ_max=-1000 e simule mostrando instabilidade se violado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python ou MATLAB para simulações numéricas de EDO stiff simples.",
                                  "tips": "Use log-plot para y(t) para visualizar oscilações claramente.",
                                  "learningObjective": "Derivar quantitativamente o gargalo de timestep em métodos explícitos.",
                                  "commonMistakes": "Esquecer o fator 2; é h < 2/|λ| exatamente para Euler."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implicações para Eficiência Computacional",
                                  "subSteps": [
                                    "Calcule número de passos: para t_final=1, N = t_final / h > 1 / (2/|λ_max|) = |λ_max|/2.",
                                    "Compare custo: stiff com λ_max=1000 precisa ~500x mais passos que não-stiff.",
                                    "Discuta trade-off: precisão vs. custo; explícitos ineficientes para stiff.",
                                    "Introduza motivação para implícitos: regiões de estabilidade ilimitadas.",
                                    "Quantifique: tempo de CPU proporcional a N."
                                  ],
                                  "verification": "Compare tempo de simulação ou N_steps para h stiff vs. não-stiff no mesmo problema.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código de simulação com timer (timeit em Python).",
                                  "tips": "Fixe tolerância de erro e mostre que explícitos ainda precisam h pequeno.",
                                  "learningObjective": "Quantificar por que explícitos são impraticáveis em stiff problems.",
                                  "commonMistakes": "Confundir lentidão com precisão ruim; é puramente estabilidade."
                                }
                              ],
                              "practicalExample": "Considere y' = -1000(y - sin(t)) + cos(t), stiff com λ_max≈-1000. Use Euler com h=0.001 (estável): converge devagar (~1000 passos). Com h=0.01: oscila e diverge imediatamente, demonstrando falha explícita.",
                              "finalVerifications": [
                                "Explicar verbalmente a condição h < 2/|λ_max| com diagrama de região de estabilidade.",
                                "Simular Euler em problema stiff com h violando condição e mostrar instabilidade.",
                                "Calcular h_max para dado λ_max e justificar ineficiência (N_steps grande).",
                                "Comparar estabilidade de Euler vs. Backward Euler no mesmo exemplo.",
                                "Identificar λ_max em matriz 2x2 stiff fornecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da condição h < 2/|λ_max| (correta fórmula e justificativa).",
                                "Demonstração numérica clara de falha (gráficos com oscilação/divergência).",
                                "Compreensão quantitativa de custo computacional (cálculo de N_steps).",
                                "Uso correto de terminologia (stiff, autovalores, região de estabilidade).",
                                "Identificação precisa de λ_max em exemplos lineares.",
                                "Explicação clara de implicações para escolha de métodos numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de reações químicas stiff (equações de Lotka-Volterra com decaimento rápido).",
                                "Engenharia Química: Simulação de reatores com escalas múltiplas (difusão vs. reação).",
                                "Ciência da Computação: Otimização de algoritmos numéricos em HPC.",
                                "Matemática Aplicada: Análise assintótica de autovalores em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular ou circuitos elétricos RC stiff, métodos explícitos como Euler falham sem h microscópico, desperdiçando CPU; leva à adoção de solvers implícitos como em software COMSOL ou MATLAB ode15s para eficiência em engenharia e pesquisa científica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Introduzir necessidade de métodos implícitos",
                            "description": "Reconhecer que métodos implícitos ou de passo múltiplo oferecem regiões de estabilidade maiores, adequadas para capturar decaimento rápido sem restrições severas em h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar limitações de métodos explícitos em problemas stiff",
                                  "subSteps": [
                                    "Defina problemas stiff como EDOs com escalas de tempo díspares, exigindo h pequeno para estabilidade.",
                                    "Analise o método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Teste com exemplo y' = -λy (λ grande, ex: λ=1000), observe oscilações ou instabilidade para h > 2/λ.",
                                    "Discuta custo computacional: passos pequenos aumentam tempo de simulação.",
                                    "Registre que métodos explícitos têm região de estabilidade limitada no plano complexo hλ."
                                  ],
                                  "verification": "O aluno explica corretamente por que h deve ser pequeno em Euler explícito para λ grande, com gráfico de solução numérica instável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Caderno, calculadora, software como Python/MATLAB para plotar soluções.",
                                  "tips": "Comece com λ pequeno e aumente gradualmente para visualizar o colapso.",
                                  "learningObjective": "Identificar restrições de estabilidade em métodos explícitos para EDOs stiff.",
                                  "commonMistakes": "Confundir precisão com estabilidade; achar que erro de truncamento causa instabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de região de estabilidade",
                                  "subSteps": [
                                    "Explique estabilidade A-estável: solução numérica imita comportamento qualitativo da exata.",
                                    "Descreva região de estabilidade como conjunto {z ∈ ℂ | |R(z)| ≤ 1}, onde R(z) é função de amplificação, z = hλ.",
                                    "Plote região para Euler explícito: disco |z| ≤ 1 no semiplano esquerdo.",
                                    "Compare com Runge-Kutta explícitos: regiões maiores mas ainda limitadas.",
                                    "Discuta necessidade de regiões que incluam todo semiplano esquerdo para stiff."
                                  ],
                                  "verification": "O aluno desenha e descreve a região de estabilidade do Euler explícito corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel milimetrado ou software de plotagem (Desmos/Geogebra), tabela de funções R(z).",
                                  "tips": "Use z = hλ com Re(z) < 0 para rigidez; foque no semiplano esquerdo.",
                                  "learningObjective": "Compreender região de estabilidade e sua relação com problemas stiff.",
                                  "commonMistakes": "Ignorar parte imaginária de λ; confundir com ordem do método."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar métodos implícitos e multistep",
                                  "subSteps": [
                                    "Apresente Euler implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}), resolve equação não linear.",
                                    "Descreva região de estabilidade: todo semiplano esquerdo (A-estável).",
                                    "Introduza métodos multistep implícitos como BDF (Backward Differentiation Formulas).",
                                    "Compare: implícitos permitem h maior (ex: h=0.1 para λ=1000), capturam decaimento rápido.",
                                    "Mencione custo: cada passo requer solver não linear (Newton), mas menos passos totais."
                                  ],
                                  "verification": "O aluno implementa Euler implícito em um exemplo stiff e mostra estabilidade para h maior.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python/Octave com fsolve para equações não lineares, exemplos de código prontos.",
                                  "tips": "Use iterações de ponto fixo simples para Euler implícito antes de Newton.",
                                  "learningObjective": "Reconhecer vantagens de métodos implícitos em termos de estabilidade.",
                                  "commonMistakes": "Achar implícitos sempre mais lentos sem considerar número de passos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e justificar necessidade de métodos implícitos",
                                  "subSteps": [
                                    "Resolva y' = -1000(y - sin(t)) numericamente com explícito vs implícito.",
                                    "Meça passos necessários para erro < 10^{-3} em [0,1].",
                                    "Discuta trade-off: custo por passo vs total.",
                                    "Conclua: implícitos essenciais para stiff real-world sem restrições severas em h.",
                                    "Liste critérios para escolher: L-stabilidade para decaimento rápido."
                                  ],
                                  "verification": "O aluno compara tempos de CPU e erros em tabela para ambos métodos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Computador com SciPy/MATLAB, problema de teste y' = -1000(y - sin(t)).",
                                  "tips": "Fixe erro tolerado e compare h efetivo.",
                                  "learningObjective": "Justificar uso de métodos implícitos para problemas stiff.",
                                  "commonMistakes": "Subestimar overhead de solvers não lineares em problemas não-stiff."
                                }
                              ],
                              "practicalExample": "Considere y' = -1000(y - sin(t)), y(0)=0 em [0, π]. Solução exata segue sin(t) após decaimento rápido. Euler explícito requer h<0.001 (1000+ passos). Euler implícito com Newton permite h=0.05 (60 passos), estável e preciso.",
                              "finalVerifications": [
                                "Explica diferença entre regiões de estabilidade explícita e implícita.",
                                "Implementa e compara soluções numéricas para EDO stiff.",
                                "Identifica quando usar implícito vs explícito.",
                                "Desenha regiões de estabilidade corretas.",
                                "Calcula h máximo para estabilidade em exemplo dado.",
                                "Discute L-estabilidade para decaimento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de limitações explícitas (30%)",
                                "Correção de regiões de estabilidade (25%)",
                                "Qualidade da comparação numérica (20%)",
                                "Justificativa da necessidade implícita (15%)",
                                "Uso correto de terminologia (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RC stiff em eletrônica.",
                                "Química: Equações de reações em série com escalas rápidas/lentas.",
                                "Engenharia: Controle de sistemas dinâmicos rígidos.",
                                "Computação: Otimização de solvers em bibliotecas como ODEPACK."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos (rigidez por reações rápidas), permitindo h práticos para previsões industriais; em modelagem climática para fluxos rápidos de ozônio."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Relacionar com controle de passo",
                            "description": "Discutir como em problemas stiff o controle de passo adaptativo é crucial para balancear precisão e estabilidade, evitando passos muito pequenos desnecessários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição de Problemas Stiff e Exigência de Estabilidade",
                                  "subSteps": [
                                    "Defina problemas stiff como EDOs com escalas de tempo muito diferentes, exigindo passos pequenos para estabilidade.",
                                    "Explique a rigidez usando o eigenvalue ratio (λ_max / λ_min >> 1).",
                                    "Discuta instabilidade em métodos explícitos como Euler forward.",
                                    "Compare com problemas não-stiff usando gráficos de solução.",
                                    "Identifique exemplos clássicos como y' = -λ(y - y_eq) com λ grande."
                                  ],
                                  "verification": "Resuma em um parágrafo as características de estabilidade em stiff problems e forneça um exemplo numérico simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), software MATLAB ou Python (SciPy).",
                                  "tips": "Use equações diferenciais lineares simples para visualizar escalas rápidas e lentas.",
                                  "learningObjective": "Compreender por que problemas stiff demandam estabilidade numérica restritiva.",
                                  "commonMistakes": "Confundir precisão com estabilidade; ignorar análise de estabilidade de Dahlquist."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Controle de Passo Fixo vs Adaptativo",
                                  "subSteps": [
                                    "Descreva métodos de passo fixo: h constante, problemas em stiff devido a h < 1/|λ_max|.",
                                    "Explique controle adaptativo: ajuste h baseado em erro local estimado (ex: embutidos como RK4(5)).",
                                    "Discuta critérios de aceitação/rejeição de passo (tol relativa/absoluta).",
                                    "Implemente um exemplo simples de passo fixo falhando em stiff.",
                                    "Simule passo adaptativo reduzindo h automaticamente."
                                  ],
                                  "verification": "Implemente e compare simulações de passo fixo e adaptativo para um stiff problem, plotando trajetórias.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com odeint ou solve_ivp, Jupyter Notebook.",
                                  "tips": "Comece com h fixo grande para observar oscilações instáveis.",
                                  "learningObjective": "Diferenciar limitações de passos fixos e vantagens adaptativos em estabilidade.",
                                  "commonMistakes": "Escolher tolerâncias muito soltas, levando a passos grandes e perda de precisão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Controle de Passo com Balanceamento de Precisão e Estabilidade",
                                  "subSteps": [
                                    "Explique como controle adaptativo evita h muito pequenos desnecessários em regiões não-stiff.",
                                    "Discuta estimadores de erro (ex: diferença entre soluções de ordens diferentes).",
                                    "Analise trade-offs: precisão (tol pequena → h pequeno), eficiência (evitar h excessivamente pequeno).",
                                    "Examine impacto em stiff: mantém estabilidade sem desperdiçar computação.",
                                    "Compare com métodos implícitos (ex: BDF) que relaxam restrições de h."
                                  ],
                                  "verification": "Escreva uma tabela comparando h médio, tempo de CPU e erro para fixo vs adaptativo em stiff ODE.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Documentação SciPy ode solvers, papel e caneta para tabelas.",
                                  "tips": "Monitore logs do solver para ver rejeições de passo e ajustes de h.",
                                  "learningObjective": "Relacionar adaptação de h com equilíbrio entre precisão, estabilidade e eficiência.",
                                  "commonMistakes": "Ignorar overhead de rejeições; assumir adaptativo sempre mais rápido."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conceito em Exemplo Prático e Sintetizar",
                                  "subSteps": [
                                    "Escolha um stiff problem real (ex: reação química A → B com taxas díspares).",
                                    "Resolva com solver adaptativo e analise histórico de h.",
                                    "Discuta como controle evita passos minúsculos após regime transitório rápido.",
                                    "Sintetize: 'controle adaptativo é crucial para stiff por balancear estabilidade sem ineficiência'.",
                                    "Crie um fluxograma do algoritmo de controle de passo."
                                  ],
                                  "verification": "Gere relatório com plots de solução, h(t) e erro, explicando relação com stiff.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Código Python pronto para stiff ODEs, ferramenta de plotagem (Matplotlib).",
                                  "tips": "Use solve_ivp com method='RK45' e dense_output=True para análise.",
                                  "learningObjective": "Sintetizar relação entre stiff problems, estabilidade e controle de passo adaptativo.",
                                  "commonMistakes": "Não plotar h ao longo do tempo, perdendo insight sobre adaptação."
                                }
                              ],
                              "practicalExample": "Considere a EDO stiff y' = -1000(y - sin(t)) + cos(t), y(0)=0. Resolva no intervalo [0,1] com passo fixo h=0.01 (instável) vs adaptativo (RK45 com rtol=1e-6): o adaptativo usa h pequeno inicialmente (~1e-4) para capturar transitório rápido, depois aumenta para ~0.01, balanceando estabilidade e eficiência.",
                              "finalVerifications": [
                                "Explicar corretamente por que stiff problems requerem h << 1/|λ_max| para estabilidade explícita.",
                                "Demonstrar via simulação falha de passo fixo e sucesso adaptativo.",
                                "Identificar ajuste dinâmico de h baseado em erro local.",
                                "Discutir trade-off: passos muito pequenos desperdiçam CPU sem ganho de precisão.",
                                "Relacionar controle adaptativo como solução chave para stiff ODEs.",
                                "Plotar histórico de h mostrando redução em regimes stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre precisão, estabilidade e eficiência (30%).",
                                "Análise numérica: Simulações comparativas com plots claros (25%).",
                                "Explicação de mecanismos: Detalhes sobre estimadores de erro e critérios (20%).",
                                "Exemplos relevantes: Uso de stiff problems reais (15%).",
                                "Síntese: Fluxograma ou resumo claro da relação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de circuitos RC com constantes de tempo díspares.",
                                "Química: Cinética de reações com mecanismos rápidos/lentos.",
                                "Engenharia: Controle de sistemas dinâmicos stiff (ex: aerodinâmica).",
                                "Ciência da Computação: Otimização de solvers numéricos em HPC."
                              ],
                              "realWorldApplication": "Em modelagem de reações químicas em reatores industriais, onde escalas rápidas (reações elementares) e lentas (difusão) coexistem, controle de passo adaptativo em solvers como CVODE permite simulações precisas e eficientes para otimização de processos, evitando crashes por instabilidade e reduzindo tempo de computação em 50-90%."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Características e Exemplos de Problemas Stiff",
                    "description": "Propriedades como separação de escalas temporais e exemplos clássicos como reações químicas rígidas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Definição e Características Fundamentais de Problemas Stiff",
                        "description": "Compreender a definição formal de problemas stiff em equações diferenciais ordinárias (EDOs), incluindo propriedades como rigidez, constante de Lipschitz elevada e instabilidade de métodos explícitos explícitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Definir um problema stiff",
                            "description": "Explicar que um problema stiff é caracterizado por uma solução suave, mas com componentes transitórios rápidos que exigem passos de tempo muito pequenos em métodos explícitos para manter a estabilidade, mesmo com tolerâncias moderadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Equações Diferenciais Ordinárias (EDOs) e Métodos Explícitos",
                                  "subSteps": [
                                    "Relembre a forma geral de uma EDO inicial: y' = f(t, y), y(t0) = y0.",
                                    "Estude métodos explícitos como Euler forward e Runge-Kutta de ordem 4, focando em como eles aproximam a solução.",
                                    "Analise o conceito de passo de tempo h e sua relação com a precisão e estabilidade.",
                                    "Implemente um método explícito simples em Python ou MATLAB para uma EDO não-stiff básica.",
                                    "Observe o comportamento da solução com h variando de pequeno a grande."
                                  ],
                                  "verification": "Execute o código e confirme que a solução converge para h pequenos sem oscilações instáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/MATLAB com bibliotecas numpy/scipy/ode45",
                                    "Notebook Jupyter",
                                    "Livro de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Comece com h = 0.01 e aumente gradualmente para visualizar limites de estabilidade.",
                                  "learningObjective": "Compreender como métodos explícitos funcionam em problemas bem comportados.",
                                  "commonMistakes": [
                                    "Confundir precisão com estabilidade",
                                    "Usar h muito grande sem testar convergência",
                                    "Ignorar condições iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Estabilidade em Métodos Explícitos",
                                  "subSteps": [
                                    "Defina estabilidade: capacidade do método de não amplificar erros numéricos ao longo das iterações.",
                                    "Estude o critério de estabilidade para Euler forward: |1 + hλ| < 1 para autovalores λ.",
                                    "Teste com EDOs lineares y' = λy, variando Re(λ) negativo grande (ex: λ = -100).",
                                    "Compare simulações com h pequeno (estável) vs. h grande (instável com oscilações).",
                                    "Registre o passo de tempo máximo h_max para estabilidade."
                                  ],
                                  "verification": "Gere gráficos mostrando solução suave para h < h_max e explosão para h > h_max.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de plotagem (Matplotlib)",
                                    "Exemplos de código para EDOs lineares",
                                    "Referência: Notas de aula sobre estabilidade A-stável"
                                  ],
                                  "tips": "Use λ reais negativos crescentes para simular rigidez crescente.",
                                  "learningObjective": "Identificar quando métodos explícitos falham devido a restrições de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir instabilidade com erro de truncamento",
                                    "Não plotar múltiplas trajetórias",
                                    "Esquecer de normalizar soluções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Características de Problemas Stiff",
                                  "subSteps": [
                                    "Defina solução suave: componente principal da solução que varia lentamente.",
                                    "Introduza componentes transitórios rápidos: modos efêmeros que decaem rapidamente mas dominam inicialmente.",
                                    "Analise decomposição em escalas: solução = y_suave(t) + y_transitório(t)e^{-λt} com |λ| grande.",
                                    "Simule um problema semi-stiff: y' = -50(y - sin(t)), observe necessidade de h << 1/50.",
                                    "Compare com problema não-stiff (λ pequeno), medindo h necessário para tolerância ε=10^{-6}."
                                  ],
                                  "verification": "Meça h requerido: para stiff, h << 1/|λ| mesmo com ε moderada; para não-stiff, h maior.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código para EDOs stiff vs. não-stiff",
                                    "Ferramenta de análise de rigidez (ex: ode23s no MATLAB)"
                                  ],
                                  "tips": "Fixe ε e varie λ para quantificar 'stiff': h_stiff / h_nonstiff >> 1.",
                                  "learningObjective": "Reconhecer discrepância entre suavidade da solução e rigidez transitória.",
                                  "commonMistakes": [
                                    "Focar só na solução final, ignorando transientes",
                                    "Usar métodos implícitos prematuramente",
                                    "Não quantificar h vs. ε"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a Definição de Problema Stiff",
                                  "subSteps": [
                                    "Compile definição: Problema stiff tem solução suave mas transientes rápidos, exigindo h muito pequeno em explícitos para estabilidade, mesmo com tolerâncias moderadas.",
                                    "Escreva formalmente usando Lipschitz constante L grande ou espectro de autovalores com |λ_max| >> 1.",
                                    "Crie fluxograma: Dado EDO → Verifique escalas de tempo → Se disparidade grande → Stiff.",
                                    "Teste definição em exemplo clássico: reator químico y' = -1000y(1-y).",
                                    "Redija parágrafo explicativo com suas palavras."
                                  ],
                                  "verification": "Sua definição explica solução suave + transientes + restrição h em explícitos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel/caneta para fluxograma",
                                    "Exemplos de literatura (ex: Hairer 'Solving ODEs')"
                                  ],
                                  "tips": "Inclua 'mesmo com tolerâncias moderadas' para diferenciar de precisão.",
                                  "learningObjective": "Articular definição precisa e acionável de problema stiff.",
                                  "commonMistakes": [
                                    "Definir só por λ grande, sem contexto de solução suave",
                                    "Confundir com problemas oscilatórios",
                                    "Omitir papel dos métodos explícitos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a EDO y' = -100(y - sin(t)), y(0)=0. A solução tende a sin(t) suavemente após transiente rápido e^( -100t ). Com método Euler explícito e ε=10^{-3}, h deve ser <0.01 para estabilidade, apesar da solução suave permitir h=0.1 em não-stiff.",
                              "finalVerifications": [
                                "Explique verbalmente as 3 características chave de stiff.",
                                "Simule exemplo stiff e mostre instabilidade com h inadequado.",
                                "Compare h requerido em stiff vs. não-stiff para mesma ε.",
                                "Redija definição em <50 palavras que inclua solução suave e restrição explícita.",
                                "Identifique se dado EDO é stiff baseado em análise espectral."
                              ],
                              "assessmentCriteria": [
                                "Definição inclui solução suave, transientes rápidos e necessidade de h pequeno em explícitos.",
                                "Exemplos demonstram discrepância quantitativa de h.",
                                "Análise distingue stiff de problemas meramente precisos.",
                                "Uso correto de termos: estabilidade vs. precisão, Lipschitz, autovalores.",
                                "Aplicação consistente em novos contextos.",
                                "Clareza na comunicação escrita/oral."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de circuitos RC com constantes de tempo díspares.",
                                "Química: Cinética de reações em série com taxas muito diferentes.",
                                "Engenharia: Controle de sistemas com polos rápidos e lentos.",
                                "Computação: Otimização de solvers numéricos em bibliotecas como SciPy."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos, problemas stiff surgem de reações rápidas/lentas; métodos explícitos falham sem h minúsculo, desperdiçando CPU, enquanto implícitos como BDF permitem passos maiores para previsões industriais eficientes."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Identificar a rigidez em termos de autovalores",
                            "description": "Analisar o espectro de autovalores da matriz jacobiana, onde autovalores com partes reais muito negativas indicam rigidez, exigindo passos de tempo h < 2 / |λ_max| para estabilidade em métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Matriz Jacobiana e Autovalores",
                                  "subSteps": [
                                    "Defina a matriz Jacobiana para um sistema de EDOs não lineares: J = ∂f/∂y.",
                                    "Explique o papel da Jacobiana na linearização local do sistema ao redor de um ponto de equilíbrio.",
                                    "Revise a definição de autovalores: soluções de det(J - λI) = 0.",
                                    "Discuta o espectro de autovalores e a importância da parte real (Re(λ)).",
                                    "Identifique que autovalores com Re(λ) << 0 indicam componentes rápidas e decay exponencial."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo simples de Jacobiana para y' = -y.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Análise Numérica (capítulo de EDOs), calculadora simbólica (SymPy ou MATLAB).",
                                  "tips": "Use diagramas de fluxo para visualizar a linearização: sistema não linear → Jacobiana → autovalores.",
                                  "learningObjective": "Compreender a relação entre Jacobiana, linearização e estabilidade espectral.",
                                  "commonMistakes": "Confundir Jacobiana com Hessiana; ignorar que é avaliada em equilíbrio."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Matriz Jacobiana para um Sistema Stiff",
                                  "subSteps": [
                                    "Escolha um sistema stiff exemplo: y' = -1000y + z, z' = y - z.",
                                    "Encontre pontos de equilíbrio resolvendo f(y,z) = 0.",
                                    "Compute elementos da Jacobiana: J11 = ∂f1/∂y, J12 = ∂f1/∂z, etc.",
                                    "Avalie J no equilíbrio encontrado.",
                                    "Verifique simbolicamente ou numericamente os elementos."
                                  ],
                                  "verification": "Apresente a Jacobiana computada e confirme que é correta derivando manualmente um elemento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis para derivação, software como Python (NumPy/SymPy) ou MATLAB.",
                                  "tips": "Para sistemas lineares, Jacobiana é a matriz A constante; pratique com lineares primeiro.",
                                  "learningObjective": "Dominar o cálculo explícito da Jacobiana em sistemas stiff.",
                                  "commonMistakes": "Derivar errado (ex: esquecer sinal); não avaliar no equilíbrio correto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar e Analisar o Espectro de Autovalores",
                                  "subSteps": [
                                    "Resolva o polinômio característico det(J - λI) = 0.",
                                    "Use métodos numéricos se analítico for complexo (eig em MATLAB/Python).",
                                    "Liste todos autovalores complexos e suas partes reais.",
                                    "Identifique λ_max como o autovalor com maior |Re(λ)| negativo.",
                                    "Calcule a razão de rigidez ρ = |λ_max| / |λ_min| onde Re(λ_min) próximo de 0."
                                  ],
                                  "verification": "Forneça lista de autovalores e confirme com output de software.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software computacional (MATLAB eig(), numpy.linalg.eig()), planilha para razões.",
                                  "tips": "Sempre plote o espectro no plano complexo para visualização intuitiva.",
                                  "learningObjective": "Calcular autovalores e quantificar o espectro de rigidez.",
                                  "commonMistakes": "Arredondamento numérico em eig; confundir parte real com módulo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Rigidez e Implicações para Métodos Numéricos",
                                  "subSteps": [
                                    "Defina rigidez: presença de autovalores com Re(λ) muito negativos vs. próximos de 0.",
                                    "Estime passo de tempo h < 2 / |Re(λ_max)| para estabilidade em Euler explícito.",
                                    "Simule numericamente com h inadequado para observar instabilidade.",
                                    "Compare com método implícito (ex: Backward Euler) que permite h maior.",
                                    "Conclua se o problema é stiff baseado na razão ρ > 1000 tipicamente."
                                  ],
                                  "verification": "Gere gráfico de solução explícita instável vs. implícita estável.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Solver numérico (ode45 MATLAB, scipy.integrate.odeint Python), gráficos.",
                                  "tips": "Teste h = 1.9 / |λ_max| para ver oscilações iniciais de instabilidade.",
                                  "learningObjective": "Aplicar análise espectral para diagnosticar rigidez e escolher solvers.",
                                  "commonMistakes": "Ignorar parte imaginária; superestimar h sem fator de segurança 2."
                                }
                              ],
                              "practicalExample": "Para o sistema y' = -1000y + z, z' = y - z, equilíbrio (0,0), J = [[-1000,1],[1,-1]]. Autovalores ≈ -1000.5 ± i*0.5, Re(λ_max)≈-1000, h<0.002 para explícito. Simulação mostra instabilidade em h=0.01.",
                              "finalVerifications": [
                                "Computa corretamente Jacobiana e autovalores para exemplo dado.",
                                "Identifica corretamente λ com maior |Re(λ)| negativo.",
                                "Estima h estável corretamente com fórmula h < 2/|λ_max|.",
                                "Simula e demonstra instabilidade em método explícito com h grande.",
                                "Explica verbalmente por que partes reais negativas causam rigidez.",
                                "Calcula razão de rigidez ρ > 1000 confirmando stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da Jacobiana (100% elementos corretos).",
                                "Correção dos autovalores (erro <1e-6).",
                                "Interpretação qualitativa e quantitativa do espectro.",
                                "Demonstração prática via simulação numérica.",
                                "Uso apropriado de fórmula de estabilidade.",
                                "Clareza na identificação de rigidez baseada em Re(λ)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em osciladores dissipativos (ex: circuitos RLC).",
                                "Química: Cinética de reações rápidas/lentas em redes químicas.",
                                "Engenharia: Controle de sistemas dinâmicos com atuadores rápidos.",
                                "Computação: Otimização de solvers ODE em bibliotecas como SciPy."
                              ],
                              "realWorldApplication": "Em simulações de combustão em motores (reações químicas stiff), análise de autovalores da Jacobiana guia escolha de solvers implícitos como BDF, permitindo passos de tempo realistas para predizer eficiência e emissões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Comparar estabilidade em métodos explícitos vs. implícitos",
                            "description": "Demonstrar por que métodos explícitos como Euler forward falham em problemas stiff devido à restrição CFL severa, enquanto métodos implícitos como backward Euler permitem passos maiores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Problemas Stiff e Estabilidade Numérica",
                                  "subSteps": [
                                    "Defina problemas stiff: sistemas de EDOs com escalas de tempo muito diferentes (eigenvalues com partes reais grandes negativas).",
                                    "Explique a condição CFL (Courant-Friedrichs-Lewy): restrição no passo de tempo h < 1/|λ_max| para estabilidade em métodos explícitos.",
                                    "Discuta regiões de estabilidade no plano complexo hλ.",
                                    "Identifique características: rigidez causa passos pequenos em explícitos, mas implícitos relaxam isso.",
                                    "Resuma diferenças iniciais entre métodos explícitos (não requerem solução de sistemas) e implícitos (requerem)."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras definindo stiff problems e CFL, confirmando com gráfico qualitativo da região de estabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), papel e caneta ou software como MATLAB/Octave para sketches.",
                                  "tips": "Use analogia de 'corrida de tartaruga e lebre' para escalas de tempo diferentes.",
                                  "learningObjective": "Compreender as raízes matemáticas da instabilidade em problemas stiff.",
                                  "commonMistakes": "Confundir stiff com não-lineares; ignorar que stiff é sobre eigenvalues reais grandes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Estabilidade do Método Explícito: Euler Forward",
                                  "subSteps": [
                                    "Escreva a fórmula do Euler forward: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Aplique a um problema modelo stiff: y' = λ y, com λ = -1000, y(0)=1.",
                                    "Calcule manualmente passos com h pequeno (h=0.001) vs h grande (h=0.01), observando oscilações e divergência.",
                                    "Derive a condição de estabilidade: |1 + hλ| < 1 para λ real negativo.",
                                    "Plote a região de estabilidade: disco unitário centrado em -1 no plano hλ."
                                  ],
                                  "verification": "Implemente código simples em Python/MATLAB mostrando divergência para h > 1/|λ|; gere gráfico de solução vs tempo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/Matplotlib ou MATLAB, exemplo de código base para Euler forward.",
                                  "tips": "Comece com λ pequeno para ver estabilidade, depois aumente para stiff.",
                                  "learningObjective": "Demonstrar falha prática do Euler forward em stiff problems devido a CFL severa.",
                                  "commonMistakes": "Usar h fixo sem testar múltiplos valores; esquecer normalizar solução exata e^{λt}."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estabilidade do Método Implícito: Backward Euler",
                                  "subSteps": [
                                    "Escreva a fórmula: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}), levando a y_{n+1} - h λ y_{n+1} = y_n.",
                                    "Resolva para o modelo stiff: y_{n+1} = y_n / (1 - h λ).",
                                    "Calcule com h grande (h=0.1), mostrando convergência suave para 0.",
                                    "Derive estabilidade: |1 / (1 - hλ)| < 1 para Re(λ)<0, região externa ao círculo unitário.",
                                    "Compare numericamente com Euler forward no mesmo problema."
                                  ],
                                  "verification": "Gere gráficos lado a lado: solução Euler forward (instável) vs Backward Euler (estável) para h=0.01.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo ambiente de programação do step 2, adicionar função para Backward Euler.",
                                  "tips": "Para linear, solução analítica é fácil; note que para não-lineares precisa de Newton.",
                                  "learningObjective": "Entender como implícitos permitem h maiores via solução de sistemas lineares.",
                                  "commonMistakes": "Esquecer o lag em t_{n+1}; confundir com trapezoidal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Visualizar Regiões de Estabilidade",
                                  "subSteps": [
                                    "Desenhe regiões de estabilidade: explícito (disco interno), implícito (plano esquerdo).",
                                    "Para λ=-1000, calcule h_max explícito (~0.001) vs implícito (ilimitado).",
                                    "Discuta custo computacional: explícito barato por passo, mas muitos passos; implícito caro por passo, poucos passos.",
                                    "Teste em problema stiff real: y' = -50(y-1) + sin(t), simulando oscilador rígido.",
                                    "Conclua vantagens/desvantagens em tabela."
                                  ],
                                  "verification": "Crie tabela comparativa e gráfico de regiões de estabilidade; explique verbalmente por 2 minutos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Matplotlib), tabela em LaTeX ou Excel.",
                                  "tips": "Use hλ como eixo para normalizar; foque no semiplano esquerdo.",
                                  "learningObjective": "Sintetizar comparação quantitativa e qualitativa de estabilidade.",
                                  "commonMistakes": "Ignorar custo de solve em implícitos para sistemas grandes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em Exemplo Prático e Refletir",
                                  "subSteps": [
                                    "Implemente ambos métodos em código para y' = -1000y + sin(1000t), y(0)=0.",
                                    "Execute com h adaptativo conceitual: reduza h em explícito até estabilizar.",
                                    "Meça tempo de CPU e erro L2 vs solução exata.",
                                    "Discuta quando usar cada: explícito para não-stiff, implícito para stiff.",
                                    "Registre insights em diário de aprendizado."
                                  ],
                                  "verification": "Submeta código, gráficos e relatório de 1 página com conclusões.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código completo, timer de CPU, referência solução (ode45 em MATLAB).",
                                  "tips": "Use scipy.integrate.odeint como benchmark.",
                                  "learningObjective": "Aplicar comparação em contexto realista e avaliar trade-offs.",
                                  "commonMistakes": "Não medir performance; superestimar simplicidade de implícitos."
                                }
                              ],
                              "practicalExample": "Considere o problema stiff y' = -1000 y, y(0)=1, modelando decaimento rápido. Com Euler forward e h=0.002 (>1/1000), solução oscila e diverge; com Backward Euler e h=0.1, converge suavemente a 0, permitindo 50x mais passos eficientes.",
                              "finalVerifications": [
                                "Explicar verbalmente por que CFL restringe explícitos em stiff problems.",
                                "Gerar gráfico de regiões de estabilidade para ambos métodos.",
                                "Implementar código que falha em explícito mas succeeds em implícito.",
                                "Calcular h_max para λ=-1000 em ambos.",
                                "Identificar cenário onde explícito ainda é preferível.",
                                "Discutir limitação de Backward Euler (não A-estável para ordem alta)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de condições de estabilidade (100% correto).",
                                "Qualidade dos gráficos e simulações numéricas (clareza e labels).",
                                "Profundidade da comparação (quantitativa + qualitativa).",
                                "Correção no exemplo prático (erro <1e-3).",
                                "Identificação de trade-offs computacionais.",
                                "Clareza na comunicação escrita/oral."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão reativa ou circuitos RC stiff.",
                                "Computação: Otimização de solvers numéricos (SciPy, PETSc).",
                                "Engenharia: Simulações CFD com escalas múltiplas.",
                                "Química Computacional: Cinética de reações rápidas/lentas."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos, problemas stiff surgem de reações rápidas; métodos implícitos como Backward Euler/backward DAE solvers permitem simular horas de processo com passos de segundos, essencial para design industrial eficiente."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Separação de Escalas Temporais",
                        "description": "Explorar a propriedade de separação de escalas em problemas stiff, onde componentes rápidos (decaindo rapidamente) e lentos (determinando o comportamento assintótico) coexistem, impactando o controle de erro e estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Descrever a separação de escalas temporais",
                            "description": "Explicar que em problemas stiff, existem escalas temporais ε << 1 para modos rápidos e τ >> 1 para modos lentos, levando a soluções com decaimento exponencial rápido e comportamento lento dominante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender escalas temporais em equações diferenciais ordinárias (EDOs)",
                                  "subSteps": [
                                    "Revise o conceito básico de EDOs e suas soluções analíticas.",
                                    "Identifique componentes de soluções que variam em diferentes velocidades temporais.",
                                    "Estude exemplos simples de EDOs lineares com constantes de tempo distintas.",
                                    "Analise graficamente soluções com escalas rápidas e lentas.",
                                    "Defina formalmente 'escala temporal' como o inverso da taxa de variação."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é uma escala temporal e dê um exemplo de EDO com múltiplas escalas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de EDOs)",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)"
                                  ],
                                  "tips": "Comece com EDOs de primeira ordem para simplicidade antes de generalizar.",
                                  "learningObjective": "Entender o papel das escalas temporais nas soluções de EDOs.",
                                  "commonMistakes": [
                                    "Confundir escala temporal com tamanho do intervalo de integração.",
                                    "Ignorar a dependência paramétrica nas taxas de variação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar modos rápidos e lentos em problemas stiff",
                                  "subSteps": [
                                    "Defina 'problema stiff' como EDOs com escalas temporais discrepantes.",
                                    "Introduza o parâmetro ε << 1 associado a modos rápidos (1/ε >> 1).",
                                    "Explique τ >> 1 para modos lentos, representando dinâmica de longo prazo.",
                                    "Examine autovalores de sistemas lineares para classificar modos.",
                                    "Compare com problemas não-stiff onde todas as escalas são similares."
                                  ],
                                  "verification": "Classifique os modos em um exemplo dado de EDO stiff, identificando ε e τ.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Exemplos de EDOs stiff impressos ou digitais",
                                    "Calculadora ou software simbólico (SymPy)"
                                  ],
                                  "tips": "Use decomposição em autovalores para visualizar modos rápidos (autovalores com parte real grande negativa).",
                                  "learningObjective": "Reconhecer características quantitativas de modos rápidos e lentos.",
                                  "commonMistakes": [
                                    "Assumir que stiffness é só rigidez numérica, ignorando origem física.",
                                    "Confundir ε pequeno com τ pequeno."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o decaimento exponencial rápido e comportamento lento dominante",
                                  "subSteps": [
                                    "Descreva o decaimento exponencial e^{-t/ε} para modos rápidos.",
                                    "Mostre como modos rápidos desaparecem rapidamente após t ~ ε.",
                                    "Explique o comportamento lento dominante como a solução quasi-estacionária.",
                                    "Simule numericamente para observar o 'layer rápido' inicial e platô lento.",
                                    "Discuta implicações para métodos numéricos integradores."
                                  ],
                                  "verification": "Plote e descreva a solução de um exemplo, destacando transições de escalas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Software numérico (Python com SciPy odeint)",
                                    "Gráficos de referência de problemas stiff"
                                  ],
                                  "tips": "Escolha ε = 0.01 para visualização clara sem computação excessiva.",
                                  "learningObjective": "Descrever dinamicamente a separação temporal em soluções stiff.",
                                  "commonMistakes": [
                                    "Negligenciar o layer rápido em simulações com passos grandes.",
                                    "Confundir decaimento rápido com oscilação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a descrição da separação de escalas temporais",
                                  "subSteps": [
                                    "Escreva a forma assintótica da solução: y(t) ≈ y_lento(t) + ε y_rápido(t/ε).",
                                    "Relacione com análise assintótica e expansões em ε.",
                                    "Discuta condições para separação válida (ε → 0).",
                                    "Aplique a um exemplo concreto e verifique numericamente.",
                                    "Resuma em um parágrafo coeso a descrição completa."
                                  ],
                                  "verification": "Redija uma descrição formal de 200 palavras sobre a separação em um problema dado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Papel e caneta para derivações",
                                    "Referências teóricas (Hairer et al., Solving ODEs II)"
                                  ],
                                  "tips": "Use notação não-dimensional para destacar ε claramente.",
                                  "learningObjective": "Articular de forma precisa e completa a separação de escalas.",
                                  "commonMistakes": [
                                    "Omitir limites assintóticos na descrição.",
                                    "Generalizar sem especificar condições."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a EDO dy/dt = - (1/ε) y + sin(t), com ε = 0.01. Inicialmente y(0)=0, observa-se um decaimento rápido para o particular sin(t), seguido por oscilação lenta dominante, ilustrando modos rápidos (1/ε ≈ 100) e lentos (τ ≈ 1).",
                              "finalVerifications": [
                                "Explica corretamente ε << 1 e τ >> 1 com exemplos numéricos.",
                                "Descreve decaimento exponencial rápido e lento dominante.",
                                "Identifica separação em um novo exemplo stiff.",
                                "Relaciona com desafios numéricos em integração.",
                                "Fornece descrição formal sem erros conceituais.",
                                "Simula e interpreta graficamente um caso stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de escalas temporais (ε e τ).",
                                "Clareza na distinção entre modos rápidos e lentos.",
                                "Correta descrição do comportamento assintótico.",
                                "Uso apropriado de exemplos e simulações.",
                                "Capacidade de generalizar para problemas reais.",
                                "Ausência de confusões comuns como rigidez vs. não-linearidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de reações químicas rápidas/lentas (cinética química).",
                                "Engenharia: Controle de sistemas multi-escala (aeroespacial).",
                                "Biologia: Dinâmica populacional com epidemias rápidas e crescimento lento.",
                                "Computação: Algoritmos de integração adaptativa em simulações.",
                                "Física Computacional: Simulações de fluidos com escalas múltiplas."
                              ],
                              "realWorldApplication": "Em simulações de combustão, onde reações químicas rápidas (ε pequeno) interagem com fluxo lento, a separação permite métodos híbridos eficientes, reduzindo custo computacional em motores de aviões."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Analisar o impacto na escolha de passos de tempo",
                            "description": "Calcular e discutir como a separação de escalas impõe h << ε para capturar modos rápidos em métodos explícitos, tornando-os ineficientes, e como métodos A-stáveis mitigam isso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a separação de escalas em problemas stiff",
                                  "subSteps": [
                                    "Defina problemas stiff como sistemas de EDOs com escalas temporais díspares (rápida e lenta).",
                                    "Identifique a razão ε (0 < ε << 1) como a separação entre escalas rápidas (1/ε) e lentas (1).",
                                    "Analise o exemplo modelo y' = -y/ε + f(y), onde o termo -y/ε domina em escalas rápidas.",
                                    "Discuta como modos rápidos decaem rapidamente, mas afetam a estabilidade numérica.",
                                    "Esboce o comportamento qualitativo da solução em diferentes escalas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a origem da rigidez e forneça um gráfico esquemático da solução.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), papel e lápis para esboços, software como MATLAB para plotar soluções exatas.",
                                  "tips": "Use analogias como 'freio de mão' para modos rápidos que estabilizam rapidamente.",
                                  "learningObjective": "Entender conceitualmente como a separação de escalas gera rigidez em EDOs.",
                                  "commonMistakes": "Confundir rigidez com não-linearidade; ignorar que soluções lentas persistem após transientes rápidos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar restrições em métodos explícitos",
                                  "subSteps": [
                                    "Revise o método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Derive a condição de estabilidade |1 + h λ| ≤ 1 para autovalores λ negativos grandes (|λ| >> 1).",
                                    "Mostre que para modos rápidos (λ ≈ -1/ε), h << ε é requerido para estabilidade.",
                                    "Calcule h_max ≈ 2ε para o pior autovalor em problemas stiff.",
                                    "Discuta ineficiência: número de passos N ≈ T / h >> T / ε, onde T é o intervalo de integração."
                                  ],
                                  "verification": "Calcule h_max para ε = 0.01 e verifique se passos maiores causam instabilidade simulando numericamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou Python/MATLAB para simulações simples de Euler explícito.",
                                  "tips": "Teste com h = 10ε para observar blow-up imediato.",
                                  "learningObjective": "Derivar e quantificar a restrição h << ε em métodos explícitos para stiff problems.",
                                  "commonMistakes": "Esquecer o fator 2 na condição de estabilidade de Euler; confundir estabilidade com precisão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Exemplo prático de cálculo de impacto",
                                  "subSteps": [
                                    "Considere y' = - (1/ε) y + (1 - y), com ε = 10^{-3}, t ∈ [0,1].",
                                    "Calcule autovalores da linearização: λ1 ≈ -1/ε, λ2 ≈ -1.",
                                    "Determine h_max ≈ 2ε = 0.002 para Euler explícito.",
                                    "Estime passos necessários: N ≈ 1 / 0.002 = 500.",
                                    "Simule com h = 0.002 (estável) vs. h = 0.01 (instável) e compare tempos de computação."
                                  ],
                                  "verification": "Produza gráficos de soluções numéricas estáveis e instáveis, com tabela de N e tempo CPU.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, script pronto para Euler explícito.",
                                  "tips": "Use ode45 em MATLAB para solução de referência e compare erros.",
                                  "learningObjective": "Aplicar cálculos teóricos a um exemplo concreto para quantificar ineficiência.",
                                  "commonMistakes": "Usar ε incorreto na linearização; ignorar o termo não-stiff na análise."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar métodos A-estáveis e sua mitigação",
                                  "subSteps": [
                                    "Defina estabilidade A: região de estabilidade inclui todo o semiplano esquerdo Re(z) ≤ 0.",
                                    "Discuta método de Backward Euler: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}), A-estável.",
                                    "Mostre que para Backward Euler, |1 / (1 - h λ)| ≤ 1 para Re(λ) < 0, sem restrição h << ε.",
                                    "Compare com explícito: h pode ser O(1), N ≈ T / 1 << T / ε.",
                                    "Simule o mesmo exemplo com Backward Euler usando h = 0.1, verificando estabilidade e precisão."
                                  ],
                                  "verification": "Execute simulação com h = 0.1 em método A-estável e confirme convergência sem oscilações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo software do Step 3, agora implementando Backward Euler.",
                                  "tips": "Note a amortecimento excessivo em A-estáveis, mas priorize estabilidade para stiff.",
                                  "learningObjective": "Compreender como A-estabilidade remove restrições de passo em stiff problems.",
                                  "commonMistakes": "Confundir A-estável com L-estável (não requerido aqui); esperar precisão alta sem adaptação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Discutir eficiência e trade-offs",
                                  "subSteps": [
                                    "Compare tabelas: passos, tempo CPU e erro para explícito vs. A-estável.",
                                    "Discuta custo por passo: explícito O(1), implícito O(n^2) para sistemas lineares n x n.",
                                    "Avalie quando explícito falha (ε pequeno) e A-estável vence.",
                                    "Mencione métodos modernos como BDF ou Runge-Kutta implícitos.",
                                    "Conclua recomendação baseada em ε e precisão desejada."
                                  ],
                                  "verification": "Escreva um relatório curto comparando métricas de eficiência para o exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Resultados das simulações anteriores, planilha para tabelas.",
                                  "tips": "Gráficos de erro vs. h log-log destacam regiões de eficiência.",
                                  "learningObjective": "Avaliar trade-offs entre estabilidade, custo computacional e precisão.",
                                  "commonMistakes": "Ignorar custo de solve linear em implícitos para sistemas grandes."
                                }
                              ],
                              "practicalExample": "Em um modelo químico de reação rápida-lenta: dy/dt = -k1 y / ε + k2 (1 - y), com ε=0.001, k1=k2=1. Euler explícito requer h<0.002 (500 passos), enquanto Backward Euler usa h=0.1 (10 passos), reduzindo tempo em 50x sem perda de precisão na dinâmica lenta.",
                              "finalVerifications": [
                                "Calcule corretamente h_max para ε dado em método explícito.",
                                "Simule instabilidade com h > 2ε e estabilidade com método A-estável.",
                                "Compare número de passos e tempo CPU quantitativamente.",
                                "Explique verbalmente por que A-estáveis mitigam rigidez.",
                                "Identifique autovalores dominantes em um exemplo stiff.",
                                "Discuta limitações de A-estáveis (ex: amortecimento excessivo)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de h_max e condições de estabilidade (30%).",
                                "Qualidade das simulações e gráficos comparativos (25%).",
                                "Profundidade da discussão conceitual sobre escalas e mitigação (20%).",
                                "Correta identificação de erros comuns e trade-offs (15%).",
                                "Clareza e estrutura do relatório final (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores amortecidos com rigidez (mecânica celeste).",
                                "Engenharia: Controle de sistemas (estabilidade em simulações de plantas industriais).",
                                "Computação: Otimização de algoritmos numéricos em solvers como SciPy odeint.",
                                "Química: Simulações de cinética reacional com escalas díspares."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD) para turbulência, onde escalas pequenas causam rigidez; métodos A-estáveis como BDF permitem simulações eficientes em aviões ou reatores químicos, reduzindo tempo de computação de dias para horas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Relacionar com controle de erro adaptativo",
                            "description": "Examinar como solvers adaptativos detectam rigidez via rejeições frequentes de passos, ajustando h para equilibrar precisão nas escalas rápida e lenta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Problemas Stiff e Controle de Erro Adaptativo",
                                  "subSteps": [
                                    "Defina problemas stiff como EDOs com escalas temporais muito diferentes (rápida e lenta).",
                                    "Explique separação de escalas: componentes que decaem rapidamente vs. evoluem lentamente.",
                                    "Descreva solvers adaptativos: usam estimadores de erro local para ajustar tamanho de passo h dinamicamente.",
                                    "Discuta tolerância de erro (tol): se erro estimado > tol, rejeita passo e reduz h.",
                                    "Ilustre com diagrama de escalas temporais em um problema modelo."
                                  ],
                                  "verification": "Resuma em um parágrafo como rigidez afeta passos fixos vs. adaptativos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notebook com Python/MATLAB"
                                  ],
                                  "tips": "Use gráficos de solução exata vs. numérica para visualizar discrepâncias.",
                                  "learningObjective": "Compreender a base teórica de rigidez e adaptação de passos.",
                                  "commonMistakes": "Confundir rigidez com não-linearidade; ignorar impacto em estabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Detecção de Rigidez via Rejeições Frequentes de Passos",
                                  "subSteps": [
                                    "Implemente um solver adaptativo simples (ex: RK4 com controle de erro).",
                                    "Simule um problema stiff: y' = -λ(y - f(t)), com λ grande (ex: 1000).",
                                    "Conte rejeições: quando erro > tol, rejeita e halve h.",
                                    "Registre frequência de rejeições em problemas stiff vs. não-stiff.",
                                    "Plote histórico de h e rejeições para visualizar detecção automática."
                                  ],
                                  "verification": "Gere gráfico mostrando >50% rejeições em região rígida.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com SciPy (solve_ivp)",
                                    "Exemplo de código para stiff ODE"
                                  ],
                                  "tips": "Comece com tol=1e-6; monitore contadores de aceitação/rejeição.",
                                  "learningObjective": "Identificar rigidez indiretamente por meio de métricas de solver.",
                                  "commonMistakes": "Atribuir rejeições apenas a tol muito restritiva, não a rigidez."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Ajuste de h para Equilibrar Precisão em Escalas Rápida e Lenta",
                                  "subSteps": [
                                    "Descreva algoritmo PID-like para h: h_new = h_old * factor (0.5-2.0 baseado em erro).",
                                    "Analise escala rápida: h pequeno para capturar transientes rápidos.",
                                    "Analise escala lenta: h maior após transiente para eficiência.",
                                    "Compare soluções com h fixo pequeno/grande vs. adaptativo.",
                                    "Calcule custo computacional (número de passos) para cada caso."
                                  ],
                                  "verification": "Demonstre que h adaptativo usa 2-5x mais passos que não-stiff, mas resolve stiff.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "MATLAB ode45 ou Python solve_ivp com stats",
                                    "Problema stiff exemplo"
                                  ],
                                  "tips": "Use eventos para detectar fim de transiente rápido.",
                                  "learningObjective": "Entender como adaptação equilibra precisão e eficiência.",
                                  "commonMistakes": "Achar que h pequeno sempre resolve; subestimar overhead de rejeições."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Relação entre Detecção de Rigidez e Controle Adaptativo",
                                  "subSteps": [
                                    "Crie fluxograma: rejeição → reduzir h → testar rigidez (rejeições > threshold).",
                                    "Discuta heurísticas: se rejeições > 20% em N passos, sinal de rigidez.",
                                    "Compare com solvers implícitos (ex: BDF) que lidam melhor com stiff.",
                                    "Teste em problema real: oscilador van der Pol com μ grande.",
                                    "Escreva relatório relacionando rejeições, h e escalas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a cadeia: rigidez → rejeições → ajuste h.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código fonte de solver adaptativo",
                                    "Ferramenta de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Automatize contadores em código para análise quantitativa.",
                                  "learningObjective": "Relacionar detecção automática com controle de erro.",
                                  "commonMistakes": "Ignorar que detecção é heurística, não exata."
                                }
                              ],
                              "practicalExample": "Considere y' = -1000(y - cos(t)) + sin(t), y(0)=1. Solvers adaptativos rejeitam passos iniciais devido à escala rápida (λ=1000), reduzindo h para ~1e-3, depois aumentam h na escala lenta, capturando o equilíbrio y≈cos(t).",
                              "finalVerifications": [
                                "Implementar e rodar solver adaptativo em problema stiff, mostrando histórico de h.",
                                "Identificar região de rigidez por pico de rejeições (>30%).",
                                "Comparar precisão e passos vs. h fixo.",
                                "Explicar por que h adaptativo resolve onde explícito falha.",
                                "Reproduzir gráfico de solução com escalas rápida/lenta destacadas.",
                                "Discutir limitação: custo alto em stiff severo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de detecção via rejeições (80%+ acerto).",
                                "Correta implementação/simulação com gráficos claros.",
                                "Análise quantitativa de h e rejeições em escalas.",
                                "Conexão explícita entre rigidez e adaptação.",
                                "Identificação de erros comuns em simulações.",
                                "Relatório conciso relacionando teoria e prática."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos diferenciais em dinâmica (ex: amortecimento rígido).",
                                "Computação: Algoritmos numéricos e análise de complexidade.",
                                "Engenharia: Simulações em controle de sistemas stiff.",
                                "Química Computacional: Cinética de reações com escalas múltiplas."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos (RC stiff), reações químicas rápidas/lentas (combustão), ou modelagem climática (escalas atmosfera/oceano), onde solvers adaptativos detectam e ajustam automaticamente para precisão sem intervenção manual."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Exemplos Clássicos de Problemas Stiff",
                        "description": "Estudar exemplos concretos como reações químicas rígidas e o oscilador de van der Pol, ilustrando as características de stiff em contextos reais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Analisar o exemplo de reações químicas rígidas",
                            "description": "Resolver numericamente o sistema y' = -k y + k z, z' = k y - k z com k >> 1, mostrando decaimento rápido para equilíbrio y = z e demonstrando falha de métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a formulação do problema e análise qualitativa",
                                  "subSteps": [
                                    "Leia e interprete o sistema de EDOs: y' = -k y + k z, z' = k y - k z.",
                                    "Identifique o equilíbrio estacionário resolvendo y' = 0 e z' = 0, mostrando que y = z.",
                                    "Analise o comportamento para k >> 1: decaimento rápido para o equilíbrio devido a escalas temporais separadas.",
                                    "Escolha condições iniciais, ex: y(0) = 1, z(0) = 0, e intervalo de tempo [0, 10].",
                                    "Desenhe um esboço qualitativo da solução esperada."
                                  ],
                                  "verification": "Confirme que o equilíbrio y = z é identificado e o decaimento rápido é descrito corretamente em um relatório curto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou editor de texto; referência ao livro de análise numérica.",
                                  "tips": "Pense em termos de modos rápidos (y - z) e lentos (y + z) para entender a rigidez.",
                                  "learningObjective": "Compreender a estrutura do problema stiff e seu comportamento qualitativo.",
                                  "commonMistakes": "Ignorar a dependência em k ou confundir o equilíbrio com solução trivial y=z=0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a solução analítica aproximada",
                                  "subSteps": [
                                    "Some as equações para obter (y + z)' = 0, implicando y + z = constante.",
                                    "Subtraia para obter (y - z)' = -2k (y - z), solução y - z = (y0 - z0) e^{-2k t}.",
                                    "Mostre que para k >> 1, y - z decai exponencialmente rápido para 0, levando a y ≈ z ≈ (y0 + z0)/2.",
                                    "Calcule numericamente alguns pontos para k=1000 e valide o decaimento.",
                                    "Compare com solução exata usando separação de variáveis se possível."
                                  ],
                                  "verification": "Gráfico ou tabela mostrando decaimento de |y - z| para < 10^{-6} em t pequeno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou Python com sympy para manipulação simbólica.",
                                  "tips": "Use transformação de variáveis w = y - z para simplificar.",
                                  "learningObjective": "Dominar a análise analítica de sistemas stiff lineares.",
                                  "commonMistakes": "Esquecer o fator 2k na taxa de decaimento ou assumir equilíbrio imediato."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar método numérico explícito e observar falha",
                                  "subSteps": [
                                    "Implemente o método de Euler explícito com passo h inicial razoável, ex: h=0.01.",
                                    "Escolha k=1000, integre até t=10 e plote y(t), z(t).",
                                    "Reduza h progressivamente (h=0.01, 0.001, 0.0001) e observe oscilações ou instabilidade.",
                                    "Compare com solução analítica para quantificar erro.",
                                    "Meça o tempo de computação e passos necessários para estabilidade."
                                  ],
                                  "verification": "Plots mostram oscilações espúrias em y-z para h não suficientemente pequeno.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com numpy, scipy.integrate.odeint (mas force Euler), matplotlib.",
                                  "tips": "Implemente Euler manualmente para controle total de h; use logscale no eixo y para ver decaimento.",
                                  "learningObjective": "Demonstrar empiricamente a falha de métodos explícitos em problemas stiff.",
                                  "commonMistakes": "Usar solver adaptativo em vez de explícito fixo; escolher k muito pequeno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar causas da rigidez e propor soluções",
                                  "subSteps": [
                                    "Explique a rigidez: autovalor -2k exige h << 1/(2k) para estabilidade no Euler.",
                                    "Calcule o passo de estabilidade: h < 1/(2k) ≈ 5e-4 para k=1000.",
                                    "Teste método implícito simples, ex: Backward Euler, mostrando estabilidade com h maior.",
                                    "Compare eficiência: número de passos e precisão.",
                                    "Documente em relatório com gráficos lado a lado."
                                  ],
                                  "verification": "Relatório explica limitação CFL-like e mostra convergência com implícito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo ambiente Python; adicione implementação de Backward Euler.",
                                  "tips": "Para implícito, resolva sistema linear 2x2 por iteração ou numpy.linalg.solve.",
                                  "learningObjective": "Identificar raízes da rigidez e necessidade de métodos implícitos.",
                                  "commonMistakes": "Atribuir falha só a 'erro de truncamento' sem mencionar estabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar resultados e verificações finais",
                                  "subSteps": [
                                    "Compile todos plots, tabelas e análises em um dashboard ou relatório.",
                                    "Verifique reprodução da solução analítica com método adequado.",
                                    "Discuta generalizações para reações químicas reais.",
                                    "Autoavalie usando critérios de assessment.",
                                    "Salve código e resultados para portfólio."
                                  ],
                                  "verification": "Dashboard completo com evidências de decaimento rápido e falha explícita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Jupyter notebook para integração.",
                                  "tips": "Use subplots para comparações diretas.",
                                  "learningObjective": "Integrar análise teórica e numérica em uma narrativa coerente.",
                                  "commonMistakes": "Plots sem legendas ou escalas inadequadas."
                                }
                              ],
                              "practicalExample": "Simule reações químicas A ⇌ B com k=1000, y=[A], z=[B], y(0)=1, z(0)=0. Método explícito com h=0.01 mostra oscilações; analítico confirma equilíbrio y=z=0.5 após t~0.01.",
                              "finalVerifications": [
                                "Solução numérica captura decaimento rápido de |y-z| para <1e-6 em t<0.01.",
                                "Método explícito exibe oscilações ou divergência para h>1/(2k).",
                                "Solução analítica derivada corretamente e matches numérico estável.",
                                "Gráficos mostram trajetórias y(t), z(t) e y-z(t) com escalas apropriadas.",
                                "Eficiência comparada: implícito usa 10x menos passos que explícito estável.",
                                "Relatório explica rigidez via autovalores."
                              ],
                              "assessmentCriteria": [
                                "Precisão da análise qualitativa e analítica (30%).",
                                "Correta implementação e demonstração de falha explícita (25%).",
                                "Qualidade de plots e comparações visuais (20%).",
                                "Explicação clara de causas da rigidez (15%).",
                                "Relatório estruturado e código comentado (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Química: Modelagem de cinética química com escalas múltiplas.",
                                "Física: Sistemas com relaxação rápida, ex: osciladores amortecidos.",
                                "Computação: Algoritmos numéricos e estabilidade de esquemas.",
                                "Engenharia: Simulações em controle de processos rígidos."
                              ],
                              "realWorldApplication": "Modelagem precisa de reações químicas em indústrias farmacêutica e petroquímica, onde k grande representa equilibrios rápidos; solvers stiff como CVODE em software industrial evitam crashes em simulações de reatores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Explorar o oscilador de van der Pol stiff",
                            "description": "Implementar e simular y'' - μ (1 - y²) y' + y = 0 com μ >> 1, observando camadas de fronteira rápidas e relaxação lenta, e comparando métodos explícitos vs. implícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o oscilador de van der Pol em sistema de primeira ordem",
                                  "subSteps": [
                                    "Estude a equação diferencial y'' - μ(1 - y²)y' + y = 0 e identifique o parâmetro μ >> 1 para regime stiff.",
                                    "Reescreva a equação como um sistema de EDOs de primeira ordem: defina y1 = y, y2 = y', resultando em y1' = y2, y2' = μ(1 - y1²)y2 - y1.",
                                    "Escolha valores iniciais típicos, como y(0) = 2, y'(0) = 0, e μ = 1000.",
                                    "Discuta conceitualmente as camadas de fronteira rápidas (transições abruptas) e relaxação lenta (oscilações suaves).",
                                    "Implemente uma função em Python/MATLAB para definir o sistema vetorial f(t, y)."
                                  ],
                                  "verification": "Confirme que o sistema está corretamente escrito e que f(t, y) reproduz a equação original para μ pequeno e grande.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de EDOs stiff",
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use sympy para verificar simbolicamente a derivação do sistema.",
                                  "learningObjective": "Compreender e linearizar o problema de segunda ordem em primeira ordem para preparação numérica.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo em y2'",
                                    "Confundir y1 e y2 nas derivadas",
                                    "Não escalar μ corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e simular com método explícito (RK4)",
                                  "subSteps": [
                                    "Implemente o método de Runge-Kutta de ordem 4 (RK4) para resolver o sistema.",
                                    "Escolha intervalo de tempo [0, 1000] e teste passos h = 0.01, 0.001.",
                                    "Plote y(t), y'(t) e o retrato de fase (y vs y').",
                                    "Observe instabilidades ou lentidão para h inadequado devido ao stiff.",
                                    "Registre o tempo de computação e número de passos necessários para estabilidade."
                                  ],
                                  "verification": "Simulação converge para órbita limite estável sem explosão numérica para h pequeno.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca SciPy odeint ou código RK4 customizado",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Use h adaptativo inicialmente para benchmark, mas fixe para comparação.",
                                  "learningObjective": "Aplicar método explícito e identificar limitações em problemas stiff.",
                                  "commonMistakes": [
                                    "Passo h muito grande causando divergência",
                                    "Não plotar retrato de fase",
                                    "Ignorar tempo de CPU"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar dificuldades do método explícito e características stiff",
                                  "subSteps": [
                                    "Identifique a razão de escalas: estimativa da largura da camada rápida ~1/μ e período lento ~O(1).",
                                    "Meça o passo h mínimo estável via experimentos (h < 2/μ approx).",
                                    "Compare simulações com μ=1 (não-stiff) vs μ=1000, destacando rigidez.",
                                    "Descreva visualmente as camadas rápidas (saltos verticais no phase plane) e relaxação lenta (arcos suaves).",
                                    "Calcule o expoente de Lipschitz para confirmar stiff (λ_max >> λ_min)."
                                  ],
                                  "verification": "Relatório com plots mostrando discrepâncias e explicação qualitativa das dinâmicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Plots anteriores",
                                    "Ferramentas de análise espectral como eigvals em SciPy"
                                  ],
                                  "tips": "Amplie plots perto das camadas rápidas para visualização clara.",
                                  "learningObjective": "Reconhecer signatures de problemas stiff e escalas múltiplas.",
                                  "commonMistakes": [
                                    "Confundir relaxação com oscilações lineares",
                                    "Não quantificar rigidez"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar método implícito e comparar",
                                  "subSteps": [
                                    "Implemente Backward Euler ou trapezoidal implícito, resolvendo via fsolve/newton.",
                                    "Use mesmo [0,1000], h=0.1 (maior que explícito).",
                                    "Plote soluções lado a lado com RK4 e compare precisão/eficiência.",
                                    "Meça redução no número de passos e tempo de CPU.",
                                    "Valide com solução de referência (μ pequeno ou solver built-in como solve_ivp(method='BDF'))."
                                  ],
                                  "verification": "Método implícito permite h 100x maior, com órbitas coincidentes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SciPy fsolve ou scipy.integrate.solve_ivp('BDF')",
                                    "Códigos anteriores"
                                  ],
                                  "tips": "Para custom implícito, use Jacobiano analítico para aceleração.",
                                  "learningObjective": "Dominar solvers implícitos para stiff e quantificar vantagens.",
                                  "commonMistakes": [
                                    "Não convergência do solver não-linear",
                                    "Esquecer Jacobiano",
                                    "Comparação injusta de h"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar observações e visualizar dinâmicas",
                                  "subSteps": [
                                    "Crie animação ou plots overlay das trajetórias rápidas/lentas.",
                                    "Compare erro global e local entre métodos.",
                                    "Discuta trade-offs: explícito (simples, não-stiff) vs implícito (robusto, custo por passo).",
                                    "Extraia lições para problemas stiff gerais.",
                                    "Documente código em relatório com conclusões."
                                  ],
                                  "verification": "Relatório final com plots comparativos e métricas quantitativas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Todos códigos e plots",
                                    "Ferramentas de animação como Matplotlib FuncAnimation"
                                  ],
                                  "tips": "Salve seeds para reprodutibilidade.",
                                  "learningObjective": "Integrar análise qualitativa e quantitativa para insight profundo.",
                                  "commonMistakes": [
                                    "Plots não sincronizados",
                                    "Conclusões sem dados"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o oscilador com μ=1000, y(0)=2, y'(0)=0 em t=[0,2000]. RK4 requer h=0.0005 (4M passos, 10s CPU), enquanto BDF usa h=0.1 (20k passos, 2s CPU), ambos convergindo para loop limite com saltos rápidos de y~2→-2 e arcos lentos.",
                              "finalVerifications": [
                                "Sistema de EDOs correto e reproduz equação original.",
                                "Plots de phase plane mostram camadas rápidas (quase verticais) e relaxação lenta.",
                                "Método explícito falha ou é lento para h razoável, implícito succeeds.",
                                "Comparação quantitativa: h_min explícito ~1/μ, implícito O(1).",
                                "Relatório explica stiff via escalas múltiplas.",
                                "Código executável e reprodutível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática (20%)",
                                "Implementação correta de solvers (30%)",
                                "Análise visual e quantitativa das dinâmicas (20%)",
                                "Comparação robusta explícito vs implícito (15%)",
                                "Clareza do relatório e código (10%)",
                                "Insight sobre stiff problems (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos não-lineares (van der Pol como oscilador relaxação).",
                                "Engenharia: Simulações em controle e eletrônica stiff.",
                                "Computação: Otimização numérica e solvers não-lineares.",
                                "Biologia: Modelos de excitação neuronal com fronts rápidos.",
                                "Matemática Aplicada: Análise assintótica de singular perturbations."
                              ],
                              "realWorldApplication": "Modelagem de circuitos osciladores em eletrônica (rádios, relógios), dinâmica de lasers, ritmos cardíacos em fisiologia, e simulações climáticas/reatores químicos com escalas múltiplas rápidas/lentas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Identificar stiff em problemas de difusão-reação",
                            "description": "Discutir exemplos de LeVeque (2007) onde termos de reação rígida dominam a difusão, requerendo métodos para EDOs stiff em semi-discretizações de PDEs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Problemas de Difusão-Reação",
                                  "subSteps": [
                                    "Estude a forma geral da PDE de difusão-reação: ∂u/∂t = D ∂²u/∂x² + R(u), onde D é o coeficiente de difusão e R(u) é o termo de reação.",
                                    "Analise escalas físicas: compare taxas de difusão (escala ~√(D t)) com taxas de reação (escala ~1/|R'(u)|).",
                                    "Identifique casos onde reação domina (R'(u) >> D/L², L comprimento característico).",
                                    "Discuta implicações numéricas: passos de tempo explícitos limitados pela estabilidade.",
                                    "Resolva analiticamente um caso simples sem reação para baseline."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como a reação pode dominar a difusão em termos de escalas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro LeVeque (2007), capítulos iniciais sobre PDEs",
                                    "Caderno para anotações",
                                    "Software como MATLAB ou Python (NumPy) para plotar soluções básicas"
                                  ],
                                  "tips": "Sempre normalize as equações para destacar escalas adimensionais (número de Damköhler).",
                                  "learningObjective": "Compreender a estrutura matemática e física de problemas de difusão-reação.",
                                  "commonMistakes": [
                                    "Confundir difusão com advecção",
                                    "Ignorar dependência não-linear em R(u)",
                                    "Não considerar unidades físicas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Semi-Discretização de PDEs em Sistemas de EDOs",
                                  "subSteps": [
                                    "Aplique método de diferenças finitas espaciais: discretize ∂²u/∂x² → (u_{i+1} - 2u_i + u_{i-1})/Δx².",
                                    "Obtenha sistema semi-discreto: du/dt = A u + R(u), onde A é matriz de difusão (tridiagonal).",
                                    "Analise autovalores de A: λ_max ~ -4D/Δx² (negativos, rígidos para Δx pequeno).",
                                    "Incorpore termo R(u): discuta quando |R'(u)| >> |λ_max| torna o sistema stiff.",
                                    "Implemente código simples para semi-discretização de um problema linear."
                                  ],
                                  "verification": "Gere e plote a matriz A para uma grade com N=10 pontos e verifique autovalores.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "LeVeque (2007), Seção 2.3-2.4",
                                    "MATLAB/Python com SciPy para autovalores",
                                    "Grid de 1D exemplo (x de 0 a 1)"
                                  ],
                                  "tips": "Use grades finas (Δx pequeno) para observar rigidez na difusão primeiro.",
                                  "learningObjective": "Dominar como PDEs viram EDOs stiff via semi-discretização.",
                                  "commonMistakes": [
                                    "Erros na discretização (falta de simetria em A)",
                                    "Confundir autovalores com passos de tempo",
                                    "Não linearizar R(u) corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos Específicos de LeVeque (2007)",
                                  "subSteps": [
                                    "Leia Seção 5.4 de LeVeque: exemplos de difusão-reação com reações rígidas (e.g., R(u) = k u (1-u), k >>1).",
                                    "Simule numericamente: compare soluções explícitas (forward Euler) vs. implícitas para k grande.",
                                    "Identifique stiff: observe oscilações ou instabilidade em métodos explícitos.",
                                    "Extraia condições: quando τ_reação =1/|R'(u)| << τ_difusão = Δx²/D.",
                                    "Compare com exemplo não-stiff (k pequeno)."
                                  ],
                                  "verification": "Produza gráficos mostrando falha de método explícito para k=1000 vs. sucesso para k=1.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "LeVeque (2007), páginas 150-160",
                                    "Código MATLAB/Python pronto (adaptar de repositórios GitHub)",
                                    "Parâmetros: D=1, k=1 a 10^6"
                                  ],
                                  "tips": "Varie k logaritmicamente para visualizar transição para stiff.",
                                  "learningObjective": "Aplicar exemplos de LeVeque para reconhecer dominação de reação rígida.",
                                  "commonMistakes": [
                                    "Passos de tempo inadequados sem análise de estabilidade",
                                    "Ignorar condições iniciais frontais",
                                    "Não escalar adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Rigidez e Selecionar Métodos para EDOs Stiff",
                                  "subSteps": [
                                    "Defina critérios de stiff: razão de escalas |λ_stiff| / |λ_difusão| >>1, onde λ_stiff ~ R'(u).",
                                    "Teste em exemplo LeVeque: compute razão cond( Jacobian ).",
                                    "Discuta métodos: Backward Euler, BDFs, Rosenbrock para semi-explícito.",
                                    "Implemente solver stiff (ode15s MATLAB ou solve_ivp method='BDF').",
                                    "Valide: compare com solução referência (k pequeno)."
                                  ],
                                  "verification": "Classifique um novo problema como stiff ou não, justificando com cálculos de escalas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "LeVeque (2007), Capítulo 5",
                                    "Documentação ODE solvers (MATLAB ode23s, Python SciPy)",
                                    "Exemplo novo: R(u)=k u^2 (1-u)"
                                  ],
                                  "tips": "Sempre cheque razão de escalas antes de escolher solver.",
                                  "learningObjective": "Identificar stiff em difusão-reação e escolher métodos apropriados.",
                                  "commonMistakes": [
                                    "Usar métodos explícitos em stiff sem testar",
                                    "Não verificar convergência",
                                    "Confundir stiff com não-linearidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o problema de LeVeque (2007, p.152): ∂u/∂t = ∂²u/∂x² + k u (1-u), x∈[0,1], t>0, u(0,t)=u(1,t)=0, u(x,0)=sin(πx), com k=10^5. A reação rígida (taxa ~k) domina a difusão (taxa ~π²), causando stiff nas EDOs semi-discretas; forward Euler falha com Δt>10^-5, mas BDF succeeds.",
                              "finalVerifications": [
                                "Descreva verbalmente um exemplo de LeVeque onde reação rígida domina.",
                                "Compute escalas de tempo para um problema dado e classifique como stiff.",
                                "Implemente semi-discretização e rode solver explícito vs. implícito, explicando diferenças.",
                                "Identifique autovalores dominantes no Jacobian linearizado.",
                                "Explique por que métodos para EDOs stiff são necessários em PDEs semi-discretas.",
                                "Gere gráfico comparativo para k=1 vs. k=10^4."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de dominação reação-difusão (razão escalas >10^3).",
                                "Correta implementação de semi-discretização (matriz A simétrica negativa definida).",
                                "Análise qualitativa/quantitativa de exemplos LeVeque.",
                                "Seleção adequada de solvers stiff com justificativa.",
                                "Gráficos e simulações sem erros numéricos evidentes.",
                                "Explicação clara de implicações para estabilidade numérica."
                              ],
                              "crossCurricularConnections": [
                                "Química: Cinética química em reatores (reações rápidas vs. difusão).",
                                "Física: Transporte em meios porosos ou combustão (frentes de deflagração).",
                                "Engenharia Química: Modelagem de biorreatores com cinética Michaelis-Menten.",
                                "Computação Científica: Desenvolvimento de solvers adaptativos para PDEs."
                              ],
                              "realWorldApplication": "Em modelagem de combustão, onde reações químicas são ordens de magnitude mais rápidas que difusão térmica, identificando stiff permite usar solvers implícitos eficientes para simular frentes de chama em motores ou incêndios florestais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.4",
                            "name": "Classificar exemplos pela razão de rigidez",
                            "description": "Calcular a razão de rigidez como max|Re(λ)| / min|Re(λ)| em autovalores e classificá-los como moderadamente ou altamente stiff, usando referências como Burden & Faires.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Razão de Rigidez em Problemas Stiff",
                                  "subSteps": [
                                    "Ler a seção sobre problemas stiff no livro Burden & Faires, focando na definição de rigidez baseada em autovalores.",
                                    "Identificar que a razão de rigidez é definida como max|Re(λ)| / min|Re(λ)|, onde λ são os autovalores da matriz jacobiana.",
                                    "Memorizar thresholds típicos: moderadamente stiff (razão entre 10³ e 10⁶), altamente stiff (razão > 10⁶).",
                                    "Explicar verbalmente ou por escrito por que autovalores com partes reais muito diferentes causam rigidez.",
                                    "Resolver um exercício simples: dado λ1 = -1, λ2 = -1000, calcular razão = 1000."
                                  ],
                                  "verification": "Resumir em 3-5 frases o conceito e calcular corretamente a razão para um exemplo dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Numerical Analysis' de Burden & Faires (9ª ou 10ª ed.), caderno de anotações.",
                                  "tips": "Foque nas partes reais (Re(λ)); ignore partes imaginárias para rigidez.",
                                  "learningObjective": "Dominar a definição e thresholds da razão de rigidez.",
                                  "commonMistakes": "Confundir |Re(λ)| com módulo completo |λ|; usar valores absolutos incorretos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Configurar Exemplos Clássicos de Problemas Stiff",
                                  "subSteps": [
                                    "Listar 3 exemplos clássicos: sistema linear y' = A y com A diagonal (-1, -10^4), equação de van der Pol (μ=1000), problema de Oregonator.",
                                    "Para problemas não-lineares, linearizar em torno de um ponto de equilíbrio para obter matriz jacobiana.",
                                    "Implementar em software: definir matriz A ou função jacobiana.",
                                    "Verificar estabilidade: todos Re(λ) < 0 para problemas stiff dissipativos.",
                                    "Preparar planilha ou script com matrizes para 2-3 exemplos."
                                  ],
                                  "verification": "Documentar 3 exemplos com suas matrizes jacobianas ou descrições claras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, exemplos do livro Burden & Faires.",
                                  "tips": "Comece com sistemas lineares para validação antes de não-lineares.",
                                  "learningObjective": "Preparar exemplos representativos de diferentes níveis de rigidez.",
                                  "commonMistakes": "Escolher exemplos não-stiff (razão <10²); ignorar linearização para não-lineares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Autovalores e Razão de Rigidez",
                                  "subSteps": [
                                    "Usar função eig() no MATLAB ou np.linalg.eig() no Python para computar autovalores.",
                                    "Extrair partes reais Re(λ) para todos autovalores.",
                                    "Identificar max|Re(λ)| e min|Re(λ)| (notando que Re(λ)<0, min é o mais negativo).",
                                    "Calcular razão = max|Re(λ)| / min|Re(λ)| numericamente e analiticamente se possível.",
                                    "Repetir para todos exemplos e registrar resultados em tabela."
                                  ],
                                  "verification": "Tabela com autovalores, Re(λ), max/min e razão calculada corretamente para cada exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python/MATLAB instalado, scripts de exemplo prontos.",
                                  "tips": "Valide com autovalores conhecidos para matrizes diagonais.",
                                  "learningObjective": "Executar cálculo preciso de autovalores e razão de rigidez.",
                                  "commonMistakes": "Usar min|Re(λ)| como o menor em magnitude ao invés do maior (mais negativo); erros de sintaxe em código."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar Exemplos e Justificar com Referências",
                                  "subSteps": [
                                    "Comparar cada razão calculada aos thresholds: moderadamente stiff (10³-10⁶), altamente stiff (>10⁶).",
                                    "Classificar cada exemplo e citar Burden & Faires para suporte.",
                                    "Discutir implicações: necessidade de métodos implícitos para altamente stiff.",
                                    "Criar relatório curto com classificações e razões.",
                                    "Comparar classificações entre exemplos."
                                  ],
                                  "verification": "Relatório com classificações corretas e justificativas para todos exemplos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Livro Burden & Faires, tabela de resultados do step 3.",
                                  "tips": "Use log10(razão) para visualizar escala; consulte apêndices do livro para exemplos.",
                                  "learningObjective": "Aplicar classificação e conectar a métodos numéricos apropriados.",
                                  "commonMistakes": "Classificações subjetivas sem thresholds; ignorar referências bibliográficas."
                                }
                              ],
                              "practicalExample": "Considere o sistema linear y' = A y com A = diag(-1, -5000). Autovalores λ1=-1, λ2=-5000. Re(λ): -1 e -5000. max|Re(λ)|=5000, min|Re(λ)|=1 (magnitude). Razão=5000/1=5000 → moderadamente stiff. Em Python: import numpy as np; A=np.diag([-1,-5000]); eigvals=np.linalg.eigvals(A); re_parts=np.real(eigvals); ratio=np.max(np.abs(re_parts))/np.min(np.abs(re_parts)).",
                              "finalVerifications": [
                                "Cálculo correto de autovalores para todos exemplos.",
                                "Razões de rigidez computadas sem erros numéricos.",
                                "Classificações consistentes com thresholds (moderado/alto).",
                                "Referências a Burden & Faires incluídas.",
                                "Tabela comparativa de exemplos clara e completa.",
                                "Código ou cálculos manuais validados."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de autovalores (erro <1e-10).",
                                "Correta identificação de max/min |Re(λ)|.",
                                "Classificação alinhada a thresholds padrão.",
                                "Justificativa teórica robusta com referências.",
                                "Análise comparativa entre exemplos.",
                                "Clareza na documentação e código.",
                                "Compreensão demonstrada em relatório."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores amortecidos com escalas rápidas/lentas.",
                                "Química: Cinética de reações com mecanismos stiff (e.g., combustão).",
                                "Engenharia: Sistemas de controle com pólos dominantes.",
                                "Computação: Otimização de solvers numéricos em SciPy/ODEPACK."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas (e.g., modelagem de poluição atmosférica), onde espécies rápidas (altos |Re(λ)|) e lentas causam rigidez; classificação guia escolha de solvers implícitos como BDF em software como COMSOL ou MATLAB ODE15s para eficiência computacional."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Estabilidade e Região de Estabilidade",
                    "description": "Análise da estabilidade absoluta de métodos numéricos no plano complexo hλ.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Estabilidade Absoluta",
                        "description": "Definição e análise da estabilidade absoluta de métodos numéricos para EDOs, baseada na equação teste de Dahlquist y' = λy, onde a solução numérica deve permanecer limitada para Re(λ) < 0, garantindo que o erro não cresça exponencialmente.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Definir estabilidade absoluta",
                            "description": "Explicar a definição formal de estabilidade absoluta usando a equação teste y' = λy com Re(λ) < 0, e a condição de que a solução numérica y_n satisfaça |y_n| ≤ K para algum K independente de n, quando h|λ| é pequeno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema Teste Linear y' = λy",
                                  "subSteps": [
                                    "Escrever a equação diferencial y' = λy e identificar y(0) = y₀ como condição inicial.",
                                    "Explicar que λ é um escalar complexo com parte real Re(λ) < 0, representando decaimento exponencial.",
                                    "Discutir por que este modelo é usado para testar estabilidade em problemas stiff.",
                                    "Resolver analiticamente para t pequeno, mostrando y(t) ≈ y₀ (1 + λt).",
                                    "Visualizar graficamente o comportamento de decaimento quando Re(λ) < 0."
                                  ],
                                  "verification": "Capacidade de escrever a equação, derivar a aproximação linear e explicar o papel de Re(λ) < 0 verbalmente ou por escrito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráfica online como Desmos ou GeoGebra",
                                    "Livro de Análise Numérica (capítulo de ODEs)"
                                  ],
                                  "tips": [
                                    "Sempre verifique Re(λ) < 0 para garantir decaimento; use exemplos numéricos como λ = -1 + 0i."
                                  ],
                                  "learningObjective": "Entender o problema modelo e sua relevância para análise de estabilidade.",
                                  "commonMistakes": [
                                    "Assumir λ real positivo (leva a crescimento)",
                                    "Ignorar a parte imaginária de λ",
                                    "Confundir com problemas não lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Solução Exata e Comportamento Assintótico",
                                  "subSteps": [
                                    "Derivar a solução exata y(t) = y₀ exp(λ t) usando separação de variáveis.",
                                    "Provar que lim_{t→∞} |y(t)| = 0 quando Re(λ) < 0.",
                                    "Calcular |y(t)| = |y₀| exp(Re(λ) t) para mostrar acoplamento.",
                                    "Discutir discretização temporal com passo h: t_n = n h.",
                                    "Comparar solução contínua vs. discreta para h pequeno."
                                  ],
                                  "verification": "Derivação correta da solução exata e prova gráfica ou analítica de |y(t)| → 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica como Wolfram Alpha",
                                    "Software MATLAB ou Python (SymPy)",
                                    "Folha de exercícios pré-preparada"
                                  ],
                                  "tips": [
                                    "Expanda exp(λ t) em série de Taylor para insights locais; foque em Re(λ) para magnitude."
                                  ],
                                  "learningObjective": "Dominar a dinâmica exata do problema teste e estabelecer baseline para estabilidade numérica.",
                                  "commonMistakes": [
                                    "Erro na integração: y' = λy implica dy/y = λ dt",
                                    "Esquecer |exp(λ t)| = exp(Re(λ) t)",
                                    "Não considerar h → 0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Soluções Numéricas y_n e Condições Iniciais",
                                  "subSteps": [
                                    "Definir a iteração numérica genérica: y_{n+1} = R(h λ) y_n, onde R(z) é a função de amplificação.",
                                    "Explicar que y_n = [R(h λ)]^n y₀ para o problema linear.",
                                    "Discutir requisito para estabilidade: |y_n| não explodir com n → ∞.",
                                    "Introduzir noção de h |λ| pequeno (regime de passos finos).",
                                    "Testar com exemplo simples: λ = -1, h = 0.1, n=100."
                                  ],
                                  "verification": "Implementar iteração manual para 5 passos e verificar |y_n| bounded.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para iterações",
                                    "Python/Jupyter Notebook básico",
                                    "Tabela de valores pré-calculados"
                                  ],
                                  "tips": [
                                    "Comece com |R(z)| ≤ 1 para z = hλ pequeno; evite h grande inicialmente."
                                  ],
                                  "learningObjective": "Conectar discretização numérica ao problema contínuo e identificar risco de instabilidade.",
                                  "commonMistakes": [
                                    "Confundir R(hλ) com exp(hλ)",
                                    "Não elevar à potência n corretamente",
                                    "Usar h|λ| >1 prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a Definição de Estabilidade Absoluta",
                                  "subSteps": [
                                    "Definir estabilidade absoluta: existe K > 0 independente de n tal que |y_n| ≤ K |y₀| para todo n, quando Re(λ) < 0 e h|λ| pequeno.",
                                    "Provar que isso requer |R(z)| ≤ 1 + O(|z|) para z → 0.",
                                    "Relacionar com região de estabilidade {z : |R(z)| ≤ 1}.",
                                    "Discutir implicações para problemas stiff (λ grande negativo).",
                                    "Verificar com método de Euler forward: R(z) = 1 + z (instável para z real negativo grande)."
                                  ],
                                  "verification": "Escrever definição formal e aplicar a um método numérico específico, mostrando boundedness.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo ou slide sobre região de estabilidade",
                                    "Software para plotar |R(z)| no plano complexo",
                                    "Exercícios de verificação"
                                  ],
                                  "tips": [
                                    "Estabilidade absoluta é local (h pequeno); para global, veja A-stability.",
                                    "Use diagrama de Dahlquist para visualização."
                                  ],
                                  "learningObjective": "Articular precisamente a definição e suas condições.",
                                  "commonMistakes": [
                                    "Omitir 'independente de n' ou 'h|λ| pequeno'",
                                    "Confundir com consistência",
                                    "Aplicar a métodos não lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere y' = -10 y, y(0)=1 (stiff, λ=-10). Para Euler forward com h=0.01 (h|λ|=0.1 pequeno): y1=1-0.1=0.9, y2=0.81, ..., |yn| diminui bounded. Aumente h=0.2 (h|λ|=2): y1=0.8, mas iterações explodem após poucas passos, ilustrando falha em estabilidade absoluta.",
                              "finalVerifications": [
                                "Escrever a equação teste y' = λy com Re(λ)<0.",
                                "Derivar y(t)=y0 exp(λt) e provar |y(t)|→0.",
                                "Definir formalmente estabilidade absoluta com |yn|≤K independente de n.",
                                "Explicar condição h|λ| pequeno e função R(z).",
                                "Aplicar a Euler forward e identificar instabilidade.",
                                "Plotar ou calcular exemplo numérico com bounded vs. unbounded."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% match com equação e condições).",
                                "Correta derivação da solução exata e análise de magnitude.",
                                "Compreensão de R(hλ) e boundedness de [R]^n.",
                                "Uso correto de h|λ| pequeno em exemplos.",
                                "Identificação de erros comuns em métodos explícitos.",
                                "Clareza em explicações verbais ou escritas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de decaimento radioativo ou amortecimento em osciladores.",
                                "Engenharia: Simulações de sistemas de controle com pólos no semiplano esquerdo.",
                                "Computação Científica: Implementação de solvers ODE em bibliotecas como SciPy.",
                                "Química: Equações stiff em cinética de reações.",
                                "Matemática Aplicada: Teoria de perturbações e análise assintótica."
                              ],
                              "realWorldApplication": "Em simulações numéricas de problemas stiff como reações químicas rápidas/lentas ou circuitos elétricos RC grandes, estabilidade absoluta garante que passos h pequenos mantenham soluções bounded, evitando crashes em software como MATLAB ODE solvers ou simulações climáticas com escalas múltiplas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Calcular fator de amplificação",
                            "description": "Derivar e calcular o fator de amplificação R(hλ) = 1 + hλ para o método de Euler explícito aplicado à equação teste, verificando |R(hλ)| ≤ 1 para estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação teste e o método de Euler explícito",
                                  "subSteps": [
                                    "Lembre-se da equação diferencial modelo y' = λ y, onde λ é um escalar complexo com Re(λ) < 0 para problemas dissipativos.",
                                    "Descreva o esquema de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n), com f(t,y) = λ y.",
                                    "Explique o conceito de fator de amplificação como o multiplicador na recursão y_{n+1} = R(hλ) y_n.",
                                    "Discuta a importância da estabilidade absoluta para problemas stiff.",
                                    "Anote os requisitos para estabilidade: |R(hλ)| ≤ 1 para todos os autovalores λ do sistema."
                                  ],
                                  "verification": "Escreva a fórmula do Euler explícito aplicada à equação teste e identifique a forma recursiva y_{n+1} = R y_n.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, livro de análise numérica (capítulo de métodos lineares), calculadora.",
                                  "tips": "Visualize λ no semiplano esquerdo do plano complexo para contextualizar problemas stiff.",
                                  "learningObjective": "Compreender a equação teste e como o Euler explícito a discretiza.",
                                  "commonMistakes": "Confundir Euler explícito com implícito; esquecer que λ pode ser complexo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o fator de amplificação R(hλ)",
                                  "subSteps": [
                                    "Substitua f(y) = λ y no esquema: y_{n+1} = y_n + h λ y_n.",
                                    "Fatore o termo comum: y_{n+1} = (1 + h λ) y_n.",
                                    "Identifique R(hλ) = 1 + h λ como o fator de amplificação.",
                                    "Verifique simbolicamente para y_n ≠ 0, confirmando a recursão exata.",
                                    "Discuta como R depende apenas de hλ, o argumento de estabilidade."
                                  ],
                                  "verification": "Derive algebricamente R(hλ) e escreva y_n = [R(hλ)]^n y_0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para derivação, software simbólico como SymPy (opcional).",
                                  "tips": "Use notação z = hλ para simplificar; z é o parâmetro de estabilidade.",
                                  "learningObjective": "Derivar precisamente o fator de amplificação para Euler explícito.",
                                  "commonMistakes": "Esquecer o h na multiplicação ou derivar erroneamente como 1 + λ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular R(hλ) e verificar a condição de estabilidade |R| ≤ 1",
                                  "subSteps": [
                                    "Calcule |R(hλ)| = |1 + hλ| para λ real negativo primeiro (caso 1D).",
                                    "Para estabilidade, resolva |1 + hλ| ≤ 1, obtendo -2 ≤ hλ ≤ 0.",
                                    "Estenda para λ complexo: |1 + z| ≤ 1 onde z = hλ, Re(z) < 0.",
                                    "Desenhe a região de estabilidade no plano z: disco unitário centrado em -1.",
                                    "Teste numericamente com exemplos: hλ = -0.5 → |1-0.5|=0.5 ≤1; hλ=-1.5 → |1-1.5|=0.5≤1; hλ=-3 → |1-3|=2>1 instável."
                                  ],
                                  "verification": "Resolva a desigualdade |1 + hλ| ≤ 1 e identifique h ≤ 2/|λ| para λ real negativo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora gráfica, papel quadriculado para plotar região de estabilidade.",
                                  "tips": "Comece com λ real para intuição, depois generalize para complexo.",
                                  "learningObjective": "Calcular |R| e determinar condições para estabilidade absoluta.",
                                  "commonMistakes": "Ignorar o módulo complexo; calcular apenas para valores reais sem generalizar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar implicações para problemas stiff",
                                  "subSteps": [
                                    "Explique por que Euler explícito falha em stiff: região pequena (|hλ|≤2).",
                                    "Compare com métodos implícitos que têm região maior.",
                                    "Calcule passo h máximo para estabilidade: h < 2/|λ_max| onde λ_max é autovalor mais negativo.",
                                    "Discuta trade-off: precisão vs. restrição em h para stiff problems.",
                                    "Resuma: R(hλ)=1+hλ limita aplicações práticas em simulações reais."
                                  ],
                                  "verification": "Para um problema com λ=-100, calcule h_max ≈ 0.02 e discuta viabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplos de problemas stiff de um textbook, MATLAB/Octave para plotar.",
                                  "tips": "Ligue à solução exata y(t)=y0 exp(λ t), que decai rapidamente para Re(λ)<0.",
                                  "learningObjective": "Aplicar o conceito de estabilidade a contextos stiff.",
                                  "commonMistakes": "Confundir estabilidade absoluta com relativa; superestimar região de Euler."
                                }
                              ],
                              "practicalExample": "Considere y' = -50 y, y(0)=1 (stiff). Para Euler explícito, R(h*(-50)) = 1 -50h. Estável se |1-50h|≤1 → h≤0.04. Simule com h=0.03: y1=(1-1.5)*1=-0.5 (ok); h=0.05: y1=(1-2.5)*1=-1.5, |R|=1.5>1, oscila e diverge.",
                              "finalVerifications": [
                                "Deriva corretamente R(hλ)=1+hλ a partir do esquema de Euler.",
                                "Calcula |R(hλ)| e resolve |1+hλ|≤1 para λ real e complexo.",
                                "Identifica a região de estabilidade como o disco |z+1|≤1.",
                                "Explica por que Euler é inadequado para problemas stiff.",
                                "Aplica a condição para determinar h máximo em um exemplo numérico.",
                                "Desenha ou descreve graficamente a região de estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica de R(hλ) (100% correto).",
                                "Correta resolução da desigualdade |R|≤1 e identificação de h_max.",
                                "Uso apropriado de notação complexa e argumento z=hλ.",
                                "Interpretação qualitativa para stiff problems.",
                                "Exemplo prático resolvido sem erros numéricos.",
                                "Clareza na descrição da região de estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos ou difusão.",
                                "Engenharia: Análise de circuitos RLC stiff em simulações elétricas.",
                                "Computação: Implementação de solvers numéricos em Python/MATLAB.",
                                "Química: Modelagem de reações químicas stiff com ODEs.",
                                "Estatística: Análise de erro em métodos Monte Carlo para EDOs."
                              ],
                              "realWorldApplication": "Em simulações de engenharia química para reatores stiff, onde autovalores grandes negativos exigem h pequeno no Euler explícito, motivando uso de métodos implícitos como Backward Euler para eficiência computacional em software como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Verificar estabilidade local",
                            "description": "Aplicar o critério de estabilidade absoluta para um dado método numérico e valor hλ, determinando se o método é estável analisando |R(hλ)| ≤ 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de estabilidade absoluta",
                                  "subSteps": [
                                    "Defina estabilidade absoluta para métodos numéricos de resolução de EDOs lineares y' = λy.",
                                    "Explique que um método é estável se |R(hλ)| ≤ 1, onde R(z) é o polinômio de amplificação.",
                                    "Diferencie estabilidade absoluta de estabilidade local e regional.",
                                    "Revise a importância para problemas stiff com Re(λ) < 0.",
                                    "Estude exemplos de métodos condicionalmente estáveis como Euler explícito."
                                  ],
                                  "verification": "Escreva uma definição precisa e identifique corretamente em um exemplo dado se |R(hλ)| ≤ 1 implica estabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notas de aula sobre estabilidade.",
                                  "tips": "Lembre-se: estabilidade absoluta é para λ fixo e h pequeno; foque na condição |R(z)| ≤ 1 com z = hλ.",
                                  "learningObjective": "Entender a definição e critério matemático de estabilidade absoluta.",
                                  "commonMistakes": "Confundir com estabilidade de A-stabilidade (região inteira do semiplano esquerdo)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o polinômio de estabilidade R(z) do método numérico",
                                  "subSteps": [
                                    "Dado o método (ex: Euler forward: y_{n+1} = y_n + h f(t_n, y_n)), derive R(z) resolvendo a recursão y_{n+1} = R(z) y_n para y' = λy.",
                                    "Para Euler forward, obtenha R(z) = 1 + z.",
                                    "Liste R(z) para métodos comuns: backward Euler (1/(1-z)), trapezoidal ((1 + z/2)/(1 - z/2)).",
                                    "Verifique se R(0) = 1 para consistência.",
                                    "Desenhe graficamente a região de estabilidade no plano complexo."
                                  ],
                                  "verification": "Derive corretamente R(z) para pelo menos dois métodos e confirme R(0)=1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de fórmulas de métodos numéricos, calculadora ou software como MATLAB para plotar.",
                                  "tips": "Use a forma de Butcher tableau se disponível para métodos Runge-Kutta.",
                                  "learningObjective": "Derivar ou recordar o polinômio de amplificação R(z) para métodos lineares.",
                                  "commonMistakes": "Esquecer o fator h em z = hλ ou derivar incorretamente para métodos implícitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular R(hλ) para o valor dado de h e λ",
                                  "subSteps": [
                                    "Calcule z = hλ, considerando λ complexo se aplicável (Re(λ) < 0 para stiff).",
                                    "Substitua z em R(z) e compute o valor numérico ou simbólico.",
                                    "Use precisão suficiente (mínimo 4 casas decimais) para evitar erros de arredondamento.",
                                    "Se z complexo, compute módulo |R(z)| = sqrt(Re^2 + Im^2).",
                                    "Repita para múltiplos h se testando limite de estabilidade."
                                  ],
                                  "verification": "Mostre cálculo passo a passo de z e R(z), com valor exato ou aproximado correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora científica, Python/MATLAB para cálculos complexos.",
                                  "tips": "Sempre compute |R(z)|, não apenas Re(R(z)), pois é módulo.",
                                  "learningObjective": "Executar o cálculo preciso de R(hλ) para dados fornecidos.",
                                  "commonMistakes": "Usar λ em vez de hλ ou calcular R(λ) incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar a condição de estabilidade e concluir",
                                  "subSteps": [
                                    "Compare |R(hλ)| com 1: se ≤1, método estável; se >1, instável.",
                                    "Discuta implicações: se instável, reduzir h ou mudar método.",
                                    "Para problemas stiff, verifique se método é A-estável.",
                                    "Registre conclusão em formato: 'Estável' ou 'Instável' com justificativa.",
                                    "Teste sensibilidade variando h ligeiramente."
                                  ],
                                  "verification": "Conclua corretamente com base no cálculo e explique por quê.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para anotações, exemplos de problemas stiff.",
                                  "tips": "Para |R(z)|=1, é marginalmente estável; monitore crescimento.",
                                  "learningObjective": "Aplicar o critério |R(hλ)| ≤ 1 para determinar estabilidade.",
                                  "commonMistakes": "Ignorar o módulo absoluto ou inverter a condição (>1 estável)."
                                }
                              ],
                              "practicalExample": "Para o método de Euler forward (R(z)=1+z) com λ=-50 e h=0.01, z=hλ=-0.5, R(z)=0.5, |R(z)|=0.5 ≤1 → estável. Se h=0.03, z=-1.5, R(z)=-0.5, |R(z)|=0.5 ≤1 ainda estável, mas próximo do limite |z|≤2 para Euler.",
                              "finalVerifications": [
                                "Derivação correta de R(z) para o método dado.",
                                "Cálculo preciso de z=hλ e |R(z)|.",
                                "Conclusão lógica baseada em |R(z)| ≤1.",
                                "Identificação de implicações para problemas stiff.",
                                "Teste com variação de h confirma consistência.",
                                "Explicação clara da região de estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática no cálculo de R(hλ) (100% correto).",
                                "Compreensão conceitual demonstrada em definições.",
                                "Capacidade de generalizar para métodos diferentes.",
                                "Análise qualitativa de estabilidade (estável/instável e por quê).",
                                "Uso correto de módulo para números complexos.",
                                "Tempo de execução eficiente sem erros aritméticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de decaimento radioativo com EDOs stiff.",
                                "Computação: Implementação em Python (scipy.integrate) testando estabilidade.",
                                "Engenharia: Simulações de circuitos RLC com autovalores negativos grandes.",
                                "Estatística: Análise de séries temporais com métodos numéricos estáveis."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos ou reações químicas stiff (ex: combustão), verificar estabilidade local garante que soluções numéricas não explodam, evitando erros em previsões de engenharia aeroespacial ou farmacêutica."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Plano Complexo hλ",
                        "description": "Representação gráfica no plano complexo z = hλ, onde o semiplano esquerdo (Re(z) < 0) corresponde às regiões de estabilidade para soluções decayentes, essencial para analisar restrições em h para problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Interpretar o plano hλ",
                            "description": "Descrever o plano complexo hλ, identificando o eixo real negativo como região onde soluções exatas decaem, e o papel de Im(λ) em oscilações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a construção do plano complexo hλ",
                                  "subSteps": [
                                    "Revise a equação diferencial y' = λy, onde λ é um autovalor complexo.",
                                    "Defina h como o tamanho do passo de tempo no método numérico.",
                                    "Construa o plano complexo plotando hλ = h * (Re(λ) + i Im(λ)).",
                                    "Identifique os eixos: eixo horizontal como Re(hλ), eixo vertical como Im(hλ).",
                                    "Pratique escalando h para diferentes valores e observe o movimento no plano."
                                  ],
                                  "verification": "Desenhe manualmente o plano hλ para λ = -1 + 2i e h=0.1, confirmando posições corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, calculadora, software de plotagem como Desmos ou Python (Matplotlib).",
                                  "tips": "Sempre normalize λ primeiro para visualizar melhor a região de estabilidade.",
                                  "learningObjective": "Construir e interpretar graficamente o plano hλ a partir de autovalores.",
                                  "commonMistakes": "Confundir hλ com λ sozinho; lembrar que h multiplica λ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o eixo real negativo e seu significado",
                                  "subSteps": [
                                    "Localize o semi-eixo negativo no eixo real (Re(hλ) < 0).",
                                    "Explique que para Re(λ) < 0, soluções exatas y(t) = y0 e^{λt} decaem para zero.",
                                    "Simule numericamente um decaimento exponencial com Re(λ) < 0.",
                                    "Compare com métodos numéricos: pontos no eixo negativo devem estar na região de estabilidade para convergência.",
                                    "Analise o que acontece se h for grande demais (sai da estabilidade)."
                                  ],
                                  "verification": "Para λ = -5, h=0.1, confirme que hλ ≈ -0.5 está no eixo negativo e solucione y' = λy.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software Python com NumPy/SciPy para simular ODEs, gráficos de solução exata vs numérica.",
                                  "tips": "Use setas no eixo negativo para visualizar o 'decaimento' ao longo do tempo.",
                                  "learningObjective": "Associar o eixo real negativo à dissipação natural das soluções exatas.",
                                  "commonMistakes": "Ignorar que h >0 move pontos para a esquerda; hλ sempre tem Re(hλ) = h Re(λ) <0 se Re(λ)<0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o papel da parte imaginária Im(λ) nas oscilações",
                                  "subSteps": [
                                    "Identifique pontos com Im(hλ) ≠ 0, representando autovalores com parte imaginária.",
                                    "Explique que Im(λ) causa oscilações na solução exata: y(t) ≈ e^{Re(λ)t} (cos(Im(λ)t) + i sin(Im(λ)t)).",
                                    "Observe que linhas paralelas ao eixo imaginário indicam frequência de oscilação constante.",
                                    "Teste com λ = -1 ± 10i: pequenas Re causam decaimento lento com oscilações rápidas.",
                                    "Discuta como métodos A-stáveis lidam melhor com regiões amplas no semi-plano esquerdo."
                                  ],
                                  "verification": "Plote trajetórias hλ para λ com Im(λ) variando, descrevendo o padrão oscilatório na solução.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas de plotagem complexa (MATLAB, Python complex plot), exemplos de ODEs oscilatórias.",
                                  "tips": "Pense em Im(hλ) como 'altura' das espirais descendentes no plano de fase.",
                                  "learningObjective": "Relacionar Im(λ) à frequência e persistência de oscilações em problemas stiff.",
                                  "commonMistakes": "Confundir oscilações com instabilidade; oscilações são da solução exata, instabilidade é numérica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o plano hλ de forma integrada para problemas stiff",
                                  "subSteps": [
                                    "Combine conhecimentos: eixo real negativo para decaimento, Im(λ) para oscilações.",
                                    "Para um sistema stiff, plote todos hλ_j dos autovalores.",
                                    "Verifique se todos estão dentro da região de estabilidade do método escolhido.",
                                    "Ajuste h para manter pontos rígidos (grande |λ|) dentro da região.",
                                    "Resuma: plano hλ guia escolha de h e método para estabilidade."
                                  ],
                                  "verification": "Para um exemplo stiff (ex: y' = [-100,1;1,-100]y), plote hλ e confirme estabilidade para h=0.01.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python para autovalores (eig) e plotagem do plano hλ.",
                                  "tips": "Autovalor com maior |Im(λ)/Re(λ)| dita o limite de h para oscilações.",
                                  "learningObjective": "Aplicar interpretação holística do plano hλ à seleção de parâmetros numéricos.",
                                  "commonMistakes": "Focar só em |λ|max; considerar razão |Im/Re| para stiff oscilatórios."
                                }
                              ],
                              "practicalExample": "Considere o problema stiff y' = λy com λ = -50 + 30i (decaimento com oscilações). Para h=0.01, hλ ≈ -0.5 + 0.3i. Plote no plano: no semi-plano esquerdo, Im indica frequência ~30 rad/unidade. Use método backward Euler (A-estável); simule e compare com exata, confirmando ausência de oscilações espúrias.",
                              "finalVerifications": [
                                "Descreva verbalmente o significado do eixo Re(hλ)<0.",
                                "Explique como aumentar Im(λ) afeta a escolha de h.",
                                "Identifique corretamente hλ para dado λ e h em um gráfico.",
                                "Distinga decaimento exato de instabilidade numérica.",
                                "Ajuste h para um λ dado manter hλ na região de estabilidade de Euler.",
                                "Resuma o plano hλ em 3 frases."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do eixo real negativo e seu papel no decaimento (80% correto).",
                                "Explicação clara do impacto de Im(λ) em oscilações, com exemplo quantitativo.",
                                "Capacidade de plotar e interpretar hλ para λ complexo stiff.",
                                "Correta distinção entre comportamento exato e requisitos de estabilidade numérica.",
                                "Habilidade em ajustar h baseado no plano para múltiplos autovalores.",
                                "Uso de terminologia precisa (ex: semi-plano esquerdo, A-estabilidade)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Oscilações amortecidas em circuitos RLC (Im(λ) para frequência natural).",
                                "Engenharia Química: Reatores stiff com cinéticas rápidas/lentas (estabilidade em simulações).",
                                "Computação Científica: Implementação de solvers ODE em bibliotecas como SciPy.",
                                "Física Computacional: Modelagem de dinâmica molecular com modos stiff."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica veicular ou aerodinâmica (problemas stiff de CFD), o plano hλ garante que modos oscilatórios de alta frequência (vibrações) decaiam corretamente sem artefatos numéricos, permitindo passos de tempo maiores e simulações mais eficientes em softwares como ANSYS ou OpenFOAM."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Plotar trajetórias hλ",
                            "description": "Plotar no plano complexo as trajetórias de hλ para diferentes passos h e autovalores λ típicos de problemas stiff, destacando a necessidade de h pequeno para métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o plano complexo hλ e autovalores em problemas stiff",
                                  "subSteps": [
                                    "Revise o plano complexo: eixo real (Re(hλ)) e imaginário (Im(hλ)).",
                                    "Defina problemas stiff: autovalores λ com |Re(λ)| grande e negativo, rigidez alta.",
                                    "Explique hλ = h * λ, onde h é o passo de tempo.",
                                    "Identifique exemplos de λ stiff: λ = -100, λ = -50 + 50i.",
                                    "Discuta região de estabilidade para métodos explícitos (disco |1 + z| ≤ 1)."
                                  ],
                                  "verification": "Desenhe o plano hλ e marque 3 exemplos de hλ para λ stiff com h=0.01 e h=0.1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de plotagem (Python/Matlab)",
                                    "Notas sobre análise numérica"
                                  ],
                                  "tips": "Comece com λ reais negativos para simplicidade antes de complexos.",
                                  "learningObjective": "Entender a representação hλ no plano complexo e sua relação com estabilidade.",
                                  "commonMistakes": [
                                    "Confundir hλ com λ puro",
                                    "Ignorar a parte imaginária em oscilações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a função de amplificação para método explícito (Euler forward)",
                                  "subSteps": [
                                    "Lembre a iteração para y' = λy: y_{n+1} = y_n + h λ y_n = (1 + hλ) y_n.",
                                    "Defina R(z) = 1 + z, onde z = hλ.",
                                    "Descreva a trajetória: z_0 = 1, z_{k+1} = R(z_k), plotar sequência z_k.",
                                    "Compare com solução exata e^{λ t} que decai para 0 se Re(λ)<0.",
                                    "Note que para estabilidade, a trajetória deve convergir para 0."
                                  ],
                                  "verification": "Escreva a fórmula de R(z) e compute manualmente 3 iterações para z = -0.5.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Visualize geometricamente: multiplicação por (1+z) é rotação e escala.",
                                  "learningObjective": "Dominar a geração de trajetórias via iteração da função de amplificação.",
                                  "commonMistakes": [
                                    "Esquecer normalização inicial z_0=1",
                                    "Confundir com método implícito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar autovalores λ típicos e calcular pontos hλ para diferentes h",
                                  "subSteps": [
                                    "Escolha λ1 = -100 (real stiff), λ2 = -50 + 50i (oscilatório stiff).",
                                    "Calcule hλ para h=0.001, 0.005, 0.01, 0.05.",
                                    "Marque esses pontos iniciais no plano complexo.",
                                    "Preveja comportamento: para |hλ| grande, |1 + hλ| >1 leva a divergência.",
                                    "Registre em tabela: h, Re(hλ), Im(hλ)."
                                  ],
                                  "verification": "Crie tabela com 8 entradas (2 λ x 4 h) e marque pontos no plano.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python (numpy)",
                                    "Gráficos vazios do plano complexo"
                                  ],
                                  "tips": "Use cores diferentes para cada λ e símbolos para cada h.",
                                  "learningObjective": "Preparar dados específicos para plotting de trajetórias.",
                                  "commonMistakes": [
                                    "Escolher h muito pequeno irrelevante",
                                    "λ com Re>0 (instável exata)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar as trajetórias iterando a amplificação",
                                  "subSteps": [
                                    "Inicie z=1 para cada hλ.",
                                    "Itere z <- (1 + z) até |z|<1e-10 ou 100 passos.",
                                    "Plote a sequência de pontos conectados por linhas.",
                                    "Use software: loop em Python com matplotlib para múltiplas curvas.",
                                    "Adicione setas indicando direção da iteração."
                                  ],
                                  "verification": "Gere gráfico com 8 trajetórias (2λ x 4h), label cada curva.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python (numpy, matplotlib) ou Matlab",
                                    "Código template para iteração"
                                  ],
                                  "tips": "Limite iterações para evitar loops infinitos em casos instáveis.",
                                  "learningObjective": "Implementar e visualizar trajetórias no plano hλ.",
                                  "commonMistakes": [
                                    "Plotar só pontos iniciais, não sequência",
                                    "Escala errada no gráfico"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar estabilidade e destacar necessidade de h pequeno",
                                  "subSteps": [
                                    "Observe: para h grande, trajetórias divergem (saem do disco unitário).",
                                    "Para h pequeno, convergem espiralando para 0.",
                                    "Meça passos até |z|<0.01 para cada curva.",
                                    "Conclua: h < 2/|λ| approx para Euler explícito.",
                                    "Discuta implicações para problemas stiff (h muito pequeno = custo computacional alto)."
                                  ],
                                  "verification": "Escreva relatório de 1 página resumindo observações e lições.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Gráficos gerados",
                                    "Template de relatório"
                                  ],
                                  "tips": "Zoom em origens para ver convergência fina.",
                                  "learningObjective": "Interpretar plots para entender limitações de métodos explícitos.",
                                  "commonMistakes": [
                                    "Ignorar oscilações em λ complexo",
                                    "Generalizar sem quantificar h crítico"
                                  ]
                                }
                              ],
                              "practicalExample": "Para λ = -50 + 50i (stiff oscilatório de reator químico), plote trajetórias com h=0.001 (converge suavemente em ~200 passos), h=0.01 (oscila e diverge após 50 passos), h=0.05 (diverge imediatamente). Código Python: z = 1; trajectory = [z]; for _ in range(200): z *= (1 + h*lambda_); trajectory.append(z); plt.plot([real for real,imag in trajectory], [imag for real,imag in trajectory]).",
                              "finalVerifications": [
                                "Descreve corretamente trajetórias hλ como iterações de R(z)=1+z a partir de 1.",
                                "Identifica corretamente λ stiff e pontos hλ dentro/fora do disco de estabilidade.",
                                "Gera plots precisos mostrando divergência para h grande.",
                                "Explica quantitativamente por que h deve ser O(1/|λ|) para estabilidade.",
                                "Compara comportamentos para λ real vs complexo.",
                                "Discute trade-off custo computacional vs estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de hλ e iterações (erro <1%).",
                                "Qualidade visual dos plots: labels, legendas, escalas adequadas.",
                                "Profundidade da análise: identificação de padrões de convergência/divergência.",
                                "Correção conceitual: ligação com região de estabilidade.",
                                "Criatividade em exemplos: uso de λ realistas.",
                                "Clareza no relatório: conclusões destacando h pequeno."
                              ],
                              "crossCurricularConnections": [
                                "Física: Trajetórias semelhantes a decaimento radioativo ou amortecimento em RLC.",
                                "Computação: Implementação de solvers ODE em SciPy (odeint vs solve_ivp).",
                                "Engenharia: Estabilidade em simulações de controle PID para plantas stiff.",
                                "Química: Modelagem de reações stiff (métodos implícitos como BDF).",
                                "Programação: Visualização de dados complexos com matplotlib ou JuliaPlots."
                              ],
                              "realWorldApplication": "Em simulações numéricas de sistemas stiff como cinética química em reatores (ex: combustão) ou circuitos elétricos RLC com capacitores grandes, plotar hλ guia a escolha de h para evitar instabilidade numérica, permitindo simulações eficientes sem crash ou resultados errados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Relacionar com rigidez",
                            "description": "Explicar como autovalores λ com |Re(λ)| grande negativo em problemas stiff restringem h em métodos explícitos no plano hλ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender problemas stiff e o papel dos autovalores",
                                  "subSteps": [
                                    "Defina problemas stiff em EDOs: sistemas com escalas temporais muito diferentes devido a autovalores com partes reais grandes negativas.",
                                    "Explique autovalores λ de matrizes jacobianas em sistemas lineares y' = Ay.",
                                    "Identifique que |Re(λ)| grande negativo indica componentes rápidas e decay exponencial.",
                                    "Discuta por que isso causa rigidez: soluções exatas decay rápido, mas numéricas explícitas oscilam se h grande.",
                                    "Calcule exemplo simples: λ = -1000, solução exata e ≈ e^{-1000t}."
                                  ],
                                  "verification": "Resuma em 3 frases o que causa rigidez via autovalores e dê um exemplo numérico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (Hairer ou Butcher)",
                                    "Software MATLAB/Octave para autovalores",
                                    "Notas sobre EDOs lineares"
                                  ],
                                  "tips": "Visualize autovalores no plano complexo; foque em Re(λ) < 0 grandes.",
                                  "learningObjective": "Identificar autovalores responsáveis pela rigidez em problemas stiff.",
                                  "commonMistakes": [
                                    "Confundir parte imaginária com rigidez (rigidez é dominada por Re(λ))",
                                    "Ignorar normalização da matriz A"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o plano complexo hλ e regiões de estabilidade",
                                  "subSteps": [
                                    "Descreva o plano hλ: eixo real negativo para decay, h > 0, λ com Re(λ) ≤ 0.",
                                    "Defina região de estabilidade S(φ): {z ∈ ℂ | |R(z)| ≤ 1}, onde R(z) é função de amplificação do método.",
                                    "Para Euler explícito, R(z) = 1 + z, S = {z | |1 + z| ≤ 1}, disco unitário esquerdo centro -1.",
                                    "Plote a região S no plano hλ para Euler forward.",
                                    "Compare com métodos implícitos (ex: Backward Euler, S = disco esquerdo ilimitado)."
                                  ],
                                  "verification": "Desenhe o plano hλ e marque a região de estabilidade para Euler explícito.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python Matplotlib)",
                                    "Tabelas de regiões de estabilidade de livros texto",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Lembre: hλ deve ficar dentro de S para estabilidade absoluta.",
                                  "learningObjective": "Mapear condições de estabilidade no plano hλ para métodos explícitos.",
                                  "commonMistakes": [
                                    "Confundir estabilidade absoluta com condicional",
                                    "Esquecer que hλ = h * λ, h escala o λ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar restrição de h por autovalores com |Re(λ)| grande negativo",
                                  "subSteps": [
                                    "Para λ com Re(λ) = -L (L >> 1), hλ ≈ h*(-L) no eixo real negativo.",
                                    "Para Euler explícito, estabilidade requer |1 + hλ| ≤ 1 → hλ ≥ -2 → h ≤ 2/|Re(λ)|.",
                                    "Calcule h_max ≈ 2/L para L grande, mostrando h muito pequeno.",
                                    "Simule numericamente: resolva y' = -1000y com h = 0.001 (ok) vs h=0.01 (instável).",
                                    "Generalize: rigidez força h pequeno para capturar modos rápidos, mesmo se não interessam."
                                  ],
                                  "verification": "Compute h_max para λ=-100, -1000 e explique por que diminui.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB para resolver EDOs e plotar soluções",
                                    "Calculadora para |1 + hλ|"
                                  ],
                                  "tips": "Teste vários h e observe oscilações ou blow-up.",
                                  "learningObjective": "Quantificar como |Re(λ)| grande restringe h em métodos explícitos.",
                                  "commonMistakes": [
                                    "Usar h baseado só no Lipschitz global, ignorando autovalores individuais",
                                    "Confundir com precisão vs estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar restrições no plano hλ à rigidez geral",
                                  "subSteps": [
                                    "Conclua: rigidez = presença de |Re(λ)| >> 1, forçando h << 1/|Re(λ)_max| em explícitos.",
                                    "Discuta custo computacional: muitos passos para t fixo.",
                                    "Compare com implícitos: hλ pode ser arbitrariamente negativo sem restrição.",
                                    "Exemplo stiff clássico: y' = -1000(y - z), z' = y - z.",
                                    "Resuma: no plano hλ, rigidez comprime região permitida perto de 0."
                                  ],
                                  "verification": "Explique em parágrafo como rigidez se manifesta no plano hλ.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplos de problemas stiff (Van der Pol com μ grande)",
                                    "Gráficos de regiões de estabilidade comparativas"
                                  ],
                                  "tips": "Pense em trade-off: explícitos baratos por passo, mas muitos passos.",
                                  "learningObjective": "Ligar conceito de rigidez diretamente às limitações do plano hλ.",
                                  "commonMistakes": [
                                    "Achar que todos os stiff precisam de implícitos (alguns A-L stable ajudam)",
                                    "Ignorar não-linearidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o problema stiff y' = [-999 1; 1 -1001] y. Autovalores ≈ -1000 ±1i. Para Euler explícito, h_max ≈ 2/1000 = 0.002. Simule de t=0 a 1: com h=0.001, estável; h=0.003, oscila e diverge. No plano hλ, hλ ≈ -1 ±0.001i fica dentro do disco |1+z|≤1 só para h pequeno.",
                              "finalVerifications": [
                                "Pode calcular h_max para dado λ e método explícito?",
                                "Explica por que problemas stiff são 'rígidos' no plano hλ?",
                                "Identifica autovalores causadores em um jacobiano simples?",
                                "Simula e compara estabilidade para h pequeno vs grande?",
                                "Desenha corretamente região S para Euler forward?",
                                "Relaciona rigidez a custo computacional?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de autovalores e rigidez (90-100%)",
                                "Correta derivação de restrições h no plano hλ (80-90%)",
                                "Uso de exemplos numéricos com simulações (70-80%)",
                                "Clareza em gráficos e plots de regiões de estabilidade (60-70%)",
                                "Conexão explícita entre |Re(λ)| grande e necessidade de h pequeno (50-60%)",
                                "Ausência de erros comuns como confusão com precisão"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de reações químicas stiff (cinética rápida/lenta)",
                                "Computação: Implementação de solvers ODE em Python (scipy.integrate)",
                                "Engenharia: Simulações de circuitos elétricos com capacitores grandes",
                                "Química: Sistemas reacionais com escalas múltiplas"
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular ou reações químicas (ex: combustão), problemas stiff surgem de modos vibracionais rápidos; métodos explícitos falham sem h minúsculo, desperdiçando CPU. Usar compreensão do plano hλ guia escolha para implícitos como BDF, acelerando simulações industriais em software como COMSOL ou OpenFOAM."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Região de Estabilidade",
                        "description": "Conjunto R ⊂ ℂ definido por {z ∈ ℂ : |R(z)| ≤ 1}, onde R(z) é a função de estabilidade do método, comparando regiões pequenas para explícitos e grandes (incluindo semiplano esquerdo) para implícitos em problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Construir região para método simples",
                            "description": "Determinar e esboçar a região de estabilidade no plano hλ para o método de Euler implícito, mostrando que inclui todo o semiplano esquerdo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Método de Euler Implícito e a Equação de Teste",
                                  "subSteps": [
                                    "Revise a fórmula do método de Euler implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Compare com o Euler explícito para destacar a diferença na avaliação de f.",
                                    "Introduza a equação de teste y' = λy, com solução exata y(t) = y_0 e^{λt}.",
                                    "Defina z = hλ como a variável no plano complexo.",
                                    "Explique o conceito de estabilidade absoluta: |y_{n+1}/y_n| ≤ 1 para n→∞."
                                  ],
                                  "verification": "Escreva corretamente a recursão para a equação de teste e identifique z = hλ.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de Análise Numérica",
                                    "Calculadora"
                                  ],
                                  "tips": "Lembre-se: implícito requer solução de equação não linear por iteração, mas para linear é explícito.",
                                  "learningObjective": "Entender a base teórica do método e sua aplicação à equação de teste.",
                                  "commonMistakes": [
                                    "Confundir com Euler explícito (R(z) = 1+z)",
                                    "Esquecer que λ pode ser complexo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Função de Amplificação R(z)",
                                  "subSteps": [
                                    "Aplique o método à y' = λy: y_{n+1} = y_n + h λ y_{n+1}.",
                                    "Resolva para y_{n+1}: y_{n+1} (1 - hλ) = y_n → y_{n+1} = y_n / (1 - hλ).",
                                    "Defina R(z) = 1 / (1 - z), onde z = hλ.",
                                    "Verifique para z=0: R(0)=1, preservando constante.",
                                    "Discuta comportamento assintótico para |R(z)| <1."
                                  ],
                                  "verification": "Escreva R(z) = 1/(1-z) e compute R(0)=1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software simbólico como Wolfram Alpha (opcional)"
                                  ],
                                  "tips": "Use álgebra simples; evite complicar com não-lineares aqui.",
                                  "learningObjective": "Derivar precisamente a função de amplificação para Euler implícito.",
                                  "commonMistakes": [
                                    "Derivar R(z)=1+z (erro do explícito)",
                                    "Esquecer o denominador."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Condição de Estabilidade |R(z)| ≤ 1",
                                  "subSteps": [
                                    "Escreva |1/(1-z)| ≤ 1 → |1| ≤ |1-z| → 1 ≤ |1-z|.",
                                    "Interprete geometricamente: |1-z| ≥1 significa exterior ou fronteira do círculo unitário centrado em 1.",
                                    "Mostre que para Re(z) ≤ 0 (semiplano esquerdo), |1-z| = distância de z a 1 ≥1, pois Re(z)≤0 implica distância ≥1.",
                                    "Prove: para z = x + iy, x≤0, |1 - x - iy|^2 = (1-x)^2 + y^2 ≥1^2 +0 =1.",
                                    "Conclua que |R(z)| ≤1 para todo semiplano esquerdo."
                                  ],
                                  "verification": "Prove que |R(z)| ≤1 ∀ Re(z)≤0, com desigualdade geométrica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Plano complexo impresso"
                                  ],
                                  "tips": "Visualize o plano z: círculo |z-1|≤1 cobre apenas Re(z)>0 parcialmente.",
                                  "learningObjective": "Analisar analiticamente a região onde a estabilidade é garantida.",
                                  "commonMistakes": [
                                    "Achar que é disco unitário",
                                    "Erro no cálculo de |1-z|^2."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Esboçar a Região de Estabilidade no Plano hλ",
                                  "subSteps": [
                                    "Desenhe o plano complexo com eixos Re(hλ) horizontal, Im(hλ) vertical.",
                                    "Marque o círculo |z - 1| = 1, centro (1,0), raio 1.",
                                    "A região de estabilidade é o exterior: tudo fora ou na fronteira do círculo.",
                                    "Destaque o semiplano esquerdo Re(z)≤0, inteiramente dentro da região.",
                                    "Rotule pontos chave: z=0 (estável), z=-1 (R(-1)=1/2<1), z=i (verificar)."
                                  ],
                                  "verification": "Esboço mostra exterior do círculo incluindo todo Re(z)≤0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Ferramentas de desenho ou Desmos/GeoGebra"
                                  ],
                                  "tips": "Use escala adequada; sombreie a região para clareza.",
                                  "learningObjective": "Visualizar e esboçar com precisão a região de estabilidade.",
                                  "commonMistakes": [
                                    "Desenhar interior do círculo",
                                    "Confundir eixos Re/Im."
                                  ]
                                }
                              ],
                              "practicalExample": "Para λ = -10 + 2i (típico de stiff), z = h(-10 + 2i). Para qualquer h>0, Re(z)<0, então |R(z)|≤1. Esboce: ponto z está sempre no semiplano esquerdo, fora do círculo |z-1|=1.",
                              "finalVerifications": [
                                "R(z) = 1/(1-z) derivada corretamente.",
                                "|R(z)| ≤1 equivale a |z-1| ≥1.",
                                "Prova que semiplano Re(z)≤0 está contido na região.",
                                "Esboço preciso do círculo centro (1,0) raio 1, com sombreamento exterior.",
                                "Explicação verbal da inclusão do semiplano esquerdo.",
                                "Verificação numérica para 2-3 pontos no semiplano esquerdo."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação de R(z) (20%)",
                                "Correção da análise |R(z)|≤1 e prova geométrica (30%)",
                                "Qualidade e acurácia do esboço (20%)",
                                "Explicação clara da inclusão do semiplano esquerdo (15%)",
                                "Uso correto de terminologia e conceitos (10%)",
                                "Organização e clareza da apresentação (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de equações diferenciais stiff como amortecimento.",
                                "Computação: Implementação numérica em Python (scipy.integrate) para problemas stiff.",
                                "Engenharia: Análise de controle e sistemas dinâmicos lineares.",
                                "Matemática Aplicada: Teoria de funções complexas e mapeamentos conformes."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas stiff (e.g., combustão), o Euler implícito permite passos h maiores sem oscilações, essencial para eficiência computacional em modelagens industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Comparar métodos explícitos e implícitos",
                            "description": "Comparar as regiões de estabilidade de métodos explícitos (ex: RK4, disco pequeno) versus implícitos (ex: Backward Euler, semiplano esquerdo), justificando uso em problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Métodos Explícitos e Implícitos",
                                  "subSteps": [
                                    "Definir método explícito: próximo valor depende apenas de valores conhecidos atuais (ex: y_{n+1} = y_n + h f(t_n, y_n))",
                                    "Definir método implícito: próximo valor depende de si mesmo (ex: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})), requer solução iterativa",
                                    "Listar exemplos: Explícito (Forward Euler, RK4); Implícito (Backward Euler, Trapezoidal)",
                                    "Explicar diferenças algébricas e computacionais (explícitos mais baratos por passo, implícitos mais estáveis)",
                                    "Contextualizar em EDOs stiff: razão de eigenvalues alta"
                                  ],
                                  "verification": "Escrever definições precisas e exemplos corretos em um resumo de 1 página",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre análise numérica",
                                    "Livro-texto (ex: Burden & Faires)",
                                    "Papel e lápis para anotações"
                                  ],
                                  "tips": "Foque na dependência algébrica: explícitos usam 'conhecido', implícitos resolvem equação não-linear",
                                  "learningObjective": "Diferenciar formulações e implicações computacionais de métodos explícitos vs. implícitos",
                                  "commonMistakes": [
                                    "Confundir Forward Euler (explícito) com Backward Euler (implícito)",
                                    "Subestimar custo computacional dos implícitos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Regiões de Estabilidade de Métodos Explícitos",
                                  "subSteps": [
                                    "Definir região de estabilidade: {z ∈ ℂ | |R(z)| ≤ 1}, onde z = hλ e R é polinômio de amplificação",
                                    "Derivar para Forward Euler: R(z) = 1 + z, disco unitário |z| ≤ 1",
                                    "Descrever para RK4: disco aproximado |z| ≤ 2.78 (raio maior que Euler)",
                                    "Esboçar regiões no plano complexo (disco centrado na origem)",
                                    "Testar estabilidade: para Re(λ) < 0, h limitado por |hλ| ≤ raio"
                                  ],
                                  "verification": "Esboçar disco corretamente e calcular R(z) para z teste",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB/Python para plotar (opcional)",
                                    "Papel milimetrado",
                                    "Tabela de regiões de estabilidade padrão"
                                  ],
                                  "tips": "Visualize z = hλ: para stiff (λ grande negativo), h deve ser pequeno em explícitos",
                                  "learningObjective": "Calcular e interpretar regiões de estabilidade limitadas dos explícitos",
                                  "commonMistakes": [
                                    "Esquecer que região é para |R(z)| ≤1, não =1",
                                    "Confundir raio de RK4 com Euler"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Regiões de Estabilidade de Métodos Implícitos",
                                  "subSteps": [
                                    "Derivar para Backward Euler: R(z) = 1/(1 - z), semiplano esquerdo Re(z) ≤ 0",
                                    "Descrever Trapezoidal: R(z) = (1 + z/2)/(1 - z/2), semiplano com indentação",
                                    "Comparar tamanhos: implícitos A-estáveis (todo semiplano esquerdo)",
                                    "Esboçar regiões no plano complexo (vs. explícitos)",
                                    "Testar: para λ negativo grande, qualquer h >0 estável"
                                  ],
                                  "verification": "Derivar R(z) e esboçar semiplano corretamente",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex: SymPy)",
                                    "Papel para derivações",
                                    "Referência: Hairer 'Solving ODEs'"
                                  ],
                                  "tips": "Implícitos cobrem todo o semiplano Re(z)<0, ideais para stiff",
                                  "learningObjective": "Reconhecer superioridade das regiões ilimitadas dos implícitos",
                                  "commonMistakes": [
                                    "Achar que Backward Euler tem disco (é semiplano)",
                                    "Ignorar A-estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Regiões e Justificar Uso em Problemas Stiff",
                                  "subSteps": [
                                    "Sobrepor esboços: explícitos (discos pequenos) vs. implícitos (semiplano esquerdo)",
                                    "Quantificar: para |λ| grande, h_max explícito ~1/|λ|, implícito ilimitado",
                                    "Justificar para stiff: eigenvalues variam (rígidos: |λ_rígido/λ_lento| >>1), explícitos instáveis",
                                    "Simular numericamente exemplo stiff simples",
                                    "Concluir: implícitos para stiff apesar de custo por passo"
                                  ],
                                  "verification": "Tabela comparativa e justificativa escrita de 200 palavras",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python/MATLAB para simulação",
                                    "Exemplo stiff: y' = -1000(y - sin(t))"
                                  ],
                                  "tips": "Stiff = h limitada por componente rígida; implícitos liberam h",
                                  "learningObjective": "Justificar escolha baseada em regiões para problemas stiff",
                                  "commonMistakes": [
                                    "Ignorar custo implícito vs. ganho em passos",
                                    "Generalizar sem exemplo numérico"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -1000 y, λ=-1000 (stiff). Com RK4 (raio~2.8), h_max~0.0028 (instável se maior). Backward Euler: estável para qualquer h>0, permitindo h=0.1 com precisão.",
                              "finalVerifications": [
                                "Esboço correto de disco RK4 e semiplano Backward Euler",
                                "Cálculo preciso de R(z) para ambos métodos",
                                "Identificação de limitação h em explícitos para Re(λ)<0 grande",
                                "Justificativa clara para uso de implícitos em stiff",
                                "Simulação numérica mostrando instabilidade explícita vs. estabilidade implícita"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivações de R(z) (exato)",
                                "Clareza nos esboços de regiões (legíveis e rotulados)",
                                "Profundidade na comparação quantitativa (h_max, custo)",
                                "Relevância da justificativa para stiff (exemplos concretos)",
                                "Originalidade na simulação prática"
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de dinâmica molecular stiff",
                                "Engenharia Química: Reatores com cinéticas rígidas (métodos implícitos para h grandes)",
                                "Computação Científica: Bibliotecas como SciPy (odeint usa implícitos para stiff)",
                                "Engenharia Elétrica: Circuitos RLC stiff em SPICE simulações"
                              ],
                              "realWorldApplication": "Em simulações de circuitos integrados (ex: SPICE), problemas stiff surgem de capacitores/diodos; métodos implícitos como Backward Euler permitem passos eficientes, reduzindo tempo computacional em designs VLSI."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Analisar implicações para stiff",
                            "description": "Avaliar como a região de estabilidade determina o passo h admissível em problemas stiff, recomendando métodos A-stáveis para eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender problemas stiff e o papel da região de estabilidade",
                                  "subSteps": [
                                    "Defina problemas stiff: sistemas de EDOs com escalas temporais muito diferentes (componentes rápidas e lentas).",
                                    "Explique a fórmula de estabilidade: z = hλ, onde λ é autovalor com grande parte real negativa.",
                                    "Descreva a região de estabilidade R como {z ∈ ℂ : |R(z)| ≤ 1}, onde R é a função de amplificação.",
                                    "Identifique por que métodos explícitos falham: região limitada no semiplano esquerdo.",
                                    "Discuta implicações iniciais: h deve satisfazer h|Re(λ)| pequeno para estabilidade."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre problemas stiff e não-stiff, citando exemplos de autovalores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), software MATLAB ou Python (SciPy) para plotar regiões.",
                                  "tips": "Use diagramas do plano complexo para visualizar o semiplano esquerdo.",
                                  "learningObjective": "Compreender conceitualmente como a rigidez afeta a escolha de h via região de estabilidade.",
                                  "commonMistakes": "Confundir estabilidade absoluta com A-estabilidade; ignorar autovalores complexos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar região de estabilidade de métodos explícitos e implícitos",
                                  "subSteps": [
                                    "Calcule R(z) para Euler explícito: R(z) = 1 + z; plote a região |1 + z| ≤ 1.",
                                    "Compare com Euler implícito: R(z) = 1/(1 - z); verifique A-estabilidade (semiplano esquerdo inteiro).",
                                    "Teste métodos multistep como BDF; identifique regiões maiores para stiff.",
                                    "Use software para plotar regiões de estabilidade de Runge-Kutta explícito vs. implícito.",
                                    "Anote limitações: métodos explícitos restringem h << 1/|λ_max|."
                                  ],
                                  "verification": "Gere plots de regiões de estabilidade e identifique se cobrem Re(z) < 0 para |z| > 10.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (matplotlib, odeint), planilha com fórmulas R(z), exemplos de código online.",
                                  "tips": "Comece com |z| pequeno e aumente para ver 'círculo unitário' do Euler explícito.",
                                  "learningObjective": "Comparar graficamente regiões de estabilidade e suas implicações para h.",
                                  "commonMistakes": "Plotar incorretamente o plano z; confundir R(z) com erro local."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar passo h admissível em problemas stiff",
                                  "subSteps": [
                                    "Extraia autovalores λ do Jacobiano do sistema stiff.",
                                    "Para um método dado, encontre h_max tal que hλ ∈ R para todos λ.",
                                    "Exemplo: para Euler explícito, h < 2 / |Re(λ_max)|.",
                                    "Calcule para um problema teste: y' = -1000y, λ = -1000, compare métodos.",
                                    "Avalie trade-off: h pequeno aumenta custo computacional."
                                  ],
                                  "verification": "Calcule h_max para λ = -500 + 10i em Euler explícito e implícito; verifique numericamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Calculadora simbólica (SymPy), exemplos de problemas stiff em PDF.",
                                  "tips": "Priorize o autovalor com maior |Re(λ)| negativo.",
                                  "learningObjective": "Quantificar h admissível baseado na interseção de λh com R.",
                                  "commonMistakes": "Usar |λ| total em vez de |Re(λ)|; ignorar direção no plano complexo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Recomendar métodos A-estáveis para eficiência em stiff",
                                  "subSteps": [
                                    "Defina A-estabilidade: R(z) ≤ 1 para todo Re(z) < 0.",
                                    "Liste métodos A-estáveis: Backward Euler, Trapezoidal, BDF2-6.",
                                    "Compare eficiência: custo por passo vs. h permitido.",
                                    "Simule um problema stiff com método explícito (instável) vs. A-estável (eficiente).",
                                    "Conclua recomendações: use A-estáveis para stiff moderado a severo."
                                  ],
                                  "verification": "Execute simulação mostrando convergência estável apenas com método A-estável.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "MATLAB/Octave scripts para solvers ode15s (stiff) vs. ode45, dados de benchmark.",
                                  "tips": "Monitore norma da solução para detectar instabilidade.",
                                  "learningObjective": "Justificar escolha de métodos baseados em propriedades de estabilidade.",
                                  "commonMistakes": "Recomendar explícitos para stiff; subestimar custo de implícitos (iterações Newton)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e sintetizar análise para problemas stiff",
                                  "subSteps": [
                                    "Resolva um problema stiff completo, variando h e método.",
                                    "Analise erro vs. custo (número de passos).",
                                    "Documente implicações: região determina viabilidade prática.",
                                    "Discuta L-estabilidade para problemas muito stiff (R(∞)=0).",
                                    "Prepare relatório com gráficos e recomendações."
                                  ],
                                  "verification": "Relatório mostra h admissível correto e recomendação justificada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Template de relatório, software de plotagem.",
                                  "tips": "Use log-escala para h e erro.",
                                  "learningObjective": "Integrar análise para tomada de decisão em EDOs stiff.",
                                  "commonMistakes": "Não considerar precisão além de estabilidade; ignorar overhead de implícitos."
                                }
                              ],
                              "practicalExample": "Considere o problema stiff y' = -1000(y - 1) + sin(t), y(0)=1, t∈[0,5]. Autovalor λ≈-1000. Para Euler explícito, h_max≈0.002 para estabilidade, exigindo ~2500 passos. Com Backward Euler (A-estável), h=0.1 é viável (~50 passos), mantendo estabilidade e precisão.",
                              "finalVerifications": [
                                "Calcula corretamente h_max para λ dado e método específico.",
                                "Identifica se método é A-estável via plot ou definição.",
                                "Simula problema stiff mostrando falha explícita e sucesso implícito.",
                                "Recomenda método apropriado com justificativa de eficiência.",
                                "Analisa trade-off custo vs. estabilidade em benchmark.",
                                "Explica verbalmente implicações da região de estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na determinação de h admissível (erro <10%).",
                                "Correta identificação de regiões de estabilidade (plots precisos).",
                                "Justificativa clara para recomendação de métodos A-estáveis.",
                                "Análise quantitativa de eficiência (passos/tempo de CPU).",
                                "Integração conceitual com exemplos numéricos.",
                                "Ausência de erros comuns como confusão explícito/implícito.",
                                "Relatório estruturado e visualmente claro."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de oscilações amortecidas em circuitos RLC stiff.",
                                "Engenharia Química: Simulação de reações em série-paralelo stiff.",
                                "Computação Científica: Implementação de solvers adaptativos em bibliotecas como SciPy.",
                                "Estatística: Análise de incerteza em integrações numéricas stiff."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular (rigidez por forças rápidas), aviação (controle de flaps stiff), ou finanças (modelos Black-Scholes com volatilidade implícita alta), análise da região de estabilidade permite escolher h eficiente e métodos A-estáveis, reduzindo tempo de computação de horas para minutos em supercomputadores."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.4",
                            "name": "Verificar A-estabilidade",
                            "description": "Verificar se um método é A-estável, i.e., sua região de estabilidade contém o semiplano esquerdo, usando teoremas como o de Dahlquist.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Estabilidade Numérica",
                                  "subSteps": [
                                    "Revise a definição de estabilidade absoluta para métodos de Runge-Kutta e lineares multistep.",
                                    "Estude a região de estabilidade como o conjunto {z ∈ ℂ | |R(z)| ≤ 1}, onde R(z) é o polinômio de estabilidade.",
                                    "Analise o semiplano esquerdo Re(z) < 0 e sua importância para problemas stiff.",
                                    "Identifique problemas stiff como aqueles com autovalores com partes reais negativas grandes em módulo.",
                                    "Discuta a necessidade de métodos implicitos para estabilidade incondicional."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre estabilidade condicional e incondicional, com um diagrama simples da região de estabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires), papel e caneta para diagramas, software como MATLAB para plotar regiões simples."
                                  ],
                                  "tips": "Desenhe o plano complexo e sombreie o semiplano esquerdo para visualização intuitiva.",
                                  "learningObjective": "Compreender os pré-requisitos teóricos para A-estabilidade.",
                                  "commonMistakes": "Confundir estabilidade absoluta com estabilidade relativa; ignorar o papel dos autovalores negativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Interpretar A-Estabilidade",
                                  "subSteps": [
                                    "Memorize a definição: Um método é A-estável se sua região de estabilidade contém todo o semiplano esquerdo Re(z) < 0.",
                                    "Estude o teorema de Dahlquist II: Métodos lineares multistep explícitos de ordem p ≥ 3 não são A-estáveis.",
                                    "Analise o teorema de Dahlquist I: Ordem máxima para métodos A-estáveis é 2.",
                                    "Discuta implicações para métodos implícitos como Backward Euler.",
                                    "Calcule R(z) para métodos simples e verifique |R(z)| ≤ 1 para Re(z) < 0."
                                  ],
                                  "verification": "Escreva a definição formal de A-estabilidade e cite os teoremas de Dahlquist com condições.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Notas de aula sobre teoremas de Dahlquist, calculadora simbólica como SymPy ou Mathematica."
                                  ],
                                  "tips": "Use provas por contradição para teoremas de Dahlquist para fixar o raciocínio.",
                                  "learningObjective": "Dominar a definição precisa e teoremas fundamentais de A-estabilidade.",
                                  "commonMistakes": "Esquecer que A-estabilidade requer inclusão estrita do semiplano, não apenas interseção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Analisar a Região de Estabilidade",
                                  "subSteps": [
                                    "Derive o polinômio de estabilidade R(z) para um método dado (ex: método de Euler implícito).",
                                    "Prove que |R(z)| ≤ 1 para todo z com Re(z) < 0 usando análise complexa.",
                                    "Use o critério de Hairer: Para métodos LMM, verificar condições em ρ(z)/σ(z).",
                                    "Plote a fronteira da região de estabilidade usando software numérico.",
                                    "Teste pontos no semiplano esquerdo e verifique numericamente a estabilidade."
                                  ],
                                  "verification": "Compute R(z) para Backward Euler e mostre |R(z)| = 1/|1 - z| ≤ 1 para Re(z) < 0.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Software MATLAB/Python com pacotes como mpmath para análise complexa, exemplos de métodos numéricos."
                                  ],
                                  "tips": "Comece com métodos conhecidos A-estáveis para ganhar confiança antes de métodos duvidosos.",
                                  "learningObjective": "Aplicar cálculos analíticos e numéricos para determinar A-estabilidade.",
                                  "commonMistakes": "Erros em derivação de R(z); testar apenas pontos reais em vez de complexos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar A-Estabilidade em Métodos Específicos",
                                  "subSteps": [
                                    "Selecione um método (ex: Trapezoidal) e aplique teoremas de Dahlquist para descartar ou confirmar.",
                                    "Para métodos de ordem >2 explícitos, prove não A-estabilidade via Dahlquist II.",
                                    "Analise métodos implícitos de ordem 2 e verifique condições adicionais.",
                                    "Compare com métodos conhecidos (A-estável vs. não A-estável).",
                                    "Documente o processo em um relatório curto com provas e plots."
                                  ],
                                  "verification": "Classifique corretamente 3 métodos como A-estáveis ou não, com justificativa teórica.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Tabela de métodos numéricos, software de plotagem (ex: Python Matplotlib com contours)."
                                  ],
                                  "tips": "Sempre volte à definição: contenção total do semiplano esquerdo.",
                                  "learningObjective": "Executar verificações completas para métodos arbitrários.",
                                  "commonMistakes": "Aplicar teoremas incorretamente a métodos não-LMM; ignorar ordens superiores."
                                }
                              ],
                              "practicalExample": "Verifique se o método Backward Euler (y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})) é A-estável. Compute R(z) = 1/(1 - z). Para Re(z) < 0, |1 - z| > 1, logo |R(z)| < 1. Na fronteira imaginária, |R(iy)| = 1. Assim, contém o semiplano esquerdo.",
                              "finalVerifications": [
                                "Defina corretamente A-estabilidade e cite teoremas de Dahlquist.",
                                "Derive R(z) para pelo menos dois métodos e verifique estabilidade.",
                                "Identifique métodos A-estáveis comuns (ex: Backward Euler, Trapezoidal).",
                                "Explique por que métodos explícitos de alta ordem não são A-estáveis.",
                                "Plote e interprete uma região de estabilidade.",
                                "Aplique o conceito a um problema stiff simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de polinômios de estabilidade (90% correto).",
                                "Correta aplicação de teoremas de Dahlquist (sem erros lógicos).",
                                "Qualidade de plots e análises numéricas (clareza e acurácia).",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Capacidade de generalizar para novos métodos.",
                                "Documentação completa com verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de EDOs em dinâmica de fluidos stiff.",
                                "Computação: Implementação eficiente de solvers numéricos em Python/Scipy.",
                                "Engenharia: Modelagem de circuitos RC com constantes de tempo díspares.",
                                "Química Computacional: Integração de equações cinéticas stiff."
                              ],
                              "realWorldApplication": "Em simulações de problemas stiff como reações químicas rápidas ou circuitos elétricos, métodos A-estáveis como Backward Euler permitem passos de tempo grandes sem instabilidade, reduzindo tempo computacional em softwares como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Métodos Explícitos vs. Implícitos",
                    "description": "Limitações dos métodos explícitos de passo simples e vantagens dos implícitos para rigidez.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Métodos Explícitos de Passo Simples",
                        "description": "Métodos numéricos explícitos, como o método de Euler explícito e os métodos de Runge-Kutta de ordem superior, que calculam a solução no próximo passo diretamente a partir dos valores anteriores, sem necessidade de resolver equações adicionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Identificar e descrever métodos explícitos comuns",
                            "description": "Reconhecer e explicar os métodos de Euler explícito, Heun e Runge-Kutta de quarta ordem, incluindo suas fórmulas e ordens de precisão, aplicados a problemas de valor inicial y' = f(t,y).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Problemas de Valor Inicial e Conceito de Métodos Explícitos",
                                  "subSteps": [
                                    "Revise a equação diferencial ordinária (EDO) na forma y' = f(t, y) com condição inicial y(t₀) = y₀.",
                                    "Defina métodos de Runge-Kutta explícitos: métodos de passo único onde y_{n+1} é computado diretamente sem resolver equações não lineares.",
                                    "Identifique características comuns: uso de passo h, aproximações polinomiais locais e ordens de precisão baseadas no erro local.",
                                    "Diferencie brevemente de métodos implícitos (ex.: requerem iterações para y_{n+1}).",
                                    "Estude o esquema geral de métodos explícitos de Runge-Kutta."
                                  ],
                                  "verification": "Explique em 2-3 frases o que diferencia métodos explícitos de implícitos e liste 3 características comuns.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre EDOs",
                                    "Livro de Análise Numérica (capítulo de métodos numéricos)",
                                    "Calculadora ou papel para esboços"
                                  ],
                                  "tips": "Visualize métodos explícitos como 'previsões diretas' sem feedback do futuro.",
                                  "learningObjective": "Entender o contexto e terminologia dos métodos explícitos comuns para EDOs.",
                                  "commonMistakes": [
                                    "Confundir ordem de precisão com tamanho do passo h",
                                    "Ignorar a dependência em f(t,y)",
                                    "Achar que todos explícitos são de ordem 1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar o Método de Euler Explícito",
                                  "subSteps": [
                                    "Memorize a fórmula: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Derive intuitivamente: tangente na base do intervalo [t_n, t_{n+1}].",
                                    "Calcule a ordem de precisão: erro local O(h²), ordem global O(h), ordem do método 1.",
                                    "Aplique a um exemplo simples: y' = -y, y(0)=1, h=0.1.",
                                    "Discuta limitações: instável para problemas stiff."
                                  ],
                                  "verification": "Implemente 2 iterações manualmente e verifique se y_1 e y_2 estão corretos dentro de 0.01.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como Python ou MATLAB para verificação opcional",
                                    "Tabela de valores exatos da solução"
                                  ],
                                  "tips": "Pense no Euler como 'passo reto na tangente' – simples mas grosseiro.",
                                  "learningObjective": "Reconhecer, escrever e aplicar a fórmula do Euler explícito com sua ordem de precisão.",
                                  "commonMistakes": [
                                    "Usar f(t_{n+1}, y_n) em vez de f(t_n, y_n)",
                                    "Esquecer o fator h",
                                    "Confundir erro local com global"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender o Método de Heun (RK2)",
                                  "subSteps": [
                                    "Entenda como predictor-corrector: k1 = f(t_n, y_n), k2 = f(t_{n+1}, y_n + h k1), y_{n+1} = y_n + (h/2)(k1 + k2).",
                                    "Memorize a ordem: 2 (erro local O(h³)).",
                                    "Compare com Euler: média de inclinações inicial e final.",
                                    "Aplique ao mesmo exemplo: y' = -y, h=0.1, compute 2 passos.",
                                    "Verifique melhoria na precisão vs. Euler."
                                  ],
                                  "verification": "Compare y_2 de Heun com solução exata e Euler; deve ser mais preciso.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para cálculos",
                                    "Gráfico comparativo de soluções"
                                  ],
                                  "tips": "Heun é 'Euler melhorado' – usa previsão para corrigir.",
                                  "learningObjective": "Explicar e implementar o método de Heun, destacando sua ordem 2.",
                                  "commonMistakes": [
                                    "Trocar k1 e k2",
                                    "Usar h em vez de h/2 na média",
                                    "Achar que é implícito por usar t_{n+1}"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Masterizar Runge-Kutta de Quarta Ordem (RK4)",
                                  "subSteps": [
                                    "Liste os coeficientes: k1 = f(t_n, y_n), k2 = f(t_n + h/2, y_n + (h/2)k1), k3 = f(t_n + h/2, y_n + (h/2)k2), k4 = f(t_n + h, y_n + h k3).",
                                    "Fórmula final: y_{n+1} = y_n + (h/6)(k1 + 2k2 + 2k3 + k4).",
                                    "Identifique ordem 4 (erro local O(h⁵)).",
                                    "Aplique ao exemplo y' = -y, h=0.1, 2 passos.",
                                    "Discuta por que é 'padrão ouro' para não-stiff."
                                  ],
                                  "verification": "Confirme que os ks estão corretos e y_2 aproxima bem a exata e^{ -1 } ≈ 0.3679.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Python pronto para RK4",
                                    "Tabela Butcher para RK4"
                                  ],
                                  "tips": "RK4 amostra a derivada em 4 pontos ponderados – alta precisão com custo moderado.",
                                  "learningObjective": "Derivar, escrever e aplicar RK4 com precisão na ordem 4.",
                                  "commonMistakes": [
                                    "Erros nos argumentos de k2/k3 (h/2 vs h)",
                                    "Coeficientes errados (ex: 1/6 em vez de pesos 1-2-2-1)",
                                    "Confundir com RK2"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar Métodos e Descrever Aplicações",
                                  "subSteps": [
                                    "Tabela comparativa: fórmulas, ordens (1,2,4), custo computacional (1,2,4 avaliações de f).",
                                    "Descreva precisão: Euler baixo, Heun médio, RK4 alta para h pequeno.",
                                    "Discuta estabilidade: todos ruins para stiff, mas RK4 melhor.",
                                    "Escreva resumo: 'Euler: simples O(h), Heun: médio O(h²), RK4: preciso O(h⁴)'.",
                                    "Teste com código ou manual em outro problema, ex: y' = y(1-y)."
                                  ],
                                  "verification": "Crie uma tabela de 1 página resumindo os 3 métodos e suas ordens.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de tabela (Word/Excel)",
                                    "Gráficos de erro vs h para cada método"
                                  ],
                                  "tips": "Ordens indicam como erro cai com h: dobro ordem, 2x precisão por √2 h menor.",
                                  "learningObjective": "Identificar, descrever e comparar os métodos com fórmulas e ordens corretas.",
                                  "commonMistakes": [
                                    "Ordens erradas (ex: RK4 como 3)",
                                    "Ignorar custo vs precisão",
                                    "Generalizar estabilidade sem stiff"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente y' = -2y, y(0)=1 até t=1 com h=0.2 usando Euler, Heun e RK4. Solução exata: y(t)=e^{-2t}. Compare y(1): Euler≈0.486, Heun≈0.455, RK4≈0.449, exata≈0.4493. Implemente em Python para plotar erros.",
                              "finalVerifications": [
                                "Escreva corretamente as fórmulas de Euler, Heun e RK4 sem erros.",
                                "Identifique ordens: Euler=1, Heun=2, RK4=4.",
                                "Aplique cada método a um problema simples e obtenha valores corretos em 3 passos.",
                                "Explique em 1 parágrafo as diferenças em precisão e custo.",
                                "Crie tabela comparativa com fórmulas e ordens.",
                                "Discuta limitação comum: inadequados para stiff sem adaptações."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas (100% correto: 40%)",
                                "Correta identificação de ordens de precisão (30%)",
                                "Capacidade de aplicação numérica sem erros aritméticos (20%)",
                                "Descrição clara de diferenças e limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/MATLAB para simulações dinâmicas.",
                                "Física: Modelar osciladores harmônicos ou decaimento radioativo.",
                                "Engenharia: Simulações de circuitos RLC ou controle de sistemas.",
                                "Biologia: Modelos populacionais Lotka-Volterra."
                              ],
                              "realWorldApplication": "Esses métodos são fundamentais em software de simulação como MATLAB Simulink ou COMSOL para prever trajetórias de foguetes, dinâmicas climáticas, epidemias (SIR models) e finanças (opções Black-Scholes), onde precisão alta com custo baixo é essencial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Analisar a estabilidade dos métodos explícitos",
                            "description": "Determinar a região de estabilidade absoluta para o método de Euler explícito no teste de Dahlquist (y' = λy), identificando que |1 + hλ| ≤ 1 restringe h para autovalores com parte real negativa grande.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o problema de teste de Dahlquist e o método de Euler explícito",
                                  "subSteps": [
                                    "Revise a equação diferencial y' = λy, onde λ é um escalar complexo com Re(λ) < 0.",
                                    "Explique a solução exata: y(t) = y(0) exp(λt), que decai para zero se Re(λ) < 0.",
                                    "Descreva o método de Euler explícito: y_{n+1} = y_n + h λ y_n = (1 + hλ) y_n.",
                                    "Defina estabilidade absoluta: a região onde |amplification factor| ≤ 1 para todos os passos.",
                                    "Discuta por que isso é crucial para problemas stiff (autovalores com |Re(λ)| grande)."
                                  ],
                                  "verification": "Escreva a fórmula de recursão do Euler explícito e explique verbalmente o problema de teste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de análise numérica, papel e caneta, calculadora.",
                                  "tips": "Comece sempre pela solução exata para contextualizar o erro numérico.",
                                  "learningObjective": "Compreender o modelo canônico para análise de estabilidade de métodos numéricos.",
                                  "commonMistakes": "Confundir estabilidade absoluta com estabilidade condicional; ignorar que λ pode ser complexo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o fator de amplificação e a condição de estabilidade",
                                  "subSteps": [
                                    "Identifique o fator de amplificação g(hλ) = 1 + hλ.",
                                    "Estabeleça a condição de estabilidade absoluta: |1 + hλ| ≤ 1.",
                                    "Expanda para λ real negativo: |1 + hλ| = |1 - h|λ|| ≤ 1, implicando 0 < h ≤ 2/|λ|.",
                                    "Generalize para o plano complexo z = hλ: região onde |1 + z| ≤ 1 (círculo unitário centrado em -1).",
                                    "Calcule pontos críticos: disco de diâmetro [-2, 0] no eixo real."
                                  ],
                                  "verification": "Derive e escreva a desigualdade |1 + hλ| ≤ 1; teste com λ = -1, h=1 (estável) e h=3 (instável).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, software de plotagem como Python (matplotlib) ou MATLAB.",
                                  "tips": "Use z = hλ para normalizar e visualizar no plano complexo.",
                                  "learningObjective": "Derivar matematicamente a região de estabilidade para Euler explícito.",
                                  "commonMistakes": "Esquecer o módulo complexo; assumir estabilidade incondicional como em métodos implícitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar restrições para problemas stiff",
                                  "subSteps": [
                                    "Defina problemas stiff: ODEs com autovalores λ com |Re(λ)| >> 1 e discrepância de escalas.",
                                    "Mostre que para |λ| grande, h ≤ 2/|λ| força passos muito pequenos.",
                                    "Compare com o passo ótimo para precisão: h ~ 1/|λ| para erro local pequeno.",
                                    "Discuta impacto computacional: custo alto para rigidez severa.",
                                    "Plote a região de estabilidade e marque autovalores típicos de problemas stiff (esquerda do plano)."
                                  ],
                                  "verification": "Para λ = -100, calcule h_max ≈ 0.02 e simule 10 passos para verificar decaimento vs. explosão.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python ou MATLAB para simulação simples; exemplos de código online.",
                                  "tips": "Implemente uma simulação numérica rápida para validar teoricamente.",
                                  "learningObjective": "Identificar limitações práticas do Euler explícito em problemas stiff.",
                                  "commonMistakes": "Subestimar o impacto da rigidez; confundir com truncamento vs. instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e interpretar a região de estabilidade",
                                  "subSteps": [
                                    "Desenhe o contorno |1 + z| = 1 no plano z (círculo |z + 1| = 1).",
                                    "Identifique que a metade esquerda do plano (Re(z) < -2) está fora da região.",
                                    "Explique por que métodos explícitos falham em stiff: autovalores fora da região.",
                                    "Discuta A-stabilidade (região inclui toda metade esquerda): ausente em explícitos.",
                                    "Resuma: Euler explícito requer h pequeno para estabilidade em componentes rígidas."
                                  ],
                                  "verification": "Crie um gráfico da região e anote pontos instáveis para λ stiff.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de graficação (Desmos, GeoGebra, Python); régua e compasso para esboço manual.",
                                  "tips": "Use cores para regiões estável/instável para melhor visualização.",
                                  "learningObjective": "Interpretar graficamente as restrições de estabilidade.",
                                  "commonMistakes": "Desenhar círculo errado (centro em 0 ao invés de -1); ignorar parte imaginária."
                                }
                              ],
                              "practicalExample": "Considere y' = -100 y (λ = -100, stiff). Com h=0.01 (estável), y_{n+1} ≈ 0.99 y_n, decai suavemente após 1000 passos. Com h=0.03 (>0.02), |1 - 3| = 2 >1, solução explode oscilatoriamente.",
                              "finalVerifications": [
                                "Derive corretamente |1 + hλ| ≤ 1 e identifique h ≤ 2/|λ| para λ real negativo.",
                                "Desenhe com precisão a região de estabilidade (disco centrado em -1+0i, raio 1).",
                                "Simule numericamente um caso stiff e mostre instabilidade para h grande.",
                                "Explique verbalmente por que explícitos são inadequados para stiff.",
                                "Compare com Euler implícito (região ilimitada na metade esquerda)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação do fator de amplificação (100%).",
                                "Correta identificação e desenho da região de estabilidade (90%+ acurácia visual).",
                                "Análise qualitativa/quantitativa das restrições para stiff (exemplos numéricos).",
                                "Uso correto de terminologia (A-estabilidade, Dahlquist, absolute stability).",
                                "Capacidade de simular e interpretar resultados computacionais.",
                                "Conexão clara entre teoria e limitações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos ou difusão (equações de calor stiff).",
                                "Engenharia Química: Modelagem de reações em série com escalas rígidas.",
                                "Ciência da Computação: Implementação eficiente de solvers ODE em bibliotecas como SciPy.",
                                "Matemática Aplicada: Análise de autovalores em sistemas lineares dinâmicos."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos RC stiff ou reações químicas rápidas/lentas, o Euler explícito exige passos minúsculos, tornando-o ineficiente; motiva uso de métodos implícitos como Backward Euler em softwares como COMSOL ou MATLAB ODE solvers para precisão e velocidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Aplicar métodos explícitos em exemplos simples",
                            "description": "Implementar numericamente um método explícito de passo simples para resolver uma EDO não rígida, calculando passos sucessivos e avaliando o erro local de truncamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema e selecionar o método explícito",
                                  "subSteps": [
                                    "Escolha uma EDO não rígida simples, como y' = -2y, y(0) = 1.",
                                    "Defina o passo de integração h (ex: h=0.1) e o número de passos n (ex: 5).",
                                    "Selecione um método explícito de passo simples, como o método de Euler forward: y_{n+1} = y_n + h*f(t_n, y_n).",
                                    "Escreva a função f(t,y) explicitamente para o exemplo escolhido.",
                                    "Anote a solução exata se conhecida (ex: y(t) = e^{-2t}) para referência futura."
                                  ],
                                  "verification": "Verifique se a EDO está corretamente escrita, h definido e fórmula do método anotada sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, calculadora opcional",
                                  "tips": "Comece com EDOs lineares autônomas para simplicidade.",
                                  "learningObjective": "Compreender a formulação inicial de um problema de EDO não rígida e preparar o método explícito.",
                                  "commonMistakes": "Confundir EDO rígida com não rígida; escolher h muito grande que cause instabilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o primeiro passo numérico",
                                  "subSteps": [
                                    "Calcule f(t_0, y_0) usando os valores iniciais.",
                                    "Aplique a fórmula do método: y_1 = y_0 + h * f(t_0, y_0).",
                                    "Atualize t_1 = t_0 + h.",
                                    "Compare y_1 aproximado com y(t_1) exato para estimar erro inicial.",
                                    "Registre os valores em uma tabela: n, t_n, y_n, f(t_n,y_n)."
                                  ],
                                  "verification": "Confira cálculos aritméticos e se y_1 está correto dentro de 0.01 de precisão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, calculadora",
                                  "tips": "Use precisão de 4 casas decimais para evitar erros de arredondamento acumulados.",
                                  "learningObjective": "Executar o primeiro passo do método explícito com precisão.",
                                  "commonMistakes": "Esquecer de multiplicar por h; sinal errado na função f."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Iterar para passos sucessivos",
                                  "subSteps": [
                                    "Para n=1 a 4, calcule f(t_n, y_n).",
                                    "Compute y_{n+1} = y_n + h * f(t_n, y_n) e t_{n+1} = t_n + h.",
                                    "Preencha a tabela com todos os valores até y_5.",
                                    "Plote graficamente os pontos (t_n, y_n) versus solução exata.",
                                    "Observe o comportamento da aproximação ao longo dos passos."
                                  ],
                                  "verification": "Tabela completa sem discrepâncias aritméticas entre passos consecutivos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, calculadora, software de plotagem como Desmos ou Excel opcional",
                                  "tips": "Mantenha uma tabela organizada para facilitar detecção de erros.",
                                  "learningObjective": "Implementar iterações múltiplas do método e visualizar a aproximação.",
                                  "commonMistakes": "Erro de propagação ao copiar y_n incorreto; não atualizar t_n."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar o erro local de truncamento",
                                  "subSteps": [
                                    "Para cada passo, calcule erro local: e_n = |y(t_{n+1}) exato - y_{n+1} approx|.",
                                    "Estime o erro local de truncamento usando a fórmula teórica O(h^2) para Euler.",
                                    "Compare erros locais entre passos e verifique se diminuem com h menor (teste opcional com h/2).",
                                    "Calcule erro global acumulado: max |e_n|.",
                                    "Discuta limitações para EDOs não rígidas."
                                  ],
                                  "verification": "Erros calculados corretamente e tabela de erros preenchida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora, tabela anterior",
                                  "tips": "Use solução exata para benchmark; foque em erro local por passo.",
                                  "learningObjective": "Quantificar e analisar o erro local de truncamento no método explícito.",
                                  "commonMistakes": "Confundir erro local com global; usar aproximação em vez de exata para benchmark."
                                }
                              ],
                              "practicalExample": "Resolva y' = -2y, y(0)=1 com Euler forward, h=0.1, para 5 passos. Solução exata: y(t)=e^{-2t}. Esperado: y1≈0.804, y2≈0.647, etc., com erros locais ~0.008 por passo.",
                              "finalVerifications": [
                                "Tabela de passos completa e precisa até 4 casas decimais.",
                                "Erros locais calculados e consistentes com O(h^2).",
                                "Gráfico mostra convergência razoável para não rígida.",
                                "Discussão breve sobre adequação do método.",
                                "Nenhum erro aritmético em cálculos manuais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos numéricos (90% correto).",
                                "Correta identificação e aplicação do método explícito.",
                                "Análise adequada do erro local de truncamento.",
                                "Tabela e visualizações claras e organizadas.",
                                "Compreensão demonstrada em explicação dos resultados.",
                                "Uso correto de h e iterações sucessivas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com loops para automação.",
                                "Física: Modelar decaimento radioativo ou circuitos RC não rígidos.",
                                "Engenharia: Simulações iniciais em controle de sistemas lineares.",
                                "Estatística: Análise de erro numérico como variância em aproximações."
                              ],
                              "realWorldApplication": "Em simulações de trajetórias de partículas em fluidos não viscosos ou modelagem de populações biológicas com crescimento exponencial moderado, onde métodos explícitos rápidos são usados em softwares como MATLAB para protótipos iniciais antes de métodos implícitos para casos rígidos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Limitações em Problemas Stiff",
                        "description": "Problemas stiff ocorrem quando a solução tem componentes rápidas e lentas, exigindo passos de tempo muito pequenos nos métodos explícitos para manter a estabilidade, apesar da precisão permitir passos maiores.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Definir e caracterizar problemas stiff",
                            "description": "Explicar o conceito de rigidez usando a razão entre os maiores e menores |Re(λ)| dos autovalores da matriz jacobiana, e identificar exemplos como y' = -1000(y - (1 - e^{-t})) + e^{-t}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de problemas stiff em EDOs",
                                  "subSteps": [
                                    "Revise equações diferenciais ordinárias (EDOs) lineares e não lineares.",
                                    "Leia definições de estabilidade numérica em métodos de Runge-Kutta explícitos.",
                                    "Estude o papel da constante de Lipschitz e escalas de tempo múltiplas em sistemas rígidos.",
                                    "Compare EDOs não rígidos (ex: y' = -y) com rígidos (componentes rápidas e lentas).",
                                    "Anote diferenças entre comportamento analítico e numérico em problemas rígidos."
                                  ],
                                  "verification": "Explique em suas palavras o que torna uma EDO 'stiff' e dê um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo de EDOs)",
                                    "Notas de aula sobre métodos explícitos",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Use analogias como molas rígidas vs. flexíveis para visualizar rigidez.",
                                  "learningObjective": "Definir rigidez como presença de escalas de tempo disparatadas que desafiam métodos explícitos.",
                                  "commonMistakes": [
                                    "Confundir rigidez com não-linearidade.",
                                    "Ignorar o contexto numérico vs. analítico.",
                                    "Pensar que todas as EDOs instáveis são stiff."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a matriz Jacobiana e seus autovalores",
                                  "subSteps": [
                                    "Lembre-se da linearização de EDOs não lineares: f(y,t) ≈ J(y*) (y - y*) onde J é a Jacobiana.",
                                    "Calcule a Jacobiana para uma EDO y' = f(y,t).",
                                    "Compute autovalores λ da Jacobiana usando ferramentas computacionais.",
                                    "Identifique partes reais Re(λ): foque nos menores (negativos grandes) e maiores em magnitude.",
                                    "Discuta rigidez qualitativa: razão |λ_max / λ_min| >> 1 indica stiff."
                                  ],
                                  "verification": "Para uma EDO simples, compute J e liste Re(λ); confirme se é stiff.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software numérico (MATLAB, Python com NumPy/SciPy)",
                                    "Exemplos de EDOs do contexto do curso",
                                    "Tabela de autovalores pré-computados para verificação"
                                  ],
                                  "tips": "Sempre verifique se J é avaliada em equilíbrio ou ponto relevante.",
                                  "learningObjective": "Calcular e interpretar autovalores da Jacobiana para caracterizar rigidez.",
                                  "commonMistakes": [
                                    "Esquecer de usar a Jacobiana em pontos de equilíbrio.",
                                    "Confundir autovalores complexos com reais.",
                                    "Não normalizar magnitudes corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e calcular a razão de rigidez",
                                  "subSteps": [
                                    "Defina formalmente: razão de rigidez r = max|Re(λ)| / min|Re(λ)| onde λ são autovalores de J.",
                                    "Para o exemplo y' = -1000(y - (1 - e^{-t})) + e^{-t}, compute J e autovalores.",
                                    "Calcule r explicitamente: espere r ≈ 1000 devido ao termo -1000.",
                                    "Teste estabilidade: simule com método explícito (ex: Euler) e observe passos necessários.",
                                    "Compare com solução exata y(t) = 1 - e^{-t}."
                                  ],
                                  "verification": "Calcule r para o exemplo dado e justifique por que é stiff (r > 100 tipicamente).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para autovalores e simulação",
                                    "Gráficos de solução exata vs. numérica",
                                    "Papel e lápis para derivação manual"
                                  ],
                                  "tips": "Use eig() em software; valide com casos conhecidos.",
                                  "learningObjective": "Quantificar rigidez via razão de autovalores e relacionar a limitações explícitas.",
                                  "commonMistakes": [
                                    "Usar |Im(λ)| em vez de |Re(λ)|.",
                                    "Calcular razão com autovalores absolutos sem foco em reais negativos.",
                                    "Ignorar dependência em t para Jacobiana tempo-variante."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e caracterizar exemplos de problemas stiff",
                                  "subSteps": [
                                    "Liste exemplos clássicos: Van der Pol com μ grande, reações químicas rígidas.",
                                    "Para o exemplo dado, plote solução e simulações explícitas/implícitas.",
                                    "Classifique: stiff se r > 10^3 ou requer h << 1 para estabilidade.",
                                    "Discuta quando métodos implícitos (ex: BDF) são necessários.",
                                    "Crie seu próprio exemplo modificando coeficientes."
                                  ],
                                  "verification": "Forneça 2 exemplos stiff com cálculo de r e explique limitações explícitas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Biblioteca SciPy odeint/solve_ivp",
                                    "Exemplos de código prontos",
                                    "Artigos introdutórios sobre stiff ODEs"
                                  ],
                                  "tips": "Simule com h pequeno para ver 'rigidez' manifestar como lentidão.",
                                  "learningObjective": "Reconhecer e caracterizar problemas stiff em contextos reais.",
                                  "commonMistakes": [
                                    "Classificar problemas oscilatórios como stiff sem checar r.",
                                    "Não simular para validar teoria.",
                                    "Confundir stiff com singularmente perturbado."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere y' = -1000(y - (1 - e^{-t})) + e^{-t}, y(0)=0. Solução exata: y(t)=1-e^{-t}. Jacobiana J = -1000. Autovalores: λ=-1000. Mas considere sistema equivalente com componente lenta. Simule com Euler explícito: requer h<10^{-3} para estabilidade, enquanto implícito permite h=0.1. Razão efetiva alta devido a termo grande.",
                              "finalVerifications": [
                                "Defina corretamente problemas stiff usando razão de autovalores.",
                                "Calcule J e λ para o exemplo dado com r≈1000.",
                                "Explique por que métodos explícitos falham (passo h limitado por λ_min).",
                                "Identifique 3 exemplos stiff de literatura.",
                                "Simule e compare explícito vs. implícito graficamente.",
                                "Discuta condições para não-stiff (r<10^2 tipicamente)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e fórmula da razão de rigidez (20%)",
                                "Cálculos corretos de Jacobiana e autovalores (25%)",
                                "Análise qualitativa/quantitativa do exemplo dado (20%)",
                                "Identificação de limitações explícitas e necessidade implícitas (15%)",
                                "Exemplos adicionais relevantes e caracterizados (10%)",
                                "Clareza em simulações e gráficos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de circuitos RC com parasitas (rigidez em simulações elétricas).",
                                "Química: Cinética de reações em série com taxas disparatadas.",
                                "Engenharia: Controle de sistemas com polos rápidos/lentos.",
                                "Computação: Otimização de solvers numéricos em SciPy/MATLAB.",
                                "Biologia: Modelos populacionais com decaimento rápido."
                              ],
                              "realWorldApplication": "Em simulações de engenharia química, problemas stiff surgem em reatores com reações rápidas/lentas; caracterizar rigidez guia escolha de solvers implícitos como Gear's method, evitando crashes e acelerando simulações industriais em óleo/gás."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Demonstrar instabilidade em métodos explícitos para stiff",
                            "description": "Simular numericamente um problema stiff com método explícito, mostrando como passos h moderados levam a oscilações ou divergência devido à violação da condição de estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir um problema stiff clássico e revisar o método explícito",
                                  "subSteps": [
                                    "Escolha o problema de valor inicial (IVP) y' = -λ y, y(0) = 1, onde λ = 1000 representa rigidez alta.",
                                    "Calcule a solução exata: y(t) = exp(-λ t), que decai rapidamente para 0.",
                                    "Revise o método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n) = y_n (1 - λ h).",
                                    "Discuta a condição de estabilidade: |1 - λ h| < 1, implicando h < 2/λ ≈ 0.002.",
                                    "Anote valores de h para teste: h_estável = 0.001, h_instável = 0.003."
                                  ],
                                  "verification": "Confirme que a fórmula do método e a condição de estabilidade estão corretas em um caderno ou documento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Caderno, calculadora ou software simbólico como SymPy para solução exata.",
                                  "tips": "Use λ grande (ex: 1000) para simular rigidez real sem computação excessiva.",
                                  "learningObjective": "Compreender a origem da rigidez em EDOs e a formulação do método explícito.",
                                  "commonMistakes": "Confundir método explícito com implícito; ignorar o sinal negativo em λ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método de Euler explícito em código",
                                  "subSteps": [
                                    "Configure um ambiente de programação (Python com NumPy e Matplotlib).",
                                    "Escreva uma função para o método de Euler: def euler_explicit(f, y0, t0, tf, h): ...",
                                    "Implemente f(t,y) = -1000 * y.",
                                    "Gere arrays de tempo e solução para um h fixo.",
                                    "Teste com h=0.001 para verificar convergência básica."
                                  ],
                                  "verification": "Execute o código e confira se para h pequeno, y(t) ≈ exp(-1000 t) em pontos amostrados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python 3+, bibliotecas NumPy, Matplotlib; editor como Jupyter Notebook.",
                                  "tips": "Use loops simples primeiro; vetorize depois para eficiência.",
                                  "learningObjective": "Desenvolver código numérico confiável para integração de EDOs.",
                                  "commonMistakes": "Erro no passo de atualização (esquecer h*f); overflow numérico com h grande."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações com diferentes tamanhos de passo h",
                                  "subSteps": [
                                    "Rode o método com h=0.001 (estável) até t=1.",
                                    "Rode com h=0.003 (instável) até t=1, observando o comportamento.",
                                    "Colete soluções numéricas em arrays para ambos os casos.",
                                    "Compute a solução exata em pontos correspondentes usando np.exp(-1000*t).",
                                    "Salve dados em variáveis para plotting posterior."
                                  ],
                                  "verification": "Verifique se para h=0.003, os valores de y começam a oscilar e crescer em magnitude após t≈0.1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código do passo anterior; acesso a terminal ou notebook.",
                                  "tips": "Limite t_f pequeno (ex: 0.5) para h grande para evitar overflow imediato.",
                                  "learningObjective": "Observar empiricamente o impacto de h na estabilidade numérica.",
                                  "commonMistakes": "Usar h muito pequeno sem notar tempo de computação; não salvar soluções para análise."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e analisar os resultados para demonstrar instabilidade",
                                  "subSteps": [
                                    "Plote y_num vs t para h_estável, h_instável e y_exata no mesmo gráfico.",
                                    "Adicione legendas e títulos explicativos (ex: 'Instabilidade em Método Explícito para Problema Stiff').",
                                    "Zoom em região inicial (t=0 a 0.1) para mostrar decaimento correto vs oscilações.",
                                    "Calcule erro relativo médio para h_estável.",
                                    "Documente observações: oscilações ocorrem quando |1 - λ h| > 1, levando a divergência."
                                  ],
                                  "verification": "O gráfico mostra solução estável colapsando para 0 com h pequeno, mas oscilando/divergindo com h grande.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matplotlib ou similar; código das simulações.",
                                  "tips": "Use plt.semilogy() para escala logarítmica e melhor visualização do decaimento.",
                                  "learningObjective": "Interpretar resultados gráficos para validar teoria de estabilidade.",
                                  "commonMistakes": "Escalas erradas no plot ocultando oscilações; esquecer solução exata como referência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Concluir e relacionar com condição de estabilidade",
                                  "subSteps": [
                                    "Calcule λ h para cada caso e verifique violação da condição |1 - λ h| < 1.",
                                    "Explique por que explícito falha em stiff: região de estabilidade pequena no plano complexo.",
                                    "Sugira métodos implícitos (ex: Backward Euler) como alternativa.",
                                    "Escreva um relatório curto com gráficos e conclusões.",
                                    "Teste um h borderline (ex: 0.002) para transição."
                                  ],
                                  "verification": "Relatório inclui fórmula de estabilidade, cálculos de λ h e justificativa da instabilidade observada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráficos gerados; caderno ou documento.",
                                  "tips": "Mencione região de estabilidade absoluta do Euler (círculo unitário no plano hλ).",
                                  "learningObjective": "Conectar simulação prática com análise teórica de estabilidade.",
                                  "commonMistakes": "Atribuir falha a 'erro de truncamento' em vez de instabilidade; ignorar dependência em λ."
                                }
                              ],
                              "practicalExample": "Implemente Euler explícito para y' = -1000 y, y(0)=1, t em [0, 0.5]. Para h=0.001, solução segue exp(-1000t). Para h=0.003 (λh=3>2), y_n alterna sinal e |y_n| cresce exponencialmente após poucos passos, demonstrando oscilações e divergência.",
                              "finalVerifications": [
                                "Gráficos mostram decaimento correto para h < 2/λ e instabilidade para h > 2/λ.",
                                "Cálculo de 1 - λ h confirma violação da estabilidade.",
                                "Solução numérica com h pequeno aproxima a exata dentro de 1% de erro relativo.",
                                "Oscilações iniciam quando y_n muda de sinal.",
                                "Relatório explica ligação com rigidez do problema.",
                                "Código roda sem erros e reproduz resultados consistentemente."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta do Euler explícito (20%).",
                                "Simulações com h estável/instável e plots claros (30%).",
                                "Análise precisa da condição de estabilidade (20%).",
                                "Relatório bem estruturado com conclusões (15%).",
                                "Uso adequado de ferramentas computacionais (10%).",
                                "Identificação de erros comuns evitados (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de decaimento radioativo ou circuitos RC com constantes de tempo díspares.",
                                "Computação: Algoritmos numéricos e análise de estabilidade em programação científica.",
                                "Engenharia: Simulações de sistemas dinâmicos stiff em controle e aerodinâmica.",
                                "Química: Equações de reações químicas com escalas de tempo múltiplas."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos stiff (ex: capacitores grandes e pequenos), reações químicas (ex: combustão), ou dinâmica molecular, métodos explícitos falham sem h minúsculo, desperdiçando computação; demonstra necessidade de solvers implícitos como em MATLAB ode15s ou SciPy solve_ivp(method='BDF')."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Explicar o controle de passo em contextos stiff",
                            "description": "Discutir como adaptadores de passo em métodos explícitos falham em problemas stiff, exigindo h << 1/|λ_max| para estabilidade, tornando o método ineficiente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender problemas stiff e estabilidade básica em métodos explícitos",
                                  "subSteps": [
                                    "Defina problemas stiff: sistemas de EDOs onde autovalores têm partes reais grandes negativas (λ_max << 0).",
                                    "Revise método de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Analise condição de estabilidade: para estabilidade, |1 + hλ| < 1 para todos autovalores λ.",
                                    "Derive limite: h < 2 / |λ_max| aproximadamente, mas para stiff, h << 1/|λ_max|.",
                                    "Exemplo simples: teste com y' = λy, λ = -1000."
                                  ],
                                  "verification": "Resolva manualmente Euler para λ=-1000 com h=0.01 e h=0.002; observe oscilações ou divergência em h maior.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Análise Numérica (Burden & Faires)",
                                    "Python/MATLAB para simulações simples",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Comece com λ pequeno para contrastar com stiff; plote |1 + hλ| no plano complexo.",
                                  "learningObjective": "Compreender por que stiff impõe restrições severas em h para métodos explícitos.",
                                  "commonMistakes": [
                                    "Confundir estabilidade com precisão; ignorar parte imaginária de λ."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar controle de passo adaptativo em métodos explícitos",
                                  "subSteps": [
                                    "Explique algoritmo de passo adaptativo: estime erro local com dois passos (h e h/2), ajuste h baseado em tolerância τ.",
                                    "Fórmula típica: h_new = h * (τ / err)^{1/(p+1)}, onde p=ordem do método.",
                                    "Implemente em código para ODE não-stiff (ex: y' = -y).",
                                    "Observe: h ajusta dinamicamente para eficiência.",
                                    "Teste com ODE stiff: y' = -1000(y - sin(t))."
                                  ],
                                  "verification": "Execute simulação; verifique se h diminui para <1/1000 em stiff, levando a milhares de passos.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Scipy.integrate.odeint ou ode45 em MATLAB",
                                    "Notebook Jupyter",
                                    "Exemplos de código de Runge-Kutta adaptativo"
                                  ],
                                  "tips": "Use tol=1e-6; monitore histórico de h e número de passos.",
                                  "learningObjective": "Identificar como adaptadores funcionam bem em não-stiff mas falham em stiff.",
                                  "commonMistakes": [
                                    "Não monitorar número total de passos; assumir que erro local captura instabilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar falha do controle de passo em contextos stiff",
                                  "subSteps": [
                                    "Discuta por que erro local subestima instabilidade: componentes stiff decaem rápido, mas explícito amplifica erros.",
                                    "Mostre que h deve satisfazer h << 1/|λ_max| para estabilidade, independentemente de precisão.",
                                    "Compare NFEs (avaliações de f): explícito stiff precisa 10^6 NFEs vs implícito 10^3.",
                                    "Gráficos: h vs tempo para stiff vs não-stiff.",
                                    "Conclua ineficiência: custo computacional explode."
                                  ],
                                  "verification": "Gere gráfico mostrando h caindo para 10^{-4} em stiff e conte NFEs >10^5.",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "Software de plotagem (Matplotlib)",
                                    "Tabela de exemplos stiff clássicos (Robertson, van der Pol μ=100)"
                                  ],
                                  "tips": "Use semi-log plot para h; normalize tempo total.",
                                  "learningObjective": "Explicar quantitativamente a falha dos adaptadores em stiff.",
                                  "commonMistakes": [
                                    "Focar só em erro de truncamento, ignorar estabilidade absoluta."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir necessidade de métodos implícitos",
                                  "subSteps": [
                                    "Resuma: explícitos com adaptadores ineficientes em stiff devido a h minúsculo.",
                                    "Introduza implícitos: estabilidade A-estável (ex: Backward Euler, hλ no semi-plano esquerdo).",
                                    "Compare simulações: explícito vs implícito no mesmo problema.",
                                    "Discuta trade-offs: custo por passo maior, mas h maior possível.",
                                    "Perspectiva: DIRK, BDF para stiff reais."
                                  ],
                                  "verification": "Simule mesmo stiff com método implícito; confirme NFEs << explícito e solução precisa.",
                                  "estimatedTime": "40 min",
                                  "materials": [
                                    "Scipy solve_ivp com method='BDF'",
                                    "Referências: Hairer 'Solving ODEs II'"
                                  ],
                                  "tips": "Use problema padrão: y' = -50(y-1) + sin(t), t=0..10.",
                                  "learningObjective": "Justificar transição para implícitos em stiff.",
                                  "commonMistakes": [
                                    "Achar que adaptadores resolvem tudo; subestimar custo de solves não-lineares."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o problema stiff y' = -1000(y - t/1000), y(0)=0 (aproximação de y=t/1000 com camada parasita). Com Euler explícito adaptativo (RK4, tol=1e-6), h cai para ~10^{-4}, requerendo >10^5 passos para t=1. Implícito (BDF2) usa h~0.1, <100 passos, mesmo resultado preciso.",
                              "finalVerifications": [
                                "Derivar corretamente h < 1/|λ_max| para estabilidade em Euler explícito.",
                                "Simular e mostrar >10^4 NFEs em explícito adaptativo para stiff simples.",
                                "Explicar verbalmente por que erro local não previne instabilidade.",
                                "Comparar gráficos de solução e h para stiff vs não-stiff.",
                                "Identificar quando usar implícito baseado em espectro de autovalores.",
                                "Calcular eficiência: tempo total ou NFEs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da condição de estabilidade (exato hλ limite).",
                                "Correta implementação e interpretação de simulações adaptativas.",
                                "Análise quantitativa de ineficiência (NFEs, h min).",
                                "Clareza na distinção estabilidade vs precisão.",
                                "Uso apropriado de exemplos e gráficos.",
                                "Conexão lógica com métodos implícitos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RLC stiff ou reações químicas rápidas.",
                                "Engenharia de Controle: Sistemas com polos dominantes rápidos (stiff).",
                                "Ciência da Computação: Otimização de solvers numéricos em HPC.",
                                "Química Computacional: Cinemática química com escalas múltiplas."
                              ],
                              "realWorldApplication": "Em simulações de circuitos integrados (SPICE), problemas stiff surgem de capacitores/diodos; adaptadores explícitos falham, exigindo solvers implícitos como Gear para eficiência em design de chips."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Métodos Implícitos e Vantagens para Rigidez",
                        "description": "Métodos implícitos, como o Euler implícito, definem a solução no próximo passo implicitamente, resolvendo um sistema linear ou não-linear, oferecendo estabilidade incondicional para problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Descrever métodos implícitos de passo simples",
                            "description": "Apresentar o método de Euler implícito (y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})) e métodos trapezoidal implícito, destacando a necessidade de iteração para solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de métodos implícitos de passo simples",
                                  "subSteps": [
                                    "Diferencie métodos explícitos de implícitos: nos explícitos, y_{n+1} é calculado diretamente de y_n; nos implícitos, y_{n+1} aparece em ambos os lados da equação.",
                                    "Identifique a equação geral: y_{n+1} = y_n + h * soma de pesos * f(t_k, y_k) onde alguns k incluem n+1.",
                                    "Reconheça a necessidade de métodos implícitos para problemas stiff, onde h é pequeno para estabilidade.",
                                    "Estude a definição formal de métodos de passo simples (one-step).",
                                    "Compare com métodos explícitos como Euler explícito."
                                  ],
                                  "verification": "Escreva uma definição clara e compare com um método explícito em um parágrafo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, quadro branco, acesso a notas de aula sobre EDOs.",
                                  "tips": "Use diagramas de fluxo para visualizar a dependência de y_{n+1}.",
                                  "learningObjective": "Diferenciar métodos implícitos de explícitos e justificar sua relevância.",
                                  "commonMistakes": "Confundir com métodos multi-step; ignorar o papel da rigidez."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o método de Euler implícito",
                                  "subSteps": [
                                    "Derive a fórmula: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Explique por que é implícito: y_{n+1} está no lado direito.",
                                    "Discuta estabilidade: método A-estável para problemas stiff.",
                                    "Implemente um exemplo simples manualmente com iteração inicial y_{n+1}^{(0)} = y_n.",
                                    "Calcule 2-3 iterações para convergência."
                                  ],
                                  "verification": "Resolva um passo com h=0.1 e verifique convergência em 3 iterações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora, planilha Excel ou Python (biblioteca numpy).",
                                  "tips": "Comece com chute inicial próximo para convergência rápida.",
                                  "learningObjective": "Derivar e aplicar a fórmula do Euler implícito.",
                                  "commonMistakes": "Esquecer de iterar; usar fórmula explícita por engano."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o método trapezoidal implícito",
                                  "subSteps": [
                                    "Derive a fórmula: y_{n+1} = y_n + (h/2) [f(t_n, y_n) + f(t_{n+1}, y_{n+1})].",
                                    "Compare ordem de precisão: ordem 2 vs. ordem 1 do Euler.",
                                    "Explique a média trapezoidal na integral.",
                                    "Aplique iteração de ponto fixo: y_{n+1}^{(k+1)} = y_n + (h/2)[f(t_n,y_n) + f(t_{n+1}, y_{n+1}^{(k)})].",
                                    "Verifique estabilidade L-estável."
                                  ],
                                  "verification": "Escreva a fórmula e resolva um passo iterativamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, calculadora, software de programação opcional.",
                                  "tips": "Use extrapolação para melhor chute inicial.",
                                  "learningObjective": "Formular e entender o trapezoidal implícito.",
                                  "commonMistakes": "Confundir pesos (1/2 cada); não iterar o suficiente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aprender técnicas de solução iterativa",
                                  "subSteps": [
                                    "Estude iteração de ponto fixo para resolver y_{n+1} = g(y_{n+1}).",
                                    "Introduza método de Newton: y^{(k+1)} = y^{(k)} - [g(y^{(k)}) - y^{(k)}]/g'(y^{(k)}).",
                                    "Defina critérios de parada: |y^{(k+1)} - y^{(k)}| < tol.",
                                    "Compare convergência: ponto fixo linear, Newton quadrático.",
                                    "Aplique a um exemplo dos passos anteriores."
                                  ],
                                  "verification": "Implemente Newton para um método implícito e conte iterações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python ou MATLAB para simulação.",
                                  "tips": "Escolha tol=1e-6; monitore resíduos.",
                                  "learningObjective": "Dominar iterações para resolver equações implícitas.",
                                  "commonMistakes": "Chute inicial ruim causando divergência; tol muito frouxo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar vantagens para problemas stiff",
                                  "subSteps": [
                                    "Defina problema stiff: autovalores com partes reais negativas grandes.",
                                    "Simule Euler explícito vs. implícito em y' = -100y.",
                                    "Meça passo h máximo estável: explícito h<0.02, implícito h arbitrário.",
                                    "Discuta eficiência computacional apesar de iterações.",
                                    "Conclua quando usar implícitos."
                                  ],
                                  "verification": "Gere gráfico comparativo de erro vs. h.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software numérico (Python com scipy.integrate).",
                                  "tips": "Use problemas teste padrão como van der Pol stiff.",
                                  "learningObjective": "Justificar uso de implícitos em contextos stiff.",
                                  "commonMistakes": "Ignorar custo iterativo; superestimar estabilidade."
                                }
                              ],
                              "practicalExample": "Resolva y' = -50(y - sin(t)), y(0)=0, t de 0 a 1, h=0.1. Use Euler implícito com 3 iterações de ponto fixo por passo. Compare com solução exata aproximada por série.",
                              "finalVerifications": [
                                "Escrever corretamente fórmulas de Euler e trapezoidal implícitos.",
                                "Executar 2 passos completos com iterações convergentes.",
                                "Explicar verbalmente por que implícitos são melhores para stiff.",
                                "Identificar quando usar Newton vs. ponto fixo.",
                                "Gerar tabela de resultados para exemplo prático.",
                                "Discutir limitações como custo computacional."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas derivadas (100% correto).",
                                "Correta implementação iterativa com convergência demonstrada.",
                                "Análise qualitativa de estabilidade e rigidez.",
                                "Uso apropriado de exemplos numéricos.",
                                "Clareza na explicação de vantagens e desvantagens.",
                                "Conexão com contexto de problemas stiff."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RLC stiff.",
                                "Computação: Implementação em bibliotecas como ODEPACK ou SciPy.",
                                "Engenharia Química: Reatores com cinéticas stiff.",
                                "Biologia Computacional: Modelos de populações com escalas rápidas."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular para fármacos (problemas stiff em química quântica), permitindo passos maiores e simulações mais rápidas em softwares como MATLAB Simulink ou COMSOL para engenharia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Analisar estabilidade e A-estabilidade",
                            "description": "Verificar que métodos implícitos como Euler implícito são A-estáveis (região de estabilidade inclui todo o semiplano Re(z) < 0), permitindo h grande em problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação teste linear e conceitos de estabilidade",
                                  "subSteps": [
                                    "Estude a equação diferencial teste y' = λy, onde λ é complexo com Re(λ) < 0.",
                                    "Defina estabilidade absoluta: |y_{n+1}| <= |y_n| para todo h > 0 quando Re(λh) < 0.",
                                    "Revise a função de amplificação R(z), com z = hλ, e a condição |R(z)| <= 1.",
                                    "Discuta problemas stiff: equações com autovalores de magnitudes muito diferentes.",
                                    "Exemplo simples: compare comportamento com Euler explícito."
                                  ],
                                  "verification": "Você consegue explicar verbalmente ou por escrito o que é estabilidade absoluta e por que é relevante para stiff.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica (capítulo de EDOs)",
                                    "Papel e caneta para anotações",
                                    "Software como MATLAB ou Python para plots iniciais"
                                  ],
                                  "tips": "Sempre normalize z = hλ para analisar no plano complexo.",
                                  "learningObjective": "Compreender a base teórica da estabilidade em métodos numéricos para EDOs.",
                                  "commonMistakes": "Confundir estabilidade condicional com incondicional; ignorar o semiplano esquerdo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a função de amplificação para Euler implícito",
                                  "subSteps": [
                                    "Escreva a fórmula do método de Euler implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Aplique à equação teste: y_{n+1} = y_n + h λ y_{n+1}, resolva para y_{n+1}/y_n = R(z) = 1 / (1 - z).",
                                    "Verifique algebricamente: R(z) = 1 / (1 - z).",
                                    "Calcule |R(z)| para z no semiplano esquerdo (Re(z) < 0).",
                                    "Compare brevemente com Euler explícito: R(z) = 1 + z."
                                  ],
                                  "verification": "Derive e escreva corretamente R(z) para Euler implícito e confirme |R(z)| < 1 para Re(z) < 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Caderno para derivações",
                                    "Calculadora ou SymPy/Python para simplificações",
                                    "Referência teórica"
                                  ],
                                  "tips": "Resolva a equação implícita isolando y_{n+1}; pratique com z pequeno.",
                                  "learningObjective": "Derivar com precisão a função de estabilidade do método implícito.",
                                  "commonMistakes": "Erro na álgebra: escrever R(z) = 1 + z em vez de 1/(1 - z); esquecer o sinal em z = hλ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a região de estabilidade no plano z",
                                  "subSteps": [
                                    "Plote |R(z)| = |1 / (1 - z)| no plano complexo.",
                                    "Mostre que para Re(z) < 0, |1 - z| > 1, logo |R(z)| < 1.",
                                    "Verifique o limite: quando |z| → ∞ com Re(z) < 0, R(z) → 0.",
                                    "Confirme que a região inclui todo o semiplano esquerdo.",
                                    "Gere gráfico da fronteira |R(z)| = 1 (eixo imaginário)."
                                  ],
                                  "verification": "Crie um plot da região de estabilidade mostrando inclusão do semiplano Re(z) < 0.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB, Python (matplotlib + numpy) ou papel para esboço",
                                    "Software de plotagem complexa"
                                  ],
                                  "tips": "Use contour plot para |R(z)|; teste pontos como z = -1 + 0i, z = -1 + i.",
                                  "learningObjective": "Visualizar e provar graficamente a região de estabilidade.",
                                  "commonMistakes": "Plotar apenas para z real; confundir região interna/externa da curva."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar A-estabilidade e vantagens em problemas stiff",
                                  "subSteps": [
                                    "Defina A-estabilidade: região de estabilidade contém todo Re(z) < 0.",
                                    "Conclua que Euler implícito é A-estável.",
                                    "Discuta implicações: h pode ser grande sem perda de estabilidade em componentes stiff.",
                                    "Compare com métodos explícitos (região limitada).",
                                    "Exemplo numérico: teste com λ = -1000, h=0.1 vs h=0.01."
                                  ],
                                  "verification": "Explique em um parágrafo por que permite h grande em stiff e dê um exemplo numérico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Solver numérico em Python/MATLAB",
                                    "Exemplos de EDOs stiff"
                                  ],
                                  "tips": "Teste numericamente: rode simulação e observe erro vs h.",
                                  "learningObjective": "Aplicar o conceito de A-estabilidade a cenários práticos de rigidez.",
                                  "commonMistakes": "Achar que A-estável implica preciso para h grande (apenas estável, não preciso)."
                                }
                              ],
                              "practicalExample": "Aplique Euler implícito à EDO y' = -100 y, y(0)=1, com h=0.2 (grande para stiff). Calcule 5 passos manualmente, plote solução exata e numérica, confirmando estabilidade (|y_n| decresce sem oscilações). Compare com Euler explícito que explode.",
                              "finalVerifications": [
                                "Derivação correta de R(z) = 1/(1 - z) para Euler implícito.",
                                "Plot da região de estabilidade inclui todo semiplano Re(z) < 0.",
                                "Explicação clara da definição de A-estabilidade.",
                                "Exemplo numérico demonstrando estabilidade para h grande em stiff.",
                                "Comparação textual com método explícito.",
                                "Identificação de vantagens para problemas stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação e análise de |R(z)| (30%).",
                                "Qualidade do plot da região de estabilidade (25%).",
                                "Compreensão conceitual de A-estabilidade e stiff (20%).",
                                "Exemplo prático com cálculos/verificação numérica (15%).",
                                "Clareza na discussão de implicações e comparações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em osciladores amortecidos e sistemas dinâmicos.",
                                "Engenharia: Simulação de circuitos RLC stiff e controle de processos.",
                                "Ciência da Computação: Implementação de solvers em bibliotecas como SciPy ODEINT.",
                                "Química: Modelagem de reações químicas com escalas múltiplas."
                              ],
                              "realWorldApplication": "Em simulações de reatores químicos stiff (reações rápidas/lentas), onde Euler implícito permite passos h maiores, reduzindo tempo computacional em software industrial como COMSOL ou ANSYS, sem instabilidade numérica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Comparar explícitos e implícitos em problemas stiff",
                            "description": "Comparar numericamente o desempenho de Euler explícito vs. implícito em um EDO stiff, mostrando eficiência do implícito com passos maiores e sem oscilações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e analisar um problema EDO stiff",
                                  "subSteps": [
                                    "Escolha um problema EDO stiff clássico, como y' = -1000(y - cos(t)), y(0) = 0, no intervalo t ∈ [0, 1].",
                                    "Derive ou confirme a solução exata aproximada: y(t) ≈ cos(t).",
                                    "Explique conceitualmente a rigidez: razão de escalas temporais (λ = 1000 grande causa instabilidade em métodos explícitos).",
                                    "Plote a solução exata usando uma ferramenta numérica de alta ordem para referência.",
                                    "Discuta por que problemas stiff desafiam métodos explícitos (restrição CFL-like)."
                                  ],
                                  "verification": "Solução exata plotada e conceito de rigidez explicado em relatório ou notebook.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy, SciPy e Matplotlib",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use SciPy para solução de referência (odeint ou solve_ivp com método não-stiff para baseline).",
                                  "learningObjective": "Compreender a natureza de EDOs stiff e selecionar um exemplo representativo.",
                                  "commonMistakes": [
                                    "Escolher λ muito pequeno (rigidez insuficiente)",
                                    "Ignorar solução exata para baseline",
                                    "Não plotar para visualização inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e simular Euler Explícito",
                                  "subSteps": [
                                    "Escreva o esquema de Euler explícito: y_{n+1} = y_n + h f(t_n, y_n).",
                                    "Implemente em Python com h inicial pequeno (ex: h=0.001) para evitar oscilações.",
                                    "Simule e plote a solução aproximada; reduza h iterativamente até convergência estável.",
                                    "Registre o número de passos (N = T/h), tempo de computação e erro global (||y_num - y_exata||).",
                                    "Observe oscilações ou divergência com h maior (ex: h=0.01)."
                                  ],
                                  "verification": "Gráficos mostram solução instável com h grande e estável apenas com h muito pequeno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Vetorize o código para eficiência; use np.linspace para malha temporal.",
                                  "learningObjective": "Implementar Euler explícito e demonstrar sua limitação em problemas stiff.",
                                  "commonMistakes": [
                                    "Não normalizar erro adequadamente",
                                    "Usar h fixo sem testar sensibilidade",
                                    "Ignorar overhead computacional de passos pequenos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e simular Euler Implícito",
                                  "subSteps": [
                                    "Escreva o esquema de Euler implícito: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Para f linear em y, resolva o sistema linear: y_{n+1} = (1 - h λ)^{-1} (y_n + h g(t_{n+1})), onde λ=1000.",
                                    "Implemente em Python com h maior (ex: h=0.05), sem oscilações.",
                                    "Plote a solução e calcule erro global e tempo de computação.",
                                    "Teste estabilidade com h ainda maior para contrastar com explícito."
                                  ],
                                  "verification": "Solução estável e precisa com h 10-50x maior que no explícito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Para problemas lineares, evite iteradores; fórmula fechada acelera.",
                                  "learningObjective": "Implementar Euler implícito e observar sua robustez em stiff.",
                                  "commonMistakes": [
                                    "Confundir ordem de argumentos em f(t,y)",
                                    "Não inverter corretamente o fator (1 + h|λ|)",
                                    "Esquecer avaliação de f em t_{n+1}"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar numericamente os desempenhos",
                                  "subSteps": [
                                    "Calcule métricas: erro L2, número de passos (N), custo computacional (tempo/N).",
                                    "Gere tabelas comparativas para diferentes h (explícito vs implícito).",
                                    "Plote erros vs h em escala log-log para mostrar ordem e estabilidade.",
                                    "Analise eficiência: implícito permite passos maiores sem oscilações.",
                                    "Conclua vantagens do implícito: estabilidade A-estável para stiff."
                                  ],
                                  "verification": "Tabela e gráficos mostram superioridade numérica do implícito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy, Matplotlib e Pandas para tabelas",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use np.linalg.norm para erros; logscale para plots.",
                                  "learningObjective": "Realizar comparação quantitativa e qualitativa entre métodos.",
                                  "commonMistakes": [
                                    "Comparar com h fixo injusto",
                                    "Não considerar custo por unidade tempo",
                                    "Omitir análise de oscilações visuais"
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: y' = -1000(y - cos(t)), y(0)=0, t∈[0,1]. Euler explícito requer h<0.001 (N>1000 passos) para estabilidade, com oscilações; implícito usa h=0.05 (N=20 passos), erro <1e-3 sem oscilações.",
                              "finalVerifications": [
                                "Gráficos comparativos mostram oscilações no explícito com h grande.",
                                "Tabela de erros confirma precisão similar com N 50x menor no implícito.",
                                "Análise de custo demonstra eficiência do implícito.",
                                "Explicação correta de rigidez e estabilidade A.",
                                "Código reproduzível gera resultados consistentes.",
                                "Conclusão destaca vantagens para problemas stiff."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das simulações (erro <1e-3).",
                                "Correta identificação de oscilações/instabilidade no explícito.",
                                "Uso de h otimizados e comparação justa de eficiência.",
                                "Qualidade dos gráficos e tabelas (legendas, escalas).",
                                "Explicação teórica integrada à análise numérica.",
                                "Código limpo, comentado e vetorizado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python (NumPy).",
                                "Física/Química: Modelos de reações stiff (cinética química).",
                                "Engenharia: Simulações de circuitos RC stiff.",
                                "Estatística: Análise de erro e convergência.",
                                "Computação Científica: Introdução a solvers implícitos (SciPy)."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas rápidas/lentas (stiff), como combustão ou farmacocinética, onde Euler implícito permite passos maiores, reduzindo tempo de simulação em software como COMSOL ou MATLAB ODE solvers industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.4",
                            "name": "Resolver sistemas implícitos com método de Newton",
                            "description": "Aplicar o método de Newton para resolver o sistema não-linear gerado por um método implícito em EDOs não-lineares stiff, configurando a iteração e critério de parada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender métodos implícitos para EDOs stiff",
                                  "subSteps": [
                                    "Revise o conceito de EDOs stiff e limitações dos métodos explícitos (ex.: Runge-Kutta).",
                                    "Estude métodos implícitos como Backward Euler ou Trapezoidal, focando na formulação geral y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Identifique por que isso gera um sistema não-linear F(y_{n+1}) = 0.",
                                    "Compare estabilidade de métodos implícitos vs. explícitos em problemas stiff.",
                                    "Analise exemplos simples de EDOs stiff como y' = -λ(y - 1) com λ grande."
                                  ],
                                  "verification": "Resuma em 3 frases as vantagens dos métodos implícitos e escreva a equação geral de um método implícito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex.: Burden & Faires)",
                                    "Notas de aula sobre EDOs",
                                    "Calculadora ou software como MATLAB/Octave"
                                  ],
                                  "tips": "Visualize a região de estabilidade no plano complexo para entender rigidez.",
                                  "learningObjective": "Entender a motivação e formulação de métodos implícitos em EDOs stiff.",
                                  "commonMistakes": [
                                    "Confundir métodos explícitos com implícitos",
                                    "Ignorar o custo computacional da não-linearidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o sistema não-linear implícito",
                                  "subSteps": [
                                    "Dado y' = f(t,y), discretize com método implícito: y_{n+1} - y_n - h f(t_{n+1}, y_{n+1}) = 0.",
                                    "Para sistemas multivariáveis, generalize para Y_{n+1} - Y_n - h F(t_{n+1}, Y_{n+1}) = 0.",
                                    "Defina a função resíduo R(Y_{n+1}) = Y_{n+1} - Y_n - h F(t_{n+1}, Y_{n+1}).",
                                    "Escolha uma aproximação inicial Y^{(0)}_{n+1} = Y_n (preditor simples).",
                                    "Teste com uma EDO escalar para validar a formulação."
                                  ],
                                  "verification": "Escreva o sistema não-linear para y' = λ y com Backward Euler e verifique R(Y^{(0)}) ≈ 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Exemplos de EDOs stiff em PDF"
                                  ],
                                  "tips": "Sempre normalize o resíduo para facilitar convergência.",
                                  "learningObjective": "Capacitar a derivação precisa do sistema não-linear a partir da discretização implícita.",
                                  "commonMistakes": [
                                    "Esquecer o termo h F",
                                    "Usar f(t_n, y_n) em vez de f(t_{n+1}, y_{n+1})"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar a iteração do método de Newton",
                                  "subSteps": [
                                    "Defina a iteração: Y^{(k+1)}_{n+1} = Y^{(k)}_{n+1} - J^{-1} R(Y^{(k)}_{n+1}), onde J é o Jacobiano.",
                                    "Compute o Jacobiano J = I - h ∂F/∂Y (avaliação analítica ou numérica).",
                                    "Resolva o sistema linear J δY = -R usando decomposição LU ou iterativos.",
                                    "Atualize k até convergência.",
                                    "Implemente em pseudocódigo."
                                  ],
                                  "verification": "Aplique 2 iterações manualmente em um exemplo escalar e verifique redução do resíduo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB/Python (SciPy para solve)",
                                    "Editor de código"
                                  ],
                                  "tips": "Use Jacobiano analítico quando possível para precisão e velocidade.",
                                  "learningObjective": "Dominar a iteração Newton-Raphson adaptada para sistemas não-lineares implícitos.",
                                  "commonMistakes": [
                                    "Invertir J explicitamente (custoso)",
                                    "Má escolha de inicialização levando a divergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir critérios de parada e controle de erro",
                                  "subSteps": [
                                    "Estabeleça ||R(Y^{(k)})|| < tol (ex.: tol=1e-6) ou ||δY|| < atol.",
                                    "Monitore número máximo de iterações (ex.: 20) para evitar loops infinitos.",
                                    "Implemente controle adaptativo de passo h baseado em erros locais.",
                                    "Avalie ordem de precisão do método implícito.",
                                    "Registre histórico de resíduos para diagnosticar convergência."
                                  ],
                                  "verification": "Simule com tol variando e observe número de iterações necessárias.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Python/MATLAB com logging",
                                    "Gráficos de resíduos"
                                  ],
                                  "tips": "Use norma relativa ||R|| / ||Y|| para escalabilidade.",
                                  "learningObjective": "Garantir convergência robusta e eficiente da iteração Newton.",
                                  "commonMistakes": [
                                    "Tol muito rígido causando muitas iterações",
                                    "Ignorar divergência"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com exemplo prático e análise",
                                  "subSteps": [
                                    "Aplique a um EDO stiff: y' = -1000(y^2 - y), y(0)=0.5, com Backward Euler.",
                                    "Compare solução Newton-implícita vs. explícita (instável).",
                                    "Plote solução e resíduos vs. passos.",
                                    "Analise custo computacional (iterações por passo).",
                                    "Generalize para sistemas de EDOs."
                                  ],
                                  "verification": "A solução converge para a exata e é estável para h grande.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código fonte pronto",
                                    "GNUPlot ou Matplotlib para visualização"
                                  ],
                                  "tips": "Teste com h pequeno primeiro para debug.",
                                  "learningObjective": "Aplicar e validar o método completo em contexto real.",
                                  "commonMistakes": [
                                    "Não plotar para visualizar falhas",
                                    "Comparar com solução errada"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a EDO stiff y' = -1000(y - sin(t)), y(0)=0. Discretize com Backward Euler: y_{n+1} = y_n + h (-1000(y_{n+1} - sin(t_{n+1}))). Resolva R(y_{n+1}) = y_{n+1} - y_n + 1000 h (y_{n+1} - sin(t_{n+1})) = 0 com Newton: y^{(k+1)} = y^{(k)} - R/J, J=1+1000h. Inicial y^{(0)}=y_n. Pare quando |R|<1e-8. Para h=0.1, converge em ~3 iterações por passo.",
                              "finalVerifications": [
                                "Explicar verbalmente a iteração Newton para um sistema implícito.",
                                "Implementar código funcional para EDO escalar stiff.",
                                "Identificar Jacobiano correto para F(y)=λ(y-g(t)).",
                                "Demonstrar estabilidade com h=10x maior que explícito.",
                                "Analisar gráfico de resíduos decrescendo.",
                                "Comparar erro global com solução exata."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação do resíduo (100% correto).",
                                "Convergência em <10 iterações médias por passo.",
                                "Código executável sem erros e comentado.",
                                "Análise de estabilidade vs. métodos explícitos.",
                                "Controle de erro com tol adaptativa.",
                                "Eficiência computacional otimizada (Jacobiano analítico)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python (SciPy) ou MATLAB.",
                                "Física Computacional: Modelos de reações químicas stiff.",
                                "Engenharia: Simulações de circuitos RC stiff.",
                                "Otimização: Similaridade com minimização não-convexa.",
                                "Estatística: Análise de erros em métodos numéricos."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas com escalas de tempo rígidas (ex.: combustão), dinâmica de populações ecológicas stiff, ou circuitos elétricos em eletrônica, onde métodos implícitos com Newton garantem estabilidade e precisão em passos de tempo grandes, reduzindo tempo computacional em solvers industriais como COMSOL ou ANSYS."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Métodos Implícitos Estáveis (A-estáveis)",
                    "description": "Métodos como Backward Euler e suas propriedades de estabilidade para problemas stiff.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Métodos Implícitos",
                        "description": "Conceitos fundamentais sobre métodos implícitos de passo único para solução de equações diferenciais ordinárias (EDOs), destacando sua necessidade em problemas stiff devido à estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Diferenciar métodos explícitos e implícitos",
                            "description": "Explicar as diferenças entre métodos explícitos (como Forward Euler) e implícitos, incluindo a dependência da solução atual em si mesma e a necessidade de resolução iterativa em métodos implícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos dos Métodos Explícitos",
                                  "subSteps": [
                                    "Revise a definição de métodos explícitos para EDOs, como o método de Euler Forward.",
                                    "Estude a fórmula geral: y_{n+1} = y_n + h * f(t_n, y_n).",
                                    "Analise como o próximo valor depende apenas de valores conhecidos anteriores.",
                                    "Implemente um exemplo simples em Python ou papel para uma EDO não-stiff.",
                                    "Observe o comportamento em problemas stiff, notando instabilidade."
                                  ],
                                  "verification": "Implemente e plote a solução para uma EDO simples; confirme que avança sem iterações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Python com NumPy e Matplotlib",
                                    "Livro de Análise Numérica (capítulo de EDOs)"
                                  ],
                                  "tips": [
                                    "Comece com h pequeno para ver estabilidade.",
                                    "Use gráficos para visualizar divergência em stiff problems."
                                  ],
                                  "learningObjective": "Identificar que métodos explícitos computam y_{n+1} diretamente de dados prévios sem resolver equações.",
                                  "commonMistakes": [
                                    "Confundir com métodos implícitos ao ignorar dependência.",
                                    "Escolher h muito grande sem testar estabilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os Conceitos dos Métodos Implícitos",
                                  "subSteps": [
                                    "Defina métodos implícitos, como Backward Euler: y_{n+1} = y_n + h * f(t_{n+1}, y_{n+1}).",
                                    "Note a dependência circular: y_{n+1} aparece nos dois lados.",
                                    "Aprenda sobre resolução iterativa, como método de Newton-Raphson.",
                                    "Implemente um exemplo básico iterativamente em código ou manualmente.",
                                    "Compare estabilidade com explícitos em problemas stiff."
                                  ],
                                  "verification": "Resolva iterativamente uma equação implícita até convergência (tolerância < 1e-6).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora ou Python com SciPy para fsolve",
                                    "Exemplos de EDOs stiff do livro-texto"
                                  ],
                                  "tips": [
                                    "Inicialize iteração com valor explícito para aceleração.",
                                    "Monitore número de iterações por passo."
                                  ],
                                  "learningObjective": "Reconhecer a necessidade de resolução numérica devido à dependência auto-referencial em y_{n+1}.",
                                  "commonMistakes": [
                                    "Esquecer iterações e tratar como explícito.",
                                    "Não verificar convergência das iterações."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Chave Entre Explícitos e Implícitos",
                                  "subSteps": [
                                    "Liste diferenças: computacional (direto vs. iterativo), estabilidade (condicional vs. A-estável).",
                                    "Crie uma tabela comparativa: dependência, custo computacional, regiões de estabilidade.",
                                    "Analise rigidez: por que implícitos são melhores para stiff problems.",
                                    "Discuta trade-offs: precisão vs. velocidade.",
                                    "Teste com gráfico de regiões de estabilidade."
                                  ],
                                  "verification": "Crie e preencha uma tabela de comparação com pelo menos 5 diferenças chave.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel para tabela",
                                    "Gráficos de estabilidade de livros ou online"
                                  ],
                                  "tips": [
                                    "Use exemplos numéricos para ilustrar cada diferença.",
                                    "Foco em A-estabilidade para implícitos."
                                  ],
                                  "learningObjective": "Diferenciar explicitamente as características estruturais e de performance.",
                                  "commonMistakes": [
                                    "Ignorar custo iterativo como desvantagem.",
                                    "Generalizar estabilidade sem contexto stiff."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Diferenciação em um Exemplo Prático",
                                  "subSteps": [
                                    "Escolha uma EDO stiff: y' = -1000*y + 1000*(1-y), y(0)=1.",
                                    "Resolva com Forward Euler e Backward Euler para h=0.01.",
                                    "Compare soluções plotadas e erro em relação à solução exata.",
                                    "Conte número de iterações para implícito e passos até instabilidade no explícito.",
                                    "Conclua qual método usar e por quê."
                                  ],
                                  "verification": "Gere plots mostrando estabilidade implícita vs. oscilação explícita.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python (NumPy, Matplotlib, SciPy)",
                                    "Solução exata: y(t) = 1 - 0.5*exp(-1000t)"
                                  ],
                                  "tips": [
                                    "Ajuste h para demonstrar falha explícita claramente.",
                                    "Salve código para reutilização."
                                  ],
                                  "learningObjective": "Aplicar diferenciação prática para validar conceitos teóricos.",
                                  "commonMistakes": [
                                    "Escolher EDO não-stiff, mascarando diferenças.",
                                    "Não plotar para visualização intuitiva."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDO y' = -50*(y - sin(t)), y(0)=0 (stiff devido a coeficiente alto), aplique Forward Euler: explode após poucos passos; Backward Euler: converge iterativamente a passos estáveis, aproximando y(t) ≈ sin(t) suavemente.",
                              "finalVerifications": [
                                "Explique verbalmente 3 diferenças principais sem hesitação.",
                                "Identifique corretamente dependência auto-referencial em equação implícita.",
                                "Preveja instabilidade de explícito em stiff problem com razão.",
                                "Implemente Backward Euler com ≤5 iterações por passo.",
                                "Compare regiões de estabilidade em diagrama.",
                                "Discuta quando preferir cada método."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de dependência (explícito: none; implícito: self).",
                                "Correta identificação de necessidade iterativa em implícitos.",
                                "Análise adequada de estabilidade para stiff vs. não-stiff.",
                                "Uso correto de exemplos numéricos com plots.",
                                "Compreensão de trade-offs computacionais.",
                                "Clareza na tabela ou lista comparativa."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/SciPy.",
                                "Física: Simulações de osciladores amortecidos stiff.",
                                "Engenharia: Modelagem de circuitos RC com rigidez.",
                                "Computação Científica: Otimização de solvers em bibliotecas como ODEPACK."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas stiff (ex: combustão), métodos implícitos como Backward Euler previnem instabilidade numérica, permitindo previsões precisas de concentrações em reatores industriais sem crash do simulador."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Identificar necessidade em problemas stiff",
                            "description": "Reconhecer por que métodos explícitos falham em problemas stiff (exigem passos muito pequenos devido a autovalores com partes reais negativas grandes) e como métodos implícitos permitem passos maiores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de problemas stiff",
                                  "subSteps": [
                                    "Estude a definição formal: problemas stiff ocorrem em EDOs quando há escalas de tempo muito diferentes, tipicamente devido a autovalores com partes reais grandes e negativas.",
                                    "Analise o exemplo clássico y' = -λy com λ >> 1, onde a solução decai rapidamente.",
                                    "Identifique componentes stiff: componentes que decaem muito rápido vs. componentes lentos.",
                                    "Revise conceitos de autovalores e autovetores em sistemas lineares.",
                                    "Discuta estabilidade numérica em métodos de Runge-Kutta explícitos."
                                  ],
                                  "verification": "Explique em suas palavras o que torna um problema stiff e dê um exemplo numérico simples.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notebook Jupyter para plots",
                                    "Artigos sobre stiff ODEs"
                                  ],
                                  "tips": "Visualize com gráficos de soluções analíticas vs. escalas de tempo para entender discrepâncias.",
                                  "learningObjective": "Definir e reconhecer problemas stiff com base em autovalores.",
                                  "commonMistakes": [
                                    "Confundir stiff com não-linearidade.",
                                    "Ignorar o papel da parte real negativa dos autovalores.",
                                    "Achar que todos os problemas rápidos são stiff."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar falhas de métodos explícitos em problemas stiff",
                                  "subSteps": [
                                    "Implemente um método explícito (ex: Euler explícito ou RK4) em um problema stiff como y' = -1000y + sin(t).",
                                    "Observe a necessidade de h << 1/|λ| para estabilidade, resultando em passos muito pequenos.",
                                    "Calcule o passo de estabilidade: para Euler explícito, |1 + hλ| < 1 implica h < 2/|λ|.",
                                    "Compare tempo de computação com solução analítica.",
                                    "Plote regiões de estabilidade no plano complexo hλ."
                                  ],
                                  "verification": "Gere um gráfico mostrando instabilidade com h inadequado e confirme com erro < 1e-3 apenas com h pequeno.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Python com SciPy e Matplotlib",
                                    "Código fonte de métodos explícitos",
                                    "Tabela de regiões de estabilidade"
                                  ],
                                  "tips": "Use λ = 1000 para exagerar o efeito stiff e facilitar observação.",
                                  "learningObjective": "Demonstrar quantitativamente por que métodos explícitos são ineficientes em stiff problems.",
                                  "commonMistakes": [
                                    "Usar h fixo grande sem testar estabilidade.",
                                    "Confundir erro de truncamento com instabilidade.",
                                    "Não normalizar soluções para comparação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir métodos implícitos e sua vantagem",
                                  "subSteps": [
                                    "Estude métodos implícitos como Backward Euler: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Discuta A-estabilidade: métodos estáveis para Re(λ) < 0 em qualquer h > 0.",
                                    "Implemente Backward Euler linearizado para o problema stiff anterior.",
                                    "Compare passos de tempo permitidos: h pode ser O(1) independentemente de |λ|.",
                                    "Analise o custo computacional (iterações de Newton vs. passos pequenos)."
                                  ],
                                  "verification": "Resolva o mesmo problema com implícito usando h 100x maior que no explícito, com erro similar.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Código SciPy odeint com método implícito",
                                    "Documentação de solvers implícitos (ex: radau)",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Comece com problemas lineares para evitar iterações pesadas inicialmente.",
                                  "learningObjective": "Explicar como métodos implícitos superam limitações explícitas via estabilidade incondicional.",
                                  "commonMistakes": [
                                    "Achar implícitos sempre mais lentos sem considerar h.",
                                    "Não linearizar para problemas não-lineares.",
                                    "Ignorar convergência de iterações fixas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar necessidade de implícitos em cenários stiff",
                                  "subSteps": [
                                    "Classifique problemas: teste autovalores da Jacobiana para detectar stiffness (max|Re(λ)| >> 1).",
                                    "Compare eficiência: tempo total vs. precisão para explícito vs. implícito.",
                                    "Discuta critérios heurísticos: razão de escalas de autovalores > 1000.",
                                    "Aplique a um sistema real: reator químico com fast/slow reactions.",
                                    "Resuma regras para escolher solver baseado em stiffness."
                                  ],
                                  "verification": "Crie um fluxograma para decidir 'stiff? -> implícito' dado um problema.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Exemplos de problemas stiff reais (ex: Robertson's chemical kinetics)",
                                    "Ferramentas como MATLAB ode23s vs ode45"
                                  ],
                                  "tips": "Use diagnóstico de stiffness em solvers como ode15s no MATLAB.",
                                  "learningObjective": "Reconhecer quando e por quê usar métodos implícitos em problemas stiff.",
                                  "commonMistakes": [
                                    "Classificar como stiff baseado só em não-linearidade.",
                                    "Subestimar custo de Jacobiana em implícitos.",
                                    "Não validar com múltiplos λ."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o problema stiff y' = -1001*(y - sin(t)) + cos(t), y(0)=1. Com Euler explícito, h deve ser <0.001 para estabilidade, levando a 1000 passos para t=1. Com Backward Euler, h=0.1 funciona com 10 passos e erro <1e-4, demonstrando eficiência.",
                              "finalVerifications": [
                                "Explique a relação entre autovalores negativos grandes e passos pequenos em explícitos.",
                                "Implemente e compare tempos de execução para um problema stiff.",
                                "Identifique stiffness em um novo sistema dado sua Jacobiana.",
                                "Descreva A-estabilidade e dê exemplo de método A-estável.",
                                "Crie um teste diagnóstico para stiffness em código.",
                                "Justifique escolha de solver para um problema real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de stiffness (autovalores, escalas).",
                                "Demonstração correta de falha explícita via simulação.",
                                "Compreensão de estabilidade implícita com exemplos numéricos.",
                                "Eficiência comparativa quantificada (tempo/passo).",
                                "Aplicação correta a problemas reais.",
                                "Ausência de erros conceituais comuns (ex: confundir com oscilatórios).",
                                "Clareza em fluxogramas ou critérios de identificação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RC com parasitas rápidos.",
                                "Química: Cinética de reações com espécies intermediárias rápidas.",
                                "Engenharia: Controle de sistemas com polos dominantes rápidos.",
                                "Biologia Computacional: Modelos de populações com decaimento rápido.",
                                "Ciência de Dados: Otimização stiff em gradiente descendente implícito."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas em reatores industriais (ex: polimerização), problemas stiff surgem de espécies reativas rápidas; métodos implícitos como BDF permitem simulações eficientes para otimização de processos, economizando horas de computação em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Descrever resolução numérica implícita",
                            "description": "Explicar técnicas para resolver equações implícitas, como iteração de ponto fixo ou método de Newton, aplicadas a y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Formulação da Equação Implícita",
                                  "subSteps": [
                                    "Identifique a equação implícita padrão: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Explique por que métodos explícitos falham em problemas stiff (rigidez devido a escalas temporais díspares).",
                                    "Defina A-estabilidade e sua relação com métodos implícitos.",
                                    "Esboce o diagrama de Butcher para um método implícito simples como Backward Euler.",
                                    "Discuta a necessidade de resolver sistemas não-lineares em cada passo."
                                  ],
                                  "verification": "Resuma em um parágrafo a diferença entre métodos explícitos e implícitos, incluindo um exemplo de equação.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta para esboços",
                                    "Software como MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Use analogias como 'mola rígida' para visualizar rigidez em ODEs stiff.",
                                  "learningObjective": "Entender conceitualmente por que equações implícitas surgem e sua importância em problemas stiff.",
                                  "commonMistakes": [
                                    "Confundir passos de métodos explícitos com implícitos",
                                    "Ignorar a dependência de y_{n+1} em f"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Iteração de Ponto Fixo",
                                  "subSteps": [
                                    "Reformule a equação como y_{n+1}^{(k+1)} = g(y_{n+1}^{(k)}), onde g(y) = y_n + h f(t_{n+1}, y).",
                                    "Escolha um ponto inicial y_{n+1}^{(0)} (ex: y_n ou extrapolação).",
                                    "Itere até |y_{n+1}^{(k+1)} - y_{n+1}^{(k)}| < tol.",
                                    "Verifique o teorema de contração: |g'(y)| < 1 para convergência.",
                                    "Teste com h pequeno para garantir estabilidade."
                                  ],
                                  "verification": "Implemente em código e mostre convergência em 5-10 iterações para um exemplo dado.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Exemplo ODE: dy/dt = -1000(y - cos(t)), y(0)=0"
                                  ],
                                  "tips": "Monitore o resíduo em cada iteração para depuração rápida.",
                                  "learningObjective": "Dominar a iteração de ponto fixo para resolver equações implícitas simples.",
                                  "commonMistakes": [
                                    "Escolha de g(y) que não satisfaz Lipschitz <1",
                                    "Ponto inicial ruim levando a divergência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Método de Newton-Raphson",
                                  "subSteps": [
                                    "Defina o resíduo F(y) = y - y_n - h f(t_{n+1}, y) = 0.",
                                    "Compute a Jacobiana J(y) = I - h ∂f/∂y (t_{n+1}, y).",
                                    "Itere y^{(k+1)} = y^{(k)} - J^{-1} F(y^{(k)}).",
                                    "Para escalares, use fórmula explícita; para sistemas, resolva sistema linear.",
                                    "Pare quando ||F(y)|| < tol ou gradiente pequeno."
                                  ],
                                  "verification": "Compare número de iterações com ponto fixo no mesmo exemplo; Newton deve convergir mais rápido.",
                                  "estimatedTime": "75 min",
                                  "materials": [
                                    "Código Python/MATLAB para Newton",
                                    "Mesma ODE stiff do passo anterior"
                                  ],
                                  "tips": "Aproxime Jacobiana numericamente se analítica complexa.",
                                  "learningObjective": "Aplicar Newton para resolução quadrática de implícitos em problemas stiff.",
                                  "commonMistakes": [
                                    "Erro no sinal da Jacobiana",
                                    "Não atualizar Jacobiana por iteração (use quasi-Newton para eficiência)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Convergência, Estabilidade e Escolha de Método",
                                  "subSteps": [
                                    "Analise ordem de convergência: linear para ponto fixo, quadrática para Newton.",
                                    "Teste estabilidade em região de estabilidade (meio-plano esquerdo para A-estável).",
                                    "Compare custo computacional: iterações vs. inversões de matriz.",
                                    "Escolha baseado em problema: ponto fixo para lineares, Newton para não-lineares fortes.",
                                    "Implemente critério adaptativo de tolerância baseado em erro local."
                                  ],
                                  "verification": "Gere gráfico de erro vs. h e vs. iterações para ambos métodos.",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "Gráficos em Matplotlib",
                                    "Documentação SciPy ode solvers"
                                  ],
                                  "tips": "Use h adaptativo para validar em intervalos longos.",
                                  "learningObjective": "Selecionar e justificar método ótimo para resolução implícita.",
                                  "commonMistakes": [
                                    "Ignorar custo de Jacobiana em sistemas grandes",
                                    "Assumir convergência sem teste de Lipschitz"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva dy/dt = -1000(y - cos(t)), y(0)=1, em [0,1] com h=0.01 usando Backward Euler implícito. Inicie com y^{(0)}=y_n. Para Newton: F(y)=y - y_n +1000h(y-cos(t_{n+1})), J=1+1000h. Converge em 3 iterações vs. 20+ do ponto fixo.",
                              "finalVerifications": [
                                "Descreva verbalmente os passos de ambos métodos sem consultar notas.",
                                "Implemente e rode código para ODE stiff, mostrando solução estável.",
                                "Explique por que método implícito é A-estável com diagrama.",
                                "Compare erros truncamento e iteracional em tabela.",
                                "Identifique quando Newton falha e sugira fixes (ex: damping)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 25% (definições corretas de implícito e A-estável).",
                                "Implementação correta: 30% (código roda sem erros, converge).",
                                "Análise comparativa: 20% (prós/contras de cada método).",
                                "Exemplos práticos: 15% (aplica a ODE real).",
                                "Clareza na descrição: 10% (linguagem acionável, sem ambiguidades)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/SciPy (Ciência da Computação).",
                                "Física: Modelagem de sistemas stiff como circuitos RC ou reações químicas.",
                                "Engenharia: Simulações em controle de processos industriais.",
                                "Estatística: Análise de erro e convergência probabilística."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular ou epidemias (modelos SIR stiff), métodos implícitos como TR-BDF2 resolvem passos rígidos eficientemente, permitindo previsões precisas em farmacocinética ou engenharia aeroespacial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Método Backward Euler",
                        "description": "Detalhes do método Backward Euler como exemplo clássico de método implícito de passo único, incluindo formulação e análise de erro.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Derivar a fórmula do Backward Euler",
                            "description": "Derivar a aproximação y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}) a partir da integral da EDO y' = f(t,y), mostrando consistência de ordem 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a forma integral da equação diferencial ordinária (EDO)",
                                  "subSteps": [
                                    "Parta da EDO y' = f(t, y) com condição inicial y(t_0) = y_0.",
                                    "Integre ambos os lados da equação de t_n a t_{n+1}, onde t_{n+1} = t_n + h.",
                                    "Escreva a solução exata: y(t_{n+1}) = y(t_n) + ∫_{t_n}^{t_{n+1}} f(s, y(s)) ds.",
                                    "Discuta a necessidade de aproximação numérica para a integral devido à impossibilidade de computar exatamente.",
                                    "Identifique que métodos implícitos aproximam o integrando no ponto final."
                                  ],
                                  "verification": "Escreva corretamente a forma integral y(t_{n+1}) = y(t_n) + ∫ f ds e explique seu significado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor LaTeX",
                                    "Livro de Análise Numérica (capítulo de EDOs)"
                                  ],
                                  "tips": "Visualize a integral como área sob a curva de f(s, y(s)); isso ajuda a entender aproximações.",
                                  "learningObjective": "Compreender a base integral da discretização de EDOs.",
                                  "commonMistakes": [
                                    "Esquecer a condição inicial",
                                    "Confundir y' com y",
                                    "Não especificar limites de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a aproximação do retângulo à direita (backward)",
                                  "subSteps": [
                                    "Aproxime o integrando f(s, y(s)) ≈ f(t_{n+1}, y(t_{n+1})) constante no intervalo [t_n, t_{n+1}].",
                                    "Justifique essa escolha: captura o comportamento no ponto final, ideal para estabilidade em problemas stiff.",
                                    "Substitua na integral: ∫_{t_n}^{t_{n+1}} f(s, y(s)) ds ≈ h * f(t_{n+1}, y(t_{n+1})).",
                                    "Derive a equação implícita: y(t_{n+1}) ≈ y(t_n) + h f(t_{n+1}, y(t_{n+1})).",
                                    "Compare com o Forward Euler (retângulo à esquerda) para destacar a diferença."
                                  ],
                                  "verification": "Desenhe o retângulo à direita no gráfico de f vs. s e calcule a área aproximada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfica de exemplo simples (ex: y' = -y)",
                                    "Software de plotagem como Desmos ou Python/Matplotlib"
                                  ],
                                  "tips": "Pense em estabilidade: backward 'olha para frente' e corrige erros acumulativos.",
                                  "learningObjective": "Dominar a aproximação integral que leva à fórmula implícita do Backward Euler.",
                                  "commonMistakes": [
                                    "Usar f(t_n, y_n) em vez de f(t_{n+1}, y_{n+1})",
                                    "Confundir com trapezoidal",
                                    "Ignorar o fator h"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever a fórmula discreta e discuti-la",
                                  "subSteps": [
                                    "Denote y_{n+1} ≈ y(t_{n+1}), y_n ≈ y(t_n), t_{n+1} = t_n + h.",
                                    "Escreva y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Explique o caráter implícito: y_{n+1} aparece nos dois lados, requer solução de equação não-linear.",
                                    "Mencione métodos de resolução: iteração de ponto fixo ou Newton-Raphson.",
                                    "Teste com exemplo linear para verificar."
                                  ],
                                  "verification": "Escreva a fórmula y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}) e resolva um passo manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo numérico impresso",
                                    "Calculadora ou Python para verificação"
                                  ],
                                  "tips": "Para lineares, resolva algebricamente: y_{n+1} (1 - h a) = y_n se f = a y.",
                                  "learningObjective": "Formular e interpretar a equação de recursão do Backward Euler.",
                                  "commonMistakes": [
                                    "Escrever explicitamente como forward",
                                    "Esquecer dependência em y_{n+1}",
                                    "Erro na notação de índices"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar a consistência de ordem 1",
                                  "subSteps": [
                                    "Expanda y(t_{n+1}) em série de Taylor: y(t_n + h) = y(t_n) + h y'(t_n) + (h^2/2) y''(ξ).",
                                    "Substitua y' = f(t,y): erro local = (h^2/2) y''(ξ).",
                                    "Para Backward Euler, mostre truncamento local O(h^2), levando a consistência ordem 1.",
                                    "Compare com Forward Euler (também ordem 1, mas menos estável).",
                                    "Discuta A-estabilidade via método das raízes características."
                                  ],
                                  "verification": "Derive o erro local O(h^2) e afirme 'consistente de ordem 1'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha com séries de Taylor",
                                    "Referência: Burden & Faires Análise Numérica"
                                  ],
                                  "tips": "Lembre: consistência ordem p significa erro local O(h^{p+1}).",
                                  "learningObjective": "Demonstrar rigorosamente a precisão e propriedades do método.",
                                  "commonMistakes": [
                                    "Confundir ordem local com global",
                                    "Erro no sinal da série de Taylor",
                                    "Ignorar ξ no resto"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y' = -10y, y(0)=1, h=0.1: Resolva y1 = y0 + 0.1*(-10 y1) → y1 + y1 = 1 → y1 = 0.5. Compare com exato y(0.1) ≈ 0.9048 (erro menor que forward).",
                              "finalVerifications": [
                                "Escreve corretamente y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                "Explica origem da integral e retângulo backward.",
                                "Deriva erro local O(h^2) via Taylor.",
                                "Resolve um passo numérico para EDO linear.",
                                "Discute implícita vs. explícita.",
                                "Afirma consistência ordem 1 com justificativa."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação integral (100%).",
                                "Clareza na explicação da aproximação backward (20%).",
                                "Precisão na análise de erro e ordem (30%).",
                                "Uso correto de notação e índices (10%).",
                                "Capacidade de aplicar em exemplo numérico (20%).",
                                "Compreensão de implicações (estabilidade) (20%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores amortecidos stiff.",
                                "Computação: Implementação em Python/Scipy (solve_ivp com method='BDF').",
                                "Engenharia Química: Reatores com cinéticas rígidas.",
                                "Física Computacional: Simulações de dinâmica molecular."
                              ],
                              "realWorldApplication": "Usado em simuladores de circuitos elétricos stiff (SPICE), previsão meteorológica com EDOs rígidas e controle de processos industriais para estabilidade numérica em problemas com escalas temporais díspares."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Implementar Backward Euler numericamente",
                            "description": "Implementar o método em pseudocódigo ou código simples para resolver y' = λy com λ < 0, demonstrando passos adaptáveis em problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a formulação matemática do Backward Euler",
                                  "subSteps": [
                                    "Revise a equação diferencial ordinária (EDO) y' = f(t, y).",
                                    "Estude a fórmula do Backward Euler: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Identifique por que é implícito: requer solução de equação não linear em y_{n+1}.",
                                    "Para o caso linear y' = λy, simplifique para y_{n+1} = y_n / (1 - hλ).",
                                    "Discuta estabilidade A-estável para λ < 0."
                                  ],
                                  "verification": "Escreva a fórmula simplificada para y' = λy e explique verbalmente sua natureza implícita.",
                                  "estimatedTime": "20-30 minutes",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referência: Livro de Análise Numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Comece com o caso linear para intuition; visualize graficamente a estabilidade.",
                                  "learningObjective": "Compreender a base matemática e a simplificação para problemas lineares stiff.",
                                  "commonMistakes": [
                                    "Confundir com Forward Euler (explícito)",
                                    "Ignorar o termo hλ no denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o pseudocódigo para o caso linear y' = λy",
                                  "subSteps": [
                                    "Defina parâmetros: y0 inicial, λ < 0, h passo, T tempo final, N = T/h passos.",
                                    "Inicialize y[0] = y0, t[0] = 0.",
                                    "Para cada n de 0 a N-1: y[n+1] = y[n] / (1 - h*λ), t[n+1] = t[n] + h.",
                                    "Armazene resultados em arrays para plotting posterior.",
                                    "Adicione loop de saída se ||y_{n+1} - y_n|| < epsilon."
                                  ],
                                  "verification": "Escreva e execute manualmente pseudocódigo para 3 passos com λ=-50, h=0.1, y0=1.",
                                  "estimatedTime": "25-35 minutes",
                                  "materials": [
                                    "Editor de pseudocódigo (ex: Notion ou papel)",
                                    "Calculadora para verificação manual"
                                  ],
                                  "tips": "Use notação array para clareza; teste com valores pequenos primeiro.",
                                  "learningObjective": "Criar pseudocódigo acionável e eficiente para implementação numérica.",
                                  "commonMistakes": [
                                    "Erro no denominador (1 + hλ em vez de 1 - hλ)",
                                    "Índices de array off-by-one"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar em código simples (Python)",
                                  "subSteps": [
                                    "Instale numpy e matplotlib se necessário.",
                                    "Escreva função backward_euler(lambda, y0, h, T).",
                                    "Implemente o loop: y = y / (1 - h*lambda) iterativamente.",
                                    "Plote y vs t e compare com solução exata y = y0 * exp(λt).",
                                    "Adapte para função geral f(t,y) usando fixed-point iteration ou solver simples."
                                  ],
                                  "verification": "Execute o código e verifique que o erro relativo < 1e-3 para T=1.",
                                  "estimatedTime": "30-45 minutes",
                                  "materials": [
                                    "Python com numpy/matplotlib",
                                    "Jupyter Notebook ou IDE"
                                  ],
                                  "tips": "Vectorize com numpy para eficiência; use semilog plot para stiff problems.",
                                  "learningObjective": "Traduzir pseudocódigo em código executável e visualizável.",
                                  "commonMistakes": [
                                    "Divisão por zero se h*|λ|>1",
                                    "Não importar bibliotecas corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e analisar estabilidade em problemas stiff",
                                  "subSteps": [
                                    "Escolha λ = -100 (stiff), h=0.05, compare com Forward Euler (instável).",
                                    "Meça erro L2: sqrt(sum((y_num - y_exact)^2)/N).",
                                    "Varie h e observe ordem de convergência (O(h)).",
                                    "Discuta adaptação para não-lineares via Newton-Raphson básico.",
                                    "Gere relatório com plots e tabela de erros."
                                  ],
                                  "verification": "Produza plot mostrando estabilidade Backward vs instabilidade Forward.",
                                  "estimatedTime": "25-40 minutes",
                                  "materials": [
                                    "Código do Step 3",
                                    "Solução exata: exp(λt)"
                                  ],
                                  "tips": "Use h grande para demonstrar stiff behavior; log-scale para erros.",
                                  "learningObjective": "Validar implementação e demonstrar vantagens em stiff ODEs.",
                                  "commonMistakes": [
                                    "Usar h muito pequeno (perde stiff demo)",
                                    "Erro na solução exata"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y' = -100y, y(0)=1 até t=1 com h=0.1. Backward Euler: y1 = 1/(1+10)=0.0909, y2=0.0909/(1+10)=0.00826, etc. Solução exata ~3.7e-44. Forward Euler explode!",
                              "finalVerifications": [
                                "Pseudocódigo correto para y' = λy.",
                                "Código Python roda sem erros e plota solução estável.",
                                "Erro relativo <1% vs exata para λ=-50, h=0.01.",
                                "Comparação com Forward Euler mostra instabilidade.",
                                "Adaptação comentada para f não-linear.",
                                "Relatório com plots e análise de estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da fórmula implícita (100%).",
                                "Correção do pseudocódigo e código (roda e converge).",
                                "Análise de estabilidade demonstrada graficamente.",
                                "Clareza dos comentários e estrutura do código.",
                                "Adaptabilidade para problemas gerais stiff.",
                                "Eficiência computacional (O(N) tempo)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Loops, arrays, plotting (Python/C++).",
                                "Física: Simulações de decaimento radioativo ou circuitos RC.",
                                "Engenharia: Modelagem de sistemas stiff em controle.",
                                "Computação Científica: Integração com SciPy odeint.",
                                "Matemática Aplicada: Análise de erro e estabilidade."
                              ],
                              "realWorldApplication": "Usado em simulações de reações químicas stiff (ex: combustão), circuitos elétricos com capacitores, modelagem climática e farmacocinética, onde métodos explícitos falham por instabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Analisar erro de truncamento local",
                            "description": "Calcular o erro de truncamento local do Backward Euler usando expansão em série de Taylor, confirmando ordem O(h^2).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a fórmula do método Backward Euler",
                                  "subSteps": [
                                    "Escreva a equação diferencial y' = f(t, y).",
                                    "Recapitule a fórmula do Backward Euler: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Identifique os termos implícitos e explique por que é implícito.",
                                    "Compare brevemente com o Forward Euler para destacar diferenças.",
                                    "Anote as condições de estabilidade A-estável."
                                  ],
                                  "verification": "Verifique se a fórmula está corretamente escrita e se você pode resolver um exemplo simples iterativamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (capítulo de métodos implícitos)",
                                    "Calculadora"
                                  ],
                                  "tips": "Lembre-se: o Backward Euler é implícito, então requer solução de equação não linear em cada passo.",
                                  "learningObjective": "Compreender a discretização implícita do Backward Euler para problemas stiff.",
                                  "commonMistakes": "Confundir com Forward Euler (explícito: y_{n+1} = y_n + h f(t_n, y_n))."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expandir a solução exata em série de Taylor",
                                  "subSteps": [
                                    "Expanda y(t_{n+1}) ao redor de t_n: y(t_n + h) = y_n + h y'(t_n) + (h^2/2) y''(t_n) + (h^3/6) y'''(ξ).",
                                    "Expanda y'(t_{n+1}) = y'(t_n + h) = y'(t_n) + h y''(t_n) + (h^2/2) y'''(t_n) + O(h^3).",
                                    "Expresse derivadas superiores usando f: y' = f, y'' = f_t + f_y f, etc.",
                                    "Mantenha termos até O(h^2) para análise de erro local.",
                                    "Substitua y_n = y(t_n) para precisão."
                                  ],
                                  "verification": "Confirme que a expansão coincide com a solução exata conhecida para uma ODE teste simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de derivadas de Taylor para f(t,y)",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Use notação ξ para o resto de Lagrange para rigor.",
                                  "learningObjective": "Dominar a expansão em Taylor da solução exata e suas derivadas.",
                                  "commonMistakes": "Esquecer o termo f_y f na y'' ou truncar cedo demais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar expansão na fórmula do Backward Euler",
                                  "subSteps": [
                                    "Substitua y_{n+1} na fórmula: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Expanda f(t_{n+1}, y_{n+1}) usando Taylor em t_{n+1} e y_{n+1}.",
                                    "Aproxime iterativamente ou use expansão assintótica: assuma y_{n+1} = y_n + h y'_n + O(h^2).",
                                    "Calcule f(t_{n+1}, y_{n+1}) ≈ f(t_n, y_n) + h (f_t + f_y y') + O(h^2).",
                                    "Multiplique por h e some a y_n para obter y_{n+1} numérico."
                                  ],
                                  "verification": "Verifique se os termos até O(h) coincidem com a solução exata.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Folha com expansões parciais",
                                    "Calculadora para coeficientes"
                                  ],
                                  "tips": "Faça expansões separadas para argumentos de f e combine.",
                                  "learningObjective": "Aplicar corretamente expansões de Taylor na discretização implícita.",
                                  "commonMistakes": "Ignorar a dependência implícita e tratar como explícito."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o erro de truncamento local",
                                  "subSteps": [
                                    "Subtraia a expansão exata da expansão numérica: τ = [y(t_{n+1}) - y_{n+1}] / h.",
                                    "Identifique termos cancelados: O(h) cancela, resto é O(h^2).",
                                    "Simplifique o termo principal: geralmente (h/2) (f_t + f_y f - f_y f).",
                                    "Escreva explicitamente τ_h = O(h^2).",
                                    "Confirme para caso geral y' = f(t,y)."
                                  ],
                                  "verification": "O erro local deve ser τ_h = (h/2) y'''(ξ) ou equivalente, confirmando ordem 2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo numérico prévio",
                                    "Referência teórica"
                                  ],
                                  "tips": "Normalize pelo h para erro local por unidade de passo.",
                                  "learningObjective": "Derivar e identificar o erro de truncamento local τ_h.",
                                  "commonMistakes": "Erro na subtração de expansões ou identificação da ordem errada (pensar O(h))."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Confirmar ordem O(h^2) e analisar implicações",
                                  "subSteps": [
                                    "Some os coeficientes do O(h^2) e mostre que é proporcional a h^2.",
                                    "Teste numericamente com h pequeno em uma ODE simples.",
                                    "Discuta por que ordem 2 apesar de implícito (similar a Trapezoidal).",
                                    "Compare com Forward Euler (ordem 1).",
                                    "Anote vantagens para stiff problems."
                                  ],
                                  "verification": "Plot ou tabela mostrando erro ~ h^2 ao reduzir h pela metade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Python/MATLAB para verificação numérica",
                                    "Gráficos de erro"
                                  ],
                                  "tips": "Use log-log plot para confirmar ordem exata.",
                                  "learningObjective": "Validar analiticamente e numericamente a ordem de precisão.",
                                  "commonMistakes": "Confundir truncamento local com global (acumula para O(h))."
                                }
                              ],
                              "practicalExample": "Para y' = -10y (stiff), y(0)=1, h=0.1. Expanda y(1.1) = y(1) + 0.1 y'(1) + (0.01/2) y''(1) + O(0.001). Backward: y1 = y0 + 0.1*(-10 y1) → y1 = 1/(1+1) ≈0.909. Expansões mostram τ_h ≈ (0.1/2) y'''(ξ) confirmando O(h^2).",
                              "finalVerifications": [
                                "Expansão exata y(t_n+h) correta até O(h^3).",
                                "Expansão de f(t_{n+1}, y_{n+1}) precisa.",
                                "Subtração resulta em τ_h = O(h^2).",
                                "Termo principal do erro identificado corretamente.",
                                "Verificação numérica confirma ordem 2.",
                                "Diferenças com métodos explícitos destacadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de expansões Taylor (90% correto).",
                                "Identificação correta do erro local O(h^2).",
                                "Explicação clara da subtração e cancelamentos.",
                                "Uso apropriado de notação assintótica.",
                                "Aplicação em exemplo numérico sem erros aritméticos.",
                                "Análise de implicações para estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar Backward Euler em Python com scipy.solve_ivp.",
                                "Física: Análise de erros em simulações de decaimento radioativo.",
                                "Engenharia: Modelagem de circuitos RLC stiff.",
                                "Computação Científica: Comparação com Runge-Kutta em solvers ODE."
                              ],
                              "realWorldApplication": "Em simulações numéricas de sistemas stiff como reações químicas rápidas, dinâmica molecular ou controle de aeronaves, onde Backward Euler previne instabilidade com erro local O(h^2), permitindo passos maiores em solvers industriais como COMSOL ou MATLAB ODE45(implícito)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Propriedades de Estabilidade A-estável",
                        "description": "Análise da estabilidade dos métodos implícitos, com foco na propriedade A-estável do Backward Euler para problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Definir região de estabilidade absoluta",
                            "description": "Definir a região de estabilidade absoluta A(hλ) para o teste linear y' = λy, e explicar estabilidade para |R(hλ)| ≤ 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema teste linear y' = λy",
                                  "subSteps": [
                                    "Explicar a solução exata: y(t) = y(0) * exp(λ t), onde λ tem Re(λ) < 0 para estabilidade.",
                                    "Discutir o comportamento assintótico: |y(t)| → 0 quando t → ∞ se Re(λ) < 0.",
                                    "Introduzir o passo h e a discretização: y_{n+1} ≈ y_n + h λ y_n para métodos explícitos.",
                                    "Destacar por que problemas stiff requerem análise de estabilidade.",
                                    "Derivar a condição numérica para estabilidade: |R(hλ)| ≤ 1."
                                  ],
                                  "verification": "Resumir em uma frase a solução exata e sua condição de estabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Visualize λ no semiplano esquerdo do plano complexo.",
                                  "learningObjective": "Entender o modelo teste padrão para estabilidade de métodos numéricos.",
                                  "commonMistakes": "Confundir estabilidade do problema contínuo com a do esquema numérico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a função de amplificação R(z)",
                                  "subSteps": [
                                    "Definir z = hλ, onde h > 0 é o passo de tempo.",
                                    "Explicar que para um método de Runge-Kutta ou linear multistep, y_{n+1} = R(z) y_n.",
                                    "Derivar R(z) para métodos simples: Euler explícito R(z) = 1 + z; Euler implícito R(z) = 1 / (1 - z).",
                                    "Plotar |R(z)| no plano z para métodos conhecidos.",
                                    "Verificar que |R(0)| = 1 para consistência."
                                  ],
                                  "verification": "Calcular R(z) para Euler implícito e verificar |R(0)| = 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)",
                                    "Folha de derivadas de métodos"
                                  ],
                                  "tips": "Use expansões em série de Taylor para aproximar R(z) perto de 0.",
                                  "learningObjective": "Dominar a definição e cálculo da função de amplificação.",
                                  "commonMistakes": "Esquecer que z = hλ, não λ diretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a região de estabilidade absoluta A",
                                  "subSteps": [
                                    "Definir formalmente A = {z ∈ ℂ | |R(z)| ≤ 1}.",
                                    "Desenhar a região A para Euler explícito (disco unitário esquerdo).",
                                    "Comparar com Euler implícito (exterior do disco unitário direito).",
                                    "Explicar que para estabilidade absoluta, hλ deve estar em A.",
                                    "Discutir o mapeamento hλ → z para λ fixo e h variável."
                                  ],
                                  "verification": "Esboçar a região A para dois métodos e rotulá-la corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Plano complexo impresso ou digital",
                                    "Exemplos de regiões de estabilidade de livros"
                                  ],
                                  "tips": "Use simetria e propriedades analíticas de R(z) para delinear A.",
                                  "learningObjective": "Definir precisamente a região de estabilidade absoluta.",
                                  "commonMistakes": "Confundir A com a região de estabilidade relativa ou condicional."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar estabilidade para |R(hλ)| ≤ 1 e A-estabilidade",
                                  "subSteps": [
                                    "Derivar que |y_n| ≤ |y_0| se |R(hλ)| ≤ 1 para todo n.",
                                    "Definir método A-estável: A contém o semiplano {z | Re(z) < 0}.",
                                    "Verificar A-estabilidade para Backward Euler (sim) e Forward Euler (não).",
                                    "Discutir implicações para problemas stiff: h pequeno não necessário se A-estável.",
                                    "Analisar limite h → 0: z → 0 ∈ A."
                                  ],
                                  "verification": "Classificar Euler implícito como A-estável com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python para testar estabilidade numérica",
                                    "Gráficos de regiões A-estáveis"
                                  ],
                                  "tips": "Teste numericamente |R(z)| em pontos do semiplano esquerdo.",
                                  "learningObjective": "Conectar |R(hλ)| ≤ 1 à estabilidade prática e A-estabilidade.",
                                  "commonMistakes": "Ignorar que A-estabilidade requer o semiplano inteiro, não só parte."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e verificar o conceito",
                                  "subSteps": [
                                    "Resolver numericamente y' = -100 y com h=0.1 para métodos A e não A-estáveis.",
                                    "Comparar erros e oscilações.",
                                    "Generalizar para sistemas lineares Y' = A Y.",
                                    "Explorar L-estabilidade (adicional para stiff).",
                                    "Documentar conclusões em um relatório curto."
                                  ],
                                  "verification": "Simulação mostra estabilidade apenas para método A-estável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou MATLAB com solvers ode45/ode15s",
                                    "Dados de teste stiff"
                                  ],
                                  "tips": "Use λ = -100 + 0i para stiff puro.",
                                  "learningObjective": "Aplicar definição em contexto prático.",
                                  "commonMistakes": "Escolher h muito pequeno, mascarando instabilidade."
                                }
                              ],
                              "practicalExample": "Para o método Backward Euler em y' = λy: R(z) = 1/(1 - z). A região A é {z | |1/(1 - z)| ≤ 1}, que é o semiplano Re(z) ≤ 0. Teste com λ = -50, h=0.1: z=-5, |R(-5)| = 1/6 <1, estável; para Forward Euler R(z)=1+z, |1-5|=4>1, instável.",
                              "finalVerifications": [
                                "Definir corretamente A = {z ∈ ℂ | |R(z)| ≤ 1}.",
                                "Explicar |R(hλ)| ≤ 1 implica |y_{n+1}| ≤ |y_n|.",
                                "Identificar semiplano esquerdo como critério para A-estabilidade.",
                                "Plotar A para pelo menos dois métodos.",
                                "Verificar numericamente estabilidade em exemplo stiff.",
                                "Diferenciar estabilidade absoluta de relativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal de A(hλ).",
                                "Correção no cálculo e interpretação de R(z).",
                                "Qualidade dos diagramas de regiões de estabilidade.",
                                "Compreensão de implicações para problemas stiff.",
                                "Uso correto de exemplos numéricos.",
                                "Clareza na explicação de A-estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de difusão/reação (equações diferenciais stiff).",
                                "Computação: Implementação de solvers ODE em Python (scipy.integrate).",
                                "Engenharia: Controle de sistemas dinâmicos com autovalores negativos grandes.",
                                "Estatística: Análise de erros numéricos em modelagem probabilística."
                              ],
                              "realWorldApplication": "Em simulações químicas de reações stiff (ex: combustão), métodos A-estáveis como Backward Euler ou BDF permitem passos h maiores, reduzindo tempo computacional em software como COMSOL ou ANSYS, essencial para engenharia química e aeroespacial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Explicar A-estabilidade",
                            "description": "Definir A-estabilidade como a propriedade em que a região de estabilidade inclui todo o semiplano complexo esquerdo (Re(z) ≤ 0), essencial para problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de estabilidade numérica",
                                  "subSteps": [
                                    "Explicar o que são equações diferenciais ordinárias (EDOs) e métodos numéricos para resolvê-las.",
                                    "Definir estabilidade numérica como a propriedade que garante que erros de arredondamento e truncamento não cresçam descontroladamente.",
                                    "Introduzir o conceito de problemas stiff, onde escalas de tempo muito diferentes causam instabilidade em métodos explícitos.",
                                    "Discutir o teste de Dahlquist para estabilidade linear.",
                                    "Apresentar a equação teste y' = λy, com λ complexo."
                                  ],
                                  "verification": "Escrever um resumo de 3 frases explicando estabilidade numérica e problemas stiff.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Slides sobre EDOs",
                                    "Calculadora ou software como MATLAB"
                                  ],
                                  "tips": "Use exemplos simples como y' = -y (não stiff) vs y' = -1000y + y^2 (stiff).",
                                  "learningObjective": "Compreender a base teórica da estabilidade em métodos numéricos para EDOs.",
                                  "commonMistakes": [
                                    "Confundir estabilidade numérica com convergência.",
                                    "Ignorar o papel dos autovalores negativos grandes em problemas stiff."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o plano complexo e regiões de estabilidade",
                                  "subSteps": [
                                    "Desenhar o plano complexo z = hλ, onde h é o passo de tempo e λ é o autovalor.",
                                    "Explicar o semiplano esquerdo: Re(z) ≤ 0, região onde soluções analíticas decaem.",
                                    "Definir a região de estabilidade absoluta S como {z ∈ ℂ | |R(z)| ≤ 1}, onde R(z) é a função de amplificação.",
                                    "Plotar regiões de estabilidade para métodos explícitos (ex: Euler explícito, disco pequeno) vs implícitos.",
                                    "Comparar visualmente por que métodos explícitos falham em problemas stiff."
                                  ],
                                  "verification": "Desenhar e rotular o plano complexo com o semiplano esquerdo e uma região de estabilidade exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de plotagem (Python/MATLAB)",
                                    "Tabelas de funções de amplificação R(z)"
                                  ],
                                  "tips": "Use cores diferentes para regiões: azul para estável, vermelho para instável.",
                                  "learningObjective": "Visualizar e interpretar o plano z e regiões de estabilidade.",
                                  "commonMistakes": [
                                    "Confundir hλ com λ diretamente.",
                                    "Esquecer que z = hλ escala com o tamanho do passo h."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e caracterizar A-estabilidade",
                                  "subSteps": [
                                    "Definir A-estabilidade: Um método é A-estável se S ⊇ {z ∈ ℂ | Re(z) ≤ 0}.",
                                    "Explicar que isso permite passos h arbitrariamente grandes para λ com Re(λ) < 0.",
                                    "Derivar ou recordar que métodos de Runge-Kutta implícitos de ordem ≥2 podem ser A-estáveis.",
                                    "Introduzir o teorema de Dahlquist: ordem máxima 2 para métodos A-estáveis lineares multistep.",
                                    "Discutir implicações para problemas stiff: estabilidade incondicional no semiplano esquerdo."
                                  ],
                                  "verification": "Escrever a definição formal de A-estabilidade e citar um exemplo de método A-estável.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Referência: Hairer et al. 'Solving ODEs'",
                                    "Caneta e papel para derivações"
                                  ],
                                  "tips": "Memorize: Trapezoidal e Backward Euler são A-estáveis.",
                                  "learningObjective": "Definir precisamente A-estabilidade e suas propriedades matemáticas.",
                                  "commonMistakes": [
                                    "Pensar que A-estabilidade implica ordem alta.",
                                    "Confundir com consistência."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e exemplificar A-estabilidade em contextos práticos",
                                  "subSteps": [
                                    "Comparar Backward Euler (A-estável) vs Forward Euler em um problema stiff.",
                                    "Calcular numericamente |R(z)| para z no semiplano esquerdo.",
                                    "Discutir limitações: A-estabilidade não garante eficiência (daí L-estabilidade).",
                                    "Listar métodos A-estáveis comuns: Radau IIA, TR-BDF2.",
                                    "Explorar quando usar métodos A-estáveis vs não."
                                  ],
                                  "verification": "Resolver um EDO stiff simples com dois métodos e comparar estabilidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software numérico (Scilab, Octave)",
                                    "Exemplo de código pronto"
                                  ],
                                  "tips": "Teste com λ = -1000 + 0i para stiff severo.",
                                  "learningObjective": "Aplicar o conceito de A-estabilidade em simulações numéricas.",
                                  "commonMistakes": [
                                    "Escolher h muito pequeno desnecessariamente em métodos A-estáveis.",
                                    "Ignorar custo computacional de métodos implícitos."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente y' = -1000(y - 1) + 0.1 sin(t), y(0)=1, com h=0.1 usando Backward Euler (A-estável) vs Euler explícito. Observe que Euler explícito explode, enquanto Backward Euler permanece estável, demonstrando a inclusão do semiplano esquerdo.",
                              "finalVerifications": [
                                "Definir corretamente A-estabilidade usando o semiplano Re(z) ≤ 0.",
                                "Plotar e interpretar uma região de estabilidade A-estável.",
                                "Identificar métodos A-estáveis (ex: Backward Euler).",
                                "Explicar por que A-estabilidade é crucial para problemas stiff.",
                                "Comparar A-estabilidade com estabilidade em disco.",
                                "Resolver um exemplo numérico stiff com método A-estável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (incluindo notação Re(z) ≤ 0).",
                                "Compreensão visual do plano complexo e regiões S.",
                                "Capacidade de citar teoremas e exemplos corretos.",
                                "Análise qualitativa/quantitativa de problemas stiff.",
                                "Clareza na explicação de implicações práticas.",
                                "Ausência de confusões com outros conceitos de estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas dinâmicos stiff em mecânica quântica ou reações químicas.",
                                "Computação: Implementação de solvers numéricos em bibliotecas como SciPy ou ODEPACK.",
                                "Engenharia: Simulações de controle automático e circuitos elétricos.",
                                "Matemática Aplicada: Análise de autovalores em álgebra linear."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas rápidas (stiff), como combustão ou farmacocinética, métodos A-estáveis permitem passos de tempo grandes, reduzindo tempo computacional em software como COMSOL ou ANSYS para engenharia química e aeroespacial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Verificar A-estabilidade do Backward Euler",
                            "description": "Calcular a função de amplificação R(z) = 1/(1 - z) para Backward Euler e provar que |R(z)| ≤ 1 para todo Re(z) ≤ 0, contrastando com métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar a função de amplificação R(z) para o Backward Euler",
                                  "subSteps": [
                                    "Considere o problema teste y' = λ y, cuja solução exata é y(t) = y(0) exp(λ t).",
                                    "Aplique o método Backward Euler: y_{n+1} = y_n + h λ y_{n+1}.",
                                    "Rearranje a equação: y_{n+1} (1 - h λ) = y_n.",
                                    "Obtenha a razão de amplificação: y_{n+1}/y_n = R(h λ) = 1 / (1 - h λ).",
                                    "Defina z = h λ, resultando em R(z) = 1 / (1 - z)."
                                  ],
                                  "verification": "Verifique se R(z) = 1/(1 - z) está corretamente derivado e escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro-texto de Análise Numérica"
                                  ],
                                  "tips": "Sempre isole y_{n+1} para obter a forma explícita da razão de amplificação.",
                                  "learningObjective": "Compreender a derivação da função de amplificação para métodos implícitos de um passo.",
                                  "commonMistakes": [
                                    "Confundir com Forward Euler (R(z) = 1 + z)",
                                    "Esquecer de resolver para y_{n+1} devido à natureza implícita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar |R(z)| no eixo imaginário (fronteira do semiplano esquerdo)",
                                  "subSteps": [
                                    "Considere z = i y, com y real (Re(z) = 0).",
                                    "Calcule R(i y) = 1 / (1 - i y).",
                                    "Compute |R(i y)|^2 = |1|^2 / |1 - i y|^2 = 1 / (1^2 + y^2) = 1 / (1 + y^2) ≤ 1.",
                                    "Conclua que |R(i y)| = 1 / sqrt(1 + y^2) ≤ 1, com igualdade apenas em y=0.",
                                    "Interprete: o método é incondicionalmente estável na fronteira."
                                  ],
                                  "verification": "Mostre que |R(i y)| ≤ 1 para todo y real, com cálculo explícito.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para valores numéricos opcionais"
                                  ],
                                  "tips": "Use a fórmula |a + b i|^2 = a^2 + b^2 para simplificar módulos.",
                                  "learningObjective": "Verificar a estabilidade absoluta na fronteira do semiplano estável.",
                                  "commonMistakes": [
                                    "Esquecer o denominador no módulo",
                                    "Confundir |R(z)| com Re(R(z))"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar |R(z)| ≤ 1 para todo Re(z) ≤ 0",
                                  "subSteps": [
                                    "Seja z = x + i y, com x ≤ 0 e y real.",
                                    "Calcule |1 - z|^2 = |1 - x - i y|^2 = (1 - x)^2 + y^2.",
                                    "Note que 1 - x ≥ 1 (pois x ≤ 0), logo (1 - x)^2 ≥ 1 e y^2 ≥ 0, assim |1 - z|^2 ≥ 1.",
                                    "Portanto, |R(z)| = 1 / |1 - z| ≤ 1.",
                                    "Igualdade ocorre quando x=0 e y=0."
                                  ],
                                  "verification": "Escreva a prova completa mostrando |1 - z|^2 ≥ 1 para Re(z) ≤ 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis"
                                  ],
                                  "tips": "Visualize geometricamente: 1 - z está fora ou no círculo unitário centrado em 0.",
                                  "learningObjective": "Dominar a prova de A-estabilidade usando análise complexa básica.",
                                  "commonMistakes": [
                                    "Erro no sinal de x (lembre x ≤ 0 implica 1 - x ≥ 1)",
                                    "Ignorar o termo y^2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com métodos explícitos e discutir implicações",
                                  "subSteps": [
                                    "Para Forward Euler: R(z) = 1 + z; para z = -a (a > 0 grande), |1 - a| > 1 se a > 2.",
                                    "Região de estabilidade de Forward Euler é disco |z| ≤ 2 no semiplano esquerdo.",
                                    "Backward Euler inclui todo semiplano esquerdo, ideal para problemas stiff (λ com Re(λ) < 0, |h λ| grande).",
                                    "Discuta: métodos explícitos requerem h pequeno, implícitos A-estáveis permitem h maior.",
                                    "Conclua: Backward Euler é A-estável, ao contrário de explícitos."
                                  ],
                                  "verification": "Compare gráficos ou exemplos numéricos de |R(z)| para ambos métodos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Desmos ou MATLAB para plotar regiões de estabilidade (opcional)"
                                  ],
                                  "tips": "Plote |R(z)| no plano complexo para visualização intuitiva.",
                                  "learningObjective": "Entender vantagens de métodos A-estáveis em problemas stiff.",
                                  "commonMistakes": [
                                    "Afirmar que explícitos são A-estáveis",
                                    "Ignorar custo computacional implícito (resolver sistemas)"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente y' = -1000(y - sin(t)), y(0)=1, h=0.1 até t=1. Forward Euler diverge com oscilações; Backward Euler converge suavemente para a solução exata aproximada y(t) ≈ sin(t), demonstrando estabilidade incondicional.",
                              "finalVerifications": [
                                "R(z) = 1/(1 - z) derivado corretamente.",
                                "|R(i y)| ≤ 1 provado para y real.",
                                "|R(z)| ≤ 1 demonstrado para Re(z) ≤ 0 com prova rigorosa.",
                                "Contraste claro com Forward Euler (não A-estável).",
                                "Implicações para problemas stiff explicadas.",
                                "Exemplo prático resolvido sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e cálculos de R(z) e |R(z)|.",
                                "Rigor lógico e matemático na prova de A-estabilidade.",
                                "Clareza e completude nos subpassos e explicações.",
                                "Correção no contraste com métodos explícitos.",
                                "Uso adequado de análise complexa e interpretação.",
                                "Aplicação prática demonstrada com exemplo concreto."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estabilidade em simulações de osciladores amortecidos e difusão.",
                                "Engenharia: Solvers para EDOs em controle de sistemas e circuitos RLC stiff.",
                                "Ciência da Computação: Implementação de ODE solvers em bibliotecas como SciPy.",
                                "Química: Modelagem de reações químicas com escalas de tempo díspares."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas stiff (ex.: combustão), onde autovalores têm partes reais negativas grandes, o Backward Euler permite passos de tempo maiores sem instabilidade, otimizando simulações em software como COMSOL ou MATLAB para engenharia química e aeroespacial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.1",
                              "10.1.5.5.3.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.4",
                            "name": "Aplicar a problemas stiff",
                            "description": "Aplicar Backward Euler a um exemplo stiff (ex: y' = -1000y + sin(t)) e comparar estabilidade com Forward Euler, mostrando passos maiores permitidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema stiff e solução referencial",
                                  "subSteps": [
                                    "Escolha o exemplo: y' = -1000y + sin(t), com y(0) = 0 e intervalo t de 0 a 2.",
                                    "Derive ou encontre a solução exata: y(t) = (sin(t) - 1000 cos(t) + 999 e^{-1000t})/1001.",
                                    "Discuta por que é stiff: constante -1000 grande, rigidez devido a escalas temporais díspares.",
                                    "Plote ou descreva o comportamento da solução exata.",
                                    "Calcule valores referenciais em pontos chave (t=0,1,2)."
                                  ],
                                  "verification": "Solução exata implementada e plotada corretamente, coincidente com comportamento esperado (oscilação amortecida rapidamente).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora simbólica (SymPy ou MATLAB), software de plotagem (Python/MATLAB).",
                                  "tips": "Use ferramentas simbólicas para solução exata para evitar erros de cálculo manual.",
                                  "learningObjective": "Compreender a natureza stiff do problema e estabelecer benchmark analítico.",
                                  "commonMistakes": "Ignorar termo exponencial e^{-1000t}, que decai muito rápido; confundir condições iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método Forward Euler",
                                  "subSteps": [
                                    "Escreva a fórmula: y_{n+1} = y_n + h f(t_n, y_n), onde f(t,y) = -1000y + sin(t).",
                                    "Escolha h pequeno (ex: 0.001) e simule até t=2.",
                                    "Aumente h gradualmente (0.01, 0.1) e observe resultados.",
                                    "Plote soluções numéricas vs. exata.",
                                    "Registre número máximo de passos antes de instabilidade."
                                  ],
                                  "verification": "Gráficos mostram oscilações ou divergência para h > 0.002, estável apenas para h muito pequeno.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software numérico (Python com NumPy/Matplotlib ou MATLAB).",
                                  "tips": "Implemente em loop simples primeiro, vetorize depois para eficiência.",
                                  "learningObjective": "Aplicar Forward Euler e identificar limitação de estabilidade (não A-estável).",
                                  "commonMistakes": "Usar h fixo grande sem testar; erro em discretização de sin(t)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método Backward Euler",
                                  "subSteps": [
                                    "Escreva a fórmula implícita: y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}), resolva para y_{n+1}.",
                                    "Para este f linear: y_{n+1} = (y_n + h sin(t_{n+1})) / (1 + 1000 h).",
                                    "Simule com mesmos h de antes (0.001 a 0.1).",
                                    "Plote soluções numéricas vs. exata.",
                                    "Verifique convergência iterativa se necessário (aqui linear, exato)."
                                  ],
                                  "verification": "Solução estável e precisa mesmo para h=0.1, sem oscilações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo software do passo anterior.",
                                  "tips": "Para problemas lineares, fórmula fechada acelera; generalize para não-lineares.",
                                  "learningObjective": "Dominar Backward Euler implícito e sua propriedade A-estável.",
                                  "commonMistakes": "Esquecer de avaliar f em t_{n+1}, y_{n+1}; instabilidade por solver mal implementado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar estabilidade e tamanhos de passo",
                                  "subSteps": [
                                    "Tabela comparativa: h, passos Forward (máx estável), Backward (estável), erro L2 vs. exata.",
                                    "Teste h=0.1: Forward explode, Backward ok.",
                                    "Calcule passos totais: Backward permite ~20x menos para mesmo intervalo.",
                                    "Plote erro vs. h para ambos.",
                                    "Analise razão de estabilidade (região |1 + hλ| <1 vs. |1/(1 - hλ)| sempre <1 para Re(λ)<0)."
                                  ],
                                  "verification": "Tabela e gráficos mostram Backward permite h 10-50x maior sem instabilidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilhas (Excel) ou código para tabelas/plots.",
                                  "tips": "Use logscale em plots de erro para visualizar melhor.",
                                  "learningObjective": "Quantificar vantagem de Backward Euler em problemas stiff.",
                                  "commonMistakes": "Comparar apenas visualmente sem métricas quantitativas; ignorar custo computacional implícito."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e concluir sobre aplicações",
                                  "subSteps": [
                                    "Resuma: Backward Euler A-estável permite passos maiores em stiff problems.",
                                    "Discuta trade-offs: precisão O(h) similar, mas custo por passo maior (implícito).",
                                    "Sugira melhorias: Backward Differentiation Formulas (BDF).",
                                    "Documente relatório com plots e tabela.",
                                    "Teste variação: mude λ=-5000 para stiff mais severo."
                                  ],
                                  "verification": "Relatório completo com conclusões corretas sobre estabilidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto ou Jupyter Notebook.",
                                  "tips": "Inclua código fonte no relatório para reprodutibilidade.",
                                  "learningObjective": "Sintetizar comparação e extrapolar para problemas reais.",
                                  "commonMistakes": "Superestimar estabilidade sem testar h extremo; omitir análise teórica."
                                }
                              ],
                              "practicalExample": "Resolva numericamente y' = -1000y + sin(t), y(0)=0 em [0,2]. Com Forward Euler, h=0.1 explode em oscilações; Backward Euler com h=0.1 dá y(2)≈0.0008 (exata≈0.0008), usando apenas 20 passos vs. 2000 necessários para Forward estável.",
                              "finalVerifications": [
                                "Implementação Backward Euler resolve equação implícita corretamente para f linear.",
                                "Simulação Forward Euler diverge para h=0.1 (||y|| explode).",
                                "Backward Euler estável e erro <1% para h=0.1 vs. solução exata.",
                                "Tabela mostra Backward permite h até 0.2 estável (Forward <0.002).",
                                "Plots superpostos confirmam estabilidade A-estável.",
                                "Relatório resume passos maiores permitidos (~100x)."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação da fórmula Backward Euler (implícita resolvida).",
                                "Evidência quantitativa de instabilidade Forward vs. estabilidade Backward.",
                                "Precisão numérica comparada à exata (erro global O(h)).",
                                "Análise de tamanhos de passo viáveis e trade-offs computacionais.",
                                "Clareza em plots, tabelas e conclusões teóricas.",
                                "Generalização para outros problemas stiff."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação numérica em Python/MATLAB.",
                                "Física: Modelos de reações químicas stiff (cinética rápida/lenta).",
                                "Engenharia: Simulações em controle de processos industriais.",
                                "Cálculo Diferencial: Compreensão de EDOs lineares não-homogêneas.",
                                "Estatística: Análise de erro e convergência numérica."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica molecular, reações químicas (ex: combustão) ou circuitos elétricos com capacitores/diodos, onde escalas stiff exigem passos pequenos em métodos explícitos; Backward Euler permite simulações mais rápidas e estáveis em softwares como COMSOL ou ODE solvers em SciPy."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.2",
                              "10.1.5.5.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.6",
                    "name": "Fórmulas de Diferenciação Backward (BDF)",
                    "description": "Métodos multistep implícitos L-estáveis usados em solvers para EDOs rígidas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.6.1",
                        "name": "Formulação das Fórmulas de Diferenciação Backward (BDF)",
                        "description": "Apresentação das equações multistep implícitas derivadas da interpolação backward para aproximação de derivadas em EDOs.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.6.1.1",
                            "name": "Derivação da fórmula BDF de ordem 1",
                            "description": "Derivar a fórmula BDF1 (método backward Euler) a partir da expansão em série de Taylor ou interpolação polinomial backward, e expressá-la na forma y_{n+1} - y_n = h f(t_{n+1}, y_{n+1}).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Expansão de Taylor Backward Centrada em t_{n+1}",
                                  "subSteps": [
                                    "Relembre a expansão de Taylor geral para uma função suave y(t) ao redor de um ponto t_{n+1}: y(t) = y(t_{n+1}) + (t - t_{n+1}) y'(t_{n+1}) + (1/2)(t - t_{n+1})^2 y''(t_{n+1}) + O(|t - t_{n+1}|^3).",
                                    "Substitua t = t_n = t_{n+1} - h, onde h é o passo de tempo positivo.",
                                    "Expanda y(t_n) = y(t_{n+1} - h) = y(t_{n+1}) - h y'(t_{n+1}) + (h^2/2) y''(t_{n+1}) - (h^3/6) y'''(ξ) para algum ξ entre t_n e t_{n+1}.",
                                    "Identifique os termos principais até O(h^2) para derivação de ordem 1.",
                                    "Anote a relação aproximada y(t_n) ≈ y(t_{n+1}) - h y'(t_{n+1})."
                                  ],
                                  "verification": "Escreva corretamente a expansão de Taylor de y(t_n) em torno de t_{n+1} até o termo quadrático.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora simbólica opcional (como Wolfram Alpha)",
                                    "Livro de Análise Numérica (capítulo de séries de Taylor)"
                                  ],
                                  "tips": "Visualize graficamente: expanda para trás a partir de t_{n+1} até t_n.",
                                  "learningObjective": "Compreender e derivar a expansão de Taylor backward para funções suaves.",
                                  "commonMistakes": [
                                    "Confundir o sinal do termo linear (deve ser -h)",
                                    "Esquecer o resto de Lagrange O(h^3)",
                                    "Expandir para frente em vez de backward"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar a Expansão com a Equação Diferencial Ordinária (EDO)",
                                  "subSteps": [
                                    "Considere a EDO y'(t) = f(t, y(t)) com condição inicial.",
                                    "Substitua y'(t_{n+1}) pela aproximação f(t_{n+1}, y(t_{n+1})) na expansão.",
                                    "Reorganize a expansão para isolar y(t_{n+1}) - y(t_n): y(t_{n+1}) - y(t_n) = h y'(t_{n+1}) - (h^2/2) y''(t_{n+1}) + O(h^3).",
                                    "Aproxime o erro de truncamento: o método será de ordem 1 se ignorarmos O(h^2).",
                                    "Discuta por que isso é 'backward': usa valores em t_{n+1}, que são desconhecidos."
                                  ],
                                  "verification": "Mostre que y(t_{n+1}) - y(t_n) ≈ h y'(t_{n+1}) com erro O(h^2).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplos de EDOs simples (y' = y, y' = -y)"
                                  ],
                                  "tips": "Substitua y'(t_{n+1}) = f(t_{n+1}, y(t_{n+1})) explicitamente.",
                                  "learningObjective": "Conectar a expansão de Taylor à discretização da EDO usando aproximação backward.",
                                  "commonMistakes": [
                                    "Usar f(t_n, y_n) em vez de f(t_{n+1}, y_{n+1})",
                                    "Ignorar o termo de erro quadrático",
                                    "Confundir com forward Euler"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar na Forma Discreta BDF1 e Verificar Ordem",
                                  "subSteps": [
                                    "Aproxime y(t_{n+1}) ≈ y_{n+1}, y(t_n) ≈ y_n, obtendo y_{n+1} - y_n ≈ h f(t_{n+1}, y_{n+1}).",
                                    "Escreva a fórmula final: y_{n+1} - y_n = h f(t_{n+1}, y_{n+1}).",
                                    "Verifique a ordem de consistência: erro local de truncamento é O(h^2), confirmando ordem 1.",
                                    "Compare com interpolação polinomial: polinômio linear p(t) tal que p(t_n) = y_n e p'(t_{n+1}) = f(t_{n+1}, y_{n+1}), levando à mesma fórmula.",
                                    "Teste com EDO linear simples para validar."
                                  ],
                                  "verification": "Derive e escreva a equação y_{n+1} - y_n = h f(t_{n+1}, y_{n+1}) com justificativa do erro O(h^2).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software como MATLAB ou Python (SymPy para derivações simbólicas)"
                                  ],
                                  "tips": "Use notação LaTeX para clareza: y_{n+1} - y_n = h f(t_{n+1}, y_{n+1}).",
                                  "learningObjective": "Obter e validar a fórmula BDF1, incluindo análise de ordem.",
                                  "commonMistakes": [
                                    "Escrever forward Euler por engano",
                                    "Errar o coeficiente de h (deve ser 1)",
                                    "Não mencionar o erro de truncamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Propriedades e Alternativa via Interpolação",
                                  "subSteps": [
                                    "Derive via interpolação: assuma p(t) linear com p(t_n) = y_n e p'(t_{n+1}) = f(t_{n+1}, y_{n+1}).",
                                    "Encontre p(t) = y_n + (t - t_n) f(t_{n+1}, y_{n+1}), então p(t_{n+1}) = y_n + h f(t_{n+1}, y_{n+1}).",
                                    "Confirme equivalência com Taylor: mesma fórmula.",
                                    "Discuta estabilidade para problemas stiff (BDF1 é L-estável).",
                                    "Resuma vantagens do método backward."
                                  ],
                                  "verification": "Mostre derivação alternativa via interpolação levando à mesma fórmula BDF1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Gráfico de polinômio interpolante"
                                  ],
                                  "tips": "Desenhe o polinômio para visualizar a condição em t_n e derivada em t_{n+1}.",
                                  "learningObjective": "Compreender derivação alternativa e propriedades básicas do BDF1.",
                                  "commonMistakes": [
                                    "Confundir condições de interpolação",
                                    "Não igualar p(t_{n+1}) a y_{n+1}",
                                    "Ignorar ligação com Taylor"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDO y' = -y, t em [0,1], y(0)=1. Expansão: y(t_n) ≈ y(t_{n+1}) - h y'(t_{n+1}) = y_{n+1} + h y_{n+1} (pois y'=-y). Então y_{n+1} - y_n = -h y_{n+1}, ou y_{n+1} (1+h) = y_n, y_{n+1} = y_n / (1+h). Solução exata y(t)=e^{-t}, compare numericamente para h=0.1.",
                              "finalVerifications": [
                                "Escreve corretamente y_{n+1} - y_n = h f(t_{n+1}, y_{n+1}).",
                                "Deriva a expansão de Taylor backward até O(h^2).",
                                "Identifica erro local de truncamento como O(h^2).",
                                "Explica equivalência com interpolação linear backward.",
                                "Aplica a um exemplo simples e verifica consistência.",
                                "Discute por que é chamado 'backward'."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor (sinais corretos, termos até O(h^2)).",
                                "Correta substituição de y' por f e reorganização da fórmula.",
                                "Análise de ordem de truncamento justificada.",
                                "Clareza na explicação alternativa via interpolação.",
                                "Exemplo prático resolvido sem erros aritméticos.",
                                "Compreensão conceitual de 'backward' vs 'forward'."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar BDF1 em Python (NumPy/SciPy).",
                                "Física: Modelagem de osciladores amortecidos stiff.",
                                "Engenharia: Simulações em circuitos elétricos (capacitância/indutância).",
                                "Química: Cinética de reações stiff.",
                                "Estatística: Métodos numéricos em processos estocásticos."
                              ],
                              "realWorldApplication": "O BDF1 (Backward Euler) é amplamente usado em solvers de EDOs stiff como ODE15s no MATLAB ou CVODE em Sundials, para simular sistemas dinâmicos em engenharia química (reatores), aeroespacial (órbitas) e biologia computacional (modelos populacionais), onde estabilidade implícita é crucial para passos grandes sem oscilações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.6.1.2",
                            "name": "Generalização para BDF de ordem k",
                            "description": "Obter a fórmula geral BDF_k usando polinômio interpolador backward de grau k-1, identificando os coeficientes α_j e β_k na soma ∑_{j=0}^k α_j y_{n+j} = h β_k f_{n+k}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Polinômios Interpoladores Backward",
                                  "subSteps": [
                                    "Revise a definição de polinômio interpolador de Lagrange e a forma backward usando diferenças divididas.",
                                    "Estude a notação backward com base nos pontos t_n, t_{n-1}, ..., t_{n-k+1}.",
                                    "Pratique construindo um polinômio backward de grau 1 e 2 manualmente.",
                                    "Identifique as vantagens da forma backward para aproximações em problemas stiff.",
                                    "Compare com interpolação forward para entender o foco em pontos passados."
                                  ],
                                  "verification": "Construa corretamente o polinômio backward de grau 2 para pontos dados e verifique interpolação exata nos nós.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de papel e lápis",
                                    "Calculadora científica",
                                    "Notas de aula sobre interpolação de Lagrange/Newton"
                                  ],
                                  "tips": "Use a forma de Newton backward para facilitar expansões em série binomial.",
                                  "learningObjective": "Compreender a construção e propriedades de polinômios interpoladores backward de grau k-1.",
                                  "commonMistakes": [
                                    "Confundir índices forward e backward",
                                    "Esquecer normalização dos fatores binomial",
                                    "Não verificar interpolação nos k+1 pontos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Polinômio Interpolador Backward de Grau k-1",
                                  "subSteps": [
                                    "Defina os k+1 pontos de interpolação: (t_{n+j}, y_{n+j}) para j=0 a k, mas focando em backward de t_n para trás? Ajuste para convenção: pontos y_n a y_{n-k}.",
                                    "Escreva o polinômio p(t) na forma de Newton backward: p(t) = ∑_{m=0}^{k-1} [∇^m y_n] * π_m((t-t_n)/h), onde π_m(u) = ∏_{i=1}^m (u - i +1)/i! wait, binomial backward.",
                                    "Expresse p(t) explicitamente para grau k-1 interpolando y_{n}, y_{n-1}, ..., y_{n-k+1}.",
                                    "Calcule as diferenças divididas backward ∇ y_n, ∇^2 y_n, etc.",
                                    "Verifique para k=2: p(t) deve satisfazer p(t_{n-j}) = y_{n-j} para j=0,1."
                                  ],
                                  "verification": "Escreva p(t) para k=3 e confirme que passa pelos 3 pontos dados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico como Mathematica ou SymPy",
                                    "Tabela de diferenças finitas",
                                    "Livro de análise numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Padronize h=1 inicialmente para simplificar cálculos.",
                                  "learningObjective": "Construir o polinômio interpolador backward de grau k-1 para pontos históricos y.",
                                  "commonMistakes": [
                                    "Índices errados nos pontos (usar forward ao invés de backward)",
                                    "Erros em fórmulas de diferenças divididas",
                                    "Grau incorreto: deve ser k-1 para ordem k"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Aproximação da Derivada para a Fórmula BDF",
                                  "subSteps": [
                                    "Compute a derivada p'(t_{n+k}) usando o polinômio backward construído.",
                                    "Expresse p'(t_{n+k}) em termos de y_{n}, y_{n-1}, ..., y_{n-k+1} e iguale a f_{n+k}.",
                                    "Ajuste para a forma multistep: multiplique por h para obter ∑ α_j y_{n+j} ≈ h β_k f_{n+k}.",
                                    "Note a convenção do prompt: índices de n a n+k, implicando generalização backward shifted.",
                                    "Derive explicitamente para k=1 e k=2 para validar."
                                  ],
                                  "verification": "Obtenha a fórmula BDF_2: α_0 y_{n+2} + α_1 y_{n+1} + α_2 y_n = h β_2 f_{n+2}, com valores corretos (ex: α=(3/2, -2, 1/2), β=3/2? Ajuste padrão).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SymPy ou MATLAB para derivação simbólica",
                                    "Papel para cálculos manuais",
                                    "Referência: Hairer 'Solving ODEs II' capítulo BDF"
                                  ],
                                  "tips": "Use expansão em série de Taylor em torno de t_n para identificar coeficientes.",
                                  "learningObjective": "Derivar a relação diferencial do polinômio levando à forma BDF_k.",
                                  "commonMistakes": [
                                    "Derivar em ponto errado (não em t_{n+k})",
                                    "Fator h incorreto",
                                    "Sinais errados nos coeficientes α"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Generalizar os Coeficientes α_j e β_k",
                                  "subSteps": [
                                    "Expanda p'(t_{n+k}) e colete termos em y_{n+j}, identificando α_j = coef de y_{n+j}.",
                                    "Encontre β_k como o coeficiente da derivada normalizado.",
                                    "Escreva as expressões gerais: α_j = (-1)^{k-j} / (j! (k-j)!) * algo; use fórmula padrão BDF.",
                                    "Verifique consistência de ordem: truncamento erro O(h^k).",
                                    "Gere tabela de coeficientes para k=1 a 5 usando software."
                                  ],
                                  "verification": "Liste α_j e β_k para k=3 corretamente e confirme com literatura.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel ou Python para tabela de coefs",
                                    "Documentação BDF online",
                                    "Livro texto"
                                  ],
                                  "tips": "Use generating functions ou integral representation para fórmula fechada.",
                                  "learningObjective": "Extrair e generalizar os coeficientes na soma BDF_k.",
                                  "commonMistakes": [
                                    "Normalização errada de β_k",
                                    "Índices j de 0 a k invertidos",
                                    "Não somar a zero os coefs para consistência"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Aplicar a Generalização",
                                  "subSteps": [
                                    "Derive BDF para k=1,2,3 e compare com fórmulas conhecidas.",
                                    "Analise estabilidade para problemas stiff.",
                                    "Implemente numericamente para um ODE simples.",
                                    "Discuta limitações (ordem máx 6 por A-stability).",
                                    "Resuma a fórmula geral em notação compacta."
                                  ],
                                  "verification": "Resolva um problema teste com BDF_3 e verifique precisão vs Euler.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/Scipy odeint com BDF",
                                    "Exemplo ODE stiff como van der Pol"
                                  ],
                                  "tips": "Sempre normalize ∑ α_j =0 para consistência nível 1.",
                                  "learningObjective": "Validar a generalização BDF_k e suas propriedades.",
                                  "commonMistakes": [
                                    "Ignorar condições de consistência",
                                    "Confundir BDF com Adams",
                                    "Erros numéricos em implementação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para k=2, construa p(t) interpolando y_n, y_{n-1}; compute p'(t_{n+2}) = (3 y_{n+2} - 4 y_{n+1} + y_n)/(2h) ≈ f_{n+2}, rearranjando para  (3/2) y_{n+2} - 2 y_{n+1} + (1/2) y_n = h f_{n+2}.",
                              "finalVerifications": [
                                "Escreve corretamente o polinômio backward de grau k-1.",
                                "Deriva a forma ∑ α_j y_{n+j} = h β_k f_{n+k}.",
                                "Lista coeficientes para k=1,2,3.",
                                "Explica origem dos coeficientes via interpolação.",
                                "Verifica consistência e ordem de truncamento.",
                                "Implementa BDF_k em código simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção do polinômio backward (80% pesos).",
                                "Correção dos coeficientes α_j, β_k (90% exatidão).",
                                "Clareza na derivação da aproximação diferencial.",
                                "Validação com casos baixos k e literatura.",
                                "Análise de erros comuns e propriedades (stability).",
                                "Capacidade de generalização para ordem arbitrária."
                              ],
                              "crossCurricularConnections": [
                                "Computação: Implementação em solvers ODE como CVODE.",
                                "Física: Simulação de osciladores stiff em mecânica.",
                                "Engenharia: Modelagem reações químicas com escalas múltiplas.",
                                "Estatística: Aproximações em processos estocásticos.",
                                "Programação: Uso de bibliotecas numéricas (SciPy, MATLAB ode45)."
                              ],
                              "realWorldApplication": "BDFs são usados em simuladores industriais para resolver EDOs stiff em engenharia química (reatores), aeroespacial (dinâmica de fluidos), e biologia computacional (modelos populacionais), onde métodos explícitos falham por instabilidade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.6.1.3",
                            "name": "Cálculo de coeficientes BDF para ordens 2 a 6",
                            "description": "Calcular explicitamente os coeficientes das fórmulas BDF2 até BDF6 e discutir limitações práticas (ex: ordem máxima estável é 6).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a formulação geral das fórmulas BDF usando interpolação de Newton backward",
                                  "subSteps": [
                                    "Revise o polinômio interpolador de Newton na forma backward: P(t) = ∑_{k=0}^{q} [∇^k y_n] * π_k(s), onde s = (t - t_n)/h, π_k(s) = ∏_{j=1}^k (s + j - 1)/j.",
                                    "Derive a aproximação da derivada y'(t_n) ≈ (1/h) ∑_{k=1}^{q+1} α_k y_{n+1-k}, identificando os coeficientes α_k.",
                                    "Estabeleça a relação geral para BDFq: ∑_{k=1}^q α_{k,q} (y_n - y_{n+1-k}) / h = β_{q,q} f_n.",
                                    "Memorize que os coeficientes vêm da expansão do polinômio backward no ponto s=0 para a derivada.",
                                    "Pratique com q=1 (BDF1, que é Euler backward: α1=1, β1=1)."
                                  ],
                                  "verification": "Escreva a fórmula geral BDFq e derive os α_k para q=1 corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Calculadora simbólica opcional (Mathematica ou SymPy)"
                                  ],
                                  "tips": "Use tabelas de diferenças finitas backward para visualizar os ∇^k.",
                                  "learningObjective": "Compreender a origem polinomial das BDF e a estrutura dos coeficientes α e β.",
                                  "commonMistakes": "Confundir forma forward com backward; sempre verifique s=0 para y'(t_n)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e calcular coeficientes para BDF2 explicitamente",
                                  "subSteps": [
                                    "Construa o polinômio backward de grau 1: P(s) = y_n + ∇y_n * s.",
                                    "Compute P'(0) = (1/h) [∇y_n + (y_n - y_{n-1})], simplificando para α1=4/3, α2=-1/3, β=2/3.",
                                    "Resolva o sistema linear para α_k resolvendo ∑ α_k = 0 (ordem 0), ∑ k α_k =1 (ordem 1).",
                                    "Verifique numericamente: para h=1, y_n - (4/3)y_{n-1} + (1/3)y_{n-2} = (2/3) f_n.",
                                    "Teste com um exemplo simples: y' = λy, confira consistência."
                                  ],
                                  "verification": "Liste α1=4/3, α2=-1/3, β2=2/3 e demonstre a derivação em 3 linhas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software SymPy para resolver sistemas",
                                    "Tabela de coeficientes BDF padrão para checagem"
                                  ],
                                  "tips": "Comece com o sistema de momentos: ∑_{k=1}^q α_k j^{m-1} = δ_{m1} para m=1 a q.",
                                  "learningObjective": "Calcular coeficientes BDF2 manualmente e entender sua consistência de ordem 2.",
                                  "commonMistakes": "Erros de sinal nos ∇; sempre normalize por h corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar coeficientes para BDF3 e BDF4 usando sistemas lineares",
                                  "subSteps": [
                                    "Para BDF3, resolva o sistema 3x3: ∑ α_k =0, ∑ k α_k=1, ∑ k^2 α_k=0.",
                                    "Calcule: α1=18/11, α2=-9/11, α3=2/11, β3=6/11.",
                                    "Repita para BDF4: sistema 4x4 até ordem 3 zero, obtendo α1=48/25, α2=-36/25, α3=16/25, α4=-3/25, β4=12/25.",
                                    "Use eliminação gaussiana ou software para eficiência.",
                                    "Compare com valores tabulados para validação."
                                  ],
                                  "verification": "Escreva os 4 coeficientes α e β para BDF3 e BDF4 com frações exatas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matriz solver online ou Python/NumPy",
                                    "Folha de exercícios com sistemas",
                                    "Referência: Hairer 'Solving ODEs II' tabela 4.1"
                                  ],
                                  "tips": "Automatize com script: def bdf_coeffs(q): resolva Vandermonde modificado.",
                                  "learningObjective": "Dominar resolução de sistemas para ordens intermediárias BDF.",
                                  "commonMistakes": "Índices errados no sistema (k=1 para y_n, k=q para y_{n-q+1}); teste ordem 1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular coeficientes para BDF5 e BDF6 e compilar tabela completa",
                                  "subSteps": [
                                    "Para BDF5: resolva 5x5, obtendo α1=300/137, α2=-300/137*2, etc., β5=60/137 (use fórmula recursiva se disponível).",
                                    "Para BDF6: 6x6, α1=1093/351, etc., β6=43/351; note precisão numérica.",
                                    "Compile tabela: BDF2 a BDF6 com α_k e β_q em frações reduzidas.",
                                    "Implemente função em Python/MATLAB para gerar e imprimir.",
                                    "Valide truncando série Taylor para ordem q."
                                  ],
                                  "verification": "Forneça tabela completa com todos os 25+ coeficientes corretos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy/SymPy",
                                    "Tabela padrão de BDF para verificação",
                                    "Computador"
                                  ],
                                  "tips": "Frações: use sympy.Rational para exatidão; arredonde só para plot.",
                                  "learningObjective": "Gerar coeficientes para altas ordens e tabular para referência.",
                                  "commonMistakes": "Perda de precisão em float; sempre frações. Ordem errada no Vandermonde."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Discutir limitações práticas e estabilidade das BDF de ordem 2 a 6",
                                  "subSteps": [
                                    "Analise zero da característica ρ(ζ)= ∑ α_k ζ^{k-1}, polynomialidade σ(ζ)=β_q.",
                                    "Mostre que ordem >6 tem raiz |ζ|>1 na região estável A(α)-estável.",
                                    "Compare truncamento local O(h^6) vs custo computacional.",
                                    "Discuta em problemas stiff: BDF6 limite por instabilidade L-stable.",
                                    "Teste numericamente estabilidade com y'=λy, Re(λ)<0."
                                  ],
                                  "verification": "Explique por que max ordem estável=6 e cite raízes relevantes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software MATLAB ode23s para demo",
                                    "Gráfico região A-estável BDF",
                                    "Artigo Dahlby sobre BDF"
                                  ],
                                  "tips": "Plot raízes de ρ para q=2-11; veja |ζ|>1 para q>6.",
                                  "learningObjective": "Avaliar trade-offs práticos das BDF altas ordens.",
                                  "commonMistakes": "Confundir A-estável com L-estável; BDF2-6 são A(α) com α→90°."
                                }
                              ],
                              "practicalExample": "Calcule coeficientes BDF4 e implemente 2 passos para resolver y' = -100(y - sin(t)), y(0)=0, h=0.01 em t=0.02. Compare com solução exata y=sin(t) e verifique erro <1e-4.",
                              "finalVerifications": [
                                "Tabela completa de coeficientes α_k, β_q para BDF2-BDF6 com frações exatas.",
                                "Derivação manual correta para BDF2 e BDF3.",
                                "Implementação numérica funcional em código para pelo menos BDF4.",
                                "Explicação da instabilidade para ordem 7+ com exemplo de raiz |ζ|>1.",
                                "Análise de consistência: erro local O(h^q) demonstrado via Taylor.",
                                "Aplicação em problema stiff modelo com redução de erro vs Euler."
                              ],
                              "assessmentCriteria": [
                                "Precisão e exatidão dos coeficientes calculados (100% frações corretas).",
                                "Clareza na derivação de sistemas lineares e uso de ferramentas.",
                                "Profundidade na discussão de limitações de estabilidade.",
                                "Qualidade do exemplo prático: código funcional e análise de erro.",
                                "Completude da tabela e verificações numéricas.",
                                "Capacidade de generalizar para ordens arbitrárias via código."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de osciladores amortecidos stiff.",
                                "Engenharia Química: modelagem de reatores com cinéticas rápidas.",
                                "Ciência da Computação: implementação em solvers como SUNDIALS CVODE.",
                                "Matemática Aplicada: análise de estabilidade A(α).",
                                "Engenharia Elétrica: circuitos RLC stiff."
                              ],
                              "realWorldApplication": "BDF são essenciais em solvers profissionais como MATLAB ode15s, COMSOL, ou LSODA para simular sistemas stiff em farmacocinética, dinâmica de fluidos, e finanças (modelos Black-Scholes com volatilidade implícita), onde ordens 2-5 equilibram precisão e estabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.6.2",
                        "name": "Propriedades de Estabilidade das BDF",
                        "description": "Análise das regiões de estabilidade absoluta e L-estabilidade, essenciais para problemas stiff.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.6.2.1",
                            "name": "Verificação de A-estabilidade para BDF",
                            "description": "Demonstrar que todas as BDF são A-estáveis para ordens 1 a 6, analisando o polinômio de estabilidade ρ(z) e σ(z) no semiplano esquerdo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as Fórmulas BDF e Derivar os Polinômios ρ(z) e σ(z) para Ordens 1 a 6",
                                  "subSteps": [
                                    "Lembre-se da definição das BDF: método implícito de ordem k para resolver y' = f(y), dado por ∑_{j=0}^k α_j y_{n+j} = h β_k f_{n+k}.",
                                    "Derive os coeficientes α_j e β_k para k=1 a 6 usando aproximação de backward difference para a derivada.",
                                    "Construa o polinômio de característica ρ(z) = ∑_{j=0}^k α_j z^j e o polinômio de estabilidade σ(z) = β_k z^k.",
                                    "Liste explicitamente ρ(z) e σ(z) para cada ordem k=1 a 6 (ex: k=1: ρ(z)=1-z, σ(z)=1).",
                                    "Verifique a consistência: ρ(1)=σ(1)=0 e ρ'(1)=σ'(1)=1."
                                  ],
                                  "verification": "Polinômios ρ(z) e σ(z) corretos listados para todos k=1-6, com coeficientes numéricos exatos (ex: k=2: ρ(z)= (3/2)z^2 - 5/2 z +1, σ(z)=z^2).",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Papel e caneta ou editor LaTeX/Mathematica",
                                    "Tabela de coeficientes BDF padrão"
                                  ],
                                  "tips": "Use tabelas prontas de coeficientes BDF para agilizar, mas derive pelo menos para k=1-2 para compreensão.",
                                  "learningObjective": "Entender a origem algébrica dos polinômios de estabilidade das BDF.",
                                  "commonMistakes": "Erros nos sinais dos coeficientes α_j; confundir ρ(z) com o polinômio de diferença forward."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Definição de A-Estabilidade e o Critério |ρ(z)/σ(z)| ≤ 1",
                                  "subSteps": [
                                    "Defina A-estabilidade: região de estabilidade absoluta S = {z ∈ ℂ : |ρ(z)/σ(z)| ≤ 1} contém o semiplano esquerdo Re(z) ≤ 0.",
                                    "Analise o comportamento assintótico: para |z| grande com Re(z)<0, ρ(z)/σ(z) ≈ z^{-1} → 0.",
                                    "Discuta o teorema de Dahlquist: métodos lineares multissetp A-estáveis têm ordem ≤2, mas verifique para BDF.",
                                    "Implemente uma função para computar R(z) = ρ(z)/σ(z) em Python ou MATLAB.",
                                    "Teste pontos teste no semiplano esquerdo: eixos imaginário negativo e real negativo."
                                  ],
                                  "verification": "Função R(z) implementada e |R(iy)| ≤1 para y∈ℝ e |R(x)|≤1 para x≤0 confirmados analiticamente para k=1.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Python com numpy e cmath",
                                    "MATLAB ou Octave",
                                    "Artigo de Hairer sobre métodos Runge-Kutta/BDF"
                                  ],
                                  "tips": "Comece com k=1 (Euler backward: R(z)=1/(1-z), |R(z)|<1 para Re(z)<0).",
                                  "learningObjective": "Dominar o critério de A-estabilidade via função de amplificação.",
                                  "commonMistakes": "Confundir estabilidade absoluta com estabilidade relativa; ignorar pólos de σ(z)=0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Numericamente A-Estabilidade para Cada Ordem k=1 a 6",
                                  "subSteps": [
                                    "Para cada k=1 a 6, compute |R(z)| em uma grade no semiplano esquerdo (ex: Re(z) de -100 a 0, Im(z) de -100 a 100).",
                                    "Plote as curvas de fronteira |R(z)|=1 e verifique inclusão do semiplano esquerdo.",
                                    "Analise analiticamente para k=1-2 (A-estáveis) e numericamente para k=3-6 (verificar se |R(z)|≤1 ou não).",
                                    "Use root locus ou argumento para provar que para k≤2, o semiplano é coberto.",
                                    "Gere gráficos de regiões de estabilidade para todos k."
                                  ],
                                  "verification": "Gráficos mostrando |R(z)|≤1 no semiplano esquerdo para k=1-2, e análise para k>2; máximo |R(z)| reportado <1.01.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Python/MATLAB com contourf para plots",
                                    "Jupyter notebook",
                                    "Biblioteca scikit-odes ou similar"
                                  ],
                                  "tips": "Use z = x + 1j*y em malha; evite divisão por zero perto de raízes de σ(z).",
                                  "learningObjective": "Aplicar verificação numérica rigorosa de estabilidade.",
                                  "commonMistakes": "Resolução insuficiente da grade levando a falsos positivos; não normalizar por σ(z) adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Concluir sobre A-Estabilidade das BDF",
                                  "subSteps": [
                                    "Compile resultados: confirme A-estabilidade para k=1-2; discuta A(α)-estabilidade para k=3-6.",
                                    "Compare com literatura: BDF1-2 A-estáveis, BDF3-6 com ângulo α_k decrescendo.",
                                    "Discuta implicações para problemas stiff: preferir BDF2 para máxima estabilidade.",
                                    "Escreva um relatório resumindo provas e plots.",
                                    "Teste com um ODE stiff modelo (ex: y' = -50y + sin(t)) usando BDF k=1-6."
                                  ],
                                  "verification": "Relatório com conclusão: 'BDF k=1-6 são A(α)-estáveis com α=90° para k≤2'; simulação numérica estável.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Solver ODE (scipy.integrate.solve_ivp com method='BDF')",
                                    "Document editor"
                                  ],
                                  "tips": "Foque em evidências visuais (plots) para convencer.",
                                  "learningObjective": "Sintetizar análise teórica e numérica em conclusão fundamentada.",
                                  "commonMistakes": "Afirmar A-estabilidade irrestrita para k>2 sem qualificação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar Extensões e Limitações",
                                  "subSteps": [
                                    "Investigue L-estabilidade: |R(z)|→0 quando |z|→∞, Re(z)<0 (válida para todas BDF).",
                                    "Compare com trapezoidal rule (A-estável, ordem 2).",
                                    "Discuta uso em software (SUNDIALS, ODEPACK).",
                                    "Proponha exercício: verificar para k=7 (não A(α)-estável).",
                                    "Auto-avaliação com quiz sobre ρ/σ."
                                  ],
                                  "verification": "Quiz resolvido com 100%; nota sobre limitações de BDF6.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Documentação SUNDIALS",
                                    "Quiz online auto-gerado"
                                  ],
                                  "tips": "Conecte à prática computacional para retenção.",
                                  "learningObjective": "Contextualizar A-estabilidade em aplicações avançadas.",
                                  "commonMistakes": "Ignorar que BDF>6 perdem até A(0)-estabilidade."
                                }
                              ],
                              "practicalExample": "Para BDF2: ρ(z) = (3/2)z^2 - (5/2)z + 1, σ(z) = z^2. Verifique |ρ(iy)/σ(iy)| = |(3/2 - (5/2)(iy) +1 - (3/2)y^2 ) / (-y^2)| ≤1 para todo y. Plote em Python: max(|R(z)|) no semiplano = 0.99 <1, confirmando A-estabilidade.",
                              "finalVerifications": [
                                "Polinômios ρ(z)/σ(z) corretos para k=1-6 listados.",
                                "Plots de região de estabilidade mostram semiplano esquerdo coberto para k=1-2.",
                                "Simulação stiff ODE converge sem oscilações para todas BDF k=1-6.",
                                "Relatório explica por que k>2 não são fully A-estáveis mas A(α).",
                                "Máximo |R(z)| <1.01 computado em 1000+ pontos teste.",
                                "Diferença com métodos explícitos destacada."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos polinômios ρ/σ (100% coeficientes corretos).",
                                "Qualidade dos plots (resolução fina, legendas claras).",
                                "Análise numérica rigorosa (grid densa, limites extremos).",
                                "Conclusão alinhada à literatura (A-estável apenas k≤2).",
                                "Clareza do relatório (estrutura lógica, referências).",
                                "Criatividade em extensões (ex: L-estabilidade)."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de equações diferenciais stiff em dinâmica molecular.",
                                "Engenharia Química: Modelagem de reatores com cinéticas rápidas/lentas.",
                                "Ciência da Computação: Otimização de solvers ODE em bibliotecas como SciPy.",
                                "Matemática Aplicada: Teoria de perturbação para análise assintótica de R(z)."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos RC stiff ou reações químicas com escalas múltiplas (ex: combustão), BDF A-estáveis garantem estabilidade numérica sem passos de tempo restritivos, permitindo soluções eficientes em software como COMSOL ou MATLAB Simulink."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.6.2.2",
                            "name": "Conceito e prova de L-estabilidade",
                            "description": "Definir L-estabilidade (A-estável com |R(∞)|=0) e provar que BDF1 e BDF2 são L-estáveis, contrastando com ordens superiores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a função de estabilidade e A-estabilidade",
                                  "subSteps": [
                                    "Estude a equação teste y' = λy com Re(λ)<0.",
                                    "Derive a função de estabilidade R(z) para métodos lineares multistep, onde z = hλ.",
                                    "Defina A-estabilidade: |R(z)| ≤ 1 para todo Re(z) ≤ 0.",
                                    "Analise exemplos como método de Euler explícito (não A-estável) e implícito (A-estável).",
                                    "Plote a região de estabilidade no plano complexo."
                                  ],
                                  "verification": "Resuma em um parágrafo a definição de A-estabilidade e esboce o semiplano esquerdo no plano z.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Solving ODEs I' de Hairer et al., Capítulo II.4",
                                    "Software MATLAB ou Python (SymPy) para plotar regiões de estabilidade"
                                  ],
                                  "tips": "Comece com métodos simples para fixar conceitos antes de BDF.",
                                  "learningObjective": "Compreender a base teórica da estabilidade para métodos numéricos de EDOs.",
                                  "commonMistakes": "Confundir estabilidade absoluta com estabilidade para h→∞; sempre verifique |R(z)| no semiplano esquerdo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir L-estabilidade formalmente",
                                  "subSteps": [
                                    "Relembre A-estabilidade.",
                                    "Introduza a condição adicional: lim_{z→-∞} |R(z)| = 0.",
                                    "Prove que L-estabilidade implica A-estabilidade.",
                                    "Discuta o significado: amortecimento forte para componentes rápidas em problemas stiff.",
                                    "Compare com estabilidade contratativa (|R(z)| ≤ 1 - α Re(z) para z→-∞)."
                                  ],
                                  "verification": "Escreva a definição matemática precisa de L-estabilidade e dê um contraexemplo não L-estável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre Análise Numérica I",
                                    "Artigo original de Dahlquist sobre L-estabilidade"
                                  ],
                                  "tips": "Use notação clara: R(∞) = lim_{|z|→∞, arg(z)=π} R(z).",
                                  "learningObjective": "Dominar a definição exata de L-estabilidade e sua motivação para problemas stiff.",
                                  "commonMistakes": "Esquecer que L-estabilidade requer tanto A-estabilidade quanto |R(∞)|=0; verifique limites."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar L-estabilidade para BDF1 e BDF2",
                                  "subSteps": [
                                    "Derive a função de estabilidade para BDF1: R(z) = 1/(1 - z).",
                                    "Mostre A-estabilidade: |R(z)| ≤ 1 para Re(z) ≤ 0.",
                                    "Calcule lim_{z→-∞} R(z) = 0.",
                                    "Para BDF2: R(z) = (1 + (5/12)z)/((1 - (1/3)z)(1 - (2/3)z)); verifique |R(z)| ≤ 1 e lim=0.",
                                    "Use expansões em série ou análise assintótica para o limite."
                                  ],
                                  "verification": "Escreva as provas completas para BDF1 e BDF2, incluindo cálculos de R(z) e limites.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Caderno para derivações",
                                    "SymPy ou Mathematica para simplificar R(z)"
                                  ],
                                  "tips": "Para BDFk, use a forma geral ρ(ζ)/ρ(1) com ζ = e^z ≈ 1 + z para z grande negativo.",
                                  "learningObjective": "Realizar provas rigorosas de L-estabilidade para métodos de baixa ordem.",
                                  "commonMistakes": "Erro no cálculo de R(z) para BDF2; sempre expanda numerador e denominador corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com BDF de ordens superiores",
                                  "subSteps": [
                                    "Derive R(z) para BDF3: mostre que |R(∞)| ≠ 0.",
                                    "Analise geral: para k≥3, |R(∞)| = 1/k ≠ 0.",
                                    "Prove que BDFk (k=3 a 6) são A-estáveis mas não L-estáveis.",
                                    "Discuta implicações para problemas stiff com escalas múltiplas.",
                                    "Plote |R(z)| ao longo do eixo negativo para comparação."
                                  ],
                                  "verification": "Forneça prova para BDF3 e um gráfico comparativo de |R(z)| para k=1,2,3.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de plotagem (MATLAB odeplot ou Python matplotlib)",
                                    "Tabela de coeficientes BDF de Hairer"
                                  ],
                                  "tips": "Use a fórmula assintótica R(z) ~ (1 + a1 z + ... + ak z^k / k!) / (z^k / k!) para z→-∞.",
                                  "learningObjective": "Entender limitações de métodos de alta ordem em contextos stiff.",
                                  "commonMistakes": "Achar que todos BDF são L-estáveis; lembre que só k=1,2 são."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e testar numericamente",
                                  "subSteps": [
                                    "Resuma diferenças entre A e L-estabilidade.",
                                    "Implemente BDF1, BDF2, BDF3 em código para equação teste y'=-1000y + oscilador rápido.",
                                    "Compare erros e amortecimento para h grande.",
                                    "Verifique numericamente |R(∞)| aproximando z→-∞.",
                                    "Discuta trade-offs em precisão vs. estabilidade."
                                  ],
                                  "verification": "Execute simulações e inclua gráficos/plots mostrando superioridade de BDF1/2 em stiff.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com SciPy (solve_ivp com method='BDF')",
                                    "Jupyter notebook"
                                  ],
                                  "tips": "Use λ=-1e6 para stiff; compare com explicit para contraste.",
                                  "learningObjective": "Aplicar teoria em experimentos numéricos para validação.",
                                  "commonMistakes": "Escolher h muito pequeno; teste com h próximo ao limite de estabilidade."
                                }
                              ],
                              "practicalExample": "Resolva numericamente y' = -1000(y - sin(t)) com y(0)=0 usando BDF1, BDF2 e Runge-Kutta4. Observe que BDF1/2 amortecem o modo transitório rápido sem oscilações, enquanto BDF3 requer h menor e RK4 falha completamente.",
                              "finalVerifications": [
                                "Definição precisa de L-estabilidade escrita corretamente.",
                                "Provas completas para BDF1 e BDF2 sem erros algébricos.",
                                "Cálculo correto de |R(∞)| para BDFk geral.",
                                "Gráfico comparativo de regiões de estabilidade.",
                                "Simulação numérica demonstrando vantagem em problema stiff.",
                                "Resumo contrastando ordens baixas vs. altas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações de R(z) (90%+ correto).",
                                "Compreensão conceitual: explica motivação para L-estabilidade em stiff.",
                                "Profundidade das provas: inclui limites e análise assintótica.",
                                "Qualidade de visualizações: plots claros de |R(z)|.",
                                "Aplicação prática: simulações reproduzíveis com código.",
                                "Síntese: discute implicações para escolha de métodos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas dissipativos (circuitos RC, reações químicas stiff).",
                                "Ciência da Computação: Implementação em bibliotecas como SciPy ou SUNDIALS.",
                                "Engenharia: Simulações em controle de processos industriais com escalas rápidas.",
                                "Matemática Aplicada: Análise de erros em métodos multistep."
                              ],
                              "realWorldApplication": "Em simulações de cinética química (e.g., combustão), onde modos rápidos (reações elementares) devem ser amortecidos rapidamente sem poluir a solução lenta (concentrações macro); BDF1/2 são preferidos em solvers como CVODE para evitar artefatos numéricos em h otimizado."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.6.2.3",
                            "name": "Análise da região de estabilidade",
                            "description": "Plotar e interpretar as regiões de estabilidade no plano complexo z = hλ para BDF1, BDF2 e BDF6, destacando vantagens para rigidez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão teórica das fórmulas BDF e definição de região de estabilidade",
                                  "subSteps": [
                                    "Estude as fórmulas BDF1, BDF2 e BDF6: BDF1 é y_{n+1} = y_n + h f(t_{n+1}, y_{n+1}), BDF2 é (3/2)y_{n+1} - 2y_n + (1/2)y_{n-1} = (3/2) h f(t_{n+1}, y_{n+1}), e BDF6 para ordens mais altas.",
                                    "Defina o plano complexo z = hλ, onde λ é o autovalor da matriz jacobiana, e explique o teste de estabilidade A(α)-estável.",
                                    "Identifique problemas rígidos: equações com escalas temporais muito diferentes, exigindo métodos implicitamente estáveis.",
                                    "Revise o polinômio de estabilidade ρ(z) e σ(z) para cada método BDF.",
                                    "Anote as propriedades A-estáveis: BDF1 e BDF2 são A(α)-estáveis com α > 60°, BDF6 tem região maior."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre BDF1, BDF2 e BDF6 em termos de estabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), notas de aula, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Comece com BDF1 para construir intuição antes de métodos de ordem superior.",
                                  "learningObjective": "Compreender os fundamentos teóricos da estabilidade em métodos BDF.",
                                  "commonMistakes": "Confundir estabilidade absoluta (A-estável) com estabilidade relativa; ignorar o papel de z no semiplano esquerdo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Cálculo das regiões de estabilidade para BDF1, BDF2 e BDF6",
                                  "subSteps": [
                                    "Para BDF1: resolva |1 / (1 - z)| ≤ 1 para |z|.",
                                    "Para BDF2: derive o polinômio e resolva | (1 + (5/3)z + (1/3)z^2) / (1 - (4/3)z + (1/3)z^2) | ≤ 1.",
                                    "Para BDF6: use fórmulas padrão ou software para obter os limites da região (ângulo de estabilidade ~73°).",
                                    "Compare os raios e ângulos: BDF1 disco unitário, BDF2 e BDF6 regiões maiores no semiplano esquerdo.",
                                    "Tabule os pontos críticos de interseção com o eixo imaginário."
                                  ],
                                  "verification": "Liste as equações características e confirme os ângulos de estabilidade conhecidos (BDF1: 90°, BDF2: 86°, BDF6: 73°).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy para resolver inequações, papel quadriculado para esboços manuais.",
                                  "tips": "Use expansão em série ou métodos numéricos para aproximar fronteiras complexas.",
                                  "learningObjective": "Calcular matematicamente as fronteiras das regiões de estabilidade.",
                                  "commonMistakes": "Erros em derivação de polinômios; esquecer normalização pela equação característica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotagem das regiões de estabilidade no plano complexo z = hλ",
                                  "subSteps": [
                                    "Configure o grid no plano complexo Re(z) vs Im(z), de -10 a 0 no eixo real.",
                                    "Implemente código para testar pontos z dentro/fora da região usando critério |R(z)| ≤ 1.",
                                    "Gere plots separados e sobrepostos para BDF1 (círculo unitário), BDF2 e BDF6.",
                                    "Marque o semiplano esquerdo e destaque áreas de instabilidade.",
                                    "Adicione legendas, eixos rotulados e exporte como imagem."
                                  ],
                                  "verification": "Produza um gráfico com as três regiões corretamente plotadas e sem erros visuais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (Matplotlib, NumPy), MATLAB ou JuliaPlots; template de código pronto.",
                                  "tips": "Use contourf para regiões preenchidas; teste com 1000x1000 pontos para resolução alta.",
                                  "learningObjective": "Visualizar graficamente as regiões de estabilidade.",
                                  "commonMistakes": "Escala errada no eixo imaginário; plotar apenas magnitude sem fase."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretação comparativa e vantagens para problemas rígidos",
                                  "subSteps": [
                                    "Compare tamanhos das regiões: BDF6 cobre mais o semiplano esquerdo para |λ| grande.",
                                    "Explique rigidez: para h|λ| >>1, métodos explícitos falham, BDFs permitem passos maiores.",
                                    "Discuta trade-offs: ordem alta (BDF6) vs custo computacional.",
                                    "Aplique a um exemplo: y' = -1000y + sin(t), mostre estabilidade.",
                                    "Conclua vantagens: BDF2/BDF6 ideais para ODEs rígidas em simulações."
                                  ],
                                  "verification": "Escreva um relatório de 200 palavras comparando as regiões e implicações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos gerados, editor de texto, exemplos numéricos resolvidos.",
                                  "tips": "Foque em aplicações: química (reações rápidas), elétrica (circuitos RC).",
                                  "learningObjective": "Interpretar plots e destacar benefícios para rigidez.",
                                  "commonMistakes": "Ignorar custo de solução implícita; superestimar estabilidade sem contexto rígido."
                                }
                              ],
                              "practicalExample": "Para o problema rígido y' = -999y + sin(t), y(0)=0, com λ≈-999, use h=0.1. Plote z=hλ≈-99.9; verifique que está dentro da região BDF2 mas fora de métodos explícitos como RK4, simulando numericamente a estabilidade.",
                              "finalVerifications": [
                                "O aluno plota corretamente as regiões para BDF1, BDF2 e BDF6.",
                                "Identifica o ângulo de estabilidade para cada método.",
                                "Explica por que BDFs são preferíveis para problemas rígidos.",
                                "Compara visualmente as regiões sobrepostas.",
                                "Aplica a interpretação a um exemplo numérico simples.",
                                "Lista vantagens e limitações de ordens altas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das fronteiras de estabilidade (90%).",
                                "Qualidade visual dos plots (clareza, legendas, escalas).",
                                "Profundidade da interpretação comparativa (análise qualitativa/quantitativa).",
                                "Correta identificação de regiões no semiplano esquerdo.",
                                "Conexão explícita com rigidez e passos de tempo adaptativos.",
                                "Relatório coerente sem erros conceituais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de sistemas dinâmicos rígidos como amortecedores ou circuitos.",
                                "Engenharia Computacional: Otimização de solvers em CFD e simulações multiphysics.",
                                "Química Computacional: Simulação de cinéticas de reação com escalas rápidas.",
                                "Matemática Aplicada: Análise de autovalores em sistemas lineares."
                              ],
                              "realWorldApplication": "Em simulações de engenharia química para reatores com reações rápidas e lentas (rigidez), BDF6 permite passos de tempo maiores, reduzindo tempo computacional em softwares como COMSOL ou OpenFOAM, evitando oscilações numéricas em problemas industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.6.3",
                        "name": "Aplicação das BDF em Solvers para EDOs Stiff",
                        "description": "Implementação prática em métodos implícitos com controle de passo para equações diferenciais rígidas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.6.3.1",
                            "name": "Resolução do sistema implícito em BDF",
                            "description": "Explicar a necessidade de solvers não-lineares (ex: Newton) para resolver o sistema implícito em cada passo das BDF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a formulação implícita das BDF",
                                  "subSteps": [
                                    "Revise a definição de BDF de ordem k: ∑_{j=0}^k α_j y_{n+j} = h β_k f(t_{n+k}, y_{n+k}).",
                                    "Identifique o termo implícito y_{n+k} no lado direito da equação.",
                                    "Derive o sistema não-linear F(y_{n+k}) = 0 a partir da equação BDF.",
                                    "Discuta por que métodos explícitos falham em problemas stiff.",
                                    "Compare com métodos explícitos como Runge-Kutta."
                                  ],
                                  "verification": "Escreva a equação implícita para BDF2 e confirme que y_{n+1} aparece implicitamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), caderno, calculadora.",
                                  "tips": "Comece com BDF1 (método backward Euler) para simplicidade antes de ordens superiores.",
                                  "learningObjective": "Entender por que BDF gera um sistema implícito não-linear.",
                                  "commonMistakes": "Confundir coeficientes α_j e β_k; ignorar o termo h β_k f que torna implícito."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a necessidade de solvers não-lineares",
                                  "subSteps": [
                                    "Explique por que iterações lineares (ex: fixed-point) podem divergir em problemas stiff.",
                                    "Introduza o método de Newton: y^{m+1} = y^m - J^{-1} F(y^m).",
                                    "Discuta a matriz Jacobiana J = ∂F/∂y.",
                                    "Compare convergência quadrática de Newton vs linear de outros métodos.",
                                    "Analise condições para convergência local."
                                  ],
                                  "verification": "Justifique matematicamente por que Newton é necessário para stiff ODEs em BDF.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre análise numérica, software como MATLAB para testar Jacobiana.",
                                  "tips": "Visualize a função F(y) graficamente para ver não-linearidades.",
                                  "learningObjective": "Reconhecer limitações de solvers simples e superioridade de Newton.",
                                  "commonMistakes": "Assumir que o sistema é linear; esquecer de atualizar a Jacobiana."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o solver Newton para o sistema BDF",
                                  "subSteps": [
                                    "Defina tolerância ε e máximo de iterações M.",
                                    "Inicialize y^0 com extrapolação de passos anteriores.",
                                    "Em cada iteração: compute F(y^m), J(y^m), resolva J δy = -F, atualize y^{m+1}.",
                                    "Pare quando ||δy|| < ε ou m > M.",
                                    "Integre com passos anteriores para avançar."
                                  ],
                                  "verification": "Codifique em Python/MATLAB e teste convergência em 5 iterações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB, exemplo de EDO stiff.",
                                  "tips": "Use Jacobiana analítica se possível para precisão; senão, aproximação finita.",
                                  "learningObjective": "Aplicar iterativamente Newton para resolver F(y)=0 em BDF.",
                                  "commonMistakes": "Inicialização ruim levando a não-convergência; inversão numérica instável de J."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar estabilidade e analisar erros",
                                  "subSteps": [
                                    "Monitore resíduo ||F(y)|| ao longo das iterações.",
                                    "Compare solução BDF-Newton com solução exata ou referência.",
                                    "Analise ordem de precisão da BDF usada.",
                                    "Teste sensibilidade a parâmetros stiff (ex: λ grande negativo).",
                                    "Ajuste ordem BDF ou step size h baseado em erros."
                                  ],
                                  "verification": "Gere gráfico de erro vs h e confirme estabilidade para stiff problems.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Matplotlib), dados de teste.",
                                  "tips": "Use problemas benchmark como van der Pol com μ grande.",
                                  "learningObjective": "Avaliar eficácia do solver em contexto stiff.",
                                  "commonMistakes": "Ignorar damping em Newton para stiff; não checar ortogonalidade em J."
                                }
                              ],
                              "practicalExample": "Resolva y' = -50(y - (1 - cos(50t))/50) com y(0)=0 usando BDF2. Inicialize y^0=0, h=0.1. Aplique Newton com ε=1e-6: compute F(y1) = (3/2)y1 - (1/2)y0 - h f(t1,y1)=0, Jacobiana J=1 + (3/2)h*50, itere até convergência. Verifique estabilidade vs Euler explícito (instável).",
                              "finalVerifications": [
                                "O solver converge em <10 iterações por passo para problema stiff.",
                                "Erro global <1e-4 comparado a solução de alta precisão.",
                                "Solução permanece estável para eigenvalues λ=-1000.",
                                "Jacobiana é corretamente computada e invertida.",
                                "Número de function evaluations é razoável (<50 por passo).",
                                "Gráficos mostram suavidade na solução stiff."
                              ],
                              "assessmentCriteria": [
                                "Explicação clara da não-linearidade em BDF (80% precisão).",
                                "Implementação correta de Newton com Jacobiana (funciona em teste).",
                                "Análise de convergência e estabilidade demonstrada.",
                                "Identificação de erros comuns evitados.",
                                "Aplicação bem-sucedida em exemplo stiff.",
                                "Conexões com teoria numérica precisas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores amortecidos stiff em dinâmica.",
                                "Computação: Otimização numérica e programação científica (SciPy ode solvers).",
                                "Engenharia: Simulações em controle de sistemas (ex: circuitos RC stiff).",
                                "Química: Reações stiff em cinética química computacional."
                              ],
                              "realWorldApplication": "Em simulações de circuitos elétricos stiff (SPICE), reações químicas em reatores, ou modelagem climática com escalas múltiplas, onde BDF+Newton permite passos eficientes sem oscilações, economizando tempo computacional em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.6.3.2",
                            "name": "Controle de erro e seleção de ordem em solvers BDF",
                            "description": "Descrever estratégias de controle de passo adaptativo e mudança de ordem variável em pacotes como ODEPACK ou solvers modernos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos de Controle de Erro em Solvers de EDOs Stiff",
                                  "subSteps": [
                                    "Estude a definição de erro local truncado e erro global em métodos implícitos como BDF.",
                                    "Analise o impacto do controle de tolerâncias absolutas (atol) e relativas (rtol) na precisão.",
                                    "Explore estimadores de erro baseados em soluções de ordens embedadas (ex: BDF2 e BDF3).",
                                    "Revise a fórmula de erro local para BDF: |e| ≈ (h^{p+1}/(p+1)!) * y^{(p+1)}(ξ)).",
                                    "Compare com métodos explícitos para destacar necessidade em problemas stiff."
                                  ],
                                  "verification": "Resuma em um diagrama as fontes de erro e como o solver as estima.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Solving ODEs II' de Hairer et al.",
                                    "Notebook Jupyter com SciPy",
                                    "Documentação ODEPACK"
                                  ],
                                  "tips": "Use gráficos de soluções exatas vs aproximadas para visualizar erros.",
                                  "learningObjective": "Compreender métricas e estimadores de erro específicos para BDF.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Subestimar o papel de rtol em soluções grandes",
                                    "Ignorar dependência em normas de vetores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estratégias de Controle de Passo Adaptativo em Solvers BDF",
                                  "subSteps": [
                                    "Descreva o algoritmo PID-like para ajuste de passo: h_new = h_old * (tol / err)^{1/(p+1)}.",
                                    "Implemente lógica de rejeição/aceitação de passos baseada em erro estimado > tol.",
                                    "Estude fatores de segurança (ex: 0.9) e limites (h_min, h_max).",
                                    "Simule adaptação em problema stiff como Van der Pol com μ grande.",
                                    "Analise convergência: reduza h se err > tol, aumente se err < 0.7*tol."
                                  ],
                                  "verification": "Codifique um pseudo-algoritmo e teste com h inicial variando.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código fonte de lsoda (ODEPACK)",
                                    "Python com solve_ivp(method='BDF')",
                                    "Gráficos de h vs tempo"
                                  ],
                                  "tips": "Monitore o número de rejeições; >20% indica problema mal escalado.",
                                  "learningObjective": "Dominar algoritmos adaptativos para eficiência em stiff ODEs.",
                                  "commonMistakes": [
                                    "Fator de segurança muito agressivo levando a oscilações",
                                    "Não limitar h_max causando instabilidade",
                                    "Ignorar redimensionamento de atol/rtol por componente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Seleção de Ordem Variável em Solvers BDF",
                                  "subSteps": [
                                    "Explique critérios para mudança de ordem: err_p / err_{p+1} para promoção/demissão.",
                                    "Estude ordens típicas em solvers (1 a 5 para BDF).",
                                    "Implemente lógica: se err_{p} < tol e err_{p+1} < tol * 1.2, suba ordem.",
                                    "Analise trade-off: ordens altas para precisão, baixas para stiff inicial.",
                                    "Teste em ODEPACK: flag para order control (mxstep, mxordn)."
                                  ],
                                  "verification": "Crie tabela comparando tempos e erros para ordens fixas vs variáveis.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação SciPy integrate.solve_ivp",
                                    "Exemplos ODEPACK Fortran/Python wrappers",
                                    "Problema de teste: química rígida"
                                  ],
                                  "tips": "Comece com ordem 1 em transients stiff para estabilidade.",
                                  "learningObjective": "Entender seleção dinâmica de ordem para otimizar precisão/velocidade.",
                                  "commonMistakes": [
                                    "Mudança precoce de ordem causando divergência",
                                    "Fixar ordem alta em não-stiff desperdiçando computação",
                                    "Não prever custo de Jacobiano em ordens altas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração e Testes em Pacotes como ODEPACK e Solvers Modernos",
                                  "subSteps": [
                                    "Configure solver BDF em SciPy: solve_ivp com method='BDF', rtol=1e-6.",
                                    "Ajuste parâmetros ODEPACK (ex: ITOL, ATOL, MXSTEP).",
                                    "Monitore saídas: nsteps, nfevals, njevals para validar controle.",
                                    "Compare com solvers Radau/LSODE em benchmarks stiff.",
                                    "Otimize para cenários reais: escalonamento de variáveis."
                                  ],
                                  "verification": "Execute simulação e gere relatório com métricas de erro e eficiência.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python SciPy 1.10+",
                                    "Exemplos GitHub ODEPACK wrappers",
                                    "Benchmark problems (Robertson, POLLU)"
                                  ],
                                  "tips": "Use events para detecção de singularidades afetando adaptação.",
                                  "learningObjective": "Aplicar controle de erro/ordem em software real.",
                                  "commonMistakes": [
                                    "Parâmetros default inadequados para stiff",
                                    "Não checar status flags de falha",
                                    "Escala inconsistente entre y e dy/dt"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o problema de Robertson (cinética química stiff): dy1/dt = -0.04*y1 + 1e4*y2*y3, etc. Use solve_ivp(method='BDF', rtol=1e-8). Plote h(t), ordem(t) e erro vs solução exata longa. Observe adaptação: h diminui em fase stiff inicial, ordem sobe para 5 em regime estável.",
                              "finalVerifications": [
                                "Explicar algoritmo de controle de passo com pseudocódigo.",
                                "Simular stiff ODE e plotar evolução de h e ordem.",
                                "Comparar eficiência (nfevals) entre ordem fixa e variável.",
                                "Identificar e corrigir rejeições excessivas ajustando tol.",
                                "Descrever impacto de atol/rtol em componentes diferentes.",
                                "Validar com benchmark: erro < 1e-6 em tempo < 1s."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de estimadores de erro (90% correto).",
                                "Correta implementação de adaptação com <10% rejeições.",
                                "Uso eficaz de ordem variável reduzindo tempo >20%.",
                                "Análise de trade-offs com gráficos quantitativos.",
                                "Aplicação correta em pacote real sem erros de configuração.",
                                "Relatório com verificações finais completas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica (Python SciPy/NumPy para implementação).",
                                "Física Computacional (modelagem dinâmica stiff em fluidos/reações).",
                                "Engenharia de Controle (simulação sistemas lineares implícitos).",
                                "Química Computacional (cinética rígida multi-escala)."
                              ],
                              "realWorldApplication": "Em simulações de reações químicas em reatores (ex: combustão), dinâmica de circuitos elétricos stiff (RCL com capacitores), ou modelagem climática com escalas múltiplas, onde controle adaptativo permite soluções precisas sem crash ou lentidão excessiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.3.1",
                              "10.1.5.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.6.3.3",
                            "name": "Exemplo numérico de problema stiff com BDF",
                            "description": "Resolver numericamente um problema stiff clássico (ex: equação de Van der Pol com μ grande) usando BDF2 e comparar com métodos explícitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema stiff clássico",
                                  "subSteps": [
                                    "Estude a equação de Van der Pol: y'' - μ(1 - y²)y' + y = 0, com μ = 1000.",
                                    "Reescreva como sistema de EDOs de primeira ordem: y1' = y2, y2' = μ(1 - y1²)y2 - y1.",
                                    "Defina condições iniciais: y(0) = [2, 0], intervalo [0, 10] e tolerância.",
                                    "Escolha passo inicial h = 0.01 para métodos explícitos.",
                                    "Implemente a função f(t,y) que define o sistema."
                                  ],
                                  "verification": "Verifique se a função f(t,y) retorna valores corretos para y=[2,0] e compare com valores analíticos iniciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy, SciPy; documentação de Van der Pol.",
                                  "tips": "Use μ grande (ex: 1000) para stiff claro; plote órbita inicial para visualização.",
                                  "learningObjective": "Compreender a estrutura de problemas stiff e configurar corretamente.",
                                  "commonMistakes": "Esquecer de reescrever como sistema de 1ª ordem; usar μ pequeno que não é stiff."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar método explícito para comparação (RK4)",
                                  "subSteps": [
                                    "Implemente o método de Runge-Kutta de ordem 4 (RK4) manualmente.",
                                    "Aplique RK4 com passos adaptativos ou fixos até o intervalo final.",
                                    "Registre tempos de computação e detecte instabilidades (blow-up).",
                                    "Gere gráfico da solução y1 vs y2.",
                                    "Calcule norma do erro se solução de referência disponível."
                                  ],
                                  "verification": "A solução deve divergir ou explodir devido a stiff, com tempo de CPU alto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python, Matplotlib para plots; timer com time module.",
                                  "tips": "Use h pequeno inicialmente; monitore ||y|| para detectar blow-up.",
                                  "learningObjective": "Demonstrar limitações de métodos explícitos em stiff.",
                                  "commonMistakes": "Não detectar instabilidade; h fixo muito grande sem adaptação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método BDF2",
                                  "subSteps": [
                                    "Revise fórmula BDF2: y_{n+1} = (4/3)y_n - (1/3)y_{n-1} + (2/3)h f(t_{n+1}, y_{n+1}).",
                                    "Use predictor (ex: extrapolação ou BDF1) para iniciar iterações de Newton.",
                                    "Implemente solver implícito com Jacobiana analítica ou numérica (finite differences).",
                                    "Ajuste h adaptativo baseado em erro local.",
                                    "Integre até t=10 e gere gráfico."
                                  ],
                                  "verification": "Solução converge sem blow-up, órbita limite de Van der Pol visível.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy.optimize para Newton; Jacobiana da Van der Pol.",
                                  "tips": "Comece com predictor simples (Adams-Bashforth); limite iterações Newton a 20.",
                                  "learningObjective": "Dominar implementação de BDF2 para EDOs stiff.",
                                  "commonMistakes": "Jacobiana incorreta levando a não-convergência; esquecer predictor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar resultados e analisar",
                                  "subSteps": [
                                    "Compare plots de RK4 vs BDF2: estabilidade, precisão, tempo de CPU.",
                                    "Calcule métricas: tempo total, passos dados, norma L2 entre soluções.",
                                    "Teste com μ variando (100, 1000) para escalabilidade.",
                                    "Discuta razões da superioridade do BDF2.",
                                    "Gere relatório com tabelas e gráficos."
                                  ],
                                  "verification": "BDF2 resolve com passos maiores, tempo menor e sem instabilidade vs RK4.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matplotlib para subplots; Pandas para tabelas.",
                                  "tips": "Use logscale para tempos; valide com solve_ivp('BDF') do SciPy.",
                                  "learningObjective": "Avaliar performance de métodos em stiff.",
                                  "commonMistakes": "Ignorar tempo de CPU; comparações sem normalização."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e generalizar",
                                  "subSteps": [
                                    "Implemente BDF de ordem variável ou compare com BDF1.",
                                    "Adicione controle de erro global.",
                                    "Teste em outro stiff (ex: Robertson).",
                                    "Documente código em notebook Jupyter.",
                                    "Prepare apresentação dos resultados."
                                  ],
                                  "verification": "Código roda para múltiplos problemas; relatório completo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Jupyter Notebook; SciPy para benchmarks.",
                                  "tips": "Reutilize classes para solvers genéricos.",
                                  "learningObjective": "Generalizar BDF para solvers robustos.",
                                  "commonMistakes": "Não testar em outros problemas; código não modular."
                                }
                              ],
                              "practicalExample": "Em Python: def vanderpol(t, y, mu=1000): return [y[1], mu*(1-y[0]**2)*y[1] - y[0]]. Implemente BDF2 com Newton para μ=1000, y0=[2,0], t_span=[0,10]; compare com RK4 que falha em t~2.",
                              "finalVerifications": [
                                "Solução BDF2 mostra órbita limite relaxada sem oscilações numéricas.",
                                "RK4 exibe blow-up ou rigidez com h<1e-4.",
                                "Tempo BDF2 < 10x tempo RK4 para precisão similar.",
                                "Erro local < 1e-6 em todos passos BDF2.",
                                "Gráficos comparativos claros com legendas.",
                                "Código comentado e reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de BDF2 com convergência (70%).",
                                "Comparação quantitativa precisa (15%).",
                                "Análise de estabilidade e eficiência (10%).",
                                "Código limpo e documentado (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/SciPy.",
                                "Física: Osciladores não-lineares como Van der Pol em eletrônica.",
                                "Engenharia: Simulações stiff em controle e dinâmica.",
                                "Computação Científica: Otimizadores para implícitos."
                              ],
                              "realWorldApplication": "Simulação de circuitos elétricos rígidos, reações químicas em cinética (ex: combustão), modelagem climática com escalas múltiplas, onde métodos explícitos falham por instabilidade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Métodos para Problemas de Valor de Contorno",
                "description": "Técnicas numéricas específicas para resolver problemas de valor de contorno em equações diferenciais.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Formulação do Problema de Valor de Contorno",
                    "description": "Definição e características dos problemas de valor de contorno em equações diferenciais ordinárias.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Definição de Problema de Valor de Contorno (BVP)",
                        "description": "Compreensão da definição formal de um problema de valor de contorno em equações diferenciais ordinárias (EDOs), contrastando com problemas de valor inicial.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Identificar a estrutura básica de um BVP",
                            "description": "Reconhecer que um BVP consiste em uma EDO de ordem n com n condições de contorno especificadas em pontos distintos do intervalo [a, b], diferenciando de IVPs onde condições são dadas em um único ponto inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Equações Diferenciais Ordinárias (EDOs)",
                                  "subSteps": [
                                    "Defina o que é uma EDO e identifique sua ordem baseada no maior derivado presente.",
                                    "Classifique EDOs lineares versus não-lineares usando exemplos simples como y' = y (linear) e y' = y^2 (não-linear).",
                                    "Escreva a forma geral de uma EDO de ordem n: F(x, y, y', ..., y^(n)) = 0.",
                                    "Discuta o intervalo de definição [a, b] para problemas em um domínio fechado.",
                                    "Pratique identificando a ordem em 3-5 equações de exemplo."
                                  ],
                                  "verification": "Liste corretamente a ordem e forma geral de pelo menos 3 EDOs de exemplo sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de EDOs (capítulo introdutório), caderno de anotações, calculadora.",
                                  "tips": "Sempre comece identificando o maior derivado para determinar a ordem.",
                                  "learningObjective": "Compreender a estrutura fundamental de EDOs de ordem n como base para problemas de valor.",
                                  "commonMistakes": "Confundir ordem com o número de variáveis independentes; ignorar termos não-derivativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Problemas de Valor Inicial (IVPs)",
                                  "subSteps": [
                                    "Defina IVP: EDO de ordem n com n condições iniciais y(x0)=y0, y'(x0)=y1', ..., y^(n-1)(x0)=y_(n-1)^(n-1) em um único ponto x0.",
                                    "Escreva um exemplo: y'' + y = 0 com y(0)=1, y'(0)=0.",
                                    "Explique por que as condições são todas no mesmo ponto inicial.",
                                    "Resolva numericamente ou analiticamente um IVP simples para visualizar a solução única.",
                                    "Compare com EDO sem condições para destacar a necessidade de n condições."
                                  ],
                                  "verification": "Escreva e resolva corretamente um IVP de ordem 2, confirmando condições em um ponto único.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de resolução de EDOs (ex: MATLAB/Octave ou Python com SciPy), exemplos impressos.",
                                  "tips": "Lembre-se: IVP usa condições 'iniciais' todas em t=0 ou x=x0.",
                                  "learningObjective": "Reconhecer a estrutura de IVPs com condições concentradas em um ponto.",
                                  "commonMistakes": "Atribuir condições em pontos diferentes em IVPs; confundir ordem com número de condições."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Estrutura de Problemas de Valor de Contorno (BVPs)",
                                  "subSteps": [
                                    "Defina BVP: EDO de ordem n com n condições de contorno especificadas em pontos distintos do intervalo [a, b], ex: α1 y(a) + α2 y'(a) + ... = β1 e γ1 y(b) + ... = β2.",
                                    "Escreva um exemplo clássico: y'' + y = 0, y(0)=0, y(π)=0.",
                                    "Identifique que condições são dadas nas 'fronteiras' a e b, não necessariamente todas as derivadas.",
                                    "Discuta formas gerais de condições de contorno separadas ou mistas.",
                                    "Pratique reescrevendo 3 problemas como BVPs padrão."
                                  ],
                                  "verification": "Formule corretamente um BVP de ordem 2 com condições em x=0 e x=1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folhas de exercícios de BVPs, software para plotar soluções.",
                                  "tips": "Condições de contorno podem envolver derivadas, mas pontos são distintos.",
                                  "learningObjective": "Identificar precisamente os componentes de um BVP: EDO + n condições em pontos distintos.",
                                  "commonMistakes": "Confundir condições mistas com IVPs; assumir todas condições em derivadas iniciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar IVPs de BVPs e Identificar Estruturas Básicas",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: IVP (1 ponto, n condições iniciais) vs BVP (2+ pontos distintos, n condições totais).",
                                    "Analise 5 problemas mistos e classifique cada um como IVP ou BVP.",
                                    "Explique implicações: IVPs têm existência/unidade local; BVPs podem não ter solução única.",
                                    "Resolva um BVP simples e compare com IVP equivalente.",
                                    "Teste compreensão com quiz de identificação."
                                  ],
                                  "verification": "Classifique corretamente 5 problemas como IVP ou BVP com justificativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela comparativa em branco, problemas de prática impressos.",
                                  "tips": "Pergunte: 'Condições em um ponto só?' -> IVP; 'Pontos distintos?' -> BVP.",
                                  "learningObjective": "Diferenciar com precisão a estrutura básica de BVPs de IVPs.",
                                  "commonMistakes": "Ignorar se pontos são distintos; contar condições erradamente."
                                }
                              ],
                              "practicalExample": "Considere a EDO y'' + λy = 0 no intervalo [0, π]. Para BVP: y(0) = 0, y(π) = 0 (condições em pontos distintos). Para IVP equivalente: y(0)=0, y'(0)=1 (ambas em 0). Identifique: BVP tem condições nas fronteiras.",
                              "finalVerifications": [
                                "Defina BVP corretamente incluindo ordem n e pontos distintos.",
                                "Dê exemplo de BVP com condições em a e b.",
                                "Diferencie de IVP citando localização das condições.",
                                "Classifique 3 problemas novos como BVP ou não.",
                                "Explique por que BVPs usam [a,b] fechado.",
                                "Identifique ordem e número de condições em um BVP dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de BVP (EDO ordem n + n condições em pontos distintos).",
                                "Correta diferenciação de IVP (todas condições em um ponto).",
                                "Uso correto de notação matemática em exemplos.",
                                "Capacidade de classificar problemas com justificativa.",
                                "Compreensão de implicações no intervalo [a,b].",
                                "Clareza em tabelas ou diagramas comparativos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de vibrações de cordas (equação de onda como BVP).",
                                "Engenharia: Análise de vigas elásticas com apoios fixos nas extremidades.",
                                "Computação: Implementação numérica em métodos de diferença finita para BVPs.",
                                "Física Quântica: Problema de partículas em caixa (BVP para função de onda)."
                              ],
                              "realWorldApplication": "Em engenharia estrutural, BVPs modelam deflexão de vigas com condições de contorno fixas nas extremidades (ex: y(0)=0, y(L)=0), permitindo prever deformações sob carga distribuída."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Diferenciar BVP de IVP",
                            "description": "Comparar problemas de valor inicial (IVPs), resolvidos sequencialmente para frente, com BVPs, que requerem condições em ambas as extremidades e frequentemente métodos de contorno como shooting ou diferenças finitas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição e características de Problemas de Valor Inicial (IVP)",
                                  "subSteps": [
                                    "Defina um IVP como um problema diferencial com condições especificadas no ponto inicial.",
                                    "Identifique que IVPs são resolvidos marchando para frente no tempo ou espaço usando métodos como Euler ou Runge-Kutta.",
                                    "Liste as condições típicas: y(x0) = y0 e derivadas iniciais.",
                                    "Esboce um exemplo simples: y' = -y, y(0) = 1.",
                                    "Explique a unicidade da solução sob condições Lipschitz."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição de IVP e resolva um exemplo básico manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica",
                                    "Caderno e calculadora",
                                    "Software como MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Foquem nas condições iniciais; visualize a solução como uma 'marcha para frente'.",
                                  "learningObjective": "Compreender a estrutura e método de resolução sequencial de IVPs.",
                                  "commonMistakes": [
                                    "Confundir condições iniciais com condições de contorno.",
                                    "Ignorar a direção de integração (sempre para frente)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a definição e características de Problemas de Valor de Contorno (BVP)",
                                  "subSteps": [
                                    "Defina um BVP como um problema diferencial com condições especificadas nas extremidades do intervalo.",
                                    "Descreva que BVPs requerem condições em x=a e x=b, como y(a)=α, y(b)=β.",
                                    "Explique a necessidade de métodos iterativos como shooting ou diferenças finitas devido à não-sequencialidade.",
                                    "Destaque a possibilidade de não-existência ou múltiplas soluções.",
                                    "Esboce um exemplo: y'' + y = 0, y(0)=0, y(π)=0."
                                  ],
                                  "verification": "Descreva um BVP com condições de contorno e identifique por que não pode ser resolvido diretamente para frente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Numérica",
                                    "Caderno",
                                    "Gráficos de funções seno/cosseno"
                                  ],
                                  "tips": "Pense nas condições como 'pinos' nas duas pontas de uma corda esticada.",
                                  "learningObjective": "Dominar a formulação de BVPs e suas peculiaridades.",
                                  "commonMistakes": [
                                    "Aplicar métodos de IVP diretamente em BVP.",
                                    "Esquecer que soluções podem não ser únicas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e contrastar IVPs e BVPs",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: condições (inicial vs. contorno), método de resolução (sequencial vs. iterativo), estabilidade.",
                                    "Discuta diferenças em existência/unicidade: IVP geralmente único, BVP depende do problema.",
                                    "Analise métodos: IVP (integração direta), BVP (shooting: transforma em IVP com parâmetros; diferenças finitas: discretização).",
                                    "Identifique cenários onde um BVP pode ser reduzido a IVP via shooting.",
                                    "Debata vantagens/desvantagens de cada tipo."
                                  ],
                                  "verification": "Preencha uma tabela de comparação e explique duas diferenças chave em voz alta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Exemplos impressos de IVP e BVP"
                                  ],
                                  "tips": "Use setas para mostrar direção: → para IVP, ↔ para BVP.",
                                  "learningObjective": "Identificar diferenças fundamentais entre IVPs e BVPs.",
                                  "commonMistakes": [
                                    "Achar que todos os problemas são IVPs.",
                                    "Ignorar métodos específicos para BVP como shooting."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar a diferenciação com exemplos mistos",
                                  "subSteps": [
                                    "Classifique 5 problemas dados como IVP ou BVP e justifique.",
                                    "Converta um IVP simples em BVP alterando condições.",
                                    "Simule um método de shooting para um BVP básico.",
                                    "Discuta quando usar cada um em contextos reais.",
                                    "Resolva numericamente um BVP simples usando software."
                                  ],
                                  "verification": "Classifique corretamente 3 problemas mistos e descreva o método apropriado para cada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de exercícios impressa",
                                    "Software Python/MATLAB com bibliotecas scipy.integrate"
                                  ],
                                  "tips": "Sempre cheque as condições primeiro: onde estão especificadas?",
                                  "learningObjective": "Aplicar a diferenciação em problemas reais e identificar métodos adequados.",
                                  "commonMistakes": [
                                    "Classificar errado baseado em equação, ignorando condições.",
                                    "Não considerar iterações em BVP."
                                  ]
                                }
                              ],
                              "practicalExample": "IVP: y'' + y = 0, y(0) = 0, y'(0) = 1 (solução: y = sin(x), resolvida marchando de x=0). BVP: y'' + y = 0, y(0) = 0, y(π) = 0 (solução: y = 0 ou shooting para ajustar y'(0) até y(π)=0).",
                              "finalVerifications": [
                                "Definir corretamente IVP e BVP com exemplos.",
                                "Explicar por que BVPs requerem métodos especiais.",
                                "Classificar 3 problemas mistos como IVP ou BVP.",
                                "Descrever método shooting para BVP.",
                                "Identificar condições de unicidade em cada.",
                                "Comparar tabela de diferenças principais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (80% correto).",
                                "Correta identificação de tipos de problemas (100% em exemplos).",
                                "Explicação clara de métodos de resolução.",
                                "Uso apropriado de terminologia (shooting, diferenças finitas).",
                                "Demonstração de compreensão via tabela comparativa.",
                                "Aplicação em exemplos práticos sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física: IVP em dinâmica (movimento de partículas), BVP em ondas estacionárias.",
                                "Engenharia: BVP em deformação de vigas e cascas.",
                                "Computação: Implementação de solvers numéricos em Python/ MATLAB.",
                                "Física Quântica: BVPs em equações de Schrödinger estacionária.",
                                "Economia: Modelos diferenciais em finanças com condições de contorno."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, BVPs modelam perfis aerodinâmicos com condições de velocidade em bordas de ataque e saída; IVPs simulam trajetórias de voo sequenciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Reconhecer exemplos iniciais de BVPs",
                            "description": "Identificar equações clássicas como y'' + p(x)y' + q(x)y = g(x) com condições y(a)=α e y(b)=β como protótipos de BVPs lineares de segunda ordem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações Diferenciais Ordinárias (EDOs) Lineares de Segunda Ordem",
                                  "subSteps": [
                                    "Estude a forma geral de uma EDO linear de segunda ordem: y'' + p(x)y' + q(x)y = g(x).",
                                    "Identifique os coeficientes p(x), q(x) e o termo forçante g(x).",
                                    "Diferencie entre homogênea (g(x)=0) e não homogênea.",
                                    "Resolva um exemplo simples homogêneo para familiarizar.",
                                    "Anote exemplos clássicos como equação harmônica simples."
                                  ],
                                  "verification": "Escreva a forma geral e classifique corretamente dois exemplos dados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de EDOs (capítulo de lineares de 2ª ordem)",
                                    "Folha de papel e calculadora"
                                  ],
                                  "tips": [
                                    "Memorize a estrutura padrão; pratique escrevendo-a de memória.",
                                    "Use gráficos para visualizar soluções."
                                  ],
                                  "learningObjective": "Compreender a estrutura fundamental de EDOs lineares de segunda ordem.",
                                  "commonMistakes": [
                                    "Confundir ordem da derivada.",
                                    "Ignorar dependência em x dos coeficientes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Condições Iniciais (IVP) de Condições de Contorno (BVP)",
                                  "subSteps": [
                                    "Defina IVP: condições em y(x0) e y'(x0) no mesmo ponto x0.",
                                    "Defina BVP: condições y(a)=α e y(b)=β em pontos distintos a e b.",
                                    "Compare: IVP garante unicidade local; BVP pode não ter solução única.",
                                    "Identifique em equações dadas se são IVP ou BVP.",
                                    "Discuta existência e unicidade para BVPs lineares."
                                  ],
                                  "verification": "Classifique 3 equações como IVP ou BVP com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre IVP/BVP",
                                    "Exemplos impressos de problemas"
                                  ],
                                  "tips": [
                                    "Lembre: contorno = pontos diferentes; inicial = mesmo ponto.",
                                    "Desenhe o intervalo [a,b] para visualizar."
                                  ],
                                  "learningObjective": "Distinguir precisamente IVPs de BVPs pela localização das condições.",
                                  "commonMistakes": [
                                    "Confundir y(a)=α com condição inicial se a=x0.",
                                    "Esquecer que BVP requer dois pontos distintos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer a Forma Padrão de BVPs Lineares de Segunda Ordem",
                                  "subSteps": [
                                    "Combine: EDO y'' + p(x)y' + q(x)y = g(x) + condições y(a)=α, y(b)=β.",
                                    "Verifique linearidade: coeficientes não dependem de y, y', y''.",
                                    "Identifique protótipos: equação de Euler-Bernoulli para vigas, etc.",
                                    "Escreva 2 exemplos completos de BVPs.",
                                    "Analise se condições são de Dirichlet (valores de y) ou mistas."
                                  ],
                                  "verification": "Escreva a forma completa de um BVP linear e identifique componentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como MATLAB ou Python (SymPy)",
                                    "Lista de equações clássicas"
                                  ],
                                  "tips": [
                                    "Sempre cheque: 2ª ordem linear + 2 condições em pontos distintos.",
                                    "Use abstração: ignore solução, foque na forma."
                                  ],
                                  "learningObjective": "Identificar instantaneamente a estrutura prototípica de BVPs.",
                                  "commonMistakes": [
                                    "Aceitar condições no mesmo ponto como BVP.",
                                    "Confundir não-lineares com lineares."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Exemplos Iniciais Clássicos",
                                  "subSteps": [
                                    "Analise exemplo: y'' + y = 0, y(0)=0, y(π)=0 (cordas vibrantes).",
                                    "Classifique: y'' - y' + y = sin(x), y(0)=1, y(1)=0.",
                                    "Crie seu próprio BVP simples e verifique.",
                                    "Discuta 3 exemplos reais: deflexão de vigas, calor em barra.",
                                    "Teste com variações: adicione não-linearidade e reclassifique."
                                  ],
                                  "verification": "Identifique corretamente 5 exemplos mistos como BVP ou não.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios de livro-texto",
                                    "Planilha com 10 problemas para classificar"
                                  ],
                                  "tips": [
                                    "Procure a assinatura: y'' linear + y(a), y(b).",
                                    "Pratique com timer para rapidez."
                                  ],
                                  "learningObjective": "Aplicar reconhecimento em contextos variados e exemplos iniciais.",
                                  "commonMistakes": [
                                    "Classificar IVPs com condições em extremos como BVP.",
                                    "Ignorar termo g(x) como quebra de linearidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a equação y'' + 4y = 0 com condições y(0) = 0 e y(π/2) = 1. Identifique: EDO linear homogênea de 2ª ordem + condições de Dirichlet em pontos distintos → BVP linear clássico, modelando vibração de membrana fixada.",
                              "finalVerifications": [
                                "Lista corretamente a forma geral de BVP linear de 2ª ordem.",
                                "Classifica 80% de exemplos dados como BVP ou não.",
                                "Explica diferença chave entre IVP e BVP.",
                                "Identifica protótipos clássicos (ex: vigas, calor).",
                                "Cria um exemplo válido de BVP inicial.",
                                "Discute condições para existência/unicidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da forma y'' + p y' + q y = g.",
                                "Correta distinção de condições de contorno vs iniciais.",
                                "Reconhecimento de linearidade e ordem.",
                                "Capacidade de abstrair protótipos clássicos.",
                                "Justificativa clara e concisa para classificações.",
                                "Aplicação a exemplos concretos sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas e vibrações com condições de contorno.",
                                "Engenharia: Análise de deflexão em vigas e estruturas.",
                                "Computação: Implementação numérica em solvers de BVP (ex: SciPy).",
                                "Física Computacional: Diferenças finitas para BVPs em simulações."
                              ],
                              "realWorldApplication": "Em engenharia civil, BVPs modelam a deflexão de vigas sob carga, com condições y(0)=0 (apoio fixo) e y(L)=0 (apoio livre), permitindo calcular tensões e otimizar designs de pontes e edifícios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Formulação Matemática do BVP",
                        "description": "Estabelecimento da notação e formulação geral para problemas de valor de contorno em EDOs, incluindo formas lineares e não lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Escrever a forma geral de um BVP linear",
                            "description": "Formular um BVP linear de segunda ordem como L[y] = f(x), onde L[y] = a(x)y'' + b(x)y' + c(x)y, sujeito a condições de contorno separadas ou mistas em x=a e x=b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação diferencial ordinária (EDO) linear de segunda ordem",
                                  "subSteps": [
                                    "Identifique os componentes principais: função desconhecida y(x), derivadas y'(x) e y''(x).",
                                    "Reconheça os coeficientes variáveis a(x), b(x) e c(x), que multiplicam y'' , y' e y, respectivamente.",
                                    "Note o termo de não-homogeneidade f(x) no lado direito da equação.",
                                    "Escreva a forma geral da EDO: a(x)y''(x) + b(x)y'(x) + c(x)y(x) = f(x).",
                                    "Verifique que a(x) ≠ 0 no intervalo [a, b] para garantir que é de segunda ordem."
                                  ],
                                  "verification": "Escreva a EDO geral em um papel e confirme que todos os termos estão presentes e corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Equações Diferenciais",
                                    "Calculadora simbólica opcional"
                                  ],
                                  "tips": "Comece com exemplos homogêneos simples (f(x)=0) para fixar a estrutura antes de adicionar f(x).",
                                  "learningObjective": "Dominar a estrutura padrão de uma EDO linear de segunda ordem com coeficientes variáveis.",
                                  "commonMistakes": [
                                    "Confundir y' com y'' ou inverter os coeficientes.",
                                    "Esquecer que os coeficientes podem depender de x."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o operador diferencial linear L[y]",
                                  "subSteps": [
                                    "Defina o operador L como L[y] = a(x) y'' + b(x) y' + c(x) y.",
                                    "Explique que L é linear porque satisfaz L[αy + βz] = α L[y] + β L[z].",
                                    "Reescreva a EDO na forma compacta L[y] = f(x).",
                                    "Teste com um exemplo simples: para y'' + y = sin(x), L[y] = y'' + y.",
                                    "Confirme que L não inclui o termo f(x), que fica do outro lado."
                                  ],
                                  "verification": "Construa L[y] para uma EDO dada e verifique se aplicando a uma função teste obtém o resultado esperado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de EDOs de um livro ou online"
                                  ],
                                  "tips": "Pense em L como uma 'máquina' que transforma y em a combinação linear de suas derivadas.",
                                  "learningObjective": "Entender e notação do operador diferencial L para representar EDOs lineares.",
                                  "commonMistakes": [
                                    "Incluir f(x) dentro de L[y].",
                                    "Esquecer parênteses em L[y] ao escrever."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar as condições de contorno (BCs)",
                                  "subSteps": [
                                    "Defina condições separadas: α y(a) + β y'(a) = γ e δ y(b) + ε y'(b) = ζ.",
                                    "Classifique: Dirichlet (y(a)=valor), Neumann (y'(a)=valor), mistas (combinações).",
                                    "Escreva BCs em forma geral para x=a e x=b.",
                                    "Exemplo: y(0)=0 (Dirichlet em a=0), y'(π)=1 (Neumann em b=π).",
                                    "Garanta que as BCs sejam lineares e homogêneas ou não, conforme o problema."
                                  ],
                                  "verification": "Para um problema dado, identifique e escreva as duas BCs corretamente nos pontos a e b.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e canita",
                                    "Lista de exemplos de BCs de análise numérica"
                                  ],
                                  "tips": "Sempre especifique os pontos exatos x=a e x=b para evitar ambiguidades.",
                                  "learningObjective": "Classificar e formular condições de contorno separadas ou mistas para BVPs.",
                                  "commonMistakes": [
                                    "Confundir condições em a e b.",
                                    "Usar condições periódicas sem especificar."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular o BVP linear completo",
                                  "subSteps": [
                                    "Combine a equação L[y] = f(x) com as duas condições de contorno.",
                                    "Escreva o BVP como: Encontrar y tal que L[y] = f(x), com BCs em x=a e x=b.",
                                    "Verifique a linearidade: L linear, BCs lineares.",
                                    "Exemplo completo: L[y] = y'' - y = 0, y(0)=0, y(1)=1.",
                                    "Confirme o intervalo [a,b] e que é um BVP de segunda ordem."
                                  ],
                                  "verification": "Escreva o BVP geral para um problema descritivo e compare com a forma padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software como Mathematica ou Python para validar sintaxe"
                                  ],
                                  "tips": "Sempre declare 'sujeito a condições de contorno' explicitamente.",
                                  "learningObjective": "Montar a formulação matemática completa de um BVP linear de segunda ordem.",
                                  "commonMistakes": [
                                    "Esquecer uma das BCs.",
                                    "Não especificar o domínio [a,b]."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o problema físico de uma viga em flexão: a equação é (EI y'')'' = q(x), mas simplificada para linear de segunda ordem: y'' = f(x), com BCs y(0)=0 (empotrada) e y'(L)=0 (livre). Forma geral: L[y] = y'' = f(x), y(0)=0, y'(L)=0, onde a=0, b=L.",
                              "finalVerifications": [
                                "Escreva corretamente L[y] para uma EDO dada.",
                                "Identifique e formule duas BCs separadas ou mistas.",
                                "Monte o BVP completo com domínio [a,b].",
                                "Verifique linearidade de L e BCs.",
                                "Dê um exemplo numérico simples.",
                                "Explique verbalmente a estrutura para um colega."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação de L[y] (coeficientes corretos).",
                                "Correta classificação e escrita das BCs.",
                                "Formulação completa do BVP com todos elementos.",
                                "Demonstração de compreensão da linearidade.",
                                "Uso apropriado de notação matemática.",
                                "Capacidade de aplicar a um exemplo concreto."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de vibrações e ondas com EDOs.",
                                "Engenharia: Análise de estruturas (vigas, membranas).",
                                "Computação: Implementação de solvers numéricos (finite differences).",
                                "Física Computacional: Simulações em Python/MATLAB."
                              ],
                              "realWorldApplication": "Formulação de BVPs é essencial em engenharia para simular deflexão de vigas sob carga, distribuição de temperatura em barras (condução de calor) e perfis de velocidade em escoamentos viscosos, permitindo soluções numéricas em softwares como ANSYS ou COMSOL."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Descrever condições de contorno comuns",
                            "description": "Explicar tipos de condições como Dirichlet (y(a)=α, y(b)=β), Neumann (y'(a)=α, y'(b)=β) e mistas (y(a)=α, y'(b)=β), e sua representação matricial para sistemas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Geral de Condições de Contorno em BVPs",
                                  "subSteps": [
                                    "Definir Problema de Valor de Contorno (BVP) como uma EDO com condições especificadas nas extremidades do intervalo.",
                                    "Explicar a necessidade de condições de contorno para garantir unicidade da solução.",
                                    "Diferenciar BVPs de Problemas de Valor Inicial (IVP), destacando a localização das condições.",
                                    "Identificar o intervalo típico [a, b] e os tipos de condições possíveis.",
                                    "Discutir a ordem da EDO e o número de condições necessárias (geralmente n para ordem n)."
                                  ],
                                  "verification": "Escrever uma definição clara de BVP e listar 3 diferenças para IVP.",
                                  "estimatedTime": "0.5 hours",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Caderno e caneta",
                                    "Slides ou vídeo introdutório sobre BVPs"
                                  ],
                                  "tips": "Use analogias físicas como uma corda vibrante fixada nas extremidades para visualizar.",
                                  "learningObjective": "Compreender o papel fundamental das condições de contorno na formulação de BVPs.",
                                  "commonMistakes": "Confundir condições de contorno com condições iniciais; ignorar a ordem da equação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever Condições de Dirichlet",
                                  "subSteps": [
                                    "Definir condição de Dirichlet: y(a) = α e y(b) = β, onde α e β são valores conhecidos.",
                                    "Explicar que especifica o valor da solução diretamente nas fronteiras.",
                                    "Derivar a representação para uma EDO de segunda ordem.",
                                    "Discutir aplicações comuns, como temperaturas fixas em placas.",
                                    "Esboçar graficamente: solução interpolando valores nas bordas."
                                  ],
                                  "verification": "Escrever a notação matemática exata e um exemplo numérico simples.",
                                  "estimatedTime": "0.75 hours",
                                  "materials": [
                                    "Software de plotagem (ex: Desmos ou MATLAB)",
                                    "Exemplos de problemas de calor/difusão"
                                  ],
                                  "tips": "Lembre-se: Dirichlet é 'valor prescrito', fácil de implementar em métodos de diferenças finitas.",
                                  "learningObjective": "Dominar a descrição e notação precisa de condições Dirichlet.",
                                  "commonMistakes": "Escrever y'(a) em vez de y(a); confundir com Neumann."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever Condições de Neumann e Mistas",
                                  "subSteps": [
                                    "Definir Neumann: y'(a) = α e y'(b) = β, especificando derivadas (fluxos).",
                                    "Explicar condições mistas: combinação como y(a) = α e y'(b) = β.",
                                    "Discutir compatibilidade para existência de solução (ex: integral para Neumann puro).",
                                    "Comparar os três tipos em uma tabela: Dirichlet, Neumann, Mista.",
                                    "Fornecer exemplos físicos: Neumann para isolamento térmico."
                                  ],
                                  "verification": "Criar uma tabela comparativa com notações e exemplos para cada tipo.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Tabela em Excel ou papel",
                                    "Referências de física aplicada (ex: equação do calor)"
                                  ],
                                  "tips": "Para mistas, identifique qual fronteira usa valor e qual usa derivada.",
                                  "learningObjective": "Diferenciar e descrever precisamente Neumann e condições mistas.",
                                  "commonMistakes": "Esquecer condições de compatibilidade em Neumann; inverter notações em mistas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Representação Matricial para Sistemas de BVPs",
                                  "subSteps": [
                                    "Explicar sistemas de EDOs: Y' = A Y + F, com condições de contorno BC(Y(a), Y(b)) = dados.",
                                    "Definir matriz de condições de contorno: forma BC(Y) = B_a Y(a) + B_b Y(b) = γ.",
                                    "Mostrar exemplo para sistema de 2 EDOs com condições Dirichlet/Neumann mistas.",
                                    "Derivar a matriz split para métodos numéricos (ex: shooting method).",
                                    "Verificar linearidade e invertibilidade da matriz BC."
                                  ],
                                  "verification": "Construir a matriz BC para um sistema simples de 2x2.",
                                  "estimatedTime": "1.25 hours",
                                  "materials": [
                                    "MATLAB ou Python (NumPy) para matrizes",
                                    "Papel para derivações matriciais"
                                  ],
                                  "tips": "Use notação vetor Y para sistemas; teste com Y constante para validar.",
                                  "learningObjective": "Formular condições de contorno em forma matricial para sistemas lineares.",
                                  "commonMistakes": "Confundir B_a e B_b; não especificar dimensões da matriz."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Sintetizar Todos os Tipos de Condições",
                                  "subSteps": [
                                    "Revisar os três tipos principais e suas matrizes associadas.",
                                    "Classificar um BVP dado em um dos tipos ou misto.",
                                    "Discutir quando cada tipo é apropriado baseado em aplicações.",
                                    "Preparar resumo: fórmulas chave e exemplos.",
                                    "Praticar descrevendo um BVP arbitrário."
                                  ],
                                  "verification": "Descrever completamente um BVP exemplo incluindo matriz se aplicável.",
                                  "estimatedTime": "0.5 hours",
                                  "materials": [
                                    "Resumo em uma página",
                                    "Quiz autoavaliação"
                                  ],
                                  "tips": "Crie flashcards com notações para revisão rápida.",
                                  "learningObjective": "Sintetizar o conhecimento para descrever qualquer condição de contorno comum.",
                                  "commonMistakes": "Generalizar demais, perdendo especificidades matriciais."
                                }
                              ],
                              "practicalExample": "Considere o BVP -y'' + y = 0 em [0, π], com condições Dirichlet y(0)=0, y(π)=0. A solução é y=0 (trivial). Para Neumann y'(0)=0, y'(π)=0, soluções incluem constantes. Matricial para sistema: suponha duas EDOs, BC = [1 0] Y(0) + [0 -1] Y(π) = [0; 1] para mista.",
                              "finalVerifications": [
                                "Listar corretamente as notações para Dirichlet, Neumann e mista.",
                                "Explicar diferença física entre valor e derivada nas fronteiras.",
                                "Construir matriz BC para um sistema de 2 EDOs simples.",
                                "Identificar tipo de condição em um BVP dado.",
                                "Discutir uma limitação (ex: Neumann puro pode não ter solução única).",
                                "Fornecer exemplo real-world para cada tipo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (100% correto).",
                                "Clareza na distinção entre tipos de condições.",
                                "Correta formulação matricial para sistemas.",
                                "Uso de exemplos relevantes e corretos.",
                                "Compreensão de implicações físicas/matemáticas.",
                                "Capacidade de classificar BVPs arbitrários."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equações de onda/calor com fronteiras fixas (Dirichlet) ou livres (Neumann).",
                                "Engenharia: Simulações em CFD (Computational Fluid Dynamics) com condições de contorno.",
                                "Computação: Implementação em métodos numéricos (diferenças finitas, elementos finitos).",
                                "Física Computacional: Shooting method requerendo matriz BC."
                              ],
                              "realWorldApplication": "Em engenharia térmica, condições Dirichlet modelam temperaturas fixas nas bordas de uma placa (ex: dissipador de calor); Neumann para superfícies isoladas; usadas em simulações de clima, previsão de fluxo de calor em edifícios ou design de reatores nucleares."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Estender para BVPs não lineares e de ordem superior",
                            "description": "Generalizar a formulação para EDOs não lineares F(x, y, y', ..., y^{(n)}) = 0 com condições de contorno lineares ou não lineares em múltiplos pontos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar formulação de BVPs lineares de ordem superior",
                                  "subSteps": [
                                    "Relembre a forma geral de EDO linear de ordem n: a_n y^{(n)} + ... + a_0 y = g(x).",
                                    "Discuta redução a sistema de EDOs de primeira ordem usando substituições y_1 = y, y_2 = y', ..., y_n = y^{(n-1)}.",
                                    "Identifique condições de contorno lineares em pontos x_i: α_{i,j} y^{(j-1)}(x_i) + β_{i,j} y^{(j)}(x_i) = γ_i para j=1 a n.",
                                    "Pratique com exemplo de ordem 3 linear.",
                                    "Verifique consistência das condições (n condições independentes)."
                                  ],
                                  "verification": "Escreva a matriz de condições de contorno e confirme que é invertível.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de Análise Numérica (Burden & Faires), caderno, calculadora simbólica (Wolfram Alpha).",
                                  "tips": "Sempre normalize a equação dividindo pelo coeficiente líder a_n.",
                                  "learningObjective": "Compreender a estrutura linear de BVPs de ordem superior como pré-requisito para generalizações.",
                                  "commonMistakes": "Confundir ordem da derivada nas condições de contorno; ignorar independência das condições."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir não linearidades na equação diferencial",
                                  "subSteps": [
                                    "Generalize para forma não linear: F(x, y, y', y'', ..., y^{(n)}) = 0, onde F não é linear em y^{(k)}.",
                                    "Classifique tipos de não linearidades: explícitas em y^{(n)}, implícitas, ou em coeficientes dependentes de y.",
                                    "Reduza a sistema de primeira ordem não linear: y'_i = f_i(x, y_1, ..., y_n) para i=1 a n.",
                                    "Analise existência e unicidade via teorema de Picard-Lindelöf para sistemas não lineares.",
                                    "Teste com exemplo: y''' + (y')^3 + y y'' = sin(x)."
                                  ],
                                  "verification": "Escreva o sistema equivalente de primeira ordem e verifique se preserva a não linearidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software MATLAB ou Python (SciPy) para plotar soluções aproximadas, notas de aula.",
                                  "tips": "Use expansão em série para linearizar localmente e ganhar intuição.",
                                  "learningObjective": "Dominar a representação geral de EDOs não lineares de ordem superior.",
                                  "commonMistakes": "Assumir linearidade ao reduzir; esquecer dependências cruzadas entre variáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular condições de contorno lineares e não lineares",
                                  "subSteps": [
                                    "Defina condições lineares separadas: g_i(y(x_i), y'(x_i), ..., y^{(n-1)}(x_i)) = 0 com g_i linear.",
                                    "Estenda para não lineares: G_i(x_i, y(x_i), ..., y^{(n-1)}(x_i)) = 0, com m condições em k pontos (m=n).",
                                    "Discuta problemas multi-point: condições em x_0, x_1, ..., x_k com alocação de derivadas.",
                                    "Verifique bem-posedness: número correto de condições independentes.",
                                    "Exemplo: y(0)=0, y'(1)+y(1)^2=1, y''(π)=0 para ordem 3."
                                  ],
                                  "verification": "Liste as condições e confirme que especificam n graus de liberdade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Papel quadriculado, software SymPy para manipulação simbólica.",
                                  "tips": "Enumere condições explicitamente para evitar contagem errada de ordens.",
                                  "learningObjective": "Capacitar formulação precisa de condições de contorno arbitrárias.",
                                  "commonMistakes": "Sobredeterminar o sistema (mais de n condições); condições dependentes levando a singularidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever formulação geral do BVP e discutir implicações numéricas",
                                  "subSteps": [
                                    "Compile: Encontre y(x) em [a,b] s.a. F(x, y, ..., y^{(n)})=0 e G_i(x_i, y(x_i), ..., y^{(n-1)}(x_i))=0 para i=1 a n.",
                                    "Discuta métodos numéricos iniciais: shooting para não lineares, diferenças finitas para ordem superior.",
                                    "Analise estabilidade: contraste com IVPs via condições de contorno.",
                                    "Implemente discretização básica em grade uniforme.",
                                    "Avalie sensibilidade a parâmetros não lineares."
                                  ],
                                  "verification": "Esboce pseudocódigo para método de shooting adaptado a ordem superior.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com NumPy/SciPy, exemplos de código de repositórios GitHub de análise numérica.",
                                  "tips": "Comece com casos lineares para validar código antes de não lineares.",
                                  "learningObjective": "Integrar todos elementos em formulação completa e preparar para resolução numérica.",
                                  "commonMistakes": "Ignorar acoplamento forte em sistemas não lineares; mal-condicionar matrizes de contorno."
                                }
                              ],
                              "practicalExample": "Resolva numericamente o BVP não linear de ordem 3: y''' + y (y')^2 + cos(x) y'' = 0 com y(0)=0, y'(0)=1, y(1)+y''(1)=2. Use método de shooting múltiplo: adivinhe y''(0), integre via Runge-Kutta e ajuste via Newton-Raphson até satisfazer y(1)+y''(1)=2.",
                              "finalVerifications": [
                                "Escreva corretamente a forma geral F(x, y, y', ..., y^{(n)})=0.",
                                "Reduza um BVP de ordem 4 não linear a sistema de 4 EDOs de 1a ordem.",
                                "Formule condições multi-point com 2 lineares e 2 não lineares.",
                                "Identifique quando um BVP está mal posto.",
                                "Implemente discretização simples e verifique resíduos <1e-6.",
                                "Discuta convergência para caso não linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão na generalização matemática (sem erros tipográficos em notação).",
                                "Profundidade na redução a sistemas de 1a ordem (incluindo Jacobiana).",
                                "Correta contagem e independência de condições de contorno.",
                                "Capacidade de identificar não linearidades e suas implicações numéricas.",
                                "Qualidade do exemplo prático com solução verificável.",
                                "Análise de estabilidade e sugestões de métodos numéricos apropriados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de elastoplasticidade em vigas (EDOs não lineares de ordem 4).",
                                "Engenharia Mecânica: Dinâmica de satélites com controle não linear.",
                                "Computação Científica: Algoritmos de otimização em shooting methods.",
                                "Biologia: Modelos de crescimento populacional com BVPs multi-point."
                              ],
                              "realWorldApplication": "Simulações em engenharia aeroespacial para perfis de temperatura em foguetes (EDOs não lineares de alta ordem com condições em múltiplas seções), ou modelagem de fluxo sanguíneo em artérias com condições não lineares nas extremidades."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Características e Propriedades dos BVPs",
                        "description": "Análise das propriedades fundamentais como existência, unicidade e bem-postoção dos problemas de valor de contorno.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Discutir existência e unicidade de soluções",
                            "description": "Explicar teoremas como o de existência e unicidade para BVPs lineares homogêneos, dependendo da não nulidade da solução trivial do problema adjunto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar formulação de BVPs lineares homogêneos",
                                  "subSteps": [
                                    "Defina um BVP linear homogêneo: Lu = f com condições de contorno homogêneas.",
                                    "Escreva a forma geral: - (p(x) u')' + q(x) u = 0, com u(a)=0, u(b)=0.",
                                    "Identifique os coeficientes p(x), q(x) e as condições de contorno.",
                                    "Discuta trivialidade da solução u=0.",
                                    "Liste propriedades básicas como linearidade e homogeneidade."
                                  ],
                                  "verification": "Escreva a formulação geral de um BVP homogêneo e identifique todos os componentes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre EDOs",
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Sempre verifique se as condições de contorno são homogêneas para aplicar teoremas específicos.",
                                  "learningObjective": "Compreender a estrutura padrão de BVPs lineares homogêneos.",
                                  "commonMistakes": [
                                    "Confundir homogêneo com não-homogêneo",
                                    "Ignorar o domínio [a,b] finito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o problema adjunto",
                                  "subSteps": [
                                    "Defina o problema adjunto para o operador L: L* v = - (p v')' + q v = 0 com condições adjuntas.",
                                    "Derive a forma do operador adjunto L* a partir de integração por partes.",
                                    "Escreva as condições de contorno para o adjunto: v(a)=0, v(b)=0 para problemas de Dirichlet homogêneos.",
                                    "Verifique simetria: para operadores auto-adjuntos, L = L*.",
                                    "Calcule o adjunto para um exemplo simples como -u'' + q u = 0."
                                  ],
                                  "verification": "Derive corretamente o operador adjunto para um BVP dado e escreva suas condições.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico como Mathematica ou SymPy",
                                    "Exercícios resolvidos de EDOs",
                                    "Quadro branco virtual"
                                  ],
                                  "tips": "Use integração por partes duas vezes para confirmar a forma adjunta.",
                                  "learningObjective": "Dominar a construção e propriedades do problema adjunto.",
                                  "commonMistakes": [
                                    "Erro no sinal ao derivar L*",
                                    "Condições de contorno incorretas para o adjunto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o teorema de existência e unicidade",
                                  "subSteps": [
                                    "Enuncie o teorema: Existe solução única se a solução trivial do adjunto é não-nula (ou kernel trivial).",
                                    "Explique a dependência: Unicidade segue se ker(L*) = {0}.",
                                    "Discuta prova via Fredholm alternativo para operadores compactos.",
                                    "Analise casos: Se existe v ≠ 0 tal que L* v = 0, então inconsistência possível.",
                                    "Relacione com autovalores: Unicidade falha em autovalores."
                                  ],
                                  "verification": "Enuncie e prove esboçadamente o teorema para um caso simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Teorema de Fredholm em PDF acadêmico",
                                    "Vídeos de análise funcional básica",
                                    "Folhas de exercícios"
                                  ],
                                  "tips": "Lembre-se: Para auto-adjuntos, reduz a ker(L) = {0}.",
                                  "learningObjective": "Explicar precisamente o teorema de existência e unicidade.",
                                  "commonMistakes": [
                                    "Confundir ker(L) com ker(L*)",
                                    "Ignorar homogeneidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e discutir em exemplos",
                                  "subSteps": [
                                    "Resolva um BVP exemplo: -u'' = 0, u(0)=u(1)=0 e encontre solução trivial.",
                                    "Construa adjunto e verifique ker(L*) trivial.",
                                    "Considere caso com autovalor: u'' + λ u = 0 e discuta falha de unicidade.",
                                    "Discuta generalizações para condições de contorno mistas.",
                                    "Conclua com condições suficientes para existência/unicidade."
                                  ],
                                  "verification": "Analise 2 exemplos: um com unicidade e um sem, justificando com adjunto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Python para plotar soluções",
                                    "Exemplos de livros de EDOs numéricas"
                                  ],
                                  "tips": "Sempre compute autovalores para prever problemas de unicidade.",
                                  "learningObjective": "Aplicar o teorema para discutir existência e unicidade em casos concretos.",
                                  "commonMistakes": [
                                    "Não verificar solução trivial do adjunto",
                                    "Generalizar incorretamente para não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o BVP -u'' + u = 0, u(0)=0, u(π)=0: O adjunto é idêntico (auto-adjunto). Solução trivial u=0 é única pois λ=1 não é autovalor (autovalores são n²). Logo, existência e unicidade garantidas.",
                              "finalVerifications": [
                                "Enuncie corretamente o teorema de existência e unicidade.",
                                "Derive o adjunto para um BVP dado.",
                                "Identifique quando ker(L*) é trivial em um exemplo.",
                                "Discuta falha de unicidade via autovalores.",
                                "Aplique a um BVP não-trivial com condições mistas.",
                                "Explique relação com Fredholm alternativo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação do teorema (20%)",
                                "Correta derivação do adjunto (25%)",
                                "Análise correta de exemplos (25%)",
                                "Discussão de condições de falha (15%)",
                                "Clareza na explicação escrita/oral (10%)",
                                "Uso apropriado de conceitos relacionados (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Equações de onda e difusão em membranas.",
                                "Engenharia: Análise de vigas e estabilidade estrutural.",
                                "Computação: Métodos numéricos como diferenças finitas.",
                                "Análise Funcional: Espaços de Sobolev e operadores elípticos."
                              ],
                              "realWorldApplication": "Em simulações de difusão de calor em barras fixas nas extremidades, o teorema garante solução única para distribuições de calor iniciais, essencial para engenharia térmica e previsão climática em modelos 1D."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Identificar problemas mal postas",
                            "description": "Reconhecer casos onde BVPs não têm solução única, como ressonância em problemas lineares, ou múltiplas soluções em não lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos fundamentais de BVPs bem e mal postas",
                                  "subSteps": [
                                    "Defina um Problema de Valor de Contorno (BVP) como uma equação diferencial com condições de contorno.",
                                    "Explique o que significa um problema 'bem posto' segundo Hadamard: existência, unicidade e estabilidade da solução.",
                                    "Identifique os três pilares: existência (existe solução?), unicidade (é única?), estabilidade (pequenas perturbações levam a pequenas mudanças?).",
                                    "Diferencie problemas mal postos por falha em um ou mais pilares, focando em falta de unicidade.",
                                    "Estude exemplos simples de EDOs lineares de segunda ordem."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos de bem e mal postas, citando Hadamard.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notas de aula sobre BVPs",
                                    "Folha de papel para anotações"
                                  ],
                                  "tips": "Use analogias como 'chave e fechadura' para unicidade: uma chave certa abre unicamente.",
                                  "learningObjective": "Compreender os critérios teóricos para classificar BVPs.",
                                  "commonMistakes": "Confundir mal posto com não linear; lembre que lineares podem ser mal postas por ressonância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar BVPs lineares e detectar ressonância",
                                  "subSteps": [
                                    "Considere a EDO linear homogênea y'' + λ y = 0 com condições y(0)=0, y(1)=0.",
                                    "Resolva analiticamente para autovalores λ_n = (nπ)^2.",
                                    "Identifique ressonância quando λ coincide com autovalor: solução trivial ou infinita.",
                                    "Verifique matriz associada ao método de diferenças finitas para singularidade.",
                                    "Teste numericamente com λ próximo a autovalores."
                                  ],
                                  "verification": "Classifique 3 exemplos lineares como bem ou mal postas justificando.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (SciPy)",
                                    "Exemplos de BVPs lineares impressos"
                                  ],
                                  "tips": "Plote soluções para visualizar não unicidade em ressonância.",
                                  "learningObjective": "Reconhecer falta de unicidade em lineares via ressonância.",
                                  "commonMistakes": "Ignorar condições homogêneas; sempre verifique se são homogêneas ou não."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar BVPs não lineares e múltiplas soluções",
                                  "subSteps": [
                                    "Estude EDO não linear como y'' = f(x,y,y') com condições de contorno.",
                                    "Use teorema de existência/unicidade de Picard-Lindelöf para condições locais.",
                                    "Identifique casos sem unicidade: bifurcações ou múltiplos ramos de solução.",
                                    "Aplique método de disparo (shooting) e observe convergência para múltiplas soluções.",
                                    "Compare com lineares para destacar diferenças."
                                  ],
                                  "verification": "Descreva por que um BVP não linear específico tem múltiplas soluções.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com solve_bvp (SciPy)",
                                    "Artigos sobre bifurcações em BVPs"
                                  ],
                                  "tips": "Varie parâmetros para forçar bifurcações e visualizar.",
                                  "learningObjective": "Identificar não unicidade em contextos não lineares.",
                                  "commonMistakes": "Assumir unicidade por linearidade; não lineares são mais propensos a múltiplas soluções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e sintetizar critérios",
                                  "subSteps": [
                                    "Resolva 5 BVPs mistos (lineares e não lineares) e classifique cada um.",
                                    "Crie um fluxograma para diagnóstico: linear? Ver ressonância; não linear? Ver múltiplas soluções.",
                                    "Discuta estabilidade em mal postas.",
                                    "Aplique a problemas reais simplificados.",
                                    "Revise erros comuns em uma autoavaliação."
                                  ],
                                  "verification": "Crie e resolva um BVP mal posto original.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de exercícios de BVPs",
                                    "Ferramenta de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Use fluxogramas para automatizar o raciocínio diagnóstico.",
                                  "learningObjective": "Aplicar critérios de forma autônoma em novos problemas.",
                                  "commonMistakes": "Focar só em existência, ignorando unicidade."
                                }
                              ],
                              "practicalExample": "Considere o BVP linear y'' + π² y = 0, y(0)=0, y(1)=0. Solução: y=0 (trivial), mas ressonância (λ=π² é autovalor) implica soluções infinitas com perturbações, tornando-o mal posto por falta de unicidade.",
                              "finalVerifications": [
                                "Classifica corretamente 90% de BVPs lineares com ressonância.",
                                "Identifica múltiplas soluções em BVPs não lineares via método de disparo.",
                                "Explica Hadamard em problemas mal postas.",
                                "Cria fluxograma diagnóstico funcional.",
                                "Aplica a exemplos reais sem erros.",
                                "Discute estabilidade em mal postas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de bem/mal postas (80%+).",
                                "Correta detecção de ressonância em lineares.",
                                "Análise de unicidade em não lineares.",
                                "Uso adequado de métodos numéricos.",
                                "Criatividade em exemplos originais.",
                                "Clareza em justificativas teóricas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Ressonância em equações de onda e vibrações.",
                                "Engenharia: Modelagem de vigas e estabilidade estrutural.",
                                "Computação: Algoritmos numéricos e condicionamento de matrizes.",
                                "Física Computacional: Simulações de PDEs mal postas."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, identificar BVPs mal postos em modelos de flutter de asas evita falhas catastróficas por vibrações ressonantes não únicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Relacionar com estabilidade e rigidez",
                            "description": "Associar características de BVPs com desafios numéricos como estabilidade em métodos de shooting e problemas stiff, preparando para métodos de solução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Estabilidade e Rigidez em EDOs",
                                  "subSteps": [
                                    "Defina estabilidade numérica como a capacidade de um método manter erros limitados ao longo da integração.",
                                    "Explique rigidez (stiffness) como a presença de escalas temporais muito diferentes nos termos da EDO, exigindo passos de tempo pequenos em métodos explícitos.",
                                    "Compare estabilidade em IVPs versus BVPs, destacando que BVPs envolvem condições em ambas as extremidades.",
                                    "Identifique indicadores de rigidez, como autovalores com partes reais grandes e negativas.",
                                    "Discuta exemplos simples de EDOs stiff, como y' = -1000y + sin(t)."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre estabilidade e rigidez, com um exemplo numérico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Análise Numérica (ex: Burden & Faires), calculadora ou Python/MATLAB para testes simples.",
                                  "tips": "Use analogias físicas: rigidez como uma mola muito dura que oscila rapidamente.",
                                  "learningObjective": "Compreender definições precisas e identificar rigidez em EDOs básicas.",
                                  "commonMistakes": "Confundir rigidez com instabilidade; rigidez causa instabilidade em métodos explícitos, mas não é sinônimo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Manifestação de Estabilidade e Rigidez em BVPs",
                                  "subSteps": [
                                    "Formule um BVP padrão: y'' + p(x)y' + q(x)y = g(x), y(a)=α, y(b)=β.",
                                    "Examine como condições de contorno afetam a propagação de erros, diferentemente de IVPs.",
                                    "Teste numericamente um BVP não-stiff vs stiff, observando sensibilidade a malha.",
                                    "Calcule o espectro de autovalores da matriz jacobiana linearizada para detectar rigidez.",
                                    "Discuta como BVPs stiff surgem em aplicações como difusão-reação."
                                  ],
                                  "verification": "Classifique um BVP dado como stiff ou não, justificando com análise de autovalores.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software numérico (MATLAB ode15s ou SciPy solve_bvp), exemplos de BVPs do contexto curricular.",
                                  "tips": "Comece com BVPs lineares para isolar efeitos de rigidez.",
                                  "learningObjective": "Relacionar características estruturais de BVPs com potenciais problemas de estabilidade e rigidez.",
                                  "commonMistakes": "Ignorar o impacto das condições de contorno na amplificação de erros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Impacto nos Métodos de Shooting",
                                  "subSteps": [
                                    "Descreva o método de shooting simples: transforma BVP em IVP com parâmetro de contorno.",
                                    "Simule falhas de estabilidade em shooting para BVPs stiff, mostrando divergência.",
                                    "Implemente shooting múltiplo e observe necessidade de passos adaptativos.",
                                    "Compare com métodos explícitos vs implícitos no contexto de shooting.",
                                    "Quantifique erro de contorno para avaliar estabilidade."
                                  ],
                                  "verification": "Execute simulação de shooting em um BVP stiff e reporte se convergeu ou não.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código Python/MATLAB para shooting (função fsolve para iteração de Newton), gráficos de solução.",
                                  "tips": "Use damping no shooting para rigidez moderada.",
                                  "learningObjective": "Identificar limitações de estabilidade nos métodos de shooting para BVPs rígidos.",
                                  "commonMistakes": "Escolher passos de tempo fixos grandes em problemas stiff, levando a instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preparar para Métodos de Solução Alternativos",
                                  "subSteps": [
                                    "Liste métodos robustos para BVPs stiff: diferenças finitas implícitas, collocation.",
                                    "Compare eficiência: shooting vs métodos globais em termos de estabilidade.",
                                    "Analise critérios para escolher método baseado em rigidez (ex: Lipschitz constante).",
                                    "Desenvolva fluxograma de decisão: se stiff → use implícito.",
                                    "Teste um método alternativo em exemplo anterior."
                                  ],
                                  "verification": "Crie fluxograma pessoal para seleção de método baseado em análise de rigidez.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Referências: Chapra ou Ascher & Petzold, implementações em bibliotecas numéricas.",
                                  "tips": "Priorize métodos que tratam o BVP globalmente para rigidez severa.",
                                  "learningObjective": "Selecionar estratégias de solução adequadas antecipando desafios de estabilidade e rigidez.",
                                  "commonMistakes": "Persistir com shooting simples em BVPs altamente rígidos sem adaptações."
                                }
                              ],
                              "practicalExample": "Considere o BVP stiff: y'' - 1000^2 y = -1000^2 sin(x), y(0)=0, y(π)=0. Usando shooting simples com método explícito (RK4), observe oscilações e divergência devido à rigidez; contraste com método implícito (BVP4c no MATLAB), que converge suavemente.",
                              "finalVerifications": [
                                "Explique verbalmente como rigidez afeta shooting em BVPs.",
                                "Classifique corretamente 3 BVPs exemplo como stiff ou não.",
                                "Implemente e compare shooting vs método global em um caso stiff.",
                                "Identifique autovalores indicativos de rigidez em matriz jacobiana.",
                                "Crie fluxograma de decisão para métodos de BVP.",
                                "Resolva um BVP stiff com sucesso usando ferramenta apropriada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e distinção de estabilidade vs rigidez (20%)",
                                "Análise correta de exemplos numéricos de BVPs (25%)",
                                "Demonstração de impactos em métodos de shooting via simulações (25%)",
                                "Seleção adequada de métodos alternativos com justificativa (15%)",
                                "Fluxograma lógico e completo (10%)",
                                "Clareza em verificações e exemplos práticos (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas amortecidas ou difusão em meios heterogêneos.",
                                "Engenharia Química: Reatores com cinéticas rígidas (fast-slow reactions).",
                                "Computação Científica: Otimização de solvers numéricos em HPC.",
                                "Matemática Aplicada: Teoria de autovalores em estabilidade de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, BVPs rígidos modelam vibrações de estruturas (ex: asas de avião); relacionar rigidez garante uso de solvers estáveis como COLNEW, evitando falhas em simulações de fadiga."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.2",
                              "10.1.6.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Método de Tiro Simples",
                    "description": "Técnica que converte o BVP em um problema de valor inicial resolvido iterativamente com condições de contorno.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Formulação do Problema de Valor de Contorno como Problema de Valor Inicial",
                        "description": "Conversão de um BVP de segunda ordem em um sistema de EDOs de primeira ordem, transformando as condições de contorno em um parâmetro inicial a ser ajustado iterativamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Identificar e reescrever o BVP como sistema de IVP parametrizado",
                            "description": "Dado um BVP y'' = f(x, y, y'), y(a)=α, y(b)=β, transformá-lo em um sistema y' = z, z' = f(x,y,z) com condição inicial y(a)=α, z(a)=s (parâmetro a estimar para satisfazer y(b)=β).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar e identificar os componentes do Problema de Valor de Contorno (BVP)",
                                  "subSteps": [
                                    "Leia atentamente a equação diferencial dada: y'' = f(x, y, y').",
                                    "Identifique os limites do intervalo [a, b].",
                                    "Anote as condições de contorno: y(a) = α e y(b) = β.",
                                    "Verifique se o BVP é de segunda ordem e linear ou não linear.",
                                    "Esboce graficamente o domínio e as condições para visualização."
                                  ],
                                  "verification": "Lista completa dos componentes (equação, intervalo, condições) anotada corretamente sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora opcional",
                                    "Referência ao problema exemplo"
                                  ],
                                  "tips": "Sempre comece escrevendo o BVP exatamente como dado para evitar confusões.",
                                  "learningObjective": "Compreender a estrutura padrão de um BVP de segunda ordem.",
                                  "commonMistakes": [
                                    "Confundir condições de contorno com iniciais",
                                    "Ignorar dependências em f(x, y, y')"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a variável auxiliar z = y' para reduzir a ordem",
                                  "subSteps": [
                                    "Defina z(x) = y'(x) como nova variável dependente.",
                                    "Diferencie z para obter z' = y'' = f(x, y, y') = f(x, y, z).",
                                    "Escreva o sistema equivalente: y' = z e z' = f(x, y, z).",
                                    "Confirme que o sistema é de primeira ordem com duas equações.",
                                    "Substitua y'' por z' em uma equação de exemplo para praticar."
                                  ],
                                  "verification": "Sistema de duas EDOs de primeira ordem escrito corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de BVP impresso ou anotado"
                                  ],
                                  "tips": "Lembre-se: z substitui y', então f(x, y, y') vira f(x, y, z) diretamente.",
                                  "learningObjective": "Transformar EDO de segunda ordem em sistema de primeira ordem.",
                                  "commonMistakes": [
                                    "Esquecer de diferenciar z ou manter y'' no sistema",
                                    "Usar z' = f(x, y, y') em vez de f(x, y, z)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir as condições iniciais parametrizadas no ponto x = a",
                                  "subSteps": [
                                    "Use a condição conhecida y(a) = α diretamente como inicial para y.",
                                    "Introduza o parâmetro s como condição inicial para z: z(a) = s.",
                                    "Escreva o IVP: y' = z, z' = f(x, y, z), com y(a) = α, z(a) = s.",
                                    "Explique que s é desconhecido e será ajustado para satisfazer y(b) = β.",
                                    "Verifique dimensionalmente se s tem sentido como y'(a)."
                                  ],
                                  "verification": "IVP parametrizado escrito com condições iniciais corretas em x = a.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de EDOs como MATLAB ou Python opcional para teste"
                                  ],
                                  "tips": "s representa a derivada inicial desconhecida; pense nele como 'chute inicial' no método de tiro.",
                                  "learningObjective": "Estabelecer IVP com parâmetro para matching de condição terminal.",
                                  "commonMistakes": [
                                    "Colocar condições em x = b como iniciais",
                                    "Confundir α com s"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a transformação e preparar para o método de tiro",
                                  "subSteps": [
                                    "Integre conceitualmente o IVP de a até b para obter y(b; s).",
                                    "Defina a função de tiro: φ(s) = y(b; s) - β = 0 para encontrar s.",
                                    "Compare soluções: confirme que o BVP original é recuperado quando φ(s) = 0.",
                                    "Teste com um BVP linear simples para verificar.",
                                    "Documente a transformação completa em formato final."
                                  ],
                                  "verification": "Transformação validada com φ(s) definida corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo resolvido de referência"
                                  ],
                                  "tips": "Visualize numericamente: resolva IVP para diferentes s e veja y(b) cruzar β.",
                                  "learningObjective": "Conectar a reformulação ao Método de Tiro Simples.",
                                  "commonMistakes": [
                                    "Definir φ(s) = y(a; s) em vez de y(b)",
                                    "Esquecer o sinal em φ(s) = y(b) - β"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o BVP y'' + y = 0, y(0) = 0, y(π) = 0: Introduza z = y', então y' = z, z' = -y, com y(0) = 0, z(0) = s. Resolva IVP e ajuste s tal que y(π; s) = 0 (s = 0 satisfaz, pois solução é y = 0).",
                              "finalVerifications": [
                                "O sistema tem exatamente duas EDOs de primeira ordem: y' = z e z' = f(x, y, z).",
                                "Condições iniciais em x = a: y(a) = α (conhecida), z(a) = s (parâmetro).",
                                "Condição terminal y(b) = β usada para determinar s via φ(s) = y(b; s) - β = 0.",
                                "Transformação preserva a equação diferencial original.",
                                "Sistema é equivalente ao BVP quando s é escolhido corretamente.",
                                "Notação consistente: f(x, y, z) substitui f(x, y, y')."
                              ],
                              "assessmentCriteria": [
                                "Precisão na reescrita do sistema de EDOs (sem erros algébricos).",
                                "Correta identificação e parametrização das condições iniciais.",
                                "Definição explícita da função de tiro φ(s).",
                                "Validação conceitual da equivalência BVP-IVP.",
                                "Clareza e completude na documentação da transformação.",
                                "Tratamento correto de dependências em f(x, y, z)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de osciladores harmônicos ou vigas elásticas via EDOs.",
                                "Programação: Implementação numérica em Python (SciPy) ou MATLAB para resolver IVP.",
                                "Engenharia: Otimização de parâmetros em simulações de estruturas.",
                                "Estatística: Root-finding como estimação de parâmetros em modelos diferenciais."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, reformular BVPs de deflexão de asas (y'' = carga distribuída) como IVPs parametrizados para simulações numéricas via Método de Tiro, ajustando condições de cisalhamento inicial para matching de deflexão terminal em CFD."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Definir a função de erro para iteração",
                            "description": "Construir a função φ(s) = ψ(b; s) - β, onde ψ(b; s) é a solução do IVP com z(a)=s, para que φ(s)=0 defina o chute inicial correto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Valor de Contorno (BVP)",
                                  "subSteps": [
                                    "Identifique as equações diferenciais de segunda ordem: z''(x) = f(x, z, z') no intervalo [a, b].",
                                    "Escreva as condições de contorno: z(a) = α (conhecida) e z(b) = β (conhecida).",
                                    "Explique por que o BVP não pode ser resolvido diretamente como IVP padrão.",
                                    "Discuta a necessidade de transformar o BVP em um problema iterativo."
                                  ],
                                  "verification": "Escreva corretamente as condições do BVP para um exemplo dado e explique a dificuldade numérica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro-texto de Análise Numérica (capítulo de EDOs)"
                                  ],
                                  "tips": "Desenhe o intervalo [a,b] e marque as condições de contorno graficamente para visualização.",
                                  "learningObjective": "Entender a estrutura padrão de um BVP de segunda ordem com condições separadas.",
                                  "commonMistakes": "Confundir condições de Dirichlet (em pontos) com Neumann (em derivadas); assumir IVP direto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Chute Inicial s no Método de Tiro Simples",
                                  "subSteps": [
                                    "Defina s como o valor chute para a derivada desconhecida z'(a) = s.",
                                    "Explique que α = z(a) é conhecida, mas z'(a) precisa ser encontrado iterativamente.",
                                    "Descreva o objetivo: encontrar s tal que a solução atenda z(b) = β.",
                                    "Mencione que o método usa raiz de uma função unidimensional em s.",
                                    "Discuta a monotonicidade típica de ψ em s para convergência."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que s é o parâmetro de iteração e como φ(s)=0 resolve o BVP.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplos de problemas de tiro de livros"
                                  ],
                                  "tips": "Pense em s como 'velocidade inicial' em um problema físico para intuição.",
                                  "learningObjective": "Reconhecer s como parâmetro livre que transforma BVP em família de IVPs.",
                                  "commonMistakes": "Esquecer que z(a)=α é fixo e apenas z'(a)=s varia; confundir com métodos de diferença finita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o Problema de Valor Inicial (IVP) Dependente de s",
                                  "subSteps": [
                                    "Escreva o sistema IVP: z'(x) = w(x), w'(x) = f(x, z, w), com z(a)=α, w(a)=s.",
                                    "Descreva ψ(x; s) como a solução z(x; s) do IVP até x=b.",
                                    "Especifique que ψ(b; s) é o valor de z(b) obtido para cada s.",
                                    "Implemente conceitualmente um solver numérico (ex: Runge-Kutta) para IVP."
                                  ],
                                  "verification": "Formule o IVP escrito para um BVP dado e isole ψ(b; s).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software como MATLAB/Octave ou Python (SciPy odeint)",
                                    "Papel para sistema equivalente de 1ª ordem"
                                  ],
                                  "tips": "Sempre reduza EDO de 2ª ordem a sistema de 1ª ordem para solvers numéricos.",
                                  "learningObjective": "Capacitar a transformação de BVP em IVP parametrizado por s.",
                                  "commonMistakes": "Esquecer de definir w = z'; usar condições erradas no IVP."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a Função de Erro φ(s)",
                                  "subSteps": [
                                    "Defina φ(s) = ψ(b; s) - β explicitamente.",
                                    "Verifique que φ é função de s apenas, com ψ(b; s) computado via IVP.",
                                    "Explique que φ(s) mede o 'erro' na condição z(b)=β para chute s.",
                                    "Confirme que a raiz φ(s*)=0 dá o chute correto s* resolvendo o BVP.",
                                    "Discuta continuidade e derivabilidade de φ para métodos de raiz (ex: Newton)."
                                  ],
                                  "verification": "Escreva a fórmula exata de φ(s) para um BVP exemplo e compute φ para s=0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou software para IVP",
                                    "Exemplo analítico simples"
                                  ],
                                  "tips": "Teste com s pequeno e grande para ver sinal de φ mudar, garantindo raiz.",
                                  "learningObjective": "Definir precisamente φ(s) como base para iteração numérica.",
                                  "commonMistakes": "Confundir ψ(b; s) com z(a); inverter subtração em φ(s) = ψ - β."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e Validar a Função φ(s) para Iteração",
                                  "subSteps": [
                                    "Analise o comportamento: φ crescente se solução linear em s.",
                                    "Planeje iteração: use bissecção ou Newton em φ(s)=0.",
                                    "Valide com exemplo analítico onde solução exata é conhecida.",
                                    "Discuta tolerância: pare quando |φ(s)| < ε."
                                  ],
                                  "verification": "Para um exemplo, encontre s aproximado tal que φ(s)≈0 e verifique solução.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software numérico",
                                    "Gráfico de φ(s) vs s"
                                  ],
                                  "tips": "Plote φ(s) para vários s para visualizar a raiz.",
                                  "learningObjective": "Compreender φ como função de erro para solvers de raiz no método de tiro.",
                                  "commonMistakes": "Ignorar não-linearidades que podem causar múltiplas raízes; não normalizar escalas."
                                }
                              ],
                              "practicalExample": "Considere o BVP: y'' + y = 0, y(0) = 0, y(π/2) = 1 em [0, π/2]. Chute s = y'(0). IVP: y(0)=0, y'(0)=s → y(x; s) = s sin(x). Então ψ(π/2; s) = s * 1 = s, φ(s) = s - 1. Raiz: s=1, solução y=sin(x).",
                              "finalVerifications": [
                                "Pode escrever φ(s) = ψ(b; s) - β para qualquer BVP dado.",
                                "Explica corretamente o papel de s como z'(a).",
                                "Computa ψ(b; s) para um exemplo numérico simples.",
                                "Identifica que φ(s)=0 resolve o BVP original.",
                                "Discute como usar φ em métodos de raiz (bissecção, secante).",
                                "Valida com exemplo analítico onde s exato é conhecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de φ(s) e suas componentes (100% correto).",
                                "Compreensão conceitual: explica transformação BVP → IVP → φ (rubrica 1-5).",
                                "Habilidade prática: computa φ para 2-3 valores de s em exemplo (erro <1%).",
                                "Análise qualitativa: descreve monotonicidade e convergência.",
                                "Clareza na escrita: fórmulas legíveis, sem erros notacionais.",
                                "Criatividade: sugere melhoria como normalização de φ."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar solver IVP em Python/MATLAB para ψ(b;s).",
                                "Física: Aplicações em osciladores harmônicos ou trajetórias balísticas.",
                                "Engenharia Computacional: Integração em pacotes FEM para BVPs não-lineares.",
                                "Estatística: Análise de sensibilidade de s em Monte Carlo.",
                                "Ciências de Dados: Otimização de hiperparâmetros similar a busca de raiz."
                              ],
                              "realWorldApplication": "No design de foguetes, define condições de contorno para trajetórias (s como ângulo de lançamento); em transferência de calor, modela temperaturas em placas com bordas fixas; em finanças, resolve EDOs de Black-Scholes com BCs para precificação de opções."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Escolher método numérico para resolver o IVP",
                            "description": "Selecionar métodos de passo simples como Runge-Kutta de ordem 4 para integrar o IVP de forma precisa e eficiente no método de tiro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar as características do Problema de Valor Inicial (IVP)",
                                  "subSteps": [
                                    "Relembrar a formulação do PVC como IVP: converter y'' = f(x, y, y') com condições y(a) = α e y'(a) = s (s parâmetro a iterar).",
                                    "Identificar propriedades da equação diferencial: linear ou não-linear, autônoma, presença de rigidez ou singularidades.",
                                    "Determinar o intervalo de integração [a, b] e condições de precisão desejada (ex.: tolerância de erro 10^{-6}).",
                                    "Avaliar o comportamento esperado da solução (oscilatória, crescente, etc.).",
                                    "Documentar em uma tabela: ordem da ODE, tipo de f, tamanho do intervalo."
                                  ],
                                  "verification": "Lista completa das propriedades do IVP anotada em tabela ou documento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, calculadora, enunciado do problema de valor de contorno.",
                                  "tips": "Use um fluxograma para mapear as condições iniciais e o intervalo.",
                                  "learningObjective": "Compreender as especificidades do IVP gerado pelo método de tiro.",
                                  "commonMistakes": "Confundir condições de contorno com condições iniciais ou ignorar o parâmetro s."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar e listar métodos numéricos de passo simples candidatos",
                                  "subSteps": [
                                    "Listar métodos comuns: Euler explícito, Heun (RK2), Runge-Kutta de ordem 3 e 4.",
                                    "Descrever fórmulas básicas: para Euler, y_{n+1} = y_n + h f(x_n, y_n); para RK4, as 4 etapas de avaliação.",
                                    "Comparar ordens de precisão: Euler O(h), RK2 O(h^2), RK4 O(h^4).",
                                    "Avaliar custo computacional: número de avaliações de f por passo (Euler:1, RK4:4).",
                                    "Consultar referências rápidas para fórmulas exatas."
                                  ],
                                  "verification": "Tabela comparativa com métodos, ordens, custos e fórmulas resumidas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Livro de análise numérica ou notas de aula, software como MATLAB/Octave para fórmulas.",
                                  "tips": "Priorize métodos explícitos de ordem alta para problemas não rígidos típicos.",
                                  "learningObjective": "Conhecer as características principais dos métodos de passo simples.",
                                  "commonMistakes": "Esquecer que métodos implícitos são mais caros para iteração no método de tiro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar critérios de seleção para o IVP específico",
                                  "subSteps": [
                                    "Priorizar precisão: escolher método com ordem alta (≥4) para reduzir h sem custo excessivo.",
                                    "Verificar estabilidade: testar ou recordar regiões de estabilidade (RK4 bom para problemas suaves).",
                                    "Analisar eficiência: equilibrar precisão vs. número de passos (N = (b-a)/h).",
                                    "Considerar implementação: métodos com coeficientes fixos como RK4 são mais simples.",
                                    "Simular erro estimado: erro global ≈ (b-a) * erro local / h."
                                  ],
                                  "verification": "Pontuação qualitativa (1-5) para cada critério por método, em tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou papel para cálculos de erro, gráficos de estabilidade.",
                                  "tips": "Use h pequeno inicialmente para testar, mas otimize para eficiência.",
                                  "learningObjective": "Aplicar critérios quantitativos e qualitativos na escolha.",
                                  "commonMistakes": "Ignorar custo computacional em iterações múltiplas do método de tiro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e justificar o método Runge-Kutta de ordem 4 (RK4)",
                                  "subSteps": [
                                    "Escolher RK4 pela alta precisão O(h^4) adequada a IVPs do método de tiro.",
                                    "Justificar estabilidade e eficiência para intervalos moderados sem rigidez extrema.",
                                    "Comparar com alternativas: RK4 supera Euler em precisão sem custo proibitivo.",
                                    "Planejar implementação: definir k1 a k4 e atualizar y e y'.",
                                    "Documentar justificativa em parágrafo claro."
                                  ],
                                  "verification": "Relatório escrito com escolha final e razões comparativas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto, pseudocódigo do RK4.",
                                  "tips": "Sempre valide com um teste simples antes do PVC completo.",
                                  "learningObjective": "Dominar a decisão motivada pela RK4 como padrão eficiente.",
                                  "commonMistakes": "Escolher Euler por simplicidade, subestimando erro acumulado."
                                }
                              ],
                              "practicalExample": "Para o PVC y'' + y = 0 com y(0)=0, y(π)=1, formule IVP: y'' = -y, y(0)=0, y'(0)=s. Escolha RK4 (h=0.1) pela precisão O(h^4), integrando de 0 a π para φ(π,s)=1-s=0, iterando s até convergência.",
                              "finalVerifications": [
                                "Explica corretamente a ordem de precisão e custo do RK4 vs. Euler.",
                                "Justifica escolha baseada em propriedades do IVP (ex.: não rígido).",
                                "Constrói tabela comparativa com pelo menos 3 métodos.",
                                "Identifica quando RK4 é inadequado (ex.: ODE rígida).",
                                "Planeja h ótimo para tolerância de erro desejada.",
                                "Verifica com exemplo numérico simples (erro <10^{-5})."
                              ],
                              "assessmentCriteria": [
                                "Correção na análise do IVP (100% das propriedades listadas).",
                                "Profundidade da comparação de métodos (ordem, custo, estabilidade).",
                                "Justificativa lógica e quantitativa para RK4 (equilíbrio precisão/eficiência).",
                                "Ausência de erros comuns (ex.: confusão de condições iniciais).",
                                "Clareza na documentação (tabelas, fluxogramas usados).",
                                "Capacidade de generalizar para outros IVPs."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar RK4 em Python (biblioteca NumPy/SciPy).",
                                "Física: Resolver equações de movimento em osciladores harmônicos.",
                                "Engenharia: Simulações de trajetórias em aerodinâmica.",
                                "Computação Científica: Otimização de solvers em MATLAB."
                              ],
                              "realWorldApplication": "No método de tiro para problemas de valores de contorno em engenharia estrutural (vibrações de vigas) ou mecânica quântica (equação de Schrödinger em 1D), onde RK4 permite simulações precisas e eficientes de perfis de tensão ou funções de onda em softwares como ANSYS ou COMSOL."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Algoritmo Iterativo do Método de Tiro Simples",
                        "description": "Procedimento iterativo para encontrar o valor de s que satisfaz a condição de contorno final, utilizando métodos de busca unidimensional como secante ou Newton.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Implementar iteração com método da secante",
                            "description": "Iniciar com s0 e s1, calcular φ(si), atualizar si+1 = si - φ(si)(si - si-1)/(φ(si) - φ(si-1)), até |φ(si)| < tol.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a função φ(s) e preparar o ambiente computacional",
                                  "subSteps": [
                                    "Importar bibliotecas necessárias: numpy, scipy.integrate e matplotlib.pyplot.",
                                    "Definir o problema de valor de contorno e implementar o resolvedor de IVP para calcular y(b; s), onde y(0)=a, y'(0)=s.",
                                    "Codificar φ(s) = y(b; s) - valor desejado em b.",
                                    "Testar φ com valores iniciais para garantir que retorna escalares corretos.",
                                    "Adicionar comentários explicando o contexto do método de tiro simples."
                                  ],
                                  "verification": "Executar φ(s0) e φ(s1) isoladamente e verificar saídas numéricas esperadas sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "SciPy (odeint ou solve_ivp)",
                                    "Matplotlib"
                                  ],
                                  "tips": "Use solve_ivp para precisão; defina o intervalo [0, b] explicitamente.",
                                  "learningObjective": "Compreender e codificar a função auxiliar φ(s) que encapsula o disparo do IVP.",
                                  "commonMistakes": [
                                    "Esquecer de definir y'(0)=s nas condições iniciais",
                                    "Erro no sinal de φ(s)",
                                    "Não vectorizar para eficiência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar parâmetros de iteração e convergência",
                                  "subSteps": [
                                    "Escolher estimativas iniciais s0 e s1 baseadas em análise qualitativa ou chute razoável.",
                                    "Definir tolerância tol (ex: 1e-6) e máximo de iterações max_iter (ex: 100).",
                                    "Criar listas para armazenar histórico de s_i e φ(s_i) para depuração e visualização.",
                                    "Imprimir parâmetros iniciais para confirmação.",
                                    "Verificar se s0 != s1 para evitar divisão por zero inicial."
                                  ],
                                  "verification": "Parâmetros impressos na tela e históricos vazios prontos para preenchimento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código do Step 1"
                                  ],
                                  "tips": "Escolha s0 e s1 do mesmo sinal que a solução esperada para aceleração.",
                                  "learningObjective": "Configurar corretamente os hiperparâmetros para garantir convergência estável.",
                                  "commonMistakes": [
                                    "tol muito pequeno causando iterações excessivas",
                                    "s0 e s1 muito próximos causando φ(s1)-φ(s0)=0",
                                    "max_iter baixo demais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop de iteração do método da secante",
                                  "subSteps": [
                                    "Calcular φ_s0 = φ(s0) e φ_s1 = φ(s1).",
                                    "Iniciar loop while i < max_iter and abs(φ_s1) >= tol:",
                                    "  Calcular denominador = φ_s1 - φ_s0; if abs(denominador) < 1e-12: break (tratamento de falha).",
                                    "  s_new = s1 - φ_s1 * (s1 - s0) / denominador.",
                                    "  Atualizar s0 = s1, φ_s0 = φ_s1, s1 = s_new, φ_s1 = φ(s_new); i +=1.",
                                    "Armazenar s_i e φ(s_i) no histórico."
                                  ],
                                  "verification": "Executar loop em um teste simples; verificar que atualiza s corretamente sem loop infinito.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2"
                                  ],
                                  "tips": "Adicione print no loop para monitorar convergência durante testes.",
                                  "learningObjective": "Codificar precisamente a fórmula da secante e gerenciar o estado das iterações.",
                                  "commonMistakes": [
                                    "Erro no sinal da fórmula de atualização",
                                    "Não atualizar φ_s0 corretamente",
                                    "Divisão por zero sem tratamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar convergência, visualizar e documentar resultados",
                                  "subSteps": [
                                    "Verificar se abs(φ(s1)) < tol ou max_iter atingido; imprimir mensagem de status.",
                                    "Resolver IVP final com s1 e plotar y(x) vs solução analítica (se disponível).",
                                    "Plotar histórico de s_i e φ(s_i) para visualizar convergência.",
                                    "Calcular erro de contorno: |y(b; s1) - desejado|.",
                                    "Adicionar docstring completa à função e salvar código."
                                  ],
                                  "verification": "Gráficos gerados mostram convergência e condições de contorno satisfeitas dentro de tol.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código completo dos Steps anteriores"
                                  ],
                                  "tips": "Use semilogy para plot de |φ(s_i)| para melhor visualização de convergência quadrática.",
                                  "learningObjective": "Analisar e validar numericamente a solução obtida pelo método.",
                                  "commonMistakes": [
                                    "Não verificar falha de convergência",
                                    "Plot incorreto das condições de contorno",
                                    "Ignorar oscilações no histórico"
                                  ]
                                }
                              ],
                              "practicalExample": "Para y'' + y = 0, y(0)=0, y(π/2)=1 (solução y=sin(x), s*=1). Defina φ(s) = integrar IVP y(0)=0, y'(0)=s até π/2, φ(s)=y(π/2)-1. Inicialize s0=0.5, s1=1.5, tol=1e-8. O código converge em poucas iterações para s≈1, com y(π/2)≈1.",
                              "finalVerifications": [
                                "abs(φ(s_final)) < tol confirmada.",
                                "Número de iterações ≤ 20 para exemplo padrão.",
                                "Solução y(x; s_final) satisfaz y(0)=0 e y(b)≈desejado.",
                                "Histórico mostra redução quadrática de |φ(s_i)|.",
                                "Código executa sem erros para 3 problemas de teste diferentes.",
                                "Gráficos de convergência e solução gerados corretamente."
                              ],
                              "assessmentCriteria": [
                                "Fórmula da secante implementada exatamente como especificada.",
                                "Tratamento robusto de singularidades (denominador zero).",
                                "Eficiência: convergência em <30 iterações para problemas bem-condicionados.",
                                "Código modular, comentado e reutilizável.",
                                "Validações numéricas e visuais incluídas.",
                                "Tratamento de falhas (não convergência) com mensagens claras."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Integração numérica e controle de loops.",
                                "Física: Modelagem de osciladores harmônicos e problemas de contorno em ondas.",
                                "Engenharia: Simulações em estruturas e controle de sistemas dinâmicos.",
                                "Estatística: Análise de erro e ordem de convergência numérica."
                              ],
                              "realWorldApplication": "Aplicado em engenharia mecânica para calcular perfis de deflexão em vigas com condições de contorno mistas, em aerodinâmica para fluxos incompressíveis, e em bioengenharia para modelar difusão em tecidos com condições conhecidas nas extremidades."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Implementar iteração com método de Newton",
                            "description": "Calcular φ'(s) ≈ [φ(s+h) - φ(s)]/h ou analiticamente via variação, e iterar s_{i+1} = s_i - φ(s_i)/φ'(s_i).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e implementar a função φ(s)",
                                  "subSteps": [
                                    "Entenda o contexto do Método de Tiro Simples: para BVP y'' = f(x, y, y'), y(0) = α, y(1) = β, defina s = y'(0) e integre o IVP de x=0 a x=1.",
                                    "Implemente um resolvedor numérico de EDOs (ex: Runge-Kutta via scipy.integrate.solve_ivp) para computar y(1; s).",
                                    "Defina φ(s) = y(1; s) - β, onde y(1; s) é a solução do IVP com condições iniciais y(0)=α, y'(0)=s.",
                                    "Teste a função φ(s) com valores iniciais de s para verificar se retorna valores esperados.",
                                    "Documente a função com parâmetros de entrada (f, α, β, h se necessário)."
                                  ],
                                  "verification": "Execute φ(s) para 3 valores diferentes de s e confirme que os resultados variam monotonicamente ou conforme esperado para o problema teste.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "Documentação de solve_ivp",
                                    "Exemplo de BVP simples como y''=0"
                                  ],
                                  "tips": "Use método 'RK45' para precisão inicial; normalize o domínio [0,1] sempre.",
                                  "learningObjective": "Compreender e codificar a função auxiliar φ(s) que mede o erro de contorno no método de tiro.",
                                  "commonMistakes": [
                                    "Esquecer de passar y'(0)=s nas condições iniciais",
                                    "Não lidar com singularidades em f",
                                    "Escala errada no domínio de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o cálculo de φ'(s)",
                                  "subSteps": [
                                    "Escolha método: numérico φ'(s) ≈ [φ(s+h) - φ(s)] / h com h pequeno (ex: 1e-6), ou analítico via variação de parâmetros/sensibilidade.",
                                    "Para numérico: implemente função derivada_finite(s, h) chamando φ duas vezes.",
                                    "Para analítico: derive a EDO sensível z' = ∂f/∂y * z + ∂f/∂y', z(0)=0, então φ'(s) = z(1).",
                                    "Teste φ'(s) comparando com diferenças finitas centradas para validar.",
                                    "Adicione tolerância para h e verifique estabilidade numérica."
                                  ],
                                  "verification": "Compare φ'(s) numérico vs. analítico para pelo menos 2 pontos s; erro relativo < 1e-4.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "SciPy para integração múltipla",
                                    "Papel e lápis para derivar EDO sensível",
                                    "Notebook Jupyter para plots de φ e φ'"
                                  ],
                                  "tips": "Use h adaptativo: h = 1e-8 * |s| se s≠0; prefira analítico para problemas não-lineares.",
                                  "learningObjective": "Calcular a derivada da função φ(s) de forma precisa para uso no método de Newton.",
                                  "commonMistakes": [
                                    "h muito grande/pequeno causando erro de cancelamento",
                                    "Erro na formulação da EDO sensível",
                                    "Não inicializar z(0)=0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop iterativo de Newton",
                                  "subSteps": [
                                    "Inicialize s0 (ex: chute inicial s=0 ou estimativa grosseira).",
                                    "Defina tolerâncias: tol_res = 1e-6 para |φ(s)|, tol_step=1e-8 para |Δs|.",
                                    "Loop: while |φ(s_i)| > tol_res and i < max_iter (ex: 50): compute φ_i = φ(s_i), φp_i = φ'(s_i), s_{i+1} = s_i - φ_i / φp_i.",
                                    "Registre histórico de s_i, φ_i para análise de convergência.",
                                    "Pare se φ'(s_i) ≈0 (divisão por zero: adicione check e fallback)."
                                  ],
                                  "verification": "Execute o loop e confirme convergência em <20 iterações com |φ(s_final)| < 1e-10.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Código das funções φ e φ' dos steps anteriores",
                                    "Listas ou arrays NumPy para histórico"
                                  ],
                                  "tips": "Monitore ||Δs|| e |φ| em log; use max_iter para evitar loops infinitos.",
                                  "learningObjective": "Codificar o algoritmo iterativo de Newton-Raphson para raiz de φ(s)=0.",
                                  "commonMistakes": [
                                    "Chute inicial ruim levando a divergência",
                                    "Não checar φ'(s)=0",
                                    "Acumular erros de integração sem re-inicializar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar convergência e solução final",
                                  "subSteps": [
                                    "Após convergência, integre o IVP final com s* para obter y(x) completo.",
                                    "Verifique condições de contorno: |y(0)-α|<eps e |y(1)-β|<eps.",
                                    "Analise ordem de convergência plotando |φ_i| vs i (deve ser quadrática).",
                                    "Compare com solução exata se disponível ou mesh refinement.",
                                    "Gere relatório: s*, número de iterações, histórico de erros."
                                  ],
                                  "verification": "Solução satisfaz |y(1)-β| < 1e-8 e convergência quadrática observada no plot.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Solução analítica do exemplo teste"
                                  ],
                                  "tips": "Salve soluções em cada iteração para visualização de y(x) evoluindo.",
                                  "learningObjective": "Avaliar a robustez e precisão da implementação do método de Newton no tiro simples.",
                                  "commonMistakes": [
                                    "Ignorar oscilações em y(x)",
                                    "Falsa convergência por tol inadequada",
                                    "Não plotar histórico"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o BVP y'' + y = 0 com y(0) = 0, y(π/2) = 1 usando domínio [0, π/2]. Solução exata: y(x) = sin(x)/cos(π/2) wait, ajustado: y(x) = tan(x) approx numéricamente. Inicialize s0=1.5, espere convergência para s* ≈ 2.678 (tan(π/2 - eps)). Integre com 1000 passos, tol=1e-10, confirme y(π/2) ≈1.",
                              "finalVerifications": [
                                "φ(s*) < 1e-10",
                                "Número de iterações < 15 para problemas lineares",
                                "Erro relativo em y(1) vs exata < 1e-6",
                                "φ'(s*) computado consistentemente entre métodos",
                                "Histórico mostra redução quadrática de erro",
                                "Solução y(x) suave sem overshoot"
                              ],
                              "assessmentCriteria": [
                                "Correção da função φ(s): testes unitários passam",
                                "Precisão de φ'(s): erro <1e-5 vs benchmark",
                                "Convergência do Newton: detecta e para corretamente",
                                "Robustez: lida com φ'=0 e max_iter",
                                "Eficiência: tempo total <5s para exemplo padrão",
                                "Documentação: código comentado e relatório gerado"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/NumPy",
                                "Física: Modelagem de EDOs em mecânica/ondas",
                                "Engenharia: Otimização em controle/simulações CFD",
                                "Estatística: Análise de erro e convergência",
                                "Computação Científica: Métodos iterativos em ML/otimização"
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, resolve BVPs para perfis de temperatura em asas (y''=f(T)); em finanças, precificação de opções (EDOs parabólicas via tiro); em biologia, modelagem de difusão em tecidos com contornos fixos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Definir critérios de parada e controle de erro",
                            "description": "Estabelecer tolerâncias para |φ(s)|, número máximo de iterações e controle de passo no solver de IVP para estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes do critério de parada no Método de Tiro Simples",
                                  "subSteps": [
                                    "Revise a definição de φ(s) como a discrepância no valor de contorno final após integração do IVP com chute inicial s.",
                                    "Identifique os riscos de não ter critérios: divergência, oscilação ou precisão insuficiente.",
                                    "Estude exemplos de problemas de BVP lineares e não-lineares para contextualizar φ(s).",
                                    "Analise o impacto da tolerância em |φ(s)| na precisão da solução.",
                                    "Discuta estabilidade numérica em solvers de IVP como Runge-Kutta."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o papel de φ(s) e liste 3 riscos sem critérios.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre Método de Tiro, livro de Análise Numérica (ex: Burden & Faires), calculadora científica.",
                                  "tips": "Desenhe o fluxograma do algoritmo iterativo para visualizar onde os critérios se encaixam.",
                                  "learningObjective": "Entender conceitualmente os critérios de parada e seu impacto na convergência.",
                                  "commonMistakes": "Confundir φ(s) com erro de truncamento do método numérico; ignorar dependência em não-linearidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a tolerância para |φ(s)|",
                                  "subSteps": [
                                    "Escolha uma tolerância ε baseada na precisão desejada (ex: 10^-6 para problemas de engenharia).",
                                    "Formule o critério: pare se |φ(s_k)| < ε.",
                                    "Considere adaptação dinâmica de ε com base no resíduo inicial.",
                                    "Teste com um BVP simples: y'' + y = 0, y(0)=0, y(π)=0, chute s=1.",
                                    "Registre como ε afeta o número de iterações."
                                  ],
                                  "verification": "Implemente em código simples e mostre convergência para ε variando de 10^-3 a 10^-8.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software como MATLAB, Python (SciPy odeint), papel e lápis para protótipo.",
                                  "tips": "Comece com ε conservador (10^-4) para depuração rápida.",
                                  "learningObjective": "Selecionar e justificar tolerâncias apropriadas para convergência.",
                                  "commonMistakes": "Escolher ε muito pequeno causando lentidão; não escalar com norma do problema."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer número máximo de iterações e controle de passo",
                                  "subSteps": [
                                    "Defina N_max = 100-1000 iterações, baseado em complexidade do BVP.",
                                    "Implemente controle de passo adaptativo no solver IVP (h reduzido se erro local > tol).",
                                    "Adicione verificação: se iterações > N_max, pare e reporte falha.",
                                    "Integre detecção de estagnação: se |s_{k+1} - s_k| < δ, pare ou ajuste.",
                                    "Simule cenários de falha: BVP sem solução ou chute ruim."
                                  ],
                                  "verification": "Execute simulação atingindo N_max e demonstre relatório de erro gerado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python/MATLAB com ode45/odeint, exemplos de BVP de livros-textos.",
                                  "tips": "Use logs para monitorar |φ(s)| por iteração; plote gráfico de convergência.",
                                  "learningObjective": "Implementar safeguards contra loops infinitos e instabilidade.",
                                  "commonMistakes": "N_max muito baixo causando falsos negativos; ignorar rigidez no IVP."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e validar os critérios no algoritmo completo",
                                  "subSteps": [
                                    "Modifique o pseudocódigo do Método de Tiro para incluir todos os critérios.",
                                    "Teste em BVP não-linear: y'' = -y + sin(x), y(0)=0, y(π/2)=1.",
                                    "Ajuste parâmetros com base em testes: otimize ε e N_max.",
                                    "Documente o algoritmo final com critérios destacados.",
                                    "Compare solução numérica com analítica para validação."
                                  ],
                                  "verification": "Forneça código funcional que converge corretamente em < N_max iterações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ambiente de programação, solucionador simbólico (SymPy/MuPAD) para soluções exatas.",
                                  "tips": "Versione o código para comparar com/ sem controles.",
                                  "learningObjective": "Construir um algoritmo robusto e testável.",
                                  "commonMistakes": "Não testar bordes como ε=0 ou N_max=1; sobrecarga computacional em passos pequenos."
                                }
                              ],
                              "practicalExample": "Para o BVP y'' + y = 0 com y(0)=0, y(π)=0, use chute inicial s=0.5. Integre IVP até x=π com RK4 (h=0.01). Calcule φ(s) = y(π;s) - 0. Atualize s via Newton: s_{k+1} = s_k - φ(s_k)/φ'(s_k). Pare se |φ(s)| < 10^-6 ou k>50. Solução converge para s≈0 em ~5 iterações.",
                              "finalVerifications": [
                                "O algoritmo para corretamente quando |φ(s)| < ε.",
                                "Não excede N_max iterações em testes padrão.",
                                "Solução numérica coincide com exata dentro de 1% de erro relativo.",
                                "Controle de passo mantém estabilidade em BVPs rígidos.",
                                "Relatórios de falha são gerados e informativos.",
                                "Tempo de execução é razoável (<10s para problemas médios)."
                              ],
                              "assessmentCriteria": [
                                "Justificativa precisa para escolha de ε e N_max (baseada em análise de erro).",
                                "Implementação correta de todos os critérios no código.",
                                "Testes abrangentes cobrindo convergência, falha e estagnação.",
                                "Documentação clara dos parâmetros e fluxograma.",
                                "Solução otimizada: convergência em <20 iterações para exemplos padrão.",
                                "Identificação e correção de instabilidades numéricas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB com controle de exceções.",
                                "Física: Modelagem de equações diferenciais em mecânica/ondas.",
                                "Engenharia Computacional: Otimização em simulações CFD/FEM.",
                                "Estatística: Análise de sensibilidade de parâmetros numéricos."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais, define convergência em solvers para trajetórias de foguetes (BVP em dinâmica orbital), evitando crashes por iterações excessivas e garantindo precisão para controle de voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Análise de Convergência, Estabilidade e Limitações",
                        "description": "Estudo das condições para convergência quadrática, sensibilidade à estabilidade do IVP e problemas em casos stiff ou lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Analisar convergência do método",
                            "description": "Verificar que |φ'(s*)| < 1 para convergência local do método da secante e quadrática para Newton, onde s* é a raiz exata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição do método de tiro simples e função φ(s)",
                                  "subSteps": [
                                    "Relembre o problema de valor de contorno (BVP) típico: y'' + p(x)y' + q(x)y = g(x), com condições y(a)=α, y(b)=β.",
                                    "Descreva o método de tiro simples: chute inicial s para y'(a)=s, integre até x=b, defina φ(s) = y(b;s) - β.",
                                    "Identifique s* como a raiz exata de φ(s)=0.",
                                    "Explique convergência local: iterações s_{k+1} = ψ(s_k) convergem se |ψ'(s*)| < 1.",
                                    "Note que para Newton ψ(s) = s - φ(s)/φ'(s), e secante usa diferenças finitas."
                                  ],
                                  "verification": "Escreva a definição de φ(s) para um BVP exemplo e confirme que φ(s*)=0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), caderno de anotações, software de DEs como MATLAB/Octave.",
                                  "tips": "Desenhe o diagrama do método de tiro para visualizar φ(s).",
                                  "learningObjective": "Compreender a função iterativa φ(s) no contexto do método de tiro.",
                                  "commonMistakes": "Confundir condições de contorno inicial e final; ignorar dependência paramétrica em s."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a expressão analítica para φ'(s)",
                                  "subSteps": [
                                    "Defina a solução y(x;s) da EDO inicial com y(a)=α, y'(a)=s.",
                                    "Diferencie φ(s) = y(b;s) - β em relação a s: φ'(s) = ∂y(b;s)/∂s.",
                                    "Use variação de parâmetros ou sensibilidade: resolva EDO adjunta z' = A(x) z, z(a)=0, z'(a)=1, onde A é matriz jacobiana do sistema.",
                                    "Para EDO escalar de 2ª ordem, transforme em sistema de 1ª ordem e derive ∂y/∂s.",
                                    "Expresse φ'(s) = z(b;s), onde z satisfaz a EDO variacional."
                                  ],
                                  "verification": "Derive φ'(s) para y''=0, y(0)=0, y(1)=1 (s*=1), confirme φ'(s)=1-s.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Cálculo variacional básico, software simbólico (SymPy ou Mathematica).",
                                  "tips": "Linearize o sistema: para y' = f(x,y,s), ∂y/∂s' = Df/∂y * ∂y/∂s + ∂f/∂s.",
                                  "learningObjective": "Dominar derivação da derivada sensibilidade φ'(s).",
                                  "commonMistakes": "Esquecer condições iniciais para a EDO variacional; derivar incorretamente para ordem superior."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar φ'(s*) na raiz exata s*",
                                  "subSteps": [
                                    "Resolva analiticamente ou numericamente o BVP para encontrar s* exato.",
                                    "Compute φ'(s*) usando a fórmula derivada, preferencialmente analiticamente.",
                                    "Para método de Newton: verifique |φ'(s*)| ≠ 0 para quadraticidade, mas foque em |1 - φ(s*)/φ'(s*)'| ≈0.",
                                    "Para secante: note ordem 1.618, mas condição similar |φ'(s*)|<1 garante convergência.",
                                    "Calcule numericamente com precisão alta para validar."
                                  ],
                                  "verification": "Para exemplo y'' + y=0, y(0)=0, y(π/2)=1, encontre s*=1, φ'(s*)=cos(π/2)=0 <1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Solver numérico de EDOs (ode45 no MATLAB, scipy.integrate).",
                                  "tips": "Use soluções exatas quando possível para s* e φ'(s*).",
                                  "learningObjective": "Calcular e interpretar φ'(s*) corretamente.",
                                  "commonMistakes": "Avaliar em s aproximado em vez de exato; ignorar singularidades se φ'(s*)=0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar condição de convergência |φ'(s*)| < 1 e implicações",
                                  "subSteps": [
                                    "Verifique se |φ'(s*)| <1: convergência local garantida para fixed-point iteration.",
                                    "Para Newton: convergência quadrática se φ'(s*)≠0 e φ'' existe.",
                                    "Para secante: superlinear se φ'(s*)≠0.",
                                    "Discuta limitações: se |φ'(s*)|≥1, diver gência ou lento.",
                                    "Sugira melhorias: escalonamento ou métodos híbridos."
                                  ],
                                  "verification": "Classifique convergência para exemplo: |φ'(s*)|=0<1, Newton quadrático.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos de iterações (plot s_k vs k).",
                                  "tips": "Teste numericamente iterações próximas a s* para validar teorema.",
                                  "learningObjective": "Interpretar resultados para estabilidade e escolha de método.",
                                  "commonMistakes": "Confundir convergência local com global; negligenciar φ'(s*)=0 (superconvergência)."
                                }
                              ],
                              "practicalExample": "Considere BVP y'' + y = 0, y(0)=0, y(π/2)=1. Solução exata y=sin(x), s*=1. φ(s)=sin(π/2) + (s-1)cos(π/2) wait, derive: y(x;s)=s sin(x), φ(s)=s sin(π/2)-1=s-1, φ'(s)=1? Wait correct: for linear, φ(s)=s*(b-a)-β approx. Real: integrate, φ'(s*)=cos(π/2;s*)=0<1. Run Newton: converge em 1 passo.",
                              "finalVerifications": [
                                "Derivação de φ'(s) está correta e matches fórmula variacional.",
                                "Cálculo de φ'(s*) é preciso (erro <1e-6 numericamente).",
                                "|φ'(s*)| <1 é verificado com interpretação.",
                                "Diferenças entre Newton (quadrático) e secante são destacadas.",
                                "Exemplo prático resolve com convergência demonstrada.",
                                "Limitações se |φ'(s*)|≥1 são discutidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de φ'(s): 30%.",
                                "Correção no evaluation de |φ'(s*)|: 25%.",
                                "Interpretação teórica da convergência: 20%.",
                                "Uso de exemplo concreto com cálculos: 15%.",
                                "Discussão de ordens (quadrático/secante): 10%."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar solvers de EDOs em Python (scipy) para validar.",
                                "Física: Aplicar em equações de onda/calor com BVPs.",
                                "Estatística: Análise de sensibilidade em modelos paramétricos.",
                                "Engenharia: Otimização em controle de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, analisar convergência no método de tiro para perfis aerodinâmicos (BVPs em Navier-Stokes simplificados), garantindo eficiência computacional em simulações CFD."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Identificar problemas de estabilidade e stiff",
                            "description": "Reconhecer que oscilações no IVP propagam erros no tiro simples, sugerindo uso de métodos de passo múltiplo ou para stiff equations.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender estabilidade em problemas de valor inicial (IVP)",
                                  "subSteps": [
                                    "Revise a definição de estabilidade para métodos numéricos em IVPs: um método é estável se erros pequenos não crescem descontroladamente.",
                                    "Estude a região de estabilidade no plano complexo (hλ), usando exemplos como o método de Euler explícito.",
                                    "Analise como passos de tempo grandes podem levar a instabilidade em equações com autovalores negativos grandes.",
                                    "Implemente um IVP simples em Python/MATLAB e varie o passo de tempo para observar estabilidade.",
                                    "Compare estabilidade absoluta vs. relativa em contextos lineares e não-lineares."
                                  ],
                                  "verification": "Gerar gráficos de soluções numéricas estáveis e instáveis, confirmando que erros não explodem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), Python com NumPy/SciPy, Jupyter Notebook.",
                                  "tips": "Comece com equações lineares teste como y' = -λy para visualizar o plano de estabilidade.",
                                  "learningObjective": "Definir e ilustrar estabilidade numérica em IVPs com exemplos gráficos.",
                                  "commonMistakes": "Confundir estabilidade numérica com estabilidade do problema; ignorar o papel do passo de tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer equações stiff e suas manifestações",
                                  "subSteps": [
                                    "Defina equações stiff: IVPs com escalas de tempo muito diferentes (autovalores com partes reais muito negativas).",
                                    "Examine exemplos clássicos: y' = -1000y + sin(t), observando oscilações espúrias em métodos explícitos.",
                                    "Simule uma equação stiff não-linear e compare soluções com métodos explícitos vs. implícitos.",
                                    "Identifique sinais: necessidade de passos de tempo minúsculos para estabilidade apesar de solução suave.",
                                    "Discuta escalas múltiplas e decomposição em componentes rápidos/lentos."
                                  ],
                                  "verification": "Produzir plot comparando solução exata vs. numérica com oscilações detectadas em stiff case.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "SciPy odeint/solve_ivp, exemplos de código de stiff equations online, papel e lápis para análise.",
                                  "tips": "Use o teste de Dahlquist para validar stiff: verifique se hλ <<1 é necessário.",
                                  "learningObjective": "Identificar e diagnosticar equações stiff por meio de simulações e análise espectral.",
                                  "commonMistakes": "Atribuir oscilações a instabilidade do problema em vez de método inadequado; subestimar rigidez."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar propagação de erros no método de tiro simples",
                                  "subSteps": [
                                    "Revise o método de tiro simples para BVPs: chutes iniciais para IVP até contorno final.",
                                    "Simule um BVP com componente stiff e observe oscilações propagadas do IVP ao matching de contorno.",
                                    "Calcule o Jacobiano da função de resíduo e analise autovalores para prever instabilidade.",
                                    "Teste sensibilidade: varie chutes iniciais e passos de tempo, medindo erros de convergência.",
                                    "Documente como erros no IVP amplificam no tiro devido à integração sensível."
                                  ],
                                  "verification": "Resolver BVP stiff com tiro simples, plotando trajetórias com oscilações e falha de convergência.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB fsolve ou SciPy fsolve, código template para shooting method.",
                                  "tips": "Linearize o BVP para análise inicial; use zoom em plots para detectar oscilações sutis.",
                                  "learningObjective": "Demonstrar como instabilidades de IVP propagam erros no método de tiro simples.",
                                  "commonMistakes": "Ignorar normalização de condições de contorno; usar passos fixos sem adaptação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar problemas e sugerir métodos alternativos",
                                  "subSteps": [
                                    "Liste critérios diagnósticos: oscilações, passos minúsculos necessários, falha de convergência rápida.",
                                    "Compare com métodos de passo múltiplo (multiple shooting) para melhor estabilidade global.",
                                    "Explore métodos para stiff: implícitos (BDF, Rosenbrock) no contexto de tiro.",
                                    "Implemente multiple shooting em um caso stiff e compare convergência.",
                                    "Recomende híbridos: COLNEW ou pacotes como bvpsolve para BVPs stiff."
                                  ],
                                  "verification": "Relatório comparando tiro simples vs. múltiplo em BVP stiff, com métricas de erro e tempo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Documentação SciPy.integrate.solve_bvp, papers sobre multiple shooting.",
                                  "tips": "Particione o intervalo em subdomínios pequenos para multiple shooting.",
                                  "learningObjective": "Diagnosticar falhas de estabilidade/stiff e propor soluções apropriadas.",
                                  "commonMistakes": "Sugestão genérica sem justificativa; não testar em casos reais."
                                }
                              ],
                              "practicalExample": "Resolva o BVP stiff y'' + 1000(y - cos(x)) = 0, y(0)=1, y(π)=1 com tiro simples: observe oscilações na solução do IVP que impedem matching preciso no x=π, exigindo h<0.001; contraste com multiple shooting dividindo [0,π] em 4 intervalos.",
                              "finalVerifications": [
                                "Explicar verbalmente como oscilações em IVP stiff propagam para erro no tiro simples.",
                                "Identificar em gráfico: oscilações espúrias vs. solução suave real.",
                                "Calcular autovalores aproximados e prever necessidade de método implícito.",
                                "Implementar e comparar tiro simples vs. múltiplo em código funcional.",
                                "Listar 3 critérios para detectar stiff em contexto de BVP.",
                                "Sugerir método alternativo com justificativa quantitativa (ex: redução de iterações)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de estabilidade e stiff (80%+ acerto em quiz).",
                                "Qualidade de simulações: plots claros com oscilações identificadas.",
                                "Análise profunda: ligação explícita entre IVP instável e falha no tiro.",
                                "Criatividade em exemplos: uso de casos reais além dos fornecidos.",
                                "Recomendações práticas: viáveis e suportadas por evidências numéricas.",
                                "Clareza no relatório: estrutura lógica, sem erros conceituais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de circuitos RLC stiff com decaimento rápido.",
                                "Engenharia Química: Equações de reações em série com escalas rígidas.",
                                "Computação Científica: Otimização em solvers de EDOs (SciPy, PETSc).",
                                "Matemática Aplicada: Análise de autovalores em estabilidade de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais, BVPs stiff modelam trajetórias de reentrada atmosférica; tiro simples falha por oscilações devido a viscosidade alta, exigindo multiple shooting ou métodos implícitos para precisão em controle de naves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Comparar com métodos de tiro múltiplo",
                            "description": "Entender limitações do tiro simples (precisão global baixa) versus tiro múltiplo (dividir [a,b] em subintervalos para melhor estabilidade).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar limitações do método de tiro simples",
                                  "subSteps": [
                                    "Relembrar a formulação do método de tiro simples para problemas de valor de contorno (BVP).",
                                    "Analisar a sensibilidade inicial: como pequenas variações no valor inicial afetam a solução final.",
                                    "Identificar problemas de precisão global baixa devido à propagação de erros em intervalos grandes.",
                                    "Estudar exemplos onde o método diverge ou oscila devido à instabilidade.",
                                    "Discutir o custo computacional para ajustes iterativos do parâmetro inicial."
                                  ],
                                  "verification": "Resumir em um parágrafo as três principais limitações e fornecer um exemplo numérico simples onde o erro é alto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre método de tiro simples",
                                    "Software como MATLAB ou Python (SciPy) para simulações",
                                    "Artigo ou livro de análise numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Comece com um BVP linear simples para visualizar os erros; use gráficos de solução vs. exata.",
                                  "learningObjective": "Compreender as razões matemáticas e numéricas pelas quais o tiro simples falha em precisão e estabilidade.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Ignorar o impacto do comprimento do intervalo [a,b]",
                                    "Não testar com diferentes passos de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o método de tiro múltiplo",
                                  "subSteps": [
                                    "Explicar a divisão do intervalo [a,b] em N subintervalos menores.",
                                    "Descrever a aplicação sequencial do tiro simples em cada subintervalo, ajustando condições de contorno contínuas.",
                                    "Detalhar o processo iterativo para matching de soluções nos pontos de junção.",
                                    "Comparar formalmente a redução do erro de propagação devido a reinicializações locais.",
                                    "Implementar pseudocódigo para o algoritmo de tiro múltiplo."
                                  ],
                                  "verification": "Escrever pseudocódigo funcional para tiro múltiplo em 2 subintervalos e testar em um BVP conhecido.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Pseudocódigo template",
                                    "Python ou MATLAB com solvers ODE (ode45/odeint)",
                                    "Exemplos de BVP de livros texto"
                                  ],
                                  "tips": "Escolha N=2 inicialmente para simplicidade; foque na continuidade de u e u' nos nós.",
                                  "learningObjective": "Dominar o conceito e implementação básica do tiro múltiplo como extensão do tiro simples.",
                                  "commonMistakes": [
                                    "Esquecer continuidade em derivadas",
                                    "Escolher subintervalos desiguais sem justificativa",
                                    "Confundir iterações locais com globais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar aspectos chave: precisão, estabilidade e custo",
                                  "subSteps": [
                                    "Tabelar métricas: erro global no tiro simples vs. múltiplo para mesmo BVP.",
                                    "Analisar estabilidade: impacto do número de subintervalos na convergência.",
                                    "Avaliar custo computacional: número de avaliações de ODE por iteração.",
                                    "Discutir ordens de convergência teóricas (ex: quadrática no simples vs. melhor no múltiplo).",
                                    "Gráficos comparativos de erros vs. tolerância ou N."
                                  ],
                                  "verification": "Criar uma tabela comparativa com pelo menos 3 BVPs, mostrando erros e tempos de CPU.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilhas Excel ou Jupyter Notebook",
                                    "Códigos de ambos métodos prontos",
                                    "Gráficos de erro (log-log)"
                                  ],
                                  "tips": "Use normas L2 ou máximo para erros; normalize custos por precisão alcançada.",
                                  "learningObjective": "Identificar quantitativamente as vantagens do tiro múltiplo sobre o simples.",
                                  "commonMistakes": [
                                    "Comparar sem normalizar tolerâncias",
                                    "Ignorar overhead de múltiplas integrações",
                                    "Usar BVPs não representativos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e validar a comparação numericamente",
                                  "subSteps": [
                                    "Implementar ambos métodos em software para um BVP não linear.",
                                    "Executar simulações variando comprimento do intervalo e N.",
                                    "Analisar resultados: gráficos de soluções, erros e convergência.",
                                    "Testar sensibilidade a ruído inicial ou passos de h.",
                                    "Concluir com recomendações de uso baseado nos resultados."
                                  ],
                                  "verification": "Gerar relatório com gráficos e tabela final comprovando superioridade do múltiplo em estabilidade.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código Python/MATLAB completo",
                                    "BVP exemplo: -u'' + u^2 = 0, u(0)=0, u(1)=1",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Automatize loops para variar N; valide com solução exata quando possível.",
                                  "learningObjective": "Aplicar a comparação em prática e interpretar resultados numéricos.",
                                  "commonMistakes": [
                                    "Bugs em matching de condições",
                                    "Escala errada em gráficos",
                                    "Concluir sem múltiplos testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o BVP -u'' + 10u = 0 em [0,10] com u(0)=0, u(10)=1. No tiro simples, erro global >10^-2 devido a instabilidade. No tiro múltiplo com N=5, erro <10^-6, com matching suave nos nós x=2,4,6,8.",
                              "finalVerifications": [
                                "Explicar verbalmente por que o tiro simples tem precisão global baixa em intervalos longos.",
                                "Demonstrar com código a redução de erro ao aumentar N no tiro múltiplo.",
                                "Identificar cenários onde tiro simples é preferível (intervalos curtos).",
                                "Comparar custos computacionais em tabela para precisão alvo de 10^-5.",
                                "Analisar gráfico de convergência mostrando superioridade do múltiplo.",
                                "Propor melhoria híbrida dos métodos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de limitações do tiro simples (80% cobertura).",
                                "Correção conceitual do algoritmo de tiro múltiplo.",
                                "Qualidade quantitativa da comparação (erros <5% discrepância com referências).",
                                "Profundidade de análise numérica com gráficos e tabelas.",
                                "Clareza em conclusões e recomendações práticas.",
                                "Uso adequado de terminologia numérica (estabilidade, convergência)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação de solvers ODE em Python/MATLAB.",
                                "Física Computacional: BVPs em equações de onda/difusão.",
                                "Engenharia Mecânica: Modelagem de vigas e perfis de tensão.",
                                "Estatística Computacional: Análise de erros e Monte Carlo para validação."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, simular perfis de temperatura em foguetes longos (intervalos grandes), onde tiro múltiplo garante estabilidade para otimização de trajetórias sem oscilações numéricas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Método de Tiro Múltiplo",
                    "description": "Variante do método de tiro que divide o intervalo em subdomínios para maior estabilidade e precisão.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Limitações do Método de Tiro Simples",
                        "description": "Compreender as restrições do método de tiro simples em problemas de valor de contorno (BVP), como instabilidade numérica e perda de precisão em intervalos grandes, motivando a necessidade do método de tiro múltiplo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Identificar instabilidade no método de tiro simples",
                            "description": "Analisar como a propagação de erros em integrações de valor inicial (IVP) ao longo de intervalos extensos leva a instabilidade, especialmente em equações diferenciais lineares e não lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos do Método de Tiro Simples",
                                  "subSteps": [
                                    "Estude a transformação de um problema de valor de contorno (BVP) em um problema de valor inicial (IVP) ajustando um parâmetro inicial.",
                                    "Implemente o método de tiro simples para um BVP linear simples, como y'' + y = 0 com y(0) = 0 e y(π) = 0.",
                                    "Execute iterações de bisseção ou Newton para encontrar o parâmetro inicial que satisfaça a condição final.",
                                    "Registre os valores de y ao longo do intervalo e compare com a solução exata.",
                                    "Analise o comportamento numérico em intervalos curtos versus intervalos iniciais longos."
                                  ],
                                  "verification": "Confirme que o método converge corretamente para intervalos curtos comparando com solução analítica (erro < 1e-6).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Python/MATLAB com bibliotecas scipy.integrate",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Comece com métodos de integração precisos como Runge-Kutta de ordem 4 para isolar o efeito do tiro.",
                                  "learningObjective": "Compreender a estrutura básica do método de tiro simples e sua dependência em solvers de IVP.",
                                  "commonMistakes": [
                                    "Confundir condições de contorno com iniciais.",
                                    "Usar passos de integração muito grandes inicialmente.",
                                    "Ignorar a sensibilidade ao método numérico de IVP."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Propagação de Erros em Soluções de IVPs",
                                  "subSteps": [
                                    "Revise conceitos de erro local e global em métodos de Runge-Kutta e multistep.",
                                    "Simule a propagação de erros truncamento e arredondamento em uma IVP linear estável e instável.",
                                    "Use análise de erros para equações como y' = λy, onde |λ| > 1 leva a amplificação exponencial.",
                                    "Plote o crescimento do erro ao longo do intervalo [0, T] para T pequeno e T grande.",
                                    "Quantifique o erro usando normas L2 e observe o fator de amplificação."
                                  ],
                                  "verification": "Gere gráficos mostrando erro crescendo exponencialmente para T > 5 (fator > 10x).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python com odeint ou solve_ivp",
                                    "Documentação SciPy",
                                    "Papel e lápis para análise teórica"
                                  ],
                                  "tips": "Normalize erros iniciais pequenos (1e-10) para destacar propagação.",
                                  "learningObjective": "Identificar como erros locais se propagam globalmente em IVPs ao longo de intervalos extensos.",
                                  "commonMistakes": [
                                    "Confundir erro de truncamento com arredondamento.",
                                    "Não escalar adequadamente equações rígidas.",
                                    "Ignorar o raio espectral do método numérico."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Instabilidade em Equações Diferenciais Lineares",
                                  "subSteps": [
                                    "Considere BVPs lineares com soluções oscilatórias, como y'' + k² y = 0 em [0, L] com L grande.",
                                    "Aplique o método de tiro simples e observe sensibilidade ao parâmetro inicial.",
                                    "Derive condicionalmente a matriz fundamental e analise seus autovalores para estabilidade.",
                                    "Simule numericamente mostrando divergência para L > 10π devido a modos instáveis.",
                                    "Compare com método de tiro múltiplo ou diferenças finitas para validar."
                                  ],
                                  "verification": "Demonstre que pequenas perturbações no chute inicial levam a soluções finais erradas por > 100%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB para análise de autovalores",
                                    "Python com NumPy/SciPy",
                                    "Referências teóricas sobre estabilidade de IVP"
                                  ],
                                  "tips": "Use decomposição em modos estável/instável para insight teórico.",
                                  "learningObjective": "Reconhecer instabilidade propagada em sistemas lineares com autovalores positivos.",
                                  "commonMistakes": [
                                    "Aplicar tiro para frente em problemas naturalmente para trás.",
                                    "Não verificar rigidez da equação.",
                                    "Subestimar o impacto de L grande."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Diagnosticar Instabilidade em Casos Não-Lineares",
                                  "subSteps": [
                                    "Estenda para BVPs não-lineares, como y'' = f(y, y') com f não-linear.",
                                    "Implemente tiro simples e monitore resíduos finais ao variar o intervalo.",
                                    "Use linearização local para prever bifurcações ou sensibilidade.",
                                    "Diagnostique instabilidade plotando trajetórias sensíveis e histérese.",
                                    "Teste remédios como tiro múltiplo ou integração adaptativa e compare."
                                  ],
                                  "verification": "Identifique corretamente 3 exemplos onde instabilidade ocorre (gráficos de divergência).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Códigos de passos anteriores",
                                    "Exemplos de BVPs não-lineares (ex: Van der Pol)",
                                    "Software de plotagem avançada"
                                  ],
                                  "tips": "Monitore o Jacobiano numérico para detectar rigidez crescente.",
                                  "learningObjective": "Diagnosticar instabilidade específica do método de tiro simples em contextos lineares e não-lineares.",
                                  "commonMistakes": [
                                    "Assumir linearidade em casos não-lineares.",
                                    "Não usar tolerâncias adaptativas.",
                                    "Ignorar não-unicidade de soluções."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o BVP y'' + 100 y = 0, y(0)=0, y(20)=1 usando método de tiro simples com Runge-Kutta4. Para intervalo [0,20], observe que erros iniciais de 1e-8 crescem para >1 devido a oscilações de alta frequência, causando falha na convergência após poucas iterações.",
                              "finalVerifications": [
                                "Explicar verbalmente como propagação de erros causa instabilidade em intervalos >10 unidades.",
                                "Implementar código que detecta e plota divergência em um BVP linear longo.",
                                "Identificar autovalores instáveis em uma matriz fundamental de exemplo.",
                                "Comparar resultados de tiro simples vs. método alternativo em caso não-linear.",
                                "Diagnosticar corretamente instabilidade em um novo BVP fornecido.",
                                "Propor pelo menos duas estratégias para mitigar instabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação teórica da propagação de erros (80%+ acerto).",
                                "Qualidade dos gráficos e simulações numéricas (erros quantificados <1e-4).",
                                "Capacidade de diagnosticar instabilidade em exemplos inéditos.",
                                "Profundidade na análise linear vs. não-linear.",
                                "Criatividade em conexões com aplicações reais.",
                                "Clareza na documentação de códigos e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de estabilidade em osciladores harmônicos e trajetórias balísticas.",
                                "Computação: Otimização numérica e análise de sensibilidade em solvers ODE.",
                                "Engenharia: Modelagem de sistemas de controle com feedback não-linear.",
                                "Estatística: Propagação de incertezas em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais de reentrada atmosférica, onde intervalos de tempo longos amplificam erros no método de tiro simples para equações de movimento orbital, levando à necessidade de métodos múltiplos para precisão em missões como as da NASA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Avaliar impacto da estabilidade em problemas stiff",
                            "description": "Explicar o papel de problemas stiff no método de tiro simples, onde rigidez causa discrepâncias entre passos explícitos e implícitos, reduzindo a precisão global.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e características de problemas stiff",
                                  "subSteps": [
                                    "Defina problemas stiff como sistemas de EDOs com escalas de tempo muito díspares (eigenvalues com partes reais muito negativas e próximas de zero).",
                                    "Identifique indicadores de rigidez: razão entre o maior e menor |Re(λ)| > 1000.",
                                    "Classifique exemplos clássicos, como y' = -1000(y - cos(t)) + sin(t).",
                                    "Explique por que métodos explícitos falham (passo h < 1/|λ_max| para estabilidade).",
                                    "Compare com problemas não-stiff via gráfico de solução exata."
                                  ],
                                  "verification": "Resuma em 3 frases o que torna um problema stiff e dê um exemplo numérico.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de análise numérica (ex: Burden & Faires)",
                                    "Notebook Jupyter com Python/NumPy",
                                    "Gráficos de eigenvalues"
                                  ],
                                  "tips": "Use o teste de Dahlquist para validar rigidez em equações lineares.",
                                  "learningObjective": "Identificar e caracterizar problemas stiff em EDOs.",
                                  "commonMistakes": [
                                    "Confundir rigidez com não-linearidade",
                                    "Ignorar a razão de eigenvalues",
                                    "Usar passos grandes sem testar estabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar o método de tiro simples e seus componentes explícitos/implícitos",
                                  "subSteps": [
                                    "Descreva o método de tiro simples: chute inicial y'(a), integre IVP até b, ajuste via secante/newton para matching y(b).",
                                    "Identifique passos explícitos (ex: Euler explícito ou RK4) usados na integração do IVP.",
                                    "Explique passos implícitos alternativos (ex: trapezoidal implícito) e sua relação com estabilidade A-stável.",
                                    "Implemente pseudocódigo para método de tiro simples com RK4 explícito.",
                                    "Teste em BVP não-stiff: u'' + u = 0, u(0)=0, u(π)=0."
                                  ],
                                  "verification": "Implemente e rode o método em um BVP simples, confirmando convergência.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Código Python (SciPy odeint ou solve_ivp)",
                                    "Papel para pseudocódigo",
                                    "Exemplos de código online"
                                  ],
                                  "tips": "Comece com método de secante para simplicidade (não requer derivadas).",
                                  "learningObjective": "Dominar a estrutura do método de tiro simples e identificar componentes sensíveis à rigidez.",
                                  "commonMistakes": [
                                    "Confundir método de tiro com shooting múltiplo",
                                    "Usar solver implícito sem justificar",
                                    "Ignorar normalização de chute inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar discrepâncias causadas por rigidez no método de tiro simples",
                                  "subSteps": [
                                    "Escolha BVP stiff: u'' = -1000(u - x), u(0)=0, u(1)=0.",
                                    "Integre com passos explícitos pequenos (h=0.001) vs grandes (h=0.1), observe oscilações/instabilidade.",
                                    "Compare soluções explícita vs implícita: note que implícita mantém estabilidade.",
                                    "Meça erro global: ||u_num - u_exata||_∞ após múltiplas iterações de tiro.",
                                    "Gere gráficos de solução vs h, destacando redução de precisão em stiff."
                                  ],
                                  "verification": "Produza gráfico mostrando divergência para h > 1/1000.",
                                  "estimatedTime": "75 min",
                                  "materials": [
                                    "Python/MATLAB com solvers odeint (explícito) e solve_bvp",
                                    "Solução exata analítica",
                                    "Ferramentas de plot (Matplotlib)"
                                  ],
                                  "tips": "Use stiff solvers como 'Radau' no SciPy para baseline implícito.",
                                  "learningObjective": "Quantificar como rigidez causa instabilidade explícita e erro no matching de contorno.",
                                  "commonMistakes": [
                                    "Não escalar o problema (divida por coeficiente grande)",
                                    "Ignorar custo computacional de h pequeno",
                                    "Comparar sem solução exata"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar impacto na precisão global e propor mitigações",
                                  "subSteps": [
                                    "Calcule ordem de convergência: log(error)/log(h) para método de tiro em stiff vs não-stiff.",
                                    "Avalie número de iterações de tiro necessárias devido a IVPs instáveis.",
                                    "Discuta impacto: precisão global cai de O(h^4) para O(h) ou pior em stiff.",
                                    "Teste mitigações: h adaptativo, switch para implícito, ou método de tiro múltiplo.",
                                    "Documente tabela: h, iterações, erro para casos stiff/não-stiff."
                                  ],
                                  "verification": "Tabela mostrando degradação de precisão em stiff.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela",
                                    "Código estendido do step 3"
                                  ],
                                  "tips": "Monitore norma residual do matching para parar iterações.",
                                  "learningObjective": "Avaliar quantitativamente o impacto da estabilidade na precisão global do método.",
                                  "commonMistakes": [
                                    "Atribuir erro só ao tiro, ignorando solver IVP",
                                    "Não testar faixa ampla de h",
                                    "Esquecer normalização de erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o BVP stiff: u'' + 1000u' + 1000000u = 0, u(0)=1, u(1)=0 (modelo de difusão rápida). Usando método de tiro simples com RK4 explícito (h=0.01), observe oscilações selvagens e não-convergência após 20 iterações (erro >1e-3). Com h=0.0001, converge mas custa 100x mais tempo. Implícito (BDF) converge em 5 iterações com h=0.1.",
                              "finalVerifications": [
                                "Explique em palavras próprias por que explícito falha em stiff.",
                                "Gere gráfico de solução instável vs estável.",
                                "Calcule razão de estabilidade requerida (1/|λ_max|).",
                                "Compare tempos de CPU para h explícito vs implícito.",
                                "Identifique quando usar tiro múltiplo como alternativa.",
                                "Resuma limitações do tiro simples em 1 parágrafo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de stiff (razão eigenvalues >1000).",
                                "Correta identificação de discrepâncias explícito/implícito.",
                                "Gráficos e tabelas quantitativos mostrando impacto.",
                                "Análise de ordem de convergência degradada.",
                                "Propostas válidas de mitigações com justificativa.",
                                "Clareza na explicação do impacto global na precisão."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de reações químicas rápidas/lentas (rigidez em cinética).",
                                "Engenharia: Circuitos RLC com parasitas (stiff em simulações elétricas).",
                                "Computação: Algoritmos adaptativos em solvers ODE (SciPy, MATLAB ode*).",
                                "Matemática Aplicada: Análise de estabilidade de Runge-Kutta.",
                                "Biologia: Modelos populacionais com predador-presa stiff."
                              ],
                              "realWorldApplication": "Em simulações de engenharia aeroespacial, problemas stiff surgem em equações de controle de voo com atrito viscoso alto; método de tiro simples falha, exigindo solvers implícitos para precisão em tempo real, evitando erros catastróficos em trajetórias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Comparar precisão com métodos de passo múltiplo para IVP",
                            "description": "Discutir como métodos de passo simples versus múltiplo em IVPs afetam a solução de BVPs, destacando controle de passo adaptativo para maior estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar métodos de passo simples e múltiplo para IVPs",
                                  "subSteps": [
                                    "Defina IVP e explique métodos de passo simples (ex: Euler, Runge-Kutta de ordem baixa).",
                                    "Descreva métodos de passo múltiplo (ex: Runge-Kutta de ordem 4 ou superior).",
                                    "Compare truncagem local e global de erro entre eles.",
                                    "Discuta impacto na propagação de erros em soluções de longo prazo.",
                                    "Estude fórmulas de erro para ambos os métodos."
                                  ],
                                  "verification": "Resuma diferenças em um quadro comparativo com fórmulas de erro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica, calculadora, papel e lápis",
                                  "tips": "Use diagramas de fluxo para visualizar passos de integração.",
                                  "learningObjective": "Compreender diferenças fundamentais em precisão entre métodos de passo simples e múltiplo.",
                                  "commonMistakes": "Confundir truncagem local com global; ignorar dependência no tamanho do passo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender aplicação no método de tiro para BVPs",
                                  "subSteps": [
                                    "Explique método de tiro simples: chute inicial, integração como IVP até o final.",
                                    "Descreva método de tiro múltiplo: dividir o intervalo em subintervalos e combinar soluções.",
                                    "Analise como precisão do IVP afeta matching das condições de contorno no BVP.",
                                    "Compare sensibilidade a erros iniciais em ambos os métodos de tiro.",
                                    "Discuta estabilidade em problemas rígidos."
                                  ],
                                  "verification": "Esboce fluxogramas para tiro simples vs múltiplo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software Python/MATLAB com solvers ODE (scipy.integrate.odeint)",
                                  "tips": "Comece com problemas lineares para intuíção antes de não-lineares.",
                                  "learningObjective": "Relacionar precisão de IVPs com eficácia na solução de BVPs via método de tiro.",
                                  "commonMistakes": "Não considerar efeitos cumulativos de erros em tiros múltiplos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar precisão e estabilidade quantitativamente",
                                  "subSteps": [
                                    "Selecione um BVP de teste (ex: y'' + y = 0, y(0)=0, y(π)=0).",
                                    "Implemente tiro simples e múltiplo com passos fixos.",
                                    "Calcule erros de solução numérica vs analítica para diferentes h.",
                                    "Plote gráficos de erro vs h para ambos.",
                                    "Avalie estabilidade observando divergência em passos grandes."
                                  ],
                                  "verification": "Gere tabelas e gráficos mostrando erros relativos menores no múltiplo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy, Matplotlib; ou MATLAB",
                                  "tips": "Use norma L2 para medir erro global.",
                                  "learningObjective": "Quantificar superioridade em precisão do método múltiplo.",
                                  "commonMistakes": "Escolha inadequada de h inicial levando a instabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar controle de passo adaptativo para estabilidade",
                                  "subSteps": [
                                    "Explique controle adaptativo: ajuste h baseado em estimativa de erro local.",
                                    "Implemente solver adaptativo (ex: RK45) no tiro simples e múltiplo.",
                                    "Compare tempo de computação e precisão final com passos fixos.",
                                    "Analise como adaptatividade mitiga instabilidades em BVPs rígidos.",
                                    "Discuta trade-offs: precisão vs custo computacional."
                                  ],
                                  "verification": "Demonstre redução de erro em simulações com output de h adaptado.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Bibliotecas scipy.integrate.solve_ivp ou ode45 no MATLAB",
                                  "tips": "Monitore tolernância de erro (ex: 1e-6) para consistência.",
                                  "learningObjective": "Destacar papel do controle adaptativo na melhoria de estabilidade.",
                                  "commonMistakes": "Definir tolerâncias muito frouxas, resultando em precisão baixa."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar comparação e discutir limitações",
                                  "subSteps": [
                                    "Compile resultados: precisão (ordem, erro), estabilidade, custo.",
                                    "Discuta cenários onde simples é suficiente vs necessidade de múltiplo/adaptativo.",
                                    "Analise limitações: não-linearidades fortes, rigidez.",
                                    "Proponha melhorias híbridas.",
                                    "Escreva relatório comparativo."
                                  ],
                                  "verification": "Crie um resumo escrito com tabelas e conclusões.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Documento Word/Google Docs, gráficos gerados",
                                  "tips": "Use métricas normalizadas para comparações justas.",
                                  "learningObjective": "Sintetizar insights para aplicação crítica.",
                                  "commonMistakes": "Generalizar excessivamente sem considerar classes de problemas."
                                }
                              ],
                              "practicalExample": "Para o BVP y'' = -y com y(0)=0, y(π)=1: Use tiro simples com RK2 (passo simples) vs RK4 (múltiplo) em [0,π]. Com h=0.1 fixo, erro L2 no simples ~0.05, no múltiplo ~0.001. Com adaptativo (RK45), erro cai para 1e-6 em ambos, mas simples requer mais rechutes.",
                              "finalVerifications": [
                                "Capacidade de gerar tabelas comparativas de erro vs h.",
                                "Gráficos de solução numérica vs exata coincidentes dentro de tolerância.",
                                "Explicação verbal correta de por que múltiplo é mais preciso.",
                                "Implementação funcional de solver adaptativo sem crashes.",
                                "Identificação de instabilidade em passos grandes no simples.",
                                "Relatório síntese com conclusões quantitativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de erros locais/globais (80%+ acerto em quiz).",
                                "Qualidade de implementações numéricas (erro <1e-4).",
                                "Profundidade na análise de estabilidade (cita exemplos rígidos).",
                                "Clareza em relatórios e gráficos (rubrica visual 4/5).",
                                "Compreensão de adaptatividade (explica ajuste h corretamente).",
                                "Criatividade em extensões (propõe híbridos viáveis)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB reforça computação científica.",
                                "Física: Aplicação em equações de onda/elastidade modeladas por BVPs.",
                                "Engenharia: Otimização em controle de sistemas dinâmicos.",
                                "Estatística: Análise de erro numérico como incerteza em simulações."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, simular perfis de temperatura em painéis (BVPs rígidos) usa tiro múltiplo adaptativo para precisão em projetos de reentrada, evitando instabilidades que poderiam prever falhas estruturais erradas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Divisão do Intervalo em Subdomínios",
                        "description": "Aprender a dividir o intervalo de integração do BVP em subdomínios menores para melhorar estabilidade e precisão no método de tiro múltiplo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Definir subdomínios no intervalo [a,b]",
                            "description": "Escolher pontos de divisão equidistantes ou adaptativos no intervalo [a,b] para decompor o BVP em uma sequência de IVPs menores, minimizando erros de propagação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto do BVP e a necessidade de divisão em subdomínios",
                                  "subSteps": [
                                    "Estude a definição de Problema de Valor de Contorno (BVP) e compare com Problema de Valor Inicial (IVP).",
                                    "Analise as limitações do Método de Tiro Simples, focando na sensibilidade inicial que causa propagação de erros.",
                                    "Explique como o Método de Tiro Múltiplo decompõe o BVP em IVPs sequenciais usando subdomínios.",
                                    "Identifique fatores que influenciam a propagação de erros, como comprimento do intervalo e não-linearidades.",
                                    "Discuta critérios iniciais para escolher o número de subdomínios (N), baseado em tolerância de erro desejada."
                                  ],
                                  "verification": "Resuma em 3-5 frases por que dividir [a,b] minimiza erros e dê um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), notas de aula, calculadora.",
                                  "tips": "Desenhe um diagrama do intervalo [a,b] dividido para visualizar a decomposição.",
                                  "learningObjective": "Entender a motivação teórica para divisão de intervalos no Método de Tiro Múltiplo.",
                                  "commonMistakes": "Confundir BVP com IVP; ignorar que mais subdomínios aumentam custo computacional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar estratégia de divisão: equidistante ou adaptativa",
                                  "subSteps": [
                                    "Defina divisão equidistante: pontos x_i = a + i*h, h=(b-a)/N, para i=0 a N.",
                                    "Descreva divisão adaptativa: ajustar h_i baseado em estimativas locais de erro ou rigidez da EDO.",
                                    "Compare prós e contras: equidistante é simples e estável; adaptativa é eficiente para problemas não-uniformes.",
                                    "Estime N inicial: N ≈ sqrt((b-a)/tol), onde tol é tolerância de erro.",
                                    "Decida baseado no problema: use equidistante para lineares suaves; adaptativa para oscilatórios."
                                  ],
                                  "verification": "Justifique a escolha de estratégia para um BVP dado, com fórmula de h.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis para esboços, software como Python/MATLAB para testes rápidos.",
                                  "tips": "Comece sempre com equidistante para baseline antes de adaptar.",
                                  "learningObjective": "Discernir quando usar cada tipo de divisão para otimizar precisão vs custo.",
                                  "commonMistakes": "Escolher N muito pequeno (erro alto) ou muito grande (ineficiente); ignorar não-linearidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e definir os pontos de divisão no intervalo [a,b]",
                                  "subSteps": [
                                    "Escolha N (número de subdomínios) baseado na análise anterior.",
                                    "Para equidistante: compute h = (b-a)/N e liste x_0 = a, x_1 = a+h, ..., x_N = b.",
                                    "Para adaptativa: use critérios como erro a posteriori de uma marcha inicial para ajustar h_i.",
                                    "Registre os pontos em uma tabela: i, x_i, h_i (se adaptativo).",
                                    "Valide que soma dos h_i = b-a e pontos são monotonicamente crescentes."
                                  ],
                                  "verification": "Liste os pontos para [0,1] com N=4 equidistante e verifique soma de intervalos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora ou Python (numpy.linspace para equidistante), planilha Excel.",
                                  "tips": "Use numpy.linspace(a, b, N+1) em Python para automação rápida.",
                                  "learningObjective": "Executar cálculo preciso de pontos de subdomínios para decomposição.",
                                  "commonMistakes": "Erro aritmético em h; pontos não cobrindo exatamente [a,b]; N par/impar inadequado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e refinar a divisão para minimizar propagação de erros",
                                  "subSteps": [
                                    "Simule propagação de erro: resolva IVPs sequenciais e meça desvio no próximo tiro.",
                                    "Compute norma de erro global: ||y_exato - y_num|| em pontos de malha.",
                                    "Ajuste N ou tipo de divisão se erro > tol (aumente N ou refine adaptativo).",
                                    "Analise estabilidade: verifique se condições de contorno intermediárias são satisfeitas.",
                                    "Documente trade-off: erro vs número de IVPs resolvidos."
                                  ],
                                  "verification": "Execute simulação simples e mostre redução de erro com N=2 vs N=4.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software numérico (SciPy solve_bvp ou ODEINT), exemplo de BVP pronto.",
                                  "tips": "Monitore erro relativo em cada subdomínio para guiar refinamento.",
                                  "learningObjective": "Avaliar efetividade da divisão na minimização de erros acumulados.",
                                  "commonMistakes": "Não verificar condições de contorno nos pontos internos; superestimar convergência."
                                }
                              ],
                              "practicalExample": "Para o BVP -y'' + y = 0 em [0,1] com y(0)=0, y(1)=1. Use divisão equidistante com N=3: h=0.333, pontos x=[0, 0.333, 0.667, 1]. Resolva IVP em [0,0.333] com y'(0.333) estimado, atire para satisfazer y(0.333)=condição intermediária, e propague.",
                              "finalVerifications": [
                                "Lista corretamente pontos de divisão para N=5 em [0,π].",
                                "Justifica escolha entre equidistante e adaptativa para um BVP oscilatório.",
                                "Simula erro de propagação e mostra redução com mais subdomínios.",
                                "Verifica que condições de contorno internas são impostas corretamente.",
                                "Estima N ótimo para tol=1e-6 em intervalo de comprimento 2.",
                                "Documenta tabela de h_i para divisão adaptativa simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de pontos (erro <1e-10 em soma h_i).",
                                "Justificativa teórica clara para escolha de estratégia.",
                                "Demonstração numérica de redução de erro de propagação.",
                                "Uso adequado de N, balanceando precisão e eficiência.",
                                "Identificação correta de erros comuns e mitigação.",
                                "Clareza na documentação de passos e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de EDOs em mecânica (ex: cordas vibrantes).",
                                "Computação: Implementação em solvers numéricos (SciPy, MATLAB).",
                                "Engenharia: Simulações de fluxo em tubos com BVPs.",
                                "Estatística: Análise de erro e otimização adaptativa."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, divide-se o domínio de um perfil aerodinâmico em subdomínios para simular escoamentos compressíveis, minimizando erros numéricos em CFD (Computational Fluid Dynamics) e permitindo simulações precisas de aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Estabelecer condições de interface entre subdomínios",
                            "description": "Garantir continuidade da solução e derivadas nas interfaces dos subdomínios, transformando o problema em um sistema de condições de contorno multi-point.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar subdomínios e pontos de interface",
                                  "subSteps": [
                                    "Divida o intervalo total [a, b] em N subdomínios [a_i, a_{i+1}] para i=1 a N, onde a_1 = a e a_{N+1} = b.",
                                    "Defina os pontos de interface x_i = a_{i+1} para i=1 a N-1.",
                                    "Especifique as condições de contorno originais em x=a e x=b.",
                                    "Liste as condições iniciais necessárias para cada subdomínio (solução y e derivada y' em x_i).",
                                    "Crie uma tabela resumindo subdomínios, pontos de interface e condições globais."
                                  ],
                                  "verification": "Confirme que os subdomínios cobrem [a,b] sem sobreposição e que pontos de interface estão corretamente identificados em um diagrama ou tabela.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis ou software de diagramação (ex: Draw.io)",
                                    "Descrição do problema de valor de contorno (BVP)"
                                  ],
                                  "tips": "Escolha número de subdomínios baseado na não-linearidade ou rigidez do problema; comece com N=2 para simplicidade.",
                                  "learningObjective": "Compreender a divisão espacial do domínio para aplicação do método de tiro múltiplo.",
                                  "commonMistakes": [
                                    "Sobrepor subdomínios",
                                    "Ignorar condições de contorno globais ao definir interfaces"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir condições de continuidade nas interfaces",
                                  "subSteps": [
                                    "Para cada interface x_i, imponha continuidade da solução: y_i(x_i) = y_{i+1}(x_i).",
                                    "Imponha continuidade da derivada: y_i'(x_i) = y_{i+1}'(x_i).",
                                    "Se aplicável, inclua condições de derivadas de ordem superior para equações de ordem >2.",
                                    "Expresse essas condições em termos das condições iniciais de cada subdomínio: y_i(a_i), y_i'(a_i).",
                                    "Anote todas as equações de interface como um conjunto de restrições."
                                  ],
                                  "verification": "Verifique se o número de condições de interface é 2*(N-1) para um problema de 2ª ordem (continuidade de y e y').",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (ex: Mathematica ou SymPy)",
                                    "Notas do Step 1"
                                  ],
                                  "tips": "Use notação consistente: denote condições iniciais como vetor S_i = [y_i(a_i), y_i'(a_i)]^T.",
                                  "learningObjective": "Formular condições de interface que garantem uma solução global suave.",
                                  "commonMistakes": [
                                    "Confundir continuidade de y com y'",
                                    "Esquecer derivadas para EDOs de ordem superior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o sistema global de condições multi-pointo",
                                  "subSteps": [
                                    "Combine condições de contorno originais: φ_a(S_1) = 0 e φ_b(S_N) = 0.",
                                    "Inclua todas as condições de interface: C_i(S_i, S_{i+1}) = 0 para i=1 a N-1.",
                                    "Monte o sistema não-linear F(S) = 0, onde S = [S_1, S_2, ..., S_N] é o vetor de condições iniciais globais.",
                                    "Verifique dimensionalidade: para EDO de ordem 2 em N subdomínios, dim(F) = 2N.",
                                    "Escreva o sistema em forma matricial ou explícita."
                                  ],
                                  "verification": "Confirme que o sistema F tem tantas equações quanto incógnitas (2N para ordem 2).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de álgebra computacional (ex: MATLAB, Python com NumPy/SciPy)",
                                    "Equações da EDO original"
                                  ],
                                  "tips": "Linearize o sistema se possível para inspeção inicial; use Jacobiano para resolução numérica posterior.",
                                  "learningObjective": "Transformar o BVP em um sistema de condições de contorno multi-pointo resolvível por métodos de tiro.",
                                  "commonMistakes": [
                                    "Erro na contagem de equações",
                                    "Não incluir condições de contorno nas extremidades"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e preparar para resolução numérica",
                                  "subSteps": [
                                    "Teste consistência: resolva um caso trivial (ex: solução conhecida) e verifique se interfaces são satisfeitas.",
                                    "Implemente uma função para avaliar F(S) numericamente.",
                                    "Planeje método de solução (ex: Newton-Raphson com Jacobiano).",
                                    "Defina tolerâncias para convergência nas interfaces.",
                                    "Documente o sistema completo para implementação."
                                  ],
                                  "verification": "Simule com valores iniciais e confirme que F(S*) ≈ 0 para solução conhecida.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ambiente de programação (Python/MATLAB)",
                                    "Exemplo de teste simples"
                                  ],
                                  "tips": "Comece com malha grossa (poucos subdomínios) para depuração rápida.",
                                  "learningObjective": "Garantir que as condições de interface suportem resolução numérica estável.",
                                  "commonMistakes": [
                                    "Ignorar rigidez levando a instabilidade",
                                    "Tolerâncias muito frouxas nas verificações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver y'' + y = 0 em [0, π] com y(0)=0, y(π)=0 usando 2 subdomínios [0, π/2] e [π/2, π]: Defina S1=[y1(0), y1'(0)], S2=[y2(π/2), y2'(π/2)]; condições: y1(0)=0, y2(π)=0, y1(π/2)=y2(π/2), y1'(π/2)=y2'(π/2). Solução: S1=[0,1], S2=[0, -1], y(x)=sin(x).",
                              "finalVerifications": [
                                "Solução y é contínua em todos os pontos de interface x_i.",
                                "Derivada y' é contínua em todos os x_i.",
                                "Condições de contorno globais y(a) e y(b) são satisfeitas.",
                                "Número de condições de interface equals 2*(N-1) para EDO de 2ª ordem.",
                                "Sistema F(S)=0 tem solução única e convergente numericamente.",
                                "Erro residual nas interfaces < 1e-6."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação das condições de continuidade (y e y').",
                                "Correta dimensionalidade do sistema multi-pointo.",
                                "Consistência com condições de contorno originais.",
                                "Capacidade de validar com exemplo numérico simples.",
                                "Clareza na documentação do sistema F(S).",
                                "Identificação de potenciais issues numéricos (ex: ill-conditioning)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de propagação de ondas ou difusão com interfaces materiais.",
                                "Computação: Implementação de solvers não-lineares (Newton, Broyden).",
                                "Engenharia: Análise de estruturas com juntas ou domínios compostos.",
                                "Estatística: Otimização multi-ponto em problemas de mínimos quadrados."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, modelar fluxo em asas com diferentes perfis aerodinâmicos, garantindo continuidade de velocidade e pressão nas interfaces para simulações CFD precisas e estáveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Implementação e Ajuste no Método de Tiro Múltiplo",
                        "description": "Implementar numericamente o método de tiro múltiplo, ajustando parâmetros iniciais em cada subdomínio para satisfazer todas as condições de contorno.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Resolver IVPs sequencialmente em subdomínios",
                            "description": "Usar solvers numéricos (ex: Runge-Kutta ou métodos para stiff) para integrar IVPs em cada subdomínio, passando condições iniciais ajustadas das interfaces anteriores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o subdomínio atual e obter condições iniciais ajustadas",
                                  "subSteps": [
                                    "Identifique os limites do subdomínio atual (x_i a x_{i+1}) baseado na divisão do domínio total.",
                                    "Recupere as condições iniciais na interface anterior (x_i), incluindo y(x_i) e y'(x_i), ajustadas pelo método de tiro anterior.",
                                    "Verifique se as condições iniciais satisfazem a equação diferencial no ponto de interface.",
                                    "Documente os parâmetros do problema BVP original para consistência.",
                                    "Ajuste tolerâncias numéricas iniciais com base no erro acumulado anterior."
                                  ],
                                  "verification": "Condições iniciais y(x_i) e y'(x_i) estão corretamente extraídas e validadas contra a solução anterior.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código fonte do método de tiro anterior, software numérico (Python com SciPy ou MATLAB), notas do problema BVP.",
                                  "tips": "Sempre armazene soluções de interfaces em variáveis persistentes para evitar recálculos.",
                                  "learningObjective": "Compreender como propagar condições de interface em métodos de domínio múltiplo.",
                                  "commonMistakes": "Usar condições não ajustadas da iteração anterior, levando a inconsistências."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e configurar o solver numérico apropriado",
                                  "subSteps": [
                                    "Avalie se o problema é stiff ou não; escolha Runge-Kutta clássico (RK4) para não-stiff ou métodos implícitos (ex: BDF) para stiff.",
                                    "Defina parâmetros do solver: tolerância absoluta/relativa (1e-6 a 1e-8), passo inicial h=0.01.",
                                    "Configure o sistema de EDOs como first-order: y' = f(x,y), derivando se necessário de EDO de ordem superior.",
                                    "Teste o solver em um intervalo pequeno para validar configuração.",
                                    "Integre eventos de parada no x_{i+1} para precisão na interface."
                                  ],
                                  "verification": "Solver roda sem erros em teste curto e produz saída suave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Biblioteca SciPy (solve_ivp), documentação de solvers ODE, exemplos de EDOs stiff/não-stiff.",
                                  "tips": "Para stiff, prefira 'method=LSODA' no SciPy para switching automático.",
                                  "learningObjective": "Selecionar solvers numéricos adequados baseado nas propriedades do problema.",
                                  "commonMistakes": "Escolher RK explícito para problemas stiff, causando instabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar o IVP numericamente no subdomínio",
                                  "subSteps": [
                                    "Execute o solver do x_i ao x_{i+1} com condições iniciais definidas.",
                                    "Monitore saídas intermediárias para detectar divergências ou oscilações.",
                                    "Extraia valores finais y(x_{i+1}) e y'(x_{i+1}) na interface próxima.",
                                    "Calcule norma do erro local se solução analítica parcial disponível.",
                                    "Salve a solução completa do subdomínio para visualização posterior."
                                  ],
                                  "verification": "Integração completa sem falhas, com y e y' finitos na saída.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software numérico configurado, plotador (Matplotlib ou similar).",
                                  "tips": "Use dense_output=True para interpolação precisa na interface.",
                                  "learningObjective": "Executar integração numérica precisa em intervalos limitados.",
                                  "commonMistakes": "Passos de malha muito grandes, perdendo precisão nas interfaces."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar saída e preparar para subdomínio seguinte",
                                  "subSteps": [
                                    "Compare solução com condições de contorno globais se aplicável.",
                                    "Calcule resíduo na interface: diferença entre y e y' contínuos esperados.",
                                    "Ajuste condições iniciais se resíduo > tolerância, iterando localmente.",
                                    "Visualize solução no subdomínio e acople com anterior.",
                                    "Registre métricas: tempo de CPU, número de passos, erro estimado."
                                  ],
                                  "verification": "Resíduo na interface < 1e-5 e solução visualmente suave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas de plotagem e análise de erro.",
                                  "tips": "Plote todos subdomínios juntos para detectar discontinuidades.",
                                  "learningObjective": "Garantir continuidade e precisão através de interfaces múltiplas.",
                                  "commonMistakes": "Ignorar resíduos, propagando erros para subdomínios subsequentes."
                                }
                              ],
                              "practicalExample": "Para o BVP -u'' + u = x em [0,1] com u(0)=0, u(1)=0, divida em dois subdomínios [0,0.5] e [0.5,1]. No primeiro, resolva IVP com chute u(0)=0, u'(0)=a (ajustado por tiro). Use RK45 para integrar até x=0.5, obtendo u(0.5) e u'(0.5) para o segundo subdomínio.",
                              "finalVerifications": [
                                "Solução é C1 contínua nas interfaces (u e u' coincidem).",
                                "Erro global em condições de contorno < 1e-4.",
                                "Integração converge independentemente do solver escolhido.",
                                "Tempo total de computação é razoável (< 1s por subdomínio).",
                                "Visualização mostra solução suave sem oscilações artificiais.",
                                "Resíduos locais em cada interface são mínimos."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro nas interfaces < 1e-5.",
                                "Eficiência: Número de avaliações de f(x,y) otimizado.",
                                "Robustez: Funciona para problemas stiff e não-stiff.",
                                "Documentação: Código comentado com parâmetros e saídas.",
                                "Análise: Relatório de erros e resíduos incluído.",
                                "Generalidade: Adaptável a diferentes divisões de subdomínios."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB reforça computação científica.",
                                "Física: Aplicável a equações de onda ou difusão em domínios compostos.",
                                "Engenharia: Modelagem de estruturas com interfaces (ex: composites).",
                                "Estatística: Análise de erros numéricos e convergência."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, resolve EDOs para fluxo em asas com camadas de malha diferentes, passando condições de interface para simulações CFD precisas e eficientes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Ajustar parâmetros de tiro via método de Newton",
                            "description": "Formular o problema como um sistema não linear para os parâmetros de tiro iniciais em subdomínios, resolvendo-o iterativamente com o método de Newton-Raphson para matching das condições finais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o problema de valor de contorno como sistema não linear",
                                  "subSteps": [
                                    "Identifique o problema de valor de contorno (PVC) e divida o intervalo em subdomínios para o método de tiro múltiplo.",
                                    "Defina os parâmetros de tiro iniciais s = [s1, s2, ..., sn] para cada subdomínio, correspondendo às condições iniciais ajustáveis.",
                                    "Especifique as condições de contorno finais desejadas e as condições de continuidade nas interfaces dos subdomínios.",
                                    "Formule o vetor resíduo F(s) = condições finais computadas - condições desejadas = 0.",
                                    "Verifique a dimensionalidade: F(s) deve ter o mesmo número de equações que parâmetros s."
                                  ],
                                  "verification": "Confirme que F(s) é um sistema não linear com n equações e n incógnitas, escrito explicitamente em código ou papel.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação do problema PVC",
                                    "Papel e lápis ou editor de código (Python/MATLAB)"
                                  ],
                                  "tips": "Comece com um número pequeno de subdomínios (ex: 2) para testar a formulação.",
                                  "learningObjective": "Entender como transformar um PVC em um sistema não linear para iteração numérica.",
                                  "commonMistakes": [
                                    "Confundir condições iniciais com finais",
                                    "Esquecer continuidade nas junções de subdomínios",
                                    "Dimensionalidade incompatível de F(s)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o resolvedor de problema de valor inicial (PVI) para condições de tiro dadas",
                                  "subSteps": [
                                    "Implemente um integrador numérico (ex: Runge-Kutta 4 ou odeint no SciPy) para resolver o PVI em cada subdomínio dado s.",
                                    "Defina a função que, para um s dado, integra sequencialmente por todos os subdomínios, aplicando continuidade nas interfaces.",
                                    "Extraia as condições finais computadas no último subdomínio.",
                                    "Teste a função com valores iniciais arbitrários de s e visualize a solução.",
                                    "Otimize o integrador para precisão (tolerância 1e-6)."
                                  ],
                                  "verification": "Execute a função PVI com s aleatório e confirme que retorna solução suave sem erros de integração.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca SciPy/ODEPACK (Python)",
                                    "Exemplo de EDO do PVC",
                                    "Gráficos (Matplotlib)"
                                  ],
                                  "tips": "Use eventos de parada no integrador para precisão nas interfaces de subdomínios.",
                                  "learningObjective": "Dominar a resolução de PVIs sequenciais para simular tiros múltiplos.",
                                  "commonMistakes": [
                                    "Não aplicar continuidade corretamente nas junções",
                                    "Escolha inadequada de passo de integração levando a instabilidade",
                                    "Ignorar singularidades na EDO"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e implementar a função resíduo F(s)",
                                  "subSteps": [
                                    "Codifique F(s) = phi(s) - condições desejadas, onde phi(s) são as condições finais do PVI.",
                                    "Inclua resíduos para todas as condições de contorno e continuidade interna.",
                                    "Teste F(s) com valores conhecidos: para s correto, ||F(s)|| deve ser próximo de zero.",
                                    "Implemente uma norma ||F(s)|| para monitorar convergência.",
                                    "Adicione logging para depuração de valores de F."
                                  ],
                                  "verification": "Calcule F(s_inicial) e confirme que não é zero, indicando necessidade de iteração.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código do resolvedor PVI",
                                    "Editor de código"
                                  ],
                                  "tips": "Use vetores NumPy para eficiência vetorial em F(s).",
                                  "learningObjective": "Construir o mapa não linear que o Newton-Raphson minimizará.",
                                  "commonMistakes": [
                                    "Erro de sinal nos resíduos",
                                    "Índices errados nas condições de continuidade",
                                    "Não normalizar condições de diferentes escalas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a matriz Jacobiana J(s)",
                                  "subSteps": [
                                    "Defina J_{ij} = dF_i / ds_j, derivadas parciais numéricas ou analíticas.",
                                    "Implemente diferenciação finita central: J ≈ [F(s + h e_j) - F(s - h e_j)] / (2h).",
                                    "Para Jacobiana analítica, derive explicitamente as sensibilidades via variação linearizada do PVI.",
                                    "Teste J multiplicando por vetor direção: ||J v - (F(s+hv)-F(s))/h|| pequeno.",
                                    "Escolha h ≈ 1e-6 * ||s|| para precisão.",
                                    "verification]: "
                                  ],
                                  "verification": "Verifique a Jacobiana com teste de consistência numérica (||J v - ΔF / Δs|| < 1e-8).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código de F(s)",
                                    "NumPy para matrizes"
                                  ],
                                  "tips": "Prefira analítica se possível; numérica é mais simples para protótipos.",
                                  "learningObjective": "Compreender o papel da Jacobiana na convergência quadrática de Newton.",
                                  "commonMistakes": [
                                    "h muito pequeno causando erro de arredondamento",
                                    "Não aproximar corretamente derivadas mistas em múltiplos tiros",
                                    "Jacobiana singular por formulação ruim"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar iteração Newton-Raphson e verificar convergência",
                                  "subSteps": [
                                    "Inicie com s0 (ex: chute linear das condições de contorno).",
                                    "Itere: resolver J Δs = -F(s), s ← s + Δs até ||F(s)|| < tol ou max_iter.",
                                    "Use solver linear (ex: np.linalg.solve) para J Δs = b.",
                                    "Monitore ||Δs||, ||F|| e plote convergência.",
                                    "Implemente safeguards: line search se necessário, limite passos."
                                  ],
                                  "verification": "Execute até convergência e confirme ||F(s_final)|| < 1e-10 e solução satisfaz PVC.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Códigos anteriores",
                                    "Solver linear NumPy"
                                  ],
                                  "tips": "Defina tol=1e-12, max_iter=20; plote para debug.",
                                  "learningObjective": "Aplicar Newton-Raphson para otimização não linear em PVCs.",
                                  "commonMistakes": [
                                    "Chute inicial ruim causando divergência",
                                    "Não checar se J é invertível",
                                    "Parar cedo sem verificar precisão final"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o PVC y'' + y = 0 em [0,2], y(0)=0, y(2)=0, y'(1)=1 (continuidade em subdomínio [0,1] e [1,2]). Ajuste s1=y'(0), s2=y'(1)+ no segundo tiro via Newton para matching y(2)=0 e continuidade y(1-)=y(1+).",
                              "finalVerifications": [
                                "||F(s_final)|| < 1e-10",
                                "Solução y(x) satisfaz todas condições de contorno dentro de 1e-8",
                                "Convergência em menos de 10 iterações",
                                "Jacobiana final não singular (condição < 1e12)",
                                "Gráfico da solução suave sem discontinuidades",
                                "Teste com perturbação: re-roda e confirma estabilidade"
                              ],
                              "assessmentCriteria": [
                                "Correta formulação de F(s) e J(s) (80% peso)",
                                "Convergência robusta para exemplo dado (15%)",
                                "Código limpo, comentado e eficiente (5%)",
                                "Tratamento de casos não convergentes",
                                "Análise de sensibilidade a chutes iniciais",
                                "Documentação de erros comuns evitados"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de trajetórias balísticas ou osciladores",
                                "Programação: Otimização numérica e solvers lineares",
                                "Engenharia: Controle de sistemas e simulações dinâmicas",
                                "Estatística: Análise de sensibilidade e propagação de erros"
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial para otimizar trajetórias de mísseis ajustando parâmetros iniciais; em bioengenharia para modelar difusão em tecidos com condições de contorno complexas; em finanças para precificação de derivativos resolvendo PDEs de Black-Scholes via métodos numéricos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Avaliar precisão e estabilidade da solução",
                            "description": "Verificar convergência, erro global e estabilidade comparando com soluções exatas ou refinando malha de subdomínios, considerando controle de passo adaptativo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar refinamento progressivo da malha de subdomínios",
                                  "subSteps": [
                                    "Divida o intervalo do problema de valor de contorno em N subdomínios iniciais.",
                                    "Implemente o método de tiro múltiplo para cada malha com N=10, 20, 40, etc.",
                                    "Registre os valores de y e y' nos pontos de interface para cada refinamento.",
                                    "Salve os dados em uma tabela ou arquivo para análise posterior.",
                                    "Automatize o processo com um loop em código para variar N."
                                  ],
                                  "verification": "Verificar se soluções foram computadas para pelo menos 4 níveis de refinamento sem erros de execução.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código fonte do método de tiro múltiplo",
                                    "Software de programação (Python/MATLAB)",
                                    "Solução exata do BVP teste (se disponível)"
                                  ],
                                  "tips": "Comece com malhas grosseiras para testes rápidos antes de refinar.",
                                  "learningObjective": "Entender como o refinamento de malha afeta a precisão numérica.",
                                  "commonMistakes": [
                                    "Não sincronizar os pontos de interface entre subdomínios",
                                    "Ignorar condições de continuidade em y e y'",
                                    "Usar passos fixos muito grandes inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular erros globais e analisar convergência",
                                  "subSteps": [
                                    "Compute o erro global como máximo de |y_num - y_exata| em pontos da malha.",
                                    "Calcule a norma L2 do erro para uma métrica mais robusta.",
                                    "Estime a ordem de convergência usando log(erro_{n}/erro_{n+1}) / log(2).",
                                    "Plote gráficos de erro vs. tamanho da malha (h) em escala log-log.",
                                    "Identifique se a convergência é linear, quadrática ou outra."
                                  ],
                                  "verification": "Gráfico de convergência mostra declínio monotônico do erro com refinamento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dados das malhas refinadas",
                                    "Bibliotecas de plotagem (Matplotlib/Octave)",
                                    "Fórmula da solução exata"
                                  ],
                                  "tips": "Use malha uniforme inicialmente para simplificar o cálculo de h.",
                                  "learningObjective": "Dominar métricas de erro e análise de convergência numérica.",
                                  "commonMistakes": [
                                    "Confundir erro local com global",
                                    "Não linearizar corretamente para ordem de convergência",
                                    "Usar solução aproximada como 'exata'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar estabilidade da solução numérica",
                                  "subSteps": [
                                    "Introduza perturbações pequenas (1e-6) nos valores iniciais de tiro.",
                                    "Reexecute o método e compare soluções perturbadas com a original.",
                                    "Calcule a sensibilidade como ||y_pert - y|| / ||pert||.",
                                    "Teste estabilidade em diferentes subdomínios variando o número de tiros.",
                                    "Analise se o erro amplifica com o refinamento."
                                  ],
                                  "verification": "Solução permanece estável com perturbações <1% de variação relativa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código com função de perturbação",
                                    "Ferramentas de análise numérica"
                                  ],
                                  "tips": "Perturbe aleatoriamente para testes mais realistas.",
                                  "learningObjective": "Compreender conceitos de estabilidade numérica em métodos iterativos.",
                                  "commonMistakes": [
                                    "Perturbações muito grandes que mascaram instabilidade",
                                    "Não normalizar a medida de sensibilidade",
                                    "Ignorar efeitos em subdomínios boundary"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar controle adaptativo de passo",
                                  "subSteps": [
                                    "Desenvolva um algoritmo que ajuste h baseado no erro estimado local.",
                                    "Use estimadores de erro a posteriori (ex: diferença entre soluções consecutivas).",
                                    "Integre o controle no método de tiro múltiplo para malhas adaptativas.",
                                    "Compare precisão e custo computacional com malha uniforme.",
                                    "Ajuste tolerâncias para erro global desejado (ex: 1e-6)."
                                  ],
                                  "verification": "Solução adaptativa atinge precisão alvo com menos subdomínios que uniforme.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código base do método",
                                    "Documentação de métodos adaptativos"
                                  ],
                                  "tips": "Comece com tolerância relaxada para depuração.",
                                  "learningObjective": "Aplicar técnicas adaptativas para otimizar precisão e eficiência.",
                                  "commonMistakes": [
                                    "Estimador de erro superestimado levando a refinamentos excessivos",
                                    "Não reconvergir tiros após adaptação",
                                    "Ignorar overhead computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar resultados e documentar avaliação",
                                  "subSteps": [
                                    "Compile tabelas de erros, ordens de convergência e medidas de estabilidade.",
                                    "Gere relatório com gráficos e conclusões sobre precisão/estabilidade.",
                                    "Recomende configurações ótimas de malha/passo para o problema.",
                                    "Teste em um BVP diferente para generalização.",
                                    "Salve código e resultados para reprodutibilidade."
                                  ],
                                  "verification": "Relatório completo com evidências quantitativas de precisão e estabilidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de LaTeX/Markdown para relatório",
                                    "Dados consolidados"
                                  ],
                                  "tips": "Use templates para relatórios padronizados.",
                                  "learningObjective": "Sintetizar análises numéricas em recomendações práticas.",
                                  "commonMistakes": [
                                    "Omite gráficos essenciais",
                                    "Conclusões sem suporte quantitativo",
                                    "Não testar generalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o BVP y'' + y = 0 com y(0)=0, y(π)=0, use método de tiro múltiplo com 4 subdomínios. Refine de h=π/40 para h=π/320, compare com y_exata=sin(x), verifique convergência O(h^2) e estabilidade com perturbação 1e-8, implementando adaptação para erro <1e-6.",
                              "finalVerifications": [
                                "Erro global < 1e-6 após refinamento adequado.",
                                "Ordem de convergência observada próxima à teórica.",
                                "Solução estável sob perturbações pequenas.",
                                "Controle adaptativo reduz número de subdomínios em 30%.",
                                "Gráficos confirmam tendências de convergência.",
                                "Relatório documenta todos os testes."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de refinamento e cálculo de erros (30%).",
                                "Análise precisa de convergência e estabilidade (25%).",
                                "Eficácia do controle adaptativo demonstrada (20%).",
                                "Qualidade dos gráficos e relatórios (15%).",
                                "Identificação de erros comuns evitados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Modelagem de equações diferenciais em mecânica.",
                                "Estatística: Análise de erros e estimação de incertezas.",
                                "Engenharia Computacional: Otimização de malhas adaptativas."
                              ],
                              "realWorldApplication": "Em simulações de engenharia aeroespacial para perfis de temperatura em foguetes, ou modelagem de circuitos elétricos, onde precisão e estabilidade garantem predições confiáveis sem custo computacional excessivo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.4",
                            "name": "Implementar em código computacional",
                            "description": "Codificar o método de tiro múltiplo em Python ou MATLAB, integrando bibliotecas como SciPy para IVPs e otimizadores para ajuste de parâmetros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema BVP e preparar funções auxiliares",
                                  "subSteps": [
                                    "Escreva as equações diferenciais do problema de valor de contorno (BVP) em forma de sistema de EDOs de primeira ordem.",
                                    "Defina as condições de contorno iniciais e finais explicitamente como funções.",
                                    "Crie a função que representa o erro residual nas condições de contorno para múltiplos tiros.",
                                    "Importe bibliotecas necessárias: numpy, scipy.integrate, scipy.optimize.",
                                    "Teste as funções auxiliares com valores de exemplo."
                                  ],
                                  "verification": "Execute as funções e verifique se os resíduos são calculados corretamente sem erros de sintaxe.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python 3.x, NumPy, SciPy (instalados via pip)",
                                  "tips": "Use def para funções claras e docstrings para documentar parâmetros.",
                                  "learningObjective": "Entender e codificar a estrutura matemática do BVP para método de tiro múltiplo.",
                                  "commonMistakes": "Esquecer de converter EDO de segunda ordem para sistema de primeira ordem; índices errados em arrays de condições de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o integrador forward para um tiro único",
                                  "subSteps": [
                                    "Defina a função rhs( t, y ) para o lado direito do sistema de EDOs.",
                                    "Use solve_ivp do SciPy para integrar de a para b com condições iniciais guess.",
                                    "Extraia os valores finais y(b) da solução integrada.",
                                    "Retorne y(b) para cálculo de resíduos.",
                                    "Adicione tratamento de eventos se necessário para convergência."
                                  ],
                                  "verification": "Integre um problema conhecido analítico e compare y(b) com solução exata (erro < 1e-6).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "SciPy.integrate.solve_ivp, Jupyter Notebook para visualização",
                                  "tips": "Use método='RK45' para precisão inicial; plote soluções para debug visual.",
                                  "learningObjective": "Dominar a integração numérica de IVPs como base para o método de tiro.",
                                  "commonMistakes": "Parâmetros iniciais incorretos em solve_ivp; não lidar com singularidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar o otimizador para ajuste de parâmetros iniciais múltiplos",
                                  "subSteps": [
                                    "Defina a função de custo que chama o integrador múltiplas vezes e soma resíduos quadrados.",
                                    "Inicialize guesses para parâmetros iniciais extras (alvos de tiro).",
                                    "Use scipy.optimize.minimize com método='SLSQP' ou 'trust-constr' para otimização.",
                                    "Defina bounds e constraints se aplicável ao problema.",
                                    "Monitore convergência com callbacks opcionais."
                                  ],
                                  "verification": "Execute otimização em problema teste e verifique se resíduos finais são próximos de zero.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "SciPy.optimize, Matplotlib para plotar convergência",
                                  "tips": "Forneça boa guess inicial baseada em solução linearizada; use jac=True se derivadas analíticas disponíveis.",
                                  "learningObjective": "Integrar otimização não linear com solvers de IVP para resolver BVPs.",
                                  "commonMistakes": "Função de custo que não retorna escalar; escalas diferentes nos resíduos causando convergência lenta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, testar e validar a solução completa",
                                  "subSteps": [
                                    "Chame o otimizador principal e obtenha parâmetros otimizados.",
                                    "Re-integre com parâmetros finais para solução precisa.",
                                    "Calcule erros de resíduos e compare com solução analítica se disponível.",
                                    "Plote solução e resíduos vs. malha para análise.",
                                    "Teste sensibilidade variando parâmetros ou malha."
                                  ],
                                  "verification": "Resíduos < 1e-8, solução converge monotonicamente, plots mostram precisão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matplotlib, SciPy.stats para análise de erro",
                                  "tips": "Salve soluções em arquivos para reprodutibilidade; use vectorize para eficiência.",
                                  "learningObjective": "Validar implementação completa e interpretar resultados numéricos.",
                                  "commonMistakes": "Não verificar tolerâncias do solver; ignorar mensagens de falha na otimização."
                                }
                              ],
                              "practicalExample": "Implemente o método para resolver o BVP não linear y'' = -e^y com y(0)=0, y(1)=0 (problema de Bratu, lambda=0). Use 1 parâmetro extra inicial y'(0)=guess, otimize para minimizar y(1). Compare com solução exata aproximada y(x) ≈ 3.513*(sin(pi*x))^2.",
                              "finalVerifications": [
                                "Resíduos das condições de contorno são inferiores a 1e-10.",
                                "Solução converge em menos de 20 iterações do otimizador.",
                                "Plots da solução coincidem com referências analíticas (erro L2 < 1e-5).",
                                "Código executa sem warnings ou erros em diferentes seeds.",
                                "Tempo de execução < 5 segundos para precisão moderada.",
                                "Sensibilidade: variação de 10% em guess inicial ainda converge."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro nos resíduos e norma L2 da solução.",
                                "Eficiência: número de chamadas ao solver IVP e tempo total.",
                                "Robustez: convergência para diferentes problemas e guesses iniciais.",
                                "Clareza do código: modularidade, comentários e docstrings.",
                                "Validação: testes unitários e plots de verificação incluídos.",
                                "Extensibilidade: fácil adaptação para novos BVPs."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de otimização e integração numérica em Python.",
                                "Física: Modelagem de EDOs em mecânica (ex: pêndulo duplo) ou química reacional.",
                                "Engenharia: Simulações em controle de sistemas e aerodinâmica.",
                                "Estatística: Análise de sensibilidade e Monte Carlo para incertezas."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, resolve BVPs para trajetórias de foguetes considerando condições de lançamento e impacto; em finanças, otimiza curvas de yield bonds modeladas por EDOs; em biologia computacional, ajusta parâmetros em modelos de difusão celular."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Métodos de Diferenças Finitas para BVPs",
                    "description": "Discretização direta do problema de valor de contorno em sistemas lineares ou não lineares de equações algébricas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Discretização por Diferenças Finitas para BVPs Lineares",
                        "description": "Transformação direta de problemas de valor de contorno lineares de segunda ordem em sistemas lineares tridiagonais utilizando aproximações de diferenças finitas centrais ou de outros tipos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Definir a malha uniforme e condições de contorno",
                            "description": "Construir uma malha equidistante no intervalo [a,b] com N pontos internos, incorporar condições de Dirichlet ou Neumann nas extremidades e expressar o problema diferencial y'' + p(x)y' + q(x)y = g(x) em forma discreta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os parâmetros da malha uniforme",
                                  "subSteps": [
                                    "Selecione o intervalo de integração [a, b].",
                                    "Escolha o número de pontos internos N (tipicamente 10-100 para equilíbrio entre precisão e custo computacional).",
                                    "Calcule o espaçamento uniforme h = (b - a) / (N + 1).",
                                    "Gere os pontos da malha x_i = a + i * h para i = 0, 1, ..., N + 1.",
                                    "Verifique que x_0 = a e x_{N+1} = b."
                                  ],
                                  "verification": "Confirme que todos os pontos estão equidistantes com diferença h constante e cobrem exatamente [a, b].",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora ou software como Python/MATLAB para verificação"
                                  ],
                                  "tips": "Comece com N pequeno para testes e aumente gradualmente para refinar a aproximação.",
                                  "learningObjective": "Compreender a construção de uma grade uniforme para discretização espacial.",
                                  "commonMistakes": [
                                    "Confundir N pontos internos com N+2 pontos totais; usar h = (b-a)/N em vez de (b-a)/(N+1)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Incorporar condições de contorno Dirichlet ou Neumann",
                                  "subSteps": [
                                    "Identifique o tipo de condição de contorno: Dirichlet (valores de y) ou Neumann (valores de y').",
                                    "Para Dirichlet: defina y(x_0) = α e y(x_{N+1}) = β diretamente.",
                                    "Para Neumann em x=a: aproxime y'(a) ≈ (y_1 - y_0)/h = γ e resolva para y_0 ou introduza um ponto fantasma.",
                                    "Para Neumann em x=b: similarmente, (y_{N+1} - y_N)/h = δ.",
                                    "Ajuste as equações de borda conforme o tipo misto se aplicável."
                                  ],
                                  "verification": "Escreva as relações explícitas para y_0 e y_{N+1} em termos das variáveis internas y_1 a y_N.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Exemplos de problemas de valor de contorno"
                                  ],
                                  "tips": "Use pontos fantasmas para Neumann de segunda ordem: y_{-1} = y_1 - 2h γ para precisão.",
                                  "learningObjective": "Aplicar corretamente condições de contorno na discretização finita.",
                                  "commonMistakes": [
                                    "Esquecer de ajustar h na aproximação de primeira ordem para Neumann; confundir y' com y'' nas bordas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Discretizar os termos da equação diferencial",
                                  "subSteps": [
                                    "Aproximação para y''(x_i): (y_{i-1} - 2 y_i + y_{i+1}) / h² (diferença finita central de segunda ordem).",
                                    "Para y'(x_i): (y_{i+1} - y_{i-1}) / (2 h) (central de segunda ordem).",
                                    "Avalie p(x_i), q(x_i) e g(x_i) diretamente nos pontos da malha.",
                                    "Substitua na EDO y'' + p y' + q y = g para i = 1, ..., N, obtendo equações lineares.",
                                    "Reescreva como a_i y_{i-1} + b_i y_i + c_i y_{i+1} = d_i."
                                  ],
                                  "verification": "Verifique truncagem de erro O(h²) para aproximações centrais e consistência com a EDO contínua.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Livro de análise numérica",
                                    "Software para plotar funções p, q, g"
                                  ],
                                  "tips": "Multiplique toda a equação por h² para eliminar denominadores e facilitar a matriz.",
                                  "learningObjective": "Dominar as fórmulas de diferenças finitas para derivadas de primeira e segunda ordem.",
                                  "commonMistakes": [
                                    "Usar diferenças forward/backward sem justificativa, reduzindo precisão; erros de sinal em y' ou y''."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expressar o problema em forma discreta matricial",
                                  "subSteps": [
                                    "Colete as N equações para i=1 a N em um sistema A y = b, onde y = [y_1, ..., y_N]^T.",
                                    "Incorpore condições de contorno modificando as linhas 1 e N de A e b.",
                                    "Identifique a estrutura tridiagonal de A com diagonais a_i, b_i, c_i.",
                                    "Verifique simetria ou propriedades para Dirichlet homogêneo.",
                                    "Teste com um caso simples para validar o sistema."
                                  ],
                                  "verification": "Resolva o sistema para um exemplo conhecido e compare com solução exata.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "MATLAB/Python/Octave para montar e resolver A y = b",
                                    "Exemplo analítico"
                                  ],
                                  "tips": "Use solvers eficientes para tridiagonal (Thomas algorithm) em implementações.",
                                  "learningObjective": "Formar o sistema linear pronto para resolução numérica.",
                                  "commonMistakes": [
                                    "Não substituir corretamente as condições de contorno nas equações de borda; inverter índices da matriz."
                                  ]
                                }
                              ],
                              "practicalExample": "Para -y'' = 2π² sin(2πx) em [0,1] com y(0)=y(1)=0 (Dirichlet homogêneo), N=4: h=0.2, x_i=[0,0.2,0.4,0.6,0.8,1]. Discretização leva a sistema tridiagonal A y = b com b_i = h² * 2π² sin(2π x_i), resolvido para y_1 a y_4 aproximando a solução exata y=sin(2πx).",
                              "finalVerifications": [
                                "Calcula corretamente h e lista todos x_i para dado [a,b,N].",
                                "Especifica y_0, y_{N+1} para Dirichlet e Neumann simples.",
                                "Escreve a stencil de diferenças finitas para y'', y', y.",
                                "Monta sistema A y = b sem erros para exemplo com N=3.",
                                "Explica impacto de h pequeno na precisão.",
                                "Diferencia tratamento de BCs mistas."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da malha (erro < 1e-6 em h e x_i).",
                                "Correta formulação de condições de contorno (incluindo aproximações de ordem 2).",
                                "Equações discretas consistentes com EDO original (verificação por limite h→0).",
                                "Sistema matricial tridiagonal montado corretamente.",
                                "Análise de erros comuns evitados e justificativa de escolhas.",
                                "Tempo de execução e clareza na documentação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Discretização de equações de Poisson/Laplace em eletromagnetismo e mecânica dos fluidos.",
                                "Computação: Implementação de solvers numéricos em Python (NumPy/SciPy) ou C++.",
                                "Engenharia: Simulações de tensão em vigas ou difusão de calor em materiais.",
                                "Estatística: Modelos de regressão espacial com diferenças finitas."
                              ],
                              "realWorldApplication": "Essencial em simulações de engenharia como propagação de calor em reatores nucleares, fluxo de fluidos em tubulações ou modelagem de ondas sísmicas, onde problemas de valor de contorno lineares são resolvidos numericamente para otimizar designs e prever comportamentos físicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Implementar diferenças finitas centrais",
                            "description": "Derivar a aproximação de segunda ordem para y''(x_i) ≈ (y_{i-1} - 2y_i + y_{i+1})/h² e y'(x_i) ≈ (y_{i+1} - y_{i-1})/(2h), resultando em um sistema Ax = b tridiagonal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar a aproximação de diferenças finitas centrais para a segunda derivada y''(x_i)",
                                  "subSteps": [
                                    "Realize a expansão de Taylor para y(x_i + h) e y(x_i - h) até termos de ordem h².",
                                    "Some as expansões e isole o termo de segunda derivada, cancelando termos pares.",
                                    "Divida por h² para obter y''(x_i) ≈ [y(x_i - h) - 2y(x_i) + y(x_i + h)] / h².",
                                    "Verifique o erro de truncamento: deve ser O(h²) para precisão de segunda ordem.",
                                    "Escreva a fórmula explicitamente com notação de índices: y''_i ≈ (y_{i-1} - 2y_i + y_{i+1}) / h²."
                                  ],
                                  "verification": "Escreva a derivação completa em papel e confirme que o erro de truncamento é O(h²).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para verificações numéricas",
                                    "Referência: Livro de análise numérica (ex: Burden & Faires)"
                                  ],
                                  "tips": "Lembre-se de que termos ímpares se cancelam na soma das expansões simétricas.",
                                  "learningObjective": "Compreender a base teórica da aproximação central de segunda ordem para derivadas segundas.",
                                  "commonMistakes": [
                                    "Esquecer o fator -2 em y_i",
                                    "Não cancelar corretamente os termos de primeira ordem",
                                    "Confundir o passo h com 2h"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a aproximação de diferenças finitas centrais para a primeira derivada y'(x_i)",
                                  "subSteps": [
                                    "Realize expansões de Taylor para y(x_i + h) e y(x_i - h) até ordem h².",
                                    "Subtraia as expansões para isolar o termo de primeira derivada.",
                                    "Divida por 2h para obter y'(x_i) ≈ [y(x_i + h) - y(x_i - h)] / (2h).",
                                    "Confirme o erro de truncamento O(h²).",
                                    "Escreva com índices: y'_i ≈ (y_{i+1} - y_{i-1}) / (2h)."
                                  ],
                                  "verification": "Derive a fórmula e teste numericamente com y(x) = sin(x) em x=0.5, h=0.1, comparando com derivada exata.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software como Python ou MATLAB para teste numérico opcional"
                                  ],
                                  "tips": "A subtração destaca termos ímpares; divida por 2h para centralizar.",
                                  "learningObjective": "Dominar a derivação da diferença central simétrica para derivadas primeiras com precisão O(h²).",
                                  "commonMistakes": [
                                    "Usar h em vez de 2h no denominador",
                                    "Inverter y_{i+1} e y_{i-1}",
                                    "Ignorar termos de h³ que cancelam"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Discretizar uma BVP linear de segunda ordem usando diferenças centrais",
                                  "subSteps": [
                                    "Considere uma BVP geral: -y''(x) + p(x)y'(x) + q(x)y(x) = f(x), com y(a)=α, y(b)=β.",
                                    "Defina grade uniforme x_i = a + i h, i=0 a N+1, h=(b-a)/(N+1).",
                                    "Aplique diferenças centrais no ponto interior i=1 a N: substitua y''_i e y'_i pelas fórmulas derivadas.",
                                    "Incorpore p(x_i), q(x_i) e f(x_i) para formar a equação discreta em y_i.",
                                    "Aplique condições de contorno: y_0 = α, y_{N+1} = β."
                                  ],
                                  "verification": "Escreva a equação discreta para um caso simples e verifique dimensionalidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Exemplo de BVP de referência"
                                  ],
                                  "tips": "Mantenha simetria para preservar propriedades como auto-adjointness.",
                                  "learningObjective": "Aplicar diferenças centrais para transformar BVP contínua em sistema discreto.",
                                  "commonMistakes": [
                                    "Aplicar diferenças nos pontos de contorno",
                                    "Esquecer multiplicar p_i pela aproximação de y'",
                                    "Erro nos índices de vizinhança"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e representar o sistema tridiagonal Ax = b",
                                  "subSteps": [
                                    "Reescreva as equações discretas para i=1 a N na forma a_i y_{i-1} + b_i y_i + c_i y_{i+1} = d_i.",
                                    "Identifique coeficientes: para -y'' + ... , a_i ≈ 1/h² - p_i/(2h), etc.",
                                    "Incorpore contornos em d_1 e d_N: d_1 += a_1 α, d_N -= c_N β.",
                                    "Monte a matriz A (N x N tridiagonal) e vetor b.",
                                    "Verifique que A é tridiagonal e simétrica para casos sem primeira derivada."
                                  ],
                                  "verification": "Construa A e b para N=4, h=0.2 em [0,1], e confirme estrutura tridiagonal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel ou planilha para matriz",
                                    "Python/Octave para montar e visualizar A"
                                  ],
                                  "tips": "Use notação padrão tridiagonal para eficiência em solvers.",
                                  "learningObjective": "Formar o sistema linear Ax=b pronto para resolução numérica.",
                                  "commonMistakes": [
                                    "Índices errados nos contornos",
                                    "Sinais incorretos em a_i/c_i para termos de convecção",
                                    "Não normalizar por h²"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva a BVP -y''(x) = 2π² sin(πx) em [0,1] com y(0)=y(1)=0 (solução exata y=sin(πx)). Use N=9 (h=0.1), derive diferenças centrais, monte A tridiagonal (diagonal 2/h², sub/sup -1/h²) e b_i = 2π² sin(π x_i), resolva Ax=b e compare com exata (erro <1e-3).",
                              "finalVerifications": [
                                "Derivação correta de y''_i e y'_i com erro O(h²).",
                                "Equação discreta para BVP linear sem erros de índices.",
                                "Matriz A tridiagonal com coeficientes corretos (ex: para Laplace, diag=2/h², off=-1/h²).",
                                "Incorporação precisa das condições de Dirichlet em b.",
                                "Teste numérico: solução converge à exata ao refinar h.",
                                "Identificação de sistema como sparse tridiagonal."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Taylor (100% dos termos corretos).",
                                "Correção da discretização (equações livres de erros algébricos).",
                                "Estrutura tridiagonal de A validada (não-banded = falha).",
                                "Tratamento correto de contornos (d_1 e d_N ajustados).",
                                "Análise de erro: reconhecimento de O(h²) e teste prático.",
                                "Clareza na representação de A e b (pronta para código)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python com NumPy/SciPy (sparse matrices, solve tridiagonal).",
                                "Física: Modelagem de equações de Poisson/Laplace em eletromagnetismo e mecânica dos fluidos.",
                                "Engenharia: Simulações CFD/FEM para perfis de temperatura e fluxo.",
                                "Computação Científica: Pré-condicionadores e solvers iterativos para sistemas grandes.",
                                "Matemática Aplicada: Análise de estabilidade e consistência de esquemas numéricos."
                              ],
                              "realWorldApplication": "Essas diferenças centrais são fundamentais em simulações numéricas de equações diferenciais elípticas/parabólicas, como propagação de calor em engenharia térmica, modelagem de potenciais eletrostáticos em física computacional, precificação de opções em finanças (equação Black-Scholes) e simulações climáticas/oceânicas em ciências ambientais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Analisar truncagem e consistência",
                            "description": "Calcular o erro de truncagem local O(h²) para esquemas centrais e verificar consistência do método com o problema contínuo à medida que h → 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o esquema de diferenças finitas central para BVPs lineares",
                                  "subSteps": [
                                    "Relembre o problema modelo: -u''(x) = f(x) para x em [a,b], com u(a)=α, u(b)=β.",
                                    "Discuta a discretização em grade uniforme com passo h = (b-a)/N.",
                                    "Escreva o esquema central: δ²u_i / h² ≈ -f(x_i), onde δ²u_i = u_{i+1} - 2u_i + u_{i-1}.",
                                    "Identifique pontos internos i=1 a N-1 e condições de contorno u_0=α, u_N=β.",
                                    "Verifique a forma matricial do sistema Au = f."
                                  ],
                                  "verification": "Escreva corretamente o esquema de diferenças finitas e o sistema linear resultante.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, tabela de diferenças finitas, software como Python ou MATLAB para visualização da grade.",
                                  "tips": "Desenhe a grade uniformemente para visualizar os pontos i=0 a N.",
                                  "learningObjective": "Compreender a base discreta do problema contínuo antes da análise de erro.",
                                  "commonMistakes": "Confundir diferenças forward/backward com central; esquecer de aplicar condições de contorno nos extremos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a expansão de Taylor para o operador de diferenças centrais",
                                  "subSteps": [
                                    "Aplique expansão de Taylor para u(x_i + h) e u(x_i - h) em torno de x_i.",
                                    "Some as expansões: u(x_i + h) + u(x_i - h) = 2u(x_i) + (h²/3)u^{(4)}(ξ) + O(h^4) para algum ξ.",
                                    "Derive δ²u_i / h² = u''(x_i) + (h²/12)u^{(4)}(ξ_i) + O(h^4).",
                                    "Substitua no esquema: δ²u_i / h² + f(x_i) = (h²/12)u^{(4)}(ξ_i) + O(h^4).",
                                    "Identifique o erro de truncagem local τ_i = O(h²)."
                                  ],
                                  "verification": "Mostre que δ²u_i / h² - u''(x_i) = O(h²) com coeficiente explícito h²/12.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de derivadas de Taylor, calculadora simbólica (SymPy ou papel).",
                                  "tips": "Mantenha termos até O(h^4) para ver o cancelamento de termos pares ímpares.",
                                  "learningObjective": "Dominar a análise de Taylor para quantificar erro local em diferenças finitas.",
                                  "commonMistakes": "Erros nos sinais das expansões de Taylor; parar em O(h) em vez de O(h²); confundir ξ_i com x_i."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular explicitamente o erro de truncagem local O(h²)",
                                  "subSteps": [
                                    "Para o esquema completo, escreva τ_i(h) = [δ²u_i / h² + f(x_i)] = O(h²).",
                                    "Estime |τ_i(h)| ≤ C h², onde C depende de ||u^{(4)}||.",
                                    "Discuta como assumir suavidade de u (u ∈ C^4) garante isso.",
                                    "Numéricamente, refine h e observe ||τ|| / h² aproximando constante.",
                                    "Confirme ordem 2 para esquemas centrais vs. ordem 1 para forward/backward."
                                  ],
                                  "verification": "Calcule τ_i para uma solução exata conhecida e mostre ||τ||_∞ = O(h²).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python/MATLAB para computar τ_i em grade refinada, exemplo analítico como u(x)=sin(x).",
                                  "tips": "Use solução exata u(x)=x^4 para u^{(4)}=constante e erro exato.",
                                  "learningObjective": "Quantificar e comprovar a ordem de truncagem local.",
                                  "commonMistakes": "Não normalizar por h² ao plotar; assumir ordem sem derivadas altas; ignorar dependência em N."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar consistência do método à medida que h → 0",
                                  "subSteps": [
                                    "Defina consistência: max_i |τ_i(h)| → 0 quando h → 0.",
                                    "Mostre que O(h²) implica consistência para esquemas de ordem ≥1.",
                                    "Argumente que para h→0 (N→∞), a solução discreta u^h → u contínua em norma adequada.",
                                    "Discuta teorema de Lax: consistência + estabilidade ⇒ convergência.",
                                    "Teste numericamente: refine h até ||u^h - u|| < ε."
                                  ],
                                  "verification": "Prove lim_{h→0} max|τ_i|=0 e demonstre com gráfico log-log de erro vs. h.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código Python para refinar h e plotar erros, teorema de Lax resumido.",
                                  "tips": "Use norma máximo para simplicidade; refine h por fatores de 2.",
                                  "learningObjective": "Entender consistência como pré-requisito para convergência numérica.",
                                  "commonMistakes": "Confundir consistência com convergência; não considerar h→0 uniformemente; ignorar estabilidade."
                                }
                              ],
                              "practicalExample": "Para -u'' = 0 em [0,1], u(0)=0, u(1)=1 (solução u=x), discretize com N=10,20,40. Calcule τ_i = δ²u_i/h² + 0, observe |τ_i| ≈ (1/12)h² u^{(4)}=0 (exato), mas para u=sin(πx), τ_i ≈ (π^4/12) h² sin(π x_i). Refine e confirme O(h²), e ||u^h - u|| →0.",
                              "finalVerifications": [
                                "Derivação de Taylor mostra erro local O(h²) com coeficiente h²/12 u^{(4)}.",
                                "Cálculo numérico confirma ||τ|| / h² constante ao refinar h.",
                                "Lim_{h→0} max|τ_i(h)| = 0 comprovado analítica e numericamente.",
                                "Gráfico log-log de log|τ| vs log h tem inclinação -2.",
                                "Solução discreta converge para contínua em pelo menos 2 refinamentos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão de Taylor (sem erros de sinal ou ordem).",
                                "Identificação correta do termo líder O(h²/12) u^{(4)}.",
                                "Comprovação rigorosa de consistência via lim h→0 τ=0.",
                                "Uso apropriado de exemplo numérico com refinamento de grade.",
                                "Explicação clara da relação com convergência (Lax equivalence).",
                                "Ausência de confusão entre erro local, global e consistência."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (NumPy/SciPy) para análise empírica de ordem.",
                                "Física: Aplicar em EDOs de mecânica (vibrações, difusão) para validar modelos discretos.",
                                "Estatística: Análise de erro em aproximações numéricas e testes de hipótese para ordem.",
                                "Engenharia Computacional: Pré-requisito para FDM em CFD e simulações estruturais."
                              ],
                              "realWorldApplication": "Em simulações de engenharia como fluxo de calor em placas (modelado por Laplace), análise de truncagem garante precisão ao refinar malha; em finanças, para resolver EDOs em precificação de opções, consistência assegura que soluções numéricas aproximem o modelo Black-Scholes contínuo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Resolução de Sistemas Lineares Tridiagonais",
                        "description": "Métodos eficientes para resolver o sistema linear tridiagonal gerado pela discretização, garantindo estabilidade e precisão.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Aplicar o algoritmo Thomas (eliminação progressiva-retroativa)",
                            "description": "Implementar o método de Thomas para resolver sistemas tridiagonais Ax = b com diagonais sub, principal e super, aproveitando a estrutura banda para complexidade O(N).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e representar o sistema tridiagonal",
                                  "subSteps": [
                                    "Identifique os vetores do sistema: subdiagonal (a_i para i=2 a n), diagonal principal (b_i para i=1 a n), superdiagonal (c_i para i=1 a n-1) e vetor de termos independentes (d_i).",
                                    "Verifique se o sistema Ax = b tem estrutura banda tridiagonal, garantindo que apenas essas diagonais são não-nulas.",
                                    "Escreva as equações matriciais explícitas para um sistema pequeno (n=3 ou 4) para visualizar a estrutura.",
                                    "Confirme estabilidade: |a_i / b_{i-1}| < 1 para evitar divisão por zero ou instabilidade.",
                                    "Anote os valores iniciais em tabelas ou arrays para facilitar o rastreamento."
                                  ],
                                  "verification": "Sistema representado corretamente com vetores a, b, c, d identificados e equações escritas sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Exemplo de sistema tridiagonal impresso ou digital"
                                  ],
                                  "tips": "Sempre indexe os vetores corretamente: a inicia em i=2, c termina em i=n-1.",
                                  "learningObjective": "Representar precisamente um sistema linear tridiagonal para aplicação do algoritmo Thomas.",
                                  "commonMistakes": [
                                    "Confundir índices dos vetores (ex: usar a_1 que não existe)",
                                    "Ignorar verificação de pivô zero na diagonal b",
                                    "Escrever matriz cheia em vez de vetores banda"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a eliminação progressiva (fase forward)",
                                  "subSteps": [
                                    "Inicialize cópias modificadas: b' = b, d' = d.",
                                    "Para i de 2 até n: calcule m_i = a_i / b'_{i-1}, então b'_i = b_i - m_i * c_{i-1}, d'_i = d_i - m_i * d'_{i-1}.",
                                    "Atualize os vetores sequencialmente, registrando cada m_i, b'_i e d'_i.",
                                    "Verifique após cada iteração se b'_i ≠ 0 para diagonal dominante.",
                                    "Complete a fase forward obtendo os vetores b' e d' modificados."
                                  ],
                                  "verification": "Vetores b' e d' calculados corretamente, comparando com cálculo manual ou software para n pequeno.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python/MATLAB para verificação",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Mantenha precisão numérica usando ponto flutuante duplo; evite arredondamentos prematuros.",
                                  "learningObjective": "Transformar o sistema em upper triangular via eliminação forward, explorando a banda tridiagonal.",
                                  "commonMistakes": [
                                    "Usar b_i em vez de b'_{i-1} no cálculo de m_i",
                                    "Esquecer de atualizar d'_i",
                                    "Aplicar loop incorreto (ex: começar i=1)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a substituição retroativa (fase backward)",
                                  "subSteps": [
                                    "Inicie com x_n = d'_n / b'_n.",
                                    "Para i de n-1 até 1: x_i = (d'_i - c_i * x_{i+1}) / b'_i.",
                                    "Calcule cada x_i sequencialmente da direita para a esquerda.",
                                    "Registre o vetor solução x completo.",
                                    "Confirme que todos x_i foram computados sem divisão por zero."
                                  ],
                                  "verification": "Vetor x obtido e multiplicação A*x ≈ b com erro < 10^{-10}.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Código Python simples para matriz-vetor"
                                  ],
                                  "tips": "Comece sempre pelo último elemento para evitar dependências circulares.",
                                  "learningObjective": "Resolver o sistema upper triangular modificado obtendo a solução exata via back-substitution.",
                                  "commonMistakes": [
                                    "Inverter o loop (forward em vez de backward)",
                                    "Usar c_{i+1} em vez de c_i",
                                    "Esquecer divisão por b'_i"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e analisar a solução",
                                  "subSteps": [
                                    "Multiplique A * x e compare com b (resíduo ||A x - b|| < ε).",
                                    "Compare com solução exata (se conhecida) ou método direto (Gauss).",
                                    "Meça tempo de execução e complexidade: confirme O(N) operações.",
                                    "Teste sensibilidade a perturbações em a, b, c, d.",
                                    "Documente o processo completo para um exemplo numérico."
                                  ],
                                  "verification": "Resíduo pequeno e complexidade confirmada via contagem de operações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software NumPy/Python ou MATLAB",
                                    "Exemplo com solução analítica"
                                  ],
                                  "tips": "Use norma euclidiana para resíduo; para N grande, implemente em código.",
                                  "learningObjective": "Verificar correção, precisão e eficiência do algoritmo Thomas.",
                                  "commonMistakes": [
                                    "Ignorar erros de arredondamento em N grande",
                                    "Comparar apenas visualmente sem métrica quantitativa",
                                    "Confundir complexidade O(N) com O(N^2)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o sistema tridiagonal 3x3: a=[1,2], b=[4,3,2], c=[1,2], d=[5,9,8].\nForward: m2=1/4=0.25, b'2=3-0.25*1=2.75, d'2=9-0.25*5=7.75; m3=2/2.75≈0.727, b'3=2-0.727*2≈0.545, d'3=8-0.727*7.75≈4.363.\nBackward: x3=4.363/0.545≈8, x2=(7.75-2*8)/2.75≈-1.545, x1=(5-1*(-1.545))/4≈1.636. Verifique A x ≈ d.",
                              "finalVerifications": [
                                "Eliminação forward produz b' e d' corretos sem divisão por zero.",
                                "Substituição backward gera x com resíduo ||Ax - b|| < 10^{-8}.",
                                "Algoritmo executado em O(N) operações para N=100.",
                                "Solução coincide com eliminação Gaussiana direta.",
                                "Implementação em código roda sem erros para sistemas instáveis detectados.",
                                "Análise de estabilidade realizada (diagonal dominante)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução (resíduo < 10^{-10}).",
                                "Correta indexação e atualização dos vetores.",
                                "Eficiência demonstrada (contagem de flops ≈ 5N).",
                                "Detecção e tratamento de pivôs pequenos.",
                                "Documentação clara do processo passo a passo.",
                                "Generalização para N arbitrário via pseudocódigo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/NumPy para automação.",
                                "Física: Discretização de EDOs em problemas de difusão/calor.",
                                "Engenharia Computacional: CFD em malhas 1D.",
                                "Análise Numérica: Comparação com LU decomposição.",
                                "Estatística: Modelos de regressão com covariâncias tridiagonais."
                              ],
                              "realWorldApplication": "Resolução eficiente de sistemas lineares oriundos da discretização por diferenças finitas em equações diferenciais parabólicas/hiperbólicas, como simulações de fluxo de calor em hastes, propagação de ondas ou finanças (modelos de Black-Scholes discretizados)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Verificar estabilidade e convergência do método",
                            "description": "Demonstrar que o método de diferenças finitas converge com ordem 2 para problemas lineares elípticos regulares, usando análise de erro global e condições de Lax.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o problema elíptico modelo e o esquema de diferenças finitas",
                                  "subSteps": [
                                    "Defina o problema modelo: -u''(x) = f(x) para x em [0,1], com u(0)=u(1)=0.",
                                    "Descreva a malha uniforme x_i = i h, h=1/(N+1).",
                                    "Apresente o esquema central: (u_{i-1} - 2u_i + u_{i+1})/h^2 = f(x_i), i=1..N.",
                                    "Explique a forma matricial tridiagonal Au = b.",
                                    "Verifique consistência básica expandindo em Taylor."
                                  ],
                                  "verification": "Escreva o esquema e confirme que aproxima a equação diferencial nos pontos internos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), caderno, calculadora.",
                                  "tips": "Use expansão de Taylor para visualizar a aproximação.",
                                  "learningObjective": "Compreender a discretização do BVP elíptico 1D pelo método de diferenças finitas.",
                                  "commonMistakes": "Confundir condições de contorno Dirichlet com Neumann; ignorar o fator h^2."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o erro de truncamento local (LTE) e mostrar ordem 2",
                                  "subSteps": [
                                    "Expanda u(x_{i-1}), u(x_{i+1}) em série de Taylor ao redor de x_i até ordem 4.",
                                    "Substitua no operador de diferenças: δ^2 u_i / h^2 = u''(x_i) + (h^2/12) u^{(4)}(ξ).",
                                    "Calcule o LTE: τ_i = |δ^2 u_i / h^2 + u''(x_i)| ≤ (h^2/12) max |u^{(4)}|.",
                                    "Conclua consistência de ordem 2: ||τ||_∞ = O(h^2).",
                                    "Discuta regularidade: assumir u em C^4 para problemas regulares."
                                  ],
                                  "verification": "Derive explicitamente o LTE e mostre que é O(h^2).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Papel para derivadas, software simbólico como Mathematica ou SymPy.",
                                  "tips": "Lembre-se: Taylor simétrico cancela termos ímpares.",
                                  "learningObjective": "Demonstrar consistência de ordem 2 via análise de Taylor.",
                                  "commonMistakes": "Parar na ordem 2 sem incluir o resíduo O(h^2); confundir LTE com erro global."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar estabilidade usando princípio do máximo discreto ou condições de Lax",
                                  "subSteps": [
                                    "Estabeleça o princípio do máximo discreto: para A com diagonais positivas, max |u_i^h| ≤ max |u| + O(h^2).",
                                    "Mostre que ||A^{-1}||_∞ ≤ 1 para o laplaciano discreto.",
                                    "Recorra ao teorema de equivalência de Lax: consistência + estabilidade ⇒ convergência.",
                                    "Para elípticos lineares: use norma energética ou Lax-Milgram discreto se em forma variacional.",
                                    "Verifique estabilidade uniforme em h: ||e^h|| ≤ C ||τ||, C independente de h."
                                  ],
                                  "verification": "Prove que a solução discreta satisfaz o princípio do máximo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Notas de aula sobre estabilidade, MATLAB para testar normas.",
                                  "tips": "Para 1D simples, máximo discreto é direto; generalize para 2D Poisson.",
                                  "learningObjective": "Estabelecer estabilidade do esquema para problemas elípticos regulares.",
                                  "commonMistakes": "Aplicar Lax hiperbólico diretamente sem adaptação; ignorar coeficientes variáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar estimativa de erro global e concluir convergência de ordem 2",
                                  "subSteps": [
                                    "Defina erro global e_i = u(x_i) - u_i^h.",
                                    "Use decomposição: ||e|| ≤ ||e_trunc|| + ||e_stab|| ≤ C h^2 max|u^{(4)}|.",
                                    "Pelo teorema: ||u - u^h||_∞ ≤ C h^2, com C de Lax-Milgram ou máximo.",
                                    "Discuta condições de regularidade: coeficientes suaves, domínio suave.",
                                    "Implemente numericamente: resolva para h=1/10,1/20,... e verifique ||erro||/h^2 constante."
                                  ],
                                  "verification": "Escreva a estimativa ||u - u^h|| = O(h^2) e numere para confirmação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB/Python para resolver sistema tridiagonal e plotar erros.",
                                  "tips": "Use thomas algorithm para eficiência; loglog plot para ordem.",
                                  "learningObjective": "Concluir convergência ordem 2 via análise de erro global.",
                                  "commonMistakes": "Confundir ordem local com global sem prova de estabilidade; superestimar C."
                                }
                              ],
                              "practicalExample": "Para -u'' = π^2 sin(π x) em [0,1], u(0)=u(1)=0 (solução exata u=sin(π x)), discretize com N=10,20,40. Resolva Au=b com A tridiagonal, compute erro máximo, plote log(erro) vs log(h): inclinação -2 confirma ordem 2.",
                              "finalVerifications": [
                                "Derivação correta do LTE O(h^2).",
                                "Prova de estabilidade via máximo discreto.",
                                "Estimativa global de erro O(h^2).",
                                "Implementação numérica mostrando convergência ordem 2.",
                                "Explicação das condições de Lax para convergência.",
                                "Discussão de regularidade assumida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na análise de Taylor para LTE (ordem exata).",
                                "Correção na prova de estabilidade (norma bounded).",
                                "Clareza na ligação consistência-estabilidade-convergência.",
                                "Qualidade da implementação numérica e plots.",
                                "Tratamento de casos regulares vs singulares.",
                                "Profundidade na discussão de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Física: Equações de Poisson em eletrostática e difusão estacionária.",
                                "Programação: Algoritmos para sistemas tridiagonais (Thomas).",
                                "Engenharia: Simulações CFD para escoamentos incompressíveis.",
                                "Estatística: Análise de erro em métodos numéricos probabilísticos."
                              ],
                              "realWorldApplication": "Verificação de precisão em simulações de campos térmicos em placas (engenharia mecânica), modelagem de potenciais em dispositivos eletrônicos, ou previsão de deformações em estruturas sob carga estática, garantindo que refinamento de malha dobra custo mas quadruplica precisão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Implementar em código numérico",
                            "description": "Codificar em Python ou MATLAB a discretização e resolução de um BVP linear exemplo, como y'' + y = 0 com y(0)=0, y(π)=0, comparando com solução exata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Problema de Valor de Contorno e Configurar o Ambiente",
                                  "subSteps": [
                                    "Defina o BVP: y'' + y = 0 com condições y(0) = 0 e y(π) = 0.",
                                    "Instale bibliotecas necessárias: NumPy para arrays e operações matriciais, SciPy para resolução linear, Matplotlib para visualização.",
                                    "Escolha parâmetros de discretização: número de pontos N (ex: 101), h = π/(N-1).",
                                    "Escreva a solução exata: y(x) = 0 (solução trivial para este BVP homogêneo).",
                                    "Crie um script Python inicial com imports e definição de constantes."
                                  ],
                                  "verification": "Script roda sem erros e imprime h e N corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "SciPy",
                                    "Matplotlib",
                                    "Editor de código (VS Code ou Jupyter)"
                                  ],
                                  "tips": "Use Jupyter Notebook para testes interativos. Comece com N pequeno (ex: 11) para depuração rápida.",
                                  "learningObjective": "Entender a formulação matemática do BVP e preparar ambiente computacional.",
                                  "commonMistakes": [
                                    "Esquecer importações",
                                    "Usar intervalos errados (0 a π)",
                                    "Confundir solução exata como não-trivial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a Discretização por Diferenças Finitas",
                                  "subSteps": [
                                    "Aplique diferenças finitas centrais: y''(x_i) ≈ (y_{i-1} - 2y_i + y_{i+1})/h².",
                                    "Formule a equação discreta: (1/h²)(y_{i-1} - 2y_i + y_{i+1}) + y_i = 0 para i=1 a N-2.",
                                    "Incorpore condições de contorno: y_0 = 0, y_{N-1} = 0.",
                                    "Monte os coeficientes da matriz tridiagonal A: diagonal principal -2/h² + 1, sub/super 1/h².",
                                    "Crie vetores para a matriz tridiagonal usando np.diag para eficiência."
                                  ],
                                  "verification": "Matriz A tem shape (N-1, N-1), é simétrica tridiagonal, e vetor b é zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NumPy para np.diag e np.zeros"
                                  ],
                                  "tips": "Use sparse matrices se N grande para eficiência, mas comece denso. Verifique A @ y_exata ≈ 0.",
                                  "learningObjective": "Dominar a derivação e implementação da discretização de segunda ordem.",
                                  "commonMistakes": [
                                    "Índices off-by-one em i=1 a N-2",
                                    "Esquecer fator 1/h² na aproximação",
                                    "Matriz não quadrada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o Sistema Linear Tridiagonal",
                                  "subSteps": [
                                    "Defina vetor b = zeros(N-1) pois homogêneo.",
                                    "Use scipy.linalg.solve(A, b) ou thomas algorithm para tridiagonal.",
                                    "Implemente algoritmo Thomas (TDMA) manualmente: forward elimination e back substitution.",
                                    "Armazene solução numérica y_num em array de tamanho N, com y[0]=0, y[-1]=0.",
                                    "Teste com N pequeno e verifique se y_num é próximo de zero."
                                  ],
                                  "verification": "Solução y_num satisfaz ||A @ y_num - b|| < 1e-10.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "SciPy.linalg",
                                    "NumPy"
                                  ],
                                  "tips": "Implemente Thomas para aprendizado; use solve() para validação. Monitore cond number de A.",
                                  "learningObjective": "Implementar eficientemente solvers para sistemas tridiagonais.",
                                  "commonMistakes": [
                                    "Divisão por zero em Thomas se pivoting necessário",
                                    "Erro em boundaries no TDMA",
                                    "Usar solver denso ineficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Solução Exata e Calcular Erros",
                                  "subSteps": [
                                    "Gere malha x = np.linspace(0, np.pi, N).",
                                    "Defina y_exata = np.zeros_like(x).",
                                    "Calcule erro absoluto: err = np.abs(y_num - y_exata).",
                                    "Calcule norma L2: np.sqrt(np.trapz(err**2, x)).",
                                    "Analise convergência testando múltiplos N (ex: 11,21,41) e plote log-log de erro vs h.",
                                    "Registre taxa de convergência esperada O(h²)."
                                  ],
                                  "verification": "Erro máximo < 1e-12 e converge quadraticamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NumPy para erros",
                                    "SciPy.integrate para trapz"
                                  ],
                                  "tips": "Para BVP não-trivial, teste com y'' + y = πx alterando b. Use np.max(err) e np.linalg.norm.",
                                  "learningObjective": "Avaliar precisão numérica e ordem de convergência.",
                                  "commonMistakes": [
                                    "Comparar em pontos errados",
                                    "Norma errada (use L-infty ou L2)",
                                    "Esquecer normalizar por h"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Visualizar Resultados e Analisar",
                                  "subSteps": [
                                    "Plote y_num e y_exata vs x com plt.plot.",
                                    "Plote erro absoluto em subplot separado.",
                                    "Adicione legenda, labels, grid e salve figura como PNG.",
                                    "Teste com BVP não-homogêneo para generalidade (ex: y'' + y = x).",
                                    "Documente código com comentários e crie função reutilizável."
                                  ],
                                  "verification": "Gráficos mostram y_num ≈ 0, erro pequeno; código modular.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matplotlib"
                                  ],
                                  "tips": "Use plt.tight_layout(). Para não-trivial, ajuste f(x) e b_i = h² f(x_i).",
                                  "learningObjective": "Comunicar resultados numéricos via visualização.",
                                  "commonMistakes": [
                                    "Escalas erradas no plot",
                                    "Legendas ausentes",
                                    "Não salvar figura"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente para y'' + y = πx (não-homogêneo), y(0)=0, y(π)=0. Solução exata envolve integrais; discretize f_i = π x_i, b_i = h² f_i. Compare erros para N=101.",
                              "finalVerifications": [
                                "Código executa sem erros para múltiplos N.",
                                "Solução numérica satisfaz condições de contorno exatamente.",
                                "Erro L∞ < 1e-10 para N=101.",
                                "Convergência O(h²) confirmada em log-log plot.",
                                "Função é reutilizável para outros BVPs lineares.",
                                "Documentação inclui comentários e README."
                              ],
                              "assessmentCriteria": [
                                "Correção da discretização (matriz A exata).",
                                "Eficiência do solver (tempo <1s para N=1001).",
                                "Análise de erro precisa (L2 e ordem).",
                                "Visualizações claras e informativas.",
                                "Código limpo, modular e comentado.",
                                "Generalidade para f(x) arbitrário."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Algoritmos numéricos em Python.",
                                "Física: Modelagem de vibrações/ondas via EDOs.",
                                "Engenharia: Simulação de estruturas (tensão em vigas).",
                                "Estatística: Análise de erros e convergência.",
                                "Computação Científica: Uso de bibliotecas NumPy/SciPy."
                              ],
                              "realWorldApplication": "Simulação de perfis de temperatura em hastes (equação de calor estacionária), análise de vigas em engenharia civil, modelagem de potenciais eletrostáticos em física computacional, onde BVPs lineares surgem frequentemente e métodos de diferenças finitas são padrão em softwares como COMSOL ou FEniCS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Extensão para BVPs Não Lineares",
                        "description": "Discretização de problemas não lineares resultando em sistemas não lineares algébricos e métodos iterativos para solução.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Formular o sistema não linear discreto",
                            "description": "Discretizar y'' = f(x, y, y') em um sistema F(y) = 0 não linear tridiagonal implícito, mantendo estrutura esparsa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a malha numérica e notação inicial",
                                  "subSteps": [
                                    "Divida o intervalo [a, b] em N+2 pontos: x_i = a + i h para i = 0, 1, ..., N+1, onde h = (b - a)/(N+1).",
                                    "Aproxime y(x_i) por y_i, com y_0 = α e y_{N+1} = β das condições de contorno.",
                                    "Defina o vetor desconhecido y = [y_1, y_2, ..., y_N]^T.",
                                    "Esboce a malha no papel, marcando pontos internos i=1 a N."
                                  ],
                                  "verification": "Malha escrita com h correto, y_0 e y_{N+1} fixos, vetor y de dimensão N.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para h"
                                  ],
                                  "tips": "Escolha N par para simetria, comece com N pequeno como 4 para testes.",
                                  "learningObjective": "Configurar corretamente a discretização espacial para BVPs.",
                                  "commonMistakes": "Confundir h = (b-a)/N em vez de /(N+1); incluir y_0 e y_{N+1} como desconhecidas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aproximar derivadas primeira e segunda usando diferenças finitas centrais",
                                  "subSteps": [
                                    "Aproxime y'(x_i) ≈ (y_{i+1} - y_{i-1}) / (2h), com erro O(h²).",
                                    "Aproxime y''(x_i) ≈ (y_{i-1} - 2 y_i + y_{i+1}) / h², com erro O(h²).",
                                    "Verifique consistência: ambas aproximações são de segunda ordem.",
                                    "Substitua nas posições i=1 a N, notando uso de y_0 e y_{N+1} conhecidos.",
                                    "Escreva explicitamente para um i genérico."
                                  ],
                                  "verification": "Fórmulas de y'_i e y''_i corretas, com fatores 2h e h² exatos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de diferenças finitas",
                                    "Livro de análise numérica (opcional)"
                                  ],
                                  "tips": "Lembre-se: central para precisão; evite forward/backward nos internos.",
                                  "learningObjective": "Dominar esquemas de diferenças finitas centradas para EDOs de segunda ordem.",
                                  "commonMistakes": "Usar h em vez de 2h para y'; esquecar o -2 em y''."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o sistema não linear F(y) = 0",
                                  "subSteps": [
                                    "Substitua na EDO discretizada: (y_{i-1} - 2 y_i + y_{i+1}) / h² = f(x_i, y_i, y'_i).",
                                    "Multiplique por h²: y_{i-1} - 2 y_i + y_{i+1} = h² f(x_i, y_i, (y_{i+1} - y_{i-1}) / (2h)).",
                                    "Defina F_i(y) = y_{i-1} - 2 y_i + y_{i+1} - h² f(x_i, y_i, (y_{i+1} - y_{i-1}) / (2h)) = 0, para i=1 a N.",
                                    "Confirme que F: ℝ^N → ℝ^N é não linear devido a f.",
                                    "Escreva o sistema completo como F(y) = 0."
                                  ],
                                  "verification": "Cada F_i envolve y_{i-1}, y_i, y_{i+1} e f corretamente; dimensão N.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para equações",
                                    "Exemplo de f simbólico"
                                  ],
                                  "tips": "Mantenha y'_i dentro de f para implicitidade plena.",
                                  "learningObjective": "Construir o operador não linear discreto implícito.",
                                  "commonMistakes": "Esquecer h² multiplicando f; linearizar prematuramente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar estrutura tridiagonal implícita e esparsidade",
                                  "subSteps": [
                                    "Analise dependências: F_i depende só de y_{i-1}, y_i, y_{i+1} (3 termos lineares + f).",
                                    "Confirme tridiagonal: na forma matricial, banda principal com sub/super-diagonais.",
                                    "Note esparsidade: ~3 não-zeros por equação, ideal para solvers esparsos.",
                                    "Discuta implicitidade: requer solução iterativa (ex: Newton).",
                                    "Esboce matriz de Jacobi aproximada (tridiagonal)."
                                  ],
                                  "verification": "Descrição da estrutura: tridiagonal, não linear, esparsa confirmada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz esparsa exemplo",
                                    "Software como MATLAB para visualizar (opcional)"
                                  ],
                                  "tips": "Pense na Jacobiana ∂F/∂y para solvers.",
                                  "learningObjective": "Reconhecer propriedades que facilitam resolução numérica.",
                                  "commonMistakes": "Ignorar dependência em y_{i-1}, y_{i+1} via y'; achar denso por f."
                                }
                              ],
                              "practicalExample": "Para y'' = y y' em [0,1] com y(0)=0, y(1)=1, h=0.25 (N=3): F_1 = y_0 -2y_1 + y_2 - h² y_1 (y_2 - y_0)/(2h) =0, com y_0=0; similar para i=2,3 usando y_4=1. Sistema: 3 eqs não lineares tridiagonais.",
                              "finalVerifications": [
                                "Sistema F(y)=0 tem exatamente N equações e N incógnitas y_1 a y_N.",
                                "Cada F_i incorpora y''_i ≈ e y'_i corretamente com O(h²).",
                                "Estrutura tridiagonal: dependência local i-1,i,i+1.",
                                "Não linearidade preservada via f(x,y,y').",
                                "Condições de contorno aplicadas via y_0 e y_{N+1}.",
                                "Esparsidade mantida: O(N) não-zeros totais."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da discretização de derivadas.",
                                "Formulação precisa de F_i sem erros algébricos.",
                                "Identificação correta da estrutura tridiagonal e esparsidade.",
                                "Inclusão adequada de condições de contorno.",
                                "Explicação da implicitidade e não linearidade.",
                                "Capacidade de aplicar a um exemplo concreto."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python com NumPy/SciPy para sistemas esparsos.",
                                "Física: Discretização de equações de onda ou difusão não linear.",
                                "Engenharia Computacional: Pré-processamento para solvers como Newton-Krylov.",
                                "Matemática Aplicada: Teoria de estabilidade para esquemas implícitos."
                              ],
                              "realWorldApplication": "Formulação essencial para simular equações diferenciais não lineares em mecânica dos fluidos (ex: Navier-Stokes discretizados), dinâmica de estruturas (deformações não lineares) e biologia (modelos de reação-difusão), permitindo soluções eficientes com métodos iterativos em softwares como COMSOL ou FEniCS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Aplicar método de Newton-Raphson",
                            "description": "Usar iterações de Newton com Jacobiana tridiagonal aproximada para resolver F(y^{(k+1)}) = F(y^{(k)}) + J(y^{(k)})(y^{(k+1)} - y^{(k)}) = 0, resolvendo sistemas lineares em cada passo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação do Problema Discretizado e Inicialização",
                                  "subSteps": [
                                    "Defina o intervalo [a, b] e o número de pontos internos n, calculando h = (b - a)/n.",
                                    "Incorpore as condições de contorno lineares ou não lineares para fixar y_0 e y_n.",
                                    "Escolha um chute inicial y^{(0)} = [y_1^{(0)}, ..., y_{n-1}^{(0)}], por exemplo, interpolação linear entre y_0 e y_n.",
                                    "Defina critérios de parada: tolerância ε (ex: 10^{-6}), máximo de iterações k_{max} = 50."
                                  ],
                                  "verification": "Verifique se y^{(0)} satisfaz aproximadamente as condições de contorno e se os parâmetros ε e k_{max} estão definidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e calculadora",
                                    "Software numérico como Python (NumPy) ou MATLAB",
                                    "Referência de diferenças finitas"
                                  ],
                                  "tips": [
                                    "Use um chute inicial próximo da solução linearizada para acelerar convergência.",
                                    "Registre todos os valores para depuração posterior."
                                  ],
                                  "learningObjective": "Preparar corretamente o sistema não linear discretizado F(y) = 0 para iterações de Newton.",
                                  "commonMistakes": [
                                    "Ignorar condições de contorno nas extremidades.",
                                    "Escolher h muito grande, levando a baixa precisão.",
                                    "Chute inicial muito distante, causando divergência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Cálculo do Resíduo Vetorial F(y^{(k)})",
                                  "subSteps": [
                                    "Para cada i = 1 a n-1, compute F_i(y^{(k)}) usando a discretização de diferenças finitas centradas: ex. F_i = (y_{i-1} - 2y_i + y_{i+1})/h^2 - f(x_i, y_i).",
                                    "Armazene o vetor F^{(k)} = [F_1, ..., F_{n-1}].",
                                    "Verifique se ||F^{(k)}|| é finito e razoável (não NaN ou Inf)."
                                  ],
                                  "verification": "Calcule a norma ||F^{(k)}||_∞; deve ser finita e preferencialmente decrescente nas iterações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha ou código para diferenças finitas",
                                    "Gráfico para visualizar F"
                                  ],
                                  "tips": [
                                    "Implemente em loop vetorizado para eficiência.",
                                    "Teste com problema linear conhecido para validar."
                                  ],
                                  "learningObjective": "Computar precisamente o resíduo do sistema não linear discretizado.",
                                  "commonMistakes": [
                                    "Erro no stencil de diferenças finitas (ex: usar forward em vez de central).",
                                    "Índices incorretos nos pontos de contorno.",
                                    "Não tratar f não linear corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construção da Jacobiana Tridiagonal Aproximada J(y^{(k)})",
                                  "subSteps": [
                                    "Para cada i=1 a n-1, compute a diagonal principal J_{i,i} ≈ ∂F_i/∂y_i = -2/h^2 - ∂f/∂y (x_i, y_i^{(k)}).",
                                    "Subdiagonal J_{i,i-1} ≈ ∂F_i/∂y_{i-1} = 1/h^2 (para i>1).",
                                    "Superdiagonal J_{i,i+1} ≈ ∂F_i/∂y_{i+1} = 1/h^2 (para i<n-1).",
                                    "Monte a matriz tridiagonal esparsa ou vetores (a,b,c) para eficiência."
                                  ],
                                  "verification": "Verifique simetria aproximada se aplicável e teste J * vetor_teste para validar montagem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Algoritmo de diferenças finitas",
                                    "Biblioteca SciPy para matrizes tridiagonais"
                                  ],
                                  "tips": [
                                    "Use aproximação finita para ∂f/∂y se analítica não disponível.",
                                    "Mantenha J esparsa para economizar memória."
                                  ],
                                  "learningObjective": "Construir a Jacobiana tridiagonal derivada da linearização newtoniana.",
                                  "commonMistakes": [
                                    "Esquecer termos não lineares em ∂f/∂y.",
                                    "Índices errados na tridiagonal.",
                                    "Não aproximar corretamente para BVPs com contornos não lineares."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolução do Sistema Linear Tridiagonal J δ = -F^{(k)}",
                                  "subSteps": [
                                    "Aplique o Algoritmo de Thomas (eliminação de Thomas) para resolver o sistema tridiagonal: forward sweep para coeficientes, backward sweep para δ.",
                                    "Implemente ou use solver integrado (ex: scipy.linalg.solve_banded).",
                                    "Verifique se a solução δ é coerente (norma razoável)."
                                  ],
                                  "verification": "Compute resíduo do sistema resolvido: ||J δ + F|| < 10^{-10} para precisão máquina.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Implementação do Algoritmo de Thomas",
                                    "Código Python/MATLAB testado"
                                  ],
                                  "tips": [
                                    "Evite pivoteamento desnecessário em tridiagonais bem condicionadas.",
                                    "Teste com sistema identidade primeiro."
                                  ],
                                  "learningObjective": "Resolver eficientemente sistemas lineares tridiagonais oriundos da linearização.",
                                  "commonMistakes": [
                                    "Divisão por zero na decomposição LU tridiagonal.",
                                    "Erro na forward/backward sweep.",
                                    "Usar solver denso ineficiente para n grande."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Atualização, Verificação de Convergência e Finalização",
                                  "subSteps": [
                                    "Atualize y^{(k+1)} = y^{(k)} + δ.",
                                    "Compute ||δ||_∞ e ||F(y^{(k+1)})||_∞; pare se ambos < ε ou k > k_{max}.",
                                    "Registre histórico de convergência (normas por iteração).",
                                    "Analise a solução final: plote y vs x, compare com solução conhecida se disponível."
                                  ],
                                  "verification": "Confirme convergência: ||δ|| < ε e ||F|| < ε; solução satisfaz contornos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráficos de convergência",
                                    "Solução analítica de referência"
                                  ],
                                  "tips": [
                                    "Monitore resíduos em log scale para detectar platô.",
                                    "Ajuste ε baseado em precisão desejada."
                                  ],
                                  "learningObjective": "Implementar o loop de Newton-Raphson completo com critérios de parada robustos.",
                                  "commonMistakes": [
                                    "Critério de parada só em ||δ||, ignorando ||F||.",
                                    "Não detectar divergência (aumentar k_max cegamente).",
                                    "Erro de arredondamento em atualizações acumuladas."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o BVP não linear y'' + y^3 = 0 com y(0) = 0, y(1) = 0. Use n=20 (h=0.05), chute inicial y_i^{(0)} = 0, ε=10^{-8}. Após 5-7 iterações, obtenha y_max ≈ 1.45 no centro, com ||F|| < 10^{-10}. Implemente em Python usando vetores tridiagonais.",
                              "finalVerifications": [
                                "O método converge em menos de 20 iterações.",
                                "Norma final do resíduo ||F(y^*)||_∞ < 10^{-8}.",
                                "Norma do incremento final ||δ||_∞ < 10^{-10}.",
                                "A solução satisfaz as condições de contorno com erro < 10^{-10}.",
                                "Histórico de resíduos mostra redução quadrática.",
                                "Teste de consistência: refinando h pela metade, solução varia < 1%."
                              ],
                              "assessmentCriteria": [
                                "Correta discretização do BVP não linear em F(y)=0.",
                                "Jacobiana tridiagonal precisa e eficientemente montada.",
                                "Resolução do sistema linear sem erros numéricos significativos.",
                                "Loop de iteração com convergência quadrática observada.",
                                "Análise pós-convergência incluindo gráficos e resíduos.",
                                "Eficiência computacional: O(n) por iteração."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Implementação de solvers numéricos em Python/MATLAB.",
                                "Física: Modelagem de equações diferenciais não lineares em mecânica e ondas.",
                                "Engenharia: Simulações em estruturas e fluidodinâmica.",
                                "Estatística: Análise de erro e convergência numérica."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, aplica-se para resolver equações não lineares de fluxo viscoso em perfis aerodinâmicos, usando diferenças finitas e Newton-Raphson para otimizar designs de asas com precisão alta e custo computacional baixo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Avaliar convergência e controle de passo",
                            "description": "Analisar condições de convergência quadrática local do Newton e introduzir estratégias de passo adaptativo ou relaxação para problemas stiff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar condições de convergência quadrática local do método de Newton",
                                  "subSteps": [
                                    "Estudar a definição de convergência quadrática local e sua relação com a derivada da função F no ponto solução x*.",
                                    "Derivar a condição |F'(x*)^{-1} F''(ξ)| < 1 para garantias de convergência quadrática.",
                                    "Analisar o comportamento assintótico do erro e = x_k - x* ≈ C e_k^2.",
                                    "Implementar um exemplo simples em código para visualizar a redução quadrática do erro.",
                                    "Comparar com convergência linear para destacar diferenças."
                                  ],
                                  "verification": "Derivar corretamente a condição de convergência e plotar gráfico de log-log do erro mostrando ordem 2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de análise numérica (ex: Burden & Faires), MATLAB/Python com NumPy/SciPy, notas de aula sobre método de Newton.",
                                  "tips": "Use aproximações simbólicas iniciais antes de numéricas para clareza conceitual.",
                                  "learningObjective": "Compreender e derivar as condições matemáticas para convergência quadrática local do Newton em BVPs não-lineares.",
                                  "commonMistakes": "Confundir convergência local com global; ignorar inversibilidade de F'(x*)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar problemas stiff em BVPs não-lineares",
                                  "subSteps": [
                                    "Definir rigidez como escalas temporais/espaçais muito diferentes nos autovalores do Jacobiano.",
                                    "Examinar BVPs não-lineares discretizados por diferenças finitas e seus Jacobianos.",
                                    "Calcular autovalores de exemplos stiff vs. não-stiff para quantificar rigidez.",
                                    "Simular iterações de Newton puro em problema stiff e observar falhas de convergência.",
                                    "Discutir impacto na escolha de passos de malha h."
                                  ],
                                  "verification": "Identificar corretamente rigidez em um BVP exemplo via espectro de autovalores e demonstrar divergência em Newton padrão.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software de autovalores (MATLAB eig() ou Python linalg.eig), exemplo BVP stiff como y'' = -y + e^{1/y} com BCs.",
                                  "tips": "Comece com malhas grosseiras para isolar rigidez antes de refinar.",
                                  "learningObjective": "Reconhecer características de problemas stiff em contextos de BVPs e seu efeito na convergência de Newton.",
                                  "commonMistakes": "Atribuir falhas apenas a h grande, ignorando rigidez inerente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar estratégias de passo adaptativo",
                                  "subSteps": [
                                    "Explicar adaptação de tamanho de passo baseada em redução de resíduo ||F(x_{k+1})||.",
                                    "Implementar backtracking line search: α_k = α_0 β^m onde m escolhido por ||F(x_k + α p_k)|| < η ||F(x_k)||.",
                                    "Testar em BVP stiff, ajustando parâmetros α_0=1, β=0.5, η=0.1.",
                                    "Monitorar número de iterações e estabilidade numérica.",
                                    "Comparar com Newton fixo-step."
                                  ],
                                  "verification": "Código roda com convergência em <20 iterações para BVP stiff, com log de α_k mostrando adaptação.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB/Python, função fsolve com options para line search, BVP exemplo stiff.",
                                  "tips": "Registre histórico de resíduos para diagnosticar adaptações falhas.",
                                  "learningObjective": "Desenvolver e aplicar algoritmos de passo adaptativo para melhorar convergência em problemas stiff.",
                                  "commonMistakes": "Escolha η muito ambiciosa levando a loops infinitos de backtrack."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir técnicas de relaxação para controle de passo",
                                  "subSteps": [
                                    "Descrever relaxação damped Newton: x_{k+1} = x_k + ω p_k com ω ∈ (0,1] ajustado empiricamente.",
                                    "Implementar estratégia de escolha de ω baseada em ganho de redução quadrática aproximada.",
                                    "Combinar com passo adaptativo para problemas muito stiff.",
                                    "Simular em BVP não-linear stiff e analisar estabilidade vs. precisão.",
                                    "Avaliar trade-offs: mais iterações mas convergência robusta."
                                  ],
                                  "verification": "Implementação converge onde Newton puro falha, com ω_k variando adequadamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Código do passo anterior, documentação de solvers como bvp4c (MATLAB) com damping.",
                                  "tips": "Use ω inicial=1 e reduza geometricamente se ||F|| não diminui.",
                                  "learningObjective": "Aplicar relaxação para estabilizar iterações de Newton em regimes stiff.",
                                  "commonMistakes": "Fixar ω baixo demais, sacrificando eficiência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e integrar controle de passo em fluxos completos",
                                  "subSteps": [
                                    "Desenvolver critérios combinados: usar adaptativo se não-stiff, relaxação se muito stiff.",
                                    "Testar em múltiplos BVPs variando rigidez.",
                                    "Analisar métricas: iterações totais, tempo CPU, precisão final.",
                                    "Documentar condições de switch entre estratégias.",
                                    "Refinar malha h adaptativamente baseado em erro estimado."
                                  ],
                                  "verification": "Relatório comparativo mostra melhoria >50% em iterações para casos stiff.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Suite de testes BVPs, ferramentas de profiling (timeit Python).",
                                  "tips": "Automatize testes com loops sobre parâmetros de rigidez.",
                                  "learningObjective": "Integrar e avaliar estratégias de controle de passo para avaliação robusta de convergência.",
                                  "commonMistakes": "Não considerar custo computacional do Jacobiano em avaliações."
                                }
                              ],
                              "practicalExample": "Resolva o BVP stiff não-linear y'' + y y' = e^y com y(0)=0, y(1)=1 usando diferenças finitas (n=50 pontos). Aplique Newton puro (diverge), depois adaptativo (converge em 15 iterações) e damped (robusto em 25 iterações). Plote solução, resíduos e histórico de passos.",
                              "finalVerifications": [
                                "Derivação correta da condição de convergência quadrática local.",
                                "Identificação precisa de rigidez via autovalores em exemplo stiff.",
                                "Implementação funcional de backtracking line search com convergência demonstrada.",
                                "Código de relaxação damped estabiliza Newton em BVP stiff.",
                                "Relatório comparativo com métricas quantitativas de performance.",
                                "Explicação integrada de quando usar cada estratégia."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na análise de convergência (30%)",
                                "Correção e eficiência dos códigos implementados (25%)",
                                "Análise quantitativa de rigidez e performance (20%)",
                                "Clareza na documentação de trade-offs e critérios (15%)",
                                "Criatividade em exemplos e testes adicionais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de difusão-reação stiff em química computacional.",
                                "Engenharia: Simulações CFD com BVPs não-lineares em aerodinâmica.",
                                "Ciência da Computação: Otimização numérica e solvers em bibliotecas como SciPy.",
                                "Estatística: Análise de erros de aproximação em métodos iterativos."
                              ],
                              "realWorldApplication": "Em simulações de combustão (reações químicas stiff), controle de aeronaves (BVPs não-lineares em dinâmica), e bioengenharia (modelos de propagação de ondas cardíacas), onde controle de passo garante convergência eficiente em Jacobianos mal-condicionados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.4",
                            "name": "Testar com exemplo não linear",
                            "description": "Resolver numericamente y'' = -y + λ sin(y) com condições de contorno, plotando soluções para diferentes λ e verificando bifurcações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular e Discretizar o Problema Não Linear",
                                  "subSteps": [
                                    "Defina as condições de contorno, como y(0) = 0 e y(π) = 0, e o domínio [0, π].",
                                    "Aplique diferenças finitas centrais para y'': (y_{i+1} - 2y_i + y_{i-1})/h² ≈ y''(x_i).",
                                    "Substitua na EDO: (y_{i+1} - 2y_i + y_{i-1})/h² + y_i - λ sin(y_i) = 0 para i=1 a N-1.",
                                    "Crie o vetor de incógnitas Y = [y_1, y_2, ..., y_{N-1}]^T com N pontos de grade.",
                                    "Escreva o sistema não linear F(Y) = 0 em forma matricial."
                                  ],
                                  "verification": "Sistema F(Y) = 0 está corretamente escrito e testado com valores iniciais simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis ou Jupyter Notebook com NumPy para prototipagem.",
                                  "tips": "Escolha h = π/(N+1) com N=20 inicialmente para testes rápidos.",
                                  "learningObjective": "Entender a discretização de BVPs não lineares via diferenças finitas.",
                                  "commonMistakes": "Esquecer condições de contorno nas equações de fronteira ou usar diferenças forward/backward incorretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método de Newton-Raphson para Resolver o Sistema Não Linear",
                                  "subSteps": [
                                    "Inicialize Y^{(0)} com a solução linear (λ=0, y=0).",
                                    "Compute a Jacobiana J = dF/dY, que é tridiagonal: diagonais com 1 - 2/h² - λ cos(y_i), sub/super com 1/h².",
                                    "Resolva J ΔY = -F(Y^{(k)}) usando decomposição LU ou solver tridiagonal.",
                                    "Atualize Y^{(k+1)} = Y^{(k)} + ΔY até ||ΔY|| < tol (ex: 1e-6).",
                                    "Teste convergência para λ=1."
                                  ],
                                  "verification": "Solução converge para valores conhecidos e resíduos < 1e-8.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy e SciPy (scipy.linalg.solve_banded para tridiagonal).",
                                  "tips": "Use damping se não convergir: Y_new = 0.5 Y_old + 0.5 Y^{(k+1)}.",
                                  "learningObjective": "Aplicar iteração de Newton para sistemas não lineares oriundos de BVPs.",
                                  "commonMistakes": "Jacobiana errada (esquecer -λ cos(y_i)) ou não tratar singularidades iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Simulações para Múltiplos Valores de λ e Detectar Bifurcações",
                                  "subSteps": [
                                    "Varra λ de 0 a 10 em passos de 0.1, usando solução anterior como chute inicial (continuation).",
                                    "Registre normas L2 de ||Y|| para cada λ para monitorar amplitude.",
                                    "Identifique λ_c ≈ 4 onde bifurcação de pitchfork ocorre (soluções triviais perdem estabilidade).",
                                    "Salve soluções Y(λ) para λ próximos a λ_c.",
                                    "Verifique simetria: soluções pares/impares para λ > λ_c."
                                  ],
                                  "verification": "Norma L2 mostra crescimento súbito em λ_c e múltiplas branches.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python estendido com loop sobre λ e arrays para armazenamento.",
                                  "tips": "Continuation evita falhas de convergência; plote norma vs λ intermediariamente.",
                                  "learningObjective": "Explorar bifurcações paramétricas em problemas não lineares.",
                                  "commonMistakes": "Chutes iniciais ruins levando a não-convergência; ignorar branches múltiplas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar Soluções e Analisar Bifurcações",
                                  "subSteps": [
                                    "Plote y(x) para λ < λ_c (trivial), λ=λ_c e λ > λ_c (ramificações).",
                                    "Crie diagrama de bifurcação: norma L2 vs λ, marcando branches simétricas.",
                                    "Compare com teoria analítica: λ_c = 1 para linearização.",
                                    "Analise estabilidade via linearização ou eigenvalues da Jacobiana.",
                                    "Documente observações em relatório curto."
                                  ],
                                  "verification": "Plots mostram bifurcação clara; λ_c ≈4 identificado corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matplotlib para plots; PDF ou Markdown para relatório.",
                                  "tips": "Use subplots para múltiplas visualizações; legendas claras.",
                                  "learningObjective": "Visualizar e interpretar fenômenos de bifurcação numericamente.",
                                  "commonMistakes": "Escalas erradas nos plots ocultando features; confundir λ_c linear com não linear."
                                }
                              ],
                              "practicalExample": "Implemente em Python para y'' = -y + λ sin(y), y(0)=y(π)=0, h=0.05. Para λ=1, solução trivial y≈0; para λ=6, observe ramificações com máximo y(π/2)≈1.5 e -1.5. Diagrama de bifurcação revela pitchfork em λ_c≈4.",
                              "finalVerifications": [
                                "Sistema discretizado F(Y)=0 correto para N=20.",
                                "Newton converge em <10 iterações para λ até 8.",
                                "Norma L2 vs λ mostra bifurcação em λ_c≈4.",
                                "Plots de y(x) exibem simetria e crescimento pós-bifurcação.",
                                "Jacobiana em λ_c tem zero eigenvalue confirmando bifurcação.",
                                "Continuation bem-sucedida sem falhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da discretização (erro O(h²) verificado).",
                                "Convergência robusta do Newton para faixa de λ.",
                                "Identificação correta de λ_c e tipo de bifurcação.",
                                "Qualidade dos plots (clareza, legendas, escalas).",
                                "Análise qualitativa alinhada com teoria.",
                                "Eficiência computacional (tempo <5s por λ)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelos de buckling de vigas ou pêndulos invertidos.",
                                "Computação: Algoritmos numéricos e programação científica.",
                                "Engenharia: Análise de estabilidade em estruturas não lineares.",
                                "Estatística: Análise de sensibilidade paramétrica."
                              ],
                              "realWorldApplication": "Simulação de instabilidades em engenharia estrutural, como colapso de pontes por buckling não linear, ou dinâmica de fluidos com bifurcações em escoamentos (ex: von Kármán street), permitindo prever pontos críticos de falha via varredura paramétrica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Introdução aos Métodos Pseudoespectrais",
                    "description": "Abordagem baseada em expansão em polinômios e interpolação para solução eficiente de BVPs.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Expansão em Polinômios Ortogonais",
                        "description": "Fundamentos das expansões espectrais utilizando polinômios ortogonais, como os de Chebyshev ou Legendre, para representar soluções de equações diferenciais em problemas de valor de contorno (BVPs).",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Identificar polinômios ortogonais comuns",
                            "description": "Reconhecer e descrever polinômios de Chebyshev e Legendre, suas propriedades de ortogonalidade no intervalo [-1,1] e sua relevância para aproximações espectrais em BVPs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Polinômios Ortogonais",
                                  "subSteps": [
                                    "Defina polinômios ortogonais como uma família de polinômios onde o produto interno ∫ p_m(x) p_n(x) w(x) dx = 0 para m ≠ n.",
                                    "Explique o peso w(x) e o intervalo comum [-1,1].",
                                    "Discuta a importância da ortogonalidade em expansões de séries.",
                                    "Identifique exemplos clássicos: Legendre, Chebyshev, Hermite.",
                                    "Revise o produto interno em espaços L2."
                                  ],
                                  "verification": "Escreva uma definição precisa e liste 3 famílias comuns com seus intervalos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Burden & Faires), calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Use analogia com vetores ortogonais para visualizar.",
                                  "learningObjective": "Entender o conceito base de ortogonalidade em polinômios.",
                                  "commonMistakes": "Confundir ortogonalidade com normalização; lembre que ortogonais podem não ser normados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Polinômios de Chebyshev",
                                  "subSteps": [
                                    "Recorde a fórmula recursiva: T_0(x)=1, T_1(x)=x, T_{n+1}(x)=2x T_n(x) - T_{n-1}(x).",
                                    "Gere os primeiros 5 polinômios: T0 a T4.",
                                    "Descreva o peso w(x) = 1/sqrt(1-x^2) no [-1,1].",
                                    "Verifique ortogonalidade computando ∫_{-1}^1 T_m T_n / sqrt(1-x^2) dx.",
                                    "Note propriedades: raízes em cos((2k-1)π/(2n)), minimax."
                                  ],
                                  "verification": "Compute manualmente T2(x) e T3(x), e esboce-os.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, software de plotagem (Matplotlib ou Desmos), tabela de Chebyshev.",
                                  "tips": "Use identidade trigonométrica T_n(cos θ) = cos(nθ) para simplificar integrais.",
                                  "learningObjective": "Reconhecer e gerar polinômios de Chebyshev com suas propriedades.",
                                  "commonMistakes": "Esquecer o fator 2 na recursão; pratique com n=2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar Polinômios de Legendre",
                                  "subSteps": [
                                    "Lembre a fórmula recursiva: P_0=1, P_1=x, (n+1)P_{n+1} = (2n+1)x P_n - n P_{n-1}.",
                                    "Gere P0 a P3 explicitamente.",
                                    "Identifique peso w(x)=1 no [-1,1].",
                                    "Verifique ∫_{-1}^1 P_m P_n dx = 2/(2n+1) δ_{mn}.",
                                    "Discuta raízes de Gauss-Legendre para quadratura numérica."
                                  ],
                                  "verification": "Escreva P2(x) e compute ∫ P1 P2 dx = 0.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabela de Legendre, SymPy para integrais, software de graficação.",
                                  "tips": "Normalização: ∫ P_n^2 dx = 2/(2n+1); memorize para n=0,1.",
                                  "learningObjective": "Dominar geração e ortogonalidade de Legendre.",
                                  "commonMistakes": "Confundir recursão de Chebyshev com Legendre; coeficientes diferem."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar à Ortogonalidade e Aproximações Espectrais em BVPs",
                                  "subSteps": [
                                    "Prove ortogonalidade via recursão ou Rodrigues formula.",
                                    "Explique uso em métodos pseudoespectrais: expansão u(x) ≈ ∑ c_k φ_k(x).",
                                    "Descreva para BVPs: projeção em espaço de polinômios, collocation em raízes.",
                                    "Compare Chebyshev (Gauss-Lobatto) vs Legendre (Gauss) pontos.",
                                    "Discuta convergência exponencial para soluções suaves."
                                  ],
                                  "verification": "Descreva como expandir uma função f(x)=x^2 em base Chebyshev até n=2.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Artigos sobre métodos espectrais (ex: Trefethen), código Python para expansão.",
                                  "tips": "Implemente uma expansão simples em Python para visualizar coeficientes.",
                                  "learningObjective": "Ligar polinômios a aplicações em problemas de valor de contorno.",
                                  "commonMistakes": "Ignorar mapeamento de intervalos; BVPs podem ser [a,b], use mudança de variável."
                                }
                              ],
                              "practicalExample": "Dado f(x) = sin(πx) em [-1,1], expanda em série de Chebyshev até T3: calcule c_k = (2/π) ∫ f T_k / sqrt(1-x^2) dx, plote aproximação e erro.",
                              "finalVerifications": [
                                "Liste fórmulas recursivas para Chebyshev e Legendre.",
                                "Compute ∫_{-1}^1 T_1 T_2 / sqrt(1-x^2) dx = 0.",
                                "Esboce P2(x) e T2(x), identificando diferenças.",
                                "Explique por que Chebyshev é preferido em aproximações minimax.",
                                "Descreva um BVP resolvido via expansão espectral.",
                                "Gere T4(x) e verifique T4(0)=1."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de polinômios (erro <5% em coeficientes recursivos).",
                                "Correta demonstração de ortogonalidade via integral numérica (erro <1e-6).",
                                "Explicação clara da relevância em pseudoespectrais (3 pontos chave).",
                                "Identificação correta de pesos e intervalos para cada família.",
                                "Aplicação prática: expansão de função com plot de convergência.",
                                "Comparação qualitativa Chebyshev vs Legendre em estabilidade numérica."
                              ],
                              "crossCurricularConnections": [
                                "Física: Polinômios de Legendre em harmonia esférica (eletromagnetismo).",
                                "Engenharia: Chebyshev em filtros digitais e otimização.",
                                "Computação: Algoritmos FFT para transformadas espectrais rápidas.",
                                "Estatística: Quadratura Gauss para integração numérica em ML."
                              ],
                              "realWorldApplication": "Em simulações CFD (dinâmica de fluidos computacional), métodos pseudoespectrais com Chebyshev resolvem equações de Navier-Stokes em domínios periódicos, oferecendo alta precisão com poucos graus de liberdade para previsão de turbulência em aviação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Calcular coeficientes de expansão",
                            "description": "Determinar os coeficientes de uma expansão espectral a partir de uma função dada, utilizando integrais de projeção ou somas discretas baseadas em quadratura Gauss.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a base ortogonal e preparar a função alvo",
                                  "subSteps": [
                                    "Selecionar a família de polinômios ortogonais apropriada (ex.: Legendre, Chebyshev, Fourier) com base no domínio e peso da função.",
                                    "Definir o intervalo de expansão e o grau máximo N dos polinômios a usar.",
                                    "Normalizar ou pré-processar a função f(x) para garantir compatibilidade com a base ortogonal.",
                                    "Listar as propriedades de ortogonalidade relevantes (integral do produto zero para i ≠ j)."
                                  ],
                                  "verification": "Verificar se a base está corretamente listada e a função é contínua no domínio escolhido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, tabela de polinômios ortogonais, software como Python (NumPy/SciPy).",
                                  "tips": "Comece com bases familiares como Legendre para [-1,1] para evitar erros de domínio.",
                                  "learningObjective": "Compreender a escolha da base ortogonal e preparação da função para projeção.",
                                  "commonMistakes": "Escolher base errada para o domínio (ex.: Fourier em intervalo finito sem periodicidade)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o método de projeção: integral ou quadratura Gauss",
                                  "subSteps": [
                                    "Decidir entre integral analítica exata ou aproximação discreta via quadratura Gauss.",
                                    "Para integral: Escrever a fórmula c_k = ∫ f(x) φ_k(x) w(x) dx / ∫ φ_k² w dx.",
                                    "Para Gauss: Definir nós e pesos da quadratura Gauss associada à base (ex.: Gauss-Legendre).",
                                    "Implementar discretização se numérica: c_k ≈ Σ f(x_i) φ_k(x_i) w_i."
                                  ],
                                  "verification": "Confirmar que os nós/pesos da quadratura coincidem com a ordem N escolhida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabelas de quadratura Gauss, calculadora ou código Python/MATLAB para nós/pesos.",
                                  "tips": "Use funções prontas como numpy.polynomial.legendre.leggauss(N) para agilizar.",
                                  "learningObjective": "Dominar a formulação matemática da projeção ortogonal.",
                                  "commonMistakes": "Confundir pesos da quadratura com os da ortogonalidade ou usar ordem insuficiente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os coeficientes de expansão",
                                  "subSteps": [
                                    "Computar cada c_k para k=0 a N usando a fórmula escolhida.",
                                    "Para método integral: Avaliar integrais numericamente se necessário (ex.: via SciPy.integrate).",
                                    "Para método discreto: Montar a matriz de valores φ_k(x_i) e multiplicar pelo vetor f(x_i) w_i.",
                                    "Armazenar coeficientes em array e plotar para inspeção visual inicial.",
                                    "Verificar normalização: |c_k| deve decair para bases adequadas."
                                  ],
                                  "verification": "Coeficientes devem satisfazer soma de resíduos quadrático pequeno (erro de projeção).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software numérico (Python com SciPy/NumPy, MATLAB), planilha para casos simples.",
                                  "tips": "Automatize com loop em código para N grande; teste com N baixo primeiro.",
                                  "learningObjective": "Executar computação precisa dos coeficientes.",
                                  "commonMistakes": "Índices errados em loops ou divisão por norma zero (polinômios mal normalizados)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e reconstruir a expansão",
                                  "subSteps": [
                                    "Reconstruir aproximação S_N(x) = Σ c_k φ_k(x).",
                                    "Calcular erro L2: ∫ (f(x) - S_N(x))² dx ou norma discreta.",
                                    "Plotar f(x) vs S_N(x) e analisar convergência variando N.",
                                    "Verificar ortogonalidade: Σ c_k c_m δ_{km} ≈ normas esperadas."
                                  ],
                                  "verification": "Erro L2 < 1e-6 para N adequado e função suave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de plotagem (Matplotlib, MATLAB), métricas de erro implementadas.",
                                  "tips": "Use truncamento suave (ex.: c_k * exp(-k²/σ)) para visualizações.",
                                  "learningObjective": "Avaliar precisão da expansão espectral.",
                                  "commonMistakes": "Ignorar Gibbs phenomenon em funções descontínuas ou N baixo."
                                }
                              ],
                              "practicalExample": "Expanda f(x) = sin(πx) em polinômios de Legendre no intervalo [-1,1] até N=10 usando quadratura Gauss-Legendre. Compute c_k, reconstrua e plote erro L2 ≈ 1e-8.",
                              "finalVerifications": [
                                "Coeficientes c_k decaem monotonicamente para função suave.",
                                "Reconstrução S_N(x) sobrepõe f(x) visualmente.",
                                "Erro L2 diminui com N crescente.",
                                "Ortogonalidade: produto interno entre modos distintos é zero dentro de tolerância numérica.",
                                "Consistência entre métodos integral e Gauss para N alto."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes (erro < 1e-10 para casos exatos).",
                                "Correta implementação de quadratura (nós/pesos validados).",
                                "Análise de convergência documentada.",
                                "Código limpo e comentado com reprodutibilidade.",
                                "Interpretação física/matemática dos resultados.",
                                "Tratamento de casos edge (ex.: funções singulares)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Expansões em séries de Fourier para equações de onda.",
                                "Engenharia: Simulações CFD usando métodos espectrais.",
                                "Computação Científica: Otimização em bibliotecas como deal.II ou Dedalus.",
                                "Estatística: Análise de componentes principais (PCA) como projeção ortogonal."
                              ],
                              "realWorldApplication": "Em modelagem climática, coeficientes espectrais aceleram soluções de PDEs em esferas (ex.: previsão de padrões atmosféricos); em aeroespacial, otimizam controle de turbulência via simulações DNS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Avaliar séries espectrais truncadas",
                            "description": "Implementar a avaliação numérica de uma soma finita de polinômios ortogonais para aproximar funções suaves em domínios finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar base de polinômios ortogonais e preparar a função alvo",
                                  "subSteps": [
                                    "Escolha uma família de polinômios ortogonais adequada ao domínio finito, como Legendre para [-1,1] ou Chebyshev para [-1,1].",
                                    "Defina a função suave f(x) a ser aproximada, garantindo que ela seja contínua e diferenciável no domínio.",
                                    "Normalice o domínio da função para coincidir com o intervalo dos polinômios (ex: mapear [a,b] para [-1,1]).",
                                    "Implemente ou importe funções para gerar os polinômios ortogonais até um grau máximo N.",
                                    "Teste a geração de polinômios para graus baixos (N=0 a 5) em pontos de amostra."
                                  ],
                                  "verification": "Verifique se os polinômios gerados satisfazem a ortogonalidade integrando produtos em pontos Gauss-Lobatto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy e SciPy (special.legendre ou cheb), editor de código",
                                  "tips": "Use pontos de Gauss para integração precisa ao testar ortogonalidade.",
                                  "learningObjective": "Compreender a escolha de bases ortogonais e preparação de funções para aproximação espectral.",
                                  "commonMistakes": "Escolher base inadequada ao domínio (ex: Fourier em domínio finito sem periodicidade); não normalizar o domínio corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular coeficientes espectrais via projeção",
                                  "subSteps": [
                                    "Defina uma grade de pontos de quadratura, como nós de Gauss-Lobatto associados aos polinômios.",
                                    "Avalie f(x) e os polinômios P_k(x) nos pontos de quadratura.",
                                    "Compute os coeficientes c_k = (∫ f P_k dx) / ||P_k||^2 usando soma de quadratura nos pontos.",
                                    "Calcule coeficientes para k=0 até N, onde N é um grau inicial alto (ex: 20).",
                                    "Plote os coeficientes c_k para observar decaimento espectral."
                                  ],
                                  "verification": "Confirme que os coeficientes decaem monotonicamente para funções suaves.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy (quadratura gaussiana), Matplotlib para plots",
                                  "tips": "Use pesos de quadratura exatos para evitar erros de integração.",
                                  "learningObjective": "Dominar o cálculo de projeções L2 para obter modos espectrais.",
                                  "commonMistakes": "Usar integração trapezoidal em vez de Gauss (baixa precisão); ignorar normalização dos polinômios."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Truncar a série e formar a aproximação espectral",
                                  "subSteps": [
                                    "Escolha o grau de truncamento M << N baseado no decaimento dos coeficientes (ex: onde |c_k| < 1e-10).",
                                    "Forme a série truncada S_M(x) = sum_{k=0}^M c_k P_k(x).",
                                    "Implemente uma função para avaliar S_M(x) em uma grade uniforme de pontos de saída.",
                                    "Otimize o código vetorizando a avaliação com broadcasting NumPy.",
                                    "Compare visualmente f(x) vs S_M(x) em plot."
                                  ],
                                  "verification": "Erro máximo em grade de teste < 1e-8 para M adequado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy, Matplotlib",
                                  "tips": "Escolha M dinamicamente baseado em tolerância de erro espectral.",
                                  "learningObjective": "Aprender a truncar séries para equilíbrio precisão-eficiência.",
                                  "commonMistakes": "Truncar prematuramente (M baixo, alta oscilação Gibbs); avaliação ineficiente em loop."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar numericamente e analisar convergência",
                                  "subSteps": [
                                    "Gere grades de avaliação fina (ex: 1000 pontos) para f(x) e S_M(x).",
                                    "Compute métricas de erro: L2, L-infinito, e erro relativo.",
                                    "Teste convergência variando M e plote erro vs M (deve ser exponencial).",
                                    "Implemente avaliação em domínios não padrão via mapeamento afim.",
                                    "Documente o código com comentários e gere relatório de precisão."
                                  ],
                                  "verification": "Curva de convergência mostra taxa espectral (erro ~ exp(-M)).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/Matplotlib, Jupyter Notebook para relatórios",
                                  "tips": "Use log-plot para visualizar decaimento exponencial claramente.",
                                  "learningObjective": "Avaliar qualidade da aproximação espectral e diagnosticar problemas.",
                                  "commonMistakes": "Grade de saída grosseira mascara erros; não testar múltiplos M."
                                }
                              ],
                              "practicalExample": "Aproxime f(x) = sin(π x) no domínio [-1,1] usando polinômios de Legendre truncados em M=10. Compute coeficientes em 21 pontos Gauss-Lobatto, avalie em 1000 pontos uniformes e verifique erro L∞ < 1e-10.",
                              "finalVerifications": [
                                "Coeficientes espectrais decaem exponencialmente para funções suaves.",
                                "Aproximação S_M(x) coincide visualmente com f(x) em plots.",
                                "Erro L2 e L∞ diminuem com M crescente.",
                                "Código avalia S_M(x) em <1s para N=50 em grade de 1000 pontos.",
                                "Testes em múltiplas funções (ex: exp(x), cos(x)) confirmam generalidade.",
                                "Mapeamento afim funciona para domínios arbitrários [a,b]."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro L∞ < 1e-8 para M=15 em funções suaves padrão.",
                                "Eficiência: Tempo de avaliação O(M * pontos) com vetorização.",
                                "Correção: Ortogonalidade preservada (integral produtos ~0 para k≠l).",
                                "Robustez: Código lida com diferentes bases (Legendre/Chebyshev).",
                                "Documentação: Função bem comentada com exemplos de uso.",
                                "Convergência: Demonstração gráfica de erro exponencial vs M."
                              ],
                              "crossCurricularConnections": [
                                "Física: Solução espectral de equações diferenciais em mecânica quântica.",
                                "Engenharia Computacional: Simulações CFD com métodos pseudoespectrais.",
                                "Ciência de Dados: Compressão de sinais via bases ortogonais (PCA espectral).",
                                "Processamento de Sinais: Filtros digitais baseados em séries truncadas."
                              ],
                              "realWorldApplication": "Em simulações numéricas de dinâmica de fluidos (Navier-Stokes via métodos espectrais em SPHINX/GEM), processamento de imagens médicas para reconstrução suave de dados ruidosos, e modelagem climática para aproximação de campos geofísicos em domínios esféricos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Interpolação Espectral e Pontos de Colocação",
                        "description": "Técnicas de interpolação em bases espectrais usando pontos específicos, como os de Chebyshev-Gauss-Lobatto, para discretizar BVPs de forma eficiente.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Definir pontos de Chebyshev-Gauss-Lobatto",
                            "description": "Explicar a distribuição dos pontos de colocação nos extremos do intervalo e sua importância para minimizar o erro de Runge na interpolação polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Polinômios de Chebyshev e Interpolação Polinomial Básica",
                                  "subSteps": [
                                    "Estude a definição dos polinômios de Chebyshev de primeira e segunda espécie.",
                                    "Revise o processo de interpolação polinomial em intervalos [-1,1].",
                                    "Entenda o mapeamento de Chebyshev: x_k = cos(π k / N) para pontos equidistantes no círculo unitário.",
                                    "Discuta limitações da interpolação em pontos equidistantes (erro de Runge).",
                                    "Pratique derivando os nós de Chebyshev extremos."
                                  ],
                                  "verification": "Resuma em 3 frases os polinômios de Chebyshev e liste 2 limitações da interpolação equidistante.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Notebook Jupyter com NumPy/Matplotlib",
                                    "Notas de aula sobre interpolação"
                                  ],
                                  "tips": "Use animações online para visualizar o oscilamento de Runge.",
                                  "learningObjective": "Compreender a base teórica dos polinômios de Chebyshev como ortogonais em [-1,1].",
                                  "commonMistakes": [
                                    "Confundir Chebyshev de 1ª e 2ª espécie",
                                    "Ignorar o peso w(x) = 1/sqrt(1-x²)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente os Pontos de Chebyshev-Gauss-Lobatto",
                                  "subSteps": [
                                    "Memorize a fórmula: μ_k = cos(π k / N) para k = 0,1,...,N nos extremos [-1,1].",
                                    "Derive a origem trigonométrica a partir da projeção no círculo unitário.",
                                    "Calcule manualmente para N=4: liste os 5 pontos exatos.",
                                    "Compare com pontos Gauss-Lobatto tradicionais (diferença nos pesos).",
                                    "Implemente uma função Python para gerar os pontos para N arbitrário."
                                  ],
                                  "verification": "Gere e liste os pontos CGL para N=6; confirme que incluem ±1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python (numpy.cos)",
                                    "Papel e lápis para cálculos manuais",
                                    "Referência: Trefethen 'Spectral Methods in MATLAB'"
                                  ],
                                  "tips": "Lembre-se: N+1 pontos para grau N; extremos garantem estabilidade.",
                                  "learningObjective": "Definir precisamente os pontos CGL e implementá-los computacionalmente.",
                                  "commonMistakes": [
                                    "Esquecer k=0 e k=N (extremos)",
                                    "Usar sin em vez de cos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Distribuição dos Pontos e Clustering nos Extremos",
                                  "subSteps": [
                                    "Plote os pontos CGL para N=10,20 usando Matplotlib.",
                                    "Meça a densidade: observe aglomeração perto de x=±1 via histograma ou zoom.",
                                    "Explique matematicamente: derivada dx/dθ = -sin(θ) → zeros nos pólos.",
                                    "Compare plots com pontos equidistantes para visualizar diferença.",
                                    "Calcule distâncias entre pontos consecutivos para N=8."
                                  ],
                                  "verification": "Crie um gráfico mostrando clustering; descreva qualitativamente a distribuição.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com Matplotlib/NumPy",
                                    "Software de plotagem (ex: Desmos ou MATLAB)"
                                  ],
                                  "tips": "Use log-scale no eixo y para distâncias entre pontos.",
                                  "learningObjective": "Visualizar e quantificar o agrupamento nos extremos do intervalo.",
                                  "commonMistakes": [
                                    "Pensar que são uniformes; ignorar transformação arc-cos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar a Importância para Minimizar o Erro de Runge",
                                  "subSteps": [
                                    "Revise o fenômeno de Runge: oscilações grandes nos extremos para interpolação equidistante.",
                                    "Demonstre numericamente: interpole runge(x)=1/(1+25x²) em pontos CGL vs. equidistantes.",
                                    "Analise o erro máximo: ||f - P||_∞ reduzido devido à distribuição.",
                                    "Discuta propriedades espectrais: base de Chebyshev minimiza Lebesgue constant.",
                                    "Conclua com teorema: CGL otimiza para pseudoespectrais."
                                  ],
                                  "verification": "Compare erros L∞ para N=16 em ambos os esquemas; mostre redução >50%.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python pronto para Runge (NumPy polyfit ou chebfun)",
                                    "Artigo sobre constante de Lebesgue"
                                  ],
                                  "tips": "Use polyval para avaliação; normalize erros.",
                                  "learningObjective": "Relacionar distribuição CGL à redução do erro de Runge na interpolação.",
                                  "commonMistakes": [
                                    "Atribuir redução só aos extremos, ignorar ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em um Contexto Pseudoespectral Simples",
                                  "subSteps": [
                                    "Implemente interpolação espectral básica usando CGL para uma função suave.",
                                    "Resolva um problema de valor inicial simples (ex: d²u/dx² = -π² sin(πx)).",
                                    "Calcule coeficientes Chebyshev via DFT ou integração quadratura.",
                                    "Verifique precisão vs. método de diferenças finitas.",
                                    "Documente o código com comentários sobre CGL."
                                  ],
                                  "verification": "Execute código e obtenha erro <1e-10 para N=32.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Biblioteca Spectral (ou código custom)",
                                    "Exemplos de Trefethen Capítulo 2"
                                  ],
                                  "tips": "Comece com Dirichlet homogêneo para simplicidade.",
                                  "learningObjective": "Integrar CGL em um método pseudoespectral básico.",
                                  "commonMistakes": [
                                    "Índices errados em expansão (paridade)",
                                    "Não diferenciar D1 vs. D2 matrizes"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule e plote os pontos CGL para N=10 no intervalo [-1,1]. Interpole f(x) = 1/(1+25x²) usando Lagrange em CGL vs. equidistantes. Meça o erro máximo: espere ~0.001 para CGL vs. ~0.3 para equidistantes, demonstrando minimização de Runge.",
                              "finalVerifications": [
                                "Lista corretamente a fórmula μ_k = cos(π k / N) para k=0 a N.",
                                "Explica clustering nos extremos via transformação trigonométrica.",
                                "Demonstra redução do erro de Runge com plot comparativo.",
                                "Implementa código Python gerando pontos e interpolação precisa.",
                                "Descreve aplicação em métodos espectrais para BVP.",
                                "Identifica CGL como nós de extrema estabilidade espectral."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e fórmula (100% match).",
                                "Compreensão qualitativa da distribuição (descrição + plot).",
                                "Análise quantitativa do erro de Runge (cálculo + comparação).",
                                "Implementação funcional de código (erro <1e-8).",
                                "Conexão clara com interpolação espectral.",
                                "Criatividade em exemplo prático além do Runge padrão."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Pontos CGL em simulações de PDEs (ex: Navier-Stokes).",
                                "Programação Numérica: Implementação em Python/MATLAB para métodos espectrais.",
                                "Engenharia: Otimização em controle e aerodinâmica via expansão espectral.",
                                "Estatística: Quadratura Gauss-Lobatto para integração numérica de alta ordem."
                              ],
                              "realWorldApplication": "Em simulações climáticas e CFD (ex: modelo ECMWF usa espectrais com CGL para discretizar esferas), minimizando erros em domínios irregulares; acelera convergência em previsão de tempo e design de turbinas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Construir interpolante espectral",
                            "description": "Construir um interpolante polinomial de grau N em pontos espectrais a partir de valores amostrados, utilizando a transformada discreta de Chebyshev.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e gerar pontos espectrais de Chebyshev",
                                  "subSteps": [
                                    "Defina o intervalo de interpolação, tipicamente [-1, 1].",
                                    "Escolha o grau N do polinômio (número de pontos M = N+1).",
                                    "Gere os pontos de Chebyshev-Gauss-Lobatto: x_k = cos(π k / N) para k = 0 a N.",
                                    "Armazene os pontos em um vetor ordenado.",
                                    "Visualize os pontos para confirmar distribuição (mais densos nas extremidades)."
                                  ],
                                  "verification": "Verifique se os pontos estão corretamente espaçados e incluem as extremidades x=±1; plote-os em um gráfico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Biblioteca NumPy (Python)",
                                    "Matplotlib para plotagem",
                                    "Documentação de pontos de Chebyshev"
                                  ],
                                  "tips": "Use np.cos(np.pi * np.arange(N+1) / N) para eficiência.",
                                  "learningObjective": "Compreender a importância dos pontos de Chebyshev para minimizar o fenômeno de Runge.",
                                  "commonMistakes": [
                                    "Usar pontos equidistantes em vez de Chebyshev",
                                    "Esquecer de ordenar os pontos",
                                    "Confundir Gauss-Lobatto com Gauss."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Amostrar a função nos pontos espectrais",
                                  "subSteps": [
                                    "Defina a função f(x) a ser interpolada (ex: f(x) = sin(π x)).",
                                    "Avalie f(x_k) em cada ponto x_k gerado.",
                                    "Armazene os valores amostrados em um vetor f_vals.",
                                    "Trate possíveis singularidades ou descontinuidades na função.",
                                    "Plote f(x_k) vs x_k para inspeção visual."
                                  ],
                                  "verification": "Confirme que f_vals tem comprimento N+1 e valores corretos comparando com avaliações manuais em pontos selecionados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NumPy para avaliação vetorial",
                                    "Função de teste conhecida (ex: sin, exp)"
                                  ],
                                  "tips": "Use avaliação vetorial para velocidade: f_vals = f(x_points).",
                                  "learningObjective": "Aplicar amostragem em nós espectrais para preparar dados para transformada.",
                                  "commonMistakes": [
                                    "Avaliar fora do intervalo [-1,1]",
                                    "Índices errados no vetor",
                                    "Não tratar NaNs em funções problemáticas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar coeficientes via Transformada Discreta de Chebyshev (DCT)",
                                  "subSteps": [
                                    "Aplique a DCT tipo II nos valores amostrados f_vals para obter coeficientes âncos c_k.",
                                    "Use fórmula: c_0 = (1/N) sum f(x_k), c_k = (2/N) sum f(x_k) cos(π k j / N) para k=1..N.",
                                    "Implemente ou use biblioteca (scipy.fft.dct com type=2, norm='ortho').",
                                    "Normalize corretamente (fator 1/2 para k>0).",
                                    "Verifique truncamento de coeficientes altos para suavidade."
                                  ],
                                  "verification": "Compare coeficientes computados com fórmula analítica para funções conhecidas (ex: T_n(x)).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SciPy (fft.dct)",
                                    "Papel e lápis para derivar fórmula manualmente"
                                  ],
                                  "tips": "SciPy dct é otimizada; ajuste norm='ortho' para coeficientes padrão.",
                                  "learningObjective": "Dominar a DCT como base para expansão em séries de Chebyshev.",
                                  "commonMistakes": [
                                    "Tipo errado de DCT (use type=2)",
                                    "Falta de normalização",
                                    "Índices off-by-one em somas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconstruir e avaliar o interpolante polinomial",
                                  "subSteps": [
                                    "Use os coeficientes c_k para formar P(x) = sum c_k T_k(x), onde T_k são polinômios de Chebyshev.",
                                    "Avalie P(x) em pontos de teste (incluindo nós originais).",
                                    "Implemente avaliação via IDCT ou recorrência de Clenshaw.",
                                    "Calcule erro de interpolação: ||f(x) - P(x)|| em grade fina.",
                                    "Plote f(x) vs P(x) para visualização."
                                  ],
                                  "verification": "Erro nos nós deve ser zero (up to numerical precision); erro global pequeno para N adequado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "SciPy (chebval para avaliação)",
                                    "NumPy para grade de teste"
                                  ],
                                  "tips": "Use chebval(c, x) do numpy.polynomial.chebyshev para eficiência.",
                                  "learningObjective": "Construir e validar o interpolante espectral completo.",
                                  "commonMistakes": [
                                    "Avaliação direta via soma lenta para alto N",
                                    "Não verificar interpolação exata nos nós",
                                    "Escala errada no plot."
                                  ]
                                }
                              ],
                              "practicalExample": "Para interpolar f(x) = exp(x) em [-1,1] com N=16: Gere 17 pontos Chebyshev, amostre f(x_k), aplique DCT para c_k, reconstrua P(x) via chebval e plote erro máximo <1e-10 nos nós.",
                              "finalVerifications": [
                                "P(x_k) == f(x_k) para todos k (erro <1e-12).",
                                "Coeficientes c_k decrescem rapidamente para funções suaves.",
                                "Erro de interpolação em grade de 1000 pontos <1e-8.",
                                "Tempo de computação O(N log N) via FFT-based DCT.",
                                "Visualização confirma convergência espectral.",
                                "Teste com função analítica: norma L2 do erro.",
                                "Estabilidade numérica: variação <1e-14 em recomputações."
                              ],
                              "assessmentCriteria": [
                                "Precisão da interpolação nos nós espectrais (exata).",
                                "Eficiência algorítmica (uso de DCT O(N log N)).",
                                "Correta normalização dos coeficientes Chebyshev.",
                                "Tratamento de casos de borda (N=1, funções pares/ímpares).",
                                "Qualidade da visualização e análise de erro.",
                                "Generalização para diferentes funções e intervalos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Solução de EDOs em métodos pseudoespectrais (ex: equação do calor).",
                                "Computação: Algoritmos FFT e processamento de sinais.",
                                "Engenharia: Compressão de dados via séries de Chebyshev.",
                                "Estatística: Aproximação de funções de densidade."
                              ],
                              "realWorldApplication": "Em simulações numéricas de fluidodinâmica (CFD), onde interpolantes espectrais permitem resolver PDEs com alta precisão e custo computacional baixo, como em previsão de turbulência ou propagação de ondas em oceanos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Analisar convergência da interpolação",
                            "description": "Demonstrar a convergência exponencial da interpolação espectral para funções analíticas e identificar casos de aliasing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos da interpolação espectral e pontos de colocação",
                                  "subSteps": [
                                    "Estudar a definição de interpolação espectral usando polinômios de Chebyshev ou Legendre.",
                                    "Explicar os pontos de colocação (ex: Gauss-Lobatto) e suas propriedades de estabilidade.",
                                    "Derivar a fórmula de interpolação espectral para uma função f(x) em N+1 pontos.",
                                    "Implementar uma função simples em Python/MATLAB para calcular coeficientes espectrais.",
                                    "Visualizar os pontos de colocação e o polinômio interpolante para uma função teste."
                                  ],
                                  "verification": "Gerar um plot comparando f(x) original e interpolante com erro máximo < 1e-3 para N=16.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de análise numérica (Trefethen 'Spectral Methods'), Python com NumPy/SciPy, Jupyter Notebook"
                                  ],
                                  "tips": "Comece com pontos Chebyshev para simplicidade; use funções built-in como chebpts() no Chebfun.",
                                  "learningObjective": "Compreender a base teórica da interpolação espectral e implementá-la computacionalmente.",
                                  "commonMistakes": [
                                    "Confundir pontos de colocação com nós equidistantes",
                                    "Ignorar normalização dos polinômios",
                                    "Não mapear o intervalo [-1,1] corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar medição de erro de interpolação para diferentes N",
                                  "subSteps": [
                                    "Definir uma função analítica suave, como f(x) = exp(x) ou sin(πx), no intervalo [-1,1].",
                                    "Calcular o interpolante espectral para N variando de 8 a 128.",
                                    "Computar o erro máximo e L2 em uma malha fina (ex: 1000 pontos).",
                                    "Armazenar erros em log-escala para análise posterior.",
                                    "Plotar log(|erro|) vs log(N) para observar taxa de convergência."
                                  ],
                                  "verification": "Obter curvas de erro decrescendo monotonicamente com N, salvando plots e dados em arquivo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/MATLAB com bibliotecas numéricas, funções exp/sin built-in"
                                  ],
                                  "tips": "Use np.linspace para malha fina de avaliação; log-space para N evita loops ineficientes.",
                                  "learningObjective": "Medir quantitativamente o erro de interpolação e preparar dados para análise de convergência.",
                                  "commonMistakes": [
                                    "Avaliar erro apenas nos pontos de colocação (runge phenomenon mascarado)",
                                    "Escala errada no plot (use semilogx)",
                                    "Funções não analíticas como teste inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar convergência exponencial para funções analíticas",
                                  "subSteps": [
                                    "Teoricamente derivar ou recordar o teorema de convergência exponencial (erro ~ ρ^{-N}).",
                                    "Ajustar uma reta em log(|erro|) vs N para estimar ρ.",
                                    "Testar múltiplas funções analíticas (ex: exp(x), cos(10x)) e comparar ρ.",
                                    "Analisar como singularidades distantes afetam ρ.",
                                    "Documentar resultados com tabelas e plots semi-log."
                                  ],
                                  "verification": "Identificar declive ≈ -k com k>1 em plot log(er) vs N, confirmando exponencial.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Papel e lápis para teoria, SciPy curve_fit para ajuste linear",
                                    "Gráficos em Matplotlib"
                                  ],
                                  "tips": "Para funções com singularidades conhecidas, calcule distância ao círculo de Bernstein.",
                                  "learningObjective": "Provar empiricamente e teoricamente a convergência exponencial em funções analíticas.",
                                  "commonMistakes": [
                                    "Confundir convergência exponencial com polinomial (inclinação constante vs linear)",
                                    "Poucos pontos N (precisa ≥6 para ajuste)",
                                    "Ignorar normalização de erro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e mitigar casos de aliasing na interpolação",
                                  "subSteps": [
                                    "Explicar aliasing: projeção de altas frequências em baixas devido a amostragem.",
                                    "Testar funções com altas oscilações (ex: sin(20πx)) e observar Gibbs/aliasing.",
                                    "Comparar espectros: FFT da função vs interpolante para detectar aliases.",
                                    "Aplicar filtros (dealiasing via 2/3 rule) e reavaliar convergência.",
                                    "Plotar espectros e erros para before/after."
                                  ],
                                  "verification": "Detectar picos espúrios no espectro e reduzi-los >50% com dealiasing.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "NumPy FFT, exemplos de funções runge-like"
                                  ],
                                  "tips": "Use orq (2/3-rule) truncando modos >2N/3; visualize espectro em log-scale.",
                                  "learningObjective": "Reconhecer aliasing espectral e técnicas de mitigação.",
                                  "commonMistakes": [
                                    "Não distinguir aliasing de Runge",
                                    "FFT sem windowing",
                                    "Testar apenas funções suaves"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente interpolação espectral de f(x)=exp(sin(3x)) em 32 pontos Chebyshev-Lobatto. Compute erro L∞ em malha fina, plote log(er) vs N=8..256 mostrando declive -2.5 (exponencial). Induza aliasing com f(x)=sin(50x), detecte via FFT e aplique 2/3-rule reduzindo erro em 70%.",
                              "finalVerifications": [
                                "Plots de erro mostram convergência exponencial (declive constante em semi-log).",
                                "Espectros FFT identificam aliases corretamente em funções de alta frequência.",
                                "Ajuste linear estima ρ <1 para funções analíticas testadas.",
                                "Dealiasing reduz picos espúrios em >50%.",
                                "Relatório resume teoria, código e resultados com <1e-10 erro para N=64 em exp(x).",
                                "Testes reproduzíveis em código compartilhado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação: erro computacional <1e-12 para N baixo.",
                                "Análise correta de convergência: identificação de taxa exponencial com ρ quantificado.",
                                "Detecção precisa de aliasing via espectros e mitigação eficaz.",
                                "Qualidade de plots e documentação: eixos log corretos, legendas claras.",
                                "Profundidade teórica: citação de teoremas (ex: Bernstein ellipse).",
                                "Generalização: testes em ≥3 funções variadas."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações PDEs espectrais em fluidodinâmica.",
                                "Processamento de Sinais: FFT e aliasing em áudio/imagens digitais.",
                                "Ciência da Computação: algoritmos numéricos e análise de complexidade.",
                                "Estatística: aproximação de funções em regressão não-linear."
                              ],
                              "realWorldApplication": "Em simulações climáticas e aeroespaciais (CFD), análise de convergência espectral garante precisão em soluções de Navier-Stokes; detecção de aliasing previne instabilidades em previsões meteorológicas e processamento de dados sísmicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.4",
                            "name": "Diferenciar numericamente via spectral",
                            "description": "Aplicar diferenciação espectral usando matrizes de derivação pré-computadas para aproximar derivadas de alta ordem em BVPs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da diferenciação espectral",
                                  "subSteps": [
                                    "Estude a base teórica: diferenciação espectral usa expansão em polinômios (ex: Chebyshev) para derivadas precisas.",
                                    "Revise pontos de colocação espectrais, como pontos de Chebyshev-Lobatto.",
                                    "Entenda como matrizes de derivação D1, D2 etc. são pré-computadas para aproximar derivadas.",
                                    "Compare com diferenças finitas: exponencial vs. espectral para alta ordem.",
                                    "Analise a precisão espectral (erro exponencial em N)."
                                  ],
                                  "verification": "Resuma em 3 frases os princípios e resolva um exercício simples de expansão de Taylor espectral.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (Trefethen 'Spectral Methods'), notebook Jupyter.",
                                  "tips": "Visualize graficamente os pontos de Chebyshev para intuição espacial.",
                                  "learningObjective": "Dominar conceitos teóricos da diferenciação espectral e suas vantagens.",
                                  "commonMistakes": "Confundir pontos de Gauss com Chebyshev-Lobatto; ignorar condições de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir matrizes de derivação pré-computadas",
                                  "subSteps": [
                                    "Implemente pontos de Chebyshev-Lobatto: x_j = cos(π j / N), j=0..N.",
                                    "Calcule matriz D1 usando Lagrange ou fórmula analítica de Trefethen.",
                                    "Derive D2 = D1 * D1 e verifique simetria para autoadjunta.",
                                    "Teste em função conhecida: u(x)=sin(πx), verifique Du ≈ π cos(πx).",
                                    "Gere Dk para k até 4 usando potência matricial."
                                  ],
                                  "verification": "Aplique D2 a u(x)=x^2, resultado deve ser 2 em todos pontos internos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy e Matplotlib, código de exemplo de spectral methods.",
                                  "tips": "Use funções prontas como chebdif(N, k) se disponível, mas implemente manualmente primeiro.",
                                  "learningObjective": "Construir e validar matrizes Dk para diferenciação de qualquer ordem.",
                                  "commonMistakes": "Índices errados nos pontos (0 a N); não impor condições de contorno nas bordas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar em problemas de valor de contorno (BVPs)",
                                  "subSteps": [
                                    "Formule BVP: Lu = f, onde L inclui derivadas altas via Dk.",
                                    "Monte sistema linear: A u = b, com A usando D2 + I por exemplo.",
                                    "Incorpore condições de Dirichlet: fixe u_0 = u_N = 0.",
                                    "Resolva com np.linalg.solve e plote solução.",
                                    "Itere com N crescente para observar convergência."
                                  ],
                                  "verification": "Para BVP teste, erro L2 < 1e-10 para N=32.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Jupyter notebook, SciPy para solve, função para erro L2.",
                                  "tips": "Condicione o sistema removendo linhas de contorno e ajustando b.",
                                  "learningObjective": "Resolver BVPs com diferenciação espectral de alta ordem.",
                                  "commonMistakes": "Não tratar singularidade nas bordas; usar solve genérico sem BCs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar precisão e estender para derivadas altas",
                                  "subSteps": [
                                    "Calcule erros para ordens 2,4,6: compare com solução exata.",
                                    "Estude convergência espectral: log(erros) vs. log(N).",
                                    "Aplique a BVP não linear ou com derivadas mistas.",
                                    "Otimize: use FFT para periódica se aplicável.",
                                    "Documente limitações: Gibbs, runge phenomenon."
                                  ],
                                  "verification": "Gere gráfico de convergência exponencial para D4 em polinômio grau 3 (erro zero).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Códigos anteriores, solução analítica de teste.",
                                  "tips": "Use loglog plot para visualizar taxa espectral.",
                                  "learningObjective": "Avaliar e refinar métodos espectrais para alta precisão.",
                                  "commonMistakes": "Atribuir erro numérico à instabilidade espectral; N muito pequeno."
                                }
                              ],
                              "practicalExample": "Resolva o BVP -u''''(x) + u''(x) = π^4 sin(πx) - π^2 sin(πx), u(0)=u'(0)=u(1)=u'(1)=0, usando N=20 pontos Chebyshev. Use D4 e D2 pré-computadas, imponha BCs naturais/integradas. Solução exata: u(x)=sin(πx). Verifique erro máximo <1e-8.",
                              "finalVerifications": [
                                "Implementa corretamente Dk para k=1..4 em N=16 pontos.",
                                "Resolve BVP de 4ª ordem com erro L∞ <1e-10.",
                                "Gera gráfico de convergência log(erros) linear em log(N).",
                                "Explica imposição de BCs de 2ª e 4ª ordem.",
                                "Compara tempo vs. diferenças finitas de ordem alta.",
                                "Identifica e corrige oscilações de Runge."
                              ],
                              "assessmentCriteria": [
                                "Precisão: erro <1e-12 para N=32 em teste suave.",
                                "Eficiência: tempo de setup <1s para N=100.",
                                "Corretude teórica: derivadas de polinômios exatos zero além do grau.",
                                "Flexibilidade: adapta a BCs mistas (Dirichlet/Neumann).",
                                "Análise: relata taxa de convergência observada.",
                                "Código limpo: modular com funções cheb_points(), diff_matrix()."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de vigas (equações de Euler-Bernoulli).",
                                "Engenharia: análise modal em estruturas vibrantes.",
                                "Processamento de Sinais: filtros diferenciais em domínio espectral.",
                                "Ciência de Dados: aproximação de gradientes em ML espectral.",
                                "Matemática Aplicada: métodos para PDEs elípticas."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais para perfis de asas (fluxo incompressível via streamfunction-vorticity), onde derivadas altas capturam vorticidade fina; ou em controle de processos industriais modelados por BVPs de ordem alta."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Formulação e Resolução de BVPs Pseudoespectrais",
                        "description": "Aplicação dos métodos pseudoespectrais à resolução de problemas de valor de contorno, transformando EDOs em sistemas lineares via colocação.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Formular BVP via colocação espectral",
                            "description": "Colocar condições de um BVP de segunda ordem em pontos espectrais, gerando um sistema linear Ax = b onde A incorpora derivadas espectrais e condições de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar o problema BVP de segunda ordem",
                                  "subSteps": [
                                    "Leia e identifique a equação diferencial de segunda ordem na forma u''(x) + p(x)u'(x) + q(x)u(x) = f(x).",
                                    "Anote as condições de contorno, como u(a) = α e u(b) = β ou condições mistas.",
                                    "Defina o intervalo [a, b] e normalize para [-1,1] se usando Chebyshev.",
                                    "Verifique se o problema está bem posto (linear, coeficientes suaves).",
                                    "Esboce uma solução analítica aproximada para referência futura."
                                  ],
                                  "verification": "Lista completa da equação, condições de contorno e intervalo anotada corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Livro de análise numérica ou notas de aula"
                                  ],
                                  "tips": "Sempre normalize o domínio para [-1,1] para facilitar cálculos com polinômios Chebyshev.",
                                  "learningObjective": "Compreender a estrutura padrão de um BVP de segunda ordem e prepará-lo para discretização espectral.",
                                  "commonMistakes": [
                                    "Ignorar coeficientes variáveis p(x) e q(x)",
                                    "Esquecer de mapear condições de contorno para o novo domínio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar pontos espectrais e definir a base de aproximação",
                                  "subSteps": [
                                    "Escolha N+1 pontos espectrais, como nós de Chebyshev: x_k = cos(π k / N), k=0..N.",
                                    "Defina a base espectral, tipicamente polinômios de Chebyshev T_k(x).",
                                    "Construa a matriz de Vandermonde V_{kj} = T_j(x_k) para interpolação.",
                                    "Prepare matrizes de diferenciação espectral D1 e D2 para primeira e segunda derivadas.",
                                    "Teste os pontos em um polinômio simples para validar."
                                  ],
                                  "verification": "Lista de pontos x_k gerada e matriz V montada sem erros numéricos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software como MATLAB/Python (NumPy/SciPy)",
                                    "Documentação de métodos espectrais"
                                  ],
                                  "tips": "Use N ímpar para incluir endpoints e condições de contorno Dirichlet.",
                                  "learningObjective": "Dominar a escolha de pontos colocation e base para alta precisão espectral.",
                                  "commonMistakes": [
                                    "Confundir nós de Chebyshev com Gauss-Lobatto",
                                    "Usar N muito pequeno levando a aliasing"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aproximar a solução e derivadas nos pontos espectrais",
                                  "subSteps": [
                                    "Aproxime u(x) ≈ ∑_{j=0}^N c_j T_j(x), com coeficientes c_j desconhecidos.",
                                    "Compute u'(x_k) ≈ ∑ D1_{kj} c_j e u''(x_k) ≈ ∑ D2_{kj} c_j nos pontos x_k.",
                                    "Avalie p(x_k), q(x_k), f(x_k) nos pontos colocation.",
                                    "Formule as equações residuais: r_k = u''(x_k) + p(x_k)u'(x_k) + q(x_k)u(x_k) - f(x_k) = 0 para k=1..N-1.",
                                    "Verifique precisão em derivadas com um polinômio teste exato."
                                  ],
                                  "verification": "Resíduos r_k computados para uma solução teste são próximos de zero.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB para matrizes D1/D2",
                                    "Biblioteca Chebfun ou pyspect"
                                  ],
                                  "tips": "Pré-compute matrizes D1 e D2 uma vez, pois são independentes do BVP.",
                                  "learningObjective": "Aplicar diferenciação espectral para aproximar derivadas com exponencial de precisão.",
                                  "commonMistakes": [
                                    "Aplicar diferenciação ponto-a-ponto em vez de matricial",
                                    "Incluir pontos de contorno nas equações internas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar condições de contorno e montar o sistema linear Ax = b",
                                  "subSteps": [
                                    "Modifique as linhas k=0 e k=N da matriz A para impor u(x_0)=α e u(x_N)=β: A_{0j}=T_j(x_0), b_0=α.",
                                    "Monte A completa: para linhas internas, A_{kj} = D2_{kj} + p(x_k)D1_{kj} + q(x_k)V_{kj}.",
                                    "Defina vetor b com f(x_k) nas linhas internas e condições nos endpoints.",
                                    "Resolva Ax = b para obter coeficientes c.",
                                    "Valide o sistema testando com solução conhecida."
                                  ],
                                  "verification": "Sistema Ax=b resolvido reproduz solução exata com erro <1e-10.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Solver linear (np.linalg.solve)",
                                    "Exemplo de BVP com solução analítica"
                                  ],
                                  "tips": "Para condições de Neumann, use derivadas nos endpoints com D1.",
                                  "learningObjective": "Formular sistema linear completo que incorpora colocação espectral e contornos.",
                                  "commonMistakes": [
                                    "Sobredeterminar o sistema incluindo contornos nas equações internas",
                                    "Erro de sinal nas condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e refinar a formulação",
                                  "subSteps": [
                                    "Implemente o código completo e teste com BVP modelo.",
                                    "Compute norma do resíduo máximo e erro L2 contra solução exata.",
                                    "Analise convergência variando N.",
                                    "Ajuste para coeficientes não-suaves se necessário.",
                                    "Documente a formulação final."
                                  ],
                                  "verification": "Erro <1e-12 para N=20 em problema teste.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código do passo anterior",
                                    "Gráficos de convergência"
                                  ],
                                  "tips": "Plote u aproximada vs exata para inspeção visual.",
                                  "learningObjective": "Garantir robustez e precisão da formulação espectral.",
                                  "commonMistakes": [
                                    "Não testar com múltiplos N",
                                    "Ignorar runge phenomenon em bases não-espectrais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o BVP -u''(x) + π² u(x) = π² sin(π x), u(-1)=u(1)=0 em [-1,1]. Use N=10 pontos Chebyshev-Lobatto. Monte A com D2 - diag(π²), condições u(-1)=0, u(1)=0. Solução exata: u(x)=sin(π x). O sistema resolve com erro espectral.",
                              "finalVerifications": [
                                "Sistema Ax=b montado corretamente para BVP teste.",
                                "Condições de contorno satisfeitas numericamente (erro <1e-12).",
                                "Resíduo máximo nos pontos internos <1e-10.",
                                "Convergência exponencial ao aumentar N.",
                                "Código reproduzível gera mesma solução.",
                                "Documentação inclui todas as matrizes e vetores."
                              ],
                              "assessmentCriteria": [
                                "Precisão da diferenciação espectral (erro em derivadas teste).",
                                "Correta incorporação de condições de contorno no sistema.",
                                "Eficiência computacional (tempo para N=50 <1s).",
                                "Tratamento de coeficientes variáveis p(x), q(x).",
                                "Análise de erros e convergência documentada.",
                                "Clareza na derivação das equações de colocação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de equações de elastica ou ondas em métodos espectrais.",
                                "Computação Científica: Implementação de solvers paralelizáveis em GPU.",
                                "Engenharia: Simulação de perfis aerodinâmicos via BVPs elípticos.",
                                "Estatística: Análise de processos gaussianos com kernels espectrais."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, formulação espectral de BVPs modela perfis de velocidade em escoamentos incompressíveis, permitindo simulações precisas e rápidas de aerofólios para otimização de aviões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Resolver sistema espectral",
                            "description": "Resolver o sistema linear resultante utilizando decomposição SVD ou pseudoinverso, considerando a singularidade induzida pelas condições de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o sistema linear espectral Ax = b",
                                  "subSteps": [
                                    "Extraia a matriz de diferenciação espectral D2 (segunda derivada) e aplique as condições de contorno para formar A.",
                                    "Inclua o termo de massa ou identidade multiplicada pelo lado direito da equação.",
                                    "Monte o vetor b considerando o termo fonte f discretizado nos pontos de collocation.",
                                    "Verifique as dimensões: A deve ser (N+1) x (N+1) para N pontos internos.",
                                    "Ajuste para condições de contorno homogêneas ou não-homogêneas."
                                  ],
                                  "verification": "Confirme que A é uma matriz quadrada e b é um vetor coluna compatível; imprima shapes no software.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software NumPy/SciPy (Python) ou MATLAB",
                                    "Funções de pontos Chebyshev e diferenciação espectral (cheb.py ou chebfun)"
                                  ],
                                  "tips": "Use pontos de Chebyshev-Gauss-Lobatto para estabilidade; evite pontos equidistantes.",
                                  "learningObjective": "Entender a montagem do sistema linear a partir da discretização pseudoespectral.",
                                  "commonMistakes": [
                                    "Esquecer de impor condições de contorno na matriz A",
                                    "Erro na indexação dos pontos de collocation",
                                    "Não discretizar corretamente o termo fonte f"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e analisar a singularidade da matriz A",
                                  "subSteps": [
                                    "Calcule o determinante ou condição number de A para confirmar singularidade.",
                                    "Explique a origem: condições de contorno induzem kernel não-trivial (modos constantes ou lineares).",
                                    "Verifique o rank de A usando SVD parcial.",
                                    "Projete b no espaço ortogonal ao kernel de A para garantir solvibilidade.",
                                    "Identifique os valores singulares próximos de zero."
                                  ],
                                  "verification": "Rank(A) < N+1 e ||P b|| pequeno onde P é projetor no kernel.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Funções np.linalg.cond() ou svdvals() no NumPy",
                                    "Documentação de análise de matrizes singulares"
                                  ],
                                  "tips": "Para BVPs homogêneos, singularidade é esperada; use tolerância 1e-12 para singulares.",
                                  "learningObjective": "Reconhecer singularidades induzidas por condições de contorno em métodos espectrais.",
                                  "commonMistakes": [
                                    "Ignorar singularidade e usar inversa direta",
                                    "Confundir rank com dimensão da matriz",
                                    "Não verificar compatibilidade de b"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar decomposição SVD e pseudoinverso",
                                  "subSteps": [
                                    "Execute SVD: A = U Σ V^H, obtendo matrizes U, Σ (diagonal), V.",
                                    "Inverta os valores singulares não-nulos: Σ+ com 1/σ_i para σ_i > tol.",
                                    "Forme o pseudoinverso A+ = V Σ+ U^H.",
                                    "Ajuste tolerância baseada em máquina epsilon e condição de A.",
                                    "Armazene os autovetores do kernel para análise posterior."
                                  ],
                                  "verification": "Verifique A ≈ U Σ V^H e A A+ A ≈ A (propriedade de Moore-Penrose).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "np.linalg.svd() no NumPy ou svd() no MATLAB",
                                    "Biblioteca SciPy para pinv() como referência"
                                  ],
                                  "tips": "Use full_matrices=False para eficiência; tolerância = max(size(A)) * eps * σ_max.",
                                  "learningObjective": "Dominar SVD para resolução de sistemas singulares.",
                                  "commonMistakes": [
                                    "Inverter singulares pequenos causando instabilidade",
                                    "Erro na conjugação hermitiana para V",
                                    "Usar pinv() sem entender SVD subjacente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema e validar a solução",
                                  "subSteps": [
                                    "Calcule x = A+ b.",
                                    "Avalie o resíduo r = A x - b e norm(r) < tol.",
                                    "Verifique condições de contorno: y(±1) ≈ condições especificadas.",
                                    "Compare com solução analítica se disponível.",
                                    "Analise convergência variando N."
                                  ],
                                  "verification": "||A x - b|| / ||b|| < 1e-10 e condições de contorno satisfeitas dentro de tol.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos com Matplotlib para plotar y(x)",
                                    "Solução exata para benchmark"
                                  ],
                                  "tips": "Projeite x no complemento do kernel para unicidade; plote solução espectral.",
                                  "learningObjective": "Aplicar pseudoinverso para obter solução mínima norma e validar numericamente.",
                                  "commonMistakes": [
                                    "Não checar resíduo levando a solução errada",
                                    "Ignorar componente no kernel",
                                    "Falta de plot para inspeção visual"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva y'' + y = sin(πx) com y(-1)=y(1)=0 usando N=16 pontos Chebyshev. Forme A = D2 + I, note rank(A)=15 devido a kernel constante, compute SVD, x = A+ b onde b vem de sin(πx_i), obtenha y interpolada satisfazendo condições com erro <1e-8.",
                              "finalVerifications": [
                                "Resíduo do sistema ||Ax - b|| < 1e-10.",
                                "Condições de contorno y(±1) = 0 dentro de tolerância máquina.",
                                "Solução converge com aumento de N (erro O(1/N^k)).",
                                "Pseudoinverso reproduz A em aproximação.",
                                "Componente no kernel de A é zero ou mínimo.",
                                "Gráfico da solução coincide com analítica."
                              ],
                              "assessmentCriteria": [
                                "Correção na montagem de A e tratamento de singularidade (30%).",
                                "Implementação precisa de SVD e pseudoinverso (30%).",
                                "Validação numérica e análise de erros (20%).",
                                "Eficiência computacional para N até 1000 (10%).",
                                "Clareza no código e comentários (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Resolução de EDOs elípticas em mecânica quântica (autovalores).",
                                "Engenharia: Simulações CFD com métodos espectrais para fluidos.",
                                "Computação: Algoritmos de álgebra linear em machine learning (PCA via SVD).",
                                "Física Computacional: Problemas de valores de contorno em ondas."
                              ],
                              "realWorldApplication": "Em simulações de escoamentos incompressíveis (Navier-Stokes pseudoespectral), controle de singularidades em condições de contorno no método de Chebyshev, ou análise de estabilidade em turbulência onde SVD filtra modos singulares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Comparar com métodos finitos",
                            "description": "Comparar precisão e custo computacional dos métodos pseudoespectrais versus diferenças finitas para BVPs suaves, destacando a eficiência espectral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos dos Métodos Diferenças Finitas e Pseudoespectrais",
                                  "subSteps": [
                                    "Estude a discretização do método de diferenças finitas para BVPs de segunda ordem, focando em esquemas centrados O(h²).",
                                    "Revise a base de Fourier ou Chebyshev para métodos pseudoespectrais, incluindo diferenciação espectral.",
                                    "Identifique suposições de suavidade: soluções analiticamente suaves para convergência exponencial espectral.",
                                    "Anote diferenças chave: precisão (polinomial vs. espectral) e custo (local vs. global).",
                                    "Compile tabela comparativa preliminar de ordem de precisão e complexidade O(N)."
                                  ],
                                  "verification": "Criar uma tabela resumindo precisão (O(h²) vs. O(e^{-N})) e custo (O(N) vs. O(N log N)) para ambos métodos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Notas de aula, livro 'Numerical Analysis' de Burden, Python/Jupyter para anotações.",
                                  "tips": "Use diagramas esquemáticos para visualizar malhas finitas vs. expansão global.",
                                  "learningObjective": "Compreender as bases teóricas para comparação justa.",
                                  "commonMistakes": "Confundir convergência para soluções não-suaves; assumir custo similar sem FFT."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular e Discretizar um BVP Suave Exemplo",
                                  "subSteps": [
                                    "Escolha BVP suave: -u''(x) + π² u(x) = 0, u(0)=0, u(1)=sin(π), solução exata u(x)=sin(π x).",
                                    "Implemente diferenças finitas: malha uniforme com N pontos, matriz tridiagonal.",
                                    "Implemente pseudoespectral: use base Chebyshev, collocation em Gauss-Lobatto, resolva sistema.",
                                    "Calcule solução numérica para N=16,32,64 em ambos métodos.",
                                    "Plote soluções aproximadas vs. exata para inspeção visual."
                                  ],
                                  "verification": "Gráficos mostram sobreposição perfeita para pseudoespectral mesmo em N baixo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com NumPy, SciPy (solve_bvp), Matplotlib; ou MATLAB.",
                                  "tips": "Normalize domínio para [-1,1] em Chebyshev para precisão numérica.",
                                  "learningObjective": "Preparar implementações comparáveis em mesmo problema suave.",
                                  "commonMistakes": "Escolher BVP não-suave (e.g., com singularidades); erros de indexação na malha."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Precisão e Custo Computacional",
                                  "subSteps": [
                                    "Calcule erros L2 e L∞ para faixas de N (10 a 256).",
                                    "Meça tempo de execução com %timeit para múltiplas runs.",
                                    "Estime FLOPs: O(N) para finitas vs. O(N²) pré-FFT ou O(N log N) com FFT.",
                                    "Gere log-log plots: erro vs. N e tempo vs. N.",
                                    "Quantifique eficiência: N necessário para erro <1e-6."
                                  ],
                                  "verification": "Plots mostram queda exponencial no erro pseudoespectral vs. linear/algebraica em finitas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Jupyter notebook, bibliotecas timing (timeit), perfiladores (line_profiler).",
                                  "tips": "Use soluções exatas para erros absolutos; rode em máquina consistente.",
                                  "learningObjective": "Quantificar superioridade espectral em precisão para BVPs suaves.",
                                  "commonMistakes": "Ignorar overhead FFT; medir tempo sem aquecimento de cache."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Destacar Eficiência Espectral",
                                  "subSteps": [
                                    "Discuta convergência: exponencial pseudoespectral devido a suavidade vs. polinomial finitas.",
                                    "Compare custo-benefício: precisão por FLOPs ou por tempo.",
                                    "Identifique cenários ideais: BVPs suaves periódicos (Fourier) vs. não-periódicos (Chebyshev).",
                                    "Resuma trade-offs: estabilidade finitas vs. precisão espectral.",
                                    "Escreva relatório com conclusões e recomendações."
                                  ],
                                  "verification": "Relatório de 1 página com tabelas/plots e afirmação clara de eficiência espectral.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Word/LaTeX para relatório, plots salvos.",
                                  "tips": "Enfatize 'para soluções suaves' para evitar generalizações.",
                                  "learningObjective": "Sintetizar comparação, destacando quando usar cada método.",
                                  "commonMistakes": "Superestimar pseudoespectral para problemas não-suaves; negligenciar condicionamento de matriz."
                                }
                              ],
                              "practicalExample": "Para o BVP -u'' + π² u = 0 em [0,1] com u(0)=u(1)=0, exceto forcing para u(x)=sin(π x), diferenças finitas com N=64 dá erro L∞ ~1e-3, enquanto pseudoespectral Chebyshev dá ~1e-10, com tempo similar ~0.01s, demonstrando eficiência espectral.",
                              "finalVerifications": [
                                "Tabelas de erro mostram convergência exponencial pseudoespectral vs. O(1/N²) finitas.",
                                "Plots de tempo vs. precisão confirmam custo-benefício superior para N moderado.",
                                "Relatório identifica eficiência espectral para BVPs suaves.",
                                "Código reproduzível gera resultados consistentes.",
                                "Discussão cobre limitações (e.g., não-suave, não-linear)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na quantificação de erros (L2/L∞ <1% discrepância).",
                                "Análise correta de custo computacional (FLOPs e tempo medidos).",
                                "Destaque explícito da eficiência espectral para suavidade.",
                                "Implementações numéricas sem bugs (convergência observada).",
                                "Relatório claro com plots e conclusões fundamentadas.",
                                "Identificação de trade-offs realistas."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de ondas/elasticiade onde BVPs suaves surgem.",
                                "Engenharia: otimização em CFD (pseudoespectrais em Spectral Elements).",
                                "Ciência de Dados: eficiência em ML para PDEs (PINNs vs. finitas).",
                                "Programação Científica: uso de FFT em processamento de sinais."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (e.g., Navier-Stokes em domínios suaves), métodos pseudoespectrais reduzem N de milhares (finitas) para centenas, acelerando previsões meteorológicas ou aerodinâmica em 10-100x sem perda de precisão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Métodos Pseudoespectrais",
                "description": "Introdução aos métodos pseudoespectrais para aproximação de soluções de equações diferenciais.",
                "totalSkills": 43,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Definição e Motivação dos Métodos Pseudoespectrais",
                    "description": "Introdução aos conceitos básicos e vantagens da aproximação espectral para soluções de equações diferenciais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1",
                        "name": "Fundamentos da Aproximação Espectral",
                        "description": "Introdução aos conceitos básicos de aproximação de funções por meio de expansões em bases ortogonais, como séries de Fourier ou polinômios de Chebyshev, que servem de base para os métodos espectrais em equações diferenciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1",
                            "name": "Identificar bases ortogonais comuns em aproximações espectrais",
                            "description": "Reconhecer e descrever as principais bases usadas em métodos espectrais, incluindo séries de Fourier para problemas periódicos e polinômios de Chebyshev para domínios finitos, explicando suas propriedades de ortogonalidade e completude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Bases Ortogonais",
                                  "subSteps": [
                                    "Defina o conceito de funções ortogonais em espaços de Hilbert com produto interno.",
                                    "Explique a ortogonalidade: ∫ φ_m(x) φ_n(x) w(x) dx = 0 para m ≠ n.",
                                    "Discuta completude: qualquer função no espaço pode ser expandida na base.",
                                    "Revise o produto interno ponderado e funções de peso w(x).",
                                    "Identifique exemplos básicos como polinômios de Legendre."
                                  ],
                                  "verification": "Resuma em um parágrafo as definições de ortogonalidade e completude, com fórmulas corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Análise Numérica (ex: Trefethen 'Spectral Methods'), caderno de anotações, calculadora simbólica (Wolfram Alpha).",
                                  "tips": "Visualize ortogonalidade como vetores perpendiculares em espaços funcionais.",
                                  "learningObjective": "Dominar definições e propriedades básicas de bases ortogonais.",
                                  "commonMistakes": "Confundir ortogonalidade com normalização; esquecer o peso w(x)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Séries de Fourier para Problemas Periódicos",
                                  "subSteps": [
                                    "Descreva a base de Fourier: senos e cossenos em [0, 2π] ou [-π, π].",
                                    "Escreva a expansão: f(x) = a0/2 + Σ (an cos(nx) + bn sen(nx)).",
                                    "Explique ortogonalidade: ∫ cos(mx) cos(nx) dx = π δ_mn para m,n ≥1.",
                                    "Discuta completude pelo teorema de Parseval.",
                                    "Aplique a um exemplo simples: expanda f(x) = |x| em [-π, π]."
                                  ],
                                  "verification": "Calcule os primeiros 3 coeficientes de Fourier para f(x) = x^2 em [-π, π] e verifique numericamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python (NumPy/SciPy para fft), papel quadriculado.",
                                  "tips": "Use simetria par/impar para simplificar cálculos de coeficientes.",
                                  "learningObjective": "Reconhecer Fourier como base ortogonal para domínios periódicos.",
                                  "commonMistakes": "Erro nos limites de integração; confundir sen e cos em fórmulas de coeficientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Polinômios de Chebyshev para Domínios Finitos",
                                  "subSteps": [
                                    "Defina polinômios de Chebyshev do primeiro tipo: T_n(cos θ) = cos(n θ).",
                                    "Explique base em [-1,1] com peso w(x) = 1/√(1-x²).",
                                    "Mostre recursão: T0=1, T1=x, T_{n+1}=2x T_n - T_{n-1}.",
                                    "Discuta ortogonalidade: ∫ T_m T_n w(x) dx = π/2 δ_mn (ajustado para n=0).",
                                    "Verifique completude em funções contínuas em [-1,1]."
                                  ],
                                  "verification": "Gere os primeiros 5 polinômios T_n(x) via recursão e plote-os.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python/MATLAB para plotagem (matplotlib/chebfun toolbox), tabela de polinômios.",
                                  "tips": "Use substituição x=cos θ para integrar facilmente.",
                                  "learningObjective": "Identificar Chebyshev como base para aproximações em intervalos finitos.",
                                  "commonMistakes": "Confundir Tn com Un (segundo tipo); erro no peso de ortogonalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Bases e Aplicar em Aproximações Espectrais",
                                  "subSteps": [
                                    "Compare Fourier (periódico, exponenciais/sen/cos) vs Chebyshev (finito, polinômios).",
                                    "Explique uso em métodos espectrais: derivadas exatas via multiplicação por ik ou T_n'.",
                                    "Descreva completude: convergência espectral para funções suaves.",
                                    "Identifique quando usar cada: periódico → Fourier; não-periódico → Chebyshev.",
                                    "Resolva um mini-problema: aproxime sin(x) em [-π,π] com ambas."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 5 critérios (ortogonalidade, domínio, etc.) e aplique a uma função teste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou Jupyter Notebook para comparações numéricas.",
                                  "tips": "Foque em aliasing em Fourier para não-periódicos como motivo para Chebyshev.",
                                  "learningObjective": "Descrever e identificar bases em contextos espectrais específicos.",
                                  "commonMistakes": "Ignorar condições de contorno; superestimar convergência para funções não-suaves."
                                }
                              ],
                              "practicalExample": "Aproxime a função f(x) = e^x em [-1,1] usando 5 termos de Chebyshev: calcule coeficientes, reconstrua e compare erro RMS com plotagem em Python.",
                              "finalVerifications": [
                                "Liste corretamente as bases Fourier e Chebyshev com domínios e pesos.",
                                "Escreva integral de ortogonalidade para ambas.",
                                "Explique completude com um teorema relevante.",
                                "Identifique 2 aplicações espectrais para cada base.",
                                "Compare erros de aproximação em um exemplo numérico.",
                                "Descreva verbalmente propriedades em 1 minuto."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de ortogonalidade e completude (80% correto).",
                                "Correção matemática em fórmulas e coeficientes (sem erros de cálculo).",
                                "Profundidade na comparação entre bases (cobertura de 4+ critérios).",
                                "Clareza na explicação verbal ou escrita.",
                                "Aplicação prática com exemplo computacional funcional.",
                                "Identificação contextual correta em métodos espectrais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e séries de Fourier em mecânica quântica.",
                                "Engenharia: Simulações CFD usando métodos espectrais com Chebyshev.",
                                "Processamento de Sinais: FFT para filtros digitais.",
                                "Computação Científica: Bibliotecas como Chebfun ou Dedalus."
                              ],
                              "realWorldApplication": "Em simulações numéricas de fluidos (DNS turbulence), Fourier resolve periodicidade em canais, enquanto Chebyshev gerencia paredes não-periódicas, permitindo derivadas de alta precisão para equações de Navier-Stokes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2",
                            "name": "Explicar a convergência exponencial da aproximação espectral",
                            "description": "Compreender e articular por que as aproximações espectrais exibem convergência exponencial para funções suaves, contrastando com a convergência algébrica dos métodos de diferenças finitas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Aproximação Espectral",
                                  "subSteps": [
                                    "Defina aproximação espectral como projeção de uma função em uma base global de funções ortogonais (ex: senos/cossenos de Fourier ou polinômios de Chebyshev).",
                                    "Explique o processo de truncamento da série infinita para N termos, formando o polinômio interpolante espectral.",
                                    "Discuta a natureza global da aproximação, onde todos os pontos influenciam todos os coeficientes.",
                                    "Identifique funções suaves (analíticas ou C^∞) como candidatas ideais para convergência rápida.",
                                    "Revise a fórmula do erro de truncamento: ||f - P_N f|| ≤ C ρ^{-N} para funções analíticas."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando a diferença entre aproximações globais e locais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre métodos pseudoespectrais",
                                    "Capítulo de livro sobre análise de Fourier (ex: Trefethen 'Spectral Methods')",
                                    "Software MATLAB/Python para visualização rápida"
                                  ],
                                  "tips": [
                                    "Comece com funções periódicas para Fourier para simplicidade.",
                                    "Visualize graficamente a base ortogonal para intuição."
                                  ],
                                  "learningObjective": "Compreender a base teórica da aproximação espectral e sua adequação para funções suaves.",
                                  "commonMistakes": [
                                    "Confundir com métodos locais como splines.",
                                    "Ignorar a ortogonalidade da base."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Decaimento Exponencial dos Coeficientes Espectrais",
                                  "subSteps": [
                                    "Estude o teorema de Bernstein: para funções analíticas em uma faixa de analyticidade, coeficientes de Fourier decaem como e^{-k δ} para k→∞.",
                                    "Derive qualitativamente por que suavidade implica decaimento rápido: integrais oscilatórios cancelam para funções lisas.",
                                    "Para Chebyshev, revise propriedades de Gibbs e como suavidade reduz overshoot.",
                                    "Calcule analiticamente coeficientes para exemplo simples como f(x) = e^{sin(x)}.",
                                    "Discuta extensão para não-periódicas via mapeamento para círculo unitário."
                                  ],
                                  "verification": "Compute manualmente os primeiros 5 coeficientes de Fourier para uma função suave e observe o decaimento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de cálculo para integrais",
                                    "Software SymPy ou Mathematica para coeficientes simbólicos",
                                    "Artigo sobre teorema de Paley-Wiener"
                                  ],
                                  "tips": [
                                    "Use integração por partes repetida para demonstrar decaimento.",
                                    "Log-plot dos coeficientes para visualizar exponencialidade."
                                  ],
                                  "learningObjective": "Explicar matematicamente o decaimento exponencial dos coeficientes para funções suaves.",
                                  "commonMistakes": [
                                    "Assumir decaimento uniforme sem considerar raio de analyticidade.",
                                    "Confundir decaimento com convergência ponto-a-ponto."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar com Convergência Algébrica em Diferenças Finitas",
                                  "subSteps": [
                                    "Revise métodos de diferenças finitas: aproximação local de derivadas via Taylor, erro O(h^p) com p fixo.",
                                    "Explique por que erro global acumula como O(h^p) independentemente da suavidade além de C^{p}.",
                                    "Compare ordens: espectral ganha fator exponencial em N ~ 1/h.",
                                    "Discuta stencil finito vs global: poluição numérica em finitas diferenças para altas frequências.",
                                    "Calcule erro para stencil central de 2a ordem em função suave."
                                  ],
                                  "verification": "Derive a expansão de Taylor para diferença finita e identifique termos de erro.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas sobre análise de erro em diferenças finitas",
                                    "Exemplos numéricos em Python (NumPy)"
                                  ],
                                  "tips": [
                                    "Pense em h = π/N para grids uniformes em ambos métodos.",
                                    "Compare DOFs necessários para mesmo erro."
                                  ],
                                  "learningObjective": "Identificar limitações algébricas das diferenças finitas vs exponencial espectral.",
                                  "commonMistakes": [
                                    "Superestimar ordem em finitas diferenças para funções não-suaves.",
                                    "Ignorar custo computacional de N alto em espectrais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar e Sintetizar a Convergência Exponencial",
                                  "subSteps": [
                                    "Implemente numericamente: plote log|erro| vs log N para espectral e finitas diferenças em f suave.",
                                    "Observe slope ~ -N (exponencial) vs constante (algébrico).",
                                    "Discuta condições: analyticidade em faixa estendendo além do domínio.",
                                    "Estenda para derivadas: preservação espectral de suavidade.",
                                    "Resuma em diagrama comparativo de taxas de convergência."
                                  ],
                                  "verification": "Gere gráfico mostrando curvas de erro e explique o porquê da diferença.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Chebfun",
                                    "Templates de código para spectral/diferenças finitas"
                                  ],
                                  "tips": [
                                    "Use função analítica como sech(x) para teste.",
                                    "Varie N de 8 a 512 e fit exponencial."
                                  ],
                                  "learningObjective": "Articular quantitativamente a superioridade exponencial via evidência numérica e teórica.",
                                  "commonMistakes": [
                                    "Escolha função não-suafe invalidando exponencial.",
                                    "Plots lineares em vez de log-log ou semi-log."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python, aproxime f(x) = exp(-x^2) no intervalo [-5,5] usando expansão de Chebyshev com N=10,20,...,128 termos. Plote erro L2 vs N em escala log-log. Compare com diferenças finitas de 4a ordem em grid com h=10/N. Observe erro espectral caindo para 10^{-12} em N=64, enquanto finitas diferenças ainda em 10^{-4}.",
                              "finalVerifications": [
                                "Derivar qualitativamente o decaimento exponencial dos coeficientes para função analítica.",
                                "Gerar gráfico numérico comparando erros espectral vs diferenças finitas.",
                                "Explicar verbalmente por que suavidade global leva a exponencial vs local algébrico.",
                                "Identificar condições necessárias (raio de analyticidade).",
                                "Aplicar conceito a um problema de derivadas espectrais.",
                                "Discutir limitações para funções com singularidades próximas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação do decaimento de coeficientes (exponencial vs polinomial).",
                                "Correta derivação/comparação de taxas de erro teóricas.",
                                "Qualidade de gráficos numéricos mostrando regimes de convergência.",
                                "Clareza na distinção entre global (espectral) e local (finitas diferenças).",
                                "Identificação correta de pré-condições como suavidade analítica.",
                                "Capacidade de estender a aplicações em PDEs."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de ondas e fluidos onde precisão espectral é crucial.",
                                "Ciência da Computação: Algoritmos FFT para eficiência em grandes N.",
                                "Engenharia: Otimização de estruturas com métodos de elementos espectrais.",
                                "Estatística: Aproximação de densidades suaves em inferência bayesiana.",
                                "Física Teórica: Expansões em séries conforme princípios variacionais."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD), métodos espectrais permitem resolver equações de Navier-Stokes com grids grosseiros (N~100), alcançando precisão de máquina, enquanto diferenças finitas exigem N~10^5 para erros similares, reduzindo drasticamente tempo de computação em previsão do tempo e aerodinâmica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3",
                            "name": "Representar uma função por expansão espectral",
                            "description": "Dado uma função suave, representar sua aproximação por uma soma finita de coeficientes espectrais multiplicados pelas funções base, calculando os coeficientes via projeção ou transformada discreta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da expansão espectral",
                                  "subSteps": [
                                    "Defina expansão espectral como uma soma finita de coeficientes multiplicados por funções base ortonormais.",
                                    "Estude propriedades das bases comuns: Fourier (periódicas), Legendre ou Chebyshev (não-periódicas).",
                                    "Revise ortogonalidade: integral do produto de funções base diferentes é zero.",
                                    "Entenda a motivação: alta precisão com poucos termos para funções suaves.",
                                    "Discuta convergência exponencial para funções analíticas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o conceito e dê um exemplo simples de base Fourier.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica, notas de aula, calculadora.",
                                  "tips": "Visualize graficamente funções base para fixar intuição.",
                                  "learningObjective": "Dominar definição e propriedades das expansões espectrais.",
                                  "commonMistakes": "Confundir bases periódicas com não-periódicas; ignorar normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher a base e discretizar a função",
                                  "subSteps": [
                                    "Analise periodicidade da função: Fourier para periódica, Chebyshev para intervalo finito.",
                                    "Defina o domínio e grau N da aproximação (ex: N=10-20).",
                                    "Escolha pontos de colocation: Gauss-Lobatto para Chebyshev ou equidistantes para Fourier.",
                                    "Amostre a função f(x) nos pontos discretos.",
                                    "Liste as funções base φ_k(x) para k=0 a N."
                                  ],
                                  "verification": "Liste pontos de colocation e valores de f(x) em uma tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software como MATLAB/Python (NumPy/SciPy), papel quadriculado.",
                                  "tips": "Comece com N baixo para testar; use intervalos simétricos quando possível.",
                                  "learningObjective": "Selecionar adequadamente base e discretização para a função dada.",
                                  "commonMistakes": "Escolher base errada (ex: Fourier em função não-periódica causa Gibbs); poucos pontos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os coeficientes espectrais",
                                  "subSteps": [
                                    "Use projeção ortogonal: c_k = ∫ f(x) φ_k(x) w(x) dx / norma.",
                                    "Para discreto: use quadratura (ex: DCT para Chebyshev, DFT para Fourier).",
                                    "Implemente fórmula discreta: c_k = soma f(x_j) φ_k(x_j) w_j.",
                                    "Calcule todos c_k para k=0 a N.",
                                    "Verifique decaimento: |c_k| diminui rapidamente para funções suaves."
                                  ],
                                  "verification": "Compare c_k computados manualmente com software para N=5.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com SciPy (chebfun ou fft), calculadora simbólica (SymPy).",
                                  "tips": "Use bibliotecas prontas para validar; normalize pesos w_j corretamente.",
                                  "learningObjective": "Computar coeficientes via projeção ou transformada discreta.",
                                  "commonMistakes": "Esquecer pesos de quadratura; erro de índice em somas discretas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e representar a aproximação espectral",
                                  "subSteps": [
                                    "Forme a soma S_N(x) = soma_{k=0}^N c_k φ_k(x).",
                                    "Avalie S_N(x) em grade fina para plotagem.",
                                    "Compare graficamente f(x) vs S_N(x).",
                                    "Calcule erro: max |f(x) - S_N(x)| ou norma L2.",
                                    "Ajuste N se erro alto."
                                  ],
                                  "verification": "Gere gráfico mostrando convergência ao aumentar N.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB/Python (Matplotlib/Plotly), planilha Excel para N baixo.",
                                  "tips": "Plote resíduos para ver onde erra mais; evite aliasing com N par.",
                                  "learningObjective": "Reconstruir a função aproximada a partir dos coeficientes.",
                                  "commonMistakes": "Índices errados na soma; não truncar coeficientes pequenos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar precisão e refinar a expansão",
                                  "subSteps": [
                                    "Compute métricas: erro máximo, RMS, taxa de convergência.",
                                    "Analise espectro: plot |c_k| vs k.",
                                    "Teste com função diferente para generalizar.",
                                    "Discuta truncamento: pare onde c_k < epsilon.",
                                    "Documente o processo completo."
                                  ],
                                  "verification": "Relatório com gráficos, erros e coeficientes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem, template de relatório.",
                                  "tips": "Logaritme erros para ver ordem de convergência.",
                                  "learningObjective": "Avaliar qualidade da aproximação espectral.",
                                  "commonMistakes": "Ignorar oscilações de Gibbs; superestimar precisão sem métricas."
                                }
                              ],
                              "practicalExample": "Aproxime f(x) = sin(π x) no intervalo [-π, π] usando expansão de Fourier com N=8 termos. Calcule coeficientes via DFT, reconstrua e plote erro < 10^{-4}.",
                              "finalVerifications": [
                                "Coeficientes c_k calculados corretamente e decaem monotonicamente.",
                                "Gráfico de S_N(x) sobrepõe f(x) com erro visual nulo.",
                                "Erro L^∞ < 10^{-6} para N=16.",
                                "Espectro |c_k| mostra convergência exponencial.",
                                "Implementação reproduzível em código.",
                                "Explicação oral da escolha da base."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática nos coeficientes (90% precisão).",
                                "Escolha adequada de base e N.",
                                "Análise de erro quantitativa e qualitativa.",
                                "Clareza nos gráficos e documentação.",
                                "Generalização para outra função suave.",
                                "Eficiência computacional demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Física: Decomposição em séries de Fourier para equações de onda.",
                                "Computação Científica: Implementação de FFT para big data.",
                                "Engenharia: Simulações CFD com métodos espectrais.",
                                "Processamento de Sinais: Filtros e compressão de áudio/imagens."
                              ],
                              "realWorldApplication": "Em simulações numéricas de dinâmica de fluidos (DNS), previsão meteorológica e processamento de sinais, onde expansões espectrais permitem alta precisão com baixa dimensionalidade, acelerando computações em supercomputadores."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.2",
                        "name": "Definição dos Métodos Pseudoespectrais",
                        "description": "Definição formal dos métodos pseudoespectrais como uma técnica de colocation que utiliza transformadas discretas rápidas (como FFT) para aproximar soluções de equações diferenciais ordinárias e parciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.2.1",
                            "name": "Definir o método pseudoespectral e seu processo básico",
                            "description": "Formular a definição precisa de um método pseudoespectral, descrevendo os passos: interpolação em pontos de Gauss-Lobatto, transformação para espaço espectral, diferenciação matricial e transformação de volta ao espaço físico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição Geral do Método Pseudoespectral",
                                  "subSteps": [
                                    "Estude a definição formal: método pseudoespectral aproxima funções por interpolação polinomial em pontos específicos e opera no espaço espectral para derivadas.",
                                    "Identifique os componentes chave: pontos de Gauss-Lobatto, transformadas forward/backward e diferenciação matricial.",
                                    "Compare com métodos finitos: pseudoespectral é global e espectral em precisão.",
                                    "Revise os polinômios base (Chebyshev ou Legendre).",
                                    "Anote a motivação: alta precisão para soluções suaves."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras com os 4 passos principais e compare com a referência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Spectral Methods' de Canuto et al.",
                                    "Notas de aula sobre análise numérica",
                                    "Calculadora ou papel para esboços"
                                  ],
                                  "tips": "Use analogia com Fourier: pseudoespectral é como FFT para polinômios.",
                                  "learningObjective": "Compreender o conceito central e os passos básicos do método.",
                                  "commonMistakes": [
                                    "Confundir com métodos espectrais tau ou Galerkin.",
                                    "Ignorar a natureza global da aproximação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Interpolação em Pontos de Gauss-Lobatto",
                                  "subSteps": [
                                    "Defina pontos de Gauss-Lobatto: extremos de polinômios Chebyshev de grau N, incluindo -1 e 1.",
                                    "Calcule pontos para N=3: x = [-1, 0, 1] ou fórmula cos(π k / N).",
                                    "Construa o polinômio interpolador: u_N(x) = ∑ u_j l_j(x), onde l_j são funções de Lagrange.",
                                    "Implemente pesos de quadratura associados.",
                                    "Visualize os pontos em um gráfico."
                                  ],
                                  "verification": "Gere pontos para N=5 e interpole uma função teste como sin(πx), verificando erro <1e-10.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/MATLAB com numpy/chebfun",
                                    "Tabela de pontos Gauss-Lobatto pré-computados"
                                  ],
                                  "tips": "Pontos Gauss-Lobatto minimizam Runge phenomenon em Chebyshev.",
                                  "learningObjective": "Aplicar interpolação precisa em grid não-uniforme.",
                                  "commonMistakes": [
                                    "Usar pontos equidistantes, causando oscilações.",
                                    "Esquecer inclusão de endpoints."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a Transformação Forward para Espaço Espectral",
                                  "subSteps": [
                                    "Colete valores físicos u_j em pontos Gauss-Lobatto.",
                                    "Compute coeficientes espectrais û_k via transformada discreta (DCT para Chebyshev).",
                                    "Use matriz de transformada forward Q: û = Q u.",
                                    "Verifique ortogonalidade aproximada dos polinômios.",
                                    "Teste com função conhecida, como polinômio de grau baixo."
                                  ],
                                  "verification": "Transforme u(x)=x^2, confira que coeficientes altos são zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python: scipy.special.roots_chebyt",
                                    "Matriz de exemplo 4x4"
                                  ],
                                  "tips": "Aproxima DCT-II para eficiência computacional.",
                                  "learningObjective": "Converter dados físicos para coeficientes modais.",
                                  "commonMistakes": [
                                    "Inverter forward/backward.",
                                    "Não normalizar corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar Diferenciação Matricial no Espaço Espectral",
                                  "subSteps": [
                                    "Construa matriz de diferenciação D: derivadas exatas de bases espectrais.",
                                    "Para Chebyshev: D_{kj} = c_k (-1)^{k+j} / c_j para k>j, etc.",
                                    "Aplique: derivada espectral = D û.",
                                    "Explique precisão exponencial para funções analíticas.",
                                    "Compare custo: O(N^2) vs O(N log N) com FFT."
                                  ],
                                  "verification": "Derive sin(πx), verifique espectro decai rapidamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Implementação MATLAB diff() para Chebyshev",
                                    "Fórmulas de Trefethen 'Spectral Methods in MATLAB'"
                                  ],
                                  "tips": "Matriz D é upper triangular para Legendre/Chebyshev.",
                                  "learningObjective": "Executar operações diferenciais eficientes no domínio espectral.",
                                  "commonMistakes": [
                                    "Usar diferenciação física (baixa ordem).",
                                    "Erros de índice na matriz."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar a Transformação Backward para Espaço Físico",
                                  "subSteps": [
                                    "Aplique transformada backward: u = Q^{-1} (D û).",
                                    "Use pseudoinversa ou Q^T / N para ortogonalidade.",
                                    "Reconstrua valores nos pontos Gauss-Lobatto.",
                                    "Integre no fluxo completo: interpolação → forward → diff → backward.",
                                    "Avalie precisão global do processo."
                                  ],
                                  "verification": "Aplique ciclo completo a f(x)=exp(x), erro norma <1e-12 para N=16.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código completo de exemplo",
                                    "Gráficos para visualizar u vs u_exact"
                                  ],
                                  "tips": "Q é quase ortogonal, acelera com Fast Cosine Transform.",
                                  "learningObjective": "Completar o ciclo pseudoespectral e validar.",
                                  "commonMistakes": [
                                    "Perder precisão na backward sem normalização.",
                                    "Confundir grids físico/espectral."
                                  ]
                                }
                              ],
                              "practicalExample": "Para aproximar u'(x) onde u(x) = sin(πx) em [-1,1] com N=6: (1) Interpole u em Gauss-Lobatto; (2) Forward para coefs Chebyshev; (3) Multiplique por D; (4) Backward; resultado converge exponencialmente a π cos(πx).",
                              "finalVerifications": [
                                "Liste e descreva os 4 passos principais corretamente.",
                                "Desenhe diagrama de fluxo: físico → espectral → diff → físico.",
                                "Implemente ciclo em código para N=8, erro <1e-10.",
                                "Explique por que Gauss-Lobatto é escolhido.",
                                "Compare precisão com diferenças finitas de 2a ordem.",
                                "Identifique quando método falha (descontinuidades)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (80% match com referência).",
                                "Correta sequência dos 4 passos com fórmulas chave.",
                                "Demonstração numérica com erro quantificado.",
                                "Explicação intuitiva das transformadas.",
                                "Identificação de vantagens/desvantagens.",
                                "Uso correto de terminologia (e.g., 'pseudo' vs spectral puro)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Solução de PDEs elípticas/parabólicas em mecânica quântica.",
                                "Computação Científica: Integração com FFT e solvers de tempo.",
                                "Engenharia: Simulações CFD para aerodinâmica.",
                                "Estatística: Análise espectral de séries temporais.",
                                "Visualização: Plots de modos espectrais."
                              ],
                              "realWorldApplication": "Métodos pseudoespectrais são usados em modelos climáticos (e.g., NASA GCM) para resolver equações de atmosfera/oceano com alta precisão em grids globais, permitindo simulações de previsão do tempo de longo prazo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.1.2.2",
                            "name": "Descrever a diferenciação espectral",
                            "description": "Explicar como derivadas são computadas exatamente no espaço espectral (exato para polinômios de grau N) e aproximadas via multiplicação por fatores espectrais, usando matrizes de diferenciação pré-computadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais da diferenciação espectral",
                                  "subSteps": [
                                    "Diferencie espaço físico (grade de pontos) do espaço espectral (coeficientes de expansão).",
                                    "Explique o uso de bases ortogonais como Fourier ou Chebyshev para representar funções suaves.",
                                    "Descreva por que a diferenciação é exata no espaço espectral para polinômios de grau ≤ N.",
                                    "Identifique a motivação: precisão global vs. local dos métodos de diferenças finitas.",
                                    "Revise transformadas direta (DCT/FFT) e inversa (IDCT/IFFT)."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e desenhe um diagrama fluxo físico-espectral-físico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Spectral Methods in MATLAB' de Trefethen (cap. 2)",
                                    "Notebook Jupyter com NumPy e SciPy"
                                  ],
                                  "tips": "Use analogia com música: notas (espectro) vs. onda sonora (físico).",
                                  "learningObjective": "Entender a base teórica da diferenciação espectral e sua exatidão.",
                                  "commonMistakes": [
                                    "Confundir exatidão espectral com métodos locais",
                                    "Ignorar periodicidade em Fourier"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender diferenciação no espaço espectral via multiplicação por fatores",
                                  "subSteps": [
                                    "Para Fourier: multiplique coeficientes ˆf_k por i k (derivada primeira).",
                                    "Para Chebyshev: use fatores espectrais específicos (k(k+1) para segunda derivada).",
                                    "Implemente a transformada direta para obter coeficientes espectrais.",
                                    "Aplique multiplicação exata pelos fatores ik ou equivalentes.",
                                    "Realize a transformada inversa para obter a derivada no espaço físico."
                                  ],
                                  "verification": "Implemente em código a derivada de uma função teste e compare com derivada analítica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python: numpy.fft.fftn e ifftn",
                                    "Função teste: exp(sin(x))"
                                  ],
                                  "tips": "Sempre normalize as FFT para evitar fatores de escala errados.",
                                  "learningObjective": "Dominar o algoritmo de multiplicação espectral para derivadas.",
                                  "commonMistakes": [
                                    "Esquecer fator i em Fourier (torna real/imaginário incorreto)",
                                    "Não tratar coeficientes zero-frequency"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar matrizes de diferenciação pré-computadas",
                                  "subSteps": [
                                    "Construa a matriz D_N de diferenciação para N pontos (exata para polinômios grau < N).",
                                    "Para Chebyshev: use fórmulas de Weideman para D_{jk} = c_j (-1)^{j+k} / c_k * (δ_{j,N-1}... ).",
                                    "Aplique D * u para derivada: u' = D u (u vetor de valores físicos).",
                                    "Verifique exatidão: teste com polinômios conhecidos (erro máquina).",
                                    "Discuta eficiência: O(N^2) vs. O(N log N) da via FFT."
                                  ],
                                  "verification": "Gere matriz D para N=16, aplique em polinômio de grau 3 e confirme erro < 1e-12.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Função chebdif() de Trefethen ou SciPy",
                                    "Matlab/Python código para matrizes"
                                  ],
                                  "tips": "Pré-compute D uma vez por grade para reutilização em ODEs.",
                                  "learningObjective": "Construir e usar matrizes D para diferenciação espectral.",
                                  "commonMistakes": [
                                    "Índices errados em extremos da grade Chebyshev",
                                    "Usar D para funções não-suaves"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com métodos tradicionais e validar",
                                  "subSteps": [
                                    "Compare precisão: espectral (exp decay erro) vs. FD (algebraic).",
                                    "Teste numérico: erro em derivada de runge(x) = 1/(1+25x^2).",
                                    "Analise estabilidade e custo computacional.",
                                    "Implemente um exemplo completo com visualização de erros.",
                                    "Resuma vantagens: exatidão para modais globais."
                                  ],
                                  "verification": "Crie gráfico log-log de erro vs. N para espectral vs. FD central.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Função Runge para teste clássico"
                                  ],
                                  "tips": "Use grids não-uniformes (Chebyshev) para funções com gradientes fortes.",
                                  "learningObjective": "Avaliar superioridade da diferenciação espectral.",
                                  "commonMistakes": [
                                    "Testar com funções não-periódicas em Fourier",
                                    "Ignorar aliasing em altas frequências"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente diferenciação espectral para aproximar a derivada de f(x) = sin(2πx) + 0.1*sin(20πx) em 64 pontos uniformes: use FFT para transformada, multiplique por ik, IFFT e plote f vs. f' analítica e numérica (erro <1e-14).",
                              "finalVerifications": [
                                "Explicar por que derivadas são exatas para polinômios grau ≤ N-1.",
                                "Descrever passo-a-passo FFT -> mult ik -> IFFT.",
                                "Construir matriz D para N=8 e verificar em x^3.",
                                "Comparar erros com FD de 4a ordem em função suave.",
                                "Identificar quando usar Fourier vs. Chebyshev.",
                                "Implementar código funcional sem erros de escala."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: exatidão espectral vs. aproximação FD (90%).",
                                "Implementação correta: código roda sem erros, match analítico (100%).",
                                "Análise de erros: decay exponencial demonstrado (80%).",
                                "Explicação clara: diagrama e resumo verbal fluido.",
                                "Eficiência: menciona O(N log N) vs. O(N^2).",
                                "Aplicação: adapta a exemplo próprio."
                              ],
                              "crossCurricularConnections": [
                                "Física: simulações de ondas/PDES (equação de calor via espectral).",
                                "Engenharia: CFD (Navier-Stokes pseudoespectral).",
                                "Ciência da Computação: algoritmos FFT rápidos (Cooley-Tukey).",
                                "Estatística: análise espectral de séries temporais.",
                                "Visualização: plots de modais espectrais."
                              ],
                              "realWorldApplication": "Em modelagem climática (GCMs), diferenciação espectral computa gradientes de temperatura/vento com precisão global em esferas (usado no modelo ECMWF); em aerodinâmica, resolve Navier-Stokes para perfis de asas com erro mínimo em domínios irregulares."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.3",
                        "name": "Motivação e Vantagens dos Métodos Pseudoespectrais",
                        "description": "Razões para adotar métodos pseudoespectrais em problemas de equações diferenciais, destacando vantagens em precisão, eficiência e aplicações específicas em comparação a métodos de diferenças finitas ou elementos finitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.3.1",
                            "name": "Comparar pseudoespectrais com métodos de diferenças finitas",
                            "description": "Analisar as diferenças em precisão (exponencial vs. polinomial), custo computacional (O(N log N) vs. O(N)) e adequação a problemas suaves, citando exemplos de problemas de valor inicial e de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos dos métodos de diferenças finitas",
                                  "subSteps": [
                                    "Estudar a discretização de derivadas parciais usando diferenças finitas centrais, forward e backward.",
                                    "Analisar a aproximação polinomial local de ordem 2 (para esquema central).",
                                    "Calcular o erro de truncamento, que é O(h²) ou superior dependendo da ordem.",
                                    "Discutir a estabilidade via critério CFL para problemas hiperbólicos.",
                                    "Implementar um exemplo simples em código para uma EDO."
                                  ],
                                  "verification": "Implementar e rodar um código que resolva uma EDO simples, verificando estabilidade e precisão com diferentes h.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro 'Análise Numérica' de Burden & Faires",
                                    "Python com NumPy e Matplotlib",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Comece com esquemas de baixa ordem para entender limitações antes de generalizar.",
                                  "learningObjective": "Compreender a base aproximadora local e suas limitações em precisão para funções não-suaves.",
                                  "commonMistakes": [
                                    "Ignorar condições de estabilidade, levando a soluções instáveis.",
                                    "Confundir erro de truncamento com erro de arredondamento."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar fundamentos dos métodos pseudoespectrais",
                                  "subSteps": [
                                    "Explicar a expansão global em bases ortogonais (Fourier para periódicos, Chebyshev para não-periódicos).",
                                    "Descrever o uso da Transformada Rápida de Fourier (FFT) para derivadas no espaço espectral.",
                                    "Analisar a precisão exponencial para funções analíticas suaves (erro ~ e^{-N}).",
                                    "Implementar diferenciação espectral para uma função teste.",
                                    "Comparar visualmente aproximações no espaço físico e espectral."
                                  ],
                                  "verification": "Derivar analiticamente as derivadas espectrais de uma função seno e validar numericamente com FFT.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação SciPy FFT",
                                    "Python com SciPy e NumPy",
                                    "Artigos de Canuto et al. sobre métodos espectrais"
                                  ],
                                  "tips": "Use funções periódicas inicialmente para evitar aliasing de Gibbs.",
                                  "learningObjective": "Dominar a representação global e a alta precisão para problemas suaves.",
                                  "commonMistakes": [
                                    "Aplicar Fourier a domínios não-periódicos sem tratamento de contorno.",
                                    "Esquecer normalização na FFT inversa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar precisão e ordem de convergência",
                                  "subSteps": [
                                    "Plotar curvas de erro log-log para ambos métodos em uma função suave (ex: exp(-x²)).",
                                    "Identificar convergência polinomial (diferenças finitas) vs. exponencial (pseudoespectrais).",
                                    "Discutir impacto de singularidades ou não-suavidade na degradação da precisão espectral.",
                                    "Realizar teste numérico com refinamento de malha N.",
                                    "Tabelar resultados de erro L2 e L∞."
                                  ],
                                  "verification": "Gerar gráficos mostrando slopes diferentes nas curvas de convergência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python compartilhado dos steps anteriores",
                                    "Matplotlib para plots log-log"
                                  ],
                                  "tips": "Use malhas uniformes e refine por fator 2 para clareza nos logs.",
                                  "learningObjective": "Quantificar matematicamente as diferenças em precisão para funções suaves vs. gerais.",
                                  "commonMistakes": [
                                    "Usar métricas de erro inadequadas (ex: L1 em vez de L∞ para oscilações).",
                                    "Não considerar o regime assintótico (N grande)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar custo computacional, adequação e exemplos",
                                  "subSteps": [
                                    "Derivar complexidades: O(N) por passo para diferenças finitas vs. O(N log N) via FFT.",
                                    "Analisar adequação: pseudoespectrais para problemas suaves (ex: ondas), finitas para choques.",
                                    "Citar exemplos: Problema de valor inicial (adveção) e de contorno (equação de Poisson).",
                                    "Medir tempos de CPU em simulações reais.",
                                    "Concluir trade-offs com tabela comparativa."
                                  ],
                                  "verification": "Executar benchmarks de tempo para N=128, 256, 512 e discutir escalabilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "%timeit no Jupyter",
                                    "Tabela LaTeX ou Markdown para resumo"
                                  ],
                                  "tips": "Otimize códigos para fair comparison (vetorização).",
                                  "learningObjective": "Avaliar trade-offs práticos e selecionar método por problema.",
                                  "commonMistakes": [
                                    "Ignorar overhead da FFT para N pequenos.",
                                    "Generalizar inadequação sem contexto de suavidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente a equação de advecção u_t + u_x = 0 com u(0,x)=sen(2πx) em [0,1]x[0,1], usando diferenças finitas de 2a ordem e pseudoespectral Fourier. Compare erros e tempos para N=64,128,256.",
                              "finalVerifications": [
                                "Explicar verbalmente por que pseudoespectrais convergem exponencialmente para funções suaves.",
                                "Identificar quando diferenças finitas são preferíveis (ex: descontinuidades).",
                                "Apresentar tabela com complexidades O(N) vs O(N log N).",
                                "Dar exemplo de problema de valor inicial (KdV) e contorno (Stokes).",
                                "Executar benchmark mostrando crossover onde FFT é mais eficiente.",
                                "Discutir tratamento de contornos em ambos métodos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de convergência polinomial vs. exponencial.",
                                "Correta derivação de complexidades computacionais.",
                                "Uso apropriado de exemplos contextualizados (IVP/BVP).",
                                "Análise qualitativa/quantitativa de adequação por suavidade.",
                                "Apresentação clara de trade-offs com evidências numéricas.",
                                "Identificação de limitações reais (aliasing, estabilidade)."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de ondas e fluidos.",
                                "Engenharia Aeronáutica: Fluxos viscosos em aerodinâmica.",
                                "Ciência de Dados: Análise de séries temporais com FFT.",
                                "Meteorologia: Modelos climáticos de alta resolução."
                              ],
                              "realWorldApplication": "Em simulações de turbulência em dinâmica de fluidos computacional (CFD), métodos pseudoespectrais são usados para capturar escalas finas em fluxos suaves (ex: NASA simulations), enquanto diferenças finitas são padrão em solvers comerciais como ANSYS para geometrias complexas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1",
                              "10.1.7.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.1.3.2",
                            "name": "Identificar aplicações e limitações",
                            "description": "Discutir motivações para uso em EDOs não-lineares, PDEs evolutivas e problemas stiff, além de limitações como necessidade de periodicidade ou suavidade, referenciando bibliografia como LeVeque (2007).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as aplicações principais em EDOs não-lineares e PDEs evolutivas",
                                  "subSteps": [
                                    "Ler a seção relevante em LeVeque (2007) sobre métodos espectrais para EDOs não-lineares.",
                                    "Identificar vantagens como alta precisão espectral para soluções suaves.",
                                    "Analisar exemplos de PDEs evolutivas, como equação de onda ou advecção.",
                                    "Anotar motivações: eficiência em capturar não-linearidades sem dissipação numérica.",
                                    "Comparar brevemente com métodos de diferenças finitas."
                                  ],
                                  "verification": "Lista anotada com pelo menos 3 aplicações específicas e suas motivações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Livro LeVeque (2007), capítulos sobre métodos espectrais",
                                    "Caderno de anotações",
                                    "Acesso a PDF ou notas de aula"
                                  ],
                                  "tips": "Enfatize contextos onde a solução é suave e periódica para maximizar vantagens.",
                                  "learningObjective": "Reconhecer cenários onde métodos pseudoespectrais superam métodos tradicionais em precisão e eficiência.",
                                  "commonMistakes": "Ignorar a necessidade de bases de Fourier para periodicidade, confundindo com métodos locais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar aplicações em problemas stiff",
                                  "subSteps": [
                                    "Estudar seção de LeVeque sobre estabilidade em problemas stiff evolutivos.",
                                    "Explicar como a precisão global permite passos de tempo maiores que métodos explícitos.",
                                    "Identificar exemplos como reações químicas ou ondas acústicas com alta frequência.",
                                    "Simular mentalmente um exemplo simples de stiff ODE.",
                                    "Anotar limitações iniciais em stiff não-periódicos."
                                  ],
                                  "verification": "Diagrama ou tabela comparando passos de tempo em métodos pseudoespectrais vs. Runge-Kutta.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "LeVeque (2007)",
                                    "Software como Python/MATLAB para visualização opcional",
                                    "Papel para diagramas"
                                  ],
                                  "tips": "Lembre-se: o 'stiff' refere-se a escalas temporais díspares; espectrais lidam bem via diagonalização.",
                                  "learningObjective": "Entender motivações para stiff problems via precisão espectral e tratamento modal.",
                                  "commonMistakes": "Confundir estabilidade espectral com estabilidade A/L, aplicando a problemas não-suaves."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar limitações principais dos métodos pseudoespectrais",
                                  "subSteps": [
                                    "Discutir requisito de condições periódicas ou domínios periódicos.",
                                    "Explicar fenômeno de Gibbs em soluções não-suaves ou com descontinuidades.",
                                    "Identificar necessidade de suavidade para convergência exponencial.",
                                    "Listar alternativas para violações: mapeamentos de Chebyshev ou filtros.",
                                    "Referenciar exemplos em LeVeque onde métodos falham."
                                  ],
                                  "verification": "Tabela com 4 limitações, impactos e possíveis mitigações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "LeVeque (2007)",
                                    "Exemplos numéricos de código ou figuras do livro"
                                  ],
                                  "tips": "Use o fenômeno de Gibbs como âncora: teste com função quadrada em Fourier.",
                                  "learningObjective": "Discernir contextos onde métodos pseudoespectrais não são adequados.",
                                  "commonMistakes": "Subestimar impacto de não-periodicidade, assumindo extensibilidade trivial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar motivações, aplicações e limitações com referências",
                                  "subSteps": [
                                    "Resumir em parágrafo: aplicações vs. limitações, citando LeVeque (2007).",
                                    "Criar mapa mental conectando EDOs/PDEs/stiff a prós/contras.",
                                    "Preparar discussão: 'Por que usar em Burgers não-linear, mas não em choque?'",
                                    "Verificar referências bibliográficas exatas.",
                                    "Autoavaliar compreensão com perguntas abertas."
                                  ],
                                  "verification": "Resumo escrito de 200 palavras com citação correta e mapa mental.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "LeVeque (2007) para citação precisa",
                                    "Ferramenta de mindmap como papel ou app"
                                  ],
                                  "tips": "Estruture como 'Motivação: X; Aplicação: Y; Limitação: Z' para clareza.",
                                  "learningObjective": "Integrar conhecimentos para discutir criticamente os métodos.",
                                  "commonMistakes": "Citar superficialmente sem conectar a contextos específicos."
                                }
                              ],
                              "practicalExample": "Na equação de Burgers não-linear u_t + u u_x = ν u_xx com baixa viscosidade ν, métodos pseudoespectrais são ideais para capturar o roll-up suave antes do choque, usando FFT para derivadas precisas (LeVeque, 2007, Fig. 8.2), mas falham pós-choque sem filtro de dealiasing devido a Gibbs.",
                              "finalVerifications": [
                                "Lista pelo menos 3 aplicações corretas em EDOs não-lineares, PDEs evolutivas e stiff.",
                                "Explica 2 limitações principais com exemplos (periodicidade e suavidade).",
                                "Cita adequadamente LeVeque (2007) em contexto.",
                                "Discute motivação para um problema específico como Burgers.",
                                "Identifica quando preferir outro método (ex: descontinuidades)."
                              ],
                              "assessmentCriteria": [
                                "Precisão e relevância das aplicações identificadas (30%).",
                                "Profundidade na análise de limitações e mitigações (25%).",
                                "Clareza na discussão de motivações com referências (20%).",
                                "Capacidade de síntese e exemplos concretos (15%).",
                                "Uso correto de terminologia numérica (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: simulações de fluidos e turbulência.",
                                "Ciência da Computação: implementação de FFT e transformadas rápidas.",
                                "Engenharia: modelagem de ondas em estruturas periódicas.",
                                "Matemática Aplicada: análise de estabilidade em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em modelagem climática, métodos pseudoespectrais resolvem PDEs evolutivas de atmosfera (ex: modelo GFDL), explorando periodicidade latitudinal para precisão em simulações de longo prazo, mas com filtros para suavidade em regiões de cisalhamento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.1.3.3",
                            "name": "Motivar o uso em problemas de valor inicial e contorno",
                            "description": "Explicar como os métodos pseudoespectrais superam limitações de métodos de passo simples/múltiplo em estabilidade e precisão para problemas stiff e de contorno, integrando conceitos prévios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender problemas de valor inicial (IVP) e valor de contorno (BVP), com ênfase em problemas stiff",
                                  "subSteps": [
                                    "Definir formalmente um IVP como y' = f(t,y), y(t0)=y0, e um BVP como y'' = f(x,y,y'), com condições em extremos.",
                                    "Explicar o conceito de rigidez (stiff) em IVPs: presença de escalas temporais muito diferentes, exigindo passos de tempo minúsculos para estabilidade.",
                                    "Discutir desafios em BVPs stiff, como instabilidade numérica e necessidade de métodos iterativos.",
                                    "Identificar exemplos: equações de Van der Pol stiff para IVP e problemas elípticos com altos coeficientes para BVP.",
                                    "Revisar conceitos prévios: métodos de Euler, Runge-Kutta e sua relação com estabilidade."
                                  ],
                                  "verification": "Listar 3 exemplos de IVP/BVP stiff e explicar por que são desafiadores para métodos explícitos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre EDOs",
                                    "Livro 'Análise Numérica' de Burden",
                                    "Software MATLAB ou Python para testes simples"
                                  ],
                                  "tips": "Use diagramas de fase para visualizar rigidez em IVPs.",
                                  "learningObjective": "Classificar problemas IVP e BVP, identificando rigidez e suas implicações numéricas.",
                                  "commonMistakes": "Confundir rigidez com não-linearidade; ignorar condições de contorno em IVPs."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar limitações dos métodos de diferenças finitas (passo simples e múltiplo)",
                                  "subSteps": [
                                    "Revisar métodos de passo simples (Euler forward/backward) e múltiplo (RK4): fórmulas e análise de estabilidade via região de estabilidade.",
                                    "Demonstrar que métodos explícitos falham em problemas stiff devido a passos de tempo restritos pelo termo rígido.",
                                    "Explicar problemas em BVPs: método de tiro requer múltiplas IVPs sensíveis a condições iniciais; métodos de relaxação convergem lentamente.",
                                    "Comparar precisão: erro local O(h^p) vs comportamento global em stiff (oscilações ou blow-up).",
                                    "Executar simulação numérica simples para ilustrar falhas."
                                  ],
                                  "verification": "Resolver um IVP stiff com RK4 e h inadequado, observando instabilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código MATLAB para RK4",
                                    "Gráficos de regiões de estabilidade",
                                    "Exercícios resolvidos de análise numérica"
                                  ],
                                  "tips": "Plotar soluções analíticas vs numéricas para visualizar erros.",
                                  "learningObjective": "Quantificar limitações de estabilidade e precisão em métodos clássicos para stiff IVP/BVP.",
                                  "commonMistakes": "Escolher h grande sem verificar estabilidade; não diferenciar explicit vs implícito."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir os fundamentos dos métodos pseudoespectrais",
                                  "subSteps": [
                                    "Explicar expansão em bases espectrais: Fourier para periódicos, Chebyshev para não-periódicos.",
                                    "Descrever método de colocation: resolver globalmente impondo condições nos pontos de Gauss-Lobatto.",
                                    "Discutir diferenciação espectral: derivadas exatas no espaço espectral via multiplicação por ik.",
                                    "Apresentar tratamento de condições de contorno: incorporação direta na matriz.",
                                    "Integrar conceitos prévios: relação com séries de Fourier e polinômios ortogonais."
                                  ],
                                  "verification": "Derivar manualmente a matriz de diferenciação para N=4 pontos Chebyshev.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tutorial de pseudoespectrais em Python (Chebfun ou Dedalus)",
                                    "Tabela de pontos/nós Chebyshev",
                                    "Notas sobre séries de Fourier"
                                  ],
                                  "tips": "Comece com problemas periódicos simples para intuitar precisão exponencial.",
                                  "learningObjective": "Entender a base matemática dos métodos pseudoespectrais e sua natureza global.",
                                  "commonMistakes": "Confundir pseudoespectral com Galerkin; ignorar aliasing."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar vantagens e motivar uso em IVP e BVP stiff",
                                  "subSteps": [
                                    "Comparar estabilidade: filtro espectral natural suprime modos altos sem restrição de h.",
                                    "Destacar precisão: convergência exponencial para soluções suaves, vs polinomial em FD.",
                                    "Para BVPs: resolução direta sem iterações de tiro; para IVPs evolutivos: time-stepping espectral.",
                                    "Discutir limitações: requer soluções suaves, mas ideal para stiff não-oscillatórios.",
                                    "Motivar integração: une análise de Fourier com solvers numéricos prévios."
                                  ],
                                  "verification": "Implementar um BVP stiff simples em pseudoespectral e comparar erro com FD.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código exemplo em Python (numpy + FFT)",
                                    "Benchmark de erros para u'' + 100u = 0"
                                  ],
                                  "tips": "Use log-log plot de erro vs N para mostrar exponencialidade.",
                                  "learningObjective": "Argumentar quantitativamente as superioridades em estabilidade e precisão.",
                                  "commonMistakes": "Superestimar para soluções com Gibbs; não considerar custo computacional."
                                }
                              ],
                              "practicalExample": "Resolva o BVP stiff y'' - 100y = -100*sin(x), y(0)=0, y(pi)=0. Com FD (h=0.01), observe erro ~10^-2 e oscilações; com pseudoespectral Chebyshev (N=16), erro <10^-10 sem restrições de h.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 limitações dos métodos clássicos em stiff BVPs.",
                                "Derivar a vantagem de precisão exponencial com exemplo numérico.",
                                "Identificar quando pseudoespectral é preferível (soluções suaves).",
                                "Comparar regiões de estabilidade qualitativamente.",
                                "Propor um IVP stiff onde pseudoespectral motiva uso.",
                                "Listar 2 conceitos prévios integrados."
                              ],
                              "assessmentCriteria": [
                                "Correção conceitual na distinção IVP/BVP e rigidez (30%)",
                                "Precisão na análise de limitações de métodos clássicos (25%)",
                                "Clareza na explicação de mecanismos pseudoespectrais (20%)",
                                "Qualidade da comparação quantitativa/qualitativa (15%)",
                                "Integração de conceitos prévios e motivação coerente (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de ondas e difusão em meios heterogêneos (equações de contorno).",
                                "Engenharia: Simulações CFD para fluxos viscosos stiff.",
                                "Computação Científica: Uso de FFT em processamento de sinais.",
                                "Matemática Aplicada: Análise de estabilidade em controle de sistemas."
                              ],
                              "realWorldApplication": "Em simulações climáticas, métodos pseudoespectrais resolvem equações de contorno stiff para circulação oceânica, superando limitações de grids finos em modelos globais de alta precisão."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.1.1",
                              "10.1.7.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Expansão em Séries de Fourier",
                    "description": "Representação de funções periódicas por meio de séries de Fourier e truncamento para aproximação numérica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Funções Periódicas e Expansão em Séries Trigonométricas",
                        "description": "Definição de funções periódicas e sua representação única por meio de séries trigonométricas infinitas, incluindo os teoremas de Dirichlet sobre condições de convergência ponto a ponto.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Identificar funções periódicas",
                            "description": "Dado uma função, determinar seu período fundamental e verificar se ela é periódica, distinguindo entre funções pares, ímpares e nem uma nem outra para simplificação da expansão de Fourier.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos fundamentais de funções periódicas",
                                  "subSteps": [
                                    "Defina função periódica: f(x + T) = f(x) para todo x, onde T é o período.",
                                    "Explique o período fundamental como o menor T > 0 que satisfaz a definição.",
                                    "Diferencie funções não-periódicas, como f(x) = x.",
                                    "Revise exemplos clássicos: sin(x) com T=2π, cos(x) com T=2π.",
                                    "Discuta que funções como e^x não são periódicas."
                                  ],
                                  "verification": "Resuma em suas palavras a definição e dê dois exemplos corretos de funções periódicas e não-periódicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Análise Matemática",
                                    "Calculadora gráfica ou software como GeoGebra",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Sempre comece pela definição formal antes de exemplos para evitar confusões.",
                                  "learningObjective": "Compreender e definir precisamente o que torna uma função periódica e seu período fundamental.",
                                  "commonMistakes": [
                                    "Confundir período com amplitude.",
                                    "Assumir que toda função oscilante é periódica (ex: damped sine)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar periodicidade e determinar o período fundamental",
                                  "subSteps": [
                                    "Dado f(x), teste se existe T tal que f(x + T) = f(x) para vários x.",
                                    "Para funções trigonométricas, use fórmulas conhecidas: tan(x) tem T=π.",
                                    "Para funções compostas, encontre o MMC dos períodos individuais.",
                                    "Se não encontrar T finito positivo mínimo, conclua não-periódica.",
                                    "Plote a função para visualização intuitiva do padrão repetitivo."
                                  ],
                                  "verification": "Para f(x) = sin(2x) + cos(3x), calcule e justifique o período fundamental como 2π.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (Desmos ou MATLAB)",
                                    "Papel quadriculado para esboços manuais"
                                  ],
                                  "tips": "Teste múltiplos candidatos para T dividindo o domínio em intervalos.",
                                  "learningObjective": "Aplicar testes para confirmar periodicidade e calcular o período fundamental com precisão.",
                                  "commonMistakes": [
                                    "Escolher múltiplos do período fundamental como 'fundamental'.",
                                    "Ignorar funções com períodos irracionais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar funções como pares, ímpares ou nem uma nem outra",
                                  "subSteps": [
                                    "Defina par: f(-x) = f(x); ímpar: f(-x) = -f(x).",
                                    "Verifique em pontos simétricos: x=0, π/2, etc.",
                                    "Exemplos: cos(x) par, sin(x) ímpar, f(x)=x+sin(x) nem.",
                                    "Relacione com Fourier: pares usam só cossenos, ímpares só senos.",
                                    "Decomponha funções complexas em componentes par/ímpar."
                                  ],
                                  "verification": "Classifique f(x) = x^2 + sin(x) e justifique com cálculos em x e -x.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de funções trigonométricas pares/ímpares",
                                    "Calculadora para avaliações numéricas"
                                  ],
                                  "tips": "Avalie f(0), f(a) e f(-a) para confirmação rápida.",
                                  "learningObjective": "Distinguir simetrias par/ímpar e sua relevância para simplificação de Fourier.",
                                  "commonMistakes": [
                                    "Confundir paridade com periodicidade.",
                                    "Esquecer de verificar em múltiplos pontos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar conceitos para análise completa no contexto de Fourier",
                                  "subSteps": [
                                    "Combine periodicidade e paridade para prever termos na expansão de Fourier.",
                                    "Para função par periódica: só termos cos(x).",
                                    "Para ímpar: só sen(x); geral: ambos.",
                                    "Resolva exercício completo: identifique para f(x)=|sin(x)| (par, T=π).",
                                    "Discuta implicações: simplifica coeficientes de Fourier."
                                  ],
                                  "verification": "Analise f(x)=e^{-x^2} sin(x) quanto a periodicidade e paridade, explicando impacto em Fourier.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre séries de Fourier",
                                    "Exercícios resolvidos de livros como Apostol"
                                  ],
                                  "tips": "Sempre relacione de volta ao objetivo de Fourier para manter foco.",
                                  "learningObjective": "Aplicar identificação de periodicidade e paridade para otimizar expansões de Fourier.",
                                  "commonMistakes": [
                                    "Assumir periodicidade infinita sem prova.",
                                    "Ignorar que Gaussianas não são periódicas."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise f(x) = sin(πx) + cos(2πx). Passos: (1) Período fundamental T=2 (MMC de 2 e 1). (2) Verifique f(x+2)=f(x). (3) Paridade: nem par nem ímpar (f(-x) ≠ ±f(x)). (4) Para Fourier: usa ambos senos e cossenos.",
                              "finalVerifications": [
                                "Corretamente define e exemplifica função periódica com período fundamental.",
                                "Calcula T para funções trigonométricas compostas sem erros.",
                                "Classifica corretamente 5 funções como par, ímpar ou nem.",
                                "Explica simplificação de Fourier baseada em paridade.",
                                "Identifica não-periódicas como polinomiais ou exponenciais.",
                                "Aplica conceitos em plotagens ou cálculos numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e cálculo de período fundamental (40%).",
                                "Correta classificação de paridade com justificativa (30%).",
                                "Integração com contexto de Fourier (15%).",
                                "Uso de verificações e exemplos práticos (10%).",
                                "Clareza e ausência de erros comuns (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas sonoras e sinais periódicos.",
                                "Engenharia: Processamento de sinais digitais (FFT).",
                                "Computação: Algoritmos numéricos para séries de Fourier.",
                                "Física Quântica: Funções de onda periódicas em cristais."
                              ],
                              "realWorldApplication": "Em engenharia de telecomunicações, identificar periodicidade e paridade de sinais permite compressão eficiente via Fourier, otimizando transmissão de áudio e vídeo em redes 5G."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Escrever a forma geral da série de Fourier",
                            "description": "Formular a expansão de Fourier de uma função periódica f(x) com período 2π como soma de senos e cossenos, incluindo os termos de Fourier a0, an e bn.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os fundamentos de funções periódicas e a necessidade da série de Fourier",
                                  "subSteps": [
                                    "Defina uma função periódica f(x) com período 2π, ou seja, f(x + 2π) = f(x) para todo x.",
                                    "Revise as condições de Dirichlet para a convergência da série de Fourier (função piecewise contínua, número finito de descontinuidades).",
                                    "Explique por que decompomos f(x) em senos e cossenos: eles formam uma base ortogonal no espaço L2[-π, π].",
                                    "Identifique o intervalo fundamental [-π, π] para o cálculo dos coeficientes.",
                                    "Discuta a representação como soma infinita: f(x) ≈ a0/2 + Σ [an cos(nx) + bn sen(nx)]."
                                  ],
                                  "verification": "Escreva a definição de função periódica e liste as condições de Dirichlet em um papel, confirmando com um exemplo simples como f(x) = sen(x).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Análise de Fourier (capítulo introdutório)",
                                    "Folha de papel e caneta",
                                    "Calculadora para gráficos básicos"
                                  ],
                                  "tips": [
                                    "Visualize funções periódicas plotando-as em software como Desmos ou GeoGebra.",
                                    "Lembre-se: o período 2π simplifica os argumentos dos trigonométricos."
                                  ],
                                  "learningObjective": "Compreender o contexto teórico que justifica a expansão em série de Fourier.",
                                  "commonMistakes": [
                                    "Confundir período 2π com 2L genérico.",
                                    "Ignorar condições de convergência, assumindo validade para qualquer função."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e formular o termo constante a0",
                                  "subSteps": [
                                    "Derive a fórmula de a0: a0 = (1/π) ∫_{-π}^{π} f(x) dx, que representa a média da função no período.",
                                    "Explique o fator 1/2 na série: f(x) = a0/2 + Σ [...], para normalizar com os outros termos.",
                                    "Calcule a0 para uma função exemplo, como f(x) = x em [-π, π].",
                                    "Verifique ortogonalidade: ∫ cos(nx) dx = 0 para n≠0 no intervalo.",
                                    "Pratique normalizando a integral para o comprimento do período."
                                  ],
                                  "verification": "Compute a0 para f(x) = |x| em [-π, π] e confirme que é 2π/π = 2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de integração simbólica como Wolfram Alpha",
                                    "Caderno de exercícios",
                                    "Tabela de integrais trigonométricas"
                                  ],
                                  "tips": [
                                    "a0/2 é a componente DC em sinais; pense em termos de média.",
                                    "Use simetria: para funções pares, bn=0; ímpares, an=0."
                                  ],
                                  "learningObjective": "Dominar o cálculo e o papel do termo constante na série de Fourier.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/π em a0.",
                                    "Colocar a0 sem dividir por 2 na soma."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular os coeficientes harmônicos an e bn",
                                  "subSteps": [
                                    "Escreva an = (1/π) ∫_{-π}^{π} f(x) cos(nx) dx para n=1,2,...",
                                    "Escreva bn = (1/π) ∫_{-π}^{π} f(x) sen(nx) dx para n=1,2,...",
                                    "Derive essas fórmulas da ortogonalidade: <cos(mx),cos(nx)> = π δ_{mn} para m,n≥1.",
                                    "Calcule an e bn para f(x) = x² em [-π, π], explorando paridade (par: bn=0).",
                                    "Liste as propriedades: funções pares afetam só an, ímpares só bn."
                                  ],
                                  "verification": "Derive an para f(x) par e confirme bn=0 integrando sen(nx) f(x) (ímpar).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora gráfica TI-84 ou app de integrais",
                                    "Exercícios resolvidos de Fourier",
                                    "Quadro branco para derivação"
                                  ],
                                  "tips": [
                                    "Memorize o fator 1/π comum; π vem do comprimento 2π/2.",
                                    "Use tabelas de integrais para funções comuns como polinômios."
                                  ],
                                  "learningObjective": "Calcular com precisão os coeficientes an e bn usando integrais definidas.",
                                  "commonMistakes": [
                                    "Usar ∫_0^π em vez de [-π,π] sem ajustar.",
                                    "Confundir sen e cos nos argumentos nx."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever e verificar a forma geral completa da série de Fourier",
                                  "subSteps": [
                                    "Combine tudo: f(x) = a0/2 + Σ_{n=1}^∞ [an cos(nx) + bn sen(nx)].",
                                    "Escreva explicitamente com as fórmulas de a0, an, bn acima.",
                                    "Teste com função conhecida: série de Fourier de onda quadrada (só bn não-nulos).",
                                    "Discuta truncamento: soma finita N termos aproxima f(x).",
                                    "Verifique convergência ponto a ponto em pontos de continuidade."
                                  ],
                                  "verification": "Escreva a série completa para f(x) = x em [-π, π] (série sen(nx)/n) e plote os primeiros termos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/MATLAB para plotar somas parciais",
                                    "Papel para anotar a fórmula final",
                                    "Exemplos online de séries de Fourier"
                                  ],
                                  "tips": [
                                    "Sempre inclua o Σ_{n=1}^∞ e os limites de integral.",
                                    "Pratique escrevendo de memória 3 vezes."
                                  ],
                                  "learningObjective": "Formular corretamente a expansão geral da série de Fourier para qualquer f periódica.",
                                  "commonMistakes": [
                                    "Escrever soma de n=0 (errado para an,bn).",
                                    "Omitir limites [-π,π] nas integrais."
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x em [-π, π] (período 2π), a0=0 (ímpar), an=0 (ímpar), bn = 2(-1)^{n+1}/n, então f(x) = 2 Σ_{n=1}^∞ [(-1)^{n+1}/n] sen(nx). Plote somas parciais para ver convergência tipo Gibbs.",
                              "finalVerifications": [
                                "Escreva a fórmula geral de cor sem olhar notas.",
                                "Calcule a0, a1, b1 corretamente para f(x)=cos(x).",
                                "Identifique erros em uma fórmula incompleta fornecida.",
                                "Explique o papel de cada coeficiente em 1 minuto.",
                                "Aplique a paridade para simplificar uma função dada.",
                                "Compare com expansão complexa e^{inx}."
                              ],
                              "assessmentCriteria": [
                                "Correção na fórmula: a0/2 + Σ [an cos(nx) + bn sen(nx)] (peso 30%).",
                                "Fórmulas exatas de a0, an, bn com integrais e fator 1/π (peso 25%).",
                                "Uso correto de limites [-π, π] e período 2π (peso 15%).",
                                "Compreensão de ortogonalidade e paridade (peso 15%).",
                                "Exemplo prático resolvido sem erros (peso 10%).",
                                "Explicação clara da convergência (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas sonoras e vibrações harmônicas.",
                                "Engenharia: Processamento de sinais digitais (pré-FFT).",
                                "Computação: Implementação numérica de somas de Fourier em Python/NumPy.",
                                "Estatística: Decomposição em componentes principais semelhantes.",
                                "Áudio: Síntese de sons via harmônicos."
                              ],
                              "realWorldApplication": "Em engenharia de sinais, a série de Fourier decompõe áudio em frequências para compressão MP3; em análise de vibrações, detecta falhas em máquinas industriais via espectros de Fourier."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Aplicar propriedades de pares e ímpares",
                            "description": "Simplificar o cálculo dos coeficientes de Fourier explorando simetrias: para funções pares, apenas termos coseno; para ímpares, apenas senos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Identificar Funções Pares e Ímpares",
                                  "subSteps": [
                                    "Defina função par: f(-x) = f(x) para todo x no domínio.",
                                    "Defina função ímpar: f(-x) = -f(x) para todo x no domínio.",
                                    "Teste exemplos simples: f(x) = x² (par), f(x) = x (ímpar), f(x) = |x| (par).",
                                    "Grafique funções em intervalos simétricos como [-π, π] para visualizar simetria.",
                                    "Classifique uma função dada como par, ímpar ou nem uma nem outra."
                                  ],
                                  "verification": "Crie uma tabela resumindo definições, exemplos e classificações de 3 funções; confira se atende as definições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora gráfica ou app de plotagem (Desmos/Geogebra)"
                                  ],
                                  "tips": "Lembre-se: simetria em torno do eixo y para pares, origem para ímpares.",
                                  "learningObjective": "Identificar corretamente funções pares e ímpares em contextos periódicos.",
                                  "commonMistakes": [
                                    "Confundir com simetria gráfica sem verificar algebricamente",
                                    "Ignorar o domínio simétrico [-L, L]"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Propriedades de Simetria de Senos e Cossenos",
                                  "subSteps": [
                                    "Verifique: cos(-x) = cos(x) (par), sin(-x) = -sin(x) (ímpar).",
                                    "Integre sobre [-π, π]: ∫ f(x) sin(nx) dx para f par resulta em 0.",
                                    "Mostre: ∫ f(x) cos(nx) dx para f ímpar resulta em 0.",
                                    "Derive graficamente ou algebricamente por que isso ocorre.",
                                    "Escreva as fórmulas gerais para integrais de produtos simétricos."
                                  ],
                                  "verification": "Calcule manualmente ∫_{-π}^π x sin(x) dx e confirme = 0 (ímpar * ímpar = par, mas espere resultado específico).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de fórmulas trigonométricas",
                                    "Software de cálculo simbólico (Wolfram Alpha)"
                                  ],
                                  "tips": "Use propriedade: integral de ímpar em intervalo simétrico é zero.",
                                  "learningObjective": "Compreender por que certos termos de Fourier desaparecem baseado em simetria.",
                                  "commonMistakes": [
                                    "Esquecer que produto par*ímpar = ímpar",
                                    "Não simetrizar o intervalo de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Simetrias aos Coeficientes de Fourier",
                                  "subSteps": [
                                    "Lembre fórmula: a_n = (1/π) ∫_{-π}^π f(x) cos(nx) dx; b_n similar com sin.",
                                    "Para f par: b_n = 0 (apenas cossenos), a_0 = (1/π) ∫ f(x) dx.",
                                    "Para f ímpar: a_n = 0 (apenas senos).",
                                    "Escreva a série simplificada: f(x) ≈ a_0/2 + Σ a_n cos(nx) para par.",
                                    "Pratique reescrevendo a fórmula geral para casos pares/ímpares."
                                  ],
                                  "verification": "Reescreva as fórmulas de a_n e b_n para uma função par genérica e verifique com um exemplo numérico simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para derivações",
                                    "Tabela de integrais trigonométricas"
                                  ],
                                  "tips": "Foque na metade positiva do intervalo e dobre para pares: a_n = (2/π) ∫_0^π f(x) cos(nx) dx.",
                                  "learningObjective": "Simplificar cálculos de coeficientes usando simetria par/ímpar.",
                                  "commonMistakes": [
                                    "Calcular termos desnecessários",
                                    "Erros nos fatores de normalização (1/π vs 2/π)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e Verificar Expansão Simplificada",
                                  "subSteps": [
                                    "Escolha f(x) par ou ímpar no exemplo prático abaixo.",
                                    "Calcule apenas os coeficientes relevantes usando a simplificação.",
                                    "Aproxime f(x) com 3-5 termos da série.",
                                    "Compare gráfico da original vs aproximação.",
                                    "Analise erro e adicione mais termos se necessário."
                                  ],
                                  "verification": "Plote ou tabule valores: erro médio < 5% em pontos de teste.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python/MATLAB com numpy/scipy para Fourier",
                                    "Gráficos manuais"
                                  ],
                                  "tips": "Use expansão por partes para integrais complicadas.",
                                  "learningObjective": "Executar cálculo completo de Fourier simplificado e validar.",
                                  "commonMistakes": [
                                    "Não normalizar corretamente a_0",
                                    "Confundir índices n=0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = x² (par) em [-π, π]: Apenas termos coseno. Calcule a_0 = (2/π) ∫_0^π x² dx = 2π²/3; a_n = (2/π) ∫_0^π x² cos(nx) dx = 4(-1)^n / n². Série: π²/3 + Σ 4(-1)^n cos(nx)/n².",
                              "finalVerifications": [
                                "Identifica corretamente se função é par ou ímpar.",
                                "Elimina termos irrelevantes nos coeficientes.",
                                "Calcula coeficientes com fator 2/π para metade intervalo.",
                                "Reconstrói série com precisão em pelo menos 80% dos pontos.",
                                "Explica verbalmente por que simetria simplifica.",
                                "Aplica a uma função não-polinomial (ex: sawtooth ímpar)."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica nos cálculos (sem erros de sinal/fator).",
                                "Eficiência: usa simplificação corretamente, reduzindo integrais pela metade.",
                                "Validação numérica/gráfica da aproximação.",
                                "Explicação clara da simetria subjacente.",
                                "Generalização para funções arbitrárias.",
                                "Tempo de execução otimizado via simetria."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas simétricas (ex: vibrações pares em cordas).",
                                "Engenharia de Sinais: Processamento de áudio com FFT explorando simetrias.",
                                "Computação: Algoritmos FFT otimizados para dados reais/ímpares.",
                                "Estatística: Funções densidade de probabilidade pares."
                              ],
                              "realWorldApplication": "Em processamento de sinais digitais (ex: compressão de áudio JPEG2000 usa simetrias para DCT rápida), análise de vibrações em engenharia mecânica e modelagem de ondas acústicas simétricas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Cálculo dos Coeficientes de Fourier",
                        "description": "Determinação dos coeficientes da série de Fourier por meio de integrais definidas, com fórmulas explícitas para a0, an e bn em intervalos de período.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Calcular coeficiente a0",
                            "description": "Computar o coeficiente médio a0/2 como a integral da função sobre um período dividido pelo comprimento do período, interpretando-o como o valor médio da função.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito e a fórmula do coeficiente a0",
                                  "subSteps": [
                                    "Revise a definição de série de Fourier e o papel do termo constante a0/2 como componente de frequência zero.",
                                    "Memorize a fórmula: a0/2 = (1/T) ∫_{t=0}^{T} f(t) dt, onde T é o período.",
                                    "Entenda que a0/2 representa o valor médio da função periódica ao longo de um período.",
                                    "Compare com o valor médio em estatística para reforçar a interpretação.",
                                    "Escreva a fórmula adaptada para intervalo [-π, π], comum em Fourier: a0/2 = (1/(2π)) ∫_{-π}^{π} f(x) dx."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o significado de a0/2 e reescreva a fórmula corretamente para um período genérico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Análise de Fourier, quadro branco ou papel para anotações.",
                                  "tips": "Visualize a função como uma onda e o termo a0/2 como a linha reta que melhor se ajusta em média.",
                                  "learningObjective": "Dominar a interpretação conceitual de a0 como valor médio da função periódica.",
                                  "commonMistakes": "Confundir a0 com a0/2; esquecer que é dividido pelo comprimento total do período."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o período da função e configurar os limites de integração",
                                  "subSteps": [
                                    "Determine o período T da função f(x) dada (ex: para sen(2x), T=π).",
                                    "Escolha os limites de integração: de 0 a T ou -T/2 a T/2 para simetria.",
                                    "Verifique se a função é periódica; se não, ajuste ou note limitações.",
                                    "Anote os limites explicitamente, ex: para T=2π, ∫_{-π}^{π}.",
                                    "Confirme unidades consistentes (ex: radianos para funções trigonométricas)."
                                  ],
                                  "verification": "Liste corretamente o período T e os limites de integração para uma função exemplo como f(x)=cos(x).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráfica da função (software como Desmos ou GeoGebra), calculadora.",
                                  "tips": "Sempre grafique a função primeiro para visualizar um período completo.",
                                  "learningObjective": "Configurar corretamente os parâmetros de integração para qualquer função periódica.",
                                  "commonMistakes": "Escolher limites errados, como 0 a 2π para funções com T=π; ignorar simetria par/ímpar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a integral definida da função sobre o período",
                                  "subSteps": [
                                    "Encontre a antiderivada primitiva F(x) de f(x).",
                                    "Avalie F(b) - F(a), onde [a,b] são os limites do período.",
                                    "Use propriedades de integração para funções pares/ímpares (ímpar integra a 0).",
                                    "Para funções complicadas, use integração por partes ou substituição.",
                                    "Verifique numericamente com software se possível."
                                  ],
                                  "verification": "Compute a integral para f(x)=x^2 em [-π, π] e obtenha (2π^3)/3.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela de integrais, software simbólico (Wolfram Alpha ou Mathematica), papel milimetrado.",
                                  "tips": "Aproveite simetria: funções ímpares têm integral zero sobre período simétrico.",
                                  "learningObjective": "Executar integral definida precisa sobre intervalos periódicos.",
                                  "commonMistakes": "Erros em limites de integração; esquecer fator 2 em funções pares; cálculo aritmético incorreto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a fórmula para obter a0/2 e interpretar o resultado",
                                  "subSteps": [
                                    "Divida o valor da integral pelo comprimento do período T.",
                                    "Multiplique por 2 se a convenção for para a0 completo.",
                                    "Interprete: se a0/2 ≈ altura média da função.",
                                    "Compare com amostragem numérica (média de pontos equidistantes).",
                                    "Registre o resultado com precisão decimal e fracionária."
                                  ],
                                  "verification": "Para f(x)=x^2 em [-π, π], calcule a0/2 = π^2/3 e explique como valor médio.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora científica, planilha Excel para verificação numérica.",
                                  "tips": "Sempre reduza frações e verifique dimensionalidade.",
                                  "learningObjective": "Finalizar o cálculo de a0/2 e ligá-lo conceitualmente ao valor médio.",
                                  "commonMistakes": "Dividir incorretamente (ex: por π em vez de 2π); confundir a0 e a0/2 na interpretação."
                                }
                              ],
                              "practicalExample": "Para f(x) = x^2 no período [-π, π] (T=2π): ∫_{-π}^{π} x^2 dx = 2π^3/3. Então a0/2 = (2π^3/3)/(2π) = π^2/3 ≈ 3.2899, que é o valor médio de x^2 nesse intervalo.",
                              "finalVerifications": [
                                "Calcule corretamente a0/2 para f(x)=cos(2x) (deve ser 0).",
                                "Explique por que funções ímpares têm a0=0.",
                                "Verifique numericamente com 10 pontos equidistantes e compare erro <1%.",
                                "Aplique a fórmula para f(x)=|sin(x)| e obtenha a0/2=2/π.",
                                "Interprete a0/2 como linha de melhor ajuste horizontal no gráfico.",
                                "Resolva para período não padrão, ex: T=4, f(t)=t em [0,4]."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da integral (erro <0.01).",
                                "Correta identificação do período e limites.",
                                "Interpretação conceitual clara de a0/2 como média.",
                                "Uso apropriado de simetria par/ímpar.",
                                "Verificação cruzada numérica ou gráfica.",
                                "Apresentação organizada com passos documentados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de sinais harmônicos em ondas sonoras.",
                                "Engenharia: Processamento de sinais digitais (pré-FFT).",
                                "Computação: Implementação numérica em Python (SciPy).",
                                "Estatística: Conceito de valor médio e expectativa."
                              ],
                              "realWorldApplication": "Em processamento de áudio, a0/2 captura o nível DC (offset médio) de um sinal, essencial para remoção de ruído em microfones ou análise espectral em telecomunicações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Calcular coeficientes an e bn",
                            "description": "Avaliar as integrais ortogonalidade para an = (1/π) ∫ f(x) cos(nx) dx e bn = (1/π) ∫ f(x) sen(nx) dx de -π a π, resolvendo exemplos analíticos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as propriedades de ortogonalidade das funções trigonométricas",
                                  "subSteps": [
                                    "Revise as funções cos(nx) e sin(nx) para n inteiro no intervalo [-π, π].",
                                    "Estude a integral de ortogonalidade: ∫_{-π}^π cos(mx)cos(nx) dx = π δ_{mn} para m,n ≥1, e similares para sin e produtos mistos.",
                                    "Memorize as normas: ∫_{-π}^π cos²(nx) dx = π e ∫_{-π}^π sin²(nx) dx = π para n≥1.",
                                    "Verifique com n=0: ∫_{-π}^π 1 dx = 2π para o termo constante.",
                                    "Pratique calculando duas integrais de exemplo manualmente."
                                  ],
                                  "verification": "Resolva corretamente 3 integrais de ortogonalidade diferentes sem consultar notas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, calculadora científica, tabela de integrais trigonométricas.",
                                  "tips": "Use simetria par/impar das funções para simplificar cálculos.",
                                  "learningObjective": "Entender por que cos(nx) e sin(nx) formam uma base ortogonal para expansões de Fourier.",
                                  "commonMistakes": "Confundir os fatores de normalização (π vs 2π); esquecer o caso n=0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e aplicar a fórmula do coeficiente an",
                                  "subSteps": [
                                    "Parta da expansão f(x) ~ a0/2 + Σ an cos(nx) + bn sin(nx).",
                                    "Multiplique ambos os lados por cos(mx) e integre de -π a π, usando ortogonalidade.",
                                    "Isolar an = (1/π) ∫_{-π}^π f(x) cos(nx) dx para n≥1.",
                                    "Discuta o caso a0 separadamente: a0 = (1/π) ∫ f(x) dx.",
                                    "Calcule an para uma função par simples, como f(x)=x²."
                                  ],
                                  "verification": "Derive a fórmula de an do zero e compute an para f(x)=cos(x), obtendo an=1 para n=1 e 0 caso contrário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de caderno quadriculado, software simbólico como Wolfram Alpha para verificação opcional.",
                                  "tips": "Funções pares simplificam bn=0; foque em simetria.",
                                  "learningObjective": "Dominar o cálculo projetivo de f(x) sobre cos(nx).",
                                  "commonMistakes": "Esquecer o fator 1/π; inverter limites de integração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e aplicar a fórmula do coeficiente bn",
                                  "subSteps": [
                                    "Repita o processo multiplicando por sin(mx) e integrando.",
                                    "Obtenha bn = (1/π) ∫_{-π}^π f(x) sin(nx) dx para n≥1.",
                                    "Note que bn=0 para funções pares e an=0 para ímpares.",
                                    "Calcule bn para f(x)=x (ímpar) no intervalo [-π, π].",
                                    "Compare com an para a mesma função."
                                  ],
                                  "verification": "Compute bn para f(x)=sin(2x), confirmando bn=1 para n=2 e 0 caso contrário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmos do step anterior, tabela de integrais indefinidas.",
                                  "tips": "Sin(nx) é ímpar, então integre apenas de 0 a π e dobre para funções ímpares.",
                                  "learningObjective": "Aplicar projeção sobre a base sin(nx).",
                                  "commonMistakes": "Usar cos em vez de sin na multiplicação; normalização errada para n=0 (bn0 não existe)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver um exemplo analítico completo e verificar",
                                  "subSteps": [
                                    "Escolha f(x)=x em [-π, π]; compute a0, an e bn.",
                                    "Encontre an=0 (paridade), bn = 2(-1)^{n+1}/n.",
                                    "Escreva a série parcial: Σ bn sin(nx).",
                                    "Plote ou avalie em pontos para verificar convergência (ex: em x=π/2).",
                                    "Compare com a função original graficamente."
                                  ],
                                  "verification": "A série reconstrói f(x) com erro <0.1 em 5 pontos testados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráfica manual ou software como Desmos/Mathematica, calculadora.",
                                  "tips": "Comece com poucos termos (N=5) para ver Gibbs phenomenon.",
                                  "learningObjective": "Integrar cálculo de an e bn em uma expansão de Fourier completa.",
                                  "commonMistakes": "Erros de sinal em bn; esquecer periodicidade fora [-π,π]."
                                }
                              ],
                              "practicalExample": "Para f(x) = x em [-π, π], an = 0 (função ímpar), bn = (2/π) ∫_0^π x sin(nx) dx = 2(-1)^{n+1}/n. Série: 2 Σ_{n=1}^∞ (-1)^{n+1} sin(nx)/n.",
                              "finalVerifications": [
                                "Derivar fórmulas de an e bn usando ortogonalidade sem erros.",
                                "Calcular coeficientes para f(x)=x² corretamente (an explícito).",
                                "Identificar simetrias par/ímpar em funções dadas.",
                                "Reconstruir série de Fourier parcial e avaliar em 3 pontos.",
                                "Explicar verbalmente o papel da normalização 1/π.",
                                "Resolver variação: f(x)=|x|."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas integrais (erro <1%).",
                                "Correta aplicação de propriedades de ortogonalidade.",
                                "Uso apropriado de simetria para simplificação.",
                                "Verificação numérica da série (erro médio <5%).",
                                "Clareza na derivação passo a passo.",
                                "Identificação de pelo menos 2 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas harmônicas e vibrações.",
                                "Engenharia: Processamento de sinais e filtros FFT.",
                                "Computação: Implementação numérica via Quadratura Gauss.",
                                "Física Computacional: Métodos espectrais em PDEs."
                              ],
                              "realWorldApplication": "Cálculo de coeficientes em análise de sinais de áudio (compressão MP3), simulações de fluxo de fluidos via métodos pseudoespectrais, e decomposição de espectros em telescópios astronômicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Aproximação numérica dos coeficientes",
                            "description": "Usar quadratura numérica (ex: trapézio ou Simpson) para estimar integrais de coeficientes quando a função não permite integração analítica exata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e preparar a função",
                                  "subSteps": [
                                    "Identificar a função f(x) periódica de período 2π que não permite integração analítica exata com e^{-ikx}.",
                                    "Definir o intervalo de integração de -π a π.",
                                    "Selecionar o índice k do coeficiente de Fourier c_k a ser aproximado.",
                                    "Verificar a normalização: c_k ≈ (1/(2π)) ∫ f(x) e^{-ikx} dx.",
                                    "Plotar f(x) para visualizar o comportamento."
                                  ],
                                  "verification": "Lista com f(x), k, intervalo e plotagem confirmados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de plotagem (Desmos, Python com Matplotlib ou MATLAB)"
                                  ],
                                  "tips": "Comece com funções como f(x) = exp(sin(x)) ou |x| em [-π, π] para testes iniciais.",
                                  "learningObjective": "Compreender o contexto e setup para aproximação numérica de coeficientes de Fourier.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/(2π)",
                                    "Usar intervalo incorreto (ex: 0 a 2π sem ajuste)",
                                    "Escolher k=0 sem cuidado com simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e configurar o método de quadratura",
                                  "subSteps": [
                                    "Comparar regras: trapézio (simples, ordem 2) vs. Simpson (ordem 4, par N).",
                                    "Definir número de pontos N (ex: N=100 para trapézio, N par para Simpson).",
                                    "Calcular passo h = 2π / N e pontos x_j = -π + j*h, j=0 a N.",
                                    "Definir pesos: trapézio w_0=w_N=h/2, outros h; Simpson alternados.",
                                    "Preparar a integrando g(x) = f(x) * exp(-i k x)."
                                  ],
                                  "verification": "Fórmulas de h, x_j e pesos listados corretamente para o método escolhido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python/Octave para pré-cálculos",
                                    "Tabela de fórmulas de quadratura"
                                  ],
                                  "tips": "Use Simpson para maior precisão com custo similar; teste com N pequeno primeiro.",
                                  "learningObjective": "Selecionar e parametrizar método de quadratura adequado para integrais complexas.",
                                  "commonMistakes": [
                                    "N ímpar em Simpson",
                                    "Confundir pesos de extremidade no trapézio",
                                    "Esquecer o i complexo em exp"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o cálculo da soma aproximada",
                                  "subSteps": [
                                    "Avaliar g(x_j) em cada ponto x_j.",
                                    "Calcular soma S ≈ ∑ w_j * g(x_j).",
                                    "Computar c_k ≈ S / (2π).",
                                    "Implementar em código (Python/Octave/MATLAB) para automação.",
                                    "Separar parte real e imaginária de c_k."
                                  ],
                                  "verification": "Código executado e c_k numérico obtido com pelo menos 4 casas decimais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Jupyter Notebook, MATLAB)",
                                    "Bibliotecas: numpy (Python) ou built-in"
                                  ],
                                  "tips": "Use loop vetorizado para eficiência; debugue com k=0 (deve ser real).",
                                  "learningObjective": "Executar computacionalmente a quadratura numérica para integrais de Fourier.",
                                  "commonMistakes": [
                                    "Erro de índice em loops",
                                    "Dividir por 2π após soma errada",
                                    "Ignorar conjugado complexo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar precisão e refinar a aproximação",
                                  "subSteps": [
                                    "Comparar com valor analítico se conhecido (ex: k=0 para funções pares).",
                                    "Aumentar N e observar convergência (erro O(1/N^2) trapézio).",
                                    "Calcular múltiplos c_k para série de Fourier parcial.",
                                    "Analisar erro: |c_k^{N} - c_k^{2N}| como estimativa.",
                                    "Documentar precisão alcançada."
                                  ],
                                  "verification": "Gráfico de convergência com N variando e erro < 10^{-4}.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código do passo anterior",
                                    "Ferramentas de plotagem de erro"
                                  ],
                                  "tips": "Log-plot de erro vs N para confirmar ordem de convergência.",
                                  "learningObjective": "Avaliar e otimizar a precisão da aproximação numérica.",
                                  "commonMistakes": [
                                    "Não testar com N maior",
                                    "Confundir erro de arredondamento com truncamento",
                                    "Ignorar oscilações de Gibbs"
                                  ]
                                }
                              ],
                              "practicalExample": "Aproxime c_3 para f(x) = exp(sin(x)) em [-π, π] usando regra de Simpson com N=200 pontos. Implemente em Python: def f(x): return np.exp(np.sin(x)); g(x) = f(x)*np.exp(-1j*3*x); some com pesos Simpson e normalize por 2π. Resultado esperado: Re(c_3) ≈ -0.135, Im(c_3) ≈ -0.090 (com precisão 10^{-5}).",
                              "finalVerifications": [
                                "Implementa corretamente trapézio e Simpson para c_k.",
                                "Código converge com N→∞ para funções teste.",
                                "Identifica quando quadratura é superior a FFT para funções não-amostradas.",
                                "Calcula pelo menos 5 coeficientes com erro <10^{-4}.",
                                "Explica trade-off precisão vs custo computacional.",
                                "Aplica a uma função real sem antiderivada conhecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão da aproximação (erro relativo < 0.1%).",
                                "Correção na implementação de pesos e normalização.",
                                "Eficiência: tempo de execução para N=1000 < 1s.",
                                "Análise de convergência demonstrada graficamente.",
                                "Uso apropriado de complexos e partes real/imaginária.",
                                "Documentação clara do código e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação em Python/Octave com NumPy.",
                                "Processamento de Sinais: Base para FFT e análise espectral.",
                                "Física Computacional: Séries de Fourier em equações de ondas.",
                                "Engenharia: Simulações em métodos pseudoespectrais para PDEs.",
                                "Estatística: Aproximação de momentos via integrais numéricas."
                              ],
                              "realWorldApplication": "Em processamento de sinais digitais (áudio/imagens), onde funções amostradas requerem coeficientes aproximados para transformada discreta de Fourier; simulações numéricas em mecânica quântica e fluidodinâmica via métodos espectrais, evitando computação analítica custosa."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Truncamento e Aproximação Numérica da Série",
                        "description": "Truncamento da série infinita em N termos para obter aproximação polinomial trigonométrica, análise de erro e introdução à Transformada Rápida de Fourier (FFT) para computação eficiente.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Truncar a série de Fourier",
                            "description": "Escrever a aproximação SN(x) = a0/2 + Σ (an cos(nx) + bn sen(nx)) para n=1 a N, plotando gráficos comparativos com a função original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular os coeficientes de Fourier a0, an e bn para uma função periódica dada",
                                  "subSteps": [
                                    "Escolha uma função periódica f(x) com período 2π, como uma onda quadrada ou dente de serra.",
                                    "Calcule o coeficiente a0 = (1/π) ∫_{-π}^{π} f(x) dx.",
                                    "Calcule an = (1/π) ∫_{-π}^{π} f(x) cos(nx) dx para n=1 a N.",
                                    "Calcule bn = (1/π) ∫_{-π}^{π} f(x) sin(nx) dx para n=1 a N.",
                                    "Use integração analítica ou numérica (ex: trapz no MATLAB/Python) para valores exatos ou aproximados."
                                  ],
                                  "verification": "Verifique se os coeficientes calculados satisfazem propriedades como a0/2 sendo a média da função e an/bn decaindo para funções suaves.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Função f(x) de exemplo",
                                    "Calculadora simbólica (SymPy ou Wolfram Alpha)",
                                    "Papel e lápis ou software de integração numérica"
                                  ],
                                  "tips": "Para funções pares, bn=0; para ímpares, an=0. Sempre normalize pelo período.",
                                  "learningObjective": "Dominar o cálculo preciso dos coeficientes Fourier para preparar a truncagem.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/π nos coeficientes",
                                    "Limites de integração errados (deve ser sobre um período)",
                                    "Confundir sen e cos nas fórmulas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a fórmula da aproximação truncada SN(x)",
                                  "subSteps": [
                                    "Escreva SN(x) = a0/2 + Σ_{n=1}^N [an cos(nx) + bn sen(nx)].",
                                    "Substitua os coeficientes calculados na Step 1 na fórmula.",
                                    "Simplifique a expressão para N pequeno (ex: N=1,2) para verificação manual.",
                                    "Discuta o erro de truncagem: |f(x) - SN(x)| diminui com N crescente.",
                                    "Teste a fórmula em pontos específicos, como x=0 ou x=π/2."
                                  ],
                                  "verification": "Avalie SN(x) em pontos conhecidos e compare manualmente com f(x); erro deve ser pequeno para N alto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Coeficientes da Step 1",
                                    "Fórmulas anotadas",
                                    "Calculadora para avaliação pontual"
                                  ],
                                  "tips": "Lembre-se: a0/2 é o termo constante; sen(nx) captura partes ímpares.",
                                  "learningObjective": "Construir corretamente a soma parcial da série de Fourier truncada.",
                                  "commonMistakes": [
                                    "Esquecer a0/2",
                                    "Índice de soma errado (de 0 ou 1?)",
                                    "Sinais errados em an ou bn"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a truncagem numericamente em software",
                                  "subSteps": [
                                    "Configure um ambiente de programação (Python com NumPy/Matplotlib ou MATLAB).",
                                    "Defina a função f(x) e calcule coeficientes numericamente usando integração (quad ou trapz).",
                                    "Implemente uma função para computar SN(x) em uma grade de pontos x.",
                                    "Gere arrays para múltiplos N (ex: 1,5,10,20) para análise de convergência.",
                                    "Otimize o código para N até 100, evitando loops lentos (use vetores)."
                                  ],
                                  "verification": "Execute o código e confira que SN(x) reproduz f(x) em pontos amostrados com erro <1e-3 para N=20.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python/MATLAB instalado",
                                    "Bibliotecas: NumPy, SciPy, Matplotlib",
                                    "Código template para séries de Fourier"
                                  ],
                                  "tips": "Use meshgrid ou linspace para x; pré-aloque arrays para eficiência.",
                                  "learningObjective": "Traduzir a teoria matemática em código numérico eficiente para truncagem.",
                                  "commonMistakes": [
                                    "Erro de indexação em loops (n=0)",
                                    "Escala errada em x (deve ser [-π,π])",
                                    "Integração numérica imprecisa sem enough pontos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar gráficos comparativos e analisar a aproximação",
                                  "subSteps": [
                                    "Gere plots de f(x) vs SN(x) para vários N sobre [-π,π].",
                                    "Adicione legendas, títulos e rótulos (ex: 'N=5', 'Erro RMS').",
                                    "Calcule métricas de erro: RMSE = sqrt( mean( (f-SN)^2 ) ).",
                                    "Observe Gibbs phenomenon perto de descontinuidades.",
                                    "Exporte figuras e relacione com teoria de convergência."
                                  ],
                                  "verification": "Gráficos mostram convergência visual; RMSE diminui monotonicamente com N.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código da Step 3",
                                    "Software de plotting",
                                    "Ferramenta para calcular RMSE"
                                  ],
                                  "tips": "Use subplots para múltiplos N; logscale para RMSE vs N.",
                                  "learningObjective": "Visualizar e quantificar a qualidade da aproximação truncada.",
                                  "commonMistakes": [
                                    "Escalas de eixo desalinhadas",
                                    "Não normalizar plots",
                                    "Ignorar overshoot de Gibbs"
                                  ]
                                }
                              ],
                              "practicalExample": "Aproxime f(x) = |x| no intervalo [-π, π] (função par). Calcule coeficientes até N=20, implemente SN(x) em Python, plote f(x) vs SN(x) para N=1,5,10,20 e observe convergência uniforme exceto em x=±π.",
                              "finalVerifications": [
                                "SN(x) coincide visualmente com f(x) para N≥10 em 90% dos pontos.",
                                "Coeficientes an/bn decrescem como 1/n ou melhor.",
                                "RMSE < 0.01 para N=20.",
                                "Código roda sem erros e reproduz resultados em múltiplas execuções.",
                                "Gráficos incluem todos os elementos (legendas, títulos, grids).",
                                "Análise escrita explica overshoot de Gibbs se aplicável."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes calculados (erro <1%).",
                                "Correção da fórmula SN(x) e implementação numérica.",
                                "Qualidade dos gráficos: clareza, múltiplos N, métricas de erro.",
                                "Análise da convergência e discussão de limitações.",
                                "Eficiência e legibilidade do código.",
                                "Completude da documentação (comentários, relatório)."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e sinais periódicos (ex: espectro de Fourier em mecânica ondulatória).",
                                "Engenharia: Processamento de sinais digitais e filtros passa-faixa.",
                                "Computação: Algoritmos numéricos e FFT para truncagem eficiente.",
                                "Estatística: Decomposição em componentes ortogonais para modelagem."
                              ],
                              "realWorldApplication": "Em processamento de áudio/imagem (JPEG usa DCT similar), simulações CFD (métodos espectrais truncam séries para estabilidade numérica), compressão de dados e análise de sinais em telecomunicações."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Avaliar convergência e erro de truncamento",
                            "description": "Estimar o erro de truncamento usando resíduo de Fourier ou norma L2, observando o fenômeno de Gibbs em descontinuidades e efeito de N no erro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de truncamento e convergência em séries de Fourier",
                                  "subSteps": [
                                    "Relembrar a representação de uma função periódica f(x) como soma infinita de coeficientes de Fourier: f(x) ≈ ∑_{k=-N}^N ĉ_k e^{i k π x / L}.",
                                    "Entender o erro de truncamento E_N(x) = f(x) - S_N(x), onde S_N é a soma truncada até N.",
                                    "Estudar taxas de convergência: rápida para funções suaves (exponencial), lenta para descontinuidades (algebraica).",
                                    "Discutir o fenômeno de Gibbs: overshoot ~9% perto de descontinuidades, independente de N.",
                                    "Analisar como o erro global diminui com N, mas localmente persiste Gibbs."
                                  ],
                                  "verification": "Resumir em um parágrafo os conceitos chave e esboçar gráfico de Gibbs para uma função degrau.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Trefethen), notebook Jupyter com NumPy/Matplotlib.",
                                  "tips": "Use visualizações gráficas para intuitivamente entender Gibbs antes de fórmulas.",
                                  "learningObjective": "Compreender teoricamente o erro de truncamento e suas patologias como Gibbs.",
                                  "commonMistakes": "Confundir erro de truncamento com erro de aliasing; ignorar periodicidade da função."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e estimar erro usando resíduo de Fourier",
                                  "subSteps": [
                                    "Computar coeficientes ĉ_k via FFT para uma função teste f(x).",
                                    "Definir resíduo de Fourier R_N = ∑_{|k|>N} |ĉ_k|^2 como estimativa do erro em norma L2.",
                                    "Implementar fórmula analítica para funções conhecidas (ex: série de quadrado).",
                                    "Plotar R_N vs log(N) para observar decaimento.",
                                    "Comparar R_N com erro real ||f - S_N||_2."
                                  ],
                                  "verification": "Código roda sem erros e R_N aproxima ||E_N||_2 dentro de 5% para N=16,32,64.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com SciPy (fft), gráficos Matplotlib; função teste como onda quadrada.",
                                  "tips": "Normalizar a função para intervalo [-π,π] para simplificar cálculos.",
                                  "learningObjective": "Aplicar resíduo de Fourier como proxy eficiente para erro L2 sem computar S_N exaustivamente.",
                                  "commonMistakes": "Esquecer soma bilateral (|k|>N); usar norma L1 em vez de L2 para resíduo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar norma L2 do erro e efeito de N",
                                  "subSteps": [
                                    "Discretizar f(x) em grid equiespaçado x_j = j h, h=2π/M, M>>N.",
                                    "Computar S_N(x_j) via ifft dos coeficientes truncados.",
                                    "Calcular ||E_N||_2 ≈ sqrt( h ∑ |f(x_j) - S_N(x_j)|^2 ).",
                                    "Variar N=8,16,32,64,128 e plotar log(||E_N||_2) vs log(N); ajustar taxa de convergência.",
                                    "Testar em funções suaves (ex: gaussiana) vs descontinuas (ex: sign(x))."
                                  ],
                                  "verification": "Gráficos mostram decaimento ~1/N para suave e ~1/sqrt(N) para jump; erro <1e-6 para N=128 em suave.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Notebook Jupyter, SciPy fft/ifft, funções teste pré-definidas.",
                                  "tips": "Use M=2^14 para aliasing mínimo; verifique Parseval: ||f||_2^2 = ∑ |ĉ_k|^2.",
                                  "learningObjective": "Quantificar numericamente como erro L2 escala com N e tipo de regularidade.",
                                  "commonMistakes": "Grid M muito pequeno causando aliasing; não normalizar norma por período."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Observar fenômeno de Gibbs e sintetizar análise de convergência",
                                  "subSteps": [
                                    "Implementar f(x)=sign(sin(x)) ou degrau; plotar f, S_N para N=10,50,200.",
                                    "Medir overshoot máximo: max|S_N - f| perto de discontinuity / jump size.",
                                    "Confirmar Gibbs ~0.09 independente de N via múltiplos N.",
                                    "Relacionar com resíduo: Gibbs local vs erro global L2.",
                                    "Escrever relatório: tabela N, ||E_N||_2, R_N, overshoot %."
                                  ],
                                  "verification": "Relatório identifica Gibbs corretamente e compara métricas com <10% erro relativo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo notebook; exportar tabelas para LaTeX/PDF.",
                                  "tips": "Amplie eixo y perto de discontinuity para visualizar overshoot claramente.",
                                  "learningObjective": "Identificar e quantificar artefatos como Gibbs em aproximações espectrais.",
                                  "commonMistakes": "Atribuir Gibbs a truncamento baixo em vez de propriedade inerente; ignorar normalização."
                                }
                              ],
                              "practicalExample": "Aproxime f(x) = |sin(x)| no [-π,π] com N=32. Calcule R_{32} ≈ 0.012, ||E_{32}||_2 ≈ 0.011, observe Gibbs de 8.9% nos picos; dobre N para N=64 e note halving do erro L2 mas Gibbs persistente.",
                              "finalVerifications": [
                                "Calcula resíduo de Fourier R_N corretamente para função dada.",
                                "Implementa norma L2 do erro com precisão <1%.",
                                "Plota e identifica overshoot de Gibbs >8% em descontinuidade.",
                                "Demonstra decaimento de erro com N via log-log plot.",
                                "Explica qualitativamente por que Gibbs não some com N maior.",
                                "Compara R_N e ||E_N||_2 com erro relativo <5%."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erros <1e-4 em normas para N=64.",
                                "Correta interpretação: distingue convergência global vs local (Gibbs).",
                                "Visualizações claras: plots rotulados com N variando e métricas anotadas.",
                                "Eficiência: usa FFT para todos cálculos, sem loops desnecessários.",
                                "Análise crítica: discute regularidade da função impactando taxa.",
                                "Relatório conciso: tabela + conclusões em <1 página."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e espectros em mecânica quântica (potenciais periódicos).",
                                "Engenharia Elétrica: Processamento de sinais digitais, filtros FFT com truncamento.",
                                "Computação Científica: Otimização de solvers PDE espectrais (ex: Navier-Stokes).",
                                "Estatística: Análise de séries temporais e previsão com truncamento de frequências."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou CFD, avalia truncamento em FFT para espectros de turbulência, garantindo erro L2 <1% com N mínimo para eficiência computacional; mitiga Gibbs em imagens médicas via filtros espectrais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Implementar aproximação via FFT",
                            "description": "Usar a Transformada Discreta de Fourier (DFT) e FFT para calcular coeficientes e reconstruir a função em pontos discretos, com código em Python ou MATLAB.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e preparar dados de entrada",
                                  "subSteps": [
                                    "Instale ou importe bibliotecas necessárias: numpy e matplotlib.",
                                    "Defina o intervalo de amostragem, como [0, 2π] com N=256 pontos equidistantes usando np.linspace.",
                                    "Defina uma função teste, por exemplo, f(x) = sin(x) + 0.5 * sin(3x), e compute os valores nos pontos.",
                                    "Plote a função original para visualização inicial.",
                                    "Verifique se os pontos são uniformemente espaçados e N é potência de 2 para eficiência da FFT."
                                  ],
                                  "verification": "Bibliotecas importadas corretamente, plot da função original exibido sem erros e pontos confirmados como equidistantes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Matplotlib",
                                    "Jupyter Notebook (opcional)"
                                  ],
                                  "tips": "Use N como potência de 2 (ex: 256, 512) para otimizar a FFT; prefira Jupyter para experimentação interativa.",
                                  "learningObjective": "Preparar dados discretos adequados para análise espectral via FFT.",
                                  "commonMistakes": [
                                    "Usar intervalos não periódicos levando a vazamento espectral.",
                                    "Pontos não equidistantes distorcendo a DFT.",
                                    "Escolher N muito pequeno para resolução insuficiente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular coeficientes de Fourier via FFT",
                                  "subSteps": [
                                    "Aplique np.fft.fft nos valores da função para obter os coeficientes complexos â_k.",
                                    "Interprete os coeficientes: â_0 é a média, â_k e â_{N-k} são conjugados para funções reais.",
                                    "Plote o espectro de magnitude |â_k| para os primeiros N/2 coeficientes.",
                                    "Normalize os coeficientes se necessário (divida por N para DFT padrão).",
                                    "Confirme simetria hermitiana para funções reais."
                                  ],
                                  "verification": "Espectro plotado mostra picos nos modos esperados da função teste (ex: k=1 e k=3).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NumPy (np.fft)"
                                  ],
                                  "tips": "Use np.fft.fftshift para centralizar o espectro zero-frequência; plot em escala log para melhor visualização.",
                                  "learningObjective": "Computar eficientemente coeficientes de Fourier usando algoritmo FFT.",
                                  "commonMistakes": [
                                    "Confundir FFT com DFT direta (lenta para N grande).",
                                    "Não normalizar corretamente levando a escalas erradas.",
                                    "Ignorar simetria complexa de â_k."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Truncar coeficientes para aproximação",
                                  "subSteps": [
                                    "Escolha número de modos M (ex: M=20, com M << N/2).",
                                    "Crie array de coeficientes truncados zerando â_k para |k| > M.",
                                    "Mantenha simetria: zero ambos â_k e â_{N-k} se um for zerado.",
                                    "Plote espectro truncado vs original para visualizar corte.",
                                    "Teste diferentes M para observar trade-off resolução vs suavidade."
                                  ],
                                  "verification": "Espectro truncado tem exatamente 2M+1 coeficientes não-nulos e mantém simetria.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "NumPy arrays"
                                  ],
                                  "tips": "Comece com M pequeno para ver Gibbs phenomenon em funções com descontinuidades.",
                                  "learningObjective": "Implementar truncamento espectral para aproximação de baixa ordem.",
                                  "commonMistakes": [
                                    "Quebrar simetria hermitiana gerando parte imaginária na reconstrução.",
                                    "Escolher M muito grande anulando benefícios da aproximação.",
                                    "Não plotar para validar truncamento."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconstruir a função aproximada via IFFT",
                                  "subSteps": [
                                    "Aplique np.fft.ifft nos coeficientes truncados para obter a aproximação em pontos discretos.",
                                    "Tome parte real da reconstrução (descartar imaginário numérico).",
                                    "Plote original vs aproximada no mesmo gráfico.",
                                    "Calcule erro pontual ou norma L2: np.linalg.norm(original - approx).",
                                    "Experimente reconstrução via soma direta para validação (opcional, lenta)."
                                  ],
                                  "verification": "Parte imaginária da IFFT < 1e-10; erro L2 diminui com M crescente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "NumPy (np.fft.ifft)"
                                  ],
                                  "tips": "Use np.real() explicitamente; para periodicidade, evite padding assimétrico.",
                                  "learningObjective": "Reconstruir sinal aproximado a partir de modos truncados usando IFFT.",
                                  "commonMistakes": [
                                    "Não descartar parte imaginária devido a erros numéricos.",
                                    "Usar FFT ao invés de IFFT na reconstrução.",
                                    "Calcular erro em pontos errados."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e validar a aproximação",
                                  "subSteps": [
                                    "Compare plots para diferentes M, observando convergência e oscilações de Gibbs.",
                                    "Compute métricas: erro relativo max, RMS, taxa de convergência.",
                                    "Teste com outra função (ex: sawtooth) para generalizar.",
                                    "Otimize N e M para equilíbrio precisão/tempo.",
                                    "Documente código em função reutilizável."
                                  ],
                                  "verification": "Erros quantificados < threshold (ex: 1e-3 para M=20); plots mostram boa aproximação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matplotlib para plots avançados"
                                  ],
                                  "tips": "Salve figuras com plt.savefig(); use legendas claras para comparações.",
                                  "learningObjective": "Avaliar qualidade da aproximação numérica e identificar artefatos.",
                                  "commonMistakes": [
                                    "Ignorar phenomenon de Gibbs perto de descontinuidades.",
                                    "Métricas de erro inconsistentes.",
                                    "Não testar generalização."
                                  ]
                                }
                              ],
                              "practicalExample": "Aproximar f(x) = |sin(x)| em [0, 2π] com N=512 pontos. Compute FFT, trunque a M=32 modos, reconstrua via IFFT e plote: observe overshoot de Gibbs ~9% perto de x=0,π. Código Python: import numpy as np; import matplotlib.pyplot as plt; x = np.linspace(0, 2*np.pi, 512, endpoint=False); f = np.abs(np.sin(x)); coeffs = np.fft.fft(f); M=32; coeffs[M:-M]=0; approx = np.real(np.fft.ifft(coeffs)); plt.plot(x, f, x, approx);",
                              "finalVerifications": [
                                "Código executa sem erros numéricos significativos (imaginário <1e-12).",
                                "Plots mostram convergência espectral com aumento de M.",
                                "Erro L2 < 0.05 para M=20 em função suave.",
                                "Simetria hermitiana preservada nos coeficientes truncados.",
                                "Tempo de execução da FFT <1s para N=1024.",
                                "Função reutilizável aceita parâmetros N, M e f como input."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de FFT/IFFT com normalização apropriada (peso 25%).",
                                "Truncamento simétrico e análise de espectro visual (peso 20%).",
                                "Cálculo preciso de erros quantitativos e qualitativos (peso 20%).",
                                "Visualizações claras com labels, legends e múltiplos M (peso 15%).",
                                "Código limpo, comentado e modular (peso 10%).",
                                "Generalização testada em pelo menos duas funções (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais em Engenharia Elétrica (filtros digitais).",
                                "Física Computacional (simulações de ondas e PDEs pseudoespectrais).",
                                "Ciência de Dados (análise espectral de séries temporais).",
                                "Engenharia de Computação (otimização de algoritmos FFT como Cooley-Tukey)."
                              ],
                              "realWorldApplication": "Em processamento de imagens (compressão JPEG via DCT similar a FFT), análise de áudio (identificação de frequências em música), simulações numéricas de equações diferenciais em mecânica dos fluidos (métodos espectrais), e detecção de falhas em vibrações industriais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Diferenciação no Espaço Espectral",
                    "description": "Cálculo eficiente de derivadas multiplicando coeficientes de Fourier por fatores ik.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Representação no Espaço Espectral via FFT",
                        "description": "Representação de funções periódicas discretizadas em coeficientes de Fourier utilizando a Transformada Discreta de Fourier (DFT) e sua implementação eficiente via Fast Fourier Transform (FFT).",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Definir e calcular a DFT de uma sequência discreta",
                            "description": "Explicar a fórmula da DFT para uma grade uniforme de N pontos, ∑_{j=0}^{N-1} u_j exp(-2π i k j / N), e computar os coeficientes de Fourier para uma função teste periódica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e fórmula da DFT",
                                  "subSteps": [
                                    "Leia a fórmula da DFT: X_k = ∑_{j=0}^{N-1} u_j exp(-2π i k j / N), para k=0 a N-1.",
                                    "Identifique os componentes: sequência discreta u_j, índices j e k, fator exponencial complexo.",
                                    "Entenda o significado: projeção da sequência no espaço de frequências discretas.",
                                    "Revise noções básicas de números complexos e exponenciais imaginários.",
                                    "Escreva a fórmula à mão para fixar."
                                  ],
                                  "verification": "Escreva a fórmula completa da DFT sem consultar notas e explique verbalmente seu significado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Referência de análise de Fourier (livro ou PDF)"
                                  ],
                                  "tips": [
                                    "Visualize a exponencial como rotações no plano complexo.",
                                    "Use notação Euler: exp(iθ) = cosθ + i sinθ."
                                  ],
                                  "learningObjective": "Dominar a fórmula matemática da DFT e seu interpretação espectral.",
                                  "commonMistakes": [
                                    "Confundir o sinal do expoente (- vs +)",
                                    "Esquecer os limites de soma (0 a N-1)",
                                    "Ignorar a dependência em N"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar uma sequência discreta de teste periódica",
                                  "subSteps": [
                                    "Escolha uma função teste simples, como u_j = cos(2π m j / N) para m=1, N=8.",
                                    "Gere a sequência u_0 a u_{N-1} amostrando a função em grade uniforme.",
                                    "Represente os valores em forma real e complexa se necessário.",
                                    "Verifique periodicidade: u_{j+N} = u_j.",
                                    "Plote a sequência para visualização intuitiva."
                                  ],
                                  "verification": "Liste os valores exatos de u_j para N=8 e confirme periodicidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de plotagem (Python/Matlab ou Excel)",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Comece com N pequeno (4 ou 8) para cálculos manuais fáceis.",
                                    "Use seno/cosseno para testar picos espectrais conhecidos."
                                  ],
                                  "learningObjective": "Criar sequências discretas representativas para testes de DFT.",
                                  "commonMistakes": [
                                    "Amostragem não uniforme",
                                    "Não garantir periodicidade artificial",
                                    "Escala errada nos argumentos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a DFT manualmente para N pequeno",
                                  "subSteps": [
                                    "Para cada k=0 a N-1, compute a soma ∑ u_j * exp(-2π i k j / N).",
                                    "Calcule cada termo complexo: magnitude e fase.",
                                    "Some os termos complexos, separando partes real e imaginária.",
                                    "Registre os coeficientes X_k em tabela.",
                                    "Verifique simetria para sequências reais: X_{N-k} = conj(X_k)."
                                  ],
                                  "verification": "Obtenha X_k exatos ou numéricos para sua sequência e confira com fórmula conhecida para cosseno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de valores trigonométricos",
                                    "Calculadora com funções complexas"
                                  ],
                                  "tips": [
                                    "Compute exp(-2π i k j / N) usando ângulos em graus/radianos padronizados.",
                                    "Agrupe termos simétricos para simplificar."
                                  ],
                                  "learningObjective": "Executar cálculo explícito da DFT, lidando com aritmética complexa.",
                                  "commonMistakes": [
                                    "Erro em cálculos trigonométricos",
                                    "Soma incorreta de complexos",
                                    "Índices off-by-one em k ou j"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e verificar os coeficientes de Fourier",
                                  "subSteps": [
                                    "Identifique picos em |X_k|: correspondem a frequências dominantes.",
                                    "Compare com a função original: para cosseno puro, dois deltas esperados.",
                                    "Compute a IDFT inversa para reconstruir u_j e cheque erro.",
                                    "Analise propriedades: Parseval (energia preservada), linearidade.",
                                    "Documente observações em relatório curto."
                                  ],
                                  "verification": "Reconstrua u_j via IDFT com erro < 1e-10 e interprete os picos espectrais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmos da etapa 3",
                                    "Folha para tabela de resultados"
                                  ],
                                  "tips": [
                                    "Use normalização 1/N na IDFT se aplicável.",
                                    "Plote |X_k| vs k para insight visual."
                                  ],
                                  "learningObjective": "Interpretar resultados da DFT e validar via propriedades.",
                                  "commonMistakes": [
                                    "Ignorar conjugação na simetria",
                                    "Erro de escala na inversa",
                                    "Má interpretação de vazamento espectral"
                                  ]
                                }
                              ],
                              "practicalExample": "Para N=4, u = [1, 0, -1, 0] (discretização de cos(π j / 2)), compute DFT: X_0=0, X_1=-2i, X_2=0, X_3=2i. Verifique picos em k=1,3 correspondendo à frequência.",
                              "finalVerifications": [
                                "Deriva corretamente a fórmula da DFT de memória.",
                                "Calcula DFT manual para N=4/8 com precisão numérica.",
                                "Reconstrói sequência original via IDFT sem erro significativo.",
                                "Identifica corretamente frequências dominantes nos coeficientes.",
                                "Explica simetria para sinais reais.",
                                "Aplica Parseval para verificar conservação de energia."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro < 1e-6).",
                                "Compreensão conceitual da transformação frequência-tempo.",
                                "Correta manipulação de números complexos.",
                                "Eficiência e organização nos passos computacionais.",
                                "Interpretação física/significado dos coeficientes.",
                                "Identificação de erros e autocorreção."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais em Engenharia Elétrica (filtros digitais).",
                                "Análise de Séries de Fourier em Física (ondas e vibrações).",
                                "Algoritmos e Implementação FFT em Ciência da Computação.",
                                "Métodos Numéricos Pseudoespectrais em Matemática Aplicada.",
                                "Análise de Dados em Estatística (espectros de potência)."
                              ],
                              "realWorldApplication": "A DFT é base para a FFT usada em compressão de áudio (MP3), processamento de imagens (MRI, JPEG), análise sísmica, simulações climáticas e telecomunicações (modulação OFDM em 5G)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Implementar a FFT para discretizações espaciais",
                            "description": "Utilizar algoritmos FFT (como Cooley-Tukey) para calcular eficientemente coeficientes espectrais em O(N log N), aplicando em uma malha periódica com exemplos numéricos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos da DFT e FFT",
                                  "subSteps": [
                                    "Revise a fórmula da Transformada Discreta de Fourier (DFT): X_k = sum_{n=0}^{N-1} x_n * exp(-2πi k n / N).",
                                    "Entenda a complexidade O(N^2) da DFT naive e a motivação para FFT O(N log N).",
                                    "Estude o princípio divide-and-conquer do algoritmo Cooley-Tukey para N potência de 2.",
                                    "Discuta a periodicidade em malhas espaciais discretas uniformes.",
                                    "Visualize exemplos gráficos de funções periódicas discretizadas."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando DFT vs FFT e desenhe o diagrama de divide-and-conquer para N=8.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notebook Jupyter ou Python IDE",
                                    "Referências: Wikipedia FFT, livro de análise numérica (ex: Trefethen)"
                                  ],
                                  "tips": [
                                    "Use plots com matplotlib para visualizar espectros.",
                                    "Comece com N pequeno (4 ou 8) para depuração manual."
                                  ],
                                  "learningObjective": "Dominar os fundamentos teóricos da FFT e sua aplicação em discretizações espaciais periódicas.",
                                  "commonMistakes": [
                                    "Confundir índices k e n na soma DFT.",
                                    "Ignorar a exigência de N=2^m.",
                                    "Não considerar a normalização dos coeficientes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a DFT Naive como Baseline",
                                  "subSteps": [
                                    "Escreva uma função Python para DFT direta usando loops duplos.",
                                    "Teste com um sinal simples: x_n = exp(2πi m n / N) para m conhecido, verificando X_m = N e outros zero.",
                                    "Meça o tempo de execução para N=1024.",
                                    "Discretize uma função espacial periódica, como sin(2π x_j / L) em malha j=0..N-1.",
                                    "Plote o espectro |X_k|."
                                  ],
                                  "verification": "O espectro do sinal exponencial exponencial deve ter pico exato em k=m com amplitude N.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Timer: timeit module"
                                  ],
                                  "tips": [
                                    "Use complex128 para precisão.",
                                    "Evite loops em NumPy; implemente puro para medir O(N^2)."
                                  ],
                                  "learningObjective": "Implementar e validar DFT naive, destacando ineficiência para grandes N.",
                                  "commonMistakes": [
                                    "Erro de índice off-by-one em somas.",
                                    "Não usar números complexos corretamente.",
                                    "Ignorar conjugado na transformada inversa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Algoritmo FFT Cooley-Tukey Recursivo",
                                  "subSteps": [
                                    "Defina função recursiva fft(x): se len(x)==1 return x; divida em pares even/odd.",
                                    "Aplique fft recursivo em even e odd: X_even = fft(x_even), X_odd = fft(x_odd).",
                                    "Combine: para k=0..N/2-1, X_k = X_even_k + w^k * X_odd_k; X_{k+N/2} = X_even_k - w^k * X_odd_k, onde w=exp(-2πi/N).",
                                    "Implemente bit-reversal para ordenação de entrada (opcional, mas recomendado).",
                                    "Teste com N=8 e sinal conhecido."
                                  ],
                                  "verification": "Comparar resultado com DFT naive; erro relativo <1e-12 para N=64.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python puro (sem numpy.fft)",
                                    "Exemplos manuais para N=4"
                                  ],
                                  "tips": [
                                    "Implemente recursão com memoização se necessário.",
                                    "Debugue recursão imprimindo sub-arrays."
                                  ],
                                  "learningObjective": "Codificar a FFT recursiva, demonstrando divide-and-conquer.",
                                  "commonMistakes": [
                                    "Fator twiddle errado (exp(-2πi / N) vs /2N).",
                                    "Não lidar com N não-potência de 2.",
                                    "Stack overflow em recursão profunda."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar FFT em Discretizações Espaciais Periódicas",
                                  "subSteps": [
                                    "Gere malha periódica: x_j = j * dx, dx = L/N, j=0..N-1.",
                                    "Defina função teste: u(x) = sin(2π k x / L) + cos(2π m x / L).",
                                    "Compute coeficientes espectrais û_k = FFT(u).",
                                    "Implemente diferenciação espectral: dû_k = i k (2π/L) û_k para derivada.",
                                    "Inverta FFT para verificar: erro L2 <1e-10.",
                                    "Plote domínio espacial, espectro e derivada reconstruída."
                                  ],
                                  "verification": "Derivada reconstruída matches derivada analítica: cos(2π k x / L)* (2π k /L) etc.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código FFT anterior",
                                    "Funções teste pré-definidas"
                                  ],
                                  "tips": [
                                    "Use padding zero para N não-potência de 2.",
                                    "Normalize FFT por 1/N na inversa."
                                  ],
                                  "learningObjective": "Aplicar FFT para representar e manipular funções em espaço espectral.",
                                  "commonMistakes": [
                                    "Não wrap-around na periodicidade.",
                                    "Aliasing em modos altos k>N/2.",
                                    "Escala errada em wavenumbers k."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Eficiência e Verificar Implementação",
                                  "subSteps": [
                                    "Meça tempo FFT vs DFT para N=2^10 a 2^16.",
                                    "Plote log(tempo) vs log(N) para confirmar slope ~log N.",
                                    "Teste com ruído: adicione small perturbation e cheque estabilidade.",
                                    "Implemente IFFT para ciclo completo.",
                                    "Documente código com comentários e README.",
                                    "Compare com numpy.fft.fft para validação."
                                  ],
                                  "verification": "FFT 100x mais rápida que DFT para N=4096; match com numpy <1e-12.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "timeit, numpy para benchmark"
                                  ],
                                  "tips": [
                                    "Rode múltiplas vezes e average tempos.",
                                    "Use %timeit em Jupyter."
                                  ],
                                  "learningObjective": "Avaliar performance O(N log N) e robustez da implementação.",
                                  "commonMistakes": [
                                    "Benchmark enviesado por cache.",
                                    "Não limpar variáveis entre testes.",
                                    "Confundir forward/inverse FFT."
                                  ]
                                }
                              ],
                              "practicalExample": "Discretize u_j = sin(2π j /8) + 0.5 cos(4π j /8) em N=8 pontos periódicos. Compute FFT: deve ter picos em k=1 (amp~4), k=2 (amp~2), k=6=-2 mod8 (amp~2), k=7=-1 mod8 (amp~4). Derive espectralmente e IFFT para obter derivada cos(2π j/8)*2π/8 + ...",
                              "finalVerifications": [
                                "Código FFT produz espectros idênticos à DFT naive (erro <1e-12).",
                                "Tempo de execução escala como O(N log N) em benchmarks N=2^8 a 2^16.",
                                "Aplicação em malha periódica reconstrói derivada com erro L2 <1e-10.",
                                "IFFT(FFT(u)) = u original (up to numerical precision).",
                                "Coeficientes espectrais corretos para funções trigonométricas conhecidas.",
                                "Código roda sem erros para N até 2^20."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro relativo <1e-12 em testes padrão.",
                                "Eficiência: speedup >50x vs DFT para N=1024.",
                                "Robustez: funciona para N=2^m, m>=1; lida com complexos.",
                                "Clareza do código: comentários, funções modulares, docstrings.",
                                "Validação completa: testes unitários para 3+ exemplos.",
                                "Visualizações: plots de espectros e reconstruções."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Algoritmos recursivos e otimização.",
                                "Física Computacional: Simulações de PDEs pseudoespectrais (ex: Navier-Stokes).",
                                "Processamento de Sinais: Análise de Fourier em áudio/imagens.",
                                "Ciência de Dados: Feature extraction via espectros.",
                                "Engenharia: Compressão de dados e filtros digitais."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (CFD), FFT acelera solvers espectrais para equações de Navier-Stokes em domínios periódicos; em processamento de imagens médicas (MRI), reconstrói sinais espectrais; em telecomunicações, demodula sinais OFDM eficientemente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Interpretar propriedades dos coeficientes de Fourier",
                            "description": "Analisar simetria (realidade da função implica coeficientes conjugados), aliasing espectral e truncamento de modos altos para funções suaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a propriedade de simetria para funções reais",
                                  "subSteps": [
                                    "Revise a definição da Transformada Discreta de Fourier (DFT) para uma sequência discreta.",
                                    "Demonstre que para funções reais, os coeficientes c_k satisfazem c_k = conj(c_{-k}).",
                                    "Plote os coeficientes reais e imaginários para uma função real simples, como cos(2πx).",
                                    "Verifique numericamente usando FFT em Python ou MATLAB.",
                                    "Explique por que isso reduz o armazenamento pela metade."
                                  ],
                                  "verification": "Coeficientes plotados mostram simetria conjugada; valores c_k e c_{-k} são conjugados dentro de tolerância numérica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/SciPy, Jupyter Notebook, função de teste como np.cos(2*np.pi*np.linspace(0,1,128)).",
                                  "tips": "Sempre normalize a FFT para evitar fatores de escala que mascarem a simetria.",
                                  "learningObjective": "Identificar e validar a simetria conjugada dos coeficientes de Fourier para funções reais.",
                                  "commonMistakes": "Ignorar a indexação circular na DFT (c_0 real, pares simétricos); confundir com simetria par/impar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o aliasing espectral na representação Fourier",
                                  "subSteps": [
                                    "Explique aliasing como sobreposição de modos devido à amostragem insuficiente (teorema de Nyquist).",
                                    "Compute FFT de uma função subamostrada e observe picos espúrios em frequências altas.",
                                    "Compare espectros com e sem aliasing variando o número de pontos N.",
                                    "Use filtro passa-baixa para mitigar aliasing e compare resultados.",
                                    "Quantifique o erro de aliasing medindo normas L2 dos coeficientes afetados."
                                  ],
                                  "verification": "Espetro mostra picos aliasados em N baixo; erro diminui com N maior ou filtro.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python/NumPy para FFT, sinal de teste como sen(10πx) com amostragem variada.",
                                  "tips": "Escolha frequências de teste próximas ao Nyquist para visualizar aliasing claramente.",
                                  "learningObjective": "Diagnosticar e quantificar aliasing espectral em decomposições Fourier discretas.",
                                  "commonMistakes": "Confundir aliasing com vazamento espectral; não considerar periodicidade imposta pela DFT."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar o truncamento de modos altos para funções suaves",
                                  "subSteps": [
                                    "Defina truncamento como zerar coeficientes |k| > K em uma expansão Fourier.",
                                    "Aplique truncamento a uma função suave (ex: gaussiana) e compute erro de reconstrução.",
                                    "Plote decaimento exponencial dos coeficientes para funções suaves (teorema de Bernstein).",
                                    "Compare com funções não-suaves (ex: degrau) mostrando decaimento lento.",
                                    "Otimize K minimizando erro vs custo computacional."
                                  ],
                                  "verification": "Coeficientes decaem rapidamente para funções suaves; erro de truncamento < 1e-6 para K adequado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python/MATLAB, funções teste: exp(-50*(x-0.5)^2) suave vs abs(x-0.5) não-suave.",
                                  "tips": "Use ifft para reconstruir e plote resíduos para visualizar truncamento.",
                                  "learningObjective": "Avaliar impacto do truncamento de modos altos na precisão para funções suaves.",
                                  "commonMistakes": "Truncar simetricamente sem respeitar simetria conjugada; superestimar suavidade da função."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar propriedades em análise completa de coeficientes",
                                  "subSteps": [
                                    "Combine simetria, aliasing e truncamento em uma rotina de análise de espectro.",
                                    "Aplique a uma função real complexa (ex: onda com ruído) e interprete o espectro.",
                                    "Gere relatório: simetria verificada, aliasing detectado, K ótimo sugerido.",
                                    "Teste sensibilidade variando parâmetros (N, suavidade).",
                                    "Discuta trade-offs em aplicações numéricas."
                                  ],
                                  "verification": "Análise integrada produz interpretação coerente com propriedades teóricas.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Código Python completo integrando FFT, plots e métricas de erro.",
                                  "tips": "Automatize plots com subplots para simetria, aliasing e truncamento lado a lado.",
                                  "learningObjective": "Sintetizar propriedades para interpretar coeficientes de Fourier em contextos reais.",
                                  "commonMistakes": "Não validar simetria antes de truncar; ignorar aliasing em funções ruidosas."
                                }
                              ],
                              "practicalExample": "Considere f(x) = cos(2πx) + 0.5*cos(6πx) amostrada em 64 pontos. Compute FFT: verifique c_1 = conj(c_{-1}), detecte aliasing se N<12, trunque |k|>4 para função suave e reconstrua com erro <1e-8.",
                              "finalVerifications": [
                                "Simetria conjugada confirmada para todos pares c_k / c_{-k}.",
                                "Ausência de aliasing significativo (picos espúrios <1% da energia total).",
                                "Decaimento exponencial dos |c_k| para funções suaves.",
                                "Erro de truncamento L2 < 1e-6 com K= N/4.",
                                "Reconstrução via iFFT idêntica à original dentro de precisão máquina.",
                                "Relatório de análise coerente e quantificado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de simetria conjugada (90%+ acerto em testes).",
                                "Detecção correta de aliasing e sugestão de N mínimo.",
                                "Escolha ótima de K de truncamento minimizando erro/custo.",
                                "Interpretação qualitativa e quantitativa das propriedades.",
                                "Uso correto de ferramentas numéricas sem erros de indexação.",
                                "Clareza em plots e explicações de resultados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e espectroscopia em mecânica quântica.",
                                "Engenharia de Sinais: Filtros digitais e compressão de áudio/vídeo.",
                                "Computação Científica: Otimização em métodos espectrais para PDEs.",
                                "Processamento de Imagens: FFT em filtros espaciais 2D."
                              ],
                              "realWorldApplication": "Em simulações climáticas ou previsão de ondas, interpretar coeficientes Fourier permite truncar modos altos para aceleração computacional sem perda de precisão, detectando aliasing para grids adequados e explorando simetria para eficiência em dados reais de sensores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Operador de Diferenciação Espectral",
                        "description": "Cálculo da derivada de uma função no domínio espectral multiplicando os coeficientes de Fourier ˆu_k por i k, explorando a eficiência e precisão exponencial para funções analíticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Derivar a fórmula de diferenciação espectral",
                            "description": "Demonstrar que a derivada du/dx tem coeficientes ˆu'_k = i k ˆu_k (para k de -N/2 a N/2, com aliasing de Nyquist), partindo da propriedade da transformada de Fourier contínua.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar a propriedade de diferenciação da Transformada de Fourier Contínua",
                                  "subSteps": [
                                    "Defina a transformada de Fourier contínua: ˆu(ξ) = ∫ u(x) e^{-2π i ξ x} dx.",
                                    "Estabeleça a propriedade: a transformada da derivada du/dx é 2π i ξ ˆu(ξ).",
                                    "Note a convenção comum em métodos espectrais: usar ˆu_k = ∑ u_j e^{-i k x_j} e ajustar o fator para i k ˆu_k.",
                                    "Verifique com uma função teste simples, como u(x) = sin(2π x), cuja derivada é 2π cos(2π x)."
                                  ],
                                  "verification": "Escreva a fórmula exata da propriedade e compute manualmente para u(x) = e^{i κ x}, confirmando ˆu'(κ) = i κ ˆu(κ).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para integrais Fourier básicas"
                                  ],
                                  "tips": "Use a convenção onde o sinal é e^{-i k x} para consistência com DFT padrão; memorize o fator i k em vez de 2π i k ajustando normalização.",
                                  "learningObjective": "Entender como a diferenciação se torna multiplicação por i k no domínio de frequência contínuo.",
                                  "commonMistakes": [
                                    "Confundir o sinal do expoente (e^{i} vs e^{-i})",
                                    "Esquecer o fator 2π na frequência angular",
                                    "Ignorar periodicidade implícita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Discretização e a Transformada Discreta de Fourier (DFT)",
                                  "subSteps": [
                                    "Considere N pontos equidistantes x_j = 2π j / N, j=0 a N-1, em [0, 2π).",
                                    "Defina a DFT: ˆu_k = ∑_{j=0}^{N-1} u(x_j) e^{-i k x_j}, para k=0 a N-1.",
                                    "Reorganize wavenumbers k em -N/2 < k ≤ N/2 para simetria, com aliasing em k=±N/2.",
                                    "Inverta via IDFT: u_j = (1/N) ∑ ˆu_k e^{i k x_j}."
                                  ],
                                  "verification": "Compute DFT manualmente para N=4 e u_j = [1,0,-1,0], confirmando ˆu_k simétricos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software Python/MATLAB com numpy.fft para verificação opcional"
                                  ],
                                  "tips": "Sempre normalize o domínio para [0, 2π) para Δx = 2π/N e Δk=1.",
                                  "learningObjective": "Mapear a discretização espacial para representação espectral via DFT.",
                                  "commonMistakes": [
                                    "Usar k=0 a N-1 sem shift para negativo",
                                    "Esquecer fator 1/N na inversa",
                                    "Confundir índice j e k"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Fórmula de Diferenciação Espectral Partindo da Contínua",
                                  "subSteps": [
                                    "Aproxime a derivada contínua: du/dx (x_j) ≈ ∑_k i k ˆu_k e^{i k x_j} / normalização.",
                                    "Some por partes na soma discreta: derive formalmente ∑ u_j' e^{i m x_j} = ∑_k i k ˆu_k δ_{k m}.",
                                    "Mostre que os coeficientes da derivada ˆu'_m = i m ˆu_m para m ≠ ±N/2.",
                                    "Confirme via Parseval ou diretamente da definição DFT da derivada aproximada."
                                  ],
                                  "verification": "Derive algebricamente ˆu'_k = i k ˆu_k assumindo interpolação trigonométrica exata para modais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de derivações",
                                    "Referência: livro de análise numérica como Canuto et al."
                                  ],
                                  "tips": "Pense na base de Fourier como eigenfunções do operador d/dx: d/dx e^{i k x} = i k e^{i k x}.",
                                  "learningObjective": "Provar que diferenciação é multiplicação pontual por i k no espaço espectral.",
                                  "commonMistakes": [
                                    "Ignorar que k é inteiro discreto",
                                    "Usar 2π k em vez de k (depende de normalização)",
                                    "Confundir derivada forward/backward com espectral"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Tratar Aliasing de Nyquist e Range de k",
                                  "subSteps": [
                                    "Identifique k = -N/2 e N/2 como Nyquist: aliasing faz ˆu_{N/2} = ˆu_{-N/2}.",
                                    "Defina convenção: para k=N/2, use ˆu'_ {N/2} = i (N/2) ˆu_{N/2} ou média com -N/2.",
                                    "Ajuste implementação: fftshift no MATLAB/Python para k de -N/2 a N/2-1.",
                                    "Teste numericamente: diferencie u(x)=sin(N x /2) e verifique aliasing."
                                  ],
                                  "verification": "Escreva a fórmula completa: ˆu'_k = i k ˆu_k para |k| < N/2, e especifique para Nyquist.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código Python simples com numpy.fft.ifft(1j * k * fft(u))"
                                  ],
                                  "tips": "Em códigos, k = fftfreq(N, d=2π/N) para wavenumbers corretos.",
                                  "learningObjective": "Compreender limitações devido a aliasing e como lidar em prática.",
                                  "commonMistakes": [
                                    "Tratar k=N/2 independentemente sem aliasing",
                                    "Usar k até N-1 sem fold",
                                    "Erro de sinal em i k para k negativo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para u(x) = sin(x) em N=8 pontos em [0,2π), compute DFT ˆu_k (picos em k=±1), então ˆu'_k = i k ˆu_k, IDFT dá cos(x), verificando derivada exata.",
                              "finalVerifications": [
                                "Escreve corretamente ˆu'_k = i k ˆu_k para k ∈ [-N/2 +1, N/2 -1].",
                                "Explica aliasing em Nyquist com exemplo N=4.",
                                "Deriva passo-a-passo da propriedade contínua para discreta.",
                                "Implementa numéricamente em Python e compara com derivada finita.",
                                "Identifica quando a fórmula falha (alta frequência).",
                                "Confirma com Parseval: energia preservada na derivada."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (fórmula exata com i k).",
                                "Correto tratamento de range k e Nyquist.",
                                "Clareza na ligação contínuo-discreto.",
                                "Exemplo prático computado corretamente.",
                                "Identificação de erros comuns e limitações.",
                                "Capacidade de codificar e verificar numericamente."
                              ],
                              "crossCurricularConnections": [
                                "Física: Solução espectral de EDOs/PDEs como equação de onda.",
                                "Computação: Implementação eficiente via FFT para simulações.",
                                "Engenharia: Análise de sinais em controle e processamento digital.",
                                "Estatística: Espectral em séries temporais e previsão."
                              ],
                              "realWorldApplication": "Em simulações numéricas de turbulência (NS equations), diferenciação espectral permite resolver hiperbolicidade sem dissipação numérica, usada em DNS (Direct Numerical Simulation) para fluidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Aplicar multiplicação por fatores ik aos coeficientes",
                            "description": "Multiplicar sequencialmente ˆu_k por i k para primeira derivada e (i k)^m para ordens superiores, tratando modos negativos e zero cuidadosamente em implementações numéricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar representação espectral e operador de diferenciação básica",
                                  "subSteps": [
                                    "Estude a transformação de Fourier discreta (DFT/FFT) para obter coeficientes espectrais ˆu_k de uma função u(x).",
                                    "Entenda que a derivada no espaço espectral é dada por multiplicação por i k, onde k é o número de onda.",
                                    "Revise a convenção de aliasing e dealiasing em pseudoespectrais.",
                                    "Identifique o domínio de k: de -N/2 a N/2 -1 para N pontos.",
                                    "Anote as propriedades de ˆu_k para funções pares/ímpares."
                                  ],
                                  "verification": "Escreva a fórmula exata para o operador de derivada de primeira ordem e dê um exemplo com N=8.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notebook com equações",
                                    "Software MATLAB ou Python com NumPy/FFT",
                                    "Referência: Canuto et al., Spectral Methods"
                                  ],
                                  "tips": "Use convenções consistentes para o sinal de k (positivo/negativo).",
                                  "learningObjective": "Compreender a base teórica da diferenciação espectral.",
                                  "commonMistakes": "Confundir k com índices de array (off-by-one); ignorar normalização da FFT."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar multiplicação por i k para derivada de primeira ordem",
                                  "subSteps": [
                                    "Compute ˆu_k via FFT de u(x) amostrada.",
                                    "Crie vetor de wavenumbers k = [-N/2 : N/2-1].",
                                    "Multiplique ˆu_k por (i * k) elemento a elemento.",
                                    "Aplique IFFT para obter a derivada no espaço físico e compare com derivada finita.",
                                    "Teste com uma função conhecida como u(x) = sin(π x)."
                                  ],
                                  "verification": "Erro L2 entre derivada espectral e analítica < 1e-10.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python/MATLAB pronto para FFT",
                                    "Gráficos para plotar u e du/dx"
                                  ],
                                  "tips": "Zero os modos altos (2/3 rule) para evitar aliasing.",
                                  "learningObjective": "Implementar corretamente a derivada de 1ª ordem.",
                                  "commonMistakes": "Esquecer o 'i' imaginário; não tratar k=0 como zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Generalizar para derivadas de ordem superior m",
                                  "subSteps": [
                                    "Derive a fórmula: fator = (i k)^m para ordem m.",
                                    "Implemente loop ou potência para m > 1.",
                                    "Teste para m=2 (segunda derivada) com u(x) = x^2.",
                                    "Verifique comutatividade aplicando duas vezes 1ª ordem vs. 2ª ordem direta.",
                                    "Ajuste para precisão numérica em ordens altas (decaying modes)."
                                  ],
                                  "verification": "Resultados idênticos para derivadas compostas e diretas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código do passo anterior",
                                    "Funções teste polinomiais"
                                  ],
                                  "tips": "Use complex128 para evitar perda de precisão em potências.",
                                  "learningObjective": "Estender o operador para ordens arbitrárias.",
                                  "commonMistakes": "Erro de sinal em (i k)^m para m par/ímpar; overflow em k altos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Tratar casos especiais (k=0 e k negativos) e validar numericamente",
                                  "subSteps": [
                                    "Force fator=0 para k=0 em todas as ordens.",
                                    "Verifique simetria: para k negativos, i k mantém propriedades (imaginário para derivadas ímpares).",
                                    "Implemente filtro para modos zero e Nyquist.",
                                    "Teste estabilidade com ruído e funções com modos negativos dominantes.",
                                    "Compare com métodos finitos de alta ordem."
                                  ],
                                  "verification": "Derivada em k=0 é zero; simetria preservada em IFFT.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código completo",
                                    "Testes unitários com assert"
                                  ],
                                  "tips": "Plote espectro antes/depois para visualizar multiplicação.",
                                  "learningObjective": "Garantir robustez em implementações numéricas.",
                                  "commonMistakes": "Não zerar k=0 levando a NaNs; assimetria em k negativos."
                                }
                              ],
                              "practicalExample": "Para u(x) = exp(sin(2π x)) em [0,1] com N=64, compute ˆu_k via FFT, aplique (i k)^2 para d²u/dx², IFFT e plote vs. derivada analítica 2 cos(2π x) exp(sin(2π x)) (2π)^2. Erro deve ser <1e-12.",
                              "finalVerifications": [
                                "Coeficientes modificados ˆu_k' = ˆu_k * (i k)^m para k ≠ 0.",
                                "ˆu_0' = 0 para todas as ordens.",
                                "Simetria preservada: parte real/imaginária consistente com paridade da derivada.",
                                "Erro L∞ no espaço físico < 1e-10 após IFFT.",
                                "Teste passou para m=1,2,3 com funções polinomiais exatas.",
                                "Estabilidade numérica: sem amplificação de ruído em modos altos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da multiplicação por (i k)^m (erro <1e-12).",
                                "Tratamento correto de k=0 e k negativos.",
                                "Eficiência computacional (O(N log N) via FFT).",
                                "Robustez a aliasing (uso de 2/3 rule).",
                                "Validação cruzada com métodos alternativos.",
                                "Código limpo e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Derivadas em equações de Navier-Stokes espectrais.",
                                "Programação: Manipulação de arrays complexos em NumPy/FFT.",
                                "Análise de Fourier: Propriedades de convolução e multiplicação.",
                                "Engenharia: Simulações de ondas e vibrações."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD) com métodos espectrais, como no modelo de previsão numérica do tempo (GFS) ou turbulência em aviões, onde derivadas precisas de alta ordem são essenciais para resolver PDEs sem dissipação numérica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Analisar precisão e estabilidade da diferenciação espectral",
                            "description": "Comparar erro espectral (exponencial em N para funções suaves) versus métodos finitos, e discutir Runge phenomenon evitado em bases trigonométricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Diferenciação Espectral e Métodos Finitos",
                                  "subSteps": [
                                    "Estude a definição de diferenciação espectral usando séries de Fourier ou Chebyshev.",
                                    "Revise a diferenciação por diferenças finitas (central, forward, backward) e suas fórmulas.",
                                    "Implemente um exemplo simples de cada método em código para uma função teste como sin(x).",
                                    "Calcule derivadas analíticas para comparação inicial.",
                                    "Registre as diferenças entre abordagens espectrais e finitas."
                                  ],
                                  "verification": "Implementação de código roda sem erros e derivadas aproximadas coincidem com analíticas para N pequeno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/SciPy ou MATLAB; função teste sin(x) ou exp(-x^2).",
                                  "tips": "Use grids uniformes para métodos finitos e Chebyshev para espectrais inicialmente.",
                                  "learningObjective": "Compreender as bases matemáticas de diferenciação espectral versus finitas.",
                                  "commonMistakes": "Confundir multiplicação por ik no espaço espectral com diferenças finitas sem considerar aliasing."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Erro Espectral e sua Dependência em N",
                                  "subSteps": [
                                    "Derive ou revise a estimativa de erro espectral: O(N^{-m}) exponencial para funções suaves de classe C^m.",
                                    "Compare com erro de métodos finitos: O(h^2) ou O(h^4) polinomial em h=1/N.",
                                    "Implemente experimentos numéricos variando N de 16 a 1024 para uma função suave como exp(-x^2).",
                                    "Plote log(erros) vs log(N) para visualizar convergência exponencial vs polinomial.",
                                    "Discuta impacto da suavidade da função no erro."
                                  ],
                                  "verification": "Gráficos mostram convergência exponencial clara para espectral e polinomial para finitos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/MATLAB com plotting (Matplotlib); funções suaves como Gaussianas.",
                                  "tips": "Use precisão dupla e evite underflow normalizando coeficientes espectrais.",
                                  "learningObjective": "Quantificar e visualizar a superioridade exponencial do erro espectral.",
                                  "commonMistakes": "Usar funções não-suaves (ex: |x|) que mascaram a convergência exponencial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Fenômeno de Runge e sua Evitação em Bases Trigonométricas",
                                  "subSteps": [
                                    "Implemente interpolação polinomial em pontos equidistantes para f(x)=1/(1+25x^2) e observe oscilações nas bordas.",
                                    "Explique o Runge phenomenon: divergência perto das extremidades para altos graus.",
                                    "Contrast com bases trigonométricas (Fourier): periodicidade evita Runge.",
                                    "Teste diferenciação em bases Chebyshev (não-periódicas) vs Fourier para funções periódicas.",
                                    "Analise estabilidade: norma do operador de diferenciação cresce como N^2 em finitos vs N em espectrais."
                                  ],
                                  "verification": "Simulações reproduzem Runge em polinomiais equidistantes e ausência em Fourier.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código para interpolação (numpy.polyfit ou FFT); função Runge 1/(1+25x^2).",
                                  "tips": "Use dealiasing com padding para FFT precisa em não-lineares.",
                                  "learningObjective": "Entender como bases trigonométricas superam limitações de estabilidade de métodos finitos.",
                                  "commonMistakes": "Aplicar Fourier a funções não-periódicas causando Gibbs phenomenon."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Precisão e Estabilidade Geral e Sintetizar Análise",
                                  "subSteps": [
                                    "Compile tabelas comparativas: erro L2/infinito, custo computacional (O(N log N) vs O(N)).",
                                    "Discuta estabilidade condicional: espectrais bem-condicionados para suaves, finitos para irregulares.",
                                    "Simule problema real: derivada de onda senoidal com ruído.",
                                    "Avalie trade-offs: precisão alta vs sensibilidade a não-suavidade.",
                                    "Escreva relatório resumindo vantagens espectrais."
                                  ],
                                  "verification": "Relatório de 1 página com tabelas/gráficos e conclusões claras.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha ou Jupyter notebook para tabelas; exemplos com ruído.",
                                  "tips": "Meça tempo de CPU para custo real.",
                                  "learningObjective": "Sintetizar comparação global de precisão e estabilidade.",
                                  "commonMistakes": "Ignorar custo log N do FFT ao superestimar eficiência espectral."
                                }
                              ],
                              "practicalExample": "Implemente diferenciação espectral via FFT para u(x) = sin(2πx) + 0.1*exp(-50(x-0.5)^2) em [0,1] periódico. Compare erro com diferenças centrais de 4a ordem para N=64,128,256. Observe erro espectral caindo de 1e-3 para 1e-10 vs 1e-5 para 1e-4 em finitos.",
                              "finalVerifications": [
                                "Explicar verbalmente erro exponencial em N para funções suaves.",
                                "Reproduzir Runge phenomenon em código para interpolação polinomial.",
                                "Plotar curvas de convergência exponencial vs polinomial.",
                                "Discutir norma do operador: O(N) espectral vs O(1/h) finitos.",
                                "Identificar cenários onde finitos superam espectrais (ex: choques).",
                                "Calcular erro para função teste específica com precisão <1e-8."
                              ],
                              "assessmentCriteria": [
                                "Compreensão do erro espectral (exponencial vs polinomial): 25%.",
                                "Análise correta do Runge phenomenon e bases trigonométricas: 25%.",
                                "Qualidade de simulações numéricas e gráficos: 20%.",
                                "Discussão de estabilidade e trade-offs: 15%.",
                                "Relatório síntese claro e conciso: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de PDEs como Navier-Stokes onde precisão espectral é crucial.",
                                "Engenharia: Análise de sinais em DSP usando FFT para derivação de velocidades.",
                                "Ciência de Dados: Processamento de séries temporais financeiras com diferenciação suave.",
                                "Computação Científica: Otimização de solvers numéricos em bibliotecas como Dedalus."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos (ex: turbulência via equações de Navier-Stokes), diferenciação espectral permite resoluções altas com N~512, capturando escalas finas inacessíveis por métodos finitos sem grids massivos, economizando tempo em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Reconstrução e Aplicação Prática",
                        "description": "Transformada inversa rápida (IFFT) para obter derivadas no espaço físico e integração em métodos pseudoespectrais para evolução temporal.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Computar a IFFT dos coeficientes diferenciados",
                            "description": "Aplicar a transformada inversa (1/N) ∑_{k} ˆu'_k exp(2π i k j / N) para reconstruir a derivada numérica no domínio físico com alta precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os coeficientes diferenciados ˆu'_k",
                                  "subSteps": [
                                    "Identifique os coeficientes espectrais originais ˆu_k da FFT da função u.",
                                    "Calcule os coeficientes diferenciados multiplicando ˆu_k por (i * 2π k / N) para k=0 a N/2 (e simétricos para modos negativos).",
                                    "Armazene os ˆu'_k em um array complexo de tamanho N, garantindo periodicidade.",
                                    "Verifique a simetria hermitiana dos coeficientes para funções reais.",
                                    "Ajuste os modos zero e Nyquist se necessário (k=0 e k=N/2)."
                                  ],
                                  "verification": "Confirme que ˆu'_k é um array complexo de tamanho N com imag(ˆu'_0)=0 e simetria ˆu'_{N-k} = conj(ˆu'_k).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca NumPy (Python)",
                                    "Array de coeficientes ˆu_k de exemplo",
                                    "Documentação FFT NumPy"
                                  ],
                                  "tips": "Use np.fft.fftfreq(N, d=dx) para obter as frequências k precisas.",
                                  "learningObjective": "Entender como os coeficientes diferenciados são obtidos a partir dos espectrais originais mantendo propriedades analíticas.",
                                  "commonMistakes": [
                                    "Esquecer a fator 2π / L na diferenciação espectral",
                                    "Não tratar modos negativos corretamente",
                                    "Ignorar simetria para funções reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar parâmetros da IFFT",
                                  "subSteps": [
                                    "Defina N como o número de pontos de grade no domínio físico.",
                                    "Prepare o vetor de índices j de 0 a N-1 para o domínio espacial.",
                                    "Selecione a convenção de normalização: fator 1/N na IFFT.",
                                    "Importe a função ifft da biblioteca (ex: np.fft.ifft).",
                                    "Defina o passo espacial dx = L / N, onde L é o período."
                                  ],
                                  "verification": "Verifique que N == len(ˆu'_k) e que a função ifft está pronta com shape correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python com NumPy",
                                    "Notebook Jupyter para testes"
                                  ],
                                  "tips": "Em NumPy, np.fft.ifft já inclui /N; confirme com docstring.",
                                  "learningObjective": "Configurar corretamente os parâmetros para garantir consistência entre FFT e IFFT.",
                                  "commonMistakes": [
                                    "Confundir normalização (FFT sem /N vs IFFT com /N)",
                                    "Usar ifft sem axis=0 para vetores 1D",
                                    "Definir dx incorreto levando a escalas erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o cálculo da IFFT",
                                  "subSteps": [
                                    "Aplique a fórmula: u'_j = (1/N) ∑_{k=0}^{N-1} ˆu'_k exp(2π i k j / N).",
                                    "Use np.fft.ifft(ˆu_prime) para computar diretamente.",
                                    "Armazene o resultado em um array real (tomando parte real se imag pequeno).",
                                    "Multiplique pelo fator de escala espacial se necessário (ex: dx para derivada física).",
                                    "Plote u'_j vs x_j para visualização inicial."
                                  ],
                                  "verification": "O resultado u' deve ser real (abs(imag) < 1e-12) e periódico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy.fft",
                                    "Matplotlib para plotagem",
                                    "Exemplo de dados numéricos"
                                  ],
                                  "tips": "Use np.real(ifft_result) para eliminar ruído numérico na parte imaginária.",
                                  "learningObjective": "Implementar numericamente a reconstrução da derivada no domínio físico via IFFT.",
                                  "commonMistakes": [
                                    "Esquecer np.real() levando a resultados complexos espúrios",
                                    "Não dividir por N manualmente se convenção errada",
                                    "Shift circular incorreto (use fftshift se necessário)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar o resultado",
                                  "subSteps": [
                                    "Compare u'_j com a derivada analítica conhecida da função original.",
                                    "Calcule o erro L2: sqrt(∑ |u'_num - u'_anal|^2 / N).",
                                    "Verifique conservação de energia ou propriedades espectrais.",
                                    "Analise precisão espectral (alta para modos resolvidos).",
                                    "Documente o processo em um relatório curto."
                                  ],
                                  "verification": "Erro L2 < 1e-10 para funções suaves e N>=32.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Função analítica de teste (ex: sin(2π x/L))",
                                    "Código para erro L2"
                                  ],
                                  "tips": "Teste com funções de alta frequência para ver aliasing.",
                                  "learningObjective": "Avaliar a precisão e confiabilidade da diferenciação pseudoespectral.",
                                  "commonMistakes": [
                                    "Comparar sem alinhar grids (fftshift/ifftshift)",
                                    "Ignorar fator dx na derivada física",
                                    "Usar N pequeno levando a baixa precisão"
                                  ]
                                }
                              ],
                              "practicalExample": "Para u(x) = sin(2π x / L) com L=1, N=16, dx=1/16. FFT → ˆu_k não-zero só em k=1 e k=N-1. Diferencie: ˆu'_1 = i 2π ˆu_1, ˆu'_{N-1} = -i 2π ˆu_{N-1}. IFFT(ˆu') → u'(x) ≈ 2π cos(2π x / L), com erro ~1e-14.",
                              "finalVerifications": [
                                "Vetor resultado tem tamanho N e é real dentro de tolerância numérica.",
                                "Erro L2 com derivada analítica < 1e-12.",
                                "Resultado periódico: u'(0) ≈ u'(L).",
                                "Energia preservada: ∫ |u'|^2 dx ≈ soma espectral de |ˆu'_k|^2.",
                                "Alta precisão para modos k << N/2.",
                                "Sem artefatos de aliasing em funções suaves."
                              ],
                              "assessmentCriteria": [
                                "Correta preparação de ˆu'_k com simetria hermitiana.",
                                "Normalização precisa na IFFT (fator 1/N aplicado).",
                                "Implementação numérica eficiente usando bibliotecas padrão.",
                                "Validação quantitativa com métricas de erro.",
                                "Interpretação física correta da derivada reconstruída.",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Resolução de PDEs como equação de onda via métodos espectrais.",
                                "Processamento de Sinais: Filtragem e análise em domínio de Fourier.",
                                "Engenharia: Simulações CFD (dinâmica de fluidos computacional).",
                                "Ciência de Dados: Manipulação eficiente de transforms em big data."
                              ],
                              "realWorldApplication": "Em simulações numéricas de turbulência atmosférica ou oceanográfica, onde diferenciação espectral via IFFT reconstrói gradientes de velocidade com precisão exponencial, essencial para modelos de previsão do tempo e clima."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Implementar um exemplo completo de diferenciação espectral",
                            "description": "Programar em Python/MATLAB o ciclo FFT → multiplicação ik → IFFT para derivar funções como sin(x) ou exp(sin(x)) em [0,2π], validando contra derivadas analíticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e definir a função de teste",
                                  "subSteps": [
                                    "Instale ou importe bibliotecas necessárias: numpy, matplotlib e scipy para FFT.",
                                    "Defina o número de pontos N (ex: 256 ou 512 para boa resolução).",
                                    "Crie o grid espacial x = np.linspace(0, 2*np.pi, N, endpoint=False) para periodicidade.",
                                    "Defina a função de teste, ex: f(x) = np.sin(x) ou f(x) = np.exp(np.sin(x)).",
                                    "Calcule a derivada analítica para validação futura, ex: df_analitica = np.cos(x)."
                                  ],
                                  "verification": "Execute o código e confirme que x tem shape (N,) e f(x) está definido corretamente sem erros.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Matplotlib",
                                    "Jupyter Notebook ou IDE similar"
                                  ],
                                  "tips": "Use endpoint=False em linspace para evitar duplicação em 0 e 2π, garantindo periodicidade.",
                                  "learningObjective": "Compreender a discretização de domínio periódico e preparação de dados para métodos espectrais.",
                                  "commonMistakes": [
                                    "Usar grid não-uniforme ou incluir endpoint=True, quebrando periodicidade.",
                                    "Escolher N muito pequeno (<128), causando aliasing.",
                                    "Definir função não periódica ou suave."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Transformada de Fourier Discreta (FFT) da função",
                                  "subSteps": [
                                    "Aplique FFT: f_hat = np.fft.fft(f).",
                                    "Defina os frequências wavenumbers k = np.fft.fftfreq(N, d=dx) onde dx = 2*np.pi/N.",
                                    "Verifique que k vai de 0 a positivo e negativo simétrico devido à periodicidade.",
                                    "Armazene f_hat como array complexo.",
                                    "Opcional: plote o espectro |f_hat| para visualizar componentes de frequência."
                                  ],
                                  "verification": "Inspecione f_hat[0] (componente DC) e magnitudes; deve ser complexo com valores esperados para sin(x).",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "NumPy (np.fft module)"
                                  ],
                                  "tips": "np.fft.fft usa convenção onde k=0 primeiro, positivos depois, negativos no final.",
                                  "learningObjective": "Dominar a transformação para o espaço espectral e interpretação de coeficientes.",
                                  "commonMistakes": [
                                    "Confundir fftfreq com rfftfreq (para real FFT).",
                                    "Não normalizar dx corretamente.",
                                    "Ignorar que FFT é não-normalizada por padrão."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar diferenciação espectral via multiplicação por i*k",
                                  "subSteps": [
                                    "Crie o filtro de diferenciação: deriv_factor = 1j * 2*np.pi * k (normalizado para derivada exata).",
                                    "Multiplique: f_hat_deriv = f_hat * deriv_factor.",
                                    "Trunque ou aplique filtro dealiasing se necessário (ex: zero modos > N/3).",
                                    "Verifique que deriv_factor[0] = 0 (sem derivada DC) e simetria imaginária para funções reais.",
                                    "Opcional: plote Re/Im de f_hat_deriv vs k."
                                  ],
                                  "verification": "Confirme que f_hat_deriv tem magnitude similar a f_hat mas fase shiftada por 90 graus em baixas frequências.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "NumPy para operações vetoriais"
                                  ],
                                  "tips": "Use 1j para imaginária; fator 2π garante derivada exata para funções trigonométricas.",
                                  "learningObjective": "Entender a multiplicação pontual no espaço de Fourier como operador diferencial.",
                                  "commonMistakes": [
                                    "Esquecer 2π na escala de k.",
                                    "Usar k sem fftfreq, levando a escalas erradas.",
                                    "Não lidar com k=0 corretamente (deve ser zero)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular IFFT para obter derivada numérica e validar",
                                  "subSteps": [
                                    "Aplique IFFT: df_num = np.real(np.fft.ifft(f_hat_deriv)).",
                                    "Compare df_num com df_analitica via erro L2 ou max: erro = np.max(np.abs(df_num - df_analitica)).",
                                    "Plote f(x), df_analitica e df_num no mesmo gráfico.",
                                    "Calcule métricas: RMSE = np.sqrt(np.mean((df_num - df_analitica)**2)).",
                                    "Teste com outra função como exp(sin(x)) para generalizar."
                                  ],
                                  "verification": "Erro máximo < 1e-12 para N=512 e sin(x); plots sobrepostos perfeitamente.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "NumPy, Matplotlib para plotting"
                                  ],
                                  "tips": "Sempre tome np.real() pois IFFT de derivada real deve ser real (erro numérico pequeno imaginário).",
                                  "learningObjective": "Validar precisão espectral exponencial e visualizar resultados.",
                                  "commonMistakes": [
                                    "Esquecer np.real(), deixando ruído imaginário.",
                                    "Não normalizar IFFT (np.fft.ifft já normaliza).",
                                    "Comparar sem periodicidade wrap-around."
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(x) = sin(x) em [0,2π] com N=512: FFT(sin) tem picos em k=±1; após *i*2πk, IFFT dá cos(x) exato até precisão máquina. Código completo: ~50 linhas em Jupyter, plot mostra match perfeito.",
                              "finalVerifications": [
                                "Código executa sem erros e produz df_num suave.",
                                "Erro máximo |df_num - df_analitica| < 1e-10 para N>=256.",
                                "Plots mostram sobreposição visual perfeita.",
                                "Teste com exp(sin(x)) dá erro similarmente baixo.",
                                "Espectro f_hat_deriv tem fase +90° em modos dominantes.",
                                "Tempo de execução <1s para N=1024."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação do ciclo FFT → *ik → IFFT com periodicidade.",
                                "Validação quantitativa (erros L∞ e L2 reportados).",
                                "Visualizações claras (plots de f, df_num, df_analitica).",
                                "Generalização para funções não-trigonométricas.",
                                "Comentários no código explicando cada etapa.",
                                "Eficiência: O(N log N) implícita via FFT."
                              ],
                              "crossCurricularConnections": [
                                "Programação Científica (Python/NumPy para computação vetorial).",
                                "Processamento de Sinais (FFT/IFFT em análise harmônica).",
                                "Física Computacional (derivadas em simulações de ondas/PDEs).",
                                "Matemática Aplicada (Séries de Fourier e operadores diferenciais).",
                                "Engenharia (Análise modal em estruturas vibrantes)."
                              ],
                              "realWorldApplication": "Método essencial em simulações numéricas de equações diferenciais parciais periódicas, como equações de Navier-Stokes para fluidos turbulentos, previsão meteorológica em esferas (via spherical harmonics) e processamento de imagens/sinais onde derivadas rápidas e precisas são críticas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.2",
                              "10.1.7.3.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Algoritmo Pseudoespectral para EDOs",
                    "description": "Passos para aplicar métodos pseudoespectrais em problemas de valor inicial de equações diferenciais ordinárias.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Seleção dos Pontos Nodais",
                        "description": "Definição e cálculo dos pontos de collocation no intervalo temporal, geralmente pontos Chebyshev-Gauss-Lobatto, para discretizar o problema de valor inicial de EDOs usando métodos pseudoespectrais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Cálculo dos pontos Chebyshev-Gauss-Lobatto",
                            "description": "Determinar os pontos nodais θ_k = cos(π k / N) para k = 0, 1, ..., N no intervalo padrão [-1, 1], onde N é o grau do polinômio de aproximação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos dos pontos nodais Chebyshev-Gauss-Lobatto",
                                  "subSteps": [
                                    "Estude a importância dos pontos nodais em métodos pseudoespectrais para aproximação de polinômios.",
                                    "Revise as propriedades dos polinômios de Chebyshev de segunda espécie, que definem os pesos CGL.",
                                    "Identifique que os pontos CGL incluem os extremos do intervalo [-1,1] para estabilidade numérica.",
                                    "Compare com outros pontos de Gauss (Legendre, Chebyshev-Gauss) destacando a inclusão de bordas.",
                                    "Anote as vantagens: clustering perto das extremidades reduzindo Runge phenomenon."
                                  ],
                                  "verification": "Resuma em 3 frases as diferenças entre CGL e pontos Gauss-Legendre.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de análise numérica (ex: Trefethen 'Spectral Methods'), notas de aula sobre pseudoespectrais.",
                                  "tips": "Visualize os pontos em um gráfico mental: eles se concentram nas pontas.",
                                  "learningObjective": "Entender o papel e propriedades únicas dos pontos CGL no contexto de aproximações espectrais.",
                                  "commonMistakes": "Confundir com pontos Chebyshev-Gauss (sem bordas) ou Gauss-Lobatto genérico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e derivar a fórmula dos pontos θ_k",
                                  "subSteps": [
                                    "Memorize a fórmula: θ_k = cos(π k / N) para k = 0, 1, ..., N.",
                                    "Derive brevemente: raízes dos polinômios de Chebyshev U_N (segunda espécie).",
                                    "Verifique para k=0: θ_0 = cos(0) = 1; k=N: θ_N = cos(π) = -1.",
                                    "Calcule manualmente para N=1: pontos [-1,1].",
                                    "Liste os k's e associe aos ângulos π k / N."
                                  ],
                                  "verification": "Escreva a fórmula e calcule θ_0, θ_N para N arbitrário.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta, calculadora científica.",
                                  "tips": "Pense em termos angulares: projeção trigonométrica no círculo unitário.",
                                  "learningObjective": "Dominar a fórmula exata e suas propriedades de contorno.",
                                  "commonMistakes": "Usar sin em vez de cos ou inverter o intervalo k."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os pontos manualmente para N pequeno",
                                  "subSteps": [
                                    "Escolha N=4 e liste k=0 a 4.",
                                    "Calcule cada θ_k: cos(0), cos(π/4), cos(2π/4), cos(3π/4), cos(π).",
                                    "Arredonde para 4 casas decimais: [1, 0.7071, 0, -0.7071, -1].",
                                    "Verifique simetria: θ_k = -θ_{N-k}.",
                                    "Repita para N=3 e tabule os resultados."
                                  ],
                                  "verification": "Tabela com pontos exatos e aproximados para N=4 coincide com valores conhecidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora com função cos (em radianos), tabela trigonométrica.",
                                  "tips": "Use radianos, não graus; memorize cos(π/4)=√2/2 ≈0.7071.",
                                  "learningObjective": "Executar cálculos precisos manualmente para internalizar o padrão.",
                                  "commonMistakes": "Erro de unidade angular (graus vs radianos) ou arredondamento precoce."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e visualizar numericamente",
                                  "subSteps": [
                                    "Escreva código em Python/MATLAB: loop for k in 0:N, theta[k] = cos(pi*k/N).",
                                    "Gere pontos para N=10 e plote no intervalo [-1,1].",
                                    "Observe o clustering nas extremidades.",
                                    "Compare precisão com função built-in (ex: chebpts em Chebfun).",
                                    "Salve a lista de pontos em um vetor para uso futuro."
                                  ],
                                  "verification": "Gráfico mostra N+1 pontos simétricos incluindo ±1; valores coincidem com cálculos manuais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com numpy/matplotlib ou MATLAB, editor de código.",
                                  "tips": "Use linspace para k: k = linspace(0,N,N+1); theta = cos(pi*k/N).",
                                  "learningObjective": "Automatizar o cálculo e visualizar propriedades geométricas.",
                                  "commonMistakes": "Índice errado no loop (off-by-one) ou plot sem marcar pontos."
                                }
                              ],
                              "practicalExample": "Para N=5 (grau 5), calcule θ_k: k=0: cos(0)=1; k=1: cos(π/5)≈0.8090; k=2: cos(2π/5)≈0.3090; k=3: cos(3π/5)≈-0.3090; k=4: cos(4π/5)≈-0.8090; k=5: cos(π)=-1. Pontos: [1, 0.8090, 0.3090, -0.3090, -0.8090, -1]. Use em interpolação pseudoespectral de f(x)=sin(x).",
                              "finalVerifications": [
                                "Lista contém exatamente N+1 pontos no [-1,1].",
                                "θ_0 = 1 e θ_N = -1 incluídos.",
                                "Simetria: θ_k = -θ_{N-k} para todos k.",
                                "Valores decrescentes de 1 a -1.",
                                "Precisão numérica: erro <1e-10 vs cos exato.",
                                "Clustering visual nas extremidades em plot."
                              ],
                              "assessmentCriteria": [
                                "Fórmula correta recitada sem hesitação.",
                                "Cálculo manual para N≤5 exato até 4 decimais.",
                                "Código gera pontos idênticos aos manuais.",
                                "Explicação clara da derivação trigonométrica.",
                                "Identificação de 3 propriedades únicas dos CGL.",
                                "Aplicação correta em exemplo simples de interpolação."
                              ],
                              "crossCurricularConnections": [
                                "Física: Pontos nodais em métodos espectrais para equações de onda/osciladores.",
                                "Computação: Implementação em bibliotecas numéricas (NumPy, SciPy).",
                                "Engenharia: Simulações CFD/PDEs com Galerkin espectral.",
                                "Estatística: Quadratura de alta ordem para integrais.",
                                "Visualização de Dados: Plots trigonométricos e distribuição de pontos."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais, os pontos CGL são usados em solvers pseudoespectrais para propagar órbitas de satélites ou resolver EDOs de dinâmica de fluidos, garantindo alta precisão com poucos pontos nodais clustered nas regiões críticas de borda."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Mapeamento do intervalo [a, b]",
                            "description": "Mapear os pontos θ_k de [-1, 1] para o intervalo temporal [a, b] do problema de valor inicial utilizando a transformação linear t_k = ((b - a)/2) * θ_k + ((a + b)/2).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Mapeamento de Intervalos",
                                  "subSteps": [
                                    "Identifique o intervalo padrão [-1, 1] usado em métodos pseudoespectrais e o intervalo temporal [a, b] do problema de valor inicial (PVI).",
                                    "Explique por que o mapeamento é necessário: os métodos pseudoespectrais são definidos em [-1, 1], mas PVIs ocorrem em [a, b].",
                                    "Revise conceitos de transformação afim linear: escala e translação.",
                                    "Discuta preservação de propriedades como extremos e simetria.",
                                    "Esboce graficamente os intervalos [-1, 1] e [a, b] com setas indicando mapeamento."
                                  ],
                                  "verification": "Resuma em 2-3 frases o propósito do mapeamento e desenhe um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora básica",
                                  "tips": "Use cores diferentes para intervalos de origem e destino no diagrama.",
                                  "learningObjective": "Entender a motivação e necessidade do mapeamento linear em métodos numéricos para EDOs.",
                                  "commonMistakes": "Confundir mapeamento com normalização simples; ignorar que é afim (escala + translação)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula de Transformação Linear",
                                  "subSteps": [
                                    "Estabeleça condições: t(-1) = a e t(1) = b.",
                                    "Defina a forma geral t(θ) = α θ + β.",
                                    "Resolva o sistema: α(-1) + β = a e α(1) + β = b, obtendo α = (b - a)/2 e β = (a + b)/2.",
                                    "Simplifique para t_k = ((b - a)/2) * θ_k + ((a + b)/2).",
                                    "Verifique com θ_k = 0: t_0 deve ser o ponto médio (a + b)/2."
                                  ],
                                  "verification": "Derive a fórmula do zero e teste com θ = -1, 0, 1 para confirmar t = a, (a+b)/2, b.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, calculadora",
                                  "tips": "Substitua valores numéricos simples (a=0, b=2) para validar intuitivamente.",
                                  "learningObjective": "Derivar corretamente a transformação linear que mapeia [-1,1] para [a,b].",
                                  "commonMistakes": "Erro aritmético em α ou β; esquecer divisão por 2 na escala."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Mapeamento a Pontos Nodais Específicos",
                                  "subSteps": [
                                    "Selecione pontos nodais θ_k, como Chebyshev: θ_k = cos(π k / N) para k=0 a N.",
                                    "Calcule t_k para cada θ_k usando a fórmula.",
                                    "Liste os t_k resultantes e ordene-os em [a,b].",
                                    "Calcule diferenças finitas ou distâncias para verificar distribuição.",
                                    "Implemente em pseudocódigo ou software simples."
                                  ],
                                  "verification": "Compute t_k para N=4 pontos Chebyshev e confirme que min(t) ≈ a e max(t) ≈ b.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora ou Python/MATLAB (opcional), tabela de pontos Chebyshev",
                                  "tips": "Use N pequeno (3-5) para cálculos manuais; automatize para N maior.",
                                  "learningObjective": "Aplicar a fórmula para gerar pontos nodais mapeados no intervalo [a,b].",
                                  "commonMistakes": "Usar θ_k fora de [-1,1]; não ordenar os pontos mapeados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Propriedades e Testar em um PVI Simples",
                                  "subSteps": [
                                    "Confirme que o mapeamento preserva linearidade e extremos.",
                                    "Teste invertibilidade: derive θ_k de t_k.",
                                    "Aplique em um PVI exemplo: y' = y, y(a)=1 em [a,b]=[0,1].",
                                    "Compare solução numérica com analítica em pontos mapeados.",
                                    "Analise erros de arredondamento em implementações numéricas."
                                  ],
                                  "verification": "Resolva um PVI simples e plote y(t_k) vs solução exata.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software numérico (Python/Octave), gráfico de pontos",
                                  "tips": "Use y' = -y para oscilações visíveis em gráficos.",
                                  "learningObjective": "Validar o mapeamento em contexto de algoritmo pseudoespectral.",
                                  "commonMistakes": "Ignorar derivadas da transformação (dt/dθ = (b-a)/2) para chain rule em EDOs."
                                }
                              ],
                              "practicalExample": "Para resolver y' = y, y(0)=1 em [0,1] com N=4 pontos Chebyshev θ_k = cos(π k /4) ≈ [-1, -0.707, 0.707, 1], aplique t_k = (1-0)/2 * θ_k + (0+1)/2 = 0.5 θ_k + 0.5, obtendo t ≈ [0, 0.146, 0.854, 1]. Use esses t_k como nós para interpolação pseudoespectral.",
                              "finalVerifications": [
                                "Fórmula derivada corretamente e testada em extremos.",
                                "Pontos t_k distribuídos corretamente em [a,b] com ordenação crescente.",
                                "Mapeamento invertível: recuperar θ_k de t_k sem perda.",
                                "Aplicação em PVI simples converge para solução exata.",
                                "Cálculos manuais coincidem com implementação computacional.",
                                "dt/dθ = (b-a)/2 reconhecido para transformação de derivadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (sem erros aritméticos).",
                                "Correta aplicação a pelo menos 5 pontos nodais.",
                                "Verificação gráfica ou tabular de mapeamento.",
                                "Integração correta em contexto de PVI pseudoespectral.",
                                "Identificação de erros comuns e mitigação.",
                                "Explicação clara da preservação de propriedades lineares."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/NumPy para automação numérica.",
                                "Física: Mapeamento em simulações de EDOs para dinâmica (ex: pêndulo).",
                                "Engenharia: Otimização em controle de sistemas com intervalos variáveis.",
                                "Estatística: Transformações afins em distribuições probabilísticas."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais, mapeia métodos espectrais de [-1,1] para trajetórias de voo [t0,tf], permitindo soluções precisas e eficientes para equações diferenciais não-lineares em design de mísseis ou órbitas."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Escolha do número de pontos N",
                            "description": "Selecionar o número de pontos nodais N+1 com base na precisão desejada e na suavidade da solução, considerando convergência espectral exponencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Convergência Espectral Exponencial",
                                  "subSteps": [
                                    "Estude a definição de métodos espectrais e sua base em séries de Fourier ou polinômios de Chebyshev.",
                                    "Aprenda que a convergência é exponencial para soluções analíticas suaves: erro ~ exp(-c N), onde N é o número de pontos.",
                                    "Revise o teorema de Bernstein sobre aproximação espectral para funções suaves.",
                                    "Analise gráficos de log(erros) vs N para visualizar a taxa exponencial.",
                                    "Compare com métodos finitos diferenciais, que têm convergência algébrica."
                                  ],
                                  "verification": "Desenhe um gráfico de convergência exponencial e explique verbalmente a relação erro-N.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Livro de análise numérica (cap. pseudoespectrais)",
                                    "Gráficos de exemplo de convergência espectral",
                                    "Software como MATLAB ou Python (NumPy/Matplotlib)"
                                  ],
                                  "tips": [
                                    "Comece com funções suaves como sen(x); evite descontinuidades iniciais.",
                                    "Use escala logarítmica para erros.",
                                    "Memorize: maior suavidade (mais derivadas contínuas) → melhor constante c."
                                  ],
                                  "learningObjective": "Explicar por que a convergência é exponencial em métodos pseudoespectrais e sua dependência em N.",
                                  "commonMistakes": [
                                    "Confundir com convergência linear de métodos FD.",
                                    "Ignorar o papel da suavidade da solução.",
                                    "Esquecer que N+1 pontos nodais implicam grau N polinômio."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a Suavidade da Solução Analítica",
                                  "subSteps": [
                                    "Identifique o número de derivadas contínuas da solução exata (classe C^k).",
                                    "Calcule os coeficientes de Fourier ou Chebyshev para quantificar decaimento exponencial.",
                                    "Use critérios como o espectro de energia: soma |c_k|^2 para k altos deve decair rápido.",
                                    "Simule suavidade com testes: integre EDO e verifique resíduos em altas frequências.",
                                    "Classifique soluções: 'muito suave' (C^∞) vs 'moderadamente suave' (C^4)."
                                  ],
                                  "verification": "Para uma EDO dada, compute os 10 primeiros coeficientes espectrais e mostre decaimento.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Código Python para FFT ou DCT",
                                    "EDOs de teste como y' = -y (solução e^{-t})",
                                    "Documentação FFTW ou SciPy"
                                  ],
                                  "tips": [
                                    "Para Chebyshev, use pontos nodais cos(pi j / N).",
                                    "Suavidade alta → N menor.",
                                    "Teste com ruído para ver impacto."
                                  ],
                                  "learningObjective": "Quantificar suavidade da solução para prever impacto na escolha de N.",
                                  "commonMistakes": [
                                    "Assumir toda solução é suave sem verificação.",
                                    "Confundir suavidade local com global.",
                                    "Usar métricas erradas como norma L1 em vez de espectral."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Critérios de Precisão Desejada",
                                  "subSteps": [
                                    "Especifique tolerância de erro: ε = 10^{-p} (ex: p=6 para precisão máquina dupla).",
                                    "Escolha norma de erro: máximo (L∞) para pseudoespectrais, comum em EDOs.",
                                    "Estime erro a priori: log(ε) ≈ -c N, resolva para N ≈ -log(ε)/c.",
                                    "Considere custo computacional: O(N^2) por timestep → equilibre precisão vs tempo.",
                                    "Defina faixas: N=16 para protótipos, N=256+ para produção."
                                  ],
                                  "verification": "Escreva fórmula para N mínimo dado ε e c estimado.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Tabela de valores c para funções modelo",
                                    "Planilha Excel para cálculos log",
                                    "Referências teóricas (Trefethen Spectral Methods)"
                                  ],
                                  "tips": [
                                    "c ≈ π k /2 para classe C^k.",
                                    "Comece conservador: N 2x maior que estimado.",
                                    "Monitore condição da matriz de diferenciação."
                                  ],
                                  "learningObjective": "Traduzir requisitos de precisão em estimativa inicial de N.",
                                  "commonMistakes": [
                                    "Escolher ε muito ambicioso sem hardware.",
                                    "Ignorar overhead de N grande em iterações.",
                                    "Usar norma L2 em vez de L∞ para erros pontuais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar, Testar e Refinar N",
                                  "subSteps": [
                                    "Calcule N inicial: N = ceil( -log(ε) / c ), com c de suavidade.",
                                    "Implemente solver pseudoespectral para N, 2N, 4N e compare erros.",
                                    "Ajuste iterativamente: dobre N até platô de precisão.",
                                    "Valide convergência: plot log(erros) vs log(N), verifique inclinação ~ -c.",
                                    "Documente escolha final com justificativa."
                                  ],
                                  "verification": "Execute simulação para N escolhido e confirme erro < ε.",
                                  "estimatedTime": "90 minutes",
                                  "materials": [
                                    "Código solver pseudoespectral (Python/MATLAB)",
                                    "EDO teste com solução conhecida",
                                    "Ferramentas de plotagem"
                                  ],
                                  "tips": [
                                    "Use pontos de Gauss-Lobatto para simplicidade.",
                                    "Monitore aliasing: N > 2 * frequências dominantes.",
                                    "Automatize com loop sobre N."
                                  ],
                                  "learningObjective": "Aplicar processo prático para escolher N ótimo.",
                                  "commonMistakes": [
                                    "Parar cedo sem platô.",
                                    "Não testar múltiplos N.",
                                    "Esquecer runge phenomenon em extremos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a EDO y' = -20 (y - sin(t)) em [0, 10π] com y(0)=0 (solução suave ~ e^{-20t} sin(t)), defina ε=1e-8. Estime c=5 pela suavidade C^∞, N ≈ -log(1e-8)/(5) ≈ 14 → teste N=16,32,64. Erro L∞ cai de 1e-4 para 1e-10, escolha N=32 (erro 1e-9, custo razoável).",
                              "finalVerifications": [
                                "Explicar verbalmente a fórmula N ≈ -log(ε)/c.",
                                "Produzir gráfico de convergência exponencial para exemplo prático.",
                                "Selecionar N correto para nova EDO com ε dada.",
                                "Identificar se solução não-suave requer N extra ou Runge-Kutta.",
                                "Calcular custo O(N^2) para N=128 vs precisão ganha.",
                                "Discutir trade-off precisão-suavidade-custo."
                              ],
                              "assessmentCriteria": [
                                "Correta derivação da estimativa N de ε e c (90% precisão).",
                                "Gráfico de convergência mostra taxa exponencial clara.",
                                "Escolha de N atinge ε sem excesso >2x.",
                                "Justificativa inclui suavidade e normas de erro.",
                                "Identificação de erros comuns em testes.",
                                "Aplicação consistente em exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Implementação eficiente em FFT para grandes N.",
                                "Física Computacional: Simulações de PDEs como Navier-Stokes com pseudoespectrais.",
                                "Engenharia: Otimização em controle ótimo (PDEs espectrais).",
                                "Estatística: Análise de séries temporais suaves via espectros.",
                                "Otimização: Equilíbrio custo-benefício em hiperparâmetros numéricos."
                              ],
                              "realWorldApplication": "Em modelagem climática (GCMs), escolher N~1024 para pseudoespectrais em esferas resolve equações de atmosfera com precisão sub-km, capturando ondas suaves sem difusão numérica excessiva, essencial para previsões de furacões."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Construção da Matriz de Diferenciação",
                        "description": "Montagem da matriz diferencial pseudoespectral D, que aproxima a derivada da solução interpolante nos pontos nodais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Polinômios de Lagrange",
                            "description": "Definir os polinômios de base de Lagrange l_k(t) = ∏_{j≠k} (t - t_j)/(t_k - t_j) associados aos pontos t_k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da interpolação polinomial de Lagrange",
                                  "subSteps": [
                                    "Revise o conceito de interpolação polinomial: dado pontos (t_j, y_j), encontrar polinômio P(t) tal que P(t_j) = y_j.",
                                    "Entenda a forma única de interpolação para n+1 pontos com polinômio de grau ≤ n.",
                                    "Identifique a necessidade de uma base ortogonal em relação aos pontos de interpolação.",
                                    "Estude a motivação para métodos pseudoespectrais em EDOs.",
                                    "Anote os símbolos: t_k como pontos de interpolação distintos."
                                  ],
                                  "verification": "Explique em suas palavras o que é interpolação de Lagrange e por que usamos bases l_k(t).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Análise Numérica",
                                    "Calculadora"
                                  ],
                                  "tips": "Comece com exemplos simples de 2 pontos para visualizar a interpolação.",
                                  "learningObjective": "Compreender o papel dos polinômios de Lagrange na interpolação.",
                                  "commonMistakes": [
                                    "Confundir com interpolação linear simples.",
                                    "Ignorar a unicidade do polinômio interpolante."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os pontos de interpolação e notação",
                                  "subSteps": [
                                    "Escolha um conjunto de N+1 pontos distintos t_0, t_1, ..., t_N.",
                                    "Introduza a notação para o k-ésimo polinômio de base l_k(t).",
                                    "Escreva a condição desejada: l_k(t_j) = δ_{kj} (1 se j=k, 0 caso contrário).",
                                    "Discuta os pontos de Chebyshev como escolha comum para estabilidade numérica.",
                                    "Liste os índices j ≠ k explicitamente."
                                  ],
                                  "verification": "Escreva a condição de Kronecker δ_{kj} para três pontos de exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de plotagem como Desmos ou GeoGebra"
                                  ],
                                  "tips": "Use pontos equidistantes inicialmente para simplicidade, depois mencione problemas de Runge.",
                                  "learningObjective": "Estabelecer a notação precisa para os polinômios de base.",
                                  "commonMistakes": [
                                    "Confundir índices k e j.",
                                    "Esquecer que pontos devem ser distintos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a fórmula do polinômio de base l_k(t)",
                                  "subSteps": [
                                    "Proponha a forma produto: l_k(t) = produto sobre j≠k de algo.",
                                    "Para satisfazer l_k(t_j)=0 quando j≠k, inclua fatores (t - t_j).",
                                    "Normalizar para l_k(t_k)=1, dividindo por produto j≠k (t_k - t_j).",
                                    "Escreva a fórmula completa: l_k(t) = ∏_{j≠k} (t - t_j)/(t_k - t_j).",
                                    "Simplifique para caso pequeno (N=2) e verifique."
                                  ],
                                  "verification": "Derive a fórmula passo a passo para k=1 com 3 pontos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplos impressos de derivação"
                                  ],
                                  "tips": "Escreva o produto explicitamente para evitar erros algébricos.",
                                  "learningObjective": "Construir e justificar a fórmula exata de l_k(t).",
                                  "commonMistakes": [
                                    "Inverter numerador e denominador.",
                                    "Esquecer o produto sobre j≠k."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades e generalizar",
                                  "subSteps": [
                                    "Verifique l_k(t_m) = δ_{km} para m≠k (produto tem zero no numerador).",
                                    "Confirme l_k(t_k)=1 (todos fatores =1).",
                                    "Discuta grau do polinômio: exatamente N para N+1 pontos.",
                                    "Conecte à matriz de diferenciação em métodos pseudoespectrais.",
                                    "Gere um exemplo numérico com valores específicos."
                                  ],
                                  "verification": "Compute l_k(t_j) para todos j e confirme as condições.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para verificação numérica"
                                  ],
                                  "tips": "Use sympy ou wolfram alpha para validação simbólica rápida.",
                                  "learningObjective": "Validar as propriedades fundamentais dos polinômios de base.",
                                  "commonMistakes": [
                                    "Erro em avaliação numérica devido a divisão por zero.",
                                    "Não generalizar para N arbitrário."
                                  ]
                                }
                              ],
                              "practicalExample": "Para pontos t0= -1, t1=0, t2=1, compute l1(t) = [(t - (-1))/(0 - (-1))] * [(t - 1)/(0 - 1)] = [(t+1)/1] * [(t-1)/(-1)] = (t+1)(1-t). Verifique: l1(-1)=0, l1(0)=1, l1(1)=0.",
                              "finalVerifications": [
                                "Escrever corretamente a fórmula de l_k(t).",
                                "Derivar l_k para 3 pontos sem erros.",
                                "Verificar condições δ_{kj} em exemplo numérico.",
                                "Explicar conexão com interpolação geral P(t) = ∑ y_k l_k(t).",
                                "Identificar grau e zeros do polinômio.",
                                "Discutir estabilidade com pontos de Chebyshev."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (100% correto).",
                                "Correção nas verificações de propriedades.",
                                "Clareza na explicação conceitual.",
                                "Uso correto de notação matemática.",
                                "Aplicação em exemplo prático sem erros numéricos.",
                                "Compreensão de limitações numéricas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aproximação de soluções em métodos espectrais para EDOs em mecânica quântica.",
                                "Informática: Implementação em código Python para interpolação numérica.",
                                "Engenharia: Simulações de fluidos usando pseudoespectrais.",
                                "Estatística: Regressão polinomial e suavização de dados."
                              ],
                              "realWorldApplication": "Os polinômios de Lagrange são fundamentais na construção da matriz de diferenciação em métodos pseudoespectrais para resolver eficientemente Equações Diferenciais Ordinárias (EDOs) em simulações científicas, como previsão de clima, dinâmica de fluidos e controle de sistemas aeroespaciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Derivadas dos polinômios de Lagrange",
                            "description": "Calcular as derivadas l_k'(t_j) nos pontos nodais, utilizando a fórmula D_{j,k} = l_k'(t_j) para j ≠ k e tratamento especial para os pontos extremos em bases Chebyshev.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição dos polinômios de Lagrange e os pesos nodais",
                                  "subSteps": [
                                    "Recordar a fórmula do polinômio de Lagrange: l_k(x) = ∏_{m≠k} (x - t_m) / (t_k - t_m)",
                                    "Identificar os pontos nodais t_j para j = 0 a N",
                                    "Definir os pesos nodais w_j = 1 / ∏_{m≠j} (t_j - t_m)",
                                    "Explicar o papel da matriz D onde D_{j,k} = l_k'(t_j)",
                                    "Discutir ajustes para pontos Chebyshev extremos (λ_0 = 1/2, λ_N = -1/2)"
                                  ],
                                  "verification": "Escrever corretamente as fórmulas de l_k(x) e w_j em um papel e verificar com referência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Tabela de pontos Chebyshev"
                                  ],
                                  "tips": "Comece com poucos pontos (N=2) para visualizar graficamente os l_k(x).",
                                  "learningObjective": "Dominar a notação e os pesos fundamentais para derivação.",
                                  "commonMistakes": [
                                    "Confundir w_j com o denominador de l_k",
                                    "Ignorar o fator 1/2 nos extremos Chebyshev"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a fórmula para D_{j,k} com j ≠ k",
                                  "subSteps": [
                                    "Partir da definição l_k'(x) como derivada do produto",
                                    "Aplicar a fórmula barycêntrica: D_{j,k} = w_k / (w_j (t_j - t_k)) para j ≠ k",
                                    "Ajustar para pesos λ_j em bases Chebyshev: usar λ_k / (λ_j (t_j - t_k))",
                                    "Verificar dimensionalmente: derivada deve ter unidade 1/distância",
                                    "Calcular manualmente para N=2 pontos equidistantes"
                                  ],
                                  "verification": "Computar D_{0,1} e D_{1,0} para dois pontos e confirmar simetria anti-aproximada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Folha de exercícios",
                                    "Software como MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Use frações exatas para evitar erros numéricos iniciais.",
                                  "learningObjective": "Derivar e aplicar a fórmula padrão para off-diagonal.",
                                  "commonMistakes": [
                                    "Inverter w_j e w_k",
                                    "Esquecer o sinal em (t_j - t_k)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os elementos diagonais D_{j,j}",
                                  "subSteps": [
                                    "Usar a propriedade de interpolação: sum_k l_k(t_j) = δ_{j k}",
                                    "Diferenciar: sum_k D_{j,k} = 0 para cada linha j",
                                    "Assim, D_{j,j} = - sum_{k≠j} D_{j,k}",
                                    "Verificar para um exemplo pequeno (N=2)",
                                    "Confirmar que a soma da linha é zero"
                                  ],
                                  "verification": "Construir matriz D completa 3x3 e verificar soma zero por linha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre verifique a propriedade de partição da unidade após diferenciação.",
                                  "learningObjective": "Compreender e aplicar a condição de soma zero para diagonal.",
                                  "commonMistakes": [
                                    "Sinal errado no D_{j,j}",
                                    "Incluir k=j no sum incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Tratamento especial para pontos extremos em bases Chebyshev",
                                  "subSteps": [
                                    "Recordar pontos Chebyshev-Lobatto: t_j = -cos(π j / N)",
                                    "Aplicar λ_j = (1/2)^{δ_{j0}+δ_{jN}} / ∏_{m≠j} (t_j - t_m) ajustado",
                                    "Calcular D usando λ: D_{j,k} = λ_k / (λ_j (t_j - t_k)) j≠k",
                                    "Verificar estabilidade numérica para N grande",
                                    "Comparar com pontos equidistantes para Runge phenomenon"
                                  ],
                                  "verification": "Implementar em código simples e plotar derivada de função teste.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy",
                                    "Referência: Trefethen 'Spectral Methods'"
                                  ],
                                  "tips": "Use precisão dupla e evite subtrações catastróficas nos extremos.",
                                  "learningObjective": "Adaptar a fórmula para bases espectrais estáveis.",
                                  "commonMistakes": [
                                    "Usar w_j sem ajuste 1/2 nos extremos",
                                    "Pontos errados para Chebyshev"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Construir e verificar a matriz de diferenciação completa",
                                  "subSteps": [
                                    "Montar matriz D para N=4 pontos Chebyshev",
                                    "Aplicar a D para derivar uma função polinomial conhecida",
                                    "Comparar com derivada analítica",
                                    "Analisar propriedades: skew-symmetric para intervalos simétricos",
                                    "Otimizar computacionalmente (O(N^2))"
                                  ],
                                  "verification": "Erro de derivada < 1e-10 para polinômio de grau < N.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Função teste: sin(x) ou polinômio"
                                  ],
                                  "tips": "Teste com funções suaves para validar precisão espectral.",
                                  "learningObjective": "Construir e validar a matriz D em contexto prático.",
                                  "commonMistakes": [
                                    "Índices off-by-one na matriz",
                                    "Não normalizar intervalos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para N=2 pontos Chebyshev-Lobatto em [-1,1]: t = [-1, 1]. Pesos λ_0=1/2, λ_1=-1/2 (ajustados). D_{0,1} = λ_1 / (λ_0 (t_0 - t_1)) = (-1/2) / ((1/2) * (-1 -1)) = (-1/2)/( (1/2)*(-2) ) = (-1/2)/(-1) = 1/2. D_{1,0} = λ_0 / (λ_1 (t_1 - t_0)) = (1/2)/((-1/2)*(2)) = (1/2)/(-1) = -1/2. Diagonais: D_{00} = -D_{01} = -1/2, D_{11}=-D_{10}=1/2. Matriz D = [[-0.5, 0.5], [ -0.5, 0.5 ]].",
                              "finalVerifications": [
                                "Conseguiu derivar corretamente D_{j,k} para j≠k usando pesos w_j ou λ_j",
                                "Calculou diagonais com soma zero por linha",
                                "Aplicou tratamento especial para extremos Chebyshev sem erros numéricos",
                                "Construiu matriz D 3x3 e verificou com derivada de polinômio",
                                "Identificou diferenças entre pontos equidistantes e Chebyshev",
                                "Implementou em código com erro <1e-12"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática das fórmulas derivadas (100%)",
                                "Precisão numérica na construção da matriz D (erro <1e-10)",
                                "Compreensão de ajustes Chebyshev (fatores 1/2 corretos)",
                                "Eficiência conceitual: O(N^2) sem loops desnecessários",
                                "Validação prática com exemplo numérico",
                                "Explicação clara de propriedades (soma zero, skew-symmetric)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Aplicação em métodos espectrais para EDOs de ondas e difusão",
                                "Computação: Implementação eficiente em NumPy/SciPy para simulações",
                                "Engenharia: Análise de estruturas vibratórias e CFD",
                                "Estatística: Aproximação espectral em regressão não-paramétrica"
                              ],
                              "realWorldApplication": "Construção da matriz de diferenciação é fundamental em métodos pseudoespectrais para resolver EDOs e EDPs em simulações de dinâmica de fluidos (CFD), previsão meteorológica e controle de sistemas aeroespaciais, permitindo alta precisão com poucos pontos nodais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.2.3",
                            "name": "Montagem da matriz D",
                            "description": "Construir a matriz tridiagonal ou esparsa D de dimensão (N+1) x (N+1) com elementos D_{j,k}, incorporando propriedades de precisão espectral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros e pontos de collocation",
                                  "subSteps": [
                                    "Escolha o grau N do polinômio de aproximação (ex: N=4 para matriz 5x5).",
                                    "Calcule os pontos de Chebyshev-Gauss-Lobatto: x_j = cos(π j / N) para j = 0 a N.",
                                    "Liste os pontos x_0, x_1, ..., x_N em ordem crescente ou decrescente conforme convenção.",
                                    "Verifique que x_0 = -1 e x_N = 1.",
                                    "Defina c_j = 2 para j=0,N e 1 caso contrário (pesos de fronteira)."
                                  ],
                                  "verification": "Confirme que os pontos x_j estão corretos e c_j definido, comparando com fórmula padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software (Python/MATLAB)",
                                    "Papel para anotações"
                                  ],
                                  "tips": "Ordene x_j de -1 a 1 para consistência; use precisão dupla.",
                                  "learningObjective": "Compreender a escolha do grid espectral para precisão exponencial.",
                                  "commonMistakes": [
                                    "Pontos lineares em vez de Chebyshev",
                                    "Esquecer c_j para bordas",
                                    "Índices errados de j"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a primeira linha da matriz D (D_{0,k})",
                                  "subSteps": [
                                    "Para k=0: D_{0,0} = (2 N^2 + 1)/6.",
                                    "Para k=1 a N-1: D_{0,k} = (-1)^k * c_k * N / (c_0 (x_0 - x_k) (1 - x_k^2)).",
                                    "Para k=N: D_{0,N} = (2 N^2 - 1)/6.",
                                    "Registre valores com alta precisão.",
                                    "Verifique soma aproximada da linha para consistência."
                                  ],
                                  "verification": "Valores coincidem com fórmulas exatas; teste D_{0,:} * [1,1,...,1]^T ≈ 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software numérico para cálculos precisos",
                                    "Tabela de fórmulas de diferenciação espectral"
                                  ],
                                  "tips": "Use expressões simbólicas se possível para exatidão.",
                                  "learningObjective": "Dominar fórmula da borda esquerda para precisão espectral.",
                                  "commonMistakes": [
                                    "Sinal errado em (-1)^k",
                                    "Inverter c_0 e c_k",
                                    "Denominador zero em x_k = x_0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a última linha da matriz D (D_{N,k})",
                                  "subSteps": [
                                    "Para k=0: D_{N,0} = -(2 N^2 - 1)/6.",
                                    "Para k=1 a N-1: D_{N,k} = (-1)^{k+1} * c_k * N / (c_N (x_N - x_k) (1 - x_k^2)).",
                                    "Para k=N: D_{N,N} = -(2 N^2 + 1)/6.",
                                    "Compare com primeira linha (assimetria esperada).",
                                    "Calcule numericamente para N pequeno."
                                  ],
                                  "verification": "Soma da linha ≈ 0; valores negativos da primeira linha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmos do step anterior",
                                    "Referência: Trefethen 'Spectral Methods in MATLAB'"
                                  ],
                                  "tips": "Note o sinal oposto nas diagonais.",
                                  "learningObjective": "Aplicar fórmula da borda direita, explorando simetria anti-simetria.",
                                  "commonMistakes": [
                                    "Sinal incorreto em (-1)^{k+1}",
                                    "Confundir com primeira linha",
                                    "Erro em c_N"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular elementos internos e montar matriz D",
                                  "subSteps": [
                                    "Para cada j=1 a N-1 e k≠j: D_{j,k} = c_k * [x_k * D_{j,0} - D_{j,N}] / (x_j - x_k).",
                                    "Preencha diagonais: D_{j,j} = - sum_{k≠j} D_{j,k}.",
                                    "Monte matriz completa (N+1)x(N+1), tridiagonal aproximada para baixa ordem mas geralmente densa.",
                                    "Otimize para esparsidade se N grande (armazenamento esparso).",
                                    "Salve em formato matricial."
                                  ],
                                  "verification": "Propriedade global: D * vetor constantes ≈ 0; teste derivada exata em ponto."
                                },
                                "estimatedTime: ",
                                "30 minutos",
                                "materials: [",
                                "Python (NumPy/SciPy)",
                                "MATLAB"
                              ],
                              "tips": "Use normas L2 ou max para erros.",
                              "learningObjective": "Validar precisão espectral da matriz D.",
                              "commonMistakes": [
                                "Função não suave para teste",
                                "Erro numérico em autovalores",
                                "Ignorar fator de escala"
                              ],
                              "stepNumber": 5,
                              "title": "Verificar propriedades de precisão espectral",
                              "subSteps": [
                                "Teste em função suave: u(x)=sin(πx), compute ||u' - D u|| pequeno.",
                                "Cheque autovalores: reais e negativos para estabilidade.",
                                "Confirme tridiagonalidade aproximada ou densidade esperada.",
                                "Analise erro de truncamento exponencial vs N.",
                                "Documente resultados."
                              ],
                              "verification": "Erro < 1e-10 para N=16; autovalores corretos.",
                              "estimatedTime": "20 minutos",
                              "materials": [
                                "Software com solvers lineares",
                                "Funções teste pré-definidas"
                              ]
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.3",
                        "name": "Formulação e Resolução do Sistema de Collocation",
                        "description": "Estabelecer o sistema não-linear de equações resultante da imposição das condições de collocation e resolver utilizando métodos iterativos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.3.1",
                            "name": "Sistema de equações D y = F(y)",
                            "description": "Formular o sistema (D y)_j = f(t_j, y_j) para j = 1, ..., N, com y_0 fixado pela condição inicial y(a) = y_0, onde y = [y_0, y_1, ..., y_N]^T.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os Pontos de Colocação e a Malha Temporal",
                                  "subSteps": [
                                    "Escolha o intervalo [a, b] para a EDO y' = f(t, y) com condição inicial y(a) = y_0.",
                                    "Selecione N pontos de colocação t_j para j=0 a N, onde t_0 = a e t_N = b (ex: pontos de Gauss-Lobatto).",
                                    "Liste os pontos t_j explicitamente para um exemplo simples, como N=3 em [0,1].",
                                    "Verifique que y_0 está fixado em t_0 = a.",
                                    "Desenhe a malha temporal em um gráfico para visualização."
                                  ],
                                  "verification": "Lista correta de t_j e confirmação de t_0 = a com y_0 fixo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora para pontos de Gauss-Lobatto.",
                                  "tips": "Use tabelas padrão de pontos de colocação para polinômios de Legendre ou Chebyshev para evitar cálculos manuais.",
                                  "learningObjective": "Compreender a discretização do domínio temporal via pontos de colocação.",
                                  "commonMistakes": "Confundir t_0 com ponto variável ou escolher pontos inadequados para o método pseudoespectral."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Matriz de Diferenciação D",
                                  "subSteps": [
                                    "Lembre-se que D é a matriz cujos elementos D_{jk} aproximam a derivada do polinômio interpolante em t_j da base em t_k.",
                                    "Calcule as entradas D_{j0} para a primeira coluna (derivadas em t_0).",
                                    "Compute as linhas para j=1 a N usando fórmulas pseudoespectrais (ex: D_{jk} = l_k'(t_j) onde l_k são polinômios de Lagrange).",
                                    "Verifique propriedades: soma das linhas (exceto última) deve ser zero para consistência.",
                                    "Escreva D explicitamente para N pequeno (ex: N=2)."
                                  ],
                                  "verification": "Matriz D simétrica ou com propriedades corretas e derivadas exatas para polinômios de grau <N.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de fórmulas pseudoespectrais, software como MATLAB para verificação opcional.",
                                  "tips": " memorized as fórmulas prontas para pontos de Gauss-Lobatto para agilizar.",
                                  "learningObjective": "Dominar a construção precisa da matriz de diferenciação D.",
                                  "commonMistakes": "Erros nos cálculos de derivadas de Lagrange, especialmente na última linha ou diagonal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar a Condição Inicial e o Vetor y",
                                  "subSteps": [
                                    "Fixe y_0 = y(a) dado pela condição inicial.",
                                    "Defina o vetor y = [y_0, y_1, ..., y_N]^T onde y_j ≈ y(t_j).",
                                    "Escreva F(y) com F_j = f(t_j, y_j) para j=1 a N (note: F_0 não usado).",
                                    "Confirme que o sistema é (D y)_j = f(t_j, y_j) apenas para j=1 a N.",
                                    "Substitua y_0 fixo nas equações iniciais."
                                  ],
                                  "verification": "Vetor y corretamente montado com y_0 fixo e F definido ponto a ponto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para vetor colunar.",
                                  "tips": "Sempre escreva y como coluna para clareza matricial.",
                                  "learningObjective": "Entender como a condição inicial torna o sistema não linear bem-posed.",
                                  "commonMistakes": "Incluir equação para j=0 ou tornar y_0 desconhecido."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular o Sistema Completo Dy = F(y)",
                                  "subSteps": [
                                    "Escreva as N equações: para cada j=1 a N, (D y)_j = f(t_j, y_j).",
                                    "Expanda (D y)_j = sum_{k=0}^N D_{jk} y_k, notando y_0 fixo.",
                                    "Reescreva como sistema de N equações em N incógnitas y_1 a y_N.",
                                    "Verifique se o sistema é Dy = F(y) com D de tamanho N x (N+1), mas ajustado.",
                                    "Teste com uma EDO linear simples para validar."
                                  ],
                                  "verification": "Sistema escrito corretamente como N equações não lineares em y_1,...,y_N.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matriz D do passo 2, exemplo de f(t,y).",
                                  "tips": "Substitua y_0 nas somas para reduzir dimensões explicitamente.",
                                  "learningObjective": "Formular o sistema collocation pseudoespectral completo.",
                                  "commonMistakes": "Esquecer de fixar y_0 ou incluir j=0 no sistema."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Interpretar o Sistema Formulado",
                                  "subSteps": [
                                    "Substitua em um exemplo numérico e compute manualmente para N=1.",
                                    "Confirme ordem de precisão: exata para polinômios de grau <=N.",
                                    "Discuta como resolver: método de Newton para não linearidades.",
                                    "Compare com método espectral global.",
                                    "Anote o sistema em forma matricial compacta."
                                  ],
                                  "verification": "Sistema validado numericamente para caso teste simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora ou Python/MATLAB para verificação numérica.",
                                  "tips": "Use EDO y'=λy para testar estabilidade.",
                                  "learningObjective": "Interpretar e validar a formulação do sistema.",
                                  "commonMistakes": "Ignorar não linearidade implícita em F(y)."
                                }
                              ],
                              "practicalExample": "Para y' = -y em [0,1] com y(0)=1, N=2, pontos Gauss-Lobatto t=[0, 0.5, 1]. Construa D (aprox. [[-1.5, 4, -2.5], [-0.5, 0, 0.5], [2, -4, 2]] ajustado), fixe y0=1, resolva (Dy)_1 = -y1, (Dy)_2 = -y2 para y=[1, y1, y2]^T.",
                              "finalVerifications": [
                                "Pode listar t_j corretamente com t_0=a fixo.",
                                "Constrói D com derivadas exatas para baixos graus.",
                                "Escreve sistema de N equações em y_1 a y_N.",
                                "Valida com exemplo numérico simples.",
                                "Explica por que y_0 é fixo e não parte das incógnitas.",
                                "Confirma consistência com método collocation."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de D (erro <1% em testes).",
                                "Correta fixação de y_0 e redução dimensional.",
                                "Clareza na escrita do sistema Dy=F(y).",
                                "Validação numérica em exemplo.",
                                "Compreensão de não linearidade e resolução.",
                                "Uso correto de notação vetorial."
                              ],
                              "crossCurricularConnections": [
                                "Física: Modelagem de EDOs em dinâmica (ex: osciladores).",
                                "Ciência da Computação: Implementação numérica em Python/MATLAB.",
                                "Engenharia: Simulações de sistemas diferenciais em controle.",
                                "Estatística: Análise de séries temporais aproximadas."
                              ],
                              "realWorldApplication": "Usado em simulações de previsão meteorológica, dinâmica de fluidos (Navier-Stokes discretizados) e controle de robótica, onde alta precisão global é necessária com poucos pontos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.7.4.3.2",
                            "name": "Método de Newton para resolução",
                            "description": "Implementar o método de Newton-Raphson para resolver o sistema não-linear G(y) = D y - F(y) = 0, atualizando y^{m+1} = y^m - J^{-1} G(y^m), onde J é a Jacobiana.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o sistema não-linear e inicializar parâmetros",
                                  "subSteps": [
                                    "Defina as funções G(y) = D y - F(y) e F(y) com base no problema de collocation pseudoespectral.",
                                    "Construa a matriz D (matriz de diferenciação pseudoespectral).",
                                    "Escolha um vetor inicial y^0 apropriado, considerando o domínio do problema.",
                                    "Defina tolerância de convergência (ex: 1e-10) e número máximo de iterações (ex: 100).",
                                    "Implemente funções para avaliar G(y) numericamente."
                                  ],
                                  "verification": "Verifique se G(y^0) é computado corretamente e se os parâmetros iniciais estão definidos sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação do método pseudoespectral, software numérico (Python com NumPy/SciPy ou MATLAB), notas de aula sobre collocation.",
                                  "tips": "Use visualizações iniciais de F(y) para escolher y^0 próximo da solução.",
                                  "learningObjective": "Compreender a formulação do sistema não-linear G(y)=0 no contexto de collocation para EDOs.",
                                  "commonMistakes": "Escolher y^0 muito distante da solução, levando a divergência; confundir D com a matriz de massa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar e implementar a Jacobiana J",
                                  "subSteps": [
                                    "Derive analiticamente a Jacobiana J(y) = D - F'(y), onde F'(y) é a derivada de F.",
                                    "Implemente uma função para calcular J(y^m) em cada iteração.",
                                    "Para eficiência, considere diferenças finitas se derivadas analíticas forem complexas.",
                                    "Teste J computando J * v para um vetor teste v e comparando com definição.",
                                    "Armazene J de forma esparsa se aplicável para grandes sistemas."
                                  ],
                                  "verification": "Aplique J a um vetor conhecido e confirme que o resultado coincide com cálculo direto de definição diferencial.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software numérico com solvers lineares (ex: scipy.linalg.solve), exemplos de Jacobianas de EDOs.",
                                  "tips": "Sempre prefira derivadas analíticas para precisão e velocidade em métodos numéricos.",
                                  "learningObjective": "Dominar o cálculo e implementação da Jacobiana para sistemas não-lineares.",
                                  "commonMistakes": "Erros de sinal na derivada de F(y); não atualizar J a cada iteração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop de iteração do método de Newton",
                                  "subSteps": [
                                    "Inicie loop com m=0.",
                                    "Calcule G(y^m) e J(y^m).",
                                    "Resolva o sistema linear J delta = -G(y^m) para delta.",
                                    "Atualize y^{m+1} = y^m + delta.",
                                    "Monitore a norma ||delta|| ou ||G(y^{m+1})||."
                                  ],
                                  "verification": "Execute uma iteração manual e confirme que y^{1} = y^0 - J^{-1} G(y^0) está correto.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código base de Step 1 e 2, debugger para rastrear iterações.",
                                  "tips": "Use solvers lineares robustos como LU decomposition para J mal-condicionada.",
                                  "learningObjective": "Executar corretamente a iteração Newton-Raphson para convergência quadrática.",
                                  "commonMistakes": "Sinal errado em delta = -J^{-1} G; loop infinito sem critério de parada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar critérios de convergência e validação",
                                  "subSteps": [
                                    "Pare se ||G(y^m)|| < tol ou ||delta|| < tol ou m > max_iter.",
                                    "Registre histórico de resíduos para análise de convergência.",
                                    "Valide solução comparando com solução exata ou método alternativo.",
                                    "Analise taxa de convergência (deve ser ~quadrática perto da solução).",
                                    "Implemente tratamento de falha (ex: reduzir passo ou reiniciar)."
                                  ],
                                  "verification": "Confirme que o loop para com resíduo abaixo da tolerância em problemas teste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos de resíduos (matplotlib), benchmarks com EDOs conhecidas.",
                                  "tips": "Plote log(resíduo) vs iterações para visualizar convergência quadrática.",
                                  "learningObjective": "Garantir robustez e confiabilidade da implementação numérica.",
                                  "commonMistakes": "Tolerância muito frouxa levando a soluções imprecisas; ignorar divergência."
                                }
                              ],
                              "practicalExample": "Para a EDO y' = -y com condição inicial y(0)=1 no intervalo [-1,1] usando 5 pontos de collocation Chebyshev: Construa D (5x5), F(y) baseada na collocation, inicialize y^0=[1,0.5,0,0.5,1], aplique Newton até ||G||<1e-12, obtendo y aproximando [e^{-1}, e^{-0.5},1,e^{-0.5},e^{-1}].",
                              "finalVerifications": [
                                "O resíduo final ||G(y^*)|| < 1e-10.",
                                "A solução satisfaz as condições de contorno da EDO.",
                                "Convergência ocorre em menos de 10 iterações para problemas bem-condicionados.",
                                "Histórico de resíduos mostra decaimento quadrático.",
                                "Solução coincide com método de Runge-Kutta em precisão relativa <1%.",
                                "Jacobiana é invertível (determinante não-zero ou solver converge)."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: atualização y^{m+1} = y^m - J^{-1} G(y^m) implementada precisamente.",
                                "Eficiência computacional: uso de solvers lineares otimizados e Jacobiana atualizada corretamente.",
                                "Robustez: tratamento de não-convergência e escolha inicial sensível.",
                                "Precisão numérica: erro relativo <1e-8 comparado a referências.",
                                "Documentação: código comentado explicando cada componente.",
                                "Testes: unit tests para G, J e uma iteração completa."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB reforça habilidades de computação científica.",
                                "Física: Aplicação em simulações de EDOs modelando oscilações ou difusão.",
                                "Engenharia: Otimização não-linear em controle de sistemas dinâmicos.",
                                "Estatística: Análise de sensibilidade e erros numéricos."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais, o método resolve sistemas não-lineares de collocation para trajetórias de satélites ou fluxos turbulentos em CFD, permitindo predições precisas de órbitas ou perfis de velocidade com alta eficiência computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.3.3",
                            "name": "Cálculo da Jacobiana",
                            "description": "Computar a matriz Jacobiana J_{j,k} = ∂G_j / ∂y_k ≈ δ_{j,k} D_{j,k} - ∂f/∂y (t_j, y_j) para sistemas autônomos ou não-lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação do sistema de colocation em métodos pseudoespectrais",
                                  "subSteps": [
                                    "Lembre-se da aproximação pseudoespectral para EDOs: y(t) ≈ ∑ y_k φ_k(t), onde φ_k são base polinomial (ex: Lagrange).",
                                    "Defina os pontos de colocation t_j e o resíduo G_j = y'(t_j) - f(t_j, y(t_j)) ≈ 0.",
                                    "Expresse G_j em termos das variáveis y_k: G_j = ∑_k D_{j,k} y_k - f(t_j, ∑_k y_k φ_k(t_j)).",
                                    "Identifique as dependências: G depende explicitamente de y através da aproximação polinomial e de f.",
                                    "Anote a equação do sistema não-linear G(y) = 0 para N pontos de colocation."
                                  ],
                                  "verification": "Escreva corretamente a expressão de G_j em função de y_k e confirme que forma um sistema de N equações em N incógnitas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referência ao algoritmo pseudoespectral (notas de aula)",
                                    "Software como MATLAB ou Python (opcional)"
                                  ],
                                  "tips": "Desenhe um diagrama mostrando pontos t_j, base φ_k e como y(t_j) é interpolado.",
                                  "learningObjective": "Compreender a estrutura do sistema G(y)=0 e suas dependências em y.",
                                  "commonMistakes": "Confundir pontos de colocation com nós de Gauss-Lobatto; esquecer a aproximação da derivada via matriz D."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a forma geral da Jacobiana ∂G_j / ∂y_k",
                                  "subSteps": [
                                    "Parta da expressão G_j = ∑_m D_{j,m} y_m - f(t_j, y(t_j)), onde y(t_j) = ∑_k y_k l_k(t_j) (polinômios de Lagrange).",
                                    "Calcule a derivada parcial: ∂G_j / ∂y_k = ∂/∂y_k [∑_m D_{j,m} y_m] - ∂/∂y_k [f(t_j, y(t_j))].",
                                    "O primeiro termo é D_{j,k}, pois δ_{j,m} só quando m=k.",
                                    "O segundo termo: ∂f/∂y * ∂y(t_j)/∂y_k = [∂f/∂y](t_j, y(t_j)) * l_k(t_j), onde l_k são os polinômios de Lagrange.",
                                    "Escreva a fórmula exata: ∂G_j / ∂y_k = D_{j,k} - [∂f/∂y](t_j, y(t_j)) * l_k(t_j)."
                                  ],
                                  "verification": "Derive e escreva a fórmula exata de ∂G_j / ∂y_k, verificando dimensões (NxN).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Cálculo diferencial (livro ou notas)",
                                    "Papel para derivadas simbólicas",
                                    "SymPy (Python) para verificação simbólica opcional"
                                  ],
                                  "tips": "Use notação de cadeia para o termo de f; lembre que l_k(t_j) = δ_{k,j} nos pontos de colocation.",
                                  "learningObjective": "Dominar a derivação analítica da Jacobiana do sistema de colocation.",
                                  "commonMistakes": "Esquecer o fator l_k(t_j) no termo de f; confundir derivada de y(t_j) com identidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aproximar a Jacobiana usando a aproximação δ_{j,k} para sistemas autônomos ou não-lineares",
                                  "subSteps": [
                                    "Note que nos pontos de colocation, l_k(t_j) ≈ δ_{j,k}, pois a interpolação é exata nos nós.",
                                    "Aproxime ∂G_j / ∂y_k ≈ δ_{j,k} D_{j,k} - [∂f/∂y](t_j, y_j), onde y_j = y(t_j).",
                                    "Justifique a aproximação: para alto ordem polinomial, δ_{j,k} é boa approx fora da diagonal, mas exata na diagonal.",
                                    "Discuta quando usar: ideal para f não-linear onde computar l_k é custoso.",
                                    "Compare com a fórmula exata: a approx simplifica montagem da matriz J."
                                  ],
                                  "verification": "Escreva a fórmula aproximada e explique por que δ_{j,k} D_{j,k} = D_{j,k} na diagonal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz D pré-computada para N=5 (exemplo)",
                                    "Gráfico de l_k(t_j) para visualizar approx"
                                  ],
                                  "tips": "Teste com N pequeno: compute l_k(t_j) numericamente para validar δ approx.",
                                  "learningObjective": "Entender e justificar a aproximação prática da Jacobiana.",
                                  "commonMistakes": "Aplicar approx sem justificar; ignorar que é δ_{j,k} * D_{j,k}, que é D_{j,j} na diagonal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar ∂f/∂y nos pontos e montar a matriz Jacobiana completa",
                                  "subSteps": [
                                    "Para cada j=1..N, compute [∂f/∂y](t_j, y_j) analiticamente se possível, ou numericamente (diferenças finitas).",
                                    "Construa J como matriz diagonal com D_{j,j} - ∂f/∂y_j na diagonal? Não: J_{j,k} = δ_{j,k} D_{j,k} - ∂f/∂y_j * δ_{j,k}? Espere, fórmula é δ_{j,k} D_{j,k} - ∂f/∂y (t_j,y_j), implicando J diagonal se D diagonal, mas D não é.",
                                    "Clarifique: a approx é J_{j,k} ≈ δ_{j,k} D_{j,k} - ∂f/∂y_j, o que faz J = diag(D_{jj}) - diag(∂f/∂y_j), mas verifique lit: na verdade para collocation, é J_{j,k} = D_{j,k} - ∂f/∂y_j * δ_{j,k}.",
                                    "Corrija pela lit padrão: em pseudoespectral, approx comum é J_{j,k} = D_{j,k} δ_{j,k}? Não, fórmula dada é ≈ δ_{j,k} D_{j,k} - ∂f/∂y, mas δ D é zero off-diagonal.",
                                    "Assuma fórmula como dada: monte J com termo Kronecker δ_{j,k} D_{j,k} (diagonal de D) menos ∂f/∂y na diagonal, mas tipicamente é J = D - F, onde F_{j,k} = δ_{j,k} ∂f/∂y_j.",
                                    "Implemente em código: crie matriz J zerada, adicione δ D - ∂f δ.",
                                    "Verifique simetria ou propriedades para sistemas autônomos."
                                  ],
                                  "verification": "Monte J para um exemplo pequeno e resolva Gy=0 com Newton para checar convergência.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python/MATLAB com NumPy/SciPy",
                                    "Exemplo de EDO: y'=y(1-y)",
                                    "Matriz D para Legendre-Gauss-Lobatto"
                                  ],
                                  "tips": "Use loop sobre j,k: if j==k: J[j,k] = D[j,k] - dfdy(tj,yj)",
                                  "learningObjective": "Implementar computacionalmente a Jacobiana aproximada.",
                                  "commonMistakes": "Confundir índices j,k; usar ∂f/∂y errada (analítica vs numérica); matriz não quadrada."
                                }
                              ],
                              "practicalExample": "Para o EDO não-linear y' = y(1 - y), t em [0,1], N=4 pontos Gauss-Lobatto. Compute D (matriz diff), y approx inicial, df/dy = 1 - 2y em tj,yj. Monte J_{j,k} = δ_{j,k} D_{j,k} - (1-2 y_j) δ_{j,k}. Use Newton para resolver G(y)=0 e plote solução vs exata y=(1+e^{-t})^{-1}.",
                              "finalVerifications": [
                                "Deriva corretamente a fórmula exata e aproximada de J.",
                                "Implementa código que monta J corretamente para N=5.",
                                "Verifica que ||J - J_exata|| < 1e-6 para approx.",
                                "Usa J em um passo de Newton-Raphson e observa convergência.",
                                "Explica limitação da approx para baixas ordens N.",
                                "Compara com solver built-in (ode45) para validar."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação analítica (fórmula correta).",
                                "Correção da implementação numérica (erro <1%).",
                                "Eficiência computacional (O(N^2) montagem).",
                                "Validação com exemplo concreto (convergência Newton).",
                                "Compreensão de approx (erro vs N).",
                                "Uso apropriado de ∂f/∂y analítica/numérica."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações dinâmicas em mecânica orbital (NASA usa pseudoespectral).",
                                "Engenharia: Controle ótimo de sistemas não-lineares (aeroespacial).",
                                "Computação: Algoritmos de álgebra linear e otimização numérica.",
                                "Química: Modelagem de reações cinéticas com EDOs rígidas.",
                                "Economia: Equilíbrios em modelos dinâmicos não-lineares."
                              ],
                              "realWorldApplication": "Essencial em solvers avançados como GPOPS-II para otimização de trajetórias em foguetes (NASA), simulações climáticas com EDOs não-lineares, e controle autônomo de veículos (drones), onde Jacobiana acelera convergência de métodos de Newton em problemas de grande escala."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.3.2"
                            ]
                          },
                          {
                            "id": "10.1.7.4.3.4",
                            "name": "Critérios de convergência e parada",
                            "description": "Definir tolerâncias para o resíduo ||G(y)|| < tol e número máximo de iterações, avaliando a solução obtida nos pontos nodais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Resíduo G(y) no Contexto Pseudoespectral",
                                  "subSteps": [
                                    "Revise a formulação do sistema de colocation: G(y) = 0 representa as condições de colocation nos pontos nodais.",
                                    "Calcule o resíduo ||G(y)|| como a norma euclidiana ou máxima dos componentes de G(y).",
                                    "Analise como ||G(y)|| mede o erro de satisfação das equações diferenciais nos pontos nodais.",
                                    "Compare ||G(y)|| com soluções exatas conhecidas para EDOs simples para validar o conceito.",
                                    "Discuta o significado de convergência: ||G(y)|| → 0 implica solução aproximada precisa."
                                  ],
                                  "verification": "Escreva uma definição clara do resíduo e compute ||G(y)|| para um exemplo simples, confirmando que está abaixo de 1e-6.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre métodos pseudoespectrais, calculadora ou Python/MATLAB para protótipo simples.",
                                  "tips": "Use normas L2 ou L∞ consistentemente; visualize ||G(y)|| graficamente para intuição.",
                                  "learningObjective": "Explicar o papel do resíduo G(y) na avaliação de convergência de soluções pseudoespectrais.",
                                  "commonMistakes": "Confundir resíduo com erro global da solução; ignorar normalização da norma."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Tolerâncias Apropriadas para o Resíduo",
                                  "subSteps": [
                                    "Estude fatores influenciando tol: precisão desejada, condição da matriz, ruído numérico.",
                                    "Escolha tol inicial como 1e-6 a 1e-12, baseado na precisão da máquina (eps ≈ 2e-16).",
                                    "Teste sensibilidade: resolva uma EDO de teste variando tol e observe impacto na solução.",
                                    "Documente justificativa para tol escolhida, considerando estabilidade e custo computacional.",
                                    "Ajuste tol adaptativamente se necessário, usando critérios como redução relativa."
                                  ],
                                  "verification": "Crie uma tabela com diferentes tol e meça tempo de convergência e erro para uma EDO padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software numérico (Python com NumPy/SciPy ou MATLAB), EDO de teste como y' = -y.",
                                  "tips": "Comece com tol conservadora (1e-8) e refine; monitore overflow/underflow.",
                                  "learningObjective": "Selecionar e justificar tolerâncias tol para ||G(y)|| baseadas em contexto do problema.",
                                  "commonMistakes": "Escolher tol muito pequeno levando a não-convergência; tol muito grande aceitando soluções ruins."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Critérios de Parada Baseados em Iterações e Resíduo",
                                  "subSteps": [
                                    "Defina maxIter como 100-1000, baseado em ordem do método e complexidade da EDO.",
                                    "Implemente loop: while ||G(y)|| >= tol and iter < maxIter: resolva sistema linear.",
                                    "Registre histórico de ||G(y)|| por iteração para diagnosticar estagnação.",
                                    "Adicione critério de redução relativa: ||G(y_k)|| / ||G(y_{k-1})|| < gamma (ex: 0.9).",
                                    "Teste o algoritmo completo em código para uma EDO não-linear simples."
                                  ],
                                  "verification": "Execute código com logs de iterações e confirme parada correta (por tol ou maxIter).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (Jupyter Notebook ou MATLAB script), biblioteca para solvers lineares (SciPy.sparse.linalg).",
                                  "tips": "Use warm-start: inicialize y_{k+1} com y_k para aceleração.",
                                  "learningObjective": "Codificar critérios de parada combinando resíduo e limite de iterações.",
                                  "commonMistakes": "Loop infinito por tol irrealista; não resetar contador de iterações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar a Solução Obtida nos Pontos Nodais",
                                  "subSteps": [
                                    "Extraia solução y nos pontos nodais (Gauss-Lobatto ou Chebyshev).",
                                    "Compute métricas: erro nos nodais vs. solução exata, condição do Jacobiano.",
                                    "Visualize solução interpolada e compare com referência.",
                                    "Analise pós-convergência: verifique consistência com condições de contorno iniciais.",
                                    "Gere relatório: iterações usadas, tol final alcançada, qualidade da solução."
                                  ],
                                  "verification": "Produza gráfico de y nodal vs. exata com erro < 1e-5; relatório escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Matplotlib ou MATLAB), solução exata da EDO de teste.",
                                  "tips": "Use interpolação espectral para avaliação em malha fina.",
                                  "learningObjective": "Validar e interpretar a solução pseudoespectral pós-convergência nos nodais.",
                                  "commonMistakes": "Avaliar apenas em nodais sem interpolação; ignorar oscilações espectrais (Gibbs)."
                                }
                              ],
                              "practicalExample": "Para a EDO y' = -y com y(0)=1 em [0,1], use 10 pontos Gauss-Lobatto. Defina tol=1e-10, maxIter=200. Inicialize y=1, resolva G(y)=0 iterativamente via Newton. Pare quando ||G(y)||<tol após ~15 iterações, avaliando y nos nodais contra y_exata=exp(-t).",
                              "finalVerifications": [
                                "||G(y)|| final < tol especificada.",
                                "Número de iterações ≤ maxIter.",
                                "Erro nos pontos nodais < 1e-5 vs. solução exata.",
                                "Histórico de resíduo mostra redução monotônica.",
                                "Solução satisfaz condições iniciais/finais nos nodais.",
                                "Jacobiano final bem-condicionado (cond < 1e12)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de resíduo e normas (90% correção).",
                                "Escolha justificada de tol e maxIter (com testes).",
                                "Implementação funcional do algoritmo de parada.",
                                "Avaliação completa nos nodais com métricas quantitativas.",
                                "Relatório claro com gráficos e conclusões.",
                                "Tratamento de casos edge (não-convergência)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/MATLAB para solvers iterativos.",
                                "Física: Simulações de EDOs em dinâmica (ex: pêndulo).",
                                "Engenharia Computacional: Otimização em controle ótimo.",
                                "Estatística: Análise de erro e tolerâncias numéricas."
                              ],
                              "realWorldApplication": "Em simulações aeroespaciais, define convergência para trajetórias de satélites resolvendo EDOs orbitais via pseudoespectral, garantindo precisão em missões da NASA com tol=1e-12 para evitar erros cumulativos em longas simulações."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.5",
                    "name": "Aplicação a Problemas com Condições de Contorno",
                    "description": "Adaptação dos métodos para condições periódicas e limitações em problemas não-periódicos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.5.1",
                        "name": "Adaptação dos Métodos Pseudoespectrais para Condições Periódicas",
                        "description": "Os métodos pseudoespectrais baseados em séries de Fourier são naturalmente adaptados para problemas com condições de contorno periódicas, permitindo aproximações espectrais eficientes e precisão exponencial para funções suaves e periódicas, com derivação via multiplicação por fatores ik no espaço de frequências.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.1.1",
                            "name": "Identificar problemas com condições periódicas adequados",
                            "description": "Reconhecer equações diferenciais (EDOs ou EDPs) onde as soluções e derivadas são contínuas e periódicas, justificando a escolha de métodos pseudoespectrais de Fourier para alta precisão com poucos graus de liberdade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de periodicidade em soluções de equações diferenciais",
                                  "subSteps": [
                                    "Defina periodicidade em funções: uma função f(x) é periódica com período T se f(x + T) = f(x) para todo x.",
                                    "Explique a importância da continuidade das soluções e suas derivadas em contextos numéricos.",
                                    "Identifique exemplos clássicos de EDOs/EDPs com soluções periódicas, como a equação da onda ou o oscilador harmônico.",
                                    "Discuta como condições de contorno periódicas (ex.: u(0) = u(L), u'(0) = u'(L)) garantem periodicidade.",
                                    "Revise propriedades de Fourier: bases senos/cossenos capturam periodicidade naturalmente."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre funções periódicas e não-periódicas, citando um exemplo de cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (capítulo sobre EDOs), calculadora gráfica, software MATLAB/Octave para plotar funções periódicas"
                                  ],
                                  "tips": "Visualize funções periódicas plotando sin(x) e cos(x) para internalizar o conceito.",
                                  "learningObjective": "Dominar definições e exemplos básicos de periodicidade em soluções diferenciais.",
                                  "commonMistakes": [
                                    "Confundir periodicidade com boundedness; ignorar derivadas na continuidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer equações diferenciais com soluções contínuas e periódicas",
                                  "subSteps": [
                                    "Analise EDOs como u'' + u = 0 com condições u(0)=u(2π), u'(0)=u'(2π), verificando solução u=sin(x) ou cos(x).",
                                    "Examine EDPs como a equação do calor com condições periódicas: u_t = u_xx, u(x+2π,t)=u(x,t).",
                                    "Classifique problemas: liste 3 EDOs/EDPs periódicos vs. 3 com condições Dirichlet/Neumann.",
                                    "Verifique continuidade: solucione analiticamente e confirme que derivadas são contínuas no período.",
                                    "Pratique identificação: dado uma EDO, determine se admite solução periódica contínua."
                                  ],
                                  "verification": "Identifique corretamente periodicidade em 5 equações dadas, justificando com condições de contorno.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folhas de exercícios com EDOs/EDPs, Wolfram Alpha para soluções analíticas, notebook Jupyter"
                                  ],
                                  "tips": "Sempre cheque condições de contorno primeiro; elas ditam a periodicidade.",
                                  "learningObjective": "Habilidade para detectar EDOs/EDPs candidatas a soluções periódicas contínuas.",
                                  "commonMistakes": [
                                    "Assumir periodicidade sem verificar derivadas; confundir soluções oscilatórias com periódicas exatas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Justificar adequação de métodos pseudoespectrais de Fourier",
                                  "subSteps": [
                                    "Explique spectral bias: métodos de Fourier convergem exponencialmente para funções suaves/periódicas.",
                                    "Compare graus de liberdade: Fourier usa N modos para precisão alta vs. finitos diferenças (ordem 2).",
                                    "Discuta truncamento de séries de Fourier: poucos termos para soluções analíticas periódicas.",
                                    "Simule numericamente: resolva uma EDO periódica com Fourier e meça erro vs. N.",
                                    "Avalie limitações: só para problemas periódicos; Gibbs para descontinuidades."
                                  ],
                                  "verification": "Escreva uma justificativa de 200 palavras para usar Fourier em um problema periódico específico.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código MATLAB para pseudoespectral Fourier, tutoriais online (ex.: Chebfun), papel e lápis para derivações"
                                  ],
                                  "tips": "Foquem em taxa de convergência: plot erro log vs. log(N) para ver exponencial.",
                                  "learningObjective": "Entender vantagens numéricas de Fourier para problemas periódicos.",
                                  "commonMistakes": [
                                    "Ignorar custo computacional; aplicar Fourier a problemas não-periódicos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar identificação em problemas reais e sintetizar conhecimento",
                                  "subSteps": [
                                    "Selecione problemas da literatura: ex. fluxo de Couette periódico ou ondas em anel.",
                                    "Crie fluxograma: 'Condições periódicas? Solução suave? -> Fourier sim'.",
                                    "Debata casos borderline: soluções quase-periódicas ou com forçantes periódicas.",
                                    "Teste com software: implemente um solver Fourier para validar identificação.",
                                    "Documente portfolio: 3 problemas identificados com justificativas."
                                  ],
                                  "verification": "Crie e apresente um fluxograma funcional para classificação de problemas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Artigos científicos (ex. sobre EDPs periódicas), Python com NumPy/FFT, gravador de tela para demo"
                                  ],
                                  "tips": "Use analogias físicas: ondas em corda infinita simulam periodicidade.",
                                  "learningObjective": "Sintetizar identificação e justificativa em workflow acionável.",
                                  "commonMistakes": [
                                    "Superestimar aplicabilidade; não considerar estabilidade numérica."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a EDO u'' + k² u = 0 com condições periódicas u(0)=u(2π), u'(0)=u'(2π). Solução u(x)=A cos(kx)+B sin(kx) é periódica e suave se k inteiro. Use Fourier: expanda em bases e^{i n x}, resolvendo sistema com poucos N=10 modos para erro <10^{-10}.",
                              "finalVerifications": [
                                "Classifica corretamente 80% de 10 EDOs/EDPs como periódicas ou não.",
                                "Justifica uso de Fourier com argumentos de convergência e DOFs.",
                                "Identifica continuidade de soluções/derivadas em exemplos dados.",
                                "Cria fluxograma preciso para triagem de problemas.",
                                "Simula um problema periódico com precisão espectral.",
                                "Discute limitações em casos não-ideais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e exemplos corretos (30%)",
                                "Profundidade de justificativa: convergência e eficiência numérica (25%)",
                                "Aplicação prática: identificação em novos problemas (20%)",
                                "Clareza de comunicação: fluxogramas e resumos (15%)",
                                "Criatividade: conexões com exemplos reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de ondas e vibrações periódicas",
                                "Engenharia: Simulações CFD com domínios periódicos",
                                "Computação Científica: Otimização de solvers FFT",
                                "Física Computacional: Modelagem de cristais e materiais periódicos"
                              ],
                              "realWorldApplication": "Em simulações climáticas, identificar periodicidade em equações de ondas atmosféricas permite usar Fourier para prever padrões sazonais com alta precisão e baixo custo computacional, essencial para modelos globais em supercomputadores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.2",
                            "name": "Implementar expansão de Fourier para aproximação periódica",
                            "description": "Construir a transformada discreta de Fourier (DFT) de uma função periódica discretizada em pontos equidistantes, computando coeficientes espectrais e reconstruindo a solução via transformada inversa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Discretizar a função periódica em pontos equidistantes",
                                  "subSteps": [
                                    "Definir o período fundamental T da função periódica (ex: T=2π).",
                                    "Escolher o número de pontos N (potência de 2 para eficiência, N≥16).",
                                    "Gerar o grid espacial x_k = 2π k / N para k=0 a N-1.",
                                    "Avaliar a função f em x_k, armazenando em vetor f (complexo se necessário).",
                                    "Verificar periodicidade: f[0] ≈ f[N] ajustando se preciso."
                                  ],
                                  "verification": "Plotar f vs x_k e confirmar visualmente a forma periódica sem saltos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Use np.linspace(0, 2*np.pi, N, endpoint=False) para grid uniforme e periódico.",
                                  "learningObjective": "Compreender a discretização de funções periódicas para métodos espectrais.",
                                  "commonMistakes": [
                                    "Incluir endpoint=True causando duplicação",
                                    "N ímpar levando a assimetria",
                                    "Ignorar natureza complexa da função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar a Transformada Discreta de Fourier (DFT)",
                                  "subSteps": [
                                    "Implementar a fórmula da DFT: c_k = (1/N) ∑_{j=0}^{N-1} f_j exp(-2π i j k / N) para k=0 a N-1.",
                                    "Usar loop ou vetorização NumPy para somas complexas.",
                                    "Armazenar coeficientes em vetor c (c[0] é média, c[N/2] Nyquist).",
                                    "Normalizar corretamente pelo fator 1/N.",
                                    "Plotar espectro |c_k| vs k para visualizar componentes dominantes."
                                  ],
                                  "verification": "Comparar c_0 com média de f; para seno puro, apenas c_{N/4} e c_{3N/4} não-zero.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NumPy (np.exp, np.fft se para referência)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Vetorize com meshgrid ou broadcasting para evitar loops lentos.",
                                  "learningObjective": "Dominar o cálculo de coeficientes espectrais via DFT.",
                                  "commonMistakes": [
                                    "Esquecer o 1/N",
                                    "Índices errados em exp (sinal negativo)",
                                    "Confundir DFT com FFT otimizada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconstruir a função via Transformada Inversa Discreta de Fourier (IDFT)",
                                  "subSteps": [
                                    "Implementar IDFT: f_rec_j = ∑_{k=0}^{N-1} c_k exp(2π i j k / N) para j=0 a N-1.",
                                    "Usar os coeficientes c_k computados anteriormente.",
                                    "Armazenar em vetor f_rec e comparar com f original.",
                                    "Calcular erro: RMSE = sqrt( mean( |f - f_rec|^2 ) ).",
                                    "Ajustar truncamento de modos altos se N pequeno."
                                  ],
                                  "verification": "RMSE < 1e-10 para N grande; plot f vs f_rec sobreposto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NumPy",
                                    "Matplotlib para plots de erro"
                                  ],
                                  "tips": "Note ausência de 1/N na IDFT; teste com np.fft.ifft para validação.",
                                  "learningObjective": "Aplicar síntese espectral para reconstrução periódica.",
                                  "commonMistakes": [
                                    "Sinal errado no exponencial (deve ser +)",
                                    "Não truncar modos espúrios",
                                    "Erro de escala na reconstrução"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e validar a aproximação periódica",
                                  "subSteps": [
                                    "Comparar espectros: plot |c_k| e confirmar decay para função suave.",
                                    "Testar convergência variando N (16,32,64).",
                                    "Aplicar filtro espectral (zero c_k para |k|>K).",
                                    "Documentar código com comentários e função reutilizável.",
                                    "Exportar resultados para relatório (plots, tabela erros)."
                                  ],
                                  "verification": "Erro diminui com N; reconstrução fiel visualmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matplotlib",
                                    "Pandas para tabelas"
                                  ],
                                  "tips": "Use np.fft para benchmark rápido da implementação manual.",
                                  "learningObjective": "Avaliar precisão e convergência da expansão de Fourier.",
                                  "commonMistakes": [
                                    "Não testar múltiplos N",
                                    "Ignorar aliasing em funções não-suaves",
                                    "Plots sem legendas"
                                  ]
                                }
                              ],
                              "practicalExample": "Discretize f(x) = sen(x) + 0.5 sen(3x) em N=64 pontos no [0,2π), compute DFT (picos em k=1,3,N-1,N-3), reconstrua via IDFT e verifique RMSE≈0.",
                              "finalVerifications": [
                                "Coeficientes c_k corretos para função teste conhecida.",
                                "Reconstrução f_rec idêntica a f original (RMSE < 1e-12).",
                                "Espectro simétrico para funções reais (|c_k| = |c_{N-k}|).",
                                "Convergência exponencial do erro com N.",
                                "Código roda em <1s para N=1024.",
                                "Plots mostram periodicidade perfeita sem Gibbs."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta de DFT/IDFT sem bibliotecas prontas.",
                                "Código limpo, comentado e modular (funções separadas).",
                                "Análise de erros quantitativa e qualitativa.",
                                "Uso eficiente de NumPy (vetorizado).",
                                "Validação com múltiplos exemplos e N.",
                                "Relatório com plots profissionais."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais Digitais (áudio/imagem).",
                                "Física (análise de ondas e vibrações periódicas).",
                                "Engenharia Elétrica (filtros e modulação).",
                                "Ciência de Dados (análise espectral de séries temporais).",
                                "Computação Científica (métodos numéricos paralelizáveis)."
                              ],
                              "realWorldApplication": "Análise espectral em processamento de áudio (identificação de notas musicais), compressão de imagens periódicas (JPEG), simulações de fluidos em domínios periódicos (turbulência), detecção de falhas em sinais mecânicos rotativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.3",
                            "name": "Aplicar diferenciação espectral em condições periódicas",
                            "description": "Calcular derivadas de ordem arbitrária multiplicando os coeficientes de Fourier por (ik)^m no espaço espectral, garantindo precisão espectral sem perda de informação para problemas periódicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar a função periódica no espaço espectral",
                                  "subSteps": [
                                    "Escolha uma função periódica teste, como f(x) = cos(2πkx), com período em [0,1].",
                                    "Discretize o domínio em N pontos uniformes (N par, ex: 64 ou 128).",
                                    "Aplique a Transformada de Fourier Discreta (DFT) para obter coeficientes â_{k}.",
                                    "Verifique a simetria dos coeficientes para funções reais (conjugar simetria).",
                                    "Confirme que a soma dos coeficientes recupera a função original via IDFT."
                                  ],
                                  "verification": "A reconstrução via IDFT deve coincidir com f(x) original com erro < 1e-12.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy e SciPy (fft module)",
                                    "Jupyter Notebook",
                                    "Função periódica de teste"
                                  ],
                                  "tips": "Use fft.fftn para eficiência e normalize corretamente com 1/N na IDFT.",
                                  "learningObjective": "Dominar a transformação de funções periódicas para o domínio de Fourier discreto.",
                                  "commonMistakes": [
                                    "Escolha de N ímpar causando aliasing",
                                    "Não tratar periodicidade estrita da função",
                                    "Esquecimento da normalização na DFT"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o operador de diferenciação espectral",
                                  "subSteps": [
                                    "Defina a ordem da derivada m (ex: m=1 para primeira derivada).",
                                    "Calcule os wavenumbers k = [-N/2 : N/2-1] * 2π (shift para frequências centradas).",
                                    "Compute os fatores de diferenciação (i k)^m para cada k, usando np.fft.fftshift.",
                                    "Multiplique os coeficientes â_{k} pelos fatores (i k)^m elemento a elemento.",
                                    "Trate o modo k=0 (derivada zero) e evite divisão por zero."
                                  ],
                                  "verification": "Os novos coeficientes devem manter a estrutura simétrica para funções reais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python do Step 1",
                                    "Documentação NumPy para fftfreq e fftshift"
                                  ],
                                  "tips": "Use complexos numpy para i = 1j; teste com m=1 onde derivada de cos é -sin.",
                                  "learningObjective": "Compreender e implementar a multiplicação exata por (i k)^m no espaço espectral.",
                                  "commonMistakes": [
                                    "Erro no shift de frequências (k não centrado)",
                                    "Confusão entre k positivo/negativo",
                                    "Não usar potências complexas corretas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconstruir a derivada no espaço físico via IDFT",
                                  "subSteps": [
                                    "Aplique a Transformada de Fourier Inversa Discreta (IDFT) nos coeficientes diferenciados.",
                                    "Plote a derivada numérica ao lado da derivada analítica exata.",
                                    "Calcule o erro em norma L2: sqrt(∫ (num - analítica)^2 dx).",
                                    "Verifique a periodicidade: derivada[0] ≈ derivada[-1].",
                                    "Teste para diferentes ordens m (1,2,3) e resoluções N."
                                  ],
                                  "verification": "Erro L2 < 1e-10 para N=64 e função suave.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Funções analíticas de teste (np.cos, np.sin)"
                                  ],
                                  "tips": "Use ifft.ifftn e fftshift para alinhamento correto dos plots.",
                                  "learningObjective": "Executar a inversão espectral e visualizar resultados precisos.",
                                  "commonMistakes": [
                                    "Esquecimento do fftshift na reconstrução",
                                    "Normalização errada na IDFT",
                                    "Comparação com função errada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar precisão espectral e condições periódicas",
                                  "subSteps": [
                                    "Compare precisão para diferentes N e observe convergência espectral (exponencial).",
                                    "Teste com funções não suaves (ex: sawtooth periódica) e analise Gibbs.",
                                    "Verifique conservação de energia espectral para m par/ímpar.",
                                    "Documente o processo em um relatório com plots e erros.",
                                    "Adapte para condições de contorno periódicas em PDEs simples."
                                  ],
                                  "verification": "Relatório mostra erro decaindo exponencialmente com N.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Códigos anteriores",
                                    "LaTeX ou Markdown para relatório"
                                  ],
                                  "tips": "Para precisão máxima, use tipos float64 e evite truncamento.",
                                  "learningObjective": "Avaliar e validar a precisão sem perda de informação em domínios periódicos.",
                                  "commonMistakes": [
                                    "Ignorar efeitos de aliasing em altas frequências",
                                    "Não testar múltiplas ordens m",
                                    "Confundir precisão espectral com finita diferenças"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule a terceira derivada de f(x) = sin(2πx) + 0.5*cos(4πx) em [0,1] com N=128 pontos. Espere derivada exata: (2π)^3 [-cos(2πx) + 0.5*(-1)^3 sin(4πx)]. Verifique erro L2 < 1e-12.",
                              "finalVerifications": [
                                "Erro L2 entre derivada numérica e analítica < 1e-10 para N=64.",
                                "Periodicidade confirmada: f'(0) = f'(1) com tolerância 1e-12.",
                                "Convergência espectral: erro diminui exponencialmente com log(N).",
                                "Coeficientes de alta frequência decaem corretamente para funções suaves.",
                                "Conservação de propriedades (ex: integral da derivada ímpar = 0).",
                                "Teste bem-sucedido para m=1,2,3 sem instabilidades."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta da multiplicação por (i k)^m sem erros de indexação.",
                                "Precisão espectral demonstrada com erros < 1e-10 em exemplos padrão.",
                                "Código reproduzível e comentado, com plots comparativos.",
                                "Análise de erros e convergência incluída no relatório.",
                                "Adaptação bem-sucedida a funções teste variadas e ordens m.",
                                "Compreensão verbal da vantagem sobre métodos de diferenças finitas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Solução de equações de onda e difusão periódicas via pseudoespectrais.",
                                "Engenharia Computacional: Simulações DNS de turbulência em caixas periódicas.",
                                "Processamento de Sinais: Filtragem espectral em dados periódicos.",
                                "Matemática Aplicada: Análise de Fourier para PDEs elípticas periódicas."
                              ],
                              "realWorldApplication": "Em simulações numéricas de dinâmica de fluidos (ex: turbulência homogênea isotrópica em domínios periódicos), onde diferenciação espectral permite resolver equações de Navier-Stokes com precisão exponencial e sem dissipação numérica artificial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.4",
                            "name": "Resolver problemas de valor inicial periódicos",
                            "description": "Integrar no tempo problemas de valor inicial (PVI) com condições periódicas usando métodos pseudoespectrais, combinando diferenciação espectral com integradores como Runge-Kutta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Problema de Valor Inicial Periódico",
                                  "subSteps": [
                                    "Defina o domínio espacial periódico, tipicamente [0, 2π] com condições u(0,t) = u(2π,t).",
                                    "Especifique a equação diferencial ordinária ou parcial no tempo, como du/dt = f(u) com u(0) dado.",
                                    "Verifique a periodicidade da solução inicial e das funções envolvidas.",
                                    "Escolha o número de modos espectrais N (ex: 64 ou 128 pontos de collocation).",
                                    "Transforme os dados para o espaço de Fourier usando FFT."
                                  ],
                                  "verification": "Confirme que a transformada de Fourier da solução inicial é real para funções reais e periódicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook com Python/NumPy/SciPy, documentação de FFT.",
                                  "tips": "Use funções pares/impares para otimizar o número de modos.",
                                  "learningObjective": "Compreender a formulação matemática de PVIs periódicos para métodos espectrais.",
                                  "commonMistakes": "Ignorar a periodicidade na condição inicial, levando a aliasing."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Diferenciação Espectral",
                                  "subSteps": [
                                    "Gere os wavenumbers k = [-N/2 : N/2-1] e multiplique pelo fator i*k para derivadas.",
                                    "Aplique a derivada espectral: multiplicar coeficientes de Fourier por i*k e IFFT de volta.",
                                    "Teste a derivada em uma função conhecida como sin(x) ou exp(sin(x)).",
                                    "Implemente derivadas de ordem superior compostas.",
                                    "Verifique precisão comparando com derivada finita de alta ordem."
                                  ],
                                  "verification": "Erro de derivada < 1e-10 para funções suaves teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código Python com FFT (numpy.fft), funções teste.",
                                  "tips": "Dealising com 3/2 rule: padding para N*3/2 antes de produto não-linear.",
                                  "learningObjective": "Dominar diferenciação espectral precisa para condições periódicas.",
                                  "commonMistakes": "Esquecimento do fator de normalização 1/N na IFFT."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar o Integrador Temporal Runge-Kutta",
                                  "subSteps": [
                                    "Escolha esquema RK4 ou RK45 adaptativo para semi-discretização método das linhas.",
                                    "Defina o operador semi-discreto: du/dt = D(u), onde D inclui diferenciação espectral.",
                                    "Implemente stages do RK: k1 = D(u), k2 = D(u + dt/2 k1), etc.",
                                    "Inclua tratamento de não-linearidades via FFT/IFFT a cada stage.",
                                    "Ajuste timestep dt baseado em CFL ou erro adaptativo."
                                  ],
                                  "verification": "Simule oscilador harmônico du/dt = -u, verifique preservação de energia.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Bibliotecas SciPy.integrate ou código custom RK.",
                                  "tips": "Vetorize operações para eficiência em N grande.",
                                  "learningObjective": "Integrar temporalmente sistemas espectrais com alta ordem.",
                                  "commonMistakes": "Não transformar de volta para espaço físico antes de plotar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Simulação e Validar Resultados",
                                  "subSteps": [
                                    "Rode simulação para tempo T final, salvando snapshots.",
                                    "Calcule normas L2 erro vs solução exata se disponível.",
                                    "Analise convergência espectral: erro ~ exp(-N).",
                                    "Visualize com plots de u(x,t) em slices temporais.",
                                    "Teste estabilidade variando dt e N."
                                  ],
                                  "verification": "Convergência observada e ausência de blow-up numérico.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Matplotlib para visualização, solução analítica referência.",
                                  "tips": "Monitore energia ou Hamiltoniano para simulações conservativas.",
                                  "learningObjective": "Validar implementação completa de PVI periódico pseudoespectral.",
                                  "commonMistakes": "Sobresampling insuficiente causando aliasing em não-lineares."
                                }
                              ],
                              "practicalExample": "Resolva numericamente a equação de Burgers periódica ∂u/∂t + u ∂u/∂x = ν ∂²u/∂x² com u(x,0)=sin(x), ν=0.01, em [0,2π], usando N=128, RK4 com dt=0.001, validando contra solução de referência de alta resolução.",
                              "finalVerifications": [
                                "Solução permanece periódica ao longo do tempo.",
                                "Erro L2 < 1e-8 em testes lineares.",
                                "Convergência exponencial com N.",
                                "Estabilidade para dt até limite CFL.",
                                "Preservação qualitativa de estruturas como shocks em Burgers.",
                                "Eficiência computacional: O(N log N) por timestep."
                              ],
                              "assessmentCriteria": [
                                "Precisão da diferenciação espectral em funções teste.",
                                "Correta implementação de stages RK sem erros de fase.",
                                "Tratamento adequado de aliasing em termos não-lineares.",
                                "Análise de convergência e estabilidade documentada.",
                                "Código limpo, vetorizado e reproduzível.",
                                "Interpretação física dos resultados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de ondas e fluidos periódicos (equação de onda, KdV).",
                                "Computação Científica: Otimização de FFT em HPC e GPU.",
                                "Engenharia: Modelagem de fluxos periódicos em aerodinâmica.",
                                "Física Computacional: Métodos para PDEs em domínios periódicos."
                              ],
                              "realWorldApplication": "Simulações de turbulência homogênea em fluidodinâmica computacional (DNS), propagação de ondas em materiais periódicos, previsão numérica de clima em domínios toroidais, e otimização de estruturas fotônicas com periodicidade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.2",
                        "name": "Limitações dos Métodos Pseudoespectrais em Problemas Não-Periódicos",
                        "description": "Em problemas com condições de contorno não-periódicas, os métodos de Fourier introduzem artefatos como o fenômeno de Gibbs, aliasing espectral e instabilidade devido à falta de periodicidade, limitando a convergência e exigindo adaptações como mapeamentos ou polinômios de Chebyshev.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.2.1",
                            "name": "Reconhecer limitações em condições não-periódicas",
                            "description": "Identificar falhas como oscilações espúrias (Gibbs) e aliasing em aproximações de Fourier para funções com descontinuidades ou condições Dirichlet/Neumann não-periódicas em intervalos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Básicos das Séries de Fourier e Periodicidade",
                                  "subSteps": [
                                    "Revisar a definição matemática de séries de Fourier para funções periódicas em todo o domínio real.",
                                    "Explicar a suposição implícita de extensão periódica ao aproximar funções em intervalos finitos.",
                                    "Discutir como condições de contorno periódicas são assumidas nos métodos pseudoespectrais.",
                                    "Visualizar a extensão periódica de uma função suave versus uma com descontinuidade.",
                                    "Comparar convergência rápida para funções periódicas suaves."
                                  ],
                                  "verification": "Resumir em 3-5 frases os pressupostos de periodicidade e desenhar um exemplo de extensão periódica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre séries de Fourier",
                                    "Papel e lápis para esboços",
                                    "Software como Python com Matplotlib"
                                  ],
                                  "tips": "Sempre imagine a função repetida infinitamente para visualizar artefatos nas junções.",
                                  "learningObjective": "Entender a fundação teórica que torna os métodos pseudoespectrais eficientes apenas para problemas periódicos.",
                                  "commonMistakes": "Confundir séries de Fourier com transformadas de Fourier contínuas ou ignorar a extensão periódica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Condições Não-Periódicas e Seus Impactos Iniciais",
                                  "subSteps": [
                                    "Definir condições de contorno Dirichlet (valor fixo) e Neumann (derivada fixa) em intervalos finitos como [-L, L].",
                                    "Exemplificar funções com descontinuidades ou incompatibilidades nas bordas, como f(-L) ≠ f(L).",
                                    "Demonstrar como a extensão periódica força f(-L) = f(L), criando descontinuidades artificiais.",
                                    "Analisar o efeito em aproximações de Fourier: introdução de alta frequência não-física.",
                                    "Plotar uma função não-periódica e sua extensão periódica para observação visual."
                                  ],
                                  "verification": "Desenhar e rotular a extensão periódica de uma função com condição Dirichlet não-compatível, destacando descontinuidades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software numérico (Python/NumPy/Matplotlib ou MATLAB)",
                                    "Exemplos de funções de referência"
                                  ],
                                  "tips": "Foque nas bordas do intervalo [-π, π]; use zoom nos plots para ver mismatches.",
                                  "learningObjective": "Reconhecer quando condições de contorno violam a periodicidade assumida, levando a falhas.",
                                  "commonMistakes": "Assumir que toda função em intervalo finito é periodicizável sem artefatos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Fenômenos Específicos: Oscilações de Gibbs e Aliasing",
                                  "subSteps": [
                                    "Explicar o fenômeno de Gibbs: overshoots e oscilações persistentes perto de descontinuidades, ~9% do salto.",
                                    "Demonstrar aliasing: vazamento de energia de alta frequência para baixa devido à discretização periódica.",
                                    "Implementar aproximações de Fourier com N=10, 50, 100 modos e plotar erros.",
                                    "Comparar comportamentos em funções com descontinuidades versus suaves.",
                                    "Quantificar Gibbs medindo amplitude máxima do overshoot em plots."
                                  ],
                                  "verification": "Gerar plots de séries parciais de Fourier para uma função com descontinuidade e identificar Gibbs/aliasing por localização e persistência.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Script Python/MATLAB para séries de Fourier",
                                    "Função teste como step ou abs(x) em [-π, π]"
                                  ],
                                  "tips": "Aumente gradualmente o número de termos para observar convergência lenta e não-uniforme.",
                                  "learningObjective": "Diferenciar e diagnosticar oscilações espúrias de Gibbs versus aliasing em aproximações.",
                                  "commonMistakes": "Confundir Gibbs (analítico, perto de salto) com aliasing (discreto, global) ou esperar convergência uniforme."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Reconhecimento de Limitações em Problemas Pseudoespectrais",
                                  "subSteps": [
                                    "Selecionar um problema com condições Dirichlet/Neumann não-periódicas, como equação de onda em domínio finito.",
                                    "Implementar método pseudoespectral e analisar solução numérica para falhas.",
                                    "Listar limitações observadas: Gibbs em descontinuidades, aliasing em derivadas.",
                                    "Discutir alternativas qualitativas como mapeamentos para domínio periódico ou métodos espectrais não-Fourier.",
                                    "Avaliar impacto em precisão global e estabilidade."
                                  ],
                                  "verification": "Analisar um exemplo dado, listar 3+ limitações específicas e propor pelo menos uma mitigação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código de exemplo pseudoespectral",
                                    "Problemas de exercício com condições de contorno variadas"
                                  ],
                                  "tips": "Teste sensibilidade variando condições de contorno para Dirichlet vs Neumann.",
                                  "learningObjective": "Diagnosticar limitações em contextos aplicados e considerar trade-offs.",
                                  "commonMistakes": "Subestimar impacto em derivadas (onde aliasing é pior) ou ignorar estabilidade numérica."
                                }
                              ],
                              "practicalExample": "Aproxime f(x) = |x| em [-π, π] com condições Dirichlet f(-π) = π, f(π) = π (compatível), mas a derivada tem salto. A extensão periódica introduz descontinuidade na derivada em x=±π, causando oscilações de Gibbs visíveis nos plots de Fourier parcial (overshoot ~9% do salto na derivada) e aliasing em modos altos, degradando precisão global.",
                              "finalVerifications": [
                                "Explicar corretamente a causa raiz de Gibbs em termos de extensão periódica.",
                                "Identificar aliasing em um plot de espectro de Fourier de função não-periódica.",
                                "Diferenciar impactos em condições Dirichlet versus Neumann não-compatíveis.",
                                "Analisar um gráfico de aproximação e quantificar overshoot de Gibbs.",
                                "Propor mapeamento ou método alternativo para mitigar limitações.",
                                "Descrever quando métodos pseudoespectrais falham em problemas reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da suposição de periodicidade e suas violações.",
                                "Identificação correta e diferenciada de Gibbs e aliasing com evidências visuais.",
                                "Uso apropriado de terminologia técnica (ex: overshoot, vazamento espectral).",
                                "Análise qualitativa/quantitativa de plots e convergência.",
                                "Capacidade de ligar limitações a condições de contorno específicas.",
                                "Sugestões de mitigação realistas e contextualizadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas em cavidades finitas com condições de contorno rígidas (Neumann).",
                                "Engenharia Mecânica: Simulações de vibrações em vigas com bordas fixas (Dirichlet não-periódico).",
                                "Processamento de Sinais: Artefatos em FFT de sinais truncados em tempo.",
                                "Ciência da Computação: Otimização numérica em solvers espectrais para PDEs.",
                                "Engenharia Elétrica: Modelagem de circuitos com respostas transitórias não-periódicas."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD) para escoamentos em canais finitos com paredes rígidas (condições no-slip, Neumann-like), métodos pseudoespectrais exibem Gibbs perto das paredes e aliasing em vórtices, levando a instabilidades; reconhecimento permite alternar para métodos de elementos finitos ou espectrais Chebyshev para precisão em aplicações aeroespaciais e automotivas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.2",
                            "name": "Explicar o fenômeno de Gibbs e aliasing",
                            "description": "Descrever matematicamente o overshoot de Gibbs em séries de Fourier truncadas e o aliasing causado por amostragem insuficiente em problemas não-periódicos, com exemplos numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos das séries de Fourier e truncamento",
                                  "subSteps": [
                                    "Revise a definição de séries de Fourier para funções periódicas: f(x) = a0/2 + Σ (an cos(nπx/L) + bn sin(nπx/L)).",
                                    "Estude a soma parcial SN(x) = soma de k=0 a N dos termos.",
                                    "Analise graficamente somas parciais para funções com descontinuidades, como a função degrau.",
                                    "Discuta a não-uniformidade da convergência de Fourier perto de descontinuidades.",
                                    "Implemente uma soma parcial simples em Python ou MATLAB."
                                  ],
                                  "verification": "Plotar SN(x) para N=5,10,20 e observar oscilações perto da descontinuidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Análise Numérica (ex: Burden & Faires)",
                                    "Python com NumPy/Matplotlib ou MATLAB"
                                  ],
                                  "tips": "Sempre normalize o intervalo para [-π, π] para facilitar cálculos.",
                                  "learningObjective": "Entender como o truncamento de séries de Fourier introduz artefatos de convergência.",
                                  "commonMistakes": "Ignorar a periodicidade forçada, confundindo com aproximações polinomiais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever matematicamente o fenômeno de Gibbs",
                                  "subSteps": [
                                    "Defina o overshoot de Gibbs: máximo local de |SN(x) - f(x)| ≈ 0.089 * jump/2 perto da descontinuidade.",
                                    "Derive a constante de Gibbs usando o integral de Dirichlet: (1/π) ∫0^π (sin t / t) dt ≈ 1.089.",
                                    "Calcule coeficientes an, bn para f(x) = sgn(x) em [-π, π].",
                                    "Mostre que o overshoot não diminui com N, mas oscila.",
                                    "Compare com o teorema de convergência de Fourier."
                                  ],
                                  "verification": "Calcular o overshoot para N=100 na função degrau e confirmar ≈8.9%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Caderno para derivações",
                                    "Software simbólico como SymPy"
                                  ],
                                  "tips": "Use a soma da série sen(t)/t para quantificar o overshoot rapidamente.",
                                  "learningObjective": "Dominar a formulação matemática do overshoot de Gibbs em séries truncadas.",
                                  "commonMistakes": "Confundir overshoot com erro de truncamento que diminui com N."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o aliasing causado por amostragem insuficiente",
                                  "subSteps": [
                                    "Revise o teorema de Nyquist-Shannon: frequência de amostragem fs > 2 fmax.",
                                    "Discuta aliasing em problemas não-periódicos: projeção de altas frequências em baixas.",
                                    "Modele matematicamente: se ω > π fs, então ω_alias = ω - 2π fs.",
                                    "Analise o espectro de Fourier discreto (DFT) e folding de frequências.",
                                    "Diferencie aliasing de Gibbs: aliasing é espectral, Gibbs é espacial."
                                  ],
                                  "verification": "Amostrar um sinal com fs < 2 fmax e plotar o espectro aliased.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Documentação FFT em SciPy",
                                    "Gerador de sinais em Python"
                                  ],
                                  "tips": "Teste com tons puros: sen(2π*50t) amostrado a 80Hz mostra alias em 30Hz.",
                                  "learningObjective": "Compreender o aliasing como consequência da amostragem sub-Nyquist.",
                                  "commonMistakes": "Aplicar Nyquist só a sinais periódicos, ignorando não-periódicos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Fornecer exemplos numéricos para ambos os fenômenos",
                                  "subSteps": [
                                    "Implemente Gibbs: aproxime f(x)=0 para x<0, 1 para x>0 com N=32 termos Fourier.",
                                    "Calcule e plote overshoot: meça max(SN - f).",
                                    "Implemente aliasing: amostre sen(2π*10t) + sen(2π*60t) a fs=80Hz.",
                                    "Compare espectros original vs amostrado.",
                                    "Discuta combinação em métodos pseudoespectrais: truncamento + DFT discreto."
                                  ],
                                  "verification": "Gerar plots com overshoot >8% e espectro aliased corretamente.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Bibliotecas NumPy, SciPy, Matplotlib"
                                  ],
                                  "tips": "Use padding zero para visualizar melhor o espectro.",
                                  "learningObjective": "Aplicar conceitos em simulações numéricas concretas.",
                                  "commonMistakes": "Escalas erradas nos plots, mascarando os fenômenos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar limitações em problemas não-periódicos",
                                  "subSteps": [
                                    "Explique por que métodos pseudoespectrais falham: condições de contorno não-periódicas causam Gibbs/aliasing.",
                                    "Compare com métodos de diferenças finitas ou elementos finitos.",
                                    "Discuta remédios: filtros low-pass, remapeamento periódico, windowing.",
                                    "Avalie trade-offs: precisão vs custo computacional.",
                                    "Resuma diferenças entre periódicos e não-periódicos."
                                  ],
                                  "verification": "Escrever um parágrafo explicando limitação em um problema de contorno Dirichlet.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigos sobre pseudoespectrais (ex: Canuto et al.)"
                                  ],
                                  "tips": "Pense em domínio periódico estendido para mitigar.",
                                  "learningObjective": "Identificar quando evitar pseudoespectrais em não-periódicos.",
                                  "commonMistakes": "Subestimar impacto em simulações físicas reais."
                                }
                              ],
                              "practicalExample": "Em uma simulação de onda em uma corda com extremidades fixas (não-periódica), aplicar DFT truncado causa overshoot de Gibbs nas descontinuidades de tensão e aliasing nas altas frequências da solução, distorcendo a propagação da onda. Implemente em Python: resolva equação da onda via pseudoespectral e compare com solução exata.",
                              "finalVerifications": [
                                "Explicar verbalmente Gibbs e aliasing em 2 minutos.",
                                "Calcular overshoot para N=20 na função degrau (erro <1%).",
                                "Gerar plot de aliasing com fs=100Hz para sinal 60Hz.",
                                "Identificar 3 causas de aliasing em pseudoespectrais.",
                                "Propor solução para problema não-periódico.",
                                "Comparar erros L2 com/ sem fenômenos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das fórmulas de Gibbs e Nyquist (90% correto).",
                                "Qualidade dos plots numéricos (legendas, escalas adequadas).",
                                "Correta distinção entre Gibbs (espacial) e aliasing (frequencial).",
                                "Exemplos numéricos reproduzíveis e quantificados.",
                                "Análise de limitações contextualizadas em pseudoespectrais.",
                                "Clareza na explicação oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de ondas e vibrações (equação de onda).",
                                "Engenharia de Sinais: Processamento digital de áudio/imagens.",
                                "Computação Científica: FFT em simulações CFD.",
                                "Estatística: Análise espectral de séries temporais."
                              ],
                              "realWorldApplication": "Em processamento de imagens médicas (MRI), Gibbs causa halos em bordas de tecidos, e aliasing em scanners subamostrados distorce diagnósticos; mitigações melhoram precisão em simulações climáticas e design de antenas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.3",
                            "name": "Analisar estabilidade e precisão em não-periódicos",
                            "description": "Avaliar a perda de precisão exponencial e instabilidades em métodos pseudoespectrais de Fourier para problemas com condições de contorno rígidas, comparando com métodos de diferenças finitas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos teóricos dos métodos pseudoespectrais e diferenças finitas",
                                  "subSteps": [
                                    "Estudar a base de Fourier nos métodos pseudoespectrais e sua adequação a funções periódicas.",
                                    "Analisar como condições de contorno rígidas (Dirichlet ou Neumann) introduzem Gibbs phenomenon e perda de precisão exponencial.",
                                    "Revisar a formulação de diferenças finitas centradas e sua estabilidade via análise de von Neumann.",
                                    "Comparar espectralmente a truncagem de séries de Fourier vs. erro de ordem em diferenças finitas.",
                                    "Derivar matematicamente a taxa de convergência esperada para cada método em domínios não-periódicos."
                                  ],
                                  "verification": "Resumir em um diagrama as diferenças chave entre os métodos e listar 3 limitações específicas dos pseudoespectrais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de análise numérica (ex: Trefethen 'Spectral Methods'), notas de aula, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Use expansões de Fourier truncadas manualmente para visualizar o ringing perto das bordas.",
                                  "learningObjective": "Compreender teoricamente por que métodos pseudoespectrais perdem precisão em problemas não-periódicos.",
                                  "commonMistakes": "Confundir instabilidade numérica com erro de truncagem; ignorar o papel das condições de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e implementar um problema teste não-periódico",
                                  "subSteps": [
                                    "Escolher a equação modelo: equação de Poisson -u_xx - u_yy = f em [0,1]x[0,1] com u=0 nas bordas (Dirichlet homogêneo).",
                                    "Definir solução exata conhecida, ex: u(x,y) = sin(πx)sin(πy), e computar f correspondente.",
                                    "Discretizar o domínio com malha NxN pontos, usando transformadas de Fourier rápidas (FFT).",
                                    "Implementar tratamento de contorno rígido via penalização ou relaxação para pseudoespectral.",
                                    "Preparar código base em Python para ambos os métodos."
                                  ],
                                  "verification": "Executar código para gerar malha e solução inicial; plotar domínio e condições de contorno.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com NumPy, SciPy (fft), Matplotlib; Jupyter Notebook.",
                                  "tips": "Comece com N=32 para testes rápidos antes de refinar.",
                                  "learningObjective": "Preparar um benchmark reprodutível para comparação de precisão e estabilidade.",
                                  "commonMistakes": "Escolher solução periódica acidentalmente; mal definir f levando a inconsistências."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular e analisar método pseudoespectral para detecção de instabilidades",
                                  "subSteps": [
                                    "Aplicar FFT 2D para derivadas espectrais no interior do domínio.",
                                    "Impor condições de contorno via multiplicação por máscara ou filtro de alta frequência.",
                                    "Executar para malhas crescentes (N=32,64,128,256) e computar norma L2 do erro vs. solução exata.",
                                    "Plotar curvas de erro: observar perda exponencial de precisão (erro ~ 10^{-k} para k pequeno).",
                                    "Identificar oscilações (Gibbs) e instabilidades em modos altos perto das bordas."
                                  ],
                                  "verification": "Gerar gráficos de erro log-lin mostrando platô exponencial; anotar fatores de perda de precisão.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Código Python do passo anterior; ferramentas de plotagem avançada (Matplotlib/Seaborn).",
                                  "tips": "Use ifftshift para alinhar modos; monitore tempo de computação para eficiência espectral.",
                                  "learningObjective": "Quantificar empiricamente a degradação de precisão em não-periódicos.",
                                  "commonMistakes": "Não filtrar modos aliasing; confundir erro de arredondamento com perda espectral."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar método de diferenças finitas e comparar resultados",
                                  "subSteps": [
                                    "Discretizar Laplace operator com stencil de 5 pontos (ordem 2).",
                                    "Resolver sistema linear via solver iterativo (ex: GMRES ou multigrid).",
                                    "Computar erros L2 para mesmas malhas NxN.",
                                    "Plotar curvas de convergência: erro ~ O(h^2) com h=1/N.",
                                    "Comparar estabilidade: analisar eigenvalues do operador discretizado."
                                  ],
                                  "verification": "Tabela comparativa de erros e tempos para N=32-256; gráficos lado a lado.",
                                  "estimatedTime": "2 horas",
                                  "materials": "SciPy.sparse para matrizes; SciPy.linalg para solvers.",
                                  "tips": "Use preconditioners para aceleração em malhas finas.",
                                  "learningObjective": "Demonstrar superioridade de diferenças finitas em estabilidade para contornos rígidos.",
                                  "commonMistakes": "Stencil assimétrico nas bordas; não normalizar erros adequadamente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar análise comparativa e recomendações",
                                  "subSteps": [
                                    "Calcular razões de erro (pseudoespectral / diferenças finitas) vs. N.",
                                    "Discutir trade-offs: precisão espectral em periódicos vs. robustez em não-periódicos.",
                                    "Propor melhorias: chebyshev polynomials ou domain decomposition para pseudoespectrais.",
                                    "Documentar relatório com plots, tabelas e conclusões.",
                                    "Testar sensibilidade a diferentes condições de contorno (Neumann)."
                                  ],
                                  "verification": "Relatório de 2-3 páginas com evidências quantitativas e qualitativas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "LaTeX ou Markdown para relatório; todos os códigos e plots gerados.",
                                  "tips": "Use logscales em plots para destacar diferenças exponenciais.",
                                  "learningObjective": "Formular recomendações baseadas em análise crítica.",
                                  "commonMistakes": "Ignorar custo computacional; generalizar excessivamente de um exemplo."
                                }
                              ],
                              "practicalExample": "Resolva numericamente a equação de Poisson -Δu = π² sin(πx)sin(πy) em [0,1]² com u=0 nas bordas. Compare erros L2 e tempo de CPU para N=128 usando pseudoespectral de Fourier (com máscara de contorno) vs. diferenças finitas de 2ª ordem, observando como o erro pseudoespectral satura em ~10^{-3} enquanto o de diferenças cai como O(1/N²).",
                              "finalVerifications": [
                                "Identificar corretamente a perda de precisão exponencial devido a Gibbs phenomenon.",
                                "Plotar curvas de erro mostrando platô para pseudoespectral e convergência polinomial para diferenças finitas.",
                                "Explicar matematicamente a origem da instabilidade em termos de modos de Fourier não-ortogonais às bordas.",
                                "Comparar tempos de execução e recomendar método baseado em contexto.",
                                "Testar com condição Neumann e confirmar padrões similares.",
                                "Documentar pelo menos 3 mitigações potenciais para pseudoespectrais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação teórica das limitações (30%)",
                                "Qualidade e correção dos códigos de simulação (25%)",
                                "Análise quantitativa de erros e estabilidade (20%)",
                                "Clareza de plots e tabelas comparativas (15%)",
                                "Profundidade da discussão e recomendações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Simulações de campos eletromagnéticos com contornos irregulares.",
                                "Engenharia Mecânica: Análise de fluxo em domínios com paredes rígidas (CFD).",
                                "Ciência da Computação: Otimização de algoritmos paralelizáveis (FFT vs. solvers esparsos).",
                                "Estatística: Análise de erro em métodos de suavização espectral de dados."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de fluidos computacional (CFD) para aerodinâmica de aviões, onde condições de contorno no solo ou asas são rígidas e não-periódicas, métodos de diferenças finitas são preferidos sobre pseudoespectrais para evitar instabilidades que poderiam invalidar previsões de turbulência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.4",
                            "name": "Discutir alternativas para condições não-periódicas",
                            "description": "Introduzir métodos pseudoespectrais baseados em polinômios de Chebyshev ou Legendre para domínios não-periódicos, destacando mapeamentos para condições de contorno e sua implementação básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as limitações dos métodos pseudoespectrais em domínios não-periódicos",
                                  "subSteps": [
                                    "Revisar os métodos pseudoespectrais baseados em Fourier, que assumem periodicidade.",
                                    "Identificar problemas como Gibbs phenomenon em condições de contorno Dirichlet ou Neumann.",
                                    "Analisar exemplos numéricos simples de falhas em domínios finitos.",
                                    "Discutir a necessidade de bases ortogonais não-periódicas.",
                                    "Comparar precisão em problemas periódicos vs. não-periódicos."
                                  ],
                                  "verification": "Resumir em um parágrafo as principais limitações e fornecer um exemplo gráfico de Gibbs phenomenon.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise numérica (ex: Trefethen 'Spectral Methods'), software MATLAB/Python para plots.",
                                  "tips": "Use visualizações gráficas para destacar oscilações perto das bordas.",
                                  "learningObjective": "Compreender por que métodos de Fourier falham em domínios não-periódicos.",
                                  "commonMistakes": "Confundir periodicidade com condições de contorno; ignorar o impacto na convergência exponencial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir polinômios de Chebyshev e Legendre como bases alternativas",
                                  "subSteps": [
                                    "Definir polinômios de Chebyshev (1º e 2º tipo) e Legendre ortogonalmente no [-1,1].",
                                    "Explicar propriedades de ortogonalidade e recursão para avaliação eficiente.",
                                    "Comparar pesos de integração: 1/sqrt(1-x²) para Chebyshev vs. 1 para Legendre.",
                                    "Implementar expansão de uma função teste em série de Chebyshev.",
                                    "Discutir convergência espectral para funções suaves."
                                  ],
                                  "verification": "Implementar e plotar aproximação de uma função suave usando 10-20 modos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Cheatsheet de recursões polinomiais, Jupyter Notebook com NumPy/SciPy.",
                                  "tips": "Use o mapeamento x = cos(θ) para Chebyshev para facilitar computações.",
                                  "learningObjective": "Dominar as bases matemáticas de polinômios não-periódicos.",
                                  "commonMistakes": "Esquecer normalização; confundir tipos de Chebyshev."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar mapeamentos para condições de contorno em domínios físicos",
                                  "subSteps": [
                                    "Mapear domínio físico [a,b] para [-1,1] via transformação linear/afim.",
                                    "Adaptar derivadas diferenciais usando chain rule no domínio computacional.",
                                    "Incorporar condições de contorno (Dirichlet/Neumann) nos coeficientes espectrais.",
                                    "Testar em um problema modelo como equação de Poisson 1D.",
                                    "Analisar estabilidade e precisão do mapeamento."
                                  ],
                                  "verification": "Resolver numericamente Poisson com BCs e comparar com solução exata (erro <1e-6).",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código base em Python (pseudospectral toolbox), papel para derivar chain rule.",
                                  "tips": "Verifique Jacobiano do mapeamento para evitar erros em derivadas.",
                                  "learningObjective": "Aplicar mapeamentos para lidar com geometrias reais.",
                                  "commonMistakes": "Ignorar fatores de escala no mapeamento; erros em BCs mistas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar método pseudoespectral básico com Chebyshev",
                                  "subSteps": [
                                    "Codificar diferenciação espectral via matriz de Chebyshev (Trefethen Alg. 68).",
                                    "Resolver um problema evolutivo simples (ex: onda 1D com BCs).",
                                    "Otimizar via FFT para multiplicações (DCT para Chebyshev).",
                                    "Validar contra métodos finitos diferenças.",
                                    "Discutir extensões para 2D/3D."
                                  ],
                                  "verification": "Executar simulação e plotar solução em t=0, t_final com erro L2 <1e-4.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Dedalus ou SpectralDNS library, laptop com Python.",
                                  "tips": "Use pontos de Gauss-Lobatto para colocation eficiente.",
                                  "learningObjective": "Implementar e testar um solver pseudoespectral completo.",
                                  "commonMistakes": "Aliasing em produtos não-lineares; boundary clustering insuficiente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Discutir vantagens, desvantagens e alternativas",
                                  "subSteps": [
                                    "Comparar Chebyshev vs. Legendre em precisão e custo computacional.",
                                    "Mencionar métodos híbridos (ex: Fourier-Chebyshev).",
                                    "Abordar limitações como rigidez em altos Reynolds.",
                                    "Explorar bibliotecas (Chebfun, Dedalus).",
                                    "Propor aplicações futuras."
                                  ],
                                  "verification": "Escrever relatório de 1 página comparando métodos em um benchmark.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos de Trefethen, benchmarks pré-computados.",
                                  "tips": "Foque em métricas: custo por grau de liberdade e ordem de precisão.",
                                  "learningObjective": "Avaliar criticamente alternativas para problemas reais.",
                                  "commonMistakes": "Superestimar convergência sem testar singularidades."
                                }
                              ],
                              "practicalExample": "Resolva numericamente a equação de calor ∂u/∂t = ∂²u/∂x² em [0,1] com u(0,t)=u(1,t)=0 e u(x,0)=sin(πx), usando pseudoespectral Chebyshev. Compare com solução exata u(x,t)=sin(πx)exp(-π²t) em t=0.5, alcançando erro <1e-8 com N=32 pontos.",
                              "finalVerifications": [
                                "Implementar e rodar código para problema modelo com BCs não-periódicas.",
                                "Plotar convergência log-log vs. N, mostrando taxa espectral.",
                                "Explicar verbalmente mapeamento e diferenciação em sala.",
                                "Comparar resultados com método FD de 4ª ordem.",
                                "Identificar e corrigir um erro comum em BCs.",
                                "Discutir limitação em um caso com singularidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da explicação teórica (ortogonalidade, mapeamentos).",
                                "Corretude da implementação numérica (erro <1e-6).",
                                "Profundidade da discussão de prós/contras vs. Fourier.",
                                "Qualidade de visualizações e análises de convergência.",
                                "Criatividade em extensão para problema próprio.",
                                "Clareza na comunicação oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Física: Simulações de fluidos (Navier-Stokes com BCs no-slip).",
                                "Engenharia: Otimização estrutural via métodos espectrais.",
                                "Computação: Algoritmos paralelos em HPC para solves espectrais.",
                                "Estatística: Análise de séries temporais não-estacionárias."
                              ],
                              "realWorldApplication": "Em simulações climáticas, métodos Chebyshev modelam circulação oceânica em domínios costeiros com BCs irregulares, permitindo previsões precisas de correntes com custo computacional reduzido em supercomputadores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 337
          }
        ],
        "totalSkills": 337
      }
    ]
  }
}